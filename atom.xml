<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ISJINHAO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://isjinhao.github.io/"/>
  <updated>2019-04-04T03:05:48.340Z</updated>
  <id>https://isjinhao.github.io/</id>
  
  <author>
    <name>ISJINHAO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Dbutils</title>
    <link href="https://isjinhao.github.io/2019/Dbutils/"/>
    <id>https://isjinhao.github.io/2019/Dbutils/</id>
    <published>2019-04-04T02:59:40.000Z</published>
    <updated>2019-04-04T03:05:48.340Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Commons DbUtils是Apache组织提供的一个对JDBC进行简单封装的开源工具类库，使用它能够简化JDBC应用程序的开发，同时也不会影响程序的性能。最大的好处是它能帮我们自动封装结果集。下面使用C3P0作为数据库连接池。</p><h2 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"></span><br><span class="line">import com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        //1、指定数据库连接池</span><br><span class="line">        ComboPooledDataSource dataSource = new ComboPooledDataSource();</span><br><span class="line"></span><br><span class="line">        //2、增删改都使用update方法</span><br><span class="line">        QueryRunner qr = new QueryRunner(dataSource);</span><br><span class="line">        String insert = &quot;insert into students(id, name, clazz) values(?, ?, ?)&quot;;</span><br><span class="line">        qr.update(insert, &quot;123&quot;, &quot;123&quot;, &quot;123&quot;);</span><br><span class="line"></span><br><span class="line">        String update = &quot;update students set name = ? where id = ?&quot;;</span><br><span class="line">        qr.update(update, &quot;789&quot;, &quot;123&quot;);</span><br><span class="line"></span><br><span class="line">        String delete = &quot;delete from students where id = ?&quot;;</span><br><span class="line">        qr.update(delete, &quot;123&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><h3 id="自定义封装-返回值类型是单个对象"><a href="#自定义封装-返回值类型是单个对象" class="headerlink" title="自定义封装-返回值类型是单个对象"></a>自定义封装-返回值类型是单个对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String query = <span class="string">"select * from students where id = ?"</span>;</span><br><span class="line"></span><br><span class="line">Student student = qr.query(query, <span class="keyword">new</span> ResultSetHandler&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            String id = rs.getString(<span class="string">"id"</span>);</span><br><span class="line">            String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">            String clazz = rs.getString(<span class="string">"clazz"</span>);</span><br><span class="line">            s.setId(id);</span><br><span class="line">            s.setName(name);</span><br><span class="line">            s.setClazz(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">"helloworld"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(student);</span><br></pre></td></tr></table></figure><h3 id="自定义封装-返回值类型是集合"><a href="#自定义封装-返回值类型是集合" class="headerlink" title="自定义封装-返回值类型是集合"></a>自定义封装-返回值类型是集合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String query = <span class="string">"select * from students"</span>;</span><br><span class="line">List&lt;Student&gt; list = qr.query(query, <span class="keyword">new</span> ResultSetHandler&lt;List&lt;Student&gt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        List&lt;Student&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            s.setId(rs.getString(<span class="string">"id"</span>));</span><br><span class="line">            s.setName(rs.getString(<span class="string">"name"</span>));</span><br><span class="line">            s.setClazz(rs.getString(<span class="string">"clazz"</span>));</span><br><span class="line">            l.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h3 id="快速封装-返回值类型是单个对象"><a href="#快速封装-返回值类型是单个对象" class="headerlink" title="快速封装-返回值类型是单个对象"></a>快速封装-返回值类型是单个对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String query = <span class="string">"select * from students where id = ?"</span>;</span><br><span class="line">Student q = qr.query(query, <span class="keyword">new</span> BeanHandler&lt;&gt;(Student.class), <span class="string">"helloworld"</span>);</span><br><span class="line">System.out.println(q);</span><br><span class="line"><span class="comment">/**Console:</span></span><br><span class="line"><span class="comment">*   Student [id=helloworld, name=qwe, clazz=160341B]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="快速封装-返回值类型是多个对象"><a href="#快速封装-返回值类型是多个对象" class="headerlink" title="快速封装-返回值类型是多个对象"></a>快速封装-返回值类型是多个对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String query = <span class="string">"select * from students"</span>;</span><br><span class="line">List&lt;Student&gt; l = qr.query(query, <span class="keyword">new</span> BeanListHandler&lt;&gt;(Student.class));</span><br><span class="line">System.out.println(l);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [Student [id=160341240, name=qwe, clazz=160341B], </span></span><br><span class="line"><span class="comment"> *      Student [id=160341244, name=qwe, clazz=160341B], </span></span><br><span class="line"><span class="comment"> *          Student [id=aaa, name=詹金浩, clazz=160341B], </span></span><br><span class="line"><span class="comment"> *              Student [id=helloworld, name=qwe, clazz=160341B]]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Commo
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JDBC" scheme="https://isjinhao.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>数据库连接池</title>
    <link href="https://isjinhao.github.io/2019/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>https://isjinhao.github.io/2019/数据库连接池/</id>
    <published>2019-04-04T02:32:20.000Z</published>
    <updated>2019-04-04T03:08:54.528Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="楔子"><a href="#楔子" class="headerlink" title="楔子"></a>楔子</h2><h3 id="之前的不足"><a href="#之前的不足" class="headerlink" title="之前的不足"></a>之前的不足</h3><p>程序和数据库之间建立连接的过程是比较耗时的，而且每次建立连接之后还需要释放资源，频繁的建立和释放是会造成很大的时间消耗。</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>在程序中始终维护多个和数据库的的连接，这些连接在程序启动的时候就建立，直到程序结束才释放。每次需要和数据库建立连接时，之际从连接池中获取连接即可。如图：</p><div align="center"><img src="/2019/数据库连接池/连接池示意图.png" style="width:80%"></div><h2 id="自定义数据库连接池"><a href="#自定义数据库连接池" class="headerlink" title="自定义数据库连接池"></a>自定义数据库连接池</h2><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>数据库连接池的概念本来就是sun公司提出来的额，所以sun公司针对数据库连接池也提供了一套规范，一个简单的数据库连接池如下，只有获取连接和归还连接的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLFeatureNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List &lt;Connection&gt; list = <span class="keyword">new</span> ArrayList&lt;Connection&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">MyDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Connection conn = JDBCUtil.getConn();</span><br><span class="line">            list.add(conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  该连接池对外公布的获取连接的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//来拿连接的时候，先看看，池子里面还有没有。</span></span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                Connection conn = JDBCUtil.getConn();</span><br><span class="line">                list.add(conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//remove(0) ---&gt; 移除第一个。 移除的是集合中的第一个。  移除的是开始的那个元素</span></span><br><span class="line">        Connection conn = list.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用完之后，记得归还。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBack</span><span class="params">(Connection conn)</span></span>&#123;</span><br><span class="line">        list.add(conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PrintWriter <span class="title">getLogWriter</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLogWriter</span><span class="params">(PrintWriter out)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoginTimeout</span><span class="params">(<span class="keyword">int</span> seconds)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLoginTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Logger <span class="title">getParentLogger</span><span class="params">()</span> <span class="keyword">throws</span> SQLFeatureNotSupportedException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">unwrap</span><span class="params">(Class&lt;T&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWrapperFor</span><span class="params">(Class&lt;?&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-amp-解决"><a href="#问题-amp-解决" class="headerlink" title="问题 &amp; 解决"></a>问题 &amp; 解决</h3><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>AddBack()：这个方法不是接口中的方法，不能使用面向接口的编程。</li><li>连接池不是单例：在一个程序中，连接池应该只存在一个，每new一个都会产生一个连接池和n个连接。</li><li>扩容：当连接数大于我们设置的数量时需要对连接池中的连接扩容，否则就会产生问题。</li></ol><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ol><li>使用装饰者模式；</li><li>把连接池设为单例；</li><li>连接池空时自动增加机制。</li></ol><h3 id="改进的数据库连接池"><a href="#改进的数据库连接池" class="headerlink" title="改进的数据库连接池"></a>改进的数据库连接池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLFeatureNotSupportedException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyDataSource</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyDataSource mds = <span class="keyword">new</span> MyDataSource();</span><br><span class="line">    <span class="keyword">static</span> List &lt;Connection&gt; list = <span class="keyword">new</span> ArrayList&lt;Connection&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Connection conn = JDBCUtil.getConn();</span><br><span class="line">            list.add(conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyDataSource <span class="title">getMyDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  该连接池对外公布的获取连接的方法，扩容</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//来拿连接的时候，先看看，池子里面还有没有。</span></span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                Connection conn = JDBCUtil.getConn();</span><br><span class="line">                list.add(conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Connection conn = list.remove(<span class="number">0</span>);</span><br><span class="line">        Connection connection = <span class="keyword">new</span> ConnectionWrap(conn, list);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用完之后，记得归还。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBack</span><span class="params">(Connection conn)</span></span>&#123;</span><br><span class="line">        list.add(conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PrintWriter <span class="title">getLogWriter</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLogWriter</span><span class="params">(PrintWriter out)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLoginTimeout</span><span class="params">(<span class="keyword">int</span> seconds)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLoginTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Logger <span class="title">getParentLogger</span><span class="params">()</span> <span class="keyword">throws</span> SQLFeatureNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">unwrap</span><span class="params">(Class&lt;T&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWrapperFor</span><span class="params">(Class&lt;?&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Array;</span><br><span class="line"><span class="keyword">import</span> java.sql.Blob;</span><br><span class="line"><span class="keyword">import</span> java.sql.CallableStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.Clob;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DatabaseMetaData;</span><br><span class="line"><span class="keyword">import</span> java.sql.NClob;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLClientInfoException;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLWarning;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLXML;</span><br><span class="line"><span class="keyword">import</span> java.sql.Savepoint;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.sql.Struct;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionWrap</span>  <span class="keyword">implements</span> <span class="title">Connection</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> List &lt;Connection&gt; list ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionWrap</span><span class="params">(Connection connection , List &lt;Connection&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.connection = connection;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        list.add(connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//====================================================================</span></span><br><span class="line">    <span class="comment">//之后的方法没有被装饰，需要使用时再装饰</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">unwrap</span><span class="params">(Class&lt;T&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isWrapperFor</span><span class="params">(Class&lt;?&gt; iface)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Statement <span class="title">createStatement</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CallableStatement <span class="title">prepareCall</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">nativeSQL</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAutoCommit</span><span class="params">(<span class="keyword">boolean</span> autoCommit)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">getAutoCommit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClosed</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DatabaseMetaData <span class="title">getMetaData</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReadOnly</span><span class="params">(<span class="keyword">boolean</span> readOnly)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCatalog</span><span class="params">(String catalog)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCatalog</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionIsolation</span><span class="params">(<span class="keyword">int</span> level)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTransactionIsolation</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SQLWarning <span class="title">getWarnings</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearWarnings</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Statement <span class="title">createStatement</span><span class="params">(<span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql, <span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CallableStatement <span class="title">prepareCall</span><span class="params">(String sql, <span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Class&lt;?&gt;&gt; getTypeMap() <span class="keyword">throws</span> SQLException &#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTypeMap</span><span class="params">(Map&lt;String, Class&lt;?&gt;&gt; map)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setHoldability</span><span class="params">(<span class="keyword">int</span> holdability)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHoldability</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Savepoint <span class="title">setSavepoint</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Savepoint <span class="title">setSavepoint</span><span class="params">(String name)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">(Savepoint savepoint)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">releaseSavepoint</span><span class="params">(Savepoint savepoint)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Statement <span class="title">createStatement</span><span class="params">(<span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency, <span class="keyword">int</span> resultSetHoldability)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql, <span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> resultSetHoldability)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CallableStatement <span class="title">prepareCall</span><span class="params">(String sql, <span class="keyword">int</span> resultSetType, <span class="keyword">int</span> resultSetConcurrency,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> resultSetHoldability)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql, <span class="keyword">int</span> autoGeneratedKeys)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql, <span class="keyword">int</span>[] columnIndexes)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql, String[] columnNames)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Clob <span class="title">createClob</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Blob <span class="title">createBlob</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NClob <span class="title">createNClob</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SQLXML <span class="title">createSQLXML</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClientInfo</span><span class="params">(String name, String value)</span> <span class="keyword">throws</span> SQLClientInfoException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClientInfo</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> SQLClientInfoException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getClientInfo</span><span class="params">(String name)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Properties <span class="title">getClientInfo</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Array <span class="title">createArrayOf</span><span class="params">(String typeName, Object[] elements)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Struct <span class="title">createStruct</span><span class="params">(String typeName, Object[] attributes)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSchema</span><span class="params">(String schema)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSchema</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abort</span><span class="params">(Executor executor)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNetworkTimeout</span><span class="params">(Executor executor, <span class="keyword">int</span> milliseconds)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNetworkTimeout</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="开源数据库连接池"><a href="#开源数据库连接池" class="headerlink" title="开源数据库连接池"></a>开源数据库连接池</h2><h3 id="DBCP"><a href="#DBCP" class="headerlink" title="DBCP"></a>DBCP</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#连接设置</span><br><span class="line">driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost:3306/jdbc-study</span><br><span class="line">username=root</span><br><span class="line">password=root</span><br><span class="line"></span><br><span class="line">#&lt;!-- 初始化连接 --&gt;</span><br><span class="line">initialSize=10</span><br><span class="line"></span><br><span class="line">#最大连接数量</span><br><span class="line">maxActive=50</span><br><span class="line"></span><br><span class="line">#&lt;!-- 最大空闲连接 --&gt;</span><br><span class="line">maxIdle=20</span><br><span class="line"></span><br><span class="line">#&lt;!-- 最小空闲连接 --&gt;</span><br><span class="line">minIdle=5</span><br><span class="line"></span><br><span class="line">#&lt;!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --&gt;</span><br><span class="line">maxWait=60000</span><br><span class="line"></span><br><span class="line">#JDBC驱动建立连接时附带的连接属性属性的格式必须为这样：[属性名=property;] </span><br><span class="line">#注意：&quot;user&quot; 与 &quot;password&quot; 两个属性会被明确地传递，因此这里不需要包含他们。</span><br><span class="line">connectionProperties=useUnicode=true;characterEncoding=gbk</span><br><span class="line"></span><br><span class="line">#指定由连接池所创建的连接的自动提交（auto-commit）状态。</span><br><span class="line">defaultAutoCommit=true</span><br><span class="line"></span><br><span class="line">#driver default 指定由连接池所创建的连接的事务级别（TransactionIsolation）。</span><br><span class="line">#可用值为下列之一：（详情可见javadoc。）NONE,READ_UNCOMMITTED, READ_COMMITTED, REPEATABLE_READ, SERIALIZABLE</span><br><span class="line">defaultTransactionIsolation=READ_UNCOMMITTED</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbcp.BasicDataSourceFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、构建数据源</span></span><br><span class="line">            BasicDataSourceFactory bdsf = <span class="keyword">new</span> BasicDataSourceFactory();</span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            pro.load(<span class="keyword">new</span> FileInputStream(<span class="string">"src/dbcpconfig.properties"</span>));</span><br><span class="line">            DataSource ds = bdsf.createDataSource(pro);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2、得到连接对象</span></span><br><span class="line">            connection = ds.getConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3、执行sql语句</span></span><br><span class="line">            String sql = <span class="string">"select * from students"</span>;</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4、获得结果、处理结果</span></span><br><span class="line">            ResultSet query = ps.executeQuery();</span><br><span class="line">            <span class="keyword">while</span>(query.next()) &#123;</span><br><span class="line">                String id = query.getString(<span class="string">"id"</span>);</span><br><span class="line">                String name = query.getString(<span class="string">"name"</span>);</span><br><span class="line">                String clazz = query.getString(<span class="string">"clazz"</span>);</span><br><span class="line">                System.out.println(id + <span class="string">" "</span> + name + <span class="string">" "</span> + clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//直接关闭就行，dbcp帮我们包装好了</span></span><br><span class="line">            ps.close();</span><br><span class="line">            connection.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- default-config 默认的配置，  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql://localhost/jdbc-study<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdleTime"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span>&gt;</span>200<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- This app is massive! --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">"oracle"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- intergalactoApp adopts a different approach to configuring statement caching --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatementsPerConnection"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- he's important, but there's only one of him --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user-overrides</span> <span class="attr">user</span>=<span class="string">"master-of-the-universe"</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatementsPerConnection"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user-overrides</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、构建数据源</span></span><br><span class="line">            ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2、得到连接对象</span></span><br><span class="line">            connection = cpds.getConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3、执行sql语句</span></span><br><span class="line">            String sql = <span class="string">"select * from students"</span>;</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4、获得结果、处理结果</span></span><br><span class="line">            ResultSet query = ps.executeQuery();</span><br><span class="line">            <span class="keyword">while</span>(query.next()) &#123;</span><br><span class="line">                String id = query.getString(<span class="string">"id"</span>);</span><br><span class="line">                String name = query.getString(<span class="string">"name"</span>);</span><br><span class="line">                String clazz = query.getString(<span class="string">"clazz"</span>);</span><br><span class="line">                System.out.println(id + <span class="string">" "</span> + name + <span class="string">" "</span> + clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DBCP和C3P0的区别"><a href="#DBCP和C3P0的区别" class="headerlink" title="DBCP和C3P0的区别"></a>DBCP和C3P0的区别</h3><p><a href="http://www.cnblogs.com/JavaSubin/p/5294721.html" target="_blank" rel="noopener">http://www.cnblogs.com/JavaSubin/p/5294721.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;楔子&quot;&gt;&lt;a href=&quot;#楔子&quot; class=&quot;headerlink&quot; title=&quot;楔子&quot;&gt;&lt;/a&gt;楔子&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JDBC" scheme="https://isjinhao.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>JDBC入门</title>
    <link href="https://isjinhao.github.io/2019/JDBC%E5%85%A5%E9%97%A8/"/>
    <id>https://isjinhao.github.io/2019/JDBC入门/</id>
    <published>2019-04-03T15:08:23.000Z</published>
    <updated>2019-04-04T02:31:52.544Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="JDBC-入门"><a href="#JDBC-入门" class="headerlink" title="JDBC - 入门"></a>JDBC - 入门</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Java Database Connectivity，Java数据库连接。是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序，所以说，JDBC对Java程序员而言是API，对实现与数据库连接的服务提供商而言是接口模型。作为API，JDBC为程序开发提供标准的接口，并为数据库厂商及第三方中间件厂商实现与数据库的连接提供了标准方法。</p><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>数据库并不是Java提供的，所以在Java中如果想连接数据库，肯定需要使用第三方jar包，这些jar包是数据库厂商根据JDBC接口模型开发的自己数据库的连接包。文章里使用的数据库是mysql，所以使用mysql-connector。</p><h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><p>使用JDBC需要六步：注册驱动、建立连接、创建Statement、执行查询、获得结果集、处理结果集、释放资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection con = <span class="keyword">null</span>;</span><br><span class="line">        Statement statement = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet query = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1、注册驱动：在使用JDBC连接连接数据库的时候，Java程序并不知道自己是否连接上了相应的</span></span><br><span class="line"><span class="comment">             *             数据库，所以在第一步需要注册驱动，如果连接正常则可以进行接下来的操作。也</span></span><br><span class="line"><span class="comment">             *             就是说注册驱动这一步是通过我们导入的jar包测试能否正常连接数据库。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">    </span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2、获得连接：数据库服务器中可能存在多个数据库，我们需要连接上我们即将使用的数据库。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            con = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost/jdbc-study"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 3、创建Statement：如果想和数据库进行交互，一定需要使用这个类。JDK对他的解释是：</span></span><br><span class="line"><span class="comment">             *                 The object used for executing a static SQL statementand returning the results it produces. </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            statement = con.createStatement();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 4、执行查询，获得结果集：想数据库中注入SQL语句，是我们能够进行操作</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String sql = <span class="string">"select * from students"</span>;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 5、处理结果集：query是数据库中的元组集合，可以通过循环获得每个元组</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            query = statement.executeQuery(sql);</span><br><span class="line">            <span class="keyword">while</span>(query.next())&#123;</span><br><span class="line">                String id = query.getString(<span class="string">"id"</span>);</span><br><span class="line">                String name = query.getString(<span class="string">"name"</span>);</span><br><span class="line">                String clazz = query.getString(<span class="string">"clazz"</span>);</span><br><span class="line">                System.out.println(id + <span class="string">"  "</span> + name + <span class="string">"  "</span> + clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 6、释放资源：操作结束后进行操作</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(query != <span class="keyword">null</span>)</span><br><span class="line">                query.close();</span><br><span class="line">            <span class="keyword">if</span>(statement != <span class="keyword">null</span>)</span><br><span class="line">                statement.close();</span><br><span class="line">            <span class="keyword">if</span>(con != <span class="keyword">null</span>)</span><br><span class="line">                con.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h2><h3 id="JDBCUtils-java"><a href="#JDBCUtils-java" class="headerlink" title="JDBCUtils.java"></a>JDBCUtils.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String driverClass = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> String url = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> String name = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> String password= <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1. 创建一个属性配置对象</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"jdbc.properties"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用类加载器，去读取src底下的资源文件。 后面在servlet</span></span><br><span class="line"><span class="comment">//InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("jdbc.properties");</span></span><br><span class="line"><span class="comment">//导入输入流。</span></span><br><span class="line">properties.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取属性</span></span><br><span class="line">driverClass = properties.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line">url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">name = properties.getProperty(<span class="string">"name"</span>);</span><br><span class="line">password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    conn = DriverManager.getConnection(url, name, password);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取连接对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConn</span><span class="params">()</span></span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(driverClass);</span><br><span class="line"><span class="comment">//静态代码块 ---&gt; 类加载了，就执行。 java.sql.DriverManager.registerDriver(new Driver());</span></span><br><span class="line"><span class="comment">//DriverManager.registerDriver(new com.mysql.jdbc.Driver());</span></span><br><span class="line"><span class="comment">//DriverManager.getConnection("jdbc:mysql://localhost/test?user=monty&amp;password=greatsqldb");</span></span><br><span class="line"><span class="comment">//2. 建立连接 参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。</span></span><br><span class="line">conn = connectionHolder.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 释放资源</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> st</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rs</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection conn , Statement st , ResultSet rs)</span></span>&#123;</span><br><span class="line">closeRs(rs);</span><br><span class="line">closeSt(st);</span><br><span class="line">closeConn(conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Connection conn =  connectionHolder.get();</span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回滚事务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Connection conn =  connectionHolder.get();</span><br><span class="line"><span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Connection conn =  connectionHolder.get();</span><br><span class="line"><span class="keyword">if</span>(conn!=<span class="keyword">null</span>)&#123;</span><br><span class="line">conn.commit();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeRs</span><span class="params">(ResultSet rs)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">rs = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSt</span><span class="params">(Statement st)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(st != <span class="keyword">null</span>)&#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">st = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConn</span><span class="params">(Connection conn)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">conn = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="jdbc-properties"><a href="#jdbc-properties" class="headerlink" title="jdbc.properties"></a>jdbc.properties</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driverClass=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost/jdbc-study</span><br><span class="line">name=root</span><br><span class="line">password=root</span><br></pre></td></tr></table></figure><h3 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.utils.JDBCUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection conn = JDBCUtil.getConn();</span><br><span class="line">        Statement sta = conn.createStatement();</span><br><span class="line">        String sql = <span class="string">"select * from students"</span>;</span><br><span class="line">        ResultSet query = sta.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span>(query.next())&#123;</span><br><span class="line">            String id = query.getString(<span class="string">"id"</span>);</span><br><span class="line">            String name = query.getString(<span class="string">"name"</span>);</span><br><span class="line">            String clazz = query.getString(<span class="string">"clazz"</span>);</span><br><span class="line">            System.out.println(id + <span class="string">"  "</span> + name + <span class="string">"  "</span> + clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        JDBCUtil.release(<span class="keyword">null</span>, sta, query);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注册驱动的细节"><a href="#注册驱动的细节" class="headerlink" title="注册驱动的细节"></a>注册驱动的细节</h3><p>其实在JDBC4.0之后不再需要写<code>Class.forName(...);</code>因为JDBC4.0之后，驱动包必须在指定位置包含java.sql.Driver文件，这样就可以自动加载驱动。原话如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JDBC 4.0 Drivers mustinclude the file META-INF/services/java.sql.Driver. This file contains the name of the JDBC driversimplementation of java.sql.Driver. For example, to load the my.sql.Driver class,the META-INF/services/java.sql.Driver file would contain the entry: </span><br><span class="line"> my.sql.Driver</span><br><span class="line">Applications no longer need to explicitly load JDBC drivers using Class.forName(). Existing programswhich currently load JDBC drivers using Class.forName() will continue to work withoutmodification.</span><br></pre></td></tr></table></figure><h2 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"><span class="keyword">import</span> java.sql.Statement;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.utils.JDBCUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRUD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Connection con;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        con = JDBCUtil.getConn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Statement statement = con.createStatement();</span><br><span class="line">        String sql = <span class="string">"select * from students"</span>;</span><br><span class="line">        ResultSet query = statement.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span>(query.next())&#123;</span><br><span class="line">            String id = query.getString(<span class="string">"id"</span>);</span><br><span class="line">            String name = query.getString(<span class="string">"name"</span>);</span><br><span class="line">            String clazz = query.getString(<span class="string">"clazz"</span>);</span><br><span class="line">            System.out.println(id + <span class="string">"  "</span> + name + <span class="string">"  "</span> + clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Statement statement = con.createStatement();</span><br><span class="line">        String sql = <span class="string">"insert into students(id, name, clazz) values ('160341238', '赵承阳', '160341B')"</span>;</span><br><span class="line">        <span class="keyword">int</span> row = statement.executeUpdate(sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Statement statement = con.createStatement();</span><br><span class="line">        String sql = <span class="string">"update students set id = 'helloworld' where id = '160341237'"</span>;</span><br><span class="line">        <span class="keyword">int</span> row = statement.executeUpdate(sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Statement statement = con.createStatement();</span><br><span class="line">        String sql = <span class="string">"delete from students where id = '160341238'"</span>;</span><br><span class="line">        <span class="comment">//返回处理的行数</span></span><br><span class="line">        <span class="keyword">int</span> row = statement.executeUpdate(sql); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PrepareStatement"><a href="#PrepareStatement" class="headerlink" title="PrepareStatement"></a>PrepareStatement</h2><h3 id="Statement的问题"><a href="#Statement的问题" class="headerlink" title="Statement的问题"></a>Statement的问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Statement statement = con.createStatement();</span><br><span class="line">    String qid = <span class="string">"160341238 or 1 = 1"</span>;</span><br><span class="line">    String sql = <span class="string">"select * from students where id = "</span> + qid;</span><br><span class="line">    ResultSet query = statement.executeQuery(sql);</span><br><span class="line">    <span class="keyword">while</span>(query.next())&#123;</span><br><span class="line">    String id = query.getString(<span class="string">"id"</span>);</span><br><span class="line">    String name = query.getString(<span class="string">"name"</span>);</span><br><span class="line">    String clazz = query.getString(<span class="string">"clazz"</span>);</span><br><span class="line">    System.out.println(id + <span class="string">"  "</span> + name + <span class="string">"  "</span> + clazz);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**Console:</span></span><br><span class="line"><span class="comment">    *      160341238  赵承阳  160341B</span></span><br><span class="line"><span class="comment">       aaa  詹金浩  160341B            */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码中，查询的qid后面添加上了or 1 = 1就可以把表中所有信息都查询出来，因为or 1 = 1这句话是一定为真，而我们刚才使用的Statement又使用的是拼接字符串的方式，在字符串中or会被认为是关键字，所以sql语句的条件永远为真。可以采用PrepareStatement类来解决这个问题。</p><h3 id="PrepareStatement-1"><a href="#PrepareStatement-1" class="headerlink" title="PrepareStatement"></a>PrepareStatement</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String sql = <span class="string">"select * from students where id=?"</span>;</span><br><span class="line">    PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从1开始，把字符串填到匹配的?里。关键字也被认为是是字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ps.setString(<span class="number">1</span>, <span class="string">"160341238 or 1 = 1"</span>);</span><br><span class="line">    ResultSet query = ps.executeQuery();</span><br><span class="line">    <span class="keyword">while</span>(query.next())&#123;</span><br><span class="line">    String id = query.getString(<span class="string">"id"</span>);</span><br><span class="line">    String name = query.getString(<span class="string">"name"</span>);</span><br><span class="line">    String clazz = query.getString(<span class="string">"clazz"</span>);</span><br><span class="line">    System.out.println(id + <span class="string">"  "</span> + name + <span class="string">"  "</span> + clazz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="改进的CURD"><a href="#改进的CURD" class="headerlink" title="改进的CURD"></a>改进的CURD</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.PreparedStatement;</span><br><span class="line"><span class="keyword">import</span> java.sql.ResultSet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.utils.JDBCUtil;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedCURD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Connection con;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        con = JDBCUtil.getConn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from students where id=?"</span>;</span><br><span class="line">        PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">        ps.setString(<span class="number">1</span>, <span class="string">"160341238"</span>);</span><br><span class="line">        ResultSet query = ps.executeQuery();</span><br><span class="line">        <span class="keyword">while</span>(query.next())&#123;</span><br><span class="line">            String id = query.getString(<span class="string">"id"</span>);</span><br><span class="line">            String name = query.getString(<span class="string">"name"</span>);</span><br><span class="line">            String clazz = query.getString(<span class="string">"clazz"</span>);</span><br><span class="line">            System.out.println(id + <span class="string">"  "</span> + name + <span class="string">"  "</span> + clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sql = <span class="string">"insert into students(id, name, clazz) values (?, ?, ?)"</span>;</span><br><span class="line">        PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">        ps.setString(<span class="number">1</span>, <span class="string">"160341244"</span>);</span><br><span class="line">        ps.setString(<span class="number">2</span>, <span class="string">"qwe"</span>);</span><br><span class="line">        ps.setString(<span class="number">3</span>, <span class="string">"160341B"</span>);</span><br><span class="line">        <span class="keyword">int</span> row = ps.executeUpdate();</span><br><span class="line">        System.out.println(row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sql = <span class="string">"update students set id = ? where id = ?"</span>;</span><br><span class="line">        PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">        ps.setString(<span class="number">1</span>, <span class="string">"helloworld"</span>);</span><br><span class="line">        ps.setString(<span class="number">2</span>, <span class="string">"160341243"</span>);</span><br><span class="line">        <span class="keyword">int</span> row = ps.executeUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sql = <span class="string">"delete from students where id = ?"</span>;</span><br><span class="line">        PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">        ps.setString(<span class="number">1</span>, <span class="string">"160341238"</span>);</span><br><span class="line">        <span class="keyword">int</span> row = ps.executeUpdate();</span><br><span class="line">        <span class="comment">//返回处理的行数</span></span><br><span class="line">        System.out.println(row);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;JDBC-入门&quot;&gt;&lt;a href=&quot;#JDBC-入门&quot; class=&quot;headerlink&quot; title=&quot;JDBC - 入门&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JDBC" scheme="https://isjinhao.github.io/tags/JDBC/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal分析</title>
    <link href="https://isjinhao.github.io/2019/ThreadLocal%E5%88%86%E6%9E%90/"/>
    <id>https://isjinhao.github.io/2019/ThreadLocal分析/</id>
    <published>2019-04-03T13:24:20.000Z</published>
    <updated>2019-04-04T07:32:43.935Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="并发编程" scheme="https://isjinhao.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>非阻塞同步</title>
    <link href="https://isjinhao.github.io/2019/%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5/"/>
    <id>https://isjinhao.github.io/2019/非阻塞同步/</id>
    <published>2019-04-03T07:24:21.000Z</published>
    <updated>2019-04-03T08:49:47.639Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h2><p>互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步（Blocking Synchronization）。 从处理问题的方式上说，互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施（例如加锁），那就肯定会出现问题，无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、 用户态核心态转换、 维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。 随着硬件指令集的发展，我们有了另外一个选择：基于冲突检测的乐观并发策略，通俗地说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步（Non-Blocking Synchronization）。</p><p>为什么使用乐观并发策略需要“硬件指令集的发展”才能进行呢？</p><p>因为我们需要<strong>操作</strong>和<strong>冲突检测</strong>这两个步骤具备原子性，靠什么来保证呢？如果这里再使用互斥同步来保证就失去意义了，所以我们只能靠硬件来完成这件事情，硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：</p><ul><li><p>测试并设置（Test-and-Set）</p></li><li><p>获取并增加（Fetch-and-Increment）</p></li><li><p>交换（Swap）</p></li><li><p>比较并交换（Compare-and-Swap，下文称CAS）</p></li><li><p>加载链接/条件存储（Load-Linked/Store-Conditional，下文称LL/SC）。</p></li></ul><p>其中，前面的3条是20世纪就已经存在于大多数指令集之中的处理器指令，后面的两条是现代处理器新增的，而且这两条指令的目的和功能是类似的。 在IA64、 x86指令集中有cmpxchg指令完成CAS功能，在sparc-TSO也有casa指令实现，而在ARM和PowerPC架构下，则需要使用一对ldrex/strex指令来完成LL/SC的功能。</p><p>CAS指令需要有3个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示）、 旧的预期值（用A表示）和新值（用B表示）。 CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。在JDK 1.5之后，Java程序中才可以使用CAS操作，该操作由sun.misc.Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程。</p><p>由于Unsafe类不是提供给用户程序调用的类（Unsafe.getUnsafe()的代码中限制了只有启动类加载器（Bootstrap ClassLoader）加载的Class才能访问它），因此，如果不采用反射手段，我们只能通过其他的Java API来间接使用它，如J.U.C包（java.util.concurrent）里面的整数原子类，其中的compareAndSet()和getAndIncrement()等方法都使用了Unsafe类的CAS操作。</p><p>我们不妨拿一段使用volatile关键字没有解决的问题代码来看看如何使用CAS操作来避免阻塞同步，代码如下面所示。 我们曾经通过这段20个线程自增10000次的代码来证明volatile变量不具备原子性，那么如何才能让它具备原子性呢？把“race++”操作或increase()方法用同步块包裹起来当然是一个办法，但是如果改成如下所示的代码，那效率将会提高许多。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> AtomicInteger race = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">race.incrementAndGet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">increase();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">threads[i].start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">Thread.yield();</span><br><span class="line"></span><br><span class="line">System.out.println(race); <span class="comment">//200000</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用AtomicInteger代替int后，程序输出了正确的结果，一切都要归功于incrementAndGet()方法的原子性。它的实现其实非常简单，如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *Atomically increment by one the current value.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">        <span class="keyword">int</span> current=get();</span><br><span class="line">        <span class="keyword">int</span> next=current+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(compareAndSet(current,next))</span><br><span class="line">            <span class="keyword">return</span> next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>incrementAndGet()方法在一个无限循环中，不断尝试将一个比当前值大1的新值赋给自己。 如果失败了，那说明在执行“获取-设置”操作的时候值已经有了修改，于是再次循环进行下一次操作，直到设置成功为止。</p><p>尽管CAS看起来很美，但显然这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是完美的，存在这样的一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。 J.U.C包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。 不过目前来说这个类比较“鸡肋”，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。</p><h2 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h2><p>要保证线程安全，并不是一定就要进行同步，两者没有因果关系。 同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那它自然就无须任何同步措施去保证正确性，因此会有一些代码天生就是线程安全的，这里简单地介绍其中的两类：可重入代码和线程本地存储。</p><h3 id="可重入代码-Reentrant-Code"><a href="#可重入代码-Reentrant-Code" class="headerlink" title="可重入代码(Reentrant Code)"></a>可重入代码(Reentrant Code)</h3><p>这种代码也叫做纯代码(Pure Code)，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。 相对线程安全来说，可重入性是更基本的特性，它可以保证线程安全，即所有的可重入的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的。</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、 用到的状态量都由参数中传入、 不调用非可重入的方法等。 我们可以通过一个简单的原则来判断代码是否具备可重入性：</p><blockquote><p>如果一个方法，它的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求，当然也就是线程安全的。</p></blockquote><h3 id="线程本地存储-Thread-Local-Storage"><a href="#线程本地存储-Thread-Local-Storage" class="headerlink" title="线程本地存储(Thread Local Storage)"></a>线程本地存储(Thread Local Storage)</h3><p>如果一段代码中所需要的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，我们就可以把共享数据的可见范围限制在同一个线程之内，这样，无须同步也能保证线程之间不出现数据争用的问题。符合这种特点的应用并不少见，大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程尽量在一个线程中消费完，其中最重要的一个应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，这种处理方式的广泛应用使得很多Web服务端应用都可以使用线程本地存储来解决线程安全问题。</p><p>Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它为“易变的”；如果一个变量要被某个线程独享，可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。</p><h4 id="ThreadLocal用法"><a href="#ThreadLocal用法" class="headerlink" title="ThreadLocal用法"></a>ThreadLocal用法</h4><h5 id="API"><a href="#API" class="headerlink" title="API"></a>API</h5><ul><li><p>ThreadLocal.get: 获取ThreadLocal中当前线程共享变量的值。</p></li><li><p>ThreadLocal.set: 设置ThreadLocal中当前线程共享变量的值。</p></li><li><p>ThreadLocal.remove: 移除ThreadLocal中当前线程共享变量的值。</p></li><li><p>ThreadLocal.initialValue: ThreadLocal没有被当前线程赋值时或当前线程刚调用remove方法后调用get方法，返回此方法值</p></li></ul><h5 id="获得ThreadLocal变量"><a href="#获得ThreadLocal变量" class="headerlink" title="获得ThreadLocal变量"></a>获得ThreadLocal变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> String <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"调用get方法时，当前线程共享变量没有设置，调用initialValue获取默认值！"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"initialValue: "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>深入理解JVM第二版（周志明）</li><li><a href="https://blog.csdn.net/djokermax/article/details/81296644" target="_blank" rel="noopener">https://blog.csdn.net/djokermax/article/details/81296644</a></li><li><a href="http://www.cnblogs.com/dolphin0520/p/3920407.html" target="_blank" rel="noopener">http://www.cnblogs.com/dolphin0520/p/3920407.html</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;非阻塞同步&quot;&gt;&lt;a href=&quot;#非阻塞同步&quot; class=&quot;headerlink&quot; title=&quot;非阻塞同步&quot;&gt;&lt;/a&gt;非阻塞同步&lt;
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>volatile</title>
    <link href="https://isjinhao.github.io/2019/volatile/"/>
    <id>https://isjinhao.github.io/2019/volatile/</id>
    <published>2019-04-03T03:18:38.000Z</published>
    <updated>2019-04-03T03:19:49.651Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>线程安全分类</title>
    <link href="https://isjinhao.github.io/2019/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E7%B1%BB/"/>
    <id>https://isjinhao.github.io/2019/线程安全分类/</id>
    <published>2019-04-03T01:48:18.000Z</published>
    <updated>2019-04-03T03:19:49.655Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="线程安全定义"><a href="#线程安全定义" class="headerlink" title="线程安全定义"></a>线程安全定义</h2><p>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的。</p><p>这个定义其实很严格，我们通常所说的线程安全都达不到这个要求。</p><p>Java中各种操作共享的数据分为以下5类：不可变， 绝对线程安全， 相对线程安全，线程兼容，线程对立。</p><h2 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h2><p>可变（Immutable）的对象一定是线程安全的，无论是对象的方法实现还是方法的调用者，都不需要再采取任何的线程安全保障措施，只要一个不可变的对象被正确地构建出来（没有发生this引用逃逸的情况），那其外部的可见状态永远也不会改变，永远也不会看到它在多个线程之中处于不一致的状态。例：被final修饰的变量，java.lang.String类的对象。</p><h2 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h2><p>绝对线程安全就是满足定义中的线程安全要求。但是实际上Java API中标注自己是线程安全的类大多数都没做到绝对线程安全。比如Vector。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对线程安全的容器 Vector的测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VectorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;(); </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        vector.remove(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                        System.out.println(vector.get(i));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            removeThread.start();</span><br><span class="line">            printThread.start();</span><br><span class="line">            <span class="comment">// 不要同时产生过多的线程，否则会导致os 假死</span></span><br><span class="line">            <span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为如果另一个线程恰好在错误的时间里删除了一个元素，导致序号i 已经不再可用的话，再用i访问数组就会抛出一个ArrayIndexOutOfBoundsException。但是并发问题是有偶然性的，所以需要多测几次才能获得结果。如果要保证这段代码能够正确执行下去，修改后的代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对线程安全的容器 Vector的测试(修改后的代码)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ModifiedVectorTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Vector&lt;Integer&gt; vector = <span class="keyword">new</span> Vector&lt;&gt;(); </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">                vector.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Thread removeThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (vector) &#123; <span class="comment">// 添加同步块，this line</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                            vector.remove(i);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            Thread printThread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (vector) &#123; <span class="comment">// 添加同步块，this line</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vector.size(); i++) &#123;</span><br><span class="line">                            System.out.println(vector.get(i));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            </span><br><span class="line">            removeThread.start();</span><br><span class="line">            printThread.start();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 不要同时产生过多的线程，否则会导致os 假死</span></span><br><span class="line">            <span class="keyword">while</span>(Thread.activeCount() &gt; <span class="number">20</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h2><p>上述 VectorTest.java 和 ModifiedVectorTest.java 就是相对线程安全的案例。实际上Java API标注的线程安全基本都指相对线程安全。</p><h2 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h2><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用。</p><h2 id="线程对立定义"><a href="#线程对立定义" class="headerlink" title="线程对立定义"></a>线程对立定义</h2><p>指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。由于Java语言天生就具备多线程特性，线程对立这种排斥多线程的代码是很少出现的，而且通常是有害的，应当尽量避免。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;线程安全定义&quot;&gt;&lt;a href=&quot;#线程安全定义&quot; class=&quot;headerlink&quot; title=&quot;线程安全定义&quot;&gt;&lt;/a&gt;线程安
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>新生代内存为什么使用两个Survivor</title>
    <link href="https://isjinhao.github.io/2019/%E6%96%B0%E7%94%9F%E4%BB%A3%E5%86%85%E5%AD%98%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E4%B8%A4%E4%B8%AASurvivor/"/>
    <id>https://isjinhao.github.io/2019/新生代内存为什么使用两个Survivor/</id>
    <published>2019-04-03T01:23:40.000Z</published>
    <updated>2019-04-03T03:19:49.653Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="为什么要有Survivor区"><a href="#为什么要有Survivor区" class="headerlink" title="为什么要有Survivor区"></a><strong>为什么要有Survivor区</strong></h2><p>先不去想为什么有两个Survivor区，第一个问题是，设置Survivor区的意义在哪里？</p><p>如果没有Survivor，Eden区每进行一次Minor GC，存活的对象就会被送到老年代。老年代很快被填满，触发Major GC（因为Major GC一般伴随着Minor GC，也可以看做触发了Full GC）。老年代的内存空间远大于新生代，进行一次Full GC消耗的时间比Minor GC长得多。你也许会问，执行时间长有什么坏处？频发的Full GC消耗的时间是非常可观的，这一点会影响大型程序的执行和响应速度，更不要说某些连接会因为超时发生连接错误了。</p><p>Survivor的存在意义，就是减少被送到老年代的对象，进而减少Full GC的发生，Survivor的预筛选保证，只有经历16次Minor GC还能在新生代中存活的对象，才会被送到老年代。</p><h2 id="为什么要设置两个Survivor区"><a href="#为什么要设置两个Survivor区" class="headerlink" title="为什么要设置两个Survivor区"></a><strong>为什么要设置两个Survivor区</strong></h2><p>设置两个Survivor区最大的好处就是解决了碎片化。stackoverflow上有一个个人推荐的回答：</p><blockquote><p>The reason for the HotSpot JVM’s two survivor spaces is to reduce the need to deal with fragmentation. New objects are allocated in eden space. All well and good. When that’s full, you need a GC, so kill stale objects and move live ones to a survivor space, where they can mature for a while before being promoted to the old generation. Still good so far. The next time we run out of eden space, though, we have a conundrum. The next GC comes along and clears out some space in both eden and our survivor space, but the spaces aren’t contiguous. So is it better to Try to fit the survivors from eden into the holes in the survivor space that were cleared by the GC?<br>Shift all the objects in the survivor space down to eliminate the fragmentation, and then move the survivors into it?<br>Just say “screw it, we’re moving everything around anyway,” and copy all of the survivors from both spaces into a completely separate space–the second survivor space–thus leaving you with a clean eden and survivor space where you can repeat the sequence on the next GC?</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/antony9118/article/details/51425581" target="_blank" rel="noopener">https://blog.csdn.net/antony9118/article/details/51425581</a></li><li><a href="https://stackoverflow.com/questions/10695298/java-gc-why-two-survivor-regions" target="_blank" rel="noopener">https://stackoverflow.com/questions/10695298/java-gc-why-two-survivor-regions</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;为什么要有Survivor区&quot;&gt;&lt;a href=&quot;#为什么要有Survivor区&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM中的锁优化</title>
    <link href="https://isjinhao.github.io/2019/JVM%E4%B8%AD%E7%9A%84%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>https://isjinhao.github.io/2019/JVM中的锁优化/</id>
    <published>2019-04-01T11:43:04.000Z</published>
    <updated>2019-04-03T01:10:40.283Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="Java线程的实现方式"><a href="#Java线程的实现方式" class="headerlink" title="Java线程的实现方式"></a>Java线程的实现方式</h2><h3 id="OS中线程的实现方式"><a href="#OS中线程的实现方式" class="headerlink" title="OS中线程的实现方式"></a>OS中线程的实现方式</h3><p>参考：</p><ul><li><a href="https://isjinhao.github.io/2019/02-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/">https://isjinhao.github.io/2019/02-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/</a></li><li>计算机操作系统（汤子瀛）</li></ul><h3 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h3><p>Java线程的实现机制和操作系统本身有关，限于笔者水平，我们下面介绍的Java线程都是基于<code>Linux</code>平台的实现。</p><p>在<code>Linux</code>平台上，一条Java线程会映射到一个轻量级进程（LWP）之中，而LWP的本质是供程序使用内核线程的接口，每个LWP都会对应一个内核支持线程（KLT），KLT的调度是内核通过操纵调度器（Thread Scheduler）完成，TS的功能就是将KLT的任务映射到各个处理器上。从这可以看出Java线程的创建、撤销、同步等操作都需要进行用户态和内核态的转换，是一种消耗较大的操作。</p><div align="center"><img src="/2019/JVM中的锁优化/java线程实现.jpg" style="width:80%"></div><h3 id="Java线程的状态"><a href="#Java线程的状态" class="headerlink" title="Java线程的状态"></a>Java线程的状态</h3><div align="center"><img src="/2019/JVM中的锁优化/线程状态.jpg" style="width:95%"></div><h2 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a>自旋锁和自适应自旋</h2><p>最常控制同步的手段是互斥，也即<code>synchronized</code>，但是从上面的分析我们可以知道互斥操作对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态进行。不过虚拟机的开发团队意识到，共享数据的锁定时间在大多数情况下只会持续很短一段时间，所以对于多处理机的机器来说，我们可以让后请求锁的线程执行一个忙循环而不放弃处理器的执行时间。这就是自旋锁。</p><p>从上面的分析可知，自旋锁在多处理机的机器上可以减少内核态与用户态之间切换的消耗，但自旋本身是要占用处理机时间的，如果自旋等待的时间太多就会白白消耗处理机资源。</p><p>所以在JDK6中引入了自适应的自旋锁，自旋的时间由上次在同一个锁上的自旋时间以及锁的拥有者决定。。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋有很大几率成功，允许自旋较长的时间。如果对于某个锁很少自旋成功过，则以后可能会省略掉自旋过程。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除指的是虚拟机即时编译器在运行时，检测到对不可能发生共享的数据进行加锁就会进行锁消除。锁消除的判定依赖来源于逃逸分析的数据支持。这里会有一个问题就是：对象会不会发生逃逸其实是程序员可以感知到的，如果对于一段代码不可能存在竞争自然不会加锁。但是实际上Java中很多的同步不是程序员可以控制的。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道String是一个不可变的对象，对于字符串的连接总是通过生成新的String对象来进行的，比如上面代码的实际操作是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>StringBuffer.append()</code>方法中有一个同步块，锁的就是<code>sb</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这种锁程序员无法控制，但是JVM可以进行锁消除来优化代码。</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>原则上，我们在编写并发代码的时候希望同步快范围越小越好，这样是为了使需要同步的操作数量尽可能变小。这种原则在大多数情况下都是合理的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁和解锁的操作出现在循环体中，会增加很多不必要的消耗，此时虚拟机会把锁的范围扩大来减少加锁解锁的操作。比如上面代码的<code>append()</code>操作就是如此。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p>HotSpot虚拟机的对象头(Object Header)包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。</p><p>但是对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额 外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志 位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。</p><div align="center"><img src="/2019/JVM中的锁优化/MarkWord.jpg" style="width:90%"></div><ul><li>epoch：偏向时间戳</li></ul><p>对象头的另外一部分是类型指针，即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说查找对象的元数据信息并不一定要经过对象本身（比如通过句柄访问对象时就可以不通过对象本身获得类型）。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。</p><h3 id="轻量级锁-1"><a href="#轻量级锁-1" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的本质是减少传统的重量级锁使用操作系统互斥量产生的性能消耗。具体过程如下：</p><ol><li>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁标志为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。</li><li>拷贝对象头中的Mark Word复制到锁记录中。</li><li>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。</li><li>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。</li><li>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</li></ol><div align="center"><img src="/2019/JVM中的锁优化/轻量级锁.jpg" style="width:90%"></div><p>这里我们需要注意两个问题，</p><ul><li>第一：CAS是对<code>Mark Word</code>进行的CAS。</li><li>第二就是要考虑一个问题，为什么更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧？在代码进入同步块的时候，同步对象锁状态为无锁状态，把对象头中的Mark Word复制到锁记录中后如果发生了线程调度，可能再调度回来的时候别的线程CAS成功，所以本线程会CAS失败，此时对象的Mark Word指向别的线程的栈帧。但是在这个过程中怎么既能CAS失败，又指向本线程的栈帧呢？笔者没有弄懂。</li></ul><p>我们可以看到在有竞争的条件下，轻量级锁会膨胀为重量级锁，此时不仅使用到信号量，还会增加多余的CAS操作，所以在有竞争的条件下，轻量级锁的引入会增加线程同步消耗。不过事实证明：“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是轻量级锁存在的必要。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>轻量级锁的目的是在无竞争的情况下使用CAS操作去除同步使用的互斥量。而偏向锁就是在无竞争的情况下把整个同步都去掉，连CAS都不用做了。具体过程：</p><ol><li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</li><li>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</li><li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）（在这个时间点上没有字节码正在执行）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）</li><li>执行同步代码。</li></ol><p>撤销操作：</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><div align="center"><img src="/2019/JVM中的锁优化/偏向锁.jpg" style="width:80%"></div><h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p>一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，当到来第一个线程时，这个线程在修改对象头成为偏向锁的时候使用CAS操作，这时候的CAS是对对象头中的偏向线程ID做，会将偏向线程ID该为本线程的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。</p><p>一旦有第二个线程访问这个对象（个人理解，即使第一个线程运行结束，它持有的偏向锁不会主动释放，即对象头不会被修改），所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。</p><p>轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</p><div align="center"><img src="/2019/JVM中的锁优化/java_synchronized.png" style="width:100%"></div><p>掘金上的巨佬，提出了一些意见：按照图中流程，<em>如果发现锁已经膨胀为重量级锁，就直接使用互斥量mutex阻塞当前线程</em>。然而，自旋锁的一大好处就是减少线程切换的开销。在这里没有必要直接阻塞当前线程，大可以像轻量级锁一样，自旋一会，失败了再阻塞。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/choukekai/article/details/63688332" target="_blank" rel="noopener">https://blog.csdn.net/choukekai/article/details/63688332</a></li><li><a href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/" target="_blank" rel="noopener">https://blog.dreamtobe.cn/2015/11/13/java_synchronized/</a></li><li><a href="https://juejin.im/post/5a5c09d051882573282164ae" target="_blank" rel="noopener">https://juejin.im/post/5a5c09d051882573282164ae</a></li><li>深入理解JVM第二版（周志明）</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Java线程的实现方式&quot;&gt;&lt;a href=&quot;#Java线程的实现方式&quot; class=&quot;headerlink&quot; title=&quot;Java线
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JIT和逃逸分析</title>
    <link href="https://isjinhao.github.io/2019/JIT%E5%92%8C%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
    <id>https://isjinhao.github.io/2019/JIT和逃逸分析/</id>
    <published>2019-04-01T09:13:32.000Z</published>
    <updated>2019-04-03T01:19:03.223Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h2><p>全称：Just-In-Time Compilation。</p><p>在部分商用虚拟机中（如HotSpot），Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与<strong>本地平台相关的机器码</strong>，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，下文统称JIT编译器）。</p><p>引入JIT编译器的Java程序运行过程如下图：</p><div align="center"><img src="/2019/JIT和逃逸分析/Java文件运行.jpg" style="width:60%"></div><p>即时编译器并不是虚拟机必须的部分，Java虚拟机规范并没有规定Java虚拟机内必须要有即时编译器存在，更没有限定或指导即时编译器应该如何去实现。但是，即时编译器编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一，它也是虚拟机中最核心且最能体现虚拟机技术水平的部分。</p><p>由于Java虚拟机规范并没有具体的约束规则去限制即使编译器应该如何实现，所以这部分功能完全是与虚拟机具体实现相关的内容，如无特殊说明，我们提到的编译器、即时编译器都是指Hotspot虚拟机内的即时编译器，虚拟机也是特指HotSpot虚拟机。</p><p>HotSpot虚拟机在JDK8中默认开启了JIT。</p><div align="center"><img src="/2019/JIT和逃逸分析/mixedmode.jpg" style="width:80%"></div><p>上图中的mixed mode便是指在硬件上跑程序时，使用解释和JIT编译的混合模式。</p><h3 id="设定HotSpot工作模式"><a href="#设定HotSpot工作模式" class="headerlink" title="设定HotSpot工作模式"></a>设定HotSpot工作模式</h3><ul><li>解释模式：<code>-Xint</code></li><li>编译模式：<code>-Xcomp</code></li><li>混合模式：<code>-Xmixed</code></li></ul><h3 id="热点探测"><a href="#热点探测" class="headerlink" title="热点探测"></a>热点探测</h3><p>如何判断方法或一段代码或是不是热点代码呢？要知道方法或一段代码是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection（热点探测）。目前主要的热点探测方式有以下两种：</p><h4 id="基于采样的热点探测"><a href="#基于采样的热点探测" class="headerlink" title="基于采样的热点探测"></a>基于采样的热点探测</h4><p>采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这个方法就是“热点方法”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</p><h4 id="基于计数器的热点探测"><a href="#基于计数器的热点探测" class="headerlink" title="基于计数器的热点探测"></a>基于计数器的热点探测</h4><p>采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</p><h3 id="HotSpot的热点检测方式？"><a href="#HotSpot的热点检测方式？" class="headerlink" title="HotSpot的热点检测方式？"></a>HotSpot的热点检测方式？</h3><p>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</p><h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p>顾名思义，这个计数器用于统计方法被调用的次数。</p><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p><p>如果不做任何设置，执行引擎并不会同步等待编译请求完成，而是继续进行解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会系统自动改写成新的，下一次调用该方法时就会使用已编译的版本。</p><div align="center"><img src="/2019/JIT和逃逸分析/方法调用计数器.png" style="width:60%"></div><p>回边计数器<br>它的作用就是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”。</p><div align="center"><img src="/2019/JIT和逃逸分析/回边计数器.png" style="width:60%"></div><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>在《深入理解Java虚拟机中》关于Java堆内存有这样一段描述：</p><blockquote><p>但是，随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p></blockquote><p>这里只是简单提了一句，并没有深入分析，笔者在刚到这里由于对JIT、逃逸分析等技术不了解，无法真正理解上面这段话的含义，但现在略有理解。JIT刚才已经介绍过，逃逸分析这部分摘取周志明老师的深入理解JVM第二版。</p><h3 id="逃逸"><a href="#逃逸" class="headerlink" title="逃逸"></a>逃逸</h3><p>逃逸分析的基本行为就是分析对象动态作用域：</p><h4 id="方法逃逸"><a href="#方法逃逸" class="headerlink" title="方法逃逸"></a>方法逃逸</h4><p>当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉代码中返回了<code>sb</code>，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。如果想要StringBuffer sb不逃出方法，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程逃逸"><a href="#线程逃逸" class="headerlink" title="线程逃逸"></a>线程逃逸</h4><p>同理，如果一个对象可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，则称为线程逃逸。</p><h3 id="逃逸分析-1"><a href="#逃逸分析-1" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>如果能证明一个对象不会逃逸到方法或线程以外，也就是别的方法或线程无法通过任何途径访问这个对象，则可能为这个变量进行一些高效的优化。</p><h3 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h3><h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>Java虚拟机中，在Java堆上分配创建对象的内存空间几乎是Java程序员都清楚的常识了，Java堆中的对象对于各个线程都是共享可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但回收动作无论是筛选可回收对象还是回收和整理内存都需要耗费时间。如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随着栈帧的出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力会小很多。</p><h4 id="同步消除"><a href="#同步消除" class="headerlink" title="同步消除"></a>同步消除</h4><p>线程同步本身是一个很耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉。</p><h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>标量是指一个数据已经无法再分解成更小的数据来显示了，Java虚拟机中的原始数据类型（ing、long等数值类型以及引用类型）都不能再进一步分解，他们就可以称为标量。相应的，如果一个数据可以继续分解，那么就把它叫做聚合量。对象就是常见的聚合量。如果把一个Java对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做标量替换。如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，程序运行的时候就可以不创建这个对象，而改为直接创建若干个标量来代替。</p><h3 id="逃逸分析开启"><a href="#逃逸分析开启" class="headerlink" title="逃逸分析开启"></a>逃逸分析开启</h3><p>JDK8中JIT和逃逸分析都是默认开启的， JVM参数如下：</p><ul><li><p><code>-XX:+DoEscapeAnalysis</code> ： 表示开启逃逸分析</p></li><li><p><code>-XX:-DoEscapeAnalysis</code> ： 表示关闭逃逸分析</p></li></ul><h3 id="逃逸分析测试"><a href="#逃逸分析测试" class="headerlink" title="逃逸分析测试"></a>逃逸分析测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a1 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        alloc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> a2 = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"cost "</span> + (a2 - a1) + <span class="string">" ms"</span>);</span><br><span class="line">    <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭逃逸分析"><a href="#关闭逃逸分析" class="headerlink" title="关闭逃逸分析"></a>关闭逃逸分析</h4><ol><li><p>DOS窗口执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx4G -Xms4G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError Test</span><br></pre></td></tr></table></figure></li><li><p>新开一个DOS窗口，输入<code>jps</code>，找到Test进程，使用<code>jmap -histo PID</code>查看。</p><div align="center"><img src="/2019/JIT和逃逸分析/不开启逃逸分析测试.jpg" style="width:80%"></div></li></ol><h4 id="开启逃逸分析"><a href="#开启逃逸分析" class="headerlink" title="开启逃逸分析"></a>开启逃逸分析</h4><ol><li><p>DOS窗口执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx4G -Xms4G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError Test</span><br></pre></td></tr></table></figure></li><li><p>新开一个DOS窗口，输入<code>jps</code>，找到Test进程，使用<code>jmap -histo PID</code>查看。</p><div align="center"><img src="/2019/JIT和逃逸分析/开启逃逸分析测试.jpg" style="width:80%"></div></li></ol><p>可以发现开启逃逸分析之后，堆中只创建了11万个对象。不开启就会创建100万个对象。</p><h3 id="逃逸分析并不成熟"><a href="#逃逸分析并不成熟" class="headerlink" title="逃逸分析并不成熟"></a>逃逸分析并不成熟</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p><h2 id="JIT和逃逸分析的联系"><a href="#JIT和逃逸分析的联系" class="headerlink" title="JIT和逃逸分析的联系"></a>JIT和逃逸分析的联系</h2><p>最开始的时候笔者一直以为，逃逸分析是JIT中的优化技术，为什么呢？因为逃逸分析的代价较大，而JIT是对热点代码进行优化，如果对诸如循环等代码进行逃逸分析，只需要分析一次就可以得到循环中的代码是否满足逃逸的条件，可以淡化逃逸分析的代价。但事实上是笔者的一个错误理解。测试中即使关闭JIT也可以开启逃逸分析。如<code>java -Xint -XX:+DoEscapeAnalysis Test</code>。</p><h2 id="this引用逃逸"><a href="#this引用逃逸" class="headerlink" title="this引用逃逸"></a>this引用逃逸</h2><p>提到逃逸，必须引出另外一个名字类似，但意义完全不同的概念，this引用逃逸：在构造器构造还未彻底完成前（即实例初始化阶段还未完成），将自身this引用向外抛出并被其他线程复制（访问）了该引用，可能会问到该还未被初始化的变量，甚至可能会造成更大严重的问题。</p><p>this引用逃逸是一种错误，而逃逸分析是优化策略。</p><p>详见：<a href="https://www.cnblogs.com/straybirds/p/8640748.html" target="_blank" rel="noopener">https://www.cnblogs.com/straybirds/p/8640748.html</a></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/sunxianghuang/article/details/52094859" target="_blank" rel="noopener">https://blog.csdn.net/sunxianghuang/article/details/52094859</a></li><li>深入理解JVM第二版，周志明</li><li><a href="http://ju.outofmemory.cn/entry/354837" target="_blank" rel="noopener">http://ju.outofmemory.cn/entry/354837</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;JIT&quot;&gt;&lt;a href=&quot;#JIT&quot; class=&quot;headerlink&quot; title=&quot;JIT&quot;&gt;&lt;/a&gt;JIT&lt;/h2&gt;&lt;p&gt;全
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>基于比较的三种简单排序</title>
    <link href="https://isjinhao.github.io/2019/%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/"/>
    <id>https://isjinhao.github.io/2019/基于比较的三种简单排序/</id>
    <published>2019-04-01T07:32:23.000Z</published>
    <updated>2019-04-01T14:03:28.215Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    简单排序：</span></span><br><span class="line"><span class="comment">        平均时间复杂度都是O(N方)级别。包括：冒泡排序、插入排序、选择排序 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    说明：</span></span><br><span class="line"><span class="comment">        实现的算法都是升序排序。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;e1, <span class="keyword">int</span> &amp;e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = e1;</span><br><span class="line">    e1 = e2;</span><br><span class="line">    e2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    冒泡排序（稳定）：</span></span><br><span class="line"><span class="comment">        重复地走访过要排序的元素列，一次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从</span></span><br><span class="line"><span class="comment">        A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说</span></span><br><span class="line"><span class="comment">        该元素已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端</span></span><br><span class="line"><span class="comment">        （升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)    <span class="comment">//len - 1 趟就行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)   <span class="comment">//某趟排序没有进行交换时，排序结束 </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    插入排序（稳定）：</span></span><br><span class="line"><span class="comment">        从索引为1的元素（设为temp）开始开始，每次把之前的元素调整成有序序列。由于之前的元素都是有序序列， </span></span><br><span class="line"><span class="comment">        从后向前若temp小于当前遍历到的元素（arr[j]），此元素后移。否则退出此次遍历。退出后把temp插入当前的arr[j]。 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i], j;</span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j--)</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    选择排序（不稳定）：</span></span><br><span class="line"><span class="comment">        每次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j++)</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min])</span><br><span class="line">                min = j;</span><br><span class="line">        swap(arr[min], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        arr[i] = rand() % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    selectSort(arr, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
      <category term="DS" scheme="https://isjinhao.github.io/categories/DS/"/>
    
    
      <category term="DSA" scheme="https://isjinhao.github.io/tags/DSA/"/>
    
      <category term="排序" scheme="https://isjinhao.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>HTML基础</title>
    <link href="https://isjinhao.github.io/2019/HTML%E5%9F%BA%E7%A1%80/"/>
    <id>https://isjinhao.github.io/2019/HTML基础/</id>
    <published>2019-03-31T14:20:42.000Z</published>
    <updated>2019-03-31T14:26:48.553Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">target</span>=<span class="string">"_self"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="target的属性值"><a href="#target的属性值" class="headerlink" title="target的属性值"></a>target的属性值</h3><ul><li><code>_self</code>：在本窗口中打开目标页面。默认属性值。</li><li><code>_blank</code>：在新的浏览器窗口打开目标页面。</li><li><code>_parent</code>：这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标<code>_self</code>等效，即如果不使用<code>frameset</code>，就和<code>_self</code>等效。</li><li><code>_top</code>：这个目标使得文档载入包含这个超链接的窗口，用<code>_top</code>目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。</li><li><code>其他值</code>：给一堆超链接以相同的target值，这种方式可以使得一组超链接在同一窗口打开，即<strong>通过单击一个窗口中的不同链接控制另一窗口内容变化</strong>。首先，浏览器会找与target值相符的框架或者窗口中的文档，有则在其中显示文档。如果不存在，浏览器打开一个新窗口，给其指定一个标识为target值，之后只要该窗口不关闭，其它超链接就可以指向这个新窗口。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.com.hk"</span> <span class="attr">target</span>=<span class="string">"HelloWorld"</span>&gt;</span>google<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://cn.bing.com"</span> <span class="attr">target</span>=<span class="string">"HelloWorld"</span>&gt;</span>必应<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">target</span>=<span class="string">"HelloWorld"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.soso.com"</span> <span class="attr">target</span>=<span class="string">"HelloWorld"</span>&gt;</span>搜搜<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="锚链接"><a href="#锚链接" class="headerlink" title="锚链接"></a>锚链接</h3><p>跳转至网页的指定部分。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"tar"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1000行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#tar"</span>&gt;</span>锚链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="链接邮件"><a href="#链接邮件" class="headerlink" title="链接邮件"></a>链接邮件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:xxx@yyy.zzz"</span>&gt;</span>发送邮件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="水平线标签"><a href="#水平线标签" class="headerlink" title="水平线标签"></a>水平线标签</h2><p><code>&lt;hr /&gt;</code></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">border</span>=<span class="string">"xxx"</span> <span class="attr">alt</span>=<span class="string">"yyy"</span> <span class="attr">title</span>=<span class="string">"zzz"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片分类"><a href="#图片分类" class="headerlink" title="图片分类"></a>图片分类</h3><ul><li><code>bmp</code>：<code>windows</code>系统下的标准位图（像素点构成的图）格式。文件较大，不建议大量使用。</li><li><code>gif</code>：动图。但是只支持256种色彩，不适合保存图片。</li><li><code>jpeg</code>：又称<code>jpg</code>，有损压缩的图片。<ul><li>有损压缩：只对图像或声波中的某些频率成分不敏感的特性，允许压缩过程中损失一定的信息；虽然不能完全恢复原始数据，但是所损失的部分对理解原始图像的影响缩小，却换来了大得多的压缩比。</li></ul></li><li><code>png</code>：无损压缩图片。</li></ul><h3 id="alt"><a href="#alt" class="headerlink" title="alt"></a><code>alt</code></h3><p>图片无法加载时，用于替换图片内容的文字。</p><h3 id="title"><a href="#title" class="headerlink" title="title"></a><code>title</code></h3><p>鼠标悬停时显示的文字。</p><h3 id="图片热点"><a href="#图片热点" class="headerlink" title="图片热点"></a>图片热点</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> =<span class="string">"planets.gif"</span> <span class="attr">alt</span>=<span class="string">"Planets"</span> <span class="attr">usemap</span> =<span class="string">"#planetmap"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"planetmap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"0,0,110,260"</span> <span class="attr">href</span>=<span class="string">"sun.htm"</span> <span class="attr">alt</span>=<span class="string">"Sun"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">"129,161,10"</span> <span class="attr">href</span>=<span class="string">"mercur.htm"</span> <span class="attr">alt</span>=<span class="string">"Mercury"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">"180,139,14"</span> <span class="attr">href</span>=<span class="string">"venus.htm"</span> <span class="attr">alt</span>=<span class="string">"Venus"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="http://www.w3school.com.cn/tags/att_area_coords.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/tags/att_area_coords.asp</a></p><h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><div align="center"><img src="/2019/HTML基础/html和css基础/tab.png" style="width:80%"></div><h2 id="滚动字幕"><a href="#滚动字幕" class="headerlink" title="滚动字幕"></a>滚动字幕</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">marquee</span>&gt;</span>默认的滚动字幕（左←右）<span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">direction</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (1).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (2).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (3).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (4).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (5).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (6).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (7).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (8).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (9).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">height</span>=<span class="string">"150"</span> <span class="attr">bgcolor</span>=<span class="string">"#eeeeee"</span> <span class="attr">direction</span>=<span class="string">"up"</span> <span class="attr">scrollamount</span>=<span class="string">"220"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>1111111111111111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>2222222222222222<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>3333333333333333<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>4444444444444444<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>5555555555555555<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul><li>cellpadding：规定单元边沿与其内容之间的空白</li><li><p>cellspacing：规定的是单元之间的空间。</p></li><li><p>colspan：合并列</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">width</span>=<span class="string">"400"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"30%"</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">width</span>=<span class="string">"70%"</span>&gt;</span>考试成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"35%"</span>&gt;</span>理论：79分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"35%"</span>&gt;</span>上机：88分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>理论：87分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>上机：74分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>rowspan：合并列</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">width</span>=<span class="string">"90%"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">bgcolor</span>=<span class="string">"#eeeeee"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"30%"</span>&gt;</span>日期<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"30%"</span>&gt;</span>时间<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"40%"</span>&gt;</span>上映电影<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"3"</span>&gt;</span>8月1日<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>8:00-11:00<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>哈利珀特7<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>11:00-13:00<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>哈利珀特7<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>13:00-15:00<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>阿凡达2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>8月2日<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>8:00-11:00<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>哈利珀特7<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>13:00-15:00<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>阿凡达2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;超链接&quot;&gt;&lt;a href=&quot;#超链接&quot; class=&quot;headerlink&quot; title=&quot;超链接&quot;&gt;&lt;/a&gt;超链接&lt;/h2&gt;&lt;fig
      
    
    </summary>
    
      <category term="前端" scheme="https://isjinhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://isjinhao.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="https://isjinhao.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Java的GC</title>
    <link href="https://isjinhao.github.io/2019/Java%E7%9A%84GC/"/>
    <id>https://isjinhao.github.io/2019/Java的GC/</id>
    <published>2019-03-31T07:58:38.000Z</published>
    <updated>2019-04-03T01:45:45.033Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>程序计数器、虚拟机栈、本地方法栈这些区域不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。垃圾收集器关注的是堆和方法区中的垃圾。</p><h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><h3 id="对象判死算法"><a href="#对象判死算法" class="headerlink" title="对象判死算法"></a>对象判死算法</h3><h4 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。但这种计数法无法解决循环引用的问题，即若A对象中有属性B，B对象中有属性A，则A、B永远都有计数。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><div align="center"><img src="/2019/Java的GC/可达性算法.jpg" style="width:80%"></div><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>在Java1.2之前，引用的定义是这样的：</p><blockquote><p>如果reference类型的数据中存储的数值代表的是另外一块内存中的起始地址，就称这块内存代表着一个引用。</p></blockquote><p>我们可以看到，这个引用的定义是非常狭隘的，因为他不能描述一些“鸡肋”对象，即我们最希望的是能描述这样一类对象：当内存空间还足够时，则能保存在内中，如果内存空间在回收后仍然很紧张则可以抛弃这些对象。所以，在Java1.2以后提出了新的引用定义：</p><ul><li>强引用：在代码中普遍存在的，类似<code>Object obj = new Object();</code>。只要强引用还存在，垃圾回收期就永远不会回收被引用的对象</li><li>软引用：用来描述一些还有用，但并非必须的对象。这样当系统要发生内存溢出异常之前，就会把软引用列进第二次垃圾回收的计划中。</li><li>弱引用：比软引用还弱的引用，被弱引用的对象只能存活到下一次垃圾回收之前。</li><li>虚引用：最弱的一种引用关系了。使用虚引用的唯一目的就是在这个对象回收前收到一个系统回收通知。</li></ul><h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使是不可达对象，也并非是非死不可的，这时候它们暂时处于”缓刑“阶段，真正宣告一个对象死亡，至少要经过<strong>两次标记过程</strong>：</p><p>如果对象在进行根搜索后发现跟root不同根，就被标记一次，同时进行筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法，”没有必要执行”的原因如下：当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>已经被JVM调用过（说明一个对象的<code>finalize()</code>方法只能执行一次）。如果这个对象有必要执行<code>finalize()</code>方法，JVM就会把它放在<code>F-Queue</code>中，稍后<code>JVM</code>会触发一个低优先级的线程去执行。<strong>但是去执行并不承诺会等待它运行结束，因为如果一个对象在finalize()方法中执行缓慢，甚至发生了死循环，就会导致F-Queue其他对象永久处于等待状态，更严重的话可能会拖垮整个内存回收系统。</strong><code>finalize()</code>是对象逃脱死亡命运的最后一次机会，稍后<code>GC</code>将会对<code>F-Queue</code>进行第二次小规模的标记，如果在<code>finalize()</code>中将自己和root挂在一个根上（比如把自己赋值给某个类变量或者对象的成员变量），那么在这第二次标记将会被移除出“即将回收的集合”：如果对象还没有逃脱，那么就基本上真的被回收了。</p><p>不过非常不推荐使用finalize()方法自救对象，因为这是Java刚诞生为了使C/C++程序员更容易接受它作的一个妥协。它的运行带价高昂，不确定性大，无法保证各个对象的调用顺序。<strong>有些教材中提到它使用“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方法都可以做的更好、更及时，Java程序员完全可以忘掉Java有finalize()。</strong></p><p><code>finalize()</code>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"haha, i'm still alive!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line">        <span class="comment">//对象第一次拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"5555, i'm dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对象第二次拯救自己，但是却跪了。因为finalize只能执行一次呀，亲！！</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"5555, i'm dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output:</span></span><br><span class="line"><span class="comment">    finalize method executed!</span></span><br><span class="line"><span class="comment">    haha, i'm still alive!</span></span><br><span class="line"><span class="comment">    5555, i'm dead!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>永久代的垃圾收集主要回收两部分内容：</p><ul><li>废弃常量：以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</li><li>无用的类：判断一个类是无用的类的条件比废弃变量要苛刻的多，要同时满足3个条件才能算是“无用的类”：<ol><li>该类所有的实例都已经被回收，意思是堆上没有该对象的实例了</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法（因为通过反射，就一定要加载该类）</li></ol></li></ul><p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。有两个问题：一是效率不高，因为当对象数量比较多的时候一一进行标记和清除较复杂；二是会产生内存碎片，当需要大的连续内存空间时，即使碎片内存总和远大于需求，也会触发垃圾回收操作。</p><div align="center"><img src="/2019/Java的GC/标记清除算法.jpg" style="width:80%"></div><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。实现简单，运行高效，但是空间缩小为原来的一半了。<strong>现在的商业JVM采用这种算法来回收新生代，IBM经过调研发现，新生代的对象98%都是朝生夕死的，所有并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。</strong>当回收时，将Eden和Survivor还存活着的对象一次性拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。<strong>HotSpot虚拟机默认Eden和Survivor的大小比例是8：1</strong>，也就是每次新生代中可用内存空间为整个内存空间的9/10，只有10%的内存是用来浪费的。当然了，我们无法保证每次回收只有少于10%的对象存活，当存活对象大于10%，就会借用其他内存（这里指老年代）进行分配担保。分配担保的详细介绍在后面。</p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。（老年代一般采用这个方法）</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾回收都采用分代收集算法，这种算法没有啥特别的，就是<strong>根据对象的存活周期的不同将内存划分为几块</strong>，一般是把Java堆分为新生代和老年代，这样就可以根据每个代不同的特点采用最适当的回收算法。比如新生代存活对象少，就采用复制算法；老年代存活对象少，复制的话代价太大，就可以采用标记-整理算法。</p><h2 id="HotSpot-的算法实现"><a href="#HotSpot-的算法实现" class="headerlink" title="HotSpot 的算法实现"></a>HotSpot 的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>可达性分析在逐个检查引用链和GC停顿（保证分析工作的一致性）上浪费时间较多。主流Java虚拟机使用的都是准确式GC，即虚拟机应当有办法直接得知哪些地方存放着对象的引用。HotSpot是通过一个OopMap的数据结构来达到这个目的的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>HotSpot没有为每条指令都生成OopMap，那样占用空间太多，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p><p>另一个问题是如何让所有线程都跑到最近的安全点停顿。这里有两种方案可供选择：<strong>抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）</strong>，其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</p><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>如果线程没有在执行呢，比如线程处于Sleep状态或者Blocked状态，就需要安全区域解决了。安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</p><p>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p><h3 id="OopMap和安全点辨析"><a href="#OopMap和安全点辨析" class="headerlink" title="OopMap和安全点辨析"></a>OopMap和安全点辨析</h3><p>OopMap 记录了栈上本地变量到堆上对象的引用关系。其作用是：垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收。但问题是，栈上的本地变量表里面只有一部分数据是 Reference 类型的（它们是我们所需要的），那些非 Reference 类型的数据对我们而言毫无用处，但我们还是不得不对整个栈全部扫描一遍，这是对时间和资源的一种浪费。</p><p>一个很自然的想法是，能不能用空间换时间，在某个时候把栈上代表引用的位置全部记录下来，这样到真正 gc 的时候就可以直接读取，而不用再一点一点的扫描了。事实上，大部分主流的虚拟机也正是这么做的，比如 HotSpot ，它使用一种叫做 OopMap 的数据结构来记录这类信息。</p><p>我们知道，一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。 gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的<code>OopMap</code>，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的<code>OopMap</code>，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。</p><p>参考：<a href="https://dsxwjhf.iteye.com/blog/2201685" target="_blank" rel="noopener">https://dsxwjhf.iteye.com/blog/2201685</a></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><div align="center"><img src="/2019/Java的GC/hotspot_gc.jpg" style="width:60%"></div><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>最基本，历史最悠久。新生代的，“单线程的”，只会用一个CPU或一个线程工作，并且收集时，必须暂停所有的工作线程，直到收集结束。它依然是虚拟机运行在<code>Client</code>端的默认新生代收集器。简单而高效，因为它不需要考虑线程切换，只专注一次把收集工作搞定，而且在<code>Client</code>端，新生代的内存一般只有几十M或者一两百M的样子，完成一次收集工作完全可以控制在几十毫秒或者一百毫秒左右，不会有很大的停顿感。</p><div align="center"><img src="/2019/Java的GC/serial.jpg" style="width:80%"></div><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>这个本质上就是Serial收集器的多线程版本。许多运行在Server模式下的虚拟机中首选的<strong>新生代收集器</strong>，其中还有一个与性能无关<strong>但很重要的原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作</strong>。（原因是Parallel Scavenge收集器和后面的G1收集器都没有使用传统的GC收集器代码框架，而是另外独立实现的，其余几种收集器则共用了框架代码）。ParNew收集器也是使用<code>-XX:+UseConcMarkSweepGC</code>选项后的默认新生代收集器，当然也可以使用<code>-XX:+UseParNewGC</code>选项来显式指定使用</p><p>单CPU的话一般会考虑用Serial，多CPU的话一般考虑用ParNew，<strong>它默认开启的收集器线程数和CPU核数相同，当你想控制的时候，可以使用<code>-XX:ParallelGCThreads</code>参数来限制收集器的线程数。</strong></p><p>然后提前解释一下<strong>并行</strong>和<strong>并发</strong>的概念，因为后面会有几个并发和并行的收集器：</p><ul><li>并行(Parallel)：指多条垃圾收集线程并行工作，<strong>但此时用户线程仍然处于等待状态</strong>。所以，遇到 Parallel 关键字的话，都是并行。所以当它们工作的时候，用户线程是阻塞的。所以也是 stop the world</li><li>并发(Concurrent)：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会根据时间片轮转交替进行），用户程序继续运行，而垃圾收集程序运行在另外一个CPU上。所以遇到 concurrent 关键字就是 GC 线程和用户线程在一段时间内交叉运行，不会将用户线程阻塞，不是 stop the world</li></ul><div align="center"><img src="/2019/Java的GC/parnew.jpg" style="width:80%"></div><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge也是<strong>一个新生代收集器</strong>，它也是<strong>使用复制算法</strong>的收集器，同时也是<strong>并行的多线程收集器</strong>。它的目标是达到可控制的CPU吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾回收时间）。比如虚拟机运行了100分钟，垃圾回收使用了1分钟，那么吞吐量就是99%。</p><p>这就说说一下应用场景了。</p><ul><li>停顿时间（垃圾回收时间）： 停顿时间越短越适合于用户交互的程序，良好的响应速度能提升用户体验</li><li>高吞吐量： 可以最高效率的利用CPU时间，尽快的完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务</li></ul><p>为了这两个目的，Parallel Scavenge收集器提供了2个参数：</p><ul><li><code>-XX:MaxGCPauseMillis</code>：大于0的毫秒数，收集器将尽力保证内存回收时间不超过这个值。不过不要异想天开认为把这个值设的特别小，就能使系统垃圾收集速度更快，GC停顿时间缩短肯定是有代价的，它会牺牲吞吐量和新生代空间来实现。</li><li><code>-XX:GCTimeRatio</code>：大于0小于100的整数.假如设为N，那么垃圾收集时间占总时间的比率就是1/(1+N),比如设置为19,占比就是1/(1+19)=5%，默认值是99，即1%。</li><li><code>-XX:+UseAdaptiveSizePolicy</code>：这也是一个有用的参数，放在这里说一下。它是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（<code>-Xmn</code>）、Eden、Survivor区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以一同最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（<code>GC Ergonomics</code>）。<strong>自适应调节策略也是Parallel Scavenge收集器和ParNew收集器的一个重要区别</strong></li></ul><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”<strong>标记-整理</strong>“算法。这个收集器的主要意义就是被Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用；另外一个就是CMS的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。是在JDK 1.6之后才提供的。前面说过，Parallel Scavenge收集器采用了独立的架构，无法和CMS配合使用。那么，在JDK 1.6以前，Parallel Scavenge只能和Serial Old配合使用。因为Serial Old是单线程的，所以在多CPU情况下无法发挥性能，所以根本实现不了高吞吐量的需求，直到JDK 1.6推出了Parallel Old之后，Parallel Scavenge收集器和Parallel Old搭配，才真正实现了对吞吐量优先的控制。所以，<strong>在注重吞吐量及CPU资源敏感的场合，都可以考虑Parallel Scavenge和Parallel Old组合</strong>。</p><div align="center"><img src="/2019/Java的GC/parallel.jpg" style="width:80%"></div><h3 id="CMS（Comcurrent-Mark-Sweep）收集器"><a href="#CMS（Comcurrent-Mark-Sweep）收集器" class="headerlink" title="CMS（Comcurrent Mark Sweep）收集器"></a>CMS（Comcurrent Mark Sweep）收集器</h3><p>CMS收集器是<strong>以获取最短回收停顿时间为目标的收集器</strong>。目前很大一部分的Java应用都集中在互联网站或者B/S系统上，这类应用<strong>尤其重视服务的响应速度，希望系统停顿时间最短，给用户最佳的用户体验。而CMS收集器就非常符合这类应用的需求</strong></p><p>从名字上可以看出，”Mark Sweep“是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤：</p><ol><li>初始标记：初始标记仅仅只是标记一下GC roots能直接关联到的对象，速度很快，需要stop the world。</li><li>并发标记：并发标记就是进行GC Roots Tracing（可达性算法）的过程。</li><li>重新标记：重新标记则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变化的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍微长一些，但远比并发标记的时间短，需要stop the world。</li><li>并发清除：垃圾清除</li></ol><div align="center"><img src="/2019/Java的GC/cms.jpg" style="width:80%"></div><p>由于整个过程中，并发标记和并发清除时间最长，收集器线程可以和用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p>CMS收集器的优点在于<strong>并发收集、低停顿</strong>，但是也不是完美的，主要有3个显著的缺点：</p><ol><li>CMS收集器对CPU资源非常敏感。默认情况下，CMS的收集线程数=(CPU数目+3)/4，当CPU个数大于4的时候，CMS的收集线程不会超过整个CPU占用率的25%。但是在CPU个数比较小的情况下，CPU占用就会突然增大，这样对于初始标记和并发标记这样”Stop The World”的过程来说，用户就会明显感觉到停顿。</li><li><strong>CMS收集器无法处理浮动垃圾，可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生</strong>。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，它<strong>需要预留一部分空间提供并发收集时的线程使用。在JDK1.5默认设置下，CMS收集器在老年代使用了68%的空间会被激活，这是一个偏保守的设置。</strong>如果在应用中，老年代增长不是太快，可以适当调高这个参数-XX:CMSInitiatingOccupancyFraction。要是CMS运行期间预留的内存无法满足程序的需要，就会出现”Concurrent Mode Failure”失败，这时候JVM会启动后备方案：临时启动Serial Old收集器来重新进行老年代的垃圾收集，因为是单线程，停顿时间就会更长了。所以如果大量出现”Concurrent Mode Failure”，就可以将这个值调低</li><li>CMS是基于<strong>标记-清除</strong>算法实现的收集器，所以会产生内存碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦：老年代还有空间但是没有连续的足够大的空间，于是不得不触发一次Full GC。为了解决这个问题，有一个开关叫做-XX:+UseCMSCompactAtFullCollection，用于在Full GC时开启内存碎片的合并整理过程。当然，这个内存整理没法并发，只有”Stop The World”了。另外，虚拟机还设计了一个参数-XX:CMSFullGCsBeforeCompaction,用于指定在多少次不压缩的Full GC后，跟着来一次带压缩的。</li></ol><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1是一款面向服务端应用的垃圾收集器。与其他GC收集器相比，G1具备如下特点。</p><ul><li>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li><li>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li><li>空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li><li>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li></ul><p>G1收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记（Initial Marking）</li><li>并发标记（Concurrent Marking）</li><li>最终标记（Final Marking）</li><li>筛选回收（Live Data Counting and Evacuation）</li></ul><h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">33.125: [GC [DefNew: 3324K-&gt;152K(3712K), 0.0025925 secs] 3324K-&gt;152K(11904K), 0.0031680 secs]</span><br><span class="line">100.667: [Full GC [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(19456K), [Perm : 2999K-&gt;2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure><p>最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</p><p>GC日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“[Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“[Full GC（System）”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC 283.736: [ParNew: 261599k-&gt;261599k(261592k), 0.0000288sec]]</span><br></pre></td></tr></table></figure><p>接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的。</p><p>后面方括号内部的“3324K-&gt;152K（3712K）”含义是“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-&gt;152K（11904K）”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量（Java堆总容量）”。</p><p>再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“[Times：user=0.01 sys=0.00，real=0.02 secs]”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致。</p><h3 id="参数总结"><a href="#参数总结" class="headerlink" title="参数总结"></a>参数总结</h3><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">UseSerialGC</td><td style="text-align:center">虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收</td></tr><tr><td style="text-align:center">UseParNewGC</td><td style="text-align:center">打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收</td></tr><tr><td style="text-align:center">UseConcMarkSweepGC</td><td style="text-align:center">打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后壁收集器使用</td></tr><tr><td style="text-align:center">UseParallelGC</td><td style="text-align:center">虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old（PS MarkSweep）的收集器组合进行内存回收</td></tr><tr><td style="text-align:center">UseParallelOldGC</td><td style="text-align:center">打开此开关后，使用Parallel Scavenge+Parallel Old的收集器组合进行内存回收</td></tr><tr><td style="text-align:center">SurvivorRatio</td><td style="text-align:center">新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survivor=8:1</td></tr><tr><td style="text-align:center">PretenureSizeThreshold</td><td style="text-align:center">直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td></tr><tr><td style="text-align:center">MaxTenuringThreshold</td><td style="text-align:center">晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄加1，当超过这个参数值时就进入老年代</td></tr><tr><td style="text-align:center">UseAdaptiveSizePolicy</td><td style="text-align:center">动态调整Java堆中各个区域的大小以及进入老年代的年龄</td></tr><tr><td style="text-align:center">HandlePromotionFailure</td><td style="text-align:center">是否允许分配担保失败，即老年代的剩余空间不足以应对新生代的整个Eden和Survivor区的所有对象都存活的极端情况</td></tr><tr><td style="text-align:center">ParallelGCThreads</td><td style="text-align:center">设置并行GC时进行内存回收的线程数</td></tr><tr><td style="text-align:center">GCTimeRatio</td><td style="text-align:center">GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td style="text-align:center">MaxGCPauseMillis</td><td style="text-align:center">设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td style="text-align:center">CMSinitiatingOccupancyFraction</td><td style="text-align:center">设置CMS收集器在老年代空间被使用多少后出发垃圾收集。默认值为68%，仅在使用CMS收集器时生效</td></tr><tr><td style="text-align:center">UseCMSCompactAtFullCollection</td><td style="text-align:center">设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效</td></tr><tr><td style="text-align:center">CMSFullGCsBeforeCompaction</td><td style="text-align:center">设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效</td></tr></tbody></table><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="Minor-GC和Full-GC"><a href="#Minor-GC和Full-GC" class="headerlink" title="Minor GC和Full GC"></a>Minor GC和Full GC</h3><ul><li>Minor GC：发生在新生代的GC。C触发条件：当Eden区满时。</li><li>Full GC（也叫Major GC）：发生在老年代的GC，通常会触发MinorGC。Major GC的速度一般会比Minor GC慢10倍以上。触发条件：<ul><li>调用System.gc时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul></li></ul><p>但是这种定义不是很规范，详细参考：<a href="http://www.importnew.com/15820.html" target="_blank" rel="noopener">http://www.importnew.com/15820.html</a></p><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><p>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Sur-vivor区之间发生大量的内存复制。注意PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效。</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进程一次Minor GC（尽管此次GC是有风险的），如果小于或者不允许冒险，需要进行一次Full GC。</p><p>在JDK 6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>深入理解JVM第二版（周志明）</li><li><a href="http://howiefh.github.io/2015/04/08/jvm-note-2/" target="_blank" rel="noopener">http://howiefh.github.io/2015/04/08/jvm-note-2/</a></li><li><a href="https://blog.csdn.net/yhyr_ycy/article/details/52566105" target="_blank" rel="noopener">https://blog.csdn.net/yhyr_ycy/article/details/52566105</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;程序计数器
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>直接引用和符号引用</title>
    <link href="https://isjinhao.github.io/2019/%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8/"/>
    <id>https://isjinhao.github.io/2019/直接引用和符号引用/</id>
    <published>2019-03-31T07:30:20.000Z</published>
    <updated>2019-03-31T12:10:36.470Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><p>在JVM中，类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。而解析阶段即是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><h2 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h2><p>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个<code>Java</code>类将会编译成一个<code>class</code>文件。在编译时，<code>Java</code>类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如<code>org.simple.People</code>类引用了<code>org.simple.Language</code>类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号<code>org.simple.Language</code>（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示<code>Language</code>类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p><h2 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h2><p>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://blog.csdn.net/u014656992/article/details/51107127" target="_blank" rel="noopener">https://blog.csdn.net/u014656992/article/details/51107127</a></p></li><li><p>深入理解Java虚拟机第七章</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在JVM中，类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。而解析阶段
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>常量池和String</title>
    <link href="https://isjinhao.github.io/2019/%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8CString/"/>
    <id>https://isjinhao.github.io/2019/常量池和String/</id>
    <published>2019-03-31T02:19:14.000Z</published>
    <updated>2019-04-01T05:58:12.460Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>常量池及String在JDK6、JDK7、JDK8中的实现以及在不同虚拟机中的实现有很大区别，限于笔者水平无法兼顾到太多版本之间的差异，所以下文章中的解释和测试都<strong>仅仅针对于HotSpot虚拟机的JDK8</strong>。</p><h2 id="常量池和运行时常量池"><a href="#常量池和运行时常量池" class="headerlink" title="常量池和运行时常量池"></a>常量池和运行时常量池</h2><p>在刚开始学习Java内存模型的时候笔者掉进入过一个大坑，即认为常量池是运行时常量池的简称。但是实际上这两者是不一样池子，运行时常量池的英文：<code>Runtime Constant Pool</code>，常量池的英文：<code>Constant Pool Table</code>，运行时常量池是方法区的一部分。常量池是Class文件中的一部分，用于存放编译期生成的各种字面量和符号引用。符号引用和直接引用请参考：<a href="https://isjinhao.github.io/2019/%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8/#more">https://isjinhao.github.io/2019/%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8/#more</a></p><h3 id="常量池的内容"><a href="#常量池的内容" class="headerlink" title="常量池的内容"></a>常量池的内容</h3><div align="center"><img src="/2019/常量池和String/常量池里的内容.png" style="width:100%"></div><h3 id="常量池到运行时常量池"><a href="#常量池到运行时常量池" class="headerlink" title="常量池到运行时常量池"></a>常量池到运行时常量池</h3><p>静态常量池存储的是当class文件被java虚拟机加载进来后存放在方法区的一些字面量和符号引用，字面量包括字符串，基本类型的常量，符号引用其实引用的就是常量池里面的字符串，但符号引用不是直接存储字符串，而是存储字符串在常量池里的索引。</p><p>动态常量池是当class文件被加载完成后，java虚拟机会将静态常量池里的内容转移到动态常量池里，在静态常量池的符号引用有一部分是会被转变为直接引用的，比如说类的静态方法或私有方法，实例构造方法，父类方法，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的一些方法是在这个方法被第一次调用的时候才会将符号引用转变为直接引用的。</p><div align="center"><img src="/2019/常量池和String/常量池和运行时常量池.jpg" style="width:80%"></div><h2 id="8种基本类型的包装类和常量池"><a href="#8种基本类型的包装类和常量池" class="headerlink" title="8种基本类型的包装类和常量池"></a>8种基本类型的包装类和常量池</h2><p>Java中基本类型的包装类的大部分都实现了常量池技术，即Byte、Short、Integer、Long、Character、Boolean。他么默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer 缓存代码 ：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">     <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">         <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出TRUE</span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">400</span>;</span><br><span class="line">Integer i2 = <span class="number">400</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出false</span></span><br></pre></td></tr></table></figure><h3 id="Integer比较更丰富的一个例子"><a href="#Integer比较更丰富的一个例子" class="headerlink" title="Integer比较更丰富的一个例子"></a>Integer比较更丰富的一个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"i1=i2   "</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">"i1=i2+i3   "</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">"i1=i4   "</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">"i4=i5   "</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">"i4=i5+i6   "</span> + (i4 == i5 + i6));   </span><br><span class="line">System.out.println(<span class="string">"40=i5+i6   "</span> + (<span class="number">40</span> == i5 + i6));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    i1=i2   true</span></span><br><span class="line"><span class="comment">    i1=i2+i3   true</span></span><br><span class="line"><span class="comment">    i1=i4   false</span></span><br><span class="line"><span class="comment">    i4=i5   false</span></span><br><span class="line"><span class="comment">    i4=i5+i6   true</span></span><br><span class="line"><span class="comment">    40=i5+i6   true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>语句<code>i4 == i5 + i6</code>，因为<code>+</code>这个操作符不适用于<code>Integer</code>对象，首先<code>i5</code>和<code>i6</code>进行自动拆箱操作，进行数值相加，即<code>i4 == 40</code>。然后<code>Integer</code>对象无法与数值进行直接比较，所以<code>i4</code>自动拆箱转为<code>int</code>值<code>40</code>，最终这条语句转为<code>40 == 40</code>进行数值比较。</p><h2 id="String类和常量池"><a href="#String类和常量池" class="headerlink" title="String类和常量池"></a>String类和常量池</h2><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>英文名字：<code>String Pool</code>，字符串常量池的本质是一个<code>StringTable</code>类（它是一个<code>HashSet</code>）。这个<code>StringTable</code>在每个HotSpot VM的实例只有一份，被所有的类共享。但它只存储运行时常量池里<code>String</code>对象的引用，而不存储<code>String</code>对象的内容，根据这个引用可以得到具体的<code>String</code>对象。注意，字符串常量池是字符串类维护的。字符串常量池只是为了加快<code>String</code>类型常量的检索。</p><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p>String.intern() 是一个 Native 方法，JDK对它的解释是（水平有限，不再翻译）：</p><blockquote><p>A pool of strings, initially empty, is maintained privately by the class String. When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.<br>It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.<br>All literal strings and string-valued constant expressions are interned.</p></blockquote><p>大致意思是：如果字符串常量池中已经有了这个字符串，那么直接返回字符串常量池中的它的引用，如果没有，那就将它的引用保存一份到字符串常量池，然后直接返回这个引用。判断字符串是否相等使用<code>equals</code>方法。</p><h3 id="字面量进入字符串常量池的时机"><a href="#字面量进入字符串常量池的时机" class="headerlink" title="字面量进入字符串常量池的时机"></a>字面量进入字符串常量池的时机</h3><p>就HotSpot VM的实现来说，在加载类的时候，字符串字面量会进入当前类的运行时常量池，不会进入<code>String Pool</code>。加载类的时候，没有解析字符串字面量，等到执行ldc指令的时候就会触发这个解析的动作。解析指符号引用替换为直接引用的过程，参见：<a href="https://isjinhao.github.io/2019/%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8/#more">https://isjinhao.github.io/2019/%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8/#more</a></p><p>ldc指令的语义是：到当前类的运行时常量池（<code>Runtime Constant Pool</code>）去查找该index对应的项，如果该项尚未resolve则resolve之，并返回resolve后的内容。 在遇到String类型常量时，resolve的过程如果发现<code>StringTable</code>已经有了内容匹配的<code>java.lang.String</code>的引用，则直接返回这个引用，反之，如果<code>StringTable</code>里尚未有内容匹配的<code>String</code>实例的引用，则会在<code>Java</code>堆里创建一个对应内容的<code>String</code>对象，然后在StringTable记录下这个引用，并返回这个引用出去。</p><p>可见，ldc指令是否需要创建新的<code>String</code>实例，全看在第一次执行这一条ldc指令时，StringTable是否已经记录了一个对应内容的<code>String</code>的引用。</p><h3 id="字符串常量池中有哪些字符串的引用"><a href="#字符串常量池中有哪些字符串的引用" class="headerlink" title="字符串常量池中有哪些字符串的引用"></a>字符串常量池中有哪些字符串的引用</h3><ul><li>由字面量创建的String在字符串常量池中都有一份引用</li><li>被<code>new</code>出来的对象调用intern()方法后再字符串常量池中才有一份引用</li></ul><h3 id="获得String对象"><a href="#获得String对象" class="headerlink" title="获得String对象"></a>获得String对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abcd"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li><p>直接使用双引号声明出来的 String 对象会直接存储在常量池中。使用双引号声明时会调用ldc命令，所以其检查的是字符串常量池。</p></li><li><p>对于<code>new String()</code>则会在堆中创建一个String对象，并返回该对象的引用。</p><blockquote><p>Initializes a newly created String object so that it represents the same sequence of characters as the argument; in other words, the newly created string is a copy of the argument string. Unless an explicit copy of original is needed, use of this constructor is unnecessary since Strings are immutable.</p></blockquote></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><ul><li><p>Q：<code>String s = new String(&quot;123&quot;);</code>定义了几个对象。</p></li><li><p>A：若常量池中已经存在”123”，则直接引用，也就是此时只会创建一个对象，如果常量池中不存”123”，则先创建后将在堆中创建”123”的一份拷贝，并把这个拷贝的引用返回。此时字符串常量池中有”123“的引用。</p></li></ul><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Hollis"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"Hollis"</span>);</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"Hollis"</span>).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><div align="center"><img src="/2019/常量池和String/例2.jpg" style="width:80%"></div><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">String s2 = <span class="string">"1"</span>;</span><br><span class="line">s.intern();</span><br><span class="line">System.out.println(s == s2);<span class="comment">//false</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"2"</span>);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = <span class="string">"12"</span>;</span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：常量池中有&quot;1&quot;，堆中有字符串&quot;1&quot;，字符串常量池中是常量池中&quot;1&quot;的引用，s是堆中的引用</span><br><span class="line">2：在字符串常量池中检索，有&quot;1&quot;，则得到常量池中&quot;1&quot;的引用</span><br><span class="line">5：常量池中有&quot;1&quot;，&quot;2&quot;。new String(&quot;1&quot;) + new String(&quot;2&quot;);的底层是使用StringBuffer的append方法将&quot;2&quot;和&quot;2&quot;拼接在一块，然后调用toString方法new出“22”；所以此时的“22”字符串是创建在堆区的；</span><br><span class="line">6：在字符串常量池中检索，没有&quot;22&quot;，把堆中该对象的引用放在字符串常量池中</span><br><span class="line">7：检查字符串常量池，有&quot;2&quot;的引用，指向堆</span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;  </span><br><span class="line">String s2=s1.intern();  </span><br><span class="line">System.out.println(s1==s1.intern());    <span class="comment">//true </span></span><br><span class="line">System.out.println(s2==s1.intern());</span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：堆中有&quot;xyz&quot;，常量池中有&quot;xy&quot;，&quot;z&quot;</span><br><span class="line">2：把堆中的&quot;xyz&quot;的引用存在字符串常量池中。</span><br><span class="line">3：都指向堆中</span><br><span class="line">4：都指向堆中</span><br></pre></td></tr></table></figure><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">"xyz"</span>) ;  </span><br><span class="line">String s2=s1.intern();  </span><br><span class="line">System.out.println(s1==s1.intern());  <span class="comment">//false</span></span><br><span class="line">System.out.println(s2==s1.intern());  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：常量池中有&quot;xyz&quot;，堆中有&quot;xyz&quot;</span><br><span class="line">2：s2指向常量池中的&quot;xyz&quot;</span><br><span class="line">3：s1.intern()指向常量池，s1指向堆</span><br><span class="line">4：s2指向堆</span><br></pre></td></tr></table></figure><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"xy"</span> + <span class="string">"z"</span>;</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println( s1==s1.intern() );  <span class="comment">//true</span></span><br><span class="line">System.out.println( s2==s1.intern() );  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：编译期可以确定s1是&quot;xyz&quot;，所以编译器会优化。在常量池中有&quot;xyz&quot;</span><br><span class="line">2：s2指向常量池中的&quot;xyz&quot;</span><br><span class="line">3：都指向常量池中的&quot;xyz&quot;</span><br><span class="line">4：都指向常量池中的&quot;xyz&quot;</span><br></pre></td></tr></table></figure><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;  </span><br><span class="line">String s3 = <span class="string">"xyz"</span>;</span><br><span class="line">String s2=s1.intern();  </span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">System.out.println(s2 == s3);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1==s1.intern());<span class="comment">//false</span></span><br><span class="line">System.out.println(s2==s1.intern()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1：堆中有&quot;xyz&quot;，常量池中有&quot;xy&quot;和&quot;z&quot;，s1指向堆中的&quot;xyz&quot;</span><br><span class="line">2：检索字符串常量池，没有&quot;xyz&quot;，在常量池中创建&quot;xyz&quot;，s3指向常量池中的&quot;xyz&quot;</span><br><span class="line">3：字符串常量池有&quot;xyz&quot;的引用，且指向常量池，s2指向常量池中&quot;xyz&quot;</span><br><span class="line">4：s1指向堆中的&quot;xyz&quot;，s2指向常量池中&quot;xyz&quot;</span><br><span class="line">5：s1指向堆中的&quot;xyz&quot;，s3指向常量池中的&quot;xyz&quot;</span><br><span class="line">6：都指向常量池中&quot;xyz&quot;</span><br><span class="line">7：s1指向堆中的&quot;xyz&quot;，s1==s1.intern指向常量池中的&quot;xyz&quot;</span><br><span class="line">8：s2指向常量池中&quot;xyz&quot;，s1==s1.intern指向常量池中的&quot;xyz&quot;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/wangbiao007/article/details/78545189" target="_blank" rel="noopener">https://blog.csdn.net/wangbiao007/article/details/78545189</a></li><li><a href="https://blog.csdn.net/Mypromise_TFS/article/details/81504137" target="_blank" rel="noopener">https://blog.csdn.net/Mypromise_TFS/article/details/81504137</a></li><li><a href="https://www.zhihu.com/question/55994121" target="_blank" rel="noopener">https://www.zhihu.com/question/55994121</a></li><li>深入理解JVM第二版</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h2&gt;&lt;p&gt;常量池及S
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="https://isjinhao.github.io/2019/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://isjinhao.github.io/2019/Java内存模型/</id>
    <published>2019-03-30T07:48:32.000Z</published>
    <updated>2019-03-31T12:10:36.472Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM则是JRE中的核心组成部分，承担分析和执行Java字节码的工作。在Java历史上有很多发行的Java虚拟机，但目前一般都是<code>HotSpot</code>。查看本机JVM：<code>java -version</code></p><div align="center"><img src="/2019/Java内存模型/查看JVM.jpg" style="width:80%"></div><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>Java虚拟机在执行Java程序的时候会把它所管理的内存区域划分为若干个不同的数据区域。根据JVM规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。</p><h2 id="运行时数据区划分"><a href="#运行时数据区划分" class="headerlink" title="运行时数据区划分"></a>运行时数据区划分</h2><h3 id="JDK6"><a href="#JDK6" class="headerlink" title="JDK6"></a>JDK6</h3><div align="center"><img src="/2019/Java内存模型/1.6内存模型.jpg" style="width:60%"></div><h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><div align="center"><img src="/2019/Java内存模型/1.8内存模型.jpg" style="width:60%"></div><h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p><strong>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p><strong>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息）</p><p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向一条字节码指令的地址）。</p><p><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong></p><ul><li><p><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</p></li><li><p><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</p></li></ul><p>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><p><strong>扩展：那么方法/函数如何调用？</strong></p><p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>Java方法有两种返回方式：</p><ul><li><p>return 语句。</p></li><li><p>抛出异常。</p></li></ul><p>不管哪种返回方式都会导致栈帧被弹出。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p><h3 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h3><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代。再细致一点有：<code>Eden空间</code>、<code>From Survivor</code>、<code>To Survivor</code>空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TwVibBF785ic5RU2iafKlnVEsC7XwTj6XECpS7ibPzdgmc3pqrvwf99HymgMU9xJnAMfsicDsuY1XxVlug/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>上图所示的eden区、s0区、s1区都属于新生代，tentired区属于老年代。大部分情况，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0或者s1，并且对象的年龄还会加 1（<code>Eden区-&gt;Survivor</code> 区后对象的初始年龄变为1），当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p><strong>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</strong></p><p>HotSpot 虚拟机中方法区也常被称为 <strong>“永久代”</strong>，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p><p><strong>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</strong></p><p>JDK 1.8 的时候，方法区被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p>我们可以使用参数： <code>-XX:MetaspaceSize</code> 来指定元数据区的大小。与永久区很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p><ul><li>字面量就是指这个量本身，比如字面量3。也就是指3. 再比如 string类型的字面量”ABC”, 这个”ABC” 通过字来描述。 可以理解成一眼就能知道的量。</li></ul><p>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><p><strong>JDK1.8及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。</strong></p><p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p><h4 id="为什么永久代向元空间的转换"><a href="#为什么永久代向元空间的转换" class="headerlink" title="为什么永久代向元空间的转换"></a>为什么永久代向元空间的转换</h4><ul><li><p>字符串存在永久代中，容易出现性能问题和内存溢出。</p></li><li><p>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p></li><li><p>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p></li></ul><h2 id="类的各个部分分别在哪个位置"><a href="#类的各个部分分别在哪个位置" class="headerlink" title="类的各个部分分别在哪个位置"></a>类的各个部分分别在哪个位置</h2><ul><li>字节码：方法区</li><li>字节码对象：堆</li><li>普通对象：大部分存在于堆。更多参考：<a href="https://blog.csdn.net/rickiyeat/article/details/76802085" target="_blank" rel="noopener">https://blog.csdn.net/rickiyeat/article/details/76802085</a></li><li>对象的属性：大部分存在于堆</li><li>static属性：常量池</li><li>方法：方法区</li><li>方法中的局部变量：Java虚拟机栈</li><li>String对象：堆或常量池</li><li>final属性：常量池</li></ul><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><div align="center"><img src="/2019/Java内存模型/对象的创建.jpg" style="width:80%"></div><ul><li><p><strong>类加载检查：</strong> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p></li><li><p><strong>分配内存：</strong> 在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p></li></ul><h3 id="内存分配的两种方式"><a href="#内存分配的两种方式" class="headerlink" title="内存分配的两种方式"></a><strong>内存分配的两种方式</strong></h3><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。详细可参考：深入理解Java虚拟机第二版第三章。</p><ul><li>指针碰撞：假设JAVA堆中的内存时绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式成为“指针碰撞”。</li><li>空闲链表：如果JAVA堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式成为“空闲列表”。</li><li><strong>初始化零值：</strong> 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>设置对象头：</strong> 初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li><li><strong>执行 init 方法：</strong> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li></ul><h3 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a><strong>内存分配并发问题</strong></h3><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，否则比如当虚拟机正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存就会引发严重的问题。通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在Eden区分配一块儿内存，称为本地线程分配缓存（Thread Local Allocation Buffer，TLAB），JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。</li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为3块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的自身运行时数据</strong>（哈希码、GC分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种：</p><ul><li><strong>句柄：</strong> 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li></ul><div align="center"><img src="/2019/Java内存模型/句柄.jpg" style="width:80%"></div><ul><li><strong>直接指针</strong>：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</li></ul><div align="center"><img src="/2019/Java内存模型/指针.jpg" style="width:80%"></div><p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485068&amp;idx=1&amp;sn=c37267fe59978dbfcd6a9a54eee1c502&amp;chksm=cea24947f9d5c051008233a6a938e802b710ccf919f4215f84dcc0bf1fdad7d0101d37497d33&amp;xtrack=1&amp;scene=0&amp;subscene=131&amp;clicktime=1553930626&amp;ascene=7&amp;devicetype=android-27&amp;version=2700033c&amp;nettype=cmnet&amp;abtest_cookie=BQABAAgACgALABIAEwAGAJ%2BGHgAjlx4AVpkeAM%2BZHgDamR4A3JkeAAAA&amp;lang=zh_CN&amp;pass_ticket=G969oFWgvfNjcImZ43XVMVLnTmWNWI4qDunqFFIS7NA%3D&amp;wx_header=1" target="_blank" rel="noopener">JavaGuide</a></p></li><li><p>深入理解Java虚拟机</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h2&gt;&lt;p&gt;J
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于winpcap的cpp控制台网络协议分析</title>
    <link href="https://isjinhao.github.io/2019/%E5%9F%BA%E4%BA%8Ewinpcap%E7%9A%84cpp%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    <id>https://isjinhao.github.io/2019/基于winpcap的cpp控制台网络协议分析/</id>
    <published>2019-03-28T06:59:27.000Z</published>
    <updated>2019-03-30T01:31:08.780Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h3><ul><li>winpcap4.1.3</li><li>vs2015</li></ul><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><ul><li><code>新建项目-&gt;Visual C++项目-&gt;Win32控制台项目</code>，在<code>Win32应用程序向导</code>窗口中的<code>应用程序设置-&gt;附加选项</code>选中<code>空项目</code>。</li><li>将<code>WinPcap</code>开发包中的Include和Lib两个文件夹复制到新建项目所在文件夹下。</li><li>点击项目，右击，然后点击属性<ul><li><code>C/C++-&gt;常规-&gt;附加包含目录</code>：如 ..\include</li><li><code>链接器-&gt;常规-&gt;附加库目录</code>：如 ..\lib</li><li><code>链接器-&gt;输入-&gt;附加依赖项</code>：wpcap.lib（winpcap的包），ws2_32.lib（windows的socket）</li></ul></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pcap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">eth_address</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_char byte1;</span><br><span class="line">u_char byte2;</span><br><span class="line">u_char byte3;</span><br><span class="line">u_char byte4;</span><br><span class="line">u_char byte5;</span><br><span class="line">u_char byte6;</span><br><span class="line">&#125;eth_address;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4 bytes IP address */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_address</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_char byte1;</span><br><span class="line">u_char byte2;</span><br><span class="line">u_char byte3;</span><br><span class="line">u_char byte4;</span><br><span class="line">&#125;ip_address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IPv4 header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_charver_ihl;<span class="comment">// Version (4 bits) + Internet header length (4 bits)</span></span><br><span class="line">u_chartos;<span class="comment">// Type of service </span></span><br><span class="line">u_short tlen;<span class="comment">// Total length </span></span><br><span class="line">u_short identification; <span class="comment">// Identification</span></span><br><span class="line">u_short flags_fo;<span class="comment">// Flags (3 bits) + Fragment offset (13 bits)</span></span><br><span class="line">u_charttl;<span class="comment">// Time to live</span></span><br><span class="line">u_charproto;<span class="comment">// Protocol</span></span><br><span class="line">u_short crc;<span class="comment">// Header checksum</span></span><br><span class="line">ip_addresssaddr;<span class="comment">// Source address</span></span><br><span class="line">ip_addressdaddr;<span class="comment">// Destination address</span></span><br><span class="line">u_intop_pad;<span class="comment">// Option + Padding</span></span><br><span class="line">&#125;ip_header;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UDP header*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">udp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_short sport;<span class="comment">// Source port</span></span><br><span class="line">u_short dport;<span class="comment">// Destination port</span></span><br><span class="line">u_short len;<span class="comment">// Datagram length</span></span><br><span class="line">u_short crc;<span class="comment">// Checksum</span></span><br><span class="line">&#125;udp_header;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MAC header*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">eth_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">eth_address daddr;</span><br><span class="line">eth_address saddr;</span><br><span class="line">u_short type;</span><br><span class="line">&#125;eth_header;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_short hardtype;<span class="comment">//硬件类型字段</span></span><br><span class="line">u_short prototype;<span class="comment">//协议类型字段</span></span><br><span class="line">u_char htlen;<span class="comment">//硬件地址的长度,以字节为单位.对于以太网上IP地址的ARP请求或应答来说,它们的值为6</span></span><br><span class="line">u_char ptlen;<span class="comment">//协议地址的长度,以字节为单位.对于以太网上IP地址的ARP请求或应答来说,它们的值为4</span></span><br><span class="line">u_short op;<span class="comment">//操作字段</span></span><br><span class="line">eth_address arp_esa;<span class="comment">//发送端MAC地址</span></span><br><span class="line">ip_address arp_isa;<span class="comment">//发送端IP地址</span></span><br><span class="line">eth_address arp_eda;<span class="comment">//目的端MAC地址</span></span><br><span class="line">ip_address arp_ida;<span class="comment">//目的端IP地址</span></span><br><span class="line">&#125;arp_header;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">icmp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_char type;<span class="comment">//ICMP报文类型</span></span><br><span class="line">u_char code;<span class="comment">//代码</span></span><br><span class="line">u_short checksum;<span class="comment">//校验和</span></span><br><span class="line">u_short identifier;<span class="comment">//标识符</span></span><br><span class="line">u_short sequence_number;<span class="comment">//序列号</span></span><br><span class="line">&#125;icmp_header;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TCP header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_shortsport;<span class="comment">//源端口</span></span><br><span class="line">u_short dport;<span class="comment">//目的端口</span></span><br><span class="line">u_long  sequence_number;<span class="comment">//序号（4字节ntohl）  </span></span><br><span class="line">u_long  acknowlegement_number;<span class="comment">//确认号</span></span><br><span class="line">u_short hlen_bl_flags;<span class="comment">//数据偏移+保留+控制位</span></span><br><span class="line">u_short window_size;<span class="comment">//窗口（发送方自己的接收窗口）</span></span><br><span class="line">u_short checksum;<span class="comment">//检验和（首部+数据）</span></span><br><span class="line">u_short urg;<span class="comment">//紧急指针</span></span><br><span class="line">u_long  option;<span class="comment">//可选+填充</span></span><br><span class="line">&#125;tcp_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dns_packet</span> //报文<span class="title">head</span>+<span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u_short id;<span class="comment">//每一个占2个字节，共12个字节</span></span><br><span class="line">    u_short flags;<span class="comment">//标志第一个为0代表查询报文</span></span><br><span class="line">    u_short ques;</span><br><span class="line">    u_short answer;</span><br><span class="line">    u_short author;</span><br><span class="line">    u_short addition;</span><br><span class="line">    u_char dns_data;<span class="comment">//查询问题部分</span></span><br><span class="line">&#125;dns_packet;</span><br></pre></td></tr></table></figure><h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pcap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers.c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DNSPORT 53</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出基本信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintBaseInfo</span><span class="params">(<span class="keyword">const</span> struct pcap_pkthdr *header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">ltime</span>;</span></span><br><span class="line"><span class="keyword">char</span> timestr[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">time_t</span> local_tv_sec;</span><br><span class="line"></span><br><span class="line">local_tv_sec = header-&gt;ts.tv_sec;</span><br><span class="line">ltime=localtime(&amp;local_tv_sec);</span><br><span class="line">strftime(timestr, <span class="keyword">sizeof</span> timestr, <span class="string">"%H:%M:%S"</span>, ltime);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n\n\n监听到Mac帧的时间：%s   MAC帧长度:%d Byte(s)\n"</span>, timestr, header-&gt;len * <span class="number">4</span>);  <span class="comment">/* 以四字节为单位 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出硬件地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintEthAddress</span><span class="params">(eth_address eth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02X:%02X:%02X:%02X:%02X:%02X"</span>, </span><br><span class="line">eth.byte1,</span><br><span class="line">eth.byte2,</span><br><span class="line">eth.byte3,</span><br><span class="line">eth.byte4,</span><br><span class="line">eth.byte5,</span><br><span class="line">eth.byte6</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出IP地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintIPAddress</span><span class="params">(ip_address ia)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d.%d.%d.%d"</span>, </span><br><span class="line">ia.byte1,</span><br><span class="line">ia.byte2,</span><br><span class="line">ia.byte3,</span><br><span class="line">ia.byte4</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出网络层协议类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintNetType</span><span class="params">(u_short type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"网络层协议： "</span>);</span><br><span class="line"><span class="keyword">if</span>(type==<span class="number">0x0800</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"IP协议"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">0x0806</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ARP协议"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">0x8035</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"RARP协议"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"接收到非本程序能处理的网络层协议类型！"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析Mac帧：</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">网络层协议类型：源MAC -&gt; 目的MAC</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">网络层协议类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u_short <span class="title">handleMac</span><span class="params">(eth_header *eth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short type=ntohs(eth-&gt;type);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Mac地址： "</span>);</span><br><span class="line">myPrintEthAddress(eth-&gt;saddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-&gt;"</span>);</span><br><span class="line">myPrintEthAddress(eth-&gt;daddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleARPAndRARP</span><span class="params">(arp_header *ah)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short arp_ht;<span class="comment">//硬件地址的类型.它的值为1即表示以太网地址</span></span><br><span class="line">u_short arp_pt;<span class="comment">//要映射的协议地址类型.它的值为0x0800，即表示IP地址</span></span><br><span class="line">u_short arp_op;<span class="comment">//四种操作类型,它们是ARP请求(值为1)、ARP应答(值为2)、RARP请求(值为3)和RARP应答(值为4)</span></span><br><span class="line">arp_ht=ntohs(ah-&gt;hardtype);<span class="comment">//硬件地址的类型.它的值为1即表示以太网地址</span></span><br><span class="line">arp_pt=ntohs(ah-&gt;prototype);<span class="comment">//要映射的协议地址类型.它的值为0x0800，即表示IP地址</span></span><br><span class="line">arp_op=ntohs(ah-&gt;op);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"硬件地址类型为：%d\t\t\t"</span>,arp_ht);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"协议地址类型为：0x%04X\n"</span>,arp_pt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"硬件地址长度为：%d\t\t\t"</span>,ah-&gt;htlen);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"协议地址长度为：%d\n"</span>,ah-&gt;ptlen);</span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：ARP请求报文。\n本机Mac地址："</span>);</span><br><span class="line">myPrintEthAddress(ah-&gt;arp_esa);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t正在请求"</span>);</span><br><span class="line">myPrintIPAddress(ah-&gt;arp_ida);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"的Mac地址\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：ARP应答报文。\n应答方的Mac地址："</span>);</span><br><span class="line">myPrintEthAddress(ah-&gt;arp_eda);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t应答方的IP地址"</span>);</span><br><span class="line">myPrintIPAddress(ah-&gt;arp_ida);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">3</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：RARP请求报文\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">4</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：RARP应答报文\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> all_ip_len = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">u_short <span class="title">handleIP</span><span class="params">(ip_header *ih)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_int ip_ver;<span class="comment">//版本</span></span><br><span class="line">u_int ip_len;<span class="comment">//首部长度</span></span><br><span class="line">u_short ip_tlen;    <span class="comment">//总长度</span></span><br><span class="line">u_short ip_ident;<span class="comment">//标识</span></span><br><span class="line">u_short ip_flag_fo; <span class="comment">//标志和片偏移</span></span><br><span class="line">u_int ip_flag;<span class="comment">//标志（3位，值为2还有分片且允许分片,1不能分片,0没有分片且允许分片）</span></span><br><span class="line">u_int ip_fo;<span class="comment">//片偏移</span></span><br><span class="line">u_short ip_type;<span class="comment">//协议</span></span><br><span class="line">u_short ip_crc;<span class="comment">//首部检验和</span></span><br><span class="line">u_long ip_op_pad;<span class="comment">//可选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* retireve the position of the ip header */</span><span class="comment">//检索IP首部的位置</span></span><br><span class="line">ip_ver = (ih-&gt;ver_ihl &gt;&gt; <span class="number">4</span>);<span class="comment">//版本</span></span><br><span class="line">ip_len = (ih-&gt;ver_ihl &amp; <span class="number">0xf</span>) * <span class="number">4</span>;<span class="comment">//首部长度，与运算，可以只取ip头部的版本长度字段的后4位</span></span><br><span class="line">ip_tlen=ntohs(ih-&gt;tlen);<span class="comment">//总长度</span></span><br><span class="line">ip_ident=ntohs(ih-&gt;identification);<span class="comment">//标识</span></span><br><span class="line">ip_flag_fo = ntohs(ih-&gt;flags_fo);<span class="comment">//2字节存放，会有字节序问题</span></span><br><span class="line">ip_flag = (ip_flag_fo &gt;&gt; <span class="number">13</span>);<span class="comment">//标志</span></span><br><span class="line">ip_fo = (ip_flag_fo &amp; <span class="number">0x1fff</span>);<span class="comment">//片偏移</span></span><br><span class="line">ip_type = ih-&gt;proto;<span class="comment">//上层协议类型</span></span><br><span class="line">ip_crc = ntohs(ih-&gt;crc);<span class="comment">//首部校验和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印IP数据报首部*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"版本：%d\t\t\t"</span>,ip_ver);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部长度：%d\n"</span>,ip_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"区分服务：%d\t\t"</span>, ih-&gt;tos);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"总长度：%d\n"</span>, ip_tlen);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标识：%d\t\t"</span>, ip_ident);</span><br><span class="line"><span class="keyword">if</span> (ip_flag == <span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：DF=1（不能分片），MF=0（没有后续分片）\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (ip_flag == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：DF=0（允许分片），MF=1（还有后续分片）\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (ip_flag == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：DF=0（允许分片），MF=0（没有后续分片）\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"片偏移：%d\t\t"</span>,ip_fo*<span class="number">8</span>);<span class="comment">//片偏移以8字节为单位</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"生存时间：%d\n"</span>,ih-&gt;ttl);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"协议：%d\t\t\t"</span>,ih-&gt;proto);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部校验和：%d\n"</span>,ip_crc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"IP地址：  "</span>);</span><br><span class="line"></span><br><span class="line">myPrintIPAddress(ih-&gt;saddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" -&gt; "</span>);</span><br><span class="line">myPrintIPAddress(ih-&gt;daddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (ip_len == <span class="number">20</span>)<span class="comment">//IP首部长度&gt;20时才有</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部长度为20，IP报文首部没有可选字段。\n"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ip_op_pad = ntohl(ih-&gt;op_pad);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"可选自段内容为：%u\n"</span>, ip_op_pad);</span><br><span class="line">&#125;</span><br><span class="line">all_ip_len = ip_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ip_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleICMP</span><span class="params">(icmp_header *ich)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short icmp_checksum;<span class="comment">//校验和</span></span><br><span class="line">u_short icmp_ident;<span class="comment">//标识符</span></span><br><span class="line">u_short icmp_seqnum;<span class="comment">//序列号</span></span><br><span class="line"></span><br><span class="line">icmp_checksum = ntohs(ich-&gt;checksum);<span class="comment">//校验和</span></span><br><span class="line">icmp_ident = ntohs(ich-&gt;identifier);<span class="comment">//标识符</span></span><br><span class="line">icmp_seqnum = ntohs(ich-&gt;sequence_number);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n运输层协议：  ICMP协议\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印ICMP报文首部*/</span></span><br><span class="line"><span class="keyword">if</span> (ich-&gt;type == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ICMP类型：回显应答\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ich-&gt;type == <span class="number">8</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ICMP类型：回显请求\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ICMP类型：其他\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"代码：%d\t\t"</span>,ich-&gt;code);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"校验和：%d\n"</span>,icmp_checksum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标识符：%d\t\t"</span>,icmp_ident);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"序列号：%d\n"</span>,icmp_seqnum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u_int udp_len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handleUDP</span><span class="params">(udp_header *uh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short sport, dport;<span class="comment">//端口</span></span><br><span class="line">u_short uh_len; <span class="comment">//长度</span></span><br><span class="line">u_short uh_crc; <span class="comment">//校验和</span></span><br><span class="line"></span><br><span class="line">sport = ntohs( uh-&gt;sport );<span class="comment">//源端口</span></span><br><span class="line">dport = ntohs( uh-&gt;dport );<span class="comment">//目的端口</span></span><br><span class="line">uh_len = ntohs(uh-&gt;len);<span class="comment">//长度</span></span><br><span class="line">uh_crc = ntohs(uh-&gt;crc);<span class="comment">//校验和</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n运输层协议：  UDP协议\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"端口号：%d -&gt; %d\n"</span>, sport, dport);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"长度：%d\t\t"</span>, uh_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"校验和：%d\n"</span>, uh_crc);</span><br><span class="line"></span><br><span class="line">udp_len = uh_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sport == DNSPORT || dport == DNSPORT)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleTCP</span><span class="params">(tcp_header *th)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_shorttcp_sport;<span class="comment">//源端口</span></span><br><span class="line">u_short tcp_dport;<span class="comment">//目的端口</span></span><br><span class="line">u_long  tcp_seqnum;<span class="comment">//序号（4字节ntohl）  </span></span><br><span class="line">u_long  tcp_acknum;<span class="comment">//确认号</span></span><br><span class="line">u_short tcp_hlen_bl_flags;<span class="comment">//数据偏移+保留+控制位</span></span><br><span class="line">u_short  tcp_hlen;</span><br><span class="line">u_short  tcp_bl;</span><br><span class="line">u_short  tcp_flags_urg;<span class="comment">//紧急1有效 </span></span><br><span class="line">u_short  tcp_flags_ack;<span class="comment">//确认=1时，确认号有效</span></span><br><span class="line">u_short  tcp_flags_psh;<span class="comment">//推送1有效，可以不用填满缓存就发报</span></span><br><span class="line">u_short  tcp_flags_rst;<span class="comment">//复位1有效，重新建立连接</span></span><br><span class="line">u_short  tcp_flags_syn;<span class="comment">//同步syn=1,ack=0时，表明这是一个连接请求报文；syn=1,ack=1,接受连接请求</span></span><br><span class="line">u_short  tcp_flags_fin;<span class="comment">//释放连接=1时，表示数据报</span></span><br><span class="line">u_short tcp_window_size;<span class="comment">//窗口（发送方自己的接收窗口）</span></span><br><span class="line">u_short tcp_checksum;<span class="comment">//检验和（首部+数据）</span></span><br><span class="line">u_short tcp_urg;<span class="comment">//紧急指针</span></span><br><span class="line">u_long tcp_option;</span><br><span class="line"></span><br><span class="line">tcp_sport=ntohs(th-&gt;sport);<span class="comment">//源端口</span></span><br><span class="line">tcp_dport=ntohs(th-&gt;dport);<span class="comment">//目的端口</span></span><br><span class="line">tcp_seqnum=ntohl(th-&gt;sequence_number);<span class="comment">//序号（4字节ntohl）  </span></span><br><span class="line">tcp_acknum=ntohl(th-&gt;acknowlegement_number);<span class="comment">//确认号</span></span><br><span class="line">tcp_hlen_bl_flags=ntohs(th-&gt;hlen_bl_flags);<span class="comment">//数据偏移4+保留6+控制位6</span></span><br><span class="line">tcp_hlen=(tcp_hlen_bl_flags &gt;&gt; <span class="number">12</span>)*<span class="number">4</span>;<span class="comment">//以4字节为单位</span></span><br><span class="line">tcp_bl=(tcp_hlen_bl_flags &amp; <span class="number">0x0fc0</span>);<span class="comment">//保留</span></span><br><span class="line">tcp_flags_urg=(tcp_hlen_bl_flags &amp; <span class="number">0x0020</span>);<span class="comment">//紧急1有效                                                    ----- </span></span><br><span class="line">tcp_flags_ack=(tcp_hlen_bl_flags &amp; <span class="number">0x0010</span>);<span class="comment">//确认=1时，确认号有效</span></span><br><span class="line">tcp_flags_psh=(tcp_hlen_bl_flags &amp; <span class="number">0x0008</span>);<span class="comment">//推送1有效，可以不用填满缓存就发报</span></span><br><span class="line">tcp_flags_rst=(tcp_hlen_bl_flags &amp; <span class="number">0x0004</span>);<span class="comment">//复位1有效，重新建立连接</span></span><br><span class="line">tcp_flags_syn=(tcp_hlen_bl_flags &amp; <span class="number">0x0002</span>);<span class="comment">//同步syn=1,ack=0时，表明这是一个连接请求报文；syn=1,ack=1,接受连接请求</span></span><br><span class="line">tcp_flags_fin=(tcp_hlen_bl_flags &amp; <span class="number">0x0001</span>);<span class="comment">//释放连接=1时，表示数据报</span></span><br><span class="line">tcp_window_size=ntohs(th-&gt;window_size);<span class="comment">//窗口（发送方自己的接收窗口）</span></span><br><span class="line">tcp_checksum=ntohs(th-&gt;checksum);<span class="comment">//检验和（首部+数据）</span></span><br><span class="line">tcp_urg=ntohs(th-&gt;urg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n运输层协议：  TCP协议\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印TCP数据报首部*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"端口号：%d -&gt; %d\n"</span>,tcp_sport,tcp_dport);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"序号：%u\t"</span>,tcp_seqnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"确认号：%u\n"</span>,tcp_acknum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数据偏移：%d\t\t"</span>,tcp_hlen);<span class="comment">//首部长度</span></span><br><span class="line"><span class="comment">//printf("保留：%d\n",tcp_bl);</span></span><br><span class="line"><span class="comment">/*控制字段,标志位*/</span></span><br><span class="line"><span class="keyword">if</span> (tcp_flags_urg == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：URG\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_ack == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：ACK\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_psh == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：PSH\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_rst == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：RST\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_syn == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：SYN\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_fin == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：FIN\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"窗口：%d\t\t"</span>,tcp_window_size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"检验和：%d\n"</span>,tcp_checksum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"紧急指针：%d\t\t"</span>,tcp_urg);<span class="comment">//URG=1时才有用，窗口大小为0也能发送</span></span><br><span class="line"><span class="keyword">if</span>(tcp_hlen == <span class="number">20</span>)<span class="comment">//数据偏移(TCP首部长度)&gt;20时才有</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部长度为20字节，没有填充字段。\n"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tcp_option = ntohl(th-&gt;option);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"填充字段:%u\n"</span>, tcp_option);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Callback function invoked by libpcap for every incoming packet */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_handler</span><span class="params">(u_char *param, <span class="keyword">const</span> struct pcap_pkthdr *header, <span class="keyword">const</span> u_char *pkt_data)</span>   <span class="comment">//param 无用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">eth_header *eth;</span><br><span class="line">u_short macType;</span><br><span class="line"></span><br><span class="line">myPrintBaseInfo(header);</span><br><span class="line"></span><br><span class="line">eth=(eth_header *) (pkt_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤以太网头部</span></span><br><span class="line">pkt_data += <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HandleMac</span></span><br><span class="line">macType=handleMac(eth);</span><br><span class="line">myPrintNetType(macType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理ARP 和 RARP</span></span><br><span class="line"><span class="keyword">if</span>(macType==<span class="number">0x0806</span> || macType==<span class="number">0x8035</span>)</span><br><span class="line">&#123;</span><br><span class="line">arp_header *ap;</span><br><span class="line">ap = (arp_header *)(pkt_data);</span><br><span class="line">handleARPAndRARP(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理IP</span></span><br><span class="line"><span class="keyword">if</span>(macType==<span class="number">0x0800</span>)</span><br><span class="line">&#123;</span><br><span class="line">u_short ip_type;</span><br><span class="line">ip_header *ih;</span><br><span class="line">ih = (ip_header *) (pkt_data);</span><br><span class="line">ip_type = handleIP(ih);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ip_type == <span class="number">1</span>) &#123;</span><br><span class="line">icmp_header *ich;</span><br><span class="line">ich = (icmp_header *)((u_char*)ih + all_ip_len);</span><br><span class="line">handleICMP(ich);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">17</span>)&#123;</span><br><span class="line">udp_header *uh;</span><br><span class="line">uh = (udp_header *) ((u_char*)ih + all_ip_len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(handleUDP(uh))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct dns_packet *pdns;</span></span><br><span class="line"><span class="comment">pdns = (struct dns_packet *)(pkt_data + all_ip_len + udp_len); // sport+dport+length+checksum,DNS头指针</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">u_char *query=&amp;(pdns-&gt;dns_data);//定位到查询部分头部</span></span><br><span class="line"><span class="comment">printf("QueryDomain=");</span></span><br><span class="line"><span class="comment">u_char domainname[100]=&#123;0&#125;;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">u_int i=0;</span></span><br><span class="line"><span class="comment">//query++;//把点去了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while(*query)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf("%d", *query);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if(*query &lt; 0x10)//48以后出现数字和英文字母</span></span><br><span class="line"><span class="comment">printf(".");</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">printf("%c", *query);</span></span><br><span class="line"><span class="comment">query++;</span></span><br><span class="line"><span class="comment">i++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf("\n"); */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">6</span>)&#123;</span><br><span class="line">tcp_header *th;</span><br><span class="line">th=(tcp_header *) ((u_char*)ih + all_ip_len);</span><br><span class="line">handleTCP(th);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pcap_if_t</span> *alldevs;</span><br><span class="line"><span class="keyword">pcap_if_t</span> *d;</span><br><span class="line"><span class="keyword">int</span> inum;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">pcap_t</span> *adhandle;</span><br><span class="line"><span class="keyword">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line">u_int netmask;</span><br><span class="line"><span class="keyword">char</span> packet_filter[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析IP数据报输入：\t1\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析ARP数据报输入：\t2\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析TCP数据报输入：\t3\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析UDP数据报输入：\t4\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析ICMP数据报输入：\t5\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析MAC、IP、ARP、TCP、UDP、IMCP输入\t6\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">packet_filter = <span class="string">"ip"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)</span><br><span class="line">packet_filter = <span class="string">"arp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">packet_filter = <span class="string">"ip and tcp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">4</span>)</span><br><span class="line">packet_filter = <span class="string">"ip and udp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">5</span>)</span><br><span class="line">packet_filter = <span class="string">"ip and icmp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">packet_filter = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"InputError : check the number you input! exit(1)"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_program</span> <span class="title">fcode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pcap_findalldevs(&amp;alldevs, errbuf) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error in pcap_findalldevs: %s\n"</span>, errbuf);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(d=alldevs; d; d=d-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d. %s"</span>, ++i, d-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (d-&gt;description)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" (%s)\n"</span>, d-&gt;description);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" (No description available)\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter the interface number (1-%d):"</span>,i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;inum);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if the user specified a valid adapter */</span></span><br><span class="line"><span class="keyword">if</span>(inum &lt; <span class="number">1</span> || inum &gt; i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nAdapter number out of range.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Jump to the selected adapter */</span></span><br><span class="line"><span class="keyword">for</span>(d=alldevs, i=<span class="number">0</span>; i&lt; inum<span class="number">-1</span> ;d=d-&gt;next, i++);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open the adapter */</span></span><br><span class="line"><span class="keyword">if</span> ((adhandle= pcap_open_live(d-&gt;name,<span class="comment">// name of the device</span></span><br><span class="line"> <span class="number">65536</span>,<span class="comment">// portion of the packet to capture. </span></span><br><span class="line"><span class="comment">// 65536 grants that the whole packet will be captured on all the MACs.</span></span><br><span class="line"> <span class="number">1</span>,<span class="comment">// promiscuous mode (nonzero means promiscuous)</span></span><br><span class="line"> <span class="number">1000</span>,<span class="comment">// read timeout</span></span><br><span class="line"> errbuf<span class="comment">// error buffer</span></span><br><span class="line"> )) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the link layer. We support only Ethernet for simplicity. */</span></span><br><span class="line"><span class="keyword">if</span>(pcap_datalink(adhandle) != DLT_EN10MB)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nThis program works only on Ethernet networks.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(d-&gt;addresses != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">/* Retrieve the mask of the first address of the interface */</span></span><br><span class="line">netmask=((struct sockaddr_in *)(d-&gt;addresses-&gt;netmask))-&gt;sin_addr.S_un.S_addr;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">/* If the interface is without addresses we suppose to be in a C class network */</span></span><br><span class="line">netmask=<span class="number">0xffffff</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//compile the filter</span></span><br><span class="line"><span class="keyword">if</span> (pcap_compile(adhandle, &amp;fcode, packet_filter, <span class="number">1</span>, netmask) &lt;<span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nUnable to compile the packet filter. Check the syntax.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set the filter</span></span><br><span class="line"><span class="keyword">if</span> (pcap_setfilter(adhandle, &amp;fcode)&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nError setting the filter.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nlistening on %s...\n"</span>, d-&gt;description);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* At this point, we don't need any more the device list. Free it */</span></span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* start the capture */</span></span><br><span class="line">pcap_loop(adhandle, <span class="number">0</span>, packet_handler, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li><p>听到网卡上Mac帧时的回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_handler</span><span class="params">(u_char *param, </span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">const</span> struct pcap_pkthdr *header, <span class="keyword">const</span> u_char *pkt_data)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出基本信息：包括监听到帧的时间，帧的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintBaseInfo</span><span class="params">(<span class="keyword">const</span> struct pcap_pkthdr *header)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出硬件地址，格式：<code>xx:xx:xx:xx:xx:xx</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintEthAddress</span><span class="params">(eth_address eth)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出IP地址，格式：<code>xx.xx.xx.xx</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintIPAddress</span><span class="params">(ip_address ia)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出网络层协议类型，格式：<code>网络层协议：xxxx</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintNetType</span><span class="params">(u_short type)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析Mac帧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u_short <span class="title">handleMac</span><span class="params">(eth_header *eth)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析ARP和RARP帧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleARPAndRARP</span><span class="params">(arp_header *ah)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析IP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u_short <span class="title">handleIP</span><span class="params">(ip_header *ih)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析ICMP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleICMP</span><span class="params">(icmp_header *ich)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析UDP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handleUDP</span><span class="params">(udp_header *uh)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析TCP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleTCP</span><span class="params">(tcp_header *th)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;
      
    
    </summary>
    
      <category term="网络编程" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机网络" scheme="https://isjinhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="winpcap" scheme="https://isjinhao.github.io/tags/winpcap/"/>
    
  </entry>
  
  <entry>
    <title>11-关系数据库理论</title>
    <link href="https://isjinhao.github.io/2019/11-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/"/>
    <id>https://isjinhao.github.io/2019/11-关系数据库理论/</id>
    <published>2019-03-27T14:58:59.000Z</published>
    <updated>2019-03-30T01:31:08.777Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="关系-amp-关系模式"><a href="#关系-amp-关系模式" class="headerlink" title="关系 &amp; 关系模式"></a>关系 &amp; 关系模式</h2><p>关系模式相当于一张二维表的框架，在这个框架下填入数据，称为关系模式的一个实例，或者叫关系R。关系模式的形式化定义是：$R(U,D,DOM,F)​$</p><ul><li>R：关系名</li><li>U：组成该关系的属性名集合</li><li>D：U中属性所来自的域<ul><li>域：一组具有相同数据类型的值的集合</li></ul></li><li>DOM：属性向域的映像集合</li><li>F：属性间数据的依赖关系集合</li></ul><p>由于D和DOM域与关系模式的设计无关，因此在讨论关系数据库理论时可以把关系模式看做：$R(U,F)​$</p><p>关系的形式化定义：当且仅当$U$上的一个关系$r$满足$F$时，r称为关系模式$R(U,F)$上的一个关系。</p><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>关系模式的设计直接影响着后续增删查改等的操作。如果设计的不合理就会发生各种各样的问题：</p><ul><li>数据冗余太大</li><li>更新异常</li><li>插入异常</li><li>删除异常</li></ul><p>比如对于一个描述学校在校生信息数据库：$Student&lt;U,F&gt;$，$U=\lbrace Sno,Sdept,Mname,Cname,Grade\rbrace$会发生的问题：</p><ul><li>冗余问题：每个系的系主任姓名重复出现，重复次数与该系所有学生的所有课程成绩次数相同</li><li>更新问题：如果某系的系主任更换后，该数据库该系中所有的元组都要更新</li><li>插入异常：如果一个系刚成立，尚无学生，则无法把该系的系主任存入数据库</li><li>删除异常：如果某个系的学生都毕业了，在删除该系学生的同时，该系系主任的信息也会被删除</li></ul><p>一个好的模式不能发生插入异常、删除异常和更新异常，数据冗余应该尽可能少。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>范式指的是规范化的关系模式，而规范也就是条件，满足不同的条件可以分别解除上述所说的不同问题。</p><h3 id="问题发生的原因"><a href="#问题发生的原因" class="headerlink" title="问题发生的原因"></a>问题发生的原因</h3><p>之所以会发生上诉的问题其实就是由于数据依赖。而数据依赖可以分为两种：函数依赖和多值依赖。但这两种依赖关系不是平级，而是递进的关系，所以我们先介绍函数依赖。</p><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>设$R(U)$是一个属性集$U$上的关系模式，$X$和$Y$是$U$的子集。若对于$R(U)$的任意两个可能的关系$r_1$、$r_2$，若$r_1[x]=r_2[x]$，则$r_1[y]=r_2[y]$，则称$X$决定$Y$，或者$Y$依赖$X$。记作$X \rightarrow Y$。</p><p>对于$X​$、$Y​$范围的不同，可以再次分为：</p><ul><li>非平凡函数依赖：如果$X \rightarrow Y​$但$Y \nsubseteq X​$，则称$X \rightarrow Y​$是非平凡函数依赖</li><li>平凡函数依赖：如果$X \rightarrow Y$但$Y \subseteq X$，则称$X \rightarrow Y$是非平凡函数依赖。<ul><li>例：$(Sno,Sname) \rightarrow Sname$</li></ul></li></ul><p>所以，在关系模式中，平凡函数依赖是一定是可以被满足的，所以我们在以后的讨论中不再关注平凡函数依赖，只关注非平凡函数依赖。而我们对于非平凡函数依赖又可以分为以下几类：</p><ul><li>完全函数依赖：如果$X \rightarrow Y​$，并且对于任意的真子集$X_i​$，都无法做到$X_i \rightarrow Y​$，则称$Y​$对$X​$是完全函数依赖。</li><li>部分函数依赖：如果$X \rightarrow Y​$，存在真子集$X_i​$，可以做到$X_i \rightarrow Y​$，则称$Y​$对$X​$是部分函数依赖。</li><li>传递函数依赖：如果$X \rightarrow Y$，$Y \rightarrow Z$且$Y \nrightarrow X$，则称$X$对$X$有传递函数依赖。</li></ul><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>在关系模型中的每一个具体关系$R$中，如果每个属性都是不可再分的，则称$R$属于第一范式，记作$R \in 1NF$。</p><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>$R \in 1NF​$且每一个非主属性完全函数依赖于码，则$R \in 2NF​$。依赖有直接依赖和传递依赖。</p><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>$R \in 2NF$且$R$中的每个非主属性不传递依赖于主码，则关系$R$是第三范式，$R \in 3NF$。</p><h3 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h3><p>从低级范式到高级范式的方法是模式分解。</p><p>举例：对于一个关系$R(SNO,SNA,CNO,GRADE,CNA,TNA,TAGE)$（学号、姓名、课号、成绩、课程名称、教师姓名、教师年龄）。</p><p>现实语义：如果假设一个教师可以交多门课且一门课仅由一个教师讲授，可得R的函数依赖集：</p><ul><li>$SNO \rightarrow SNM$</li><li>$(SNO,CNO) \rightarrow GRADE​$</li><li>$CNO \rightarrow CNA$</li><li>$CNO \rightarrow TNA$</li><li>$TNA \rightarrow TAGE​$</li></ul><p>函数依赖图如下：</p><div align="center"><img src="/2019/11-关系数据库理论/函数依赖图.jpg" style="width:50%"></div><p>分解为第二范式：</p><ul><li><p>$R1&lt;(SNO,SNA),SNO \rightarrow SNA&gt;​$</p></li><li><p>$R2&lt;(SNO,CNO,GRADE), (SNO,CNO) \rightarrow GRADE&gt;​$</p></li><li><p>$R3&lt;(CNO,CNA,TNA,TAGE),CNO \rightarrow CNA, CNO \rightarrow TNA, TNA \rightarrow TAGE&gt;​$</p></li></ul><p>分解为第三范式：</p><ul><li><p>$R1&lt;(SNO,SNA),SNO \rightarrow SNA&gt;$</p></li><li><p>$R2&lt;(SNO,CNO,GRADE), (SNO,CNO) \rightarrow GRADE&gt;$</p></li><li><p>$R3&lt;(CNO,CNA,TNA),CNO \rightarrow CNA, CNO \rightarrow TNA&gt;​$</p></li><li>$R3&lt;(CNO,TAGE),CNO \rightarrow TAGE&gt;$</li></ul><h3 id="第三范式的问题"><a href="#第三范式的问题" class="headerlink" title="第三范式的问题"></a>第三范式的问题</h3><p>仓库保管$WPE(W#,P#,E#,QNT)$，（ 仓库号，器件号，职工号，数量）。</p><p>一个职工只能管理一个仓库的某类型器件，一个仓库的某类型器件数量是确定的，一个员工管理的某类型器件数量是一定的。</p><p>函数依赖：</p><ol><li>$(W#, P#) \rightarrow QNT$</li><li>$(E#,P#) \rightarrow QNT$</li><li>$(W#,P#) \rightarrow E#​$</li><li>$E# \rightarrow W#$</li></ol><p>函数依赖图：</p><div align="center"><img src="/2019/11-关系数据库理论/函数依赖图2.jpg" style="width:50%"></div><p>此时关系模式$WPE​$有两个侯选码，$(W#,P#)​$ ，$(E#,P#)​$，假设确定$(E#,P#)​$为主码，那么某新职工分配来仓库，处于学习阶段，但没有独立承但任务，即有$E#​$但无$P#​$，缺少码的组成部分，无法插入到该关系，即插入异常。这是由于<strong>主属性$W#​$对另一个侯选码$(E#,P#)​$的部分函数依赖</strong>。</p><h3 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h3><p>BC范式的定义：每个决定因素都包含码，则$R \in BCNF​$。</p><p>而既然每个决定因素都要包含码，则此时意味着必须放弃某些函数依赖，即失去某些现实语义。如例子中若选择$(E#,P#)$，则只能保存函数依赖中的2和4。</p><h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h3><p>设$R(U)$是属性集U上的一个关系模式。$X$，$Y$，$Z$是的$U$的子集，并且$Z=U-X-Y$。关系模式$R(U)$中多值依赖（记做，$X \rightarrow \rightarrow Y$）成立，当且仅当对$R(U)$的任一关系$r$，给定的一对$(x,z)$值有一组$Y$的值，这组值仅仅决定于$x$值而与$z$值无关。</p><p>若$X \rightarrow \rightarrow Y$，$Z$为空，则称$X \rightarrow \rightarrow Y$为平凡的多值依赖。 所以我们以下只讨论非平凡的函数依赖。</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>比如对于关系模型$Teaching(C,T,B)$便是存在多值依赖（码为全属性）：</p><div align="center"><img src="/2019/11-关系数据库理论/teaching.jpg" style="width:80%"></div><h3 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h3><p>如果对于$R$的每个非平凡多值依赖$X \rightarrow \rightarrow Y$，$X$都含有码，则$R$都含有码。</p><p>多值依赖的解决依然是分解。如上例中分解为：</p><ul><li>$R(C,T)$</li><li>$R(C,B)$</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;关系-amp-关系模式&quot;&gt;&lt;a href=&quot;#关系-amp-关系模式&quot; class=&quot;headerlink&quot; title=&quot;关系 &amp;a
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CPP中的字节序</title>
    <link href="https://isjinhao.github.io/2019/CPP%E4%B8%AD%E7%9A%84%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    <id>https://isjinhao.github.io/2019/CPP中的字节序/</id>
    <published>2019-03-27T13:26:28.000Z</published>
    <updated>2019-03-27T14:12:15.059Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。</p><ul><li><p>大端字节序：高位字节在前，低位字节在后。</p></li><li><p>小端字节序：低位字节在前，高位字节在后。</p></li></ul><p>假如我们要存储<code>0x01234567</code>，大端法和小端法如下：</p><div align="center"><img src="/2019/CPP中的字节序/大端.gif" style="width:70%"></div><h2 id="为什么会有小端字节序"><a href="#为什么会有小端字节序" class="headerlink" title="为什么会有小端字节序"></a>为什么会有小端字节序</h2><p>人类能接受的字节序肯定是大端存储，所以很多人会不理解为什么还要有小端字节序呢？其实计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。</p><p>个人觉得之所以会存在小端字节序是由于计算机电路在计算时先处理低位字节，存储单元里的数据按小端字节序存储方便计算。</p><h2 id="字节序的处理"><a href="#字节序的处理" class="headerlink" title="字节序的处理"></a>字节序的处理</h2><ul><li><p>其实只有读取的时候，才必须区分字节序，其他情况都不用考虑。</p></li><li><p>数据长度大于1字节（8bits）时才需要区分字节序。</p></li></ul><p>虽然在计算机中存储和具体的平台相关，但是规定在网络中传输的数据采用大端传输，即如果有一串网络流为：<code>010101000100110101010</code>，实际发送时越左边的越先发送到网络中。</p><h3 id="C语言中处理字节序"><a href="#C语言中处理字节序" class="headerlink" title="C语言中处理字节序"></a>C语言中处理字节序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为16位主机字节序的值，返回值是16位网络字节序的值</span></span><br><span class="line"><span class="keyword">uing16_t</span> htons(<span class="keyword">uint16_t</span> host16bitvalue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为32位主机字节序的值，返回值是32位网络字节序的值</span></span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> host32bitvalue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为16位网络字节序的值，返回值是16位主机字节序的值</span></span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> net16bitvalue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为16位网络字节序的值，返回值是16位主机字节序的值</span></span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> net32bitvalue);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;字节序&quot;&gt;&lt;a href=&quot;#字节序&quot; class=&quot;headerlink&quot; title=&quot;字节序&quot;&gt;&lt;/a&gt;字节序&lt;/h2&gt;&lt;p&gt;计
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="https://isjinhao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="字节序" scheme="https://isjinhao.github.io/tags/%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    
      <category term="计算机组成原理" scheme="https://isjinhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="https://isjinhao.github.io/2019/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://isjinhao.github.io/2019/物理层/</id>
    <published>2019-03-27T05:15:14.000Z</published>
    <updated>2019-03-27T13:11:04.558Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><h3 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h3><p>数字通信中对数字信号的计量单位。在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>假如基带信号是<code>101011000110111010...</code>，如果直接发送，则每个码元携带一个比特的信息（每个码元只有2种状态），但是如果将信号中的三个比特编为一组，即101，011，000，110，111，010…，三个比特共有8种不同的排列，我们可以用不同的调制方法来表示这种信，如8种不同的振幅，频率，相位等，如果采用相位调制，相位$\phi_0$表示000，$\phi_1$表示001，以此类推，那么接收端如果收到相位是$\phi_0$的信号就知道表示的是000，以此类推，这样一个码元就不知不觉的传输了三个比特位的信号，此时每个码元有8种状态。一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难。</p><h3 id="编码级别"><a href="#编码级别" class="headerlink" title="编码级别"></a>编码级别</h3><p>如果把n个比特编码成一个码元，则此时编码状态$M=2^n$，其表示当前传输时有多少不同的状态，如8级编码，会有：<code>000、001、010 …</code></p><h2 id="奈斯准则"><a href="#奈斯准则" class="headerlink" title="奈斯准则"></a>奈斯准则</h2><h3 id="码间串扰"><a href="#码间串扰" class="headerlink" title="码间串扰"></a>码间串扰</h3><p>码元的传输速率是有限制的，超过某上限就会出现码间串扰问题。这是由于在真正传输中，信号在传输时都不是理想化的，如下图就是理想化的高低电平和真实传输时的高低电平。</p><div align="center"><img src="/2019/物理层/真实和理想.jpg" style="width:50%"></div><p>假如此时速度太快，就可能把低电平和高电平弄混。而最高的码元传输速率被奈斯准则限制。</p><h3 id="奈斯准则内容"><a href="#奈斯准则内容" class="headerlink" title="奈斯准则内容"></a>奈斯准则内容</h3><ul><li>理想低通信道（能通过信号频率在某值之下）的最高码元传输速率为：$2W Baud$。</li></ul><div align="center"><img src="/2019/物理层/低通信道.png" style="width:80%"></div><ul><li>理想带通信道（能通过信号频率在某范围之内）的最高码元传输速率为：$1W Baud$。</li></ul><div align="center"><img src="/2019/物理层/带通信道.png" style="width:80%"></div><p>W是理想低通信道的带宽，单位为赫(Hz)。Baud 是波特，是码元传输速率的单位，1 波特为每秒传送 1 个码元。</p><h3 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h3><p>单位时间内数据通信系统所传输的码元个数（信号个数），单位是波特（Baud）。</p><h3 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h3><p>表示单位时间内数据通信系统传输的比特数，单位是比特/秒（b/s或bps）。$比特率 = 波特率 * log_2M$</p><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><h3 id="编码级数限制"><a href="#编码级数限制" class="headerlink" title="编码级数限制"></a>编码级数限制</h3><p>虽然码元传输速率有限制，但是如果我们能尽可能提高编码级数不就能提升信息传输速率了吗？但事实上信号传输速率不受限于调制技术，而是受限于信噪比。举个例子，如果我们是在天气晴朗的一天出门，我们穿任意颜色衣服都能被分辨出来，但是如果我们在沙尘暴天气出门，穿<code>橘黄</code>和<code>橙黄</code>两种颜色的衣服别人自然就认不出来了。在这个比喻中衣服的颜色代表码元，确定衣服的颜色代表信息，沙尘暴就是噪声。</p><h3 id="香农公式内容"><a href="#香农公式内容" class="headerlink" title="香农公式内容"></a>香农公式内容</h3><p>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率$C=W \ast log_2(1+PS/PN)（b/s）​$。</p><ul><li>其中$W$是信道的带宽。$PS$是信号的能量。$PN$是噪声的能量。</li><li>信噪比：$S/N=10lg{PS/PN}$。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>设带宽是<code>1MHz</code>，信噪比是<code>24dB</code>，则信道的最高信息传输速率为：$C=1M \ast log_2{(1+(10^{2.4}))}=7.98Mbps$。</p><h2 id="奈氏准则vs香农公式"><a href="#奈氏准则vs香农公式" class="headerlink" title="奈氏准则vs香农公式"></a>奈氏准则vs香农公式</h2><div align="center"><img src="/2019/物理层/香农公式和奈斯准则.png" style="width:80%"></div><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>电路交换中独占电路资源，并不是指用户线和中继线都被此次交换所独占，而是说在两个用户建立连接之后，除非连接中断，否则他们当前所拥有的资源不会被释放，即使他们之间不传输信息。而如何在中继线上实现多组用户通信就是多路复用技术。</p><p>产生多路复用的物理基础是：传输媒体的带宽或容量往往会大于传输单一信号的需求，使用多路复用，为了有效地利用通信线路，希望一个信道同时传输多路信号。</p><p>这种技术会将链路/网络资源（如带宽）划分为“资源片”，将资源片分配给各路“呼叫”（calls），每路呼叫独占分配到的资源片进行通信，资源片可能“闲置”</p><p>常见的复用技术有：频分多路复用、时分多路复用、波分多路复用、码分多路复用。</p><div align="center"><img src="/2019/物理层/多路复用.png" style="width:80%"></div><h3 id="频分多路复用"><a href="#频分多路复用" class="headerlink" title="频分多路复用"></a>频分多路复用</h3><p>FMD：Frequency-division multiplexing，是指载波带宽被划分为多种不同频带的子信道，每个子信道可以并行传送一路信号的一种多路复用技术。也就是说信道的可用频带被分成若干个互不交叠的频段，每路信号用其中一个频段传输，因而可以用滤波器将它们分别滤出来，然后分别解调接收。</p><div align="center"><img src="/2019/物理层/频分多路复用.png" style="width:40%"></div><h3 id="时分多路复用"><a href="#时分多路复用" class="headerlink" title="时分多路复用"></a>时分多路复用</h3><p>TDM：time division multiplexing，它使不同的信号在不同的时间内传送，将整个传输时间分为许多时间间隔（Time Slot，TS，又称为时隙），每个时间片被一路信号占用。TDM就是通过在时间上交叉发送每一路信号的一部分来实现一条电路传送多路信号的。电路上的每一短暂时刻只有一路信号存在。因数字信号是有限个离散值，所以TDM多应用于数字通信系统。</p><div align="center"><img src="/2019/物理层/时分多路复用.png" style="width:70%"></div><h3 id="波分多路复用"><a href="#波分多路复用" class="headerlink" title="波分多路复用"></a>波分多路复用</h3><p>将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器（亦称合波器，Multiplexer）汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；在接收端，经解复用器（亦称分波器或称去复用器，Demultiplexer）将各种波长的光载波分离，然后由光接收机作进一步处理以恢复原信号。</p><div align="center"><img src="/2019/物理层/波分多路复用.png" style="width:70%"></div><h3 id="码分多路复用"><a href="#码分多路复用" class="headerlink" title="码分多路复用"></a>码分多路复用</h3><p>为每个用户分配一个唯一的mbit的码片序列（chipping sequence），二进制下的0用-1表示，二进制下的1用+1表示。在信道上传输的信号 = 原始数据 <em>码片序列，比如码片序列是：(-1, 1, 1)，需要传一个0，应该是 -1 </em>(-1, 1, 1)，所以传输的就是(1, -1, -1)。</p><p>同时为了保证数据之间不相互影响，被共享的用户所占有的码片应该相互正交的。即：$\frac{1}{m}S_i \cdot S_j = 0 (i \neq j)​$。而信道上真正传输的数据是各用户发送数据的叠加值。</p><div align="center"><img src="/2019/物理层/码分多路复用.png" style="width:80%"></div><h3 id="数字信号在模拟信道传输"><a href="#数字信号在模拟信道传输" class="headerlink" title="数字信号在模拟信道传输"></a>数字信号在模拟信道传输</h3><p>数字信号需要编码后才能传输。常见的三种编码：</p><ol><li>NRZ编码：进制数字0、1分别用两种电平来表示。常用-5V表示1，+5V表示0。</li><li>曼切斯特编码：用电压的变化表示0和1：高→低 &lt;=&gt; 0，低→高 &lt;=&gt; 1。</li><li>差分曼切斯特编码：在码元开始处有无跳变来表示0和1：有 &lt;=&gt; 0，无 &lt;=&gt; 1。</li></ol><div align="center"><img src="/2019/物理层/数字信号编码.png" style="width:80%"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Thu Apr 04 2019 15:33:10 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;码元&quot;&gt;&lt;a href=&quot;#码元&quot; class=&quot;headerlink&quot; title=&quot;码元&quot;&gt;&lt;/a&gt;码元&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://isjinhao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://isjinhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
