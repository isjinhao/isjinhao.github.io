<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ISJINHAO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://isjinhao.github.io/"/>
  <updated>2019-12-20T09:29:57.563Z</updated>
  <id>https://isjinhao.github.io/</id>
  
  <author>
    <name>ISJINHAO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>04.02-网络-链路层</title>
    <link href="https://isjinhao.github.io/posts/24372.html/"/>
    <id>https://isjinhao.github.io/posts/24372.html/</id>
    <published>2019-12-20T09:22:11.000Z</published>
    <updated>2019-12-20T09:29:57.563Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="相邻"><a href="#相邻" class="headerlink" title="相邻"></a>相邻</h2><p>计算机网络中链路层的功能是“相邻节点间的数据传输”。这句话什么意思呢？我们先讨论“相邻”一词，再讨论“数据传输”。两台主机，用一根网线相连是相邻。多台主机，用一根网线相连，仍然是相邻。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/56b3b0fe-68ac-4f0a-96ca-5d1a91d3ddca"></div><br>这根线缆退化成一个节点，这样的设备称为集线器。通过集线器相连的多台主机也是相邻。集线器没有任何智能，等同于线缆。在集线器上增加简单的智能控制功能，就是交换机。通过交换机相连的多台主机也是相邻。交换机将计算机互联在一起，构成局域网。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/02a42964-8121-4cd4-aa4d-320e8fbe1f87"></div><br>所以“相邻节点间的数据传输”换一种说法就是“构建局域网”，再换一种说法就是“局域网内的主机都是邻居关系”。链路层的功能就是构建局域网。相邻这一概念很重要，主机间的数据传输可以分为两种情况，一种是两个主机在同<br>一个局域网内，两主机是相邻关系，简称内网通信，另一种是两个主机在两个不同的网络里，可称外网通信，两种数据传输原理完全不同。本篇文章只关注内网通信。<br><br><br><br>## 链路层解决的问题<br><br>数据传输就是将一台主机内的数据传输到另一台主机，物理层解决了比特转换为电磁信号传输的问题，但这不是数据传输的全部问题，还有一些问题，例如：<br>- 物理层传输中的数据有可能出错，如何处理？<br>- 发送方与接收方的速度可能不匹配，如何调节？<br>- 数据如何封装成数据帧，然后传输，如何传输封装？<br>- 发生碰撞该怎么办？<br>针对这些问题制定的解决方案称为数据链路层的通信协议。物理链路+通信协议构成了我们要研究的数据链路。<br><br><br><br>## 循环冗余码<br><br>循环冗余码（CRC）在很多地方都被用来校验传输的数据是否出错，至于其如何证明，笔者也未曾探究，下文介绍冗余码的思想和计算方法。<br>如果发送方只传输 87，接收方收到 82，接收方是无法判断 82 是不是发送方发送的数据，就是说无法判断 82 是对还是错。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/9cc48d60-5fb9-48aa-bee8-289923b4def8"></div><br>怎么办？发送方与接收方事先商量好一个数，例如 15，发送时先计算 87 除 15 的余数，为 12，将这个余数与 87 一起发送，即 8712，接收时先计算 82 除 15 的余数，为 7，不等于 12，就认为传输的数据出错，这样检错的概率并非百分之百，例如87 错成 72 就检测不出来，但总体来说，检错概率已经非常高了。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/deb03917-f54b-4a55-a49a-035080cb338c"></div><p><br></p><h3 id="CRC-计算方法"><a href="#CRC-计算方法" class="headerlink" title="CRC 计算方法"></a>CRC 计算方法</h3><ul><li>第一，CRC 有一个生成多项式 P(x)，其作用等同于除数 15，将其写成比特串，转化规则如图：</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/b05ad501-470b-401d-a351-30621e3a5a5b"></div><br>- 第二，如果 P(x) 的比特串是 n 位，在发送数据后补 n-1 个 0。例如 P(x)为 1101，就要补 000。<br>- 第三，做模2除法。<strong>注意模二除法不是二进制除法。</strong><br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/2fe57653-6891-4811-9f64-64ddf0a63426"></div><br>- 第四，用<strong>余数</strong>替换补的 0，形成发送数据，101001001。<br>- 第五，接收方用接收数据 101001001 除以 P(x)1101，如果能整除，就表示没有错（等同与原理中的余数相同），如果不能整除，就表示出错了（等同与原理中的余数不相等）。<br><br><br><br>## 停止等待协议（Stop-and-Wait protocol）<br><br>如果两个主机间数据传输时，接收方的速度永远不会低于发送方的速度；传输的数据帧不会出错，也不会丢失，完全理想化的数据传输，那就没有什么问题，当然也不需要解决问题的办法，也就不需要协议。现在假设，没有差错，但是接收方的速度低于发送方的速度，怎么办？显然控制的思路只能是快的一方牵就慢的一方，就是由慢的一方指挥快的一方。具体来说，就是发送方每发送一帧就停下来，等待；收到 ACK 发送下一帧，接收方则是等待，收到数据帧，发送 ACK（确认 Acknowledgment ），等待下一帧。停下来，等待就是停止等待协议的由来。<br>停止等待协议当然不仅仅需要这一个问题，其需要解决的问题如下：<br>- 接收方的速度低于发送方的速度；<br>- 传输的数据帧可能出错；<br>- 数据帧可能丢失，确认帧 ACK 也可能丢失；<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/94b7f382-3546-4f7b-9b20-d4922ad72022"></div><p><strong>确认号</strong></p><p>接收方收到一个数据帧，并校验正确，给发送方一个确认 ACKn，ACKn 表示“第 n-1 号帧已经收到，现在期望接收第 n 号帧”。确认号是接收方预期接收的下一帧的序号。</p><p><strong>差错</strong></p><p>数据帧出错时，接收方收到一个数据帧，校验时发现数据帧出错，接收方丢弃此数据帧，此外不做任何事，即不发送 ACK。发送方发送完数据帧后在停止等待 ACK，然而此时不会有 ACK，发送方就等死在这里了。</p><p><strong>重传定时器</strong></p><p>发送方设计一个重传定时器的机制，发送方每发送一个数据帧，就启动一个倒计时的重传定时器，如果在超时 timeout 之前收到确认，就关闭定时器并发送下一帧。如果超时，就重传之前的帧。</p><p><strong>丢失</strong></p><p>接收方收到一个数据帧，校验正确发送 ACK，等待接收下一帧，如果确认帧丢失，发送方收不到确认，超时后重传旧帧，而接收方在等待新帧，此刻发送方与接收方的状态不同步，如何区分新帧与重传的帧？</p><p><strong>帧编号</strong></p><p>停等协议使用序号和确认号，以区分重传的数据帧。发送方发送帧时使用序号，接收方使用确认号。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/748650d2-50d3-4df5-8c6e-6a6a4ba625ff"></div><p><br></p><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>停止等待协议的优点是简单，但缺点是信道利用率太低。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a73393e2-cbc6-4080-a3d2-1c94b49054e0"></div><br>信道利用率公式：$U=\frac{T_D}{T_D+RTT+T_A}$，其中：<br>- $T_D$：数据帧传输时延<br>- $RTT$：数据帧+确认帧传播时延<br>- $T_A$：确认帧传输时延<br>举例：假设主机甲与主机乙使用停等协议传输数据，若甲乙之间的单向传播延迟是 15ms，数据帧长为 1000 字节，信道宽带为 100Mbps，乙每收到一个数据帧立即利用一个短帧（忽略其发送时延）进行确认，则信道利用率为：发送一个数据帧到 100Mbps 链路所需时间为：$T_D = \frac{1000 \ast 8bits}{100 \ast 10^6bit/s }= 80\mu s$。发送方在 t=0 时刻发送，15ms 后第 1 个比特到达主机乙，15.08ms 时主机乙收到最后一比特，开始发送确认帧，由于确认帧很短，我们忽略其发送时延，在30.08ms 时，确认帧到达主机甲，总时间周期为T𝐷 + RTT + T𝐴(忽略) = 30.08ms，信道利用率为0.0027。信道利用率为 0.27%，就是说发送方只有百分之0.27的时间是忙的。停止等待协议信道利用率太低了。<br><br><br><br>## GBN 协议<br><br>我们讨论一个可以获得较高信道利用率的协议：连续 ARQ 协议(Go-back-NProtocol)，或称 GBN 协议，也称为滑动窗口协议（Sliding Window Protocol）。发送方在接收到确认之前，发送一组数据帧，而不是发送一个数据帧就停止等待确认。<br><br><strong>确认号</strong><br><br>在 GBN 协议中，采用累积确认的方式，确认号是希望接收的下一个分组序号。举例，ACK7 表示序号 6 以内的所有帧都已正确收到了，等待接收 7 号帧。<br><br><strong>发送窗口</strong><br><br>在 GBN 协议中，发送一组帧，然后停止等待确认。发送窗口定义了最多可以发送多少个数据帧。举例如下图：一个大小为 7 的窗口，窗口左侧是已确认，已丢弃的帧，窗口内有色的是已发送的，尚未收到确认的帧，0，1，2，3 号帧，发送方需要等待，可称为未完成帧，窗口内无色的是可发送还未发送的帧，是 4，5，6 号帧，窗口右侧是不能发送的帧。描述发送窗口需 3 个变量：<br>- $S_f$：发送窗口，第一个未完成分组。完成指的是发送方接收到确认方的确认帧。<br>- $S_n$：发送窗口，下一个待发送分组。<br>- $S_{size}$：发送窗口，大小。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/2abd2748-98e6-4814-8109-52b707ded1f9"></div><br>当 ackNo 大于等于 $S_f$ 且小于 $S_n$ 的无错 ACK 到达时，发送窗口可以滑动一个或多个槽。举例，当发送方收到 $ACK_6$，表示 4，5 号帧已正确接收，窗口滑动，状态如下图。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/57c10335-51ac-4ae5-b198-48d7b27e2cdf"></div><p><strong>接收窗口</strong></p><p>在 GBN 协议中，接收窗口大小总是 1。只有序号在接收窗口内的数据帧才接收。任何失序的分组都会被丢弃，需要重发。描述接收窗口控制只需 1 个变量 $R_n$，表示其期待下一次接收的帧，</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/16e25de1-cd2e-4926-b80b-bad21e0665cb"></div><p><strong>重传定时器</strong></p><p>在 GBN 协议中，只使用一个计时器。接收窗口大小总是 1。当定时器超时，发送方重发所有未完成分组。例如，假设发送方已经发送了分组 6（$S_n=7$），但是唯一的计时器终止。如果 $S_f=3$，这意味着分组 3、4、5 和 6 没有被确认；发送方回退并重发分组 3、4、5 和 6。</p><ul><li>发送方<ul><li>发送分组。发送方会开启唯一的计时器。$S_n$ 的值增长，（$S_n=S_n+1$）如果达到窗口值进入阻塞状态。</li><li>如果 ACK 到达，其 ackNo 与一个未完成分组有关，那么发送方滑动窗口（令 $S_f=ackNo$），并且如果所有未完成分组都被确认（$ackNo=S_n$），那么关闭计时器。如果并不是所有未完成分组都被确认，那么重新开启计时器。</li><li>如果超时发生，发送方重发所有未完成分组并重新开启计时器。</li></ul></li><li>接收方<ul><li>如果 $seqNo=R_n$ 的无错分组到达，之后窗口滑动，$R_n=（R_n+1）$。$ackNo=R_n$的 ACK 被发送。</li><li>如果 seqNo 在窗口之外的无错分组到来，分组被丢弃，但是 $ackNo=R_n$的 ACK 被发送。</li></ul></li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/431b9ded-4d9a-4c03-8462-9ab01615ac63"></div><p><strong>发送窗口的最大值</strong></p><p>当用 n 个比特进行帧编号时，接收窗口的大小为 1，则只有在发送窗口的大小$W_T ≤ 2^n − 1$时，连续 ARQ 协议才能正确运行。例如，当采用 2bit 编码时，发送窗口的最大值是 3 而不是 4。下图比较 4 与 3 两种情况。如果窗口的大小是 4 并且所有确认都丢失，发送方将会重传旧的所有 4 个帧。但是接收方等待接收的是新的 0 号帧，由于窗口匹配，接收 0 号帧，接收方认为接收的是新的 0 号帧，这是一个错误。如果窗口大小为 3 并且所有三个确认都丢失，那么超时并且重发所有 3 个分组，接收方现在期待 3 号帧，而不是 0 号帧，因此重传分组被正确丢弃。不会产生错误。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/68b3e6ca-aacc-441b-ad6d-85ca8f56e6d9"></div><br>为能正确区分重传的帧，应保证在$W_T+W_R$的窗口内不出现重复序号，即$W_T + W_R ≤ 2^n$，我们将 WT 和 WR 拼接在一起，在$W_T + W_R$窗口内如果出现重复序号，就会发生上述的错误，如果不出现重复的序号，就不会发生上述的错误。GBN 协议的接收窗口为 1，所以发送窗口最大为$2^n − 1$<br><br><br><br>## CSMA/CD<br><br>共享信道有一个基本问题，碰撞 （Collision）。若某时刻两帧同时发出，会相互重叠，结果使信号无法辨认，称为碰撞。如下图便是碰撞：<br><br><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/527274c9-4165-4b0a-8bc4-721b372b901c"></div><br>碰撞的结果是两个帧都变得无用。解决碰撞的思路大致有两类：<br>- 一类思路是将工作做在前面，预防碰撞，即受控接入：各主机不能任意发送数据，必须服从一定的控制。如令牌环网，拥有令牌的主机可发送数据，没有令牌的主机只能接收数据，令牌如击鼓传花般依次传递。<br>- 另一类思路是将工作做在后面，撞就撞吧，做好事故的处理，即随机接入：所有主机都可以根据自己的意愿随机地发送数据。<br>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）载波监听多点接入/碰撞检测。载波监听（Carrier Sense）指监测信道上有无数据信号传输，监测方法是判断基带上是否有脉冲二进制 0 或 1。多点接入（Multiple Access）同时有多个站点连接在信道上。显然，使用随机接入的方式是无法避免碰撞的。在随机接入的情况下，需要完成几项工作：<br>- 尽量减少碰撞<br>- 是否碰撞有明确结论<br>- 碰撞之后的事故处理<br>CSMA/CD 协议完成这些工作的原理，简缩为三句口诀。<br>- 先听后发<br>- 边发边听<br>- 冲突重发<br><br><br><br>### 先听后发<br><br>我们当然希望尽量减少碰撞，想个什么办法呢？就是在发送数据帧之前，先监听信道。“载波监听”就是“发送前先监听”，如果信道上有数据帧，当然就先不发送数据帧，否则一发送数据帧就产生碰撞，碰撞了就毫无意义。当监听信道时，如果信道忙有数据帧，站点回去睡一段随机时间，然后再回来监听信道，这种策略称非坚持型 CSMA。当监听信道时，如果信道忙有数据帧。站点不是回去睡一会，而是蹲守在这儿，继续监听直到信道空闲，这种策略称坚持型 CSMA。当监听到信道空闲下来时，站点立即就发送数据，称 1-坚持型 CSMA。当监听到信道空闲下来时，站点并不立即发送数据，先抛一次硬币，如果是字就发，如果是花就不发，就是说以概率 p 发送数据，称 p-坚持型 CSMA。<br><br><br><br>### 边发边听<br><br>站点发出数据帧后，是否碰撞需要有明确的结论。就需要“碰撞检测”（Collision Detection）。如何检测呢？站点检测信道上的信号电压大小，当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，“碰撞检测”也称为“冲突检测”。<br>假设 A 站点与 B 站点是网络最远的两端，从 A 站点发出一数据帧，到达 B站点的所花费的时间为$\tau$，A 站点发出一数据帧，就在即将到达 B 站的时刻，B站发出一数据帧，立即发生碰撞，碰撞信号继续到达 A 站，A 站在经过时间 $2\tau$（两倍的端到端传播时延）发现碰撞。所以，$发送站点监听时间&gt;2\tau$，就可以得到是否碰撞的明确结论。$2\tau$ 也即称为争用期，或碰撞窗口。所以为得到是否碰撞的明确结论，只需要$监听时间&gt;2\tau$就可以了。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/21337352-8cd5-428c-9c57-ebcc9ef4f616"></div><p><br></p><h3 id="冲突重发"><a href="#冲突重发" class="headerlink" title="冲突重发"></a>冲突重发</h3><p>发生碰撞，两个数据帧都损坏，当然需要重发。但是如果两个站点都立即重发数据帧，又会再次碰撞，两个站点发送时刻最好能够错开一些。CSMA/CD 协议使用<strong>截断二进制指数退避算法</strong>，发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。</p><ul><li>重传次数 k，$k=Min[重传次数,10]$</li><li>从整数集合$[0,1,…,(2^k-1)]$中随机地取出一个数，记为 r。</li><li>重传所需的时延就是 r 倍的基本退避时间。基本退避时间一般是取为争用期。<br>当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。使用 CSMA/CD 协议后不能进行全双工通信而只能进行双向交替通信（半双工通信）。每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><p><br></p><h2 id="10BASE-T-以太网"><a href="#10BASE-T-以太网" class="headerlink" title="10BASE-T 以太网"></a>10BASE-T 以太网</h2><p>10Base-T以太网使用的是1-坚持型CSMA / CD。<br>10BASE-T 以太网不用同轴电缆而用无屏蔽双绞线，降低了成本，还增加了一种可靠性非常高的设备，叫做集线器（hub）。正是这两个原因，使得 10BASE-T以太网拥有很低的成本和很高的可靠性，迅速在局域网中占据了统治地位。10BASE-T 以太网定义：</p><ul><li>争用期的长度为 51.2 us，而$监听时间 &gt; 2 \tau$ 便等价于$发送数据帧的时间 &gt; 2\tau$。可得：$\frac{帧长L}{10Mbps}&gt;51.2 \mu s$，即$L &gt; 512bit$。最短帧长 64 字节。</li><li>帧间最小间隔为 9.6us，因为要给双方留下缓冲时间。</li><li>站点到集线器的距离不超过 100m，为了保证双绞线上的信号不会出错。</li><li>如果数据帧太长就会出现有的主机长时间不能发送数据，而且有的发送数据可能超出接收端的缓冲区大小，造成缓冲溢出。为避免单一主机占用信道时间过长，规定了以太网帧的数据部分最大长度为1500。</li></ul><p><br></p><h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>在主机内部，需要 10BASE-T 的网络接口板又称为通信适配器（adapter）或网络接口卡 NIC(Network Interface Card)，或“网卡”。网络适配器的重要功能：</p><ul><li>对数据进行串行/并行传输的转换</li><li>编码与译码即曼彻斯特编码与译码。</li><li>链路管理主要是 CSMA/CD 协议的实现。</li><li>数据的封装与解封封装以太网帧。<br>网卡的第一，第二项功能属于物理层的功能。第三项 CSMA/CD 协议的原理上文也介绍了，在此主要介绍一下以太网帧，也称 MAC 帧。网络适配器工作在数据链路层和物理层。生产网卡时，在网卡的 ROM 固化了 6 字节的 MAC 地址，因此 MAC 地址也叫做硬件地址(hardware address)或物理地址。MAC 地址唯一标识了一块网卡。MAC 地址字段是 6 字节（48 位），前三个字节（即高位 24 位），是生产厂家标识，称为组织唯一标识符，后三个字节（即低位 24 位）由厂家自行指派的产品串号，称为扩展唯一标识符，必须保证串号没有重复。网卡将上一层交下来的数据加上首部和尾部，成为以太网的帧。接收时将以太网的帧剥去首部和尾部，然后送交上一层。常用的以太网 MAC 帧格式有两种标准：DIXEthernetV2 标准和 IEEE 的 802.3 标准，最常用的 MAC 帧是以太网 V2 的格式。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/57c68567-71f2-48eb-8302-5615a05c6932"></div><p><br></p><h3 id="网卡工作要点"><a href="#网卡工作要点" class="headerlink" title="网卡工作要点"></a>网卡工作要点</h3><ul><li>适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中，准备发送。</li><li>若适配器检测到信道空闲，就发送这个帧。若检测到信道忙，则继续检测并等待信道转为空闲（加上 96 比特时间），然后发送这个帧。</li><li>在发送过程中继续检测信道，若一直未检测到碰撞，就顺利把这个帧成功发送完毕。若检测到碰撞，则中止数据的发送，并发送人为干扰信号。</li><li>在中止发送后，适配器就执行指数退避算法，等待 r 倍 512 比特时间后，返回到步骤 2。<br>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。早期以太网采用无源的总线结构。现在采用以太网交换机的星形结构成为以太网的首选拓扑。总线以太网使用 CSMA/CD 协议，以半双工方式工作。以太网<br>交换机以全双工方式工作，不使用共享总线，没有碰撞问题，因此不使用CSMA/CD 协议。但仍然采用以太网的帧结构。</li></ul><p><br></p><h2 id="网桥与交换机"><a href="#网桥与交换机" class="headerlink" title="网桥与交换机"></a>网桥与交换机</h2><p>我们看下面一个拓扑，某学院有三个系，各自有一个以太网，三个以太网是三个独立的碰撞域，如果用集线器连成一个更大的以太网，同时也形成一个更大的碰撞域。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/dc645445-17f8-4e1b-81dc-62ca4e233b11"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/35f7eb90-8d1e-474c-81f5-2537406a1092"></div><br>连接的范围扩大了，但碰撞也多了，能不能只扩大范围，不扩大碰撞呢？<br><br><br><br>### 网桥<br><br>有一种网络设备，称为网桥（bridge），能只扩大范围，不扩大碰撞。网桥工作在数据链路层，其内部维护一张转发表，根据 MAC 地址转发数据帧。当网桥收到一个帧时，根据此帧的目的 MAC 地址，检索转发表，然后再转发帧到接口。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/b5a7f938-7c1e-4f68-ab44-86f02adc0f1c"></div><br>我们看下面的一个拓扑图，先不考虑网桥的转发表是怎么来的，先看一下网桥 B1 和网桥 B2 的转发表的最终形态，可以看出，转发表的本质就是拓扑图的描述，推想一下，这是必然的，网桥若要正确转发数据帧，就需要知道各主机与其的位置关系。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/bdec481c-20b7-42fc-a7d9-8b095ea16a01"></div><br>那么，这张转发表又是怎么来的呢？网桥 B1 和网桥 B2 刚上电时，其内部转发表都是空表，这时，主机 A 给主<br>机 B 发送一数据帧，网桥 B1 的接口 1 收到这帧，网桥 B1 能判断出主机 A 在它的接口 1 侧，但判断不出主机 B 在哪侧，首先转发，把帧向网桥除接口 1 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“A 接口 1”填入转发表，网桥 B1 就学到 1 个条目。网桥 B2 收到网桥 B1 的转发帧，网桥 B2 也能判断出主机 A 在它的接口 1 侧，但判断不出主机 B 在哪侧，首先转发，把帧向网桥除接口 1 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“A 接口 1”填入转发表，网桥 B2 也学到 1 个条目。<br>接下来，第二个数据帧是主机 F 给主机 C 发送的，网桥 B2 的接口 2 收到这帧，网桥 B2 能判断出主机 F 在它的接口 2 侧，但判断不出主机 C 在哪侧，首先转发，把帧向网桥除接口 2 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“F 接口 2”填入转发表，网桥 B2 就学到 2 个条目。网桥 B1 收到网桥 B2 的转发帧，网桥 B1 也能判断出主机 F 在它的接口 2 侧，但判断不出主机 C 在哪侧，首先转发，把帧向网桥除接口 2 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“F 接口 2”填入转发表，网桥 B1 也学到 2 个条目。<br>第三个数据帧是主机 B 给主机 A 发送的，网桥 B1 的接口 1 收到这帧，网桥B1 能判断出主机 B 在它的接口 1 侧，由于已经学到 2 个条目，网桥 B1 由前 2个条目，知道主机 A 在接口 1 侧的，所以不转发。第二，将“B 接口 1”填入转发表，网桥 B2 就学到 3 个条目。因为网桥 1 没转发，网桥 B2 没收到任何数据帧，网桥 B2 仍维持着 2 个条目。<br>经过一段时间，各主机发送了很多数据帧，网桥 B1 和网桥 B2 就学习到了完整的转发表。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/06c46dbe-9db3-4e95-8778-d974ce4eca44"></div><br>但是需要注意，在下图中三个碰撞域内是可以进行通信，但是跨碰撞域之后还是会产生碰撞。如A给D发消息时，B和C不能进行通信。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/4e88f21e-c0aa-4266-8897-b079929fa81b"></div><p><br></p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>网桥只有 2 个接口，可是谁规定网桥只能有 2 个接口呢，网桥也可以有更多接口，这就是以太网交换机，以太网交换机（switch）实质上就是一个多接口的网桥。通常都有十几个或更多的接口。每个接口都直接与一个单台主机或另一个以太网交换机相连，工作在全双工方式。以太网交换机工作原理也是按转发表转发数据帧，工作在数据链路层，是第二层交换机，其内部的帧交换表（又称为地址表）是通过自学习算法自动地逐渐建立起来的。<br>我们看下面的一个拓扑图，先不考虑交换机的转发表是怎么来的，先看一下交换机的转发表的最终形态，可以看出，转发表的本质就是拓扑图的描述，推想一下，这是必然的，交换机若要正确转发数据帧，就需要知道哪个接口与哪个主机相连。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/1c417675-7ccc-4520-9631-54ac9d2a013c"></div><br>那么，这张转发表又是怎么来的呢？交换机启动时，其内部转发表是空表。A 先向 B 发送一帧，交换机收到帧后，先执行转发功能。查找交换表，如果没有查到，洪泛，交换机向除接口 1 以外的所有的接口广播这个帧。再执学习发功能，把这个帧的源地址 A 和接口 1 写入交换表中。当所有主机都发送过数据帧后，交换机就将交换表学完整了。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a35ff815-0672-4828-974f-aa0398fab524"></div><br>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就自动被删除。以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。交换机工作原理是按转发表（MAC 表）转发数据帧，转发表的本质就是拓扑图的描述。要把交换机转发表的本质牢固的记住：<strong>交换机就是要知道哪个接口与哪个主机相连。</strong><br><br><br><br>### MAC 表抖动与广播风暴<br><br>网桥和交换机的使用可能会发生一下问题，我们以网桥举例：<br>- 会发生 MAC 表抖动（flapping）的问题：就是说同一个MAC地址在一台交换机上的两个及以上接口都学习到，导致MAC地址表中关于此MAC地址与交换机的端口对应不断改变。<br>- 数据帧会循环兜圈子，形成广播风暴。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/19775cdd-57d8-4935-8d64-77b5bf9bb174"></div><br>在拓扑图上，我们可以看到 帧F 到 网桥1 的时候将 F 转发出去，设为 F1，此时 网桥1 学习 到MACA（主机A的MAC地址）在下方接口。F1 到 F2 是 网桥2 学习到 MACA 在 上方接口，但是 帧F 到达 网桥2 的时候网桥2学习到MACA在下方接口，这便是MAC表抖动。同样的 F2 到 网桥1 的时候 网桥1 学习到 MACA 在上方接口，也会发生抖动。（注意：F、F1、F2的MAC地址一致）<br>如果数据帧按照我们上面所述的方式运行，他们会在网桥1和网桥2之间不停的转圈。<br>至于交换机自然也会出现上述的问题。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/99c85247-548b-4a65-81ce-80e5e13ba214"></div><br>解决的办法，就是在逻辑上将环打断，环打断就是棵树。一句话，就是将环打断生成树，简称为“生成树”。在网桥或交换机上运行生成树协议 STP（Spanning Tree Protocol）。生成树协议的要点是：不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。<br><br><br><br>## 无线局域网与 CSMA/CA<br><br>IEEE802.11是一个有固定基础设施的无线局域网WLAN（Wireless Local Area Network）的国际标准。简单地说，802.11 就是无线以太网的标准：使用星形拓扑，其中心叫做接入点 AP(Access Point)，在 MAC 层使用 CSMA/CA 协议，802.11 无线局域网又称为 Wi-Fi（Wireless-Fidelity，意思是“无线保真度”）。以下讨论都是这种无线局域网。<br>无线局域网最小构件是基本服务集 BSS（Basic Service Set），基本服务集里面的基站叫做接入点 AP（AccessPoint，AP 的逻辑功能等同与以太网的集线器），一个基本服务集通过接入点 AP 连接到一个主干分配系统 DS（Distribution System），然后再接入到另一个基本服务集，构成了一个扩展的服务集 ESS。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/f61ba2fe-de15-4c12-8068-b2b21fda115e"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/1f2b499a-9727-4986-8995-225524d90c5a"></div><p><br></p><h3 id="无线局域网没有碰撞检测"><a href="#无线局域网没有碰撞检测" class="headerlink" title="无线局域网没有碰撞检测"></a>无线局域网没有碰撞检测</h3><p>无线局域网逻辑上也是共享信道，采用的也是随机接入的思路。但是，无线局域网与有线局域网有一个重要的差异，无线局域网没有碰撞检测（Collision Detection）。</p><ul><li>“碰撞检测”要求一个站点在发送本站数据的同时，还必须不间断地检测信道，但接收到的信号强度往往会远远小于发送信号的强度，在无线局域网的设备中要实现这种功能就花费过大。</li><li>隐蔽站问题，如下图，有 ABCD 四个站，但 A 只知道有 B，不知道有 CD。A 和 C 互相检测不到对方的无线信号时，都以为 B 是空闲的，都向 B 发送数据，结果发生碰撞。隐蔽站问题使“碰撞检测”失去意义。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/af2532d2-b781-46fd-aea9-0f43b7589f28"></div><br>由于以上两个原因，无线局域网没有碰撞检测。为什么没有碰撞检测就成为问题了呢？因为没有碰撞检测引发了两个问题：<br>- 怎么确定发出的数据帧是否发生碰撞，是否碰撞要有明确的结论，这个结论怎么下？<br>- 在碰撞发生时，就没有感觉，撞了发送方也不会停止发送数据，仍发送数据，直到发送完才停止。不是“撞-停”的情况，而是“撞撞撞撞撞撞···”的情况，碰撞的损失过大。<br>这两个问题都需要解决。先说第一个问题，是否碰撞的结论怎么下？无线网使用了停止等待协议，由接收方发送 ACK 帧来表示正确收到数据帧，否则引发超时重传。再说第二个问题，对于这个问题的解决办法，当然就是“尽量不碰撞”。无线网为了“尽量不碰撞”，设计了一个复杂的协议 CSMA/CA。注意，CSMA/CA协议只能做到“尽量少碰撞”，做不到“完全不碰撞”。第一个问题仍需解决，无线网的 CSMA/CA 替代不了无线网的停等协议。<br><br><br><br>### CSMA/CA 协议<br><br>无线局域网没有碰撞检测，所以有线的 CSMA/CD 就被阉割为 CSMA，可不甘心，还想进一步的减少碰撞，就又加了一个 CA（Collision Avoidance 碰撞避免）功能。802.11 就使用 CSMA/CA 协议。而在使用 CSMA/CA 的同时，还增加使用停止等待协议。<br><br>#### 帧间间隔 IFS<br><br>所有的站在完成发送后，必须再等待一段很短的时间（继续监听）才能发送下一帧。这段时间的通称是帧间间隔 IFS（Inter Frame Space）。SIFS，即短（Short）帧间间隔，长度为 28us，使用 SIFS 的帧类型有：ACK 帧、CTS 帧。DIFS，即分布协调功能帧间间隔，长度为 128us。DIFS 用来发送数据帧和管理帧。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/9ba7baf3-7466-4506-84c2-8cca4944ef2a"></div><h4 id="争用窗口（二进制指数退避）"><a href="#争用窗口（二进制指数退避）" class="headerlink" title="争用窗口（二进制指数退避）"></a>争用窗口（二进制指数退避）</h4><p>信道从忙态变为空闲时，任何一个站要发送数据帧时，不仅都必须等待一个DIFS 的间隔，而且还要进入争用窗口，各站就要执行退避算法。802.11 使用二进制指数退避算法。这样做就减少了发生碰撞的概率。但其避退算法和CSMA/CD的有区别。第i次退避就在$2^{2+i}$个时隙中随机地选择一个。这就是说，第1次退避是在8个时隙（而不是2个）中随机选择一个，而第2次退避是在16个时隙（而不是4个）中随机选择一个。 这样做的目的是减少碰撞。<br>发送算法如下：</p><ol><li>如果某站点检测到信道空闲，会等待一个DIFS发送该帧。</li><li>否则该站点选取一个随机值进行避退，并且在检测到信道忙的时候递减该值。当检测不忙的时候计数值保持不变。</li><li>当计数值减为0的时候（此时信道一定为空闲），该站点发送整个数据帧并等待确认。</li><li>如果发送方收到确认，发送站点知道他的帧被目的站正确接收了，如果该站点要发送另一帧它需要从第二步开始进行。如果未收到，执行回退算法，此次会在一个更大的范围里选取。</li></ol><div align="center"><img src="http://blogfileqiniu.isjinhao.site/eeadb88c-5d8a-4bc0-bb4a-30002461f518"></div><br>需要注意，上图中的退避区间内退避算法得到的计数值不一定在减少。冻结指的就是再次检测到信道忙的时候不再减少计数值。<br><br><br><br>### 信道预约<br><br>为了更好地解决隐蔽站带来的碰撞问题，802.11 允许要发送数据的站对信道进行预约。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/796e3d46-c4d9-4ae1-af12-b9217e20a90c"></div><p><br></p><h3 id="有线与无线的对比"><a href="#有线与无线的对比" class="headerlink" title="有线与无线的对比"></a>有线与无线的对比</h3><p>无线局域网与有线局域网都是使用随机接入的方式，都是无法绝对避免碰撞的。在这种情况下，都需要考虑以下问题：尽量减少碰撞、是否碰撞要有明确结论、碰撞之后的事故处理。简单做一对比：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/5b2f531a-545f-4014-9d5f-1c9f591bb0bd"></div><br>无线网中碰撞造成的损失更大，就需要在减少碰撞的方面做更多的工作，精心设计了 CSMA/CA 协议，包含帧间间隔，争用窗口（二进制指数退避），信道预约三种机制，但仍无法完全避免碰撞。由于没有碰撞检测，是否碰撞的明确结论，由接收方发送 ACK 确认帧机制。碰撞事故处理是空，是因为将重发中的二进制指数退避已经融合到 CSMA/CA 协议中。<br><br><br><br>### 802.11 局域网的 MAC 帧<br><br>802.11 帧共有三种类型：控制帧、数据帧和管理帧。只简单讨论数据帧。数据帧的三大部分，MAC 首部，共 30 字节。帧的复杂性都在帧的首部。帧主体，数据部分不超过 2312 字节，通常都是小于 1500 字节。帧检验序列 FCS 是尾部，共 4 字节。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/21028d9d-ae4c-4f4d-bd06-eda73c2a39ce"></div><br>802.11 数据帧最特殊的地方就是有四个地址字段。地址 4 用于自组网络（博主暂未接触）。我们在这里只讨论前三种地址。地址 1 总是帧将访问的下一个设备的地址，地址 2 总是帧离开的前一个设备的地址，如果地址 1 没有定义最后的目的地址，地址 3 就是最后的目的站点的地址，如果地址 2 没有定义原始源地址，地址 3 就是原始源站点地址。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a6b5ea14-5de9-48fe-8bbb-d452b9b68fe1"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/f4e5d00a-3eb1-4e2e-b69c-385af0f8eebf"></div><br>站点 A 向 B 发送数据帧，但这个数据帧必须经过 AP 转发。首先站点 A 发送数据帧到 AP1，然后 AP1 把数据帧发送给 B。举例：A-&gt;AP1 时：<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/04e71d45-4d7d-44a9-8b46-d704cb112caf"></div><p><br></p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>ARP（Address Resolution Protocol），根据 IP 地址查询MAC 地址。ARP 协议的工作原理如下图，有 ARP 请求（Request）和 ARP 回答（Reply）两个报文。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/5fd13274-deb0-49f7-80ed-0ac4d3857d82"></div><br>ARP 报文封装成 Mac 帧，是 Mac 帧的负载，mac 帧类型值 0806 指示 mac 帧的数据部分是 ARP 报文。ARP 请求（Request）是广播，ARP 回答（Reply）是单播，见下图：ARP 请求报文所封装的 Mac 帧，目的 Mac 地址是 FF-FF-FF-FF-FF-FF，这 个地址是广播地址，交换机就会广播这个帧。ARP 请求报文和校园广播的大喇叭是不是很像呢？如果目的主机也在你的网络里，你用大喇叭喊它，要来它的mac 地址，就可以封装 mac 帧了。注意，ARP 直接封装为 MAC 帧，不是封装为 IP 报。从这点看，我个人更赞同将 ARP 理解为链路层协议。<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/0b5f2881-2e5f-469a-a93d-15aae56325d7"></div><br>报文格式：<br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/25614eda-c07d-4487-9f50-9855491f0af9"></div><p><br></p><h2 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h2><p>ARP 是设备通过自己知道的IP地址来获得自己不知道的物理地址的协议。假如一个设备不知道它自己的IP地址，但是知道自己的物理地址，应该怎么办呢？RARP（逆地址解析协议）正是针对这种情况的一种协议。<br>RARP以与ARP相反的方式工作。RARP发出要反向解析的物理地址并希望返回其对应的IP地址，应答包括由能够提供所需信息的RARP服务器发出的IP地址。虽然发送方发出的是广播信息，RARP规定只有RARP服务器能产生应答。许多网络指定多个RARP服务器，这样做既是为了平衡负载也是为了作为出现问题时的备份。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;相邻&quot;&gt;&lt;a href=&quot;#相邻&quot; class=&quot;headerlink&quot; title=&quot;相邻&quot;&gt;&lt;/a&gt;相邻&lt;/
      
    
    </summary>
    
      <category term="网络" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://isjinhao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>04.01-网络-绪论&amp;物理层</title>
    <link href="https://isjinhao.github.io/posts/52199.html/"/>
    <id>https://isjinhao.github.io/posts/52199.html/</id>
    <published>2019-12-20T09:22:11.000Z</published>
    <updated>2019-12-20T09:29:23.825Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>计算机网络就是互联的、自治的计算机集合。自治指的是所有的计算机直接没有主从关系；互联指的是互联互通，能进行数据交换。<br>计算机网络的本质是一种通信网络，只不过信源和信宿都是主机。它是计算机技术和通信技术的结合。</p><p><strong>信道</strong></p><p>信道是数据交换的载体。狭义上说人和人之间交流所承载信息的空气就是信道。广义上说它还可以包括有关的变换装置，这样的话信道往往被分成信道编码器、信道本身和信道译码器。简易通信系统模型如下：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/cb141b56-b5ee-4a92-9d19-2be0a5a24e75"></div><p><br></p><h2 id="计算机网络基本原理"><a href="#计算机网络基本原理" class="headerlink" title="计算机网络基本原理"></a>计算机网络基本原理</h2><p>分组交换技术，也就是拆分分组、传输分组、合并分组的技术。这个技术的优点就是便宜，因为把数据打包成分组和分组拆分都在计算机中进行，网络上只进行分组的转发，就使得网络的结构很简单，路由器设计也很简单。这一中原则被叫做“端到端的原则”，即能在端系统做的事情不在网络上实现。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e86bd0fa-aeae-45e2-afb5-c10e2b8af5d3" style="width:60%"></div><p><strong>主机（host）</strong></p><p>诸如手机、电脑、服务器等端系统（end systems）。</p><p><strong>交换机</strong></p><p>如果想实现多个计算机之间的互联，按照之前的想法是每两台计算机进行连接，但这样太麻烦，一个好的做法是把这个计算机连接在某一中心上，这个中心把所有连接上来的计算机进行互联，在链路层这个中心叫做交换机。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/540709b5-356a-40fd-96f6-bff6dfd4b7e7" style="width:25%"></div><p><strong>分组</strong></p><p>分组是带有地址信息的信息小片，可以理解成是计算机把一个文件切片后打成的包裹，由两部分构成：地址信息和真正传输的东西。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/9f112321-0df3-423e-bd4f-0f1311fccf6b"></div><p><strong>路由器</strong></p><p>是计算机网络的一种专用计算机，它只有一个功能，就是转发分组。可以简单的理解为路由器是电子化的邮局，全国所有的邮局之间互联，是包裹能够传递，路由器之间互联，是分组能够正确转发。<br>路由器和交换机的区别是：交换机将计算机连在一起，构成局域网；路由器将局域网连在一起，形成互联网。</p><p><br></p><h3 id="分组交换技术"><a href="#分组交换技术" class="headerlink" title="分组交换技术"></a><strong>分组交换技术</strong></h3><ol><li>一个主机至少连接一个路由器：数据最终是通过路由器进行转发的，所以一个主机至少得连接一个路由器。</li><li>分组存储转发：分组完全进入路由器后，路由器按照地址信息检索转发表。注意不是第一个bit或Byte进入时就开始转发，是全部进入才转发。</li><li>分组独立选择路径：一个文件被分成多个分组，但这些分组之间是独立的，路由器给他们看成相互独立的数据。分组的组装是通过接收方进行的，和网络无关。</li></ol><p><br></p><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><p><strong>ISP</strong></p><p>ISP，全称为Internet Service Provider，因特网服务提供商，即指提供互联网服务的公司。能提供拨号上网服务、网上浏览、下载文件、收发电子邮件等服务。</p><p><strong>不同角度看Internet</strong></p><ul><li>组成细节角度：ISP网络互联形成的网络之网络。由运行各种网路应用的计算设备，光纤、铜缆、无线电等通信链路、路由器和交换机等组成的分组交换设备组成。</li><li>服务角度：是为网络应用提供通信服务的通信基础设施和为网络应用提供的应用编程接口。</li></ul><p><br></p><h3 id="Internet结构"><a href="#Internet结构" class="headerlink" title="Internet结构"></a>Internet结构</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6c2e0e1d-7464-4e21-9613-555098981116" style="width:70%"></div><ul><li><code>一级ISP包含</code>：网通、电信等商业ISP，还包含谷歌、微软等内容提供商网络。</li><li><code>IXP</code>：全称：Internet eXchange Point，即互联网交换中心。互联网Internet是由众多的网络互相连接而形成的全球性网络，互联网交换中心负责这些不同的网络之间互相通信的交换点，是互联网的关键基础设施。</li></ul><p><br></p><h2 id="网络的结构"><a href="#网络的结构" class="headerlink" title="网络的结构"></a>网络的结构</h2><ul><li>网络边缘：位于“网络边缘”运行网络应用程序的端系统。</li><li>接入网络、物理介质：有线或无线的通信链路。</li><li>网络核心：互联的路由器（或分组转发设备）。构成“网络之网络”的关键。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/be135250-0412-4b86-8a24-fc9721f3e72a" style="width:25%"></div><p><br></p><h3 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h3><p>接入网络是一种用户网络，它连接用户到特定的服务提供商并通过承载网络到达其他网络。两个被用户关心的特征：带宽（数据传输速率，bps）、独占/共享（独占是带宽为某用户独用，共享是多个用户分用同一带宽）。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/f3a7b5dd-8def-42e9-a42b-dab1f978146a" style="width:45%"></div><p><strong>家庭接入</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/4e2f6236-0695-4119-aeab-83a40f1c6872" style="width:60%"></div><p><strong>机构（企业）接入</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/746d62b1-e5b4-45c2-add6-ab4481d685d5" style="width:55%"></div><p><strong>无线局域网</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/fbf80f8f-4746-447e-a9b6-aef4e6efe108" style="width:25%"></div><p><strong>广域局域网</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/5b47b9b2-71be-4283-8fc5-ee8199b954d2" style="width:30%"></div><p><br></p><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>网络核心的功能是：路由（routing）：确定分组从源到目的传输路径；转发（forwarding）：将分组从路由器的输入端口交换至正确的输出端口。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/62b0406d-4aef-4de6-8280-651809e62c3f" style="width:70%"></div><p><br></p><h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>包含三个阶段：建立连接、通信、释放连接。最显著的特点是独占电路资源。最典型的是电话网络。（下图的中继线上可以存在多组用户通信，详见复用技术）</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/d6034a53-8e86-47fc-bf19-5bf762352514" style="width:80%"></div><p><br></p><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>报文交换是指把信息整个打包，然后经过存储转发送到目的地。</p><p><br></p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>分组交换是把信息拆分成不同的分组，然后把所有的分组相继发送给路由器，路由器通过路由&amp;转发把数据传输到目的地。</p><ul><li>和报文交换的区别是：报文交换不拆分信息。</li><li>和电路交换的区别是：如果把每个分组看成原子单位，区别就是各分组走不同的路径，不需要独占资源。</li></ul><h4 id="分组交换的优势"><a href="#分组交换的优势" class="headerlink" title="分组交换的优势"></a>分组交换的优势</h4><ul><li>和报文交换相比：速度快，因为在报文交换时，同一时间只有一个路由器在工作，其他路由器在等待。路由器的存储空间小，最低存储空间和分组大小差不多。</li><li>和电路交换相比：分组交换允许更多用户同时使用网络，让网络资源充分共享。</li></ul><h4 id="分组交换的劣势"><a href="#分组交换的劣势" class="headerlink" title="分组交换的劣势"></a>分组交换的劣势</h4><p>可能产生拥塞（congestion）：分组延迟和丢失。需要协议处理可靠数据传输和拥塞控制。</p><p><br></p><h3 id="图解三种交换"><a href="#图解三种交换" class="headerlink" title="图解三种交换"></a>图解三种交换</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/8285469f-5cc3-4866-8578-a7a72f4aba93" style="width:80%"></div><p><br></p><h2 id="网络性能参数"><a href="#网络性能参数" class="headerlink" title="网络性能参数"></a>网络性能参数</h2><p><strong>速率 &amp; 带宽</strong></p><ul><li>速率：又称数据率，数据传输速率或比特率。单位bps、kbps、Mbps、Gbps。</li><li>带宽：数字信道所能传输的最大数据率。单位bps等。</li></ul><p><strong>丢包</strong></p><p>如果路由器的缓存满了，再到达的分组会被路由器丢弃，即造成丢包现象。丢包率 = 丢包数 / 已发分组数。</p><p><strong>分组延迟</strong></p><ul><li>结点处理延迟：差错检测、确定输出链路；</li><li>排队延迟：等待输出链路可用、取决于路由器拥塞程度；</li><li>传输延迟：分组长度/链路带宽；</li><li>传播延迟：物理链路长度/信号传输速度。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/bb29b169-33bb-4979-a91e-c1e282396508" style="width:60%"></div><p><strong>流量强度</strong></p><p>设链路带宽为R(bps)，分组长度为L(bits)，平均每组到达速率为v。则：</p><ul><li>$L \ast v / R \longrightarrow 0 $时：平均排队延迟很小；</li><li>$L \ast v / R \longrightarrow 1$时：平均排队延迟很大；</li><li>$L \ast v / R &gt; 1$时：超出服务能力，延迟 趋向于 无限大。</li></ul><p><strong>时延带宽积</strong></p><p>$时延带宽积 = 传播时延 \ast 带宽$，单位：bit。实际意义是：从我们向某一信道上发送第一个bit，到这个bit被接收方接受这个时间里，发送方总共向信道上发送了多少bit。也可以称为以比特为单位的链路长度，比如某段链路长度为n比特。</p><p><strong>吞吐率/量（Throughput）</strong></p><p>发送端与接收端之间的传送数据率（b/s）。端到端的吞吐量取决于瓶颈链路。</p><p><br></p><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>network protocol。为进行网络中的数据交换而建立的规则、标准或约定。其中规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到的消息或发生的事件而产生的动作。也可以说网络协议规定了网络中所有信息的发送和接受过程。</p><p><strong>协议三要素</strong></p><ul><li>语义：语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。</li><li>语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。</li><li>时序：时序是对事件发生顺序的详细说明。（也可称为“同步”）。<br>总结：语义表示要做什么，语法表示要怎么做，时序表示做的顺序。</li></ul><p><br></p><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><p>指通信系统的整体设计，它为网络硬件、软件、协议、存取控制和拓扑提供标准。计算机网络是一个非常复杂的系统，需要解决的问题很多并且性质各不相同。所以，在设计时使用了“分层”的思想，即将庞大而复杂的问题分为若干较小的易于处理的局部问题。各层之间是按照功能进行分层的，同时每层遵循相应的网络协议完成本层功能。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/db782db0-9889-4ba0-a9a3-92684553f7b5"></div><p><strong>各层的主要功能</strong></p><ul><li>应用层：为用户提供具体的网络应用服务。</li><li>运输层：通过中间网络，两个主机中进程之间的通信服务。包含有可靠通信的协议TCP和无可靠性的协议UDP。</li><li>网络层：两台主机间的通信。分组交换网上的两台主机间的通信，选择合适的路由，构建互联网络，这些是同一件事的不同说法。</li><li>数据链路层：两个相邻结点之间，数据的可靠传输。</li><li>物理层：透明地传送比特流。<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/b7177899-d60c-43b9-b045-50e37fddc7bc"></div></li></ul><p><strong>各层传输数据的叫法</strong></p><ul><li>协议数据单元PDU（Protocol Data Unit）：对等层之间传送数据的单位。</li><li>服务数据单元SDU（Service Data Unit）：层与层之间交换数据的单位。<br>即：<code>PDU=首部+SDU=下一层的SDU</code>。<div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/c00de438-4b7e-4c9e-8039-fa14b1376978"></div></li></ul><p><br></p><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><p>假如基带信号是<code>101011000110111010...</code>，如果直接发送，则每个码元携带一个比特的信息（每个码元只有2种状态），但是如果将信号中的三个比特编为一组，即101，011，000，110，111，010…，三个比特共有8种不同的排列，我们可以用不同的调制方法来表示这种信，如8种不同的振幅，频率，相位等，如果采用相位调制，相位$\phi_0$表示000，$\phi_1$表示001，以此类推，那么接收端如果收到相位是$\phi_0$的信号就知道表示的是000，以此类推，这样一个码元就不知不觉的传输了三个比特位的信号，此时每个码元有8种状态。一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难。</p><p><strong>编码级别</strong></p><p>如果把n个比特编码成一个码元，则此时编码状态$M=2^n$，其表示当前传输时有多少不同的状态，如8级编码，会有：<code>000、001、010 …</code>，共计8种状态。</p><p><br></p><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><p>数据通信中很自然很重要的一个问题：在一个通道中，能够以多快的速率发送数据，即每秒钟能发送多少比特？比特是由电磁信号携带的，所以这个问题要再拆分一下：</p><ol><li>问题1：在一个通道中，能够以多快的速率发送信号？</li><li>问题2：一个信号能携带多少个比特？</li></ol><p><br></p><h3 id="奈斯准则"><a href="#奈斯准则" class="headerlink" title="奈斯准则"></a>奈斯准则</h3><p><strong>码间串扰</strong></p><p>码元的传输速率是有限制的，超过某上限就会出现码间串扰问题。这是由于在真正传输中，信号在传输时都不是理想化的，如下图就是理想化的高低电平和真实传输时的高低电平。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/86866885-db6c-4686-a45d-f1c29d05e60a" style="width:40%"></div><p>假如此时速度太快，就可能把低电平和高电平弄混。而最高的码元传输速率被奈斯准则限制。</p><p><strong>奈斯准则内容</strong></p><ul><li>理想低通信道（能通过信号频率在某值之下）的最高码元传输速率为：$2W Baud$。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/68d8fe1f-0d45-4778-b233-ca72ca0cb4fd" style="width:80%"></div><ul><li>理想带通信道（能通过信号频率在某范围之内）的最高码元传输速率为：$1W Baud$。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/7ec776ff-084d-4641-884e-c82bf93ae0b4" style="width:80%"></div><p>W是理想低通信道的带宽，单位为赫(Hz)。Baud 是波特，是码元传输速率的单位，1 波特为每秒传送 1 个码元。</p><ul><li>波特率：单位时间内数据通信系统所传输的码元个数（信号个数），单位是波特（Baud）。</li><li>比特率：表示单位时间内数据通信系统传输的比特数，单位是比特/秒（b/s或bps）。$比特率 = 波特率 * log_2M$</li></ul><p><br></p><h3 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h3><p><strong>编码级数限制</strong></p><p>虽然码元传输速率有限制，但是如果我们能尽可能提高编码级数不就能提升信息传输速率了吗？但事实上信号传输速率不受限于调制技术，而是受限于信噪比。举个例子，如果我们是在天气晴朗的一天出门，我们穿任意颜色衣服都能被分辨出来，但是如果我们在沙尘暴天气出门，穿<code>橘黄</code>和<code>橙黄</code>两种颜色的衣服别人自然就认不出来了。在这个比喻中衣服的颜色代表码元，确定衣服的颜色代表信息，沙尘暴就是噪声。</p><p><strong>香农公式内容</strong></p><p>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率$C=W \ast log_2(1+PS/PN)（b/s）$。</p><ul><li>其中$W$是信道的带宽。$PS$是信号的能量。$PN$是噪声的能量。</li><li>信噪比：$S/N=10lg{PS/PN}$。<br>举例：带宽是<code>1MHz</code>，信噪比是<code>24dB</code>，则信道的最高信息传输速率：$C=1M \ast log_2{(1+(10^{2.4}))}=7.98Mbps$。</li></ul><p><br></p><h3 id="奈氏准则vs香农公式"><a href="#奈氏准则vs香农公式" class="headerlink" title="奈氏准则vs香农公式"></a>奈氏准则vs香农公式</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6011892c-da47-4cf8-a1e8-a7acf176cd0f" style="width:80%"></div><p><br></p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>电路交换中独占电路资源，并不是指用户线和中继线都被此次交换所独占，而是说在两个用户建立连接之后，除非连接中断，否则他们当前所拥有的资源不会被释放，即使他们之间不传输信息。而如何在中继线上实现多组用户通信就是多路复用技术。<br>产生多路复用的物理基础是：传输媒体的带宽或容量往往会大于传输单一信号的需求，使用多路复用，为了有效地利用通信线路，希望一个信道同时传输多路信号。<br>这种技术会将链路/网络资源（如带宽）划分为“资源片”，将资源片分配给各路“呼叫”（calls），每路呼叫独占分配到的资源片进行通信，资源片可能“闲置”<br>常见的复用技术有：频分多路复用、时分多路复用、波分多路复用、码分多路复用。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a0a4f676-e2fd-47d2-bdbb-566054c38206" style="width:80%"></div><p><strong>频分多路复用</strong></p><p>FMD：Frequency-division multiplexing，是指载波带宽被划分为多种不同频带的子信道，每个子信道可以并行传送一路信号的一种多路复用技术。也就是说信道的可用频带被分成若干个互不交叠的频段，每路信号用其中一个频段传输，因而可以用滤波器将它们分别滤出来，然后分别解调接收。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e2799478-b496-4a0a-853f-bfc708b69443" style="width:40%"></div><p><strong>时分多路复用</strong></p><p>TDM：time division multiplexing，它使不同的信号在不同的时间内传送，将整个传输时间分为许多时间间隔（Time Slot，TS，又称为时隙），每个时间片被一路信号占用。TDM就是通过在时间上交叉发送每一路信号的一部分来实现一条电路传送多路信号的。电路上的每一短暂时刻只有一路信号存在。因数字信号是有限个离散值，所以TDM多应用于数字通信系统。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/64c09afb-772f-43a0-90a9-cd44eeec4368" style="width:70%"></div><p><strong>波分多路复用</strong></p><p>将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器（亦称合波器，Multiplexer）汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；在接收端，经解复用器（亦称分波器或称去复用器，Demultiplexer）将各种波长的光载波分离，然后由光接收机作进一步处理以恢复原信号。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/08d98e2f-6c88-430f-9bb7-e055f3c4b476" style="width:70%"></div><p><strong>码分多路复用</strong></p><p>为每个用户分配一个唯一的mbit的码片序列（chipping sequence），二进制下的0用-1表示，二进制下的1用+1表示。在信道上传输的信号 = 原始数据 <em>码片序列，比如码片序列是：(-1, 1, 1)，需要传一个0，应该是 -1 </em>(-1, 1, 1)，所以传输的就是(1, -1, -1)。<br>同时为了保证数据之间不相互影响，被共享的用户所占有的码片应该相互正交的。即：$\frac{1}{m}S_i \cdot S_j = 0 (i \neq j)$。而信道上真正传输的数据是各用户发送数据的叠加值。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/79261e94-12b6-41c9-a4e0-0759e893e6ea" style="width:80%"></div><p><br></p><h2 id="数字信号在模拟信道传输"><a href="#数字信号在模拟信道传输" class="headerlink" title="数字信号在模拟信道传输"></a>数字信号在模拟信道传输</h2><p>数字信号需要编码后才能传输。常见的三种编码：</p><ol><li>NRZ编码：进制数字0、1分别用两种电平来表示。常用-5V表示1，+5V表示0。</li><li>曼切斯特编码：用电压的变化表示0和1：高→低 &lt;=&gt; 0，低→高 &lt;=&gt; 1。</li><li>差分曼切斯特编码：在码元开始处有无跳变来表示0和1：有 &lt;=&gt; 0，无 &lt;=&gt; 1。</li></ol><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e8108185-883f-4246-92a3-e68184a1baf8" style="width:80%"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;
      
    
    </summary>
    
      <category term="网络" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://isjinhao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>04.03-网络-网络层</title>
    <link href="https://isjinhao.github.io/posts/12139.html/"/>
    <id>https://isjinhao.github.io/posts/12139.html/</id>
    <published>2019-12-20T09:22:11.000Z</published>
    <updated>2019-12-20T09:29:23.839Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><blockquote><p>网络层分为两分布，网络构建和网络通信</p></blockquote><p><br></p><h2 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h2><p>Autonomous System，AS。每个AS由一组通常处在相同管理控制下的路由器组成。一个ISP中的路由器以及连接他们的线路可以构成一个AS，一个ISP也可以将他们的网络划分成多个AS。每个AS由一个唯一的ASN来标识。所以在构建网络的时候，我们需要对 AS 内的网络和 AS 之外的网络进行区分。这两个统称为路由协议。</p><p><strong>内部网关协议</strong></p><p>Interior Gateway Protocol （IGP），用于自治系统（AS）内部的路由交换也叫做域内路由选择（intradomain routing），如 RIP 和 OSPF 协议</p><p><strong>外部网关协议</strong></p><p>Exterior Gateway Protocol （EGP），用于不同自治系统（AS）之间的路由交换，也叫做域间路由选择（interdomain routing），目前使用最多的是 BGP-4。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/80d95615-de0a-4b0f-9a33-94f3c2b3cd37"></div><p><strong>路由选择算法分类</strong></p><p>常用的分类是：每个路由器知道的是全局的信息还是分散的信息？</p><ul><li>全局的<ul><li>所有的路由器具有完整的拓扑和链路费用信息</li><li>“链路状态(L-S)”算法</li><li>应用于RIP协议</li></ul></li><li>分散的<ul><li>路由器只知道物理连接的邻居和到邻居的链路费用</li><li>迭代的计算过程，与邻居交换信息</li><li>“距离向量(D-V)”算法</li><li>应用于OSPF协议</li></ul></li></ul><p><br></p><h2 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h2><p>基于距离向量的分布式路由选择协议，规定：</p><ul><li>“距离”为到目的网络所经过的路由器数。</li><li>从一路由器到直接连接的网络的距离定义为 1。</li><li>RIP允许一个通路最多包含15个路由器，多于15个路由器时不可达。</li><li>RIP不能在两个网络之间同时使用多条路由，它选择一个具有最少路由器的路由，具有相同路径长度的路规定先入为主。</li></ul><p><br></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>仅和相邻路由器交换信息。</li><li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。</li><li>按固定的时间间隔交换路由信息，例如，每隔 30 秒。</li></ul><p><br></p><h3 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h3><p>收到相邻路由器（其地址为 X）的一个 RIP 报文：</p><ol><li>先修改此 RIP 报文中的所有项目：将“下一跳”字段中的地址都改为 X，并将所有的“距离”字段的值加 1。</li><li>对修改后的 RIP 报文中的每一个项目，重复以下步骤：<ul><li>若项目中的目的网络不在路由表中，则将该项目加到路由表中。</li><li>否则<ul><li>若下一跳字段给出的路由器地址是同样的，则将收到的项目替换原路由表中的项目</li><li>否则<ul><li>若收到项目中的距离小于路由表中的距离，则进行更新</li><li>否则，什么也不做。</li></ul></li></ul></li></ul></li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则将此相邻路由器记为不可达的路由器，即将距离置为16（距离为16表示不可达）。</li><li>返回。</li></ol><p><br></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>一开始，各路由表只有到相邻路由器的信息：</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/877953f4-af6f-424c-b4ce-e93378883861"></div><p>路由器 B 收到相邻路由器 A 和 C 的路由表：<br>修改 A 的路由表，将 RIP 报文中的所有项目下一跳的字段都改成 A ，距离增加 1。<br>| 目的网络 | 距离 | 下一跳 |<br>| :——: | :–: | :—-: |<br>| 1 | 2 | A |<br>| 2 | 3 | A |<br>| 3 | 3 | A |<br>修改 C 的路由表，将 RIP 报文中的所有项目下一跳的字段都改成 C ，距离增加 1。<br>| 目的网络 | 距离 | 下一跳 |<br>| :——: | :–: | :—-: |<br>| 4 | 2 | C |<br>| 6 | 2 | C |<br>将 B 原来不可达的项目加入到B的路由表中，加入后B的路由表：<br>| 目的网络 | 距离 | 下一跳 |<br>| :——: | :–: | :—-: |<br>| 3 | 1 | - |<br>| 4 | 1 | - |<br>| 1 | 2 | A |<br>| 2 | 2 | A |<br>| 6 | 2 | C |<br>修改 收到的目的网络原本在B路由器中且下一跳的字段和原B路由表项目中的字段一致 的项目，发现不用修改。<br>修改 B 可达，A和C也可达的项目，发现收到项目中的距离小于路由表中的距离，则进行更新，否则不更新。则修改后B的路由表是：<br>| 目的网络 | 距离 | 下一跳 |<br>| :——: | :–: | :—-: |<br>| 3 | 1 | - |<br>| 4 | 1 | - |<br>| 1 | 2 | A |<br>| 2 | 2 | A |<br>| 6 | 2 | C |</p><p><br></p><h3 id="RIP-协议的优缺点"><a href="#RIP-协议的优缺点" class="headerlink" title="RIP 协议的优缺点"></a>RIP 协议的优缺点</h3><ul><li>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。即好消息传播得快，而坏消息传播得慢。</li><li>RIP 协议最大的优点就是实现简单，开销较小。</li><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li></ul><p><strong>好消息传播得快，坏消息传播得慢</strong></p><p>在正常情况下，R1中项目表示到网1距离为1，R2中项目表示到网1距离为2。R2收到 R1 的项目后修改R2的项目为：1 2 R1，R2发现到网1的下一跳为R1，和原路由表一致，修改原路由表该项目为：1 2 R1。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/05b3939d-9535-4f8b-a62e-fa0a9bdb227b"></div><p>R1 说：“我到网 1 的距离是 16 （表示无法到达），是直接交付”。但 R2 在收到 R1 的更新报文之前，还发送原来的报文，因为这时 R2 并不知道 R1 出了故障。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6907f7d7-c64d-4cae-a506-1eafebd225a6"></div><p>我们列出一个网1出现故障后的交换表：<br>| | R1 | R2 |<br>| :—: | :—–: | :—–: |<br>| 正常 | 1 1 - | 1 2 R1 |<br>| 故障 | 1 16 - | 1 2 R1 |<br>| 第1次 | 1 3 R2 | 1 16 R1 |<br>| 第2次 | 1 16 R2 | 1 4 R1 |<br>| 第3次 | 1 5 R2 | 1 16 R1 |<br>| … | … | … |<br>这样不断更新下去，直到 R1 和 R2 到网 1 的距离都增大到 16 时，R1 和 R2 才知道网1是不可达的。</p><p><br></p><h3 id="RIP协议的位置"><a href="#RIP协议的位置" class="headerlink" title="RIP协议的位置"></a>RIP协议的位置</h3><ul><li>RIP 协议使用运输层的用户数据报 UDP进行传送（使用 UDP 的端口 520）。</li><li>因此 RIP 协议的位置应当在应用层。但转发 IP 数据报的过程是在网络层完成的。<br>这时有一个困惑，RIP是网络层协议，可是为什么用UDP封装？因为路由器虽然是网络层设备，但并不代表他只具备物理层、链路层、网络层功能，他还具备一些应用层的功能，当遇到RIP报文这类应用层的协议，他也能够解封。然后读取RIP报文中的下一跳路由。</li></ul><p><br></p><h3 id="RIP2-协议的报文格式"><a href="#RIP2-协议的报文格式" class="headerlink" title="RIP2 协议的报文格式"></a>RIP2 协议的报文格式</h3><p>RIP2由RIP而来，属于RIP协议的补充协议，提升装载的信息量，增加安全性。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/b3e522eb-a295-43fa-a8ad-db7c9a5a40d2"></div><p><br></p><h2 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h2><p>开放最短路径优先协议OSPF （Open Shortest Path First）。</p><p><br></p><h3 id="RIP-协议的问题"><a href="#RIP-协议的问题" class="headerlink" title="RIP 协议的问题"></a>RIP 协议的问题</h3><ul><li>以跳数评估的路由并非最优路径</li><li>最大跳数16导致网络尺度小</li><li>收敛速度慢</li><li>更新发送全部路由表浪费网络资源</li></ul><p><br></p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li>向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。<ul><li>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”（metric）。</li></ul></li><li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</li></ul><p><br></p><h3 id="链路状态数据库"><a href="#链路状态数据库" class="headerlink" title="链路状态数据库"></a>链路状态数据库</h3><p>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得快是其重要优点。</p><p><br></p><h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/f82cf955-ba06-4232-9e93-ed9fa5c8aa0b"></div><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th></tr></thead><tbody><tr><td style="text-align:center">初始化1</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">6</td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center">+无穷</td><td style="text-align:center">+无穷</td></tr><tr><td style="text-align:center">第1步</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center"><strong>2</strong></td><td style="text-align:center">+无穷</td></tr><tr><td style="text-align:center">第2步</td><td style="text-align:center">0</td><td style="text-align:center"><strong>2</strong></td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">第3步</td><td style="text-align:center">0</td><td style="text-align:center"><strong>2</strong></td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">6</td></tr></tbody></table><p>路径：1 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 3 -&gt; 6</p><p><br></p><h3 id="OSPF-的区域-area"><a href="#OSPF-的区域-area" class="headerlink" title="OSPF 的区域(area)"></a>OSPF 的区域(area)</h3><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。每一个区域都有一个 32 bit 的区域标识符（用点分十进制表示）。区域也不能太大，在一个区域内的路由器最好不超过 200 个。 同时 OSPF 划分为两种不同的区域：</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/e8c18218-ed29-4398-8bdd-0ca802b40a8c"></div><p>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。OSPF 使用层次结构的区域划分。在上层的区域叫作主干区域(backbone area)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。 图中的R3、R4、R6、R7是主干路由器。</p><p><br></p><h3 id="OSPF-载体"><a href="#OSPF-载体" class="headerlink" title="OSPF 载体"></a>OSPF 载体</h3><ul><li>OSPF 不用 UDP 而是直接用 IP 数据报传送。</li><li>OSPF 构成的数据报很短。这样做可减少路由信息的通信量。</li><li>数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</li></ul><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/3efadacc-da1f-41a2-8b64-81c10d07c755"></div><p><br></p><h3 id="OSPF-的五种分组类型"><a href="#OSPF-的五种分组类型" class="headerlink" title="OSPF 的五种分组类型"></a>OSPF 的五种分组类型</h3><ul><li>类型1，问候（Hello）分组。</li><li>类型2，数据库描述（Database Description）分组。</li><li>类型3，链路状态请求（Link State Request）分组。</li><li>类型4，链路状态更新（Link State Update）分组，用洪泛法对全网更新链路状态。</li><li>类型5，链路状态确认（Link State Acknowledgment）分组。</li></ul><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/91d30389-500d-4b4c-8ae0-f7e60f34f956"></div><p><br></p><h2 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h2><p>BGP 是不同自治系统的路由器之间交换路由信息的协议。 BGP 较新版本是 2006 年 1 月发表的 BGP-4，可以将 BGP-4 简写为 BGP。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/a0012ab0-82aa-4243-8b0c-7a9ad66a00f6"></div><p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP 发言人” 。一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。<br>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话（session），利用 BGP 会话交换路由信息。使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站或对等站。</p><p><br></p><h3 id="BGP报文"><a href="#BGP报文" class="headerlink" title="BGP报文"></a>BGP报文</h3><ul><li>打开（Open）报文，用来与相邻的另一个BGP发言人建立关系。</li><li>更新（Update）报文，用来发送某一路由的信息，以及列出要撤消的多条路由。</li><li>保活（Keepalive）报文，用来确认打开报文和周期性地证实邻站关系。</li><li>通知（Notificaton）报文，用来发送检测到的差错。</li></ul><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/e82597b8-4c61-4f6e-840c-efa802aacd75"></div><p><br></p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><ul><li>IP协议<ul><li>只有一种报文格式：IP报文</li><li>功能：传递上层数据</li><li>缺乏：应付可能出现差错的能力</li></ul></li><li>网际控制报文协议 ICMP (Internet Control Message Protocol)<ul><li>IP的辅助协议</li><li>为IP提供差错报告机制</li><li>同时为其它层（TCP/UDP、应用）提供辅助功能<br>ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</li></ul></li></ul><p><br></p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/43d8be87-449f-4b2e-8c98-8e4c7ac25b92" width="80%"></div><p><br></p><h3 id="差错报告报文"><a href="#差错报告报文" class="headerlink" title="差错报告报文"></a>差错报告报文</h3><ul><li>终点不可达</li><li>源点抑制(Source quench)</li><li>时间超过</li><li>参数问题</li><li>改变路由（重定向）(Redirect)</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/d8ee4745-03c7-48f6-af25-c2c1c53f51e4" width="80%"></div><p><br></p><h3 id="询问报文"><a href="#询问报文" class="headerlink" title="询问报文"></a>询问报文</h3><ul><li>回送请求和回答报文</li><li>时间戳请求和回答报文</li></ul><p><br></p><h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h3><p>Ping发送一个ICMP 报文；回声请求消息给目的地并报告是否收到所希望的ICMPecho （ICMP回声应答）。它是用来检查网络是否通畅或者网络连接速度的命令。</p><blockquote><p>此上是<strong>网络层-网络构建</strong>部分<br>此下是<strong>网络层-网络通信</strong>部分</p></blockquote><p><br></p><h2 id="网络通信分类"><a href="#网络通信分类" class="headerlink" title="网络通信分类"></a>网络通信分类</h2><p>不同主机间的数据通信可以分为三种：两个主机属于同一个网、两个主机属于相邻的两个网中、两个主机属于不相邻的两个网络中。其中第一类是链路层所解决的问题，而后两类都是网络需要解决的问题，图示如下。为了叙述方便，博主将第二类情况简称“两个网”，第三类情况简称“三个网”，但实际上“三个网”的理论可以推广到“n个网”中。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/df9159ab-39c1-4e1e-b875-f79439ce098b"></div><p><br></p><h2 id="传统的IP地址划分"><a href="#传统的IP地址划分" class="headerlink" title="传统的IP地址划分"></a>传统的IP地址划分</h2><p>传统的IP地址划分规则中，地址由两个部分组成：网络号 + 主机号。具有相同网络号的IP地址属于同一个网络。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/b7f583ca-bd60-416e-ba0c-e15933180e04"></div><p>同时网络被划分为5类：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/17a560db-9ff3-4055-a487-e836f9d51394"></div><p>但是并不是所有的主机号都能被用来标识主机，主机号全为0的IP地址被称为网络地址，标识一个网络。主机号全为1的地址被称为广播地址，用于向某个网络的所有主机广播。例：主机 212.111.44.136 所在网络的广播地址为212.111.44.255。而对于任意一个主机若想向其所在的网络中广播都可以使用255.255.255.255。按照这个划分我们可以得到各类地址的特性：</p><p><strong>A类地址</strong></p><ul><li>前1字节标识网络地址，后3字节标识主机地址</li><li>每个网络最多可容纳（$2^{24} －2$）台主机</li><li>从高位起，前1位为“0”，第1字节用十进制表示的取值范围为“0～127”</li><li>具有A类地址特征的网络总数为126个</li></ul><p><strong>B类地址</strong></p><ul><li>前2字节标识网络地址，后2字节标识主机地址</li><li>每个网络最多可容纳（$2^{16} －2$）台主机</li><li>从高位起，前2位为“10”，第1字节用十进制表示的取值范围为“128～191”</li><li>具有B类地址特征的网络总数为 $2^{14} －1$ 个</li></ul><p><strong>C类地址</strong></p><ul><li>前3字节标识网络地址，后1字节标识主机地址</li><li>每个网络最多可容纳254台主机</li><li>从高位起，前3位为“110”，第1字节用十进制表示的取值范围为“192～223”</li><li>具有C类地址特征的网络总数为 $2^{21} －1$个</li></ul><p><strong>D类地址</strong></p><ul><li>多播通信地址（multicast address）</li><li>从高位起，前4位为“1110”，第1字节用十进制表示的取值范围为“224－239”，用于标识multicast通信地址</li><li>后28位用于区分不同的multicast组</li></ul><p><strong>E类地址</strong></p><ul><li>从高位起，前4位为“1111”，第1字节用十进制表示的取值范围为“240－255”，用于标识E类地址</li><li>后28位留作它用</li></ul><p><br></p><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>早期的 IP 地址的设计确实不够合理。会存在如下问题：</p><ul><li>IP 地址空间的利用率有时很低。</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li><li>两级的 IP 地址不够灵活。</li><li>网络很快就被分配完了。<br>所以从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址。但划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。其实现思路就是从主机号借用若干个比特作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个比特。</li></ul><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/30996293-909a-4077-bc46-c4b25db49e4d"></div><p><br></p><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><p>划分子网后仍然没有解决IP V4的问题，1992年互联网的三大危机：</p><ul><li>B类地址耗尽</li><li>路由表爆炸</li><li>IP地址整体耗尽<br>无分类域间路由选择，Classless Inter-Domain Routing，是为解决上述危机而开发的一种方案。<br>在CIDR技术中，IP 地址由两部分组成，网络前缀 + 主机号。CIDR 还使用“斜线记法”(slash notation)，它又称为CIDR记法，即在IP地址后面加上一个斜线“/”，然后写上网络前缀所占的比特数（这个数值对应于三级编址中子网掩码中比特 1 的个数）。CIDR 将网络前缀都相同的连续的 IP 地址组成“CIDR地址块”。</li><li>128.14.32.0/20 表示的地址块共有 212 个地址（因为斜线后面的 20 是网络前缀的比特数，所以主机号的比特数是 12）。</li><li>这个地址块的起始地址是 128.14.32.0。</li><li>在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”。</li><li>128.14.32.0/20 地址块的最小地址：128.14.32.0。128.14.32.0/20 地址块的最大地址：128.14.47.255</li><li>全 0 和全 1 的主机号地址一般不使用。</li></ul><p><br></p><h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3><p>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由，减少了路由器之间的路由信息交换。路由聚合也称为构成超网。（super netting）。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/62ef63c5-d9c2-4c42-8ead-5b8ff4c891bb"></div><p>这个 ISP 共有 6 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每一个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，只需用路由聚合后的 1 个项目 206.0.64.0/18 就能找到该 ISP。 需要注意的是若是因特网中某路由器想标识该ISP，只需要记录206.0.64.0/18，但是对于ISP内的路由器还是会将各子地址块的网络地址记录。</p><p><br></p><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><ul><li>使用 CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果。</li><li>应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配（longest-prefix matching）。</li><li>网络前缀越长，其地址块就越小，因而路由就越具体。</li><li>最长前缀匹配又称为最长匹配或最佳匹配。</li></ul><p><br></p><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>如果把计算机网络与快递网络做类比，假设东北大学是一个网络，西南大学是一个网络，东北大学想向西南大学寄点东西那么它需要通过自己学校的驿站寄到西南大学的驿站。网络之间进行通信的时候也需要有一个这种“驿站”。这便是网关。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6f3f0b89-45f9-433c-9d93-fedd1ef553f6"></div><p>默认网关就是为主机转发分组的路由器网络接口，就是主机的第一跳路由器，网关就是你邮信时需要找到的校园邮筒的地址，即默认网关是在网关中选一个。主机 H1 的默认网关是路由器的 E0 接口。“两个网”时，需要正确配置网关。网关是主机的第一跳路由器。举例：假设主机 H2 的 E0 接口 IP 地址 100.16.0.1，掩码 255.255.0.0，E1 接口 IP 地址 100.17.0.1，掩码 255.255.0.0：主机 H1 本地连接 IP 地址 100.16.0.2，掩码 255.255.0.0，默认网关 100.16.0.1。主机 H3 的默认网关是什么呢？100.16.0.1。主机 H5 的默认网关又是什么？是100.17.0.1。<br>在“多个网”时，多个网络如何互联？我们看下面的网络拓扑图，这是 3 个路由器连接了 4 个网络。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/9925731e-bd05-4bc0-aa7c-f361df4228fe"></div><p>假设网 1 内部有一个主机 H1，网 1 内部只有一个路由器 R1，因此默认网关只能设为 R1 的 15.0.0.4，再配置好 IP 地址，就可以与外网通信了。假设网 2 内部有一个主机 H3，在网 2 内有两个路由器 R1 和 R2，可以任选一个做默认网关，假设选 R2，默认网关设为 20.0.0.9，再配置好 IP 地址，就可以与外网通信了。<br>再讨论如何配置路由器。路由器不傻，只要配置好路由器接口的 IP 地址，路由器会从接口的 IP 地址计算出网络地址，也就是说路由器能看清自己身边的网络。至于路由器是怎么看到的，在网络层-网络构建中会解释。</p><p><br></p><h2 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h2><p>之前说了这么多都是在做铺垫，本篇博文主要想介绍的一点是路由器是如何转发不同网络中的数据包。算法如下：</p><ol><li>从收到的分组的首部提取目的 IP 地址 D。</li><li>先用各网络的子网掩码和 D 逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行3。</li><li>若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行4。</li><li>对路由表中的每一行的子网掩码和 D 逐位相“与”，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行5。</li><li>若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行6。</li><li>报告转发分组出错。</li></ol><div align="center"><img src="http://blogfileqiniu.isjinhao.site/0f1eb042-f036-497c-9343-78e15368c0d4"></div><p>R1的路由表：<br>| 目的网络地址 | 子网掩码 | 下一跳 |<br>| :———–: | :————-: | :—-: |<br>| 128.30.33.0 | 255.255.255.128 | 接口0 |<br>| 128.30.33.128 | 255.255.255.128 | 接口1 |<br>| 128.30.36.0 | 255.255.255.0 | R2 |<br>R2的路由表：<br>| 目的网络地址 | 子网掩码 | 下一跳 |<br>| :———–: | :————-: | :—-: |<br>| 128.30.33.0 | 255.255.255.128 | R1 |<br>| 128.30.33.128 | 255.255.255.128 | 接口0 |<br>| 128.30.36.0 | 255.255.255.0 | 接口1 |<br>在上图中，若H1（128.30.33.13）想给H3（128.30.36.12）发送数据，我们来分析一下具体的过程：</p><ol><li>主机 H1 首先将本子网的子网掩码 255.255.255.128与分组的 IP 地址 128.30.36.12 逐位相“与”（AND 操作）。即255.255.255.128 AND 128.30.36.12 得到 128.30.36.0，发现不等于128.30.33.0，所以他要将数据报发送到它的默认网关（128.30.33.1）上。</li><li>R1收到这个地址后，会遍历所有的子网掩码，进行按位与后再和对应的网络地址做比对。可以得到转发给R2计算过程如下：<ol><li>255.255.255.128 AND 128.30.36.12 = 128.30.36.0 不等于 128.30.33.0</li><li>255.255.255.128 AND 128.30.36.12 = 128.30.36.0 不等于 128.30.33.128、</li><li>255.255.255.0 AND 128.30.36.12 等于 128.30.36.0</li></ol></li><li>R1收到这个地址后，会遍历所有的子网掩码，进行按位与后再和对应的网络地址做比对。可以得到转发给接口1。</li><li>然后便是链路层需要解决的问题。</li></ol><p><br></p><h3 id="ARP深入"><a href="#ARP深入" class="headerlink" title="ARP深入"></a>ARP深入</h3><p>只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。可以分为四种情况：</p><ul><li>发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li><li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li></ul><p><br></p><h2 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h2><div align="center"><img src="http://blogfileqiniu.isjinhao.site/cc935459-2325-48cf-bfbe-5c1bdfdd9182"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/31da1294-a3ee-48a0-b39d-b4a471b95a67"></div><ul><li>版本：占 4 位，指 IP 协议的版本目前的 IP 协议版本号为 4 （即 IPv4）。</li><li>首部长度：占 4 位，可表示的最大数值是 15 个单位（一个单位为 4 字节）因此 IP 的首部长度的最大值是 60 字节。</li><li>区分服务：占 8 位，用来获得更好的服务在旧标准中叫做服务类型，但实际上一直未被使用过。1998 年这个字段改名为区分服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段。</li><li>总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。</li><li>标识（identification）：占 16 位，它是一个计数器，用来产生数据报的标识。</li><li>标志（flag）：占 3 位，目前只有前两位有意义。标志字段的最低位是 MF（More Fragment）。MF = 1 表示后面“还有分片”。MF = 0 表示最后一个分片。标志字段中间的一位是 DF（Don’t Fragment）。只有当 DF=0 时才允许分片。</li><li>片偏移(13 位)指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/8117370c-6825-4dbe-b615-d0325a27c3c8"></div><ul><li>生存时间（8 位）记为 TTL（Time To Live）：数据报在网络中可通过的路由器数的最大值。</li><li>协议（8 位）：指出此数据报携带的数据使用何种协议，即运输层协议。</li><li>首部检验和（16 位）字段只检验数据报的首部不检验数据部分。</li><li>源地址和目的地址都各占 4 字节。</li></ul><p><br></p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>在现在的网络中，IP地址分为公网IP地址和私有IP地址。公网IP是在Internet使用的IP地址，而私有IP地址则是在局域网中使用的IP地址。私有IP地址是一段保留的IP地址。只使用在局域网中，无法在Internet上使用。</p><ul><li>A类私有地址：10.0.0.0～10.255.255.255</li><li>B类私有地址：172.16.0.0～172.31.255.255</li><li>C类私有地址：192.168.0.0～192.168.255.255<br>这些地址可以在任何组织或企业内部使用，和其他Internet地址的区别就是，仅能在内部使用，不能作为全球路由地址。这就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到Internet，就可以使用这些地址而不用向 IANA（The Internet Assigned Numbers Authority，互联网数字分配机构，是负责协调一些使Internet正常运作的机构） 提出申请，而在内部的路由管理和报文传递方式与其他网络没有差异。<br>对于有Internet访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署NAT网关，在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有IP地址了。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/f617babc-a4f1-49ad-9681-1427664ee7f7"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;blockquote&gt;&lt;p&gt;网络层分为两分布，网络构建和网络通信&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;自治系统&quot;&gt;
      
    
    </summary>
    
      <category term="网络" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://isjinhao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>04.04-网络-运输层</title>
    <link href="https://isjinhao.github.io/posts/22725.html/"/>
    <id>https://isjinhao.github.io/posts/22725.html/</id>
    <published>2019-12-20T09:22:11.000Z</published>
    <updated>2019-12-20T09:29:23.846Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="传输服务"><a href="#传输服务" class="headerlink" title="传输服务"></a>传输服务</h2><p>网络层完成了“主机到主机”的通信，但主机间的通信并不是最后的结果，产生和消耗数据的并不是主机，而是某项网络应用，真正通信的是两个应用“进程”。“进程”就是“正在进行的程序”。而“进程到进程的通信”正是传输层的功能。但这不是全部，更重要的，传输层的任务是为从源主机到目的主机提供可靠的，低价格的数据传输。可靠性，低价格是两个关键词，或者为了更明显一些，可以有第三个关键词，拥塞控制。其实可靠性与拥塞控制本质上是一个词。可靠性、低价格、拥塞控制使传输层成为整个协议体系的核心与灵魂。如果没有传输层，就没有可靠的数据传输，网络层也将失去意义。<br>传输层的服务与网络层服务很相似，为何要分为两个层呢？答案就是“可靠性”。网络层并不提供可靠性，路由器可以丢失分组，用户无法控制中间的网络设备，用户不能选择性能更好的路由器或质量更好的数据链路，那么如何保证数据可以正常传输呢？添加一个传输层，传输层应该检测到各种问题，并采取补救措施，从而提供可靠的数据传输。传输层就是要弥补网络层技术、设计的各种缺陷。用个不恰当的比方，传输层就是“填坑的”，将网络层与应用层之间的坑、沟填平。传输层服务前，是遍布坑、沟的公路，传输层服务后，是平坦的公路。<br>再谈谈“低价格”这个关键词。如果在设计网络时，由网络层提供可靠性，会如何呢？如果由网络层提供可靠性，就要在中间网络的千万个路由器上添加可靠性的功能，系统的复杂性会提高数据传输的成本，那就与电话通信网的成本差别不大。可靠性由通信网提供还是由端计算机提供，二者的价格差别可太大了。可靠性由端计算机提供，才有了低成本的数据传输，低价格才是计算机网络将其他通信技术淘汰的本质。要低价格，可靠性就要放置在端计算机内部。显然放置在操作系统内部更加合理，直接由操作系统对应用程序提供可靠的数据传输服务，是非常自然的选择。传输层封装在端计算机的操作系统内，用个不恰当的比方，如同封装在房间内的电线，在装修时已经埋好了，只是提供了许多插座，这个插座接洗衣机，那个插座接冰箱，那个插座接电视，等等。<br>对计算机网络来说，“可靠性”的关键是什么？或者反过来，造成数据传输不可靠的最主要的原因是什么？是网络拥塞，当网络拥塞时，路由器就会丢弃数据包。传输层需要具有“调控网络”的功能。我们说，传输层在端主机内，而端主机是无法控制中间的网络设备的，“调控网络”从何谈起呢？后面会说到网络拥塞如同现实生活的堵车，根本的解决办法是不让车上路，所有的车都不上路，路就不堵了。“调控网络”是说所有端计算机内的传输层要能感知到网络的状态，能感知到当前通信网的态势，网络拥塞，就少发数据，网络通畅，就多发数据。尤其是网络拥塞时，要少发数据，让中间网络尽快恢复传输能力。</p><p><br></p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>最常用的进程到进程的通信方式是客户机与服务器模式。我们这里说的客户机与服务器都是指一个应用进程，而不是机器。客户机，请求服务，主动发起呼叫的进程。服务器，提供服务，被动等待的进程。总是客户机呼叫服务器，绝不可能是服务器呼叫客户机。在生活中，总是你给消防队打电话，绝不可能是消防队给你打电话。某一项服务，就是一项网络应用。端主机完全可以同时有多项网络应用，如同时打开浏览器浏览网页，打开 QQ 聊天。标识不同的网络应用进程的标识符称为协议端口号 (protocol port number)，简称为端口 (port)。端口是一个 16 位的标识符。客户机用一个临时端口号定义自己。客户机可以随机选择一个端口号使用。服务器也需要用一个端口号来定义自己，但是服务器不能随机选用一个端口号。为什么呢？假设消防队随机使用一个电话号码，当发生火灾时，人们向哪打电话呢？服务器必须使用一个预先定义的，众所周知的端口号，就如同消防队使用119，急救中心使用 120 一样。</p><p><br></p><h3 id="端口范围划分"><a href="#端口范围划分" class="headerlink" title="端口范围划分"></a>端口范围划分</h3><ul><li>熟知端口，端口号范围是 0~1023。由 ICANN 分配和控制。</li><li>注册端口，端口号范围是 1024~49151，ICANN 不分配也不控制，但必须在 ICANN 登记以防止重复。通常为没有熟知端口号的应用程序使用的。</li><li>动态端口，端口号范围是 49152~65535，这范围的端口号即不用指派，也不需注册，可以由任何进程使用。最初的建议是客户机使用的临时端口号应该在这个范围，但许多程序员可没有遵守这个建议。<br>注意：端口号只具有本地意义，只是为了标志本计算机应用层中的各进程。<div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/d19ce3a4-2d66-410b-9d29-cfc7638fc33b"></div></li></ul><p><br></p><h3 id="复用与分用"><a href="#复用与分用" class="headerlink" title="复用与分用"></a>复用与分用</h3><p>某台主机中可能有多个应用进程同时分别和网络上的许多其他主机中的某个或多个应用进程通信。这表明运输层有一个很重要的功能：复用（multiplexing）和分用（demultiplexing）。<br>当一个实体接受来自多个源的输入时，就称为复用（multiplexing） （多到一）。<br>而当一个实体将数据交到多个源时，就称为分用（demultiplexing）（一到多）。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/9ddb4411-0ed2-4975-b6de-83abc3c6fc51"></div><p><br></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>用户数据报协议 UDP（User Datagram Protocol）是无连接不可靠的传输层协议。它只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和校验和的功能。校验和功能是可选的，如果不选择校验功能，就全填入 0。UDP 缺点是不可靠，优点是开销小。发送数据之前不需要建立连接。这对某些实时应用是很重要的。网络出现拥塞时，不调整，不降低发送速率。UDP 用户数据报首部如下图：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/60f8cda8-e859-4f21-ba03-232c9603df05"></div><p>源端口和目的端口号，各占 16 位，标志应用进程，总长度为 UDP 的总长度，UDP 首部加 UDP 数据的长度，校验和计算下面介绍。</p><p><br></p><h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><p>UDP 的校验和功能是可选的，如果不选择校验和功能，就全填入 0，否则，计算校验和。计算时包含三个部分，伪首部，首部，数据部分，注意计算校验和是包含了数据部分的。如下图：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/21ce0657-8c31-4c2e-a1f6-d5667dee5395" width="80%"></div><h4 id="计算-UDP-检验和的例子"><a href="#计算-UDP-检验和的例子" class="headerlink" title="计算 UDP 检验和的例子"></a>计算 UDP 检验和的例子</h4><p>二进制反码计算规则：0 + 0 = 10；0 + 1 = 1； 1 + 1 = 0</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/86e18cb5-a16b-48c9-858d-39dad429d10b" width="80%"></div><p><br></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP格式"><a href="#TCP格式" class="headerlink" title="TCP格式"></a>TCP格式</h3><p>一个 TCP 报文段分为首部和数据两部分，首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。而 TCP 的全部功能都体现在它首部中各字段的作用：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/dfeef354-34b9-46ef-95e8-dc9416e0de6c"></div><ul><li>源端口和目的端口字段：各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。</li><li>序号字段：占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</li><li>确认号字段：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li><li>窗口字段：占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</li><li>数据偏移（即首部长度）：占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。</li><li>保留：占 6 位，保留为今后使用。</li><li>控制：占 6 位，定义了 6 种不同的控制位或标志。在同一时间可设置位或多位标志位。分别是 URG、ACK、PSH、RST、SYN、FIN。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/18eddd52-8822-47d6-aca7-47babefa45ae"></div><ul><li>检验和：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li><li>紧急指针字段：占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。</li><li>选项字段：长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3>TCP 是可靠的传输层协议。就是说 TCP 向应用层交付的是按顺序的，没有差错的，没有丢失的数据。TCP 通过 2 种机制进行差错控制：<code>检验和</code>、<code>确认和超时</code>。</li></ul><p><strong>检验和</strong></p><p>TCP 规定每个报文段都必须使用 16 位的检验和。TCP 检验计算时包含三个部分，伪首部，首部，数据部分，注意计算校验和是包含了数据部分的。计算方 法同 UDP 一样。</p><p><strong>确认和超时</strong></p><p>TCP 采用确认的方式来证实收到报文。接收方可以在合适的时候单独发送确 认报文，也可以在自己有数据要发送时把确认信息捎带上。TCP 使用肯定的累积确认。先解释“肯定”，ACK 就是“肯定”的意思。就是只在正确的情况下才发送确认。当发生丢弃，丢失，重复这些错误时，就什么也不做。“报喜不报忧”，注意，当发生错误时，不发送确认。这样，对方收不到确认，重传定时器就会超时，触发重传。 再解释“累积”，就是表示的累积效果，确认号字段值表示的是希望接收的下一个字节的序号。例如确认号为 301，是表示 301 号字节之前的数据都正确接收了，希望接收的下一个字节是 301 号字节。</p><p><strong>重传定时器</strong></p><p>差错控制的核心就是重传机制。TCP 使用确认-超时重传机制。具体说，TCP 每发送一个报文段，就设置一个重传定时器，当重传时间到，但还没有收到确认，就要重传这一报文段。重传定时器的值怎么设是 TCP 最复杂的事情之一。后面我们会解释原因，现在我们只要知道，重传定时器的值的估算要尽可能的准确，定时器的值不像加班费，越大越好，也不是越小越好，是越准确越好。<br>首先，很自然的想法，重传定时器的值应该是“一个往返时延再多一点”。“一个往返时延”如何确定？举例，8 点测了一次往返时延，8:05 又测一次，间隔 5 分钟，测了 10 次，往返时延应该用哪次测量的值呢？显然，用哪一次的<br>也不合适，应该是某种“平均值”。下面介绍的这个算法的目标是使估计值更加“平滑”，我们将往返时延估计值记作 RTTs。这个算法中，历史的累积效应权重更大一些，占比 7/8，新测量值的权重小，占比1/8。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/3ff3ce9c-8b0a-4de9-8841-527c8c48fc77"></div><p>下图是 RTT 样本与 RTT 估计值示意图，蓝色的是各次的测量值，红色的是RTT 的估计值。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/b04a113a-7bb5-41a9-9720-b2a0bb804e63"></div><p>说完“一个往返时延”，再说“多一点”。这一点Δ怎么算呢？取样本值到平滑线的距离为Δ，|RTTs-新样本|，显然，每个样本点到平滑线都有一个Δ，就是Δ1，Δ2，Δ3，Δ4，···，取哪个Δ合适呢？显然，用哪一个Δ也不合适，还应<br>该是某种“平均值”。算法也是给出一种“平滑平均值”，记作 RTTD。这个算法中，历史的累积效应权重更大一些，占比 3/4，新测量值的权重小，占比 1/4。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6c9b3665-ac82-4cc0-ada1-2f9479621db1"></div><p>总的RTO计算公式：$RTO=RTTs + 4 \ast RTTD$</p><p><br></p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 是全双工通信，TCP 为每个方向的数据传输使用两个窗口，发送窗口和接收窗口。双向通信就有四个窗口，为简化讨论，只讨论单向数据传输。</p><p><strong>发送窗口</strong></p><p>下图是一发送窗口例子，TCP 中的窗口以字节为单位。TCP 的传输实际是一个一个的报文段，但控制窗口的变量是以字节为单位。TCP 中只使用一个重传计时器。为方便说明，字节编号取得很小。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6bf72bbc-5975-478d-9240-ecd57e4b9d97"></div><p>发送窗口的后沿（left wall）只能向前移动（关闭 closes），前沿可向前移动（opens），也可收缩（shrinks），但 TCP 标准不赞成收缩。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/52271787-924e-4fbe-9341-63b39fd0f013"></div><p><strong>接收窗口</strong></p><p>下图是一接收窗口例子。实际上，接收窗口永远不会收缩。通常，接收方 TCP 等待应用进程来取数据。就是说，分配给接收方的缓存可能包含已接收且确认的数据字节，它们在正等待应用进程将它们拉走。接收窗口总是小于缓冲区的大小。接收窗口通常称为 rwnd，rwnd = 缓冲区大小 – 正在等待被拉走的字节数，如下图：rwnd = 40 。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/49a96632-fe3f-41c4-a55a-9974d2796802"></div><p><strong>窗口如何滑动</strong></p><p>TCP 通过滑动窗口机制实现流量控制。我们先忽略差错、拥塞等其他因素，且只简化讨论一个方向的数据传输。下图描述了一个例子，总是客户端发送数据，服务器确认。客户端是发送方，发送窗口，使用序号字段，服务器是接收方，接收窗口，使用确认号和窗口两个字段，窗口字段值是 rwnd 的值。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/035533ae-e496-40d2-9474-8823e132cfe1" width="80%"></div><p>假设发送方的缓冲区与接收方的缓冲区大小都是 800 字节。</p><ol><li>第 1 个报文段，客户端发给服务器，SYN 报文段，seq=100。三次握手建立连接的第一个报文，请求连接，并通告初始序号是 seq=100。</li><li>第 2 个报文段，服务器发给客户端，SYN+ACK 报文段，ack=101，rwnd=800。三次握手建立连接的第二个报文，窗口值通告 rwnd=800。</li><li>第3个报文段，客户端发给服务器，ACK报文段。客户端通告rwnd=2000，表示客户端的接收缓冲区的大小，我们忽略这个值，只讨论单向传输。</li><li>第 4 个报文段，客户端发给服务器，数据报文段，seq=101。客户端发送一数据报文段，携带 200 字节数据，数据字节编号 101~300，序号字段填写第 1个数据字节的编号 seq=101。发送窗口前沿在 901，后沿在 101，显示已发送 200字节数据，正等待确认。</li><li>第 5 个报文段，服务器发给客户端，ACK 报文段，ack=301，rwnd=600。服务器收到 101~300 号字节，共 200 字节数据，接收窗口调整，后沿向前滑动 200 字节，表示已收好 200 字节。向客户端发送 ACK 确认，确认字段值 ack=301，表示 301 号之前数据收好，下一个希望接收的字节是 301 号字节。注意，此刻 200 字节数据仍在接收缓冲区内，服务器的应用进程还没将它们拉走，接收窗口的大小 rwnd= 800 – 200 = 600。报文段中通告的窗口值为 600。</li><li>第 6 个报文段，客户端发给服务器，数据报文段，seq=301。客户端收到确认 ack=301，rwnd=600。客户端知道服务器已经收好 101~300 号字节，就可以删除这些数据，发送窗口调整，后沿向前滑动 200 字节，至01 处。但前沿不能向前滑动，因为现在接收方通告的 rwnd=600，前沿=301+600=901。客户端发送数据报文段，携带 300 字节数据，数据字节编号 301~600，序号字段eq=301。</li><li>第 7 个报文段，服务器发给客户端，ACK 报文段，ack=601，rwnd=400。服务器收到第二次的 301~600 号字节数据，共 300 字节数据。接收窗口调整，后沿向前滑动 300 字节，至 601 处。因 TCP 使用累积确认，向客户端发送的确认为 ack=601，表示 601 号之前所有数据收好，下一个希望接收的字节是 601 号字节。注意，此刻 200+300=500 字节数据仍在接收缓冲区内。这时，服务器的应用进程拉走 100 字节数据，接收缓冲区的 101~200 号字节空间被释放，但 201~601的 400 字节数据滞留在接收缓冲区内。接收窗口的大小 wnd= 800 – 400 = 400。通告窗口值为 rwnd=400。客户端收到确认 ack=601，rwnd=400。客户端知道服务器已经收好 601 号之前的数据，就可以删除这些数据，发送窗口调整，后沿向前滑动至 601 处。因为现在接收方通告的 rwnd=400，前沿=601+400=1001。前沿向前滑动至 1001 处。</li><li>第 8 个报文段，服务器发给客户端，ACK 报文段，ack=601，rwnd=600。服务器的应用进程又拉走 200 字节数据，接收缓冲区的 201~400 号字节空间被释放，但 401~601 的 200 字节数据仍滞留在接收缓冲区内。接收窗口的大小 rwnd= 800 – 200 = 600。通告窗口值为 400。对于确认来说，服务器现在收好的是 601 号字节之前的数据，确认为 ack=601，表示希望接收的下一个字节是 601 号字节。客户端收到确认 ack=601，wnd=600。客户端知道服务器已经收好 601 号之前的数据，发送窗口的后沿就在 601 处，不需滑动。因为现在接收方通告的rwnd=600，前沿=601+600=1201。前沿向前滑动至 1201 处。</li></ol><p><br></p><h3 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h3><p>假如 TCP 发送的报文段只含有 1 个字节的数据，那么意味着为发送 1 字节的数据，而发送了 41 个字节的报文段，20 个字节的 TCP 首部和 20 个字节的 IP首部。此时的效率是 1/41。这一现象称为糊涂窗口综合症（Silly Window Syndrome）。糊涂窗口综合症是怎样产生的呢?</p><p><strong>由发送方产生的糊涂窗口综合症（Syndrome Created by the Sender）</strong></p><p>如果发送方 TCP 正在为一个产生数据很缓慢的应用程序服务，例如一次产生 1 字节数据，就有可能产生糊涂窗口综合症。解决方法是使用 Nagle 算法。<br>Nagle 算法</p><ol><li>发送方 TCP 把它从应用进程收到的第一块数据发送出去，即使只有 1 字节。</li><li>在发送一个报文段后，发送方 TCP 就在输出缓存中累积数据并等待，直至收到接收方发来的确认，或者已积累了足够的数据已达到报文段的最大长度时，就立即发送一个报文段。</li><li>重复步骤 2。<br>Nagle 算法之巧妙，在于其巧妙地平衡了应用程序产生数据速度和网络传输速度。如果应用程序比网络速度快，报文段就大（最大报文段长度），如果应用程序比网络速度慢，报文段就小。</li></ol><p><strong>由接收方产生的糊涂窗口综合症（Syndrome Created by the Receiver）</strong></p><p>如果接收方 TCP 正在为一个消耗数据很缓慢的应用程序服务，例如一次消耗 1 字节数据，接收方每次发送 rwnd=1 的通告，就有可能产生糊涂窗口综合症。解决方法的是推迟确认。<br>报文到达时，不立即发送确认，接收方等待一段时间，直到输入缓存有足够的空间（或者接收缓存已有一个最长报文段的空间，或者接收缓存已有一半空闲的空间），就发送确认报文。但推迟确认不能超过 500ms。</p><p><br></p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制是 TCP 协议中最重要的一部分。理解 TCP 的拥塞控制，关键在于真正理解网络拥塞这一现象，理解了拥塞，以后的内容都会顺理成章的很好理解。</p><p><strong>拥塞概述</strong></p><p>两个主机，通过中间的一个传输网，连接在一起。正是因为中间有网络，就有了网络拥塞问题。谈网络拥塞之前，先回忆一下路由器的原理。网络层的路由器是一种“尽力而为”的机制。当超过路由器的能力时，路由器就将会丢弃数据报。假设路由器每秒能转发 1000 个数据报，此刻来了 1200 个数据报，路由器就将后 200 个数据报丢弃。注意：当没有超过路由器的负载能力时，路由器是不会丢弃数据报的。换一句话说，就是某个路由节点拥塞了，才会丢弃数据报。<br>怎么解决拥堵呢？很明显有两种方案，用公路网来打比方就是增加路的数量和减少驶入公路网的车。从协议的角度考虑，自然是做不到增加路的数量，所以我们就要控制发送到网络中的数据量。</p><p><strong>传输网络</strong></p><p>当网络拥塞时，如同城市交通堵塞，南城的人去不了北城，北城的人一样也去不了南城，路都堵死了，谁也走不了。也就是说，拥塞时，网络外围的所有主机，发送的数据包都会被丢掉，所以一定不会有返回的 ACK 确认，超时定时器一定会闹响。也就是说，网络拥塞时，所有主机都会超时。这样问题就解决了，简单归纳为一句话，超时就表示网络拥塞。</p><blockquote><p>超时就表示网络全拥塞。<br>因为 TCP 协议中以超时做为网络拥塞的判断依据，重传定时器的值需要估算合适，这很重要。值估算小了，实际网络不拥塞，确产生了超时重传，误判为拥塞，就不能充分使用网络的传输能力。值估算大了，实际网络已经拥塞，确没有产生超时重传，误判为通畅，就会使拥塞更加恶化，最终通信崩溃。在日常的生活中，城市的交通堵塞一定是渐渐堵死的，绝无可能在前一分钟，全城都是通畅的，后一分钟，全城所有的道路都堵死。总是开始时某些路段堵死，然后慢慢扩大，最后全部堵死。如果在某些路段堵死的时候，就开始疏导，有可能不会演变为全堵死。同理在计算机网络中，也很难相信，在前一分钟，所有的路由器都负载很轻，后一分钟，所有的路由器都超负载。应该是，某些路由器超负载了，其他路由器正常，这时后续的数据包就会自动绕路。假设某主机，连续发送了 2，3，4，5号数据包，2 号数据包碰到超负荷的路由器，被路由器丢弃，3，4，5 号数据包绕路到达目的主机，目的主机发送了 3 个 ACK 确认，请求 2 号数据包。当发送方收到 3 个重复 ACK 时，就会判断，网络是部分拥塞的，前面的数据包堵死在路上，后面的数据包绕路走了，已经到达目的地。简单归纳为一句话，3 个重复ACK 就表示网络部分拥塞，我称为半拥塞。<br>3 个重复 ACK 就表示网络半拥塞。<br>至此，外围的主机有了推测中间传输网络状态的办法，这两个事件就标志着网络的两种状态。用两个事件标志两种网络状态的方法，需要认真领会。TCP 的拥塞控制不能算闭环，没有一个具体的设备发出一个网络拥塞的信号，因为拥塞是全网的状态，不是某一个路由器的状态。一个路由器超载，可以绕其他路由器。TCP 的拥塞控制也不能算开环，“超时”与“3ACK”这两个事件确实反馈了中间传输网络的状态，为决策提供了依据。了解了网络现在的状态，就好办了。全拥塞有全拥塞的处理办法，半拥塞有半拥塞的处理办法。</p></blockquote><p><strong>拥塞窗口</strong></p><p>在上文中，讨论过 TCP 的流量控制，发送方窗口大小是由接收方的可用缓存空间（rwnd）决定的，就是由接收方指示发送方应当使用多大的窗口，这当然可以保证接收方不会溢出。但是，这个方法没考虑网络的存在，上文说过，要调控网络拥塞，就要根据当前网络的状态，调整发送到网络中的数据量。也就是说，TCP 需要一个控制变量，即TCP 发送方使用拥塞窗口 cwnd （Congestion Window）作为控制变量，根据当前网络的拥塞程度，拥塞窗口的大小动态地变化，调整发送的数据量。这样一来发送窗口大小不仅取决于接收方通告的接收窗口 rwnd，还取决于网络的拥塞状况 cwnd，进而 实际的发送窗口 = min（ rwnd , cwnd ）</p><p><strong>拥塞检测</strong></p><p>TCP 的发送方使用两个事件作为判断网络全拥塞和半拥塞的依据。超时表示网络全拥塞。3 次重复 ACK 表示网络半拥塞。</p><blockquote><p>超时<br>上文已经解释过拥塞的现象，我们现在简单理解为：发送方的超时事件就表示中间网络全部堵死了。<br>发送方 TCP 在整个连接期间，只维护一个 RTO 计时器。发送方发送段 1 和 段 2，计时器启动，接收方发回 ACK，发送方收到 ACK 后，计时器清零。在启动计时器，发送段 3，段 4，段 3 丢失，段 4 到达，接收方将段 4 存储下来，因为段 3 丢失，接收方留出一个间隙，表明数据是不连续的，接收方只能再发送对段 2 的确认 ACK。发送方收到确认，但因为不是对段 3，段 4 的确认，计时器不能清零，计时器超时，就会重传段 3，并重启计时器，这次段 3 正常到达，接收方发送 ACK，发送方收到，将计时器清零。</p></blockquote><div align="center"><img src="http://blogfileqiniu.isjinhao.site/84f15937-f917-4fa2-9f6b-9bd4790bcddd"></div><blockquote><p>三次重复 ACK（3dupACKs）<br>三次重复 ACK，也称做“快重传”（Fast retransmission）。如下图：发送方发送 2 个段后，正常收到 ACK，这个 ACK 是原始的 ACK，超时计时器清零。发送方再发送 4 个段，并再次启动超时计时器，段 3 丢失，段 4，5，6 到达。当接收方收到失序的数据段时，立即发送 ACK。接收方会发出 3 个重复的 ACK。发送方收到三个重复的 ACK，就立即重传丢失的报文段，而不等待计时器超时，并重启计时器。这一规则称为“快重传”，目前的 TCP 都遵守这规则。</p></blockquote><div align="center"><img src="http://blogfileqiniu.isjinhao.site/798ac667-fc74-4728-8ea6-e41631d22166"></div><p>三次重复 ACK，显然是某个报文段丢失了，后面的报文段正常到达。这就表示网络有堵死的地方，造成丢失，其他部分通畅，后面的报文段绕行了通畅的路径。我们现在简单理解为：发送方收到三次重复 ACK，就表示中间网络半堵死。</p><h4 id="拥塞控制策略"><a href="#拥塞控制策略" class="headerlink" title="拥塞控制策略"></a>拥塞控制策略</h4><p>TCP 拥塞策略基于两个阶段，慢启动（slow-start，SS）阶段和拥塞避免（congestion avoidance，CA）阶段。在慢启动阶段，发送方从非常慢的速率开始，很快达到一个门限值。当到达门限值，进入拥塞避免阶段。</p><p><strong>慢启动（SS, Slow start）</strong></p><p>指数增大，拥塞窗口 cwnd 从 1 个最大报文段 MSS 开始。每收到一个 ACK 确认，拥塞窗口增加一个 MSS。慢启动算法开始很慢，但它是以指数增大的。<br>按 ACK 计算， cwnd = cwnd + 1。<br>如图，从 cwnd=1 开始，第 1 个 ACK 到达后，cwnd 加 1，就是 2。这时，就可发送 2 个段，相应的回来 2 个 ACK，对于每个 ACK，cwnd 加 1，就是 4 了。是按指数增大的。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/b458f253-508e-4a58-abf6-9035cb56c1ea"></div><p>慢启动不能无限制的指数增大，有一个门限值来终止慢启动。发送方有一个慢开始门限 ssthresh（slow-start threshold）的变量，当拥塞窗口大小达到阈值时，慢启动停止，开始拥塞避免阶段。</p><p><strong>拥塞避免（CA，Congestion avoidance）</strong></p><p>加法增大，在慢启动阶段，当拥塞窗口达到慢开始门限 ssthresh 的值时，慢启动停止，进入拥塞避免阶段。此时，拥塞窗口按加法增大。每次整个“窗口”的所有段都被确认后，拥塞窗口增加 1。<br>举例，发送方以 cwnd=4 开始，此刻发送方只能发 4 个段，在 4 个 ACK 到达后，拥塞窗口才加 1。如果按往返时延 RTT 观察，拥塞窗口是每一轮次加 1。<br>按 ACK 计算， cwnd = cwnd + ( 1 / cwnd )<br>按 RTT 计算， cwnd = cwnd + 1</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/1ea0b9ed-9022-4808-82a5-bd5ce4ae9ca9"></div><p><strong>拥塞控制策略的转换</strong></p><p>在拥塞避免阶段，拥塞窗口加法增大。拥塞避免阶段会一直持续下去吗？继续下去，会是什么情况？显然，拥塞避免阶段继续下去，网络只会有处于通畅，半拥塞，全拥塞三种状态中的一种。就如同城市交通一样，只会是不堵车，部分堵死，全部堵死这三种情况之一。</p><blockquote><p>通畅<br>标志是无事件发生。拥塞避免阶段继续，拥塞窗口继续按加法增大。<br>半拥塞</p><ul><li>标志事件是：发送方收到三次重复 ACK（3dupACKs）。</li><li>处理办法是：<ul><li>ssthresh 门限值设为此刻 cwnd 的一半 ssthresh = cwnd / 2</li><li>将拥塞窗口设为门限值。 cwnd = ssthresh</li><li>进入拥塞避免阶段。<br>全拥塞</li></ul></li><li>标志事件是：发送方超时。</li><li>处理办法是：<ul><li>ssthresh 门限值设为此刻 cwnd 的一半 ssthresh = cwnd / 2</li><li>将拥塞窗口重新设置设为 1。 cwnd = 1</li><li>进入慢启动阶段</li></ul></li></ul></blockquote><div align="center"><img src="http://blogfileqiniu.isjinhao.site/ddef19c7-997b-49f1-a770-1376ac491b01"></div><p><strong>拥塞举例</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/1eb816dc-dcee-40b4-9cca-ac8f6a628e40"></div><p><br></p><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>TCP 是一种面向连接的协议。TCP 以全双工方式传送数据。在 TCP 中，面向连接的传输需要经过三个阶段：连接建立，数据传输，连接断开。TCP 连接采用客户服务器方式。主动发起连接建立的应用进程叫做客户（client），被动等待连接建立的应用进程叫做服务器（server）。</p><p><strong>TCP 连接管理的三规则</strong></p><ul><li>规则 1：TCP 规定，SYN 报文段不能携带数据，但要消耗掉一个序号</li><li>规则 2：TCP 的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号。</li><li>规则 3：TCP 规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。</li></ul><h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h4><p>TCP 建立连接的过程叫做三次握手（three-way handshaking）。服务器首先打开一个端口，端口处于监听态，称为被动打开。客户端发起连接请求，连接到服务器的打开的端口上，连接就建立了。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/525579dd-b72f-4bcc-953d-b747534cdb28"></div><ol><li>客户端发送第 1 个报文段，SYN 标志置 1，SYN 是请求同步的意思，SYN 报文段是控制报文，只在每个方向的第 1 个报文里出现。客户随机选择一个数字作为初始序号，假设为 x。<strong>TCP协议规定：SYN 报文段不能携带数据，但要消耗掉一个序号。</strong></li><li>服务器发送第 2 个报文段，SYN，ACK 置 1。SYN 标志表示服务器方的请求同步，并且服务器设置自己的初始序号，假设为 y。ACK 置 1 表示包含确认，这个确认是对客户端 SYN 报文的确认，所以确认号=x+1，表示序号 x+1 之前的报文都收好了，希望收到序号为 x+1 的报文段。</li><li>客户端发送第 3 个报文段，ACK 标志置 1。这个报文段仅仅是一个 ACK 段，通常不携带数据。这个段是客户端发出的，序号就是 x+1。ACK 置 1 表示包含确认，这是对服务器 SYN 报文的确认，确认号=y+1，表示服务器发送的序号 y+1 之前的报文都收好了，希望收到服务器发送的序号为 y+1 的报文段。要特别注意教材中的这句话，并需要真正理解。<strong>TCP 的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号。</strong><br>举例：客户端发送的第 1 个 SYN 报文段，序号为 8000，服务器发送的第 2 个 SYN+ACK 报文段，序号为 15000，此后，客户端发送了第 3 个报文段，未携带数据，第 4 个报文段，携带 100 字节数据，问客户端发送的第 3，4 个报文段的序号是什么？<br>解析：第 3 个报文段，序号为 8001，因为序号 8000 已经被 SYN 报用掉了。 第 4 个报文段，序号仍然是 8001，注意不是 8002，因为第 3 个报文段是一个 ACK 报文段，并且没携带数据，所以不消耗序号，就是说第 3 个报文的序号 8001 没有被用掉，在第 4 个报文中继续使用。</li></ol><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>连接建立后，可进行双向的数据传输。客户端和服务器都可以发送数据和确认。TCP 连接使用了序号和确认号的机制。</p><h5 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h5><p>TCP 把要发送的数据都按字节编上号。两个方向的编号是相互独立的。编号并不是从 0 开始，而是使用一个随机数作为初始编号，初始编号在建立连接的第一个 SYN 报文段里通告给对方。每个 TCP 报文段都有序号字段，序号字段值是这个报文段中第一个数据字节的编号。</p><blockquote><p>TCP 报文的序号字段值是这个报文段中第一个数据字节的编号。</p></blockquote><h5 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h5><p>TCP 使用确认机制。当报文段中 ACK 标志置 1，报文的确认号字段有效，TCP 的确认是累计确认，确认号字段值是完全接收好的数据的最后一个字节的编号+1，表示此值前的数据已收好，期望接收的下一字节是此值。举例，确认号是5644，表示从开始到 5643 号字节的数据都已收好，希望接收 5644 号字节。<br>TCP 是累积确认。确认号字段值是期望接收的下一个字节的编号。<br>举例：客户端发送一报文段，序号 8001，确认号 15001，携带 1000 字节数据。服务器发送的下一个报文段，序号，确认号是多少？服务器的回复携带 2000 字节数据，则客户端发送的再下一个报文，序号，确认号是多少？<br>解析：因第 1 个报文的确认号 15001，是期望接收的下一个报文段的序号，所以，服务器发送的下一个报文段的序号是 15001。因第 1 个报文的序号 8001，携带 1000 字节数据，服务器收到了 8001-9000 编号的 1000 字节数据，确认号是9001，表示 9001 号字节之前的数据已经收好，希望接收的下一个字节是 9001号字节。同理，第 3 个报文，序号为 9001，确认号是 17001。</p><h4 id="连接断开"><a href="#连接断开" class="headerlink" title="连接断开"></a>连接断开</h4><p>数据传输结束后，客户端和服务器任一方都可以发起断开连接。一般来说客户端发起断开连接。TCP 连接释放过程是四次握手。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/1538eed9-f35b-4b5b-bb0d-bf820cda3e89"></div><ol><li>正常情况下，客户端发起连接断开的请求。客户端发送第 1 个报文段，FIN 标志置 1，FIN 是请求结束的意思，表示客户端方向数据传输结束。假设这个段的序号是 u，在此图中，FIN 报文段值只是控制报文，没携带数据。<strong>TCP 规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。</strong></li><li>服务器发送第 2 个报文段，ACK 报文段，确认它收到了客户端的 FIN 报文段，假设其序号为 v，确认号= u+1。</li><li>服务器发送第 3 个报文段，FIN 报文段，两个标志 FIN，ACK 置 1，FIN 表示服务器方向数据传输结束，确认仍是对第 1 个报文段的确认，确认号= u+1。注意，其序号仍然是 v，原因是第 2 个报文段运用了下述的规则 2，其序号 v 没有消耗，继续使用。</li><li>客户端发送第 4 个报文段，ACK 报文段，ACK 标志置 1，确认是对服务器 FIN 报文段的确认，确认号= v+1。其序号是 u+1，原因第 1 个报文段运用了规则 3，序号 u 被消耗掉了，所以现在序号是 u+1。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;传输服务&quot;&gt;&lt;a href=&quot;#传输服务&quot; class=&quot;headerlink&quot; title=&quot;传输服务&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="网络" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://isjinhao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>04.05-网络-网络安全</title>
    <link href="https://isjinhao.github.io/posts/46574.html/"/>
    <id>https://isjinhao.github.io/posts/46574.html/</id>
    <published>2019-12-20T09:22:11.000Z</published>
    <updated>2019-12-20T09:29:23.853Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="网络安全威胁"><a href="#网络安全威胁" class="headerlink" title="网络安全威胁"></a>网络安全威胁</h2><h3 id="拟人模型"><a href="#拟人模型" class="headerlink" title="拟人模型"></a>拟人模型</h3><p>在网络通信中，数据肯定有发送方和接收方，在全双工通信的时候双方既为发送者也为接受者，这便是图上的Alice和Bob，而Trudy可以指破坏通信的软件，也可以指破坏通信的主机。如：</p><ul><li>病毒（virus）</li><li>蠕虫（worm）</li><li>间谍软件（spyware）：记录键盘输入、web站点访问、向收集站点上传信息等<div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/7641f209-e0a7-4f79-a196-abb236cce4f5"></div></li></ul><p><br></p><h3 id="Trudy可以做什么"><a href="#Trudy可以做什么" class="headerlink" title="Trudy可以做什么"></a>Trudy可以做什么</h3><p><strong>映射（Mapping）</strong></p><p>在任何网络攻击发起之前都会有一个映射，这是发起攻击前的“探路”（case the joint），即找出网络上在运行什么服务：</p><ul><li>利用ping命令确定网络上主机的地址</li><li>端口扫描（Port-scanning）：获得主机地址后依次尝试与每个端口建立TCP连接<br>对策（Countermeasures）</li><li>记录到达的网络流量</li><li>分析、识别出可疑活动（IP地址和端口被依次扫描）</li></ul><p><strong>分组“嗅探”（sniffing）</strong></p><ul><li>广播介质（共享式以太网，无线网络）</li><li>混杂（promiscuous）模式网络接口可以接收/记录所有经过的分组/帧</li><li>可以读到所有未加密数据（例如账户密码）</li><li>不一定所有的嗅探都是有害的，Wireshark就是一个典型免费的分组嗅探软件<br><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/f8af59de-5097-49fc-a1fd-a2010d4e562d"></div><br>对策</li><li>组织中的所有主机都运行软件，周期性监测网络接口是否工作在混杂模式</li><li>每段广播介质连接一台主机（如交换式以太网）</li></ul><p><strong>IP欺骗（Spoofing）：</strong></p><ul><li>直接由应用生成“原始”IP分组，可以设置分组的源IP地址字段为任意值</li><li>接收方无法判断源地址是否被欺骗</li><li>e.g.: C冒充B<br><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/258cf251-cf53-4dd1-ad40-2c93dea0edb3"></div><br>对策<br>入口过滤（ingress filtering），即路由器不转发源IP地址无效的IP分组（例如当源IP地址不属于所连接网络时）。这是很有效的对策！但是不能强制所有网络都执行入口过滤。</li></ul><p><strong>拒绝服务DOS（Denial of service）</strong></p><p>向接收方恶意泛洪（flood）分组，淹没（swamp）接收方</p><ul><li>带宽耗尽</li><li>资源耗尽<br>分布式拒绝服务攻击（DDOS）：多个源主机协同淹没接收方，例如C与另一个远程主机协同对A进行SYN攻击。<div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/3bd06301-ef88-40e2-b19f-de748801d7cc"></div><br>SYN 攻击<br>利用TCP连接的三次握手过程，Trudy向服务器发送第一次握手，服务器给建立TCP连接分配资源，发送第二次握手，但是Trudy在发送第一次握手之后不再做任何响应，服务器接收不到三次握手信号，一直发送第二次握手信息。大量的类似TCP连接产生后，服务器会陷于拒绝服务的状态。<br>对策：在接收到第一次握手信号后不立即分配资源，而是将源IP、目的IP、源端口、目的端口、随机数构成的五元组哈希成服务器的序列号<code>y</code>，并且发送二次握手信号。此时服务器不进行超时重传等机制。如果再接收到ACK为<code>y+1</code>第三次握手信号才去分配资源。所以在接收到第一次握手后服务器可以保留一份<code>y</code>到五元组的映射，这样的话在接收到ACK为<code>y+1</code>第三次握手信号之后就可以查一下<code>y</code>是否在哈希表中，如果在便可以为为客户端分配资源。<br><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/3f4e50e1-4b61-4a96-9324-cac5a009326a"></div></li></ul><p><br></p><h2 id="密码学名词"><a href="#密码学名词" class="headerlink" title="密码学名词"></a>密码学名词</h2><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/5bfae191-c089-46ce-9fc9-6292b77075ba"></div><br>在我们现今的密码学体系中，加密结果的影响因素有两个，加密算法和加密秘钥，而加密算法一般是公开的，因为创建一个加密算法是非常困难的事情。所以密文可以被表示为：$K_A(m)$，解密后的密文：$m=K_B(K_A(m))$。<br><br><br><br>### <strong>对称秘钥加密</strong><br><br>对称密码是我们最容易被理解的密码算法，其对应上图就是$K_B == K_A$，也就是说对于一次加密过程，我们进行一次逆过程就可以完成解密。<br><br><strong>DES</strong><br><br>Data Encryption Standard。IBM公司研制。DES的部分部分是保密的。<br>- 1972年，美国国家标准局开始实施计算机数据保护标准的开发计划。<br>- 1973年5月13日，NBS征集在传输和存贮数据中保护计算机数据的密码算法。<br>- 1975年3月17日，首次公布DES算法描述。<br>- 1977年1月15日，正式批准为加密标准，当年7月1日正式生效。<br>- 1994年1月的评估后决定1998年12月以后不再将DES作为数据加密标准。<br><br><strong>AES</strong><br><br>Advanced Encryption Standard，1997年美国国家标准技术研究所NIST宣布征集AES算法，要求：<br>- 可公开加密方法<br>- 分组加密，分组长度为128位<br>- 至少像3DES一样安全<br>- 更加高效、快<br>- 可提供128/192/256位密钥<br>- 比利时学者Joan Daemen和Vincent Rijmen提出的Rijndael加密算法最终被选为AES算法。<br>- NIST在2001年12月正式颁布了基于Rijndael算法AES标准<br><br><br><br>### <strong>公钥密码学</strong><br><br>公钥密码也是非对称密码。公钥加密算法一般由五个部分组成：<br>- 原文（Message）：需要加密的信息，可以是数字、文字、视频、音频等，用$M$表示。<br>- 密文（Ciphertext）：加密后得到的信息，用$C$表示。<br>- 公钥（Public Key）和私钥（Private Key），用$PU$和$PR$表示。<br>- 加密算法（Encryption）：若$E(x)$为加密算法，加密过程可以理解为$C=E(m)$，根据原文和加密算法得到密文。<br>- 解密算法（Decryption）：若$D(x)$为解密算法，解密过程可以理解为$M=D(c)$，根据密文和解密算法得到原文。<br>对于公钥密码学，我们不去探究他们的数学原理是什么，但是需要了解算法的特性和用途。我们先看算法的特性，在下面的其他部分再看算法的用处。<br>我们先不考虑公钥和私钥，将秘钥设为秘钥A和秘钥B，使用密钥A加密数据得到的密文，只有密钥B可以进行解密操作（即使密钥A也无法解密），对应的，使用了密钥B加密数据得到的密文，只有密钥A可以解密。此时我们把一个秘钥公开出去，一个秘钥自己掌握，便区分为公钥和私钥。而根据不同用途，对数据进行加密所使用的密钥也不相同，即有时用公钥加密，私钥解密；有时则相反，用私钥加密，公钥解密。<br><br><br><br>## 数字签名<br><br><br>### <strong>消息完整性</strong><br><br>报文/消息完整性（message integrity），也称为报文/消息认证（或报文鉴别），指在传输、存储信息或数据的过程中，确保信息或数据不被未授权的篡改或在篡改后能够被迅速发现。它有几个核心目标：<br>- 证明报文确实来自声称的发送方<br>- 验证报文在传输过程中没有被篡改<br>- 预防报文的时间、顺序被篡改<br>- 预防报文持有期被修改<br>- 预防抵赖<br>- 发送方否认<br>- 接收方否认<br><br><br><br>### <strong>密码散列函数</strong><br><br>密码散列函数（Cryptograph ic Hash Function）的特点：<br>- 散列算法公开<br>- H(m)能够快速计算<br>- 对任意长度报文进行映射，均产生定长输出<br>- 对于任意报文无法预知其散列值<br>- 不同报文不能产生相同的散列值<br>- 单向性：无法根据散列值倒推出报文，即对于给定散列值h，无法计算找到满足h = H(m)的报文m<br>- 抗弱碰撞性（Weak Collision Resistence-WCR），即对于给定报文x，计算上不可能找到y且y≠x，使得H(x)=H(y)。<br>- 抗强碰撞性（Strong Collision Resistence-SCR），在计算上，不可能找到任意两个不同报文x和y(x≠y)，使得<br>H(x)=H(y)。<br><br><strong>散列函数算法</strong><br><br>MD5：被广泛应用的散列函数（RFC 1321）。对任意长度的报文输入，计算输出128位的散列值。但是MD5不是足够安全，1996年，Dobbertin找到了两个不同的512-bit块，在MD5计算下产生了相同的散列值<br>SHA-1：Secure Hash Algorithm，SHA-1要求输入消息长度$&lt;2^{64}$，SHA-1的散列值为160位。其速度慢于MD5，安全性优于MD5。<br><br><strong>报文摘要</strong><br><br>Message digests，对报文m应用散列函数H，得到一个固定长度的散列码，称为报文摘要（message digest），记为H(m)。可以作为报文m的数字指纹（fingerprint）。<br><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/4b305c4c-d1de-41b5-9fee-d9d0ae3dfab6"></div><p><br></p><h3 id="报文认证"><a href="#报文认证" class="headerlink" title="报文认证"></a><strong>报文认证</strong></h3><p><strong>简单的报文认证</strong></p><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/a4e06403-1801-4b1b-ad71-7b4ae2a50203"></div><br>在不知道散列的情况下，简单的报文认证什么都不能保证，因为在简单的报文认证中修改了报文，只要顺便修改了报文摘要就无法检测报文的正确性。<br><br><strong>报文认证码MAC</strong><br><br>Message Authentication Code。在简单报文的基础上，加上认证密钥（对称秘钥）。<br><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/a0842382-efbc-42a8-a9a7-d3e230fee72c"></div><br>加上认证秘钥之后，只要能保证秘钥的安全性（后面会介绍如何保证对称秘钥的安全性）。但是此时仍然不能解决如下问题：<br>- 否认<br>- 发送方不承认自己发送过某一份报文<br>- 接收方不承认自己接收过某一份报文<br>- 伪造：接收方自己伪造一份报文，并声称来自发送方<br>- 篡改：接收方对收到的信息进行篡改<br><br><br><br>### 数字签名<br><br><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/426724a8-039d-4865-b37f-89ce24c7f18b"></div><br>使用数字签名后，假设Alice收到报文m以及签名，Alice利用Bob的公 解密 ，并检验来证实报文m是Bob签名的。如果成立，则签名m的一定是Bob的私钥，于是，Alice可以证实：<br>- Bob签名了m。<br>- 没有其他人签名m的可能。即这份报文只能是来自Bob。<br>- Bob签名的是m而不是其他报文m。因为只有Bob知道他自己的私钥。<br>同时，Alice没有Bob的私钥，不可能伪造，篡改Bob发来的报文。<br>数字签名相比于MAC又能解决更多的问题，但是数字签名不能解决“接收方不承认自己接收过某一份报文”的问题，想要解决这个问题必须采用其他的协议。<br><br><br><br>## 秘钥分发<br><br><br>### KDC<br><br>Key Distribution Center。对称秘钥的问题便是如何建立共享秘钥。即在Alice和Bob通信过程中，如何保证双方接收到的会话秘钥都是正确的且没有被Trudy接收到。而解决办法就是设立一个可信任的密钥分发中心作为中介。<br>密钥分发中心是一种运行在物理安全服务器上的服务，KDC维护着领域中所有安全主体账户信息数据库。与每一个安全主体的其他信息一起，KDC存储了仅安全主体和KDC知道的加密密钥，这个密钥也称长效密钥（主密钥），用于在安全主体和KDC之间进行交换。而用于Alice和Bob相互认证的会话密钥就是由KDC分发的。<br><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/42c86c06-43e6-4664-9d22-88dcdedd98c8"></div><br>KDC的工作方式如下：<br>1. Alice使用自己和KDC共享的那一份秘钥加密自己和Bob的信息。表示自己想和Bob通信。<br>2. KDC使用Bob和KDC共享的那份秘钥加密Alice的信息和给本地通信颁发的会话秘钥R1。设为E。<br>3. KDC将E用Alice的秘钥加密，发送给Alice。<br>4. Alice用自己的秘钥解密后，可以获得E。<br>5. Alice将E发送给Bob，Bob用其有KDC共享的秘钥解密E后就可以知道自己需要和Alice使用R1通信。<br><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/f78cb111-1f00-4397-b672-88e903ef0c8a"></div><br>使用KDC进行通信加密的时候有个破绽，就是Alice和Bob与KDC之间共享的那份秘钥<br><br><br><br>### CA<br><br>Certification Authority。公钥通信的问题就是如何保证接收方接到的是发送方的公钥。即如何避免中间人攻击。<br><br><strong>中间人攻击</strong><br><br><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/0cbec0df-c73f-4fe5-986c-9f5688d3469b"></div><br>1. Bob给Alice发送自己公钥，这个消息被Trudy接收到了。此时Trudy有了Bob的公钥。<br>2. Trudy将自己的公钥发送给了Alice，此时Alice有的是Trudy的公钥。<br>3. Bob给Alice发送消息，消息被Trudy截获，Trudy有Bob的公钥能解密Bob的报文。<br>4. Trudy给Alice发送假消息，Alice用第二步获得的Bob的公钥解密，以为是Bob给自己发送的消息。<br><br><strong>可信任的认证中心</strong><br><br>中间人攻击的解决方案就是寻找一个可信任的认证中心。实现特定实体E与其公钥的绑定<br>- 每个E（如人、路由器等）在CA上注册其公钥。需要Bob的个人信息和Bob的公钥。<br>- CA创建绑定E及其公钥的证书（certificate）<br>- 证书包含由CA签名的E的公钥 – CA声明：“这是E的公钥”<br><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/617bc167-697e-4975-a0a8-4b4c280bb8c4"></div><br>可信赖的认证中心可以解决很多问题，但是还有一个缺陷，就是Bob怎么获得CA的公钥？如果Bob通过网络获取CA的公钥，那么仍然会被中间人攻击，所以在现在的浏览器、操作系统中已经内置了一些认证中心的公钥。这样的话，Bob发送给CA的信息就不可能被劫持。Alice也能使用内置的公钥解密CA签发的公钥证书。<br><br><br><br>## HTTPS<br><br><br><strong>数字证书</strong><br><br><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/e95c0b5b-eb54-474e-95c4-e4051c7d961a"></div><p><strong>https基本原理</strong></p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/141df582-50fe-4a61-95d8-801fc99828f2"></div><p><strong>回放攻击的抵御</strong></p><p>我们上面的https能够抵御中间人攻击，但是却无法抵御回放攻击。什么是回放攻击呢？<br>假如Alice想向Bob转10块钱。Alice发送一个报文个给支付宝，Alice和支付宝之间的通信使用https进行加密，此时Trudy通过嗅探的方式获得了这个数据包，虽然Trudy无法知道这个报文的内容是什么，但是如果Trudy将这个报文多次发送给支付宝，Alice就相当于转了好多次钱给Bob。那么该如何解决呢？<br>一次性随机数<br>Alice在向服务器发送转账报文之前，先向服务器申请一个一次性随机数，服务器在生成这个随机数<code>R</code>后一边将其存储在服务器上（设为表<code>X</code>），一边再将其发送给Alice。然后在发送转账报文的时候将<code>R+1</code>附在报文上，服务器收到报文后解密报文再减一得到便可以得到<code>R</code>，然后再查表<code>X</code>，此时服务器就知道<code>R</code>没有被使用过，在处理完此次请求后，服务器将<code>R</code>从表<code>X</code>中删除。如果Trudy伪造了一份报文发送给服务器，服务器在表中查不到<code>R</code>，便不会处理此次请求。<br>过期时间<br>一次性随机数可以抵御回访攻击，但是还有点缺陷，就是如果Alice在获得<code>R</code>后不发送转账报文，表<code>X</code>中的<code>R</code>永远不会被删除，就会造成内存泄漏。此时可以将表中的每个随机数设置一个过期时间，便可以很好的解决这个问题。</p><p><br></p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。<br>SSH使用的加密方式也是公钥加密技术，所以其和https面临相同的问题，就是中间人攻击。但是和https寻找CA认证不同，SSH采用用户自行确认的方式进行认证。<br>所以在第一次登录到对方主机的时候，系统会出现类似下面的提示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host</span><br><span class="line">The authenticity of host &apos;host (12.18.429.21)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p></p><p>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。<br>如果用户经过核对（或者不核对）之后确定是对方主机，就可以和对方主机建立连接。然后便是输入用户名密码的环节了。</p><p><br></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>哈尔滨工业大学mooc</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513779&amp;idx=1&amp;sn=a1de58690ad4f95111e013254a026ca2&amp;chksm=80d67b70b7a1f26697fa1626b3e9830dbdf4857d7a9528d22662f2e43af149265c4fd1b60024&amp;mpshare=1&amp;scene=1&amp;srcid=1218TNdDIgHKi0iNGqcuUHIK&amp;sharer_sharetime=1576679757750&amp;sharer_shareid=4ee2705235be865f9b9d37ec8d0880da&amp;key=24f4c229624f48232229f8ff098300bbabbf27cc8205e886555c110b686feecc3ec87498d571e56403557416f09a3398afeb9fb53cbd747d5d6f67e079f7012ee64f504c893b7a5c616cc692fc42e431&amp;ascene=1&amp;uin=MTE0ODk0OTI2&amp;devicetype=Windows+10&amp;version=62070158&amp;lang=zh_CN&amp;exportkey=AS6xaCbzJExHlv9GvBG8bcc%3D&amp;pass_ticket=XKq1g7kn6ID3JUkISrEmy5kSZzr7rf2NdClQ0jY13cY%3D">码农翻身</a></li><li><a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;网络安全威胁&quot;&gt;&lt;a href=&quot;#网络安全威胁&quot; class=&quot;headerlink&quot; title=&quot;网络安全
      
    
    </summary>
    
      <category term="网络" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://isjinhao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>04.06-网络-面试题</title>
    <link href="https://isjinhao.github.io/posts/329.html/"/>
    <id>https://isjinhao.github.io/posts/329.html/</id>
    <published>2019-12-20T09:22:11.000Z</published>
    <updated>2019-12-20T09:29:23.856Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="TCP-对比-UDP"><a href="#TCP-对比-UDP" class="headerlink" title="TCP 对比 UDP"></a>TCP 对比 UDP</h2><p><strong>对比</strong></p><ul><li>TCP提供面向连接的、可靠的数据流传输，TCP传输单位称为TCP报文段。</li><li>UDP提供的是非面向连接的、不可靠的数据流传输。UDP传输单位称为用户数据报。</li></ul><p><strong>应用层协议</strong></p><blockquote><p>TCP对应的协议</p><ul><li>FTP：定义了文件传输协议，使用21端口。</li><li>SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。</li><li>POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。</li><li>HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。<br>UDP对应的协议</li><li>DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</li></ul></blockquote><p><br></p><h2 id="TCP的可靠传输"><a href="#TCP的可靠传输" class="headerlink" title="TCP的可靠传输"></a>TCP的可靠传输</h2><p><strong>差错控制</strong></p><p>TCP保证差错控制使用的方式是：校验和 &amp; 确认与重传</p><blockquote><p>校验和<br>校验和的目的是为了保证接收端接收到的数据不会因为网络的不稳定导致数据出错。<br>确认与重传<br>确认和重传机制是为了保证报文段在传输的时候没有发生丢失。</p></blockquote><p><strong>流量控制</strong></p><p>流量控制的目的是为了保证传输两端之间速率的匹配。即不能由于发送方发送的速度太快而导致接收在接收到数据后来不及处理而被迫丢弃进而引起发送方重传。<br>使用GBN协议或者选择重传协议来控制。即使用<code>发送-确认</code>的机制来协调点到点之间传输的速率。</p><blockquote><p>接收方窗口<br>在流量控制阶段接收方会分配一段内存空间做为接收缓冲区。通常情况，接收方的缓存中包含已接收且确认的数据字节，它们在正等待应用进程将它们拉走，称为未交付数据。接收缓冲区剩余的空间，即可用来接收新数据的空间，称为接收窗口（通常记为rwnd）。若应用进程迟迟不讲缓存区中的数据取走，随着不断接收新数据，接收窗口（可用的接收缓存）会越来越小，直到为零。而对于任何时刻：<code>rwnd(接收窗口)=缓冲区大小-未交付数据字节数</code>。</p></blockquote><p><strong>拥塞控制</strong></p><p>拥塞控制作用于网络，它防止过多的数据注入到网络中，避免出现网络负载过大的情况。</p><blockquote><p>阻塞的检测</p><ul><li>全阻塞：超时表示网络全阻塞。</li><li>半阻塞：三次重复ACK表示网络半阻塞。<br>拥塞控制策略</li></ul><ol><li>慢开始，指数增大</li><li>到达慢开始门限值（ssthresh）的时候进行加法增大（起始的慢开始门限值是人为设置的）</li><li>当发生全阻塞时<ol><li>ssthresh门限值设为此刻cwnd的一半，ssthresh=cwnd/2</li><li>将拥塞窗口重新设置设为1。cwnd =1</li><li>进入慢启动阶段。</li></ol></li><li>当发生半阻塞时<ol><li>ssthresh门限值设为此刻cwnd的一半，ssthresh=cwnd/2</li><li>将拥塞窗口设为门限值。 cwnd=ssthresh</li><li>进入拥塞避免阶段。</li></ol></li></ol></blockquote><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/74e6326a-2cfb-4c0e-bded-d9cba2da99d1"></div><p><br></p><h2 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h2><p><strong>三次握手</strong></p><ul><li>客户端向服务器发送建立连接请求，并且携带一个客户端起始序列号。</li><li>服务器向客户端确认已收到客户端的序列号，并且将服务器起始序列号发送给客户端。</li><li>客户端收到服务器的序列号之后，客户端向服务器确认已收到服务器序列号。<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/c5150931-5dea-4eba-9e6a-6ba4ec5ed059"></div></li><li>客户端状态：<ul><li>SYN_SENT：客户端发送请求给服务器后的状态</li><li>ESTABLISHED：客户端进入连接建立状态</li></ul></li><li>服务器状态：<ul><li>SYN_RECV：服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态</li><li>ESTABLISHED：服务器进入连接建立状态</li></ul></li></ul><p><strong>二次握手的缺陷</strong></p><blockquote><p>二次挥手不能防止已失效的连接请求又传送到服务器端。</p><ul><li>客户端发送第一个请求给服务器（第一次<code>第一次握手</code>），如果这个请求在网络上迷失，客户端在超时之后会再发一次请求给服务器（第二次<code>第一次握手</code>）</li><li>服务器收到第一次握手的这个连接之后会发送ACK给客户端（<code>第二次握手</code>）。</li><li>在二次握手的情况下，客户端不发送ACK，此时可以进行通信。</li><li>此时若我们第一次发送的<code>第一次握手</code>信号达到了服务器，那么服务器以为是新的连接，就会发确认报文到客户端确认并建立连接，但发送端可能已经关闭，接收端可能就这样等待，这在网络中就浪费了资源。</li><li>但是有了<code>第三次握手</code>不一样了，服务器在接收到了滞留在网络中的信息后，会发送确认信息给客户端，但是当客户端没有理会的时候，服务器在超时之后就会自动关闭这次连接。</li></ul></blockquote><p><strong>四次挥手</strong></p><p>连接断开时可以先由服务器发起，也可以先由客户端发起。下面假设是客户端发起的连接断开。</p><ul><li>客户端向服务器发送一个FIN报文段；此时，服务器进入FIN_WAIT_1状态。这表示客户端没有数据要发送给服务器了。</li><li>服务器收到了客户端发送的FIN报文段，向客户端回一个ACK报文段，服务器进入CLOSE_WAIT状态。表示服务器知道客户端没有数据要传送过来了，服务器自己进入<code>等待关闭</code>状态，表示发完手上的数据就进行关闭。</li><li>服务器发完手上的数据后向客户端发送FIN报文段来请求关闭连接。这表示客户端服务器已经没有数据要传给客户端了。</li><li>客户端收到服务器发送的FIN报文段，向服务器发送ACK报文段。服务器收到客户端的ACK报文段以后，就关闭连接。此时服务器关闭连接完成。如果客户端等待2MSL后依然没有收到回复，客户端的定时器关闭，表示客户端关闭连接完成。<div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/7b9939d2-b1fc-4cc9-aa44-c2e486888200"></div></li><li>客户端状态：<ul><li>FIN_WAIT_1：客户端发送FIN报文段后的状态</li><li>FIN_WAIT_2：客户端接收到服务器的ACK报文段之后的状态</li><li>TIME_WAIT：客户端接收到服务器发送的最后一个ACK之后，进入一个2MSL的等待期。</li></ul></li><li>服务器状态：<ul><li>CLOSE_WAIT：服务器接收到客户端请求关闭的报文之后进入关闭等待期</li><li>LAST_ACK：服务器发送完关闭连接报文段后（FIN）等待接收客户端的确认的状态。</li></ul></li></ul><p><strong>为什么四次挥手后需要等待一段时间</strong></p><ol><li><strong>为了保证客户端发送的最后一个ACK报文能够到达服务器。</strong>这个ACK的报文有可能丢失，这样处于LAST-ACK状态的服务器如果收不到客户端的ACK报文，会再次发送<code>第三次挥手</code>信号，而客户端在2MSL的时间内收到这个重传的信号。接着客户端重传一次确认，重新启动2MSL计时器。如果客户端不在TIME-WAIT状态下等待一段时间，而是在发送完ACK报文后立即释放连接，那么就无法收到重传的<code>第三次挥手</code>报文，因而也不会再一次的发送确认报文，那么服务器就会永远进行重传。</li><li><strong>避免新旧连接混淆。</strong>等待2MSL可以让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接请求不会出现旧的连接请求报文。我们假设TCP连接是<code>A(1.2.3.4:8888)-B(6.7.8.9:9999)</code>，这就是一个TCP四元组。当TCP连接关闭后，四元组释放。后面的新连接可能会重用到这个四元组，那么问题就来了：新四元组和旧四元组完全一致，他们的网络包会产生混乱。所以等待一段时间可以让旧四元组对应的所有网络包都消失，避免新旧连接混淆。</li></ol><p><br></p><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/db782db0-9889-4ba0-a9a3-92684553f7b5"></div><p><strong>各层的功能</strong></p><blockquote><p>应用层（application layer）<br>是体系结构中的最高。直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。<br>协议：HTTP协议、SMTP协议、FTP协议、DNS、POP3、SNMP、Telnet<br>运输层（transport layer）<br>负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能</p><ul><li>复用，就是多个应用层进程可同时使用下面运输层的服务。</li><li>分用，就是把收到的信息分别交付给上面应用层中相应的进程。<br>协议：UDP协议、TCP协议<br>网络层(network layer）<br>网络层(network layer)主要包括以下两个任务：</li><li>负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。</li><li>选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。<br>协议：IP、ICMP、IGMP、ARP、RARP<br>数据链路层（data link layer）<br>将网络层交下来的IP数据报组装成帧（framing），在两个相邻结点之间的链路上“透明”地传送帧中的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。<br>协议：GBN协议、选择重传协议<br>物理层（physical layer）<br>物理层的任务就是透明地传送比特流。</li></ul></blockquote><p><br></p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;TCP-对比-UDP&quot;&gt;&lt;a href=&quot;#TCP-对比-UDP&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="网络" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://isjinhao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>06.01-操作系统引论</title>
    <link href="https://isjinhao.github.io/posts/2543.html/"/>
    <id>https://isjinhao.github.io/posts/2543.html/</id>
    <published>2019-12-20T09:19:38.000Z</published>
    <updated>2019-12-20T09:29:23.860Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h2><p>操作系统（Operating System，简称OS）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是管理硬件设备来提高利用率和吞吐量，同时为用户和应用系统提供易于使用的接口。</p><ul><li>提高利用率：使系统中各设备的空闲时间尽可能短。</li><li>提高吞吐量：使单位时间内完成的业务更多。</li><li>提供易于使用的接口：即是方便使用计算机资源。例如没有操作系统，操纵计算机可能需要用户输入二进制代码，有了操作系统，用户可以点击图标，操作系统就会将其转换成二进制代码。</li></ul><p><br></p><h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><ul><li>方便性：即对用户和应用程序提供易于使用的接口。</li><li>有效性：提高利用率和吞吐量。</li><li>可扩充性：计算机硬件和体系结构等都在不断发展中，OS需要有好的可扩充性来满足不断发展的需求。</li><li>开放性：为了使计算机的应用环境从单机转换成网络，OS需要满足相应的软硬件标准来实现设备的互联。</li></ul><p><br></p><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ul><li>提供易于使用的接口，如Shell、图形界面等。</li><li>管理计算机所有的资源，负责计算机系统全部资源的分配、控制、调度和回收。</li><li>隐蔽硬件特性，如计算2*3，某些机器的实现是使用加法器做2+2+2，而有的机器是乘法器实现2*3。操作系统屏蔽这些细节，用户只需要输入2*3就能完成。</li></ul><p><br></p><h2 id="未配置操作系统的计算机系统"><a href="#未配置操作系统的计算机系统" class="headerlink" title="未配置操作系统的计算机系统"></a>未配置操作系统的计算机系统</h2><ul><li>人工操作：程序员把程序和数据通过穿孔的方式记录在纸带上，再启动机器读入纸带，运行完成并取走计算结果后，才允许下一个用户上机。缺点：<ul><li>用户独占整机：计算机上的资源为上机用户独占。</li><li>设备空闲率高：用户装卡，卸卡等人工操作时，设备资源是空闲的。</li></ul></li><li>脱机输入/输出（Off-Line I/O）：为了解决人机矛盾及CPU、I/O等设备之间速度的不匹配。它是先把纸带通过输入设备在外围机（与主机相比处于次要地位的计算机）的控制下输入到磁带上，当CPU需要这些信息时再从磁带上高速地调取。类似的，在输出时把信息输出到磁盘中，在外围机的控制下通过输出设备输出。也就是说主机直接对磁盘进行操作，输入输出和程序运行脱离。<ul><li>減少了CPU的空闲时间：主机不必依赖输入输出，可以从磁盘中读取数据。</li><li>提升了I/O速度：主机读取信息不再是从卡片中读取，从磁盘读取速度较快。<div align="center"><img src="http://blogfileqiniu.isjinhao.site/40683018-6777-42a0-ae90-90a136f75876"></div></li></ul></li></ul><p><br></p><h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><p>为了提升计算机资源的利用率和提升计算机的吞吐量研发出了批操作系统。</p><p><strong>基础概念</strong></p><ul><li>作业：程序+数据+作业说明书（系统根据说明书来对程序的运行进行控制）。</li><li>周转时间：从作业进入系统到作业完成退出系统所用的时间。</li><li>平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NT_i]$</li><li>带权周转时间：作业的周转时间（$T$）和系统为它提供服务的时间（$T_S$）。$W=\frac{T}{T_s}$</li><li>平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NW_i]$</li></ul><p><br></p><h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><p>设计一个常驻内存的程序（监督程序），操作员有选择地把若干作业合成一批，安装输入设备上，并启动监督程序，然后由监督程序自动控制这批作业运行，从而减少部分人工干预，有效地缩短了作业运行前的准备时间，相对的提高CPU的利用率。同一时刻只有一个硬件在运行。特点：自动性、顺序性、单道性。缺点：</p><ul><li>I/O的慢速与CPU 的高速不匹配，且输入时需要CPU等待。</li><li>用户交互性差。作业安装输入后，就不能再交互。<div align="center"><img src="http://blogfileqiniu.isjinhao.site/5404ba6f-d320-4018-a0d1-5a289d94f674"></div></li></ul><p><br></p><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><p>把一个以上的作业存放在主存中，并且同时处于运行状态，使这些作业共享处理机和外部设备等其它系统资源。对于一个单处理机系统来说，作业同时处于运行状态只是宏观的概念，其含义是指每个作业都已开始运行，但尚未完成。就微观而言，在任意特定时刻，处理机上运行的作业只有一个。特点：多道性、无序性、调度性。优缺点：</p><ul><li>优点：资源利用率高、系统吞吐量大。</li><li>缺点：作业仍然要排队处理，所以平均周转时间长、无交互能力。<br>此时如何调度程序已经不是再用一张简单的流程图能说明了。下图只是说明处理器利用率高。<div align="center"><img src="http://blogfileqiniu.isjinhao.site/3cf806a0-cc5d-40ca-9590-52b94be8a2c1"></div></li></ul><p><br></p><h3 id="举例证明资源利用率高和系统吞吐量大"><a href="#举例证明资源利用率高和系统吞吐量大" class="headerlink" title="举例证明资源利用率高和系统吞吐量大"></a>举例证明资源利用率高和系统吞吐量大</h3><p>设内存中有三道程序 A、B、C，它们的计算和I/O操作的时间如下表所示：<br>| 程序操作 | A | B | C |<br>| :——: | :–: | :–: | :–: |<br>| 计算 | 30 | 60 | 20 |<br>| I/O | 40 | 30 | 40 |<br>| 计算 | 10 | 10 | 20 |</p><ul><li>单道<div align="center"><img src="http://blogfileqiniu.isjinhao.site/ae55bc34-5c24-455e-8203-e7ca54ce1fc7" width="100%"></div></li><li>多道<div align="center"><img src="http://blogfileqiniu.isjinhao.site/cbdd6ae8-1724-4643-b97e-6ce7e1742cb4" width="100%"></div></li></ul><p><br></p><h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><p>批处理系统中，作业一旦提交就不能进行更改，所以人机交互性很差。为了满足人机交互的需求诞生分时系统。每一个用户通过一台终端与计算机相连，以交互式的命令使用系统，采用分享CPU的方法，由于CPU的速度比人在终端输入指令的时间快得多，所以用户感到自己独占了整个计算机系统。系统规定一个称之为“时间片”的时间单位，所有终端用户轮流享用一个时间片的CPU。需要解决的问题：</p><ul><li>及时接受：所有终端用户输入的信息都要能够被及时的送到处理器上。所以主机会以很快的速度循环扫描各个终端。每个终端也要拥有缓存区来保存输入的信息。</li><li>及时处理：用户需要能对自己的作业及其允许及时地实施控制。所以所有的作业必须驻留在内存中，因此批作业系统不能被使用。它采用的方式是：作业直接进入内存。但每个用户只连续使用一个“时间片”的时间，对所有用户进行循环。这样每个用户都能及时地与自己的作业进行交互。<div align="center"><img src="http://blogfileqiniu.isjinhao.site/98780fe2-3f17-4ec0-a295-b21276cad639"></div></li></ul><p><br></p><h3 id="分时系统与多道批处理系统的不同特性"><a href="#分时系统与多道批处理系统的不同特性" class="headerlink" title="分时系统与多道批处理系统的不同特性"></a>分时系统与多道批处理系统的不同特性</h3><ul><li>多路性：允许多个用户共享一台计算机，提高资源利用率。</li><li>独立性：每个用户之间互不干扰，感觉就是一个人在独占一台计算机。</li><li>及时性：用户的请求能在很短的时间内得到回应。</li><li>交互性：用户可以通过终端和计算机进行及时交互。</li></ul><p><br></p><h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2><p>指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。实时系统强调程序运行的时间，它需对接收到的某些信号做出及时地反应。大多数的实时系统是专用系统，如：工业（武器）控制系统、信息查询系统、多媒体系统、嵌入式系统等。最大的特点就是可靠性：系统必须高度可靠，因为任何可能的差错都可能带来灾难性后果，所以系统一般都有多级容错措施。</p><ul><li>按是否周期执行分类：<ul><li>周期性实时任务：如外部设备周期性地发出状态信号给计算机使其状态能被实时感知。</li><li>非周期性实时任务：提交给系统时需要指定开始截止时间和完成截止时间。</li></ul></li><li>硬实时任务&amp;软实时任务：<ul><li>硬实时任务（Hard Real-time Task）：截止时间到达时任务必须完成，比如武器控制系统。</li><li>软实时任务（Soft Real-time Task）：截止时间到达时任务没有完成没有太大影响，比如多媒体系统。</li></ul></li></ul><p><br></p><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ul><li>进程：在系统中能独立运行并作为资源分配的基本单位。</li><li>线程：独立运行的基本单位，比进程更小，基本上不拥有系统资源。通常在一个进程中包含了若干个线程。</li></ul><p><br></p><h2 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a>操作系统的基本特性</h2><ul><li>并发：宏观上是多个进程同时运行，微观上是每一时刻只有一道进程在执行。</li><li>共享：系统中的资源可供内存中多个并发执行的进程（线程）共同使用。有两种共享方式：<ul><li>互斥共享方式，如打印机；</li><li>同时访问方式，如共享文件夹、网络资源。</li></ul></li><li>虚拟：通过某种技术把一个物理实体变为若干个逻辑上的对应物。这样可以避免一个进程单独占用某个物理设备，一个物理设备被分配给多个进程便可以提升物理设备的使用率。</li><li>不确定性（异步性）：进程以人们不可预知的速度向前推进，即为进程的不确定性。这样的话很可能是先进入内存的作业后完成；而后进入内存的作业先完成。尽管如此，但只要有合理的进程同步方式且运行环境相同，作业经多次运行，都会获得完全相同的结果。因此，异步运行方式是允许的。</li></ul><p><br></p><h2 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h2><h3 id="传统操作系统结构"><a href="#传统操作系统结构" class="headerlink" title="传统操作系统结构"></a>传统操作系统结构</h3><ul><li>无结构OS：<ul><li>关注功能的实现和获得高的效率操作系统是为数众多的一组过程的集合，各过程之间可以相互调用，在操作系统内部不存在任何结构。</li><li>程序设计的技巧，只是如何编制紧凑的程序，以便于有效地利用内存。</li><li>操作系统既庞大又杂乱，缺乏清晰的程序结构。</li><li>程序错误很多，给调试工作带来很多困难；另一方面也使程序难以阅读和理解，增加了维护人员的负担。</li></ul></li><li>模块化结构OS<ul><li>模块化程序设计技术，是最早（20世纪60年代）出现的一种程序设计技术。该技术是基于“分解”和“模块”原则来控制大型软件的复杂度的。</li><li>将OS按其功能划分为若干个具有一定独立性和大小的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口， 使各模块之间能通过该接口实现交互，然后再进一步将各模块细分为若干个具有一定管理功能的子模块。（会导致模块之间的依赖关系很重，OS结构不清晰）</li><li>若子模块较大时，再进一步将它细分。<div align="center"><img src="http://blogfileqiniu.isjinhao.site/3637ba18-bc51-4b80-ba93-7e2ac5780c21"></div></li></ul></li><li>分层式结构OS：<ul><li>改进设计方式，使每一步设计都是建立在可靠的基础上一层一层地自底向上增添软件层，每一层都实现若干功能，最后总能构成一个能满足需要的OS。</li><li>每一层都仅使用其底层所提供的功能和服务，这样可使系统的调试和验证都变得容易。</li><li>一旦发现错误后，通常该错误只会局限于某一层，因为它与所有其高层的软件无关，而此层以下的各层软件，又都经过仔细的调试，bug修复较为容易。</li></ul></li></ul><p><br></p><h3 id="客户-服务器结构"><a href="#客户-服务器结构" class="headerlink" title="客户/服务器结构"></a>客户/服务器结构</h3><ul><li>为了提高OS的灵活性和可扩充性而将OS划分为两部分。</li><li>一部分是用于提供各种服务的一组服务器（进程），所有这些服务器（进程）都运行在用户态。当有一用户进程（现在称为客户进程）要求读文件的一个盘块时，该进程便向文件服务器（进程）发出一个请求；当服务器完成了该客户的请求后，便给该客户回送一个响应。</li><li>另一部分是内核，用来处理客户和服务器之间的通信， 即由内核来接收客户的请求，再将该请求送至相应的服务器；同时它也接收服务器的应答， 并将此应答回送给请求客户。</li><li>此外，在内核中还应具有其它一些机构，用于实现与硬件紧密相关的和一些较基本的功能。</li></ul><p><br></p><h3 id="面向对象结构（20世纪80年代）"><a href="#面向对象结构（20世纪80年代）" class="headerlink" title="面向对象结构（20世纪80年代）"></a>面向对象结构（20世纪80年代）</h3><ul><li>该技术是基于“抽象”和“隐蔽”原则来控制大型软件的复杂度的。所谓对象，是指在现实世界中具有相同属性、服从相同规则的一系列事物的抽象，而把其中的具体事物称为对象的实例。</li><li>OS中的各类实体如进程、线程、消息、存储器等，都使用了对象这一概念，相应地，便有进程对象、线程对象、 存储器对象等。<ul><li>由于隐蔽了表示实体的数据和操作，因而可以改变对象的表示而不会影响其它部分， 从而可以方便地改变老的对象和增加新的对象。</li><li>继承性。继承性是面向对象技术所具有的重要特性。继承性是指子对象可以继承父对象的属性，这样，在创建一个新的对象时， 便可减少大量的时空开销。</li><li>正确性和可靠性。由于对象是构成操作系统的基本单元，可以独立地对它进行测试，这样，比较易于保证其正确性和可靠性，从而比较容易保证整个系统的正确性和可靠性。</li></ul></li></ul><p><br></p><h3 id="微服务结构（20世纪90年代）"><a href="#微服务结构（20世纪90年代）" class="headerlink" title="微服务结构（20世纪90年代）"></a>微服务结构（20世纪90年代）</h3><ul><li>能有效支持多处理机，适用于分布式系统环境。</li><li>以微内核为操作系统核心，以客户/服务器为基础，采用了面向对象的程序设计方法。<ul><li>所谓微内核技术，是指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS（程序）不同， 它更小更精炼，它不仅运行在核心态，而且开机后常驻内存， 它不会因内存紧张而被换出内存。</li><li>微内核并非是一个完整的OS， 而只是为构建通用OS提供一个重要基础。</li><li>在微内核OS结构中，通常都采用了客户/服务器模式，因此OS的大部分功能和服务，都是由若干服务器来提供的， 如文件服务器、作业服务器和网络服务器等。</li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;操作系统的定义&quot;&gt;&lt;a href=&quot;#操作系统的定义&quot; class=&quot;headerlink&quot; title=&quot;操作
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>06.03-处理机调度</title>
    <link href="https://isjinhao.github.io/posts/21854.html/"/>
    <id>https://isjinhao.github.io/posts/21854.html/</id>
    <published>2019-12-20T09:19:38.000Z</published>
    <updated>2019-12-20T09:29:23.870Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>处理机调度是指通过对处理机资源进程的合理分配来提升系统资源的利用率、降低作业周转时间等。但是由于不同操作系统的目标不同，所以处理机调度的策略和目标也不相同。</p><p><br></p><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ul><li>高级调度：又称作业调度或长程调度。它的主要功能是根据某种算法决定把外存上处于后备队列中的哪些作业调入内存，并为他们创建进程、分配资源等，然后放入就绪进程队列。主要用于批处理系统，分时系统的实时系统中不设置高级调度。</li><li>低级调度：又称进程调度或断层调度。它的主要功能是根据某种算法决定让哪些就绪队列获得处理机，并由分配程序将处理机分配给被选中的进程。在批处理系统、实时系统和分时系统中都设置低级调度。</li><li><p>中级调度：又称内存调度。它的主要功能是根据某种算法决定将哪些暂时不能运行的进程调至外存等待，当它们具备运行条件且内存又有空闲时再调入内存。这实际上是存储器管理中的对换功能，在下一章再展开介绍，</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/38d9944c-3486-467d-ae1e-87a64eaa8e55"></div></li></ul><p><br></p><h3 id="处理机调度的目标"><a href="#处理机调度的目标" class="headerlink" title="处理机调度的目标"></a>处理机调度的目标</h3><p><strong>共同目标</strong></p><ul><li>提升资源利用率：$ CPU的利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$。</li><li>公平：每个进程都应获得合理的CPU时间，不发生进程饥饿现象。</li><li>平衡：进程可以分成多个类型，如计算型、I/O型等等。平衡是指系统中不同的设备都能处于忙碌状态。</li><li>策略强制执行：指某些强制型任务，比如安全策略等，即使会造成其他工作的延迟。</li></ul><p><strong>批处理系统的目标</strong></p><ul><li>平均周转时间短：<ul><li>周转时间：从作业进入系统到作业完成退出系统所用的时间。</li><li>平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$ T=\frac{1}{n}[\sum_{i=1}^NT_i]$</li><li>带权周转时间：作业的周转时间（$ T$）和系统为它提供服务的时间（$T_S$）。$W=\frac{T}{T_s}$</li><li>平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$ T=\frac{1}{n}[\sum_{i=1}^NW_i]$</li></ul></li><li>系统吞吐量高：单位时间内系统完成的作业数尽量多。</li><li>处理机利用率高。</li></ul><p><strong>分时系统的目标</strong></p><ul><li>响应时间快：指终端提交一个请求到主机返回结果至终端的时间短。</li><li>均衡：不同请求的复杂度不同，所以响应时间必定不同，均衡是指响应时间应和请求复杂度相适应。</li></ul><p><strong>实时系统的目标</strong></p><ul><li>截止时间的保证：对于HRT任务截止时间必须满足要求，SRT也要尽可能满足。</li><li>可预测性：如在观看电影时一般都会连续播放帧，所以请求是可预测的，假如采用双缓冲实现第<code>i</code>帧和第<code>i+1</code>帧并行处理就能提高实时性。</li></ul><p><br></p><h2 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h2><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ul><li>作业：比程序更为广泛的概念，不仅包含了通常的程序和数据，还有一份作业说明书。在批处理系统中，是以作业为基本单位从外存调入内存的。</li><li>作业步：在作业运行期间，每个作业都必须经过若干个相对独立。又相互关联的顺序加工步骤才能得到结果。期中每一个加工步骤成为一个作业步。</li></ul><p><br></p><h3 id="作业控制块"><a href="#作业控制块" class="headerlink" title="作业控制块"></a>作业控制块</h3><p>Job Control Block，JCB。是作业在系统中存在的标志。保存了系统对作业进行管理和调度所需的全部信息。如：作业标识、用户名称、用户账号、作业类型（CPU繁忙型、I/O繁忙型、批量型、终端型等）、作业状态、调度信息（优先级、作业运行时间）、资源需求（预计运行时间、要求内存大小等）、已申请到资源的使用情况。</p><p><br></p><h3 id="作业运行的三个阶段"><a href="#作业运行的三个阶段" class="headerlink" title="作业运行的三个阶段"></a>作业运行的三个阶段</h3><ul><li>收容阶段：每一个作业进入系统时（即输入到硬盘），便由“作业注册”程序为该作业建立一个作业控制块JCB并把它放入作业后备队列中。</li><li>运行阶段：后备队列中的作业被选中后，系统会为其分配必要的资源和建立进程，然后将其放入就绪队列。一个作业从第一次进入就绪状态开始到它运行结束前都是处于运行阶段。</li><li><p>完成阶段：当作业完成或发生异常而终止时，作业便处于完成阶段，此时系统会撤销进程和资源，并将运行结果通过某种方式输入，如输出到文件中。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/5514dcb1-1977-4326-8f23-8c3ca9ce19f4"></div></li></ul><p><br></p><h3 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h3><p>First-Come First-served，FCFS。每次调度都是选择一个或多个最先进入队列的作业或进程，为它们分配资源，创建进程和分配CPU，使之投入运行。它是最简单的调度算法，同时也可用于进程调度。效率不高，所以一般不作为主调度算法。<br>适用于CPU繁忙型而不适用于I/O繁忙型。因为CPU繁忙型长时间占用CPU很少有I/O操作，一旦获得CPU，就会运行很长时间，就是会长时间占用CPU，而I/O繁忙型由于要频繁访问IO端口，每次访问都要放弃CPU，等I/O访问完后要重新等待下一次调度（此时排到了就绪队列的队尾），所以要等待很久才能重新被调度。因此先来先服务有利于CPU繁忙型而不利于I/O繁忙型。</p><p><br></p><h3 id="短作业优先算法"><a href="#短作业优先算法" class="headerlink" title="短作业优先算法"></a>短作业优先算法</h3><p>Short Job First，SJF。指对短作业优先调度的算法，它从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。<br>此种算法对长作业非常不利而且实际使用上很难预估每个作业的运行时间。</p><p><br></p><h3 id="静态优先级调度算法"><a href="#静态优先级调度算法" class="headerlink" title="静态优先级调度算法"></a>静态优先级调度算法</h3><p>为照顾紧迫性作业，使之进入系统后获得优先处理，引入优先级调度算法。按照进程的优先级大小来调度，使高优先级进程得到优先处理的策略称为优先权调度算法。<br>静态优先级调度算法是指在输入前作业为其赋予优先级且一直保持不变。虽然可以照顾紧迫性作业，但是没有考虑到作业本身的运行时间和作业的等待时间等，所以产生了更好的动态优先级算法。</p><p><br></p><h3 id="高响应比算法"><a href="#高响应比算法" class="headerlink" title="高响应比算法"></a>高响应比算法</h3><p>高响应比算法是动态优先级算法的一种，其中$ 优先级 = \frac{响应时间}{要求服务时间} = \frac{等待时间+要求服务时间}{要求服务时间}$。这样可以得到：</p><ul><li>对于短作业：其要求服务时间短，优先级相对较高。</li><li>对于长作业：在等待一段时间之后，其优先级会增长，直至够高而能获得服务。</li><li>对于先来作业：假如在某一时刻其仍未获得服务，和后来的作业相比其优先级相对较高。<br>相应时间与周转时间的对比，假如作业运行完了，两者相等，假如没有则 $响应时间&lt;周转时间$</li><li>周转时间：从作业进入系统到作业完成退出系统所用的时间。</li><li>响应时间：等待时间+要求服务时间。</li></ul><p><br></p><h2 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h2><h3 id="进程调度的任务"><a href="#进程调度的任务" class="headerlink" title="进程调度的任务"></a>进程调度的任务</h3><ul><li>保存处理机的现场信息：比如程序计数器、通用寄存器里的内容。</li><li>按某种算法选取进程。</li><li>把处理机分配给进程：把选中进程的PCB中的有关处理机调度的信息装入处理器的寄存器中，把处理器的控制权交给进程使其能从上次的断点处恢复运行。</li></ul><p><br></p><h3 id="进程调度机制"><a href="#进程调度机制" class="headerlink" title="进程调度机制"></a>进程调度机制</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/51c80e55-e603-4592-9a7c-c454fee155c5"></div><ul><li>排队器：每当有进程转入就绪状态时，排队器会将它插入到相应的就绪队列。</li><li>分派器：分派器依据进程调度程序（更直接的说，进程调度算法）所选定的进程，将其从就绪队列中取出。</li><li>上下文切换器：会产生两次上下文切换：<ul><li>旧进程和分配程序之间的切换；</li><li>分配程序和新进程之间的切换。<br>排队器、分派器、上下文切换器本身也是程序，但是它们是处于系统态的程序，而被调度的进程一般是用户态的程序，从系统态到用户态进行上下文切换需要很大的耗费，所以一般采用两组（或多组）寄存器，一组用于处理机在系统态时使用，一组用于系统在用户态时使用，这样在系统态和用户态之间切换时就可以只改变指针（用于从寄存器中存取数据和指令）使其指向指定寄存器就行。</li></ul></li></ul><p><br></p><h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><p><strong>非抢占方式</strong></p><p>一旦某进程获得处理机，就会一直运行下去，直至该进程完成或者因发生某种事件而被阻塞其他进程才能获得处理机。此时引起进程调度的因素：</p><ul><li>正在执行的进程运行完毕。</li><li>外部环境的改变使其不能再继续运行，如程序运行发生异常。</li><li>进程通信或进程同步时执行了某种原语，如<code>Block</code>。</li><li>正在执行的进程发出I/O请求。</li></ul><p><strong>抢占方式</strong></p><p>允许调度程序根据某种原则去暂停某个正在执行的进程，将处理机分配给其他进程。这些原则一般有三种：</p><ul><li>高优先级原则</li><li>短进程优先原则</li><li>时间片原则<br>我们后面所提到的进程调度算法其实都是抢占方式下的策略。</li></ul><p><br></p><h3 id="轮转调度算法"><a href="#轮转调度算法" class="headerlink" title="轮转调度算法"></a>轮转调度算法</h3><p>将CPU的处理时间分成固定大小的时间片q， q的大小从几ms到几百ms。系统将所有就绪进程按先来先服务的原则排成队列。每次调度时，把CPU分配给队首进程，令其执行一个时间片，时间片用完后若进程未结束，则送回就需队列尾部重新调度，在一给定的时间内，就绪进程均能获得一时间片的执行时间。<br>此时时间片大小是关键问题，一般来说时间片q正比于响应时间，反比于就绪进程数目。计算机的处理能力。速度快，q可小些。通常q值是这样决定的：</p><ul><li>批处理系统:80%的CPU周期在一个时间片内完成</li><li>分时系统：$ q=T/N_{max}$，（$T-响应时间上限，N_{max}-最大进程数$）</li></ul><p><br></p><h3 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h3><h4 id="抢占式-非抢占式"><a href="#抢占式-非抢占式" class="headerlink" title="抢占式/非抢占式"></a>抢占式/非抢占式</h4><p><strong>非抢占式优先级调度算法</strong></p><p>即一旦某个高优先级的进程占有了处理机，就一直运行下去，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件）才让另一高优先级进程运行。主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p><p><strong>抢占式优先级调度算法</strong></p><p>任何时刻都严格按照高优先级进程在处理机上运行的原则进行进程的调度。常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。</p><h4 id="静态-动态优先权"><a href="#静态-动态优先权" class="headerlink" title="静态/动态优先权"></a>静态/动态优先权</h4><p><strong>静态优先权</strong></p><p>静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，这些整数被称为优先数。确定优先权大小的依据：</p><ul><li>进程类型；</li><li>进程对资源的需求；</li><li>用户要求。</li></ul><p><strong>动态优先权</strong></p><p>动态优先权是指，在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得<br>更好的调度性能。例如，我们可以规定，在就绪队列中的进程，随其等待时间的增长，其优先权以速率<code>a</code>提高。若所有的进程都具有相同的优先权初值，则显然是最先进入就绪队列的进程，将因其动态优先权变得最高而优先获得处理机，此即<code>FCFS算法</code>。若所有的就绪进程具有各不相同的优先权初值，那么，对于优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机。当采用抢占式优先权调度算法时，如果再规定当前进程的优先权以速率b下降，则可防止一个长作业长期地垄断处理机。</p><p><br></p><h3 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h3><p>之前介绍的调度算法都是用一个算法来解决所有的进程调度，这样无法满足系统中不同用户对进程调度策略的不同要求。而多队列调度算法就是将就绪队列从一个分成多个，将不同性质或类型的进程放在不同的就绪队列，这样不同的队列之间设置优先级，和队列内部也可以设置优先级，能更好的满足用户的需求。<br>同时在多处理机系统中，可以方便的给每个处理机设置单独的就绪队列。</p><h4 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h4><ol><li>设置多个就绪队列，每个队列赋予不同的优先级，一个队列的优先级最高，第二个队列次之，其余各队列的优先级逐个降低，各队列内部使用FCFS原则排列。</li><li>优先级越高的进程时间片越短。</li><li>当一个进程进入内存后，首先放在第一队列的尾部，按FCFS的原则调度，如果该时间片内未结束，进程调度时将此进程转入第二队列队尾，直至第N个对列，若进程仍未结束，在第N个对列上采用时间片轮转算法。</li><li>仅当第<code>i</code>队列空闲时才调度第<code>i+1</code>队列，如果有新进程进入优先级较高的队列，剥夺CPU执行新进程，旧进程放入原队列尾部。<br>此算法不必事先知道各进程执行的所需时间，可满足各种进程需要，是目前公认较好的进程调度算法。</li></ol><div align="center"><img src="http://blogfileqiniu.isjinhao.site/12ef01d9-3f05-4ff6-9cfb-2a250ca73b4f"></div><p><strong>举例</strong></p><p>第<code>i</code>个对列的时间片为$ 2^{i-1}$。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/4ac099d2-2a5d-4b3b-acbb-1b50387dca7d"></div><p><br></p><h3 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h3><h4 id="保证调度算法"><a href="#保证调度算法" class="headerlink" title="保证调度算法"></a>保证调度算法</h4><p>保证每个进程都获得相同的处理机时间：</p><ol><li>跟踪计算每个进程自创建以来已经执行的时间。</li><li>计算每个进程应该获得的处理机时间，即自创建以来的时间除以n。</li><li>比较各进程获得处理机时间的比率，即实际执行时间除以应获得的处理机时间。</li><li>比较各进程获得处理机时间的比率，如A：0.5；B：0.9；C：1.2。</li><li>调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率，然后把处理机让给此时比率最小的进程。</li></ol><h4 id="公平调度算法"><a href="#公平调度算法" class="headerlink" title="公平调度算法"></a>公平调度算法</h4><p>在上个算法中，如果用户A有4个进程，用户B有1各进程，那用户A获得处理机的时间是用户B的四倍。而公平调度算法的目标是保证每个用户都获得相同的处理机时间。</p><p><br></p><h3 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h3><p>实时调度必须能满足实时任务对截止时间的要求。所以实时任务的算法和优先级算法有些区别。</p><h4 id="实时算法的分类"><a href="#实时算法的分类" class="headerlink" title="实时算法的分类"></a>实时算法的分类</h4><p><strong>非抢占式调度算法</strong></p><ul><li>非抢占式轮转调度算法</li><li>非抢占式优先调度算法</li></ul><p><strong>抢占式调度算法</strong></p><ul><li>基于时钟中断的抢占式优先级调度算法：在某实时任务到达后，如果它的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断发生时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先级任务。</li><li>立即抢占式优先级调度算法：一旦出现外部中断，只要当前任务未处于临界区，便立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/30d48a74-09c0-414d-84f9-af18b588b938"></div><h4 id="最早截止时间优先算法"><a href="#最早截止时间优先算法" class="headerlink" title="最早截止时间优先算法"></a>最早截止时间优先算法</h4><p>Earliest Deadline First，EDF。可用于非抢占式算法，也可用于抢占式算法。</p><p><strong>非抢占式</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/2187a911-f433-4d65-9eba-bd4af7660494"></div><p><strong>抢占式</strong></p><p>有两个周期任务，A、B的周期分别是20ms，50ms。A、B的执行时间分别是10ms和25ms。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/2612cb3c-d7df-4031-8b97-3292d05f638a"></div><h4 id="最低松弛度优先即算法"><a href="#最低松弛度优先即算法" class="headerlink" title="最低松弛度优先即算法"></a>最低松弛度优先即算法</h4><p>Least Laxity First，LLF。$ 松弛度=截止时间-当前时间-任务执行时间$。主要用于抢占式调度。</p><p><strong>例</strong></p><p>有两个周期任务，A、B的周期分别是20ms，50ms。A、B的执行时间分别是10ms和25ms。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/40c0060f-2a5c-40a1-8c8e-32aed3d969d6"></div><p><br></p><h3 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h3><p>即高优先级进程（或线程）被低优先级（或线程）延迟或阻塞。例，假如有三个完全独立的进程P1、P2和P3，优先级P1&gt;P2&gt;P3。P1和P3通过共享一个临界资源进行交互。<br></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P1：...P(mutex); CS<span class="number">-1</span>; V(mutex);... </span><br><span class="line">P2: ...Program2...;</span><br><span class="line">P3：...P(mutex); CS<span class="number">-3</span>; V(mutex);...</span><br></pre></td></tr></table></figure><p></p><p>假如P3最先执行，在执行了P(mutex)操作后，进入临界区CS-3。在时刻a，P2就绪，因为它比P3的优先级高，P2抢占了P3的处理机而运行，在时刻b，P1就绪，因为它比P2的优先级高，抢占处理机执行，但P1执行P(mutex)之后被阻塞，处理机被P2获得，P2执行结束后，P1仍不能进入临界区，处理机被P3获得，等P3退出临界区，P1才能获得处理机。所以本应该高优先级的P1优先执行，但是由于存在临界资源而导致优先级倒置。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/414d2145-02ed-48c9-86a8-988dda60f4c1"></div><h4 id="优先级倒置的解决"><a href="#优先级倒置的解决" class="headerlink" title="优先级倒置的解决"></a>优先级倒置的解决</h4><p>遵循动态优先级继承原则：当高优先级进程P1要进入临界区去使用临界资源，如果已经有一个低优先级进程P3正在使用该资源，此时一方面P1被阻塞，一方面P3继承P1的优先级并一直保持到P3退出临界区。这样做就能保证不会有比P3优先级高但比P1优先级低的进程插进来。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a336fb94-97da-456a-8a23-5ce5a0eeef1a"></div><p><br></p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h3><p><strong>可重用资源和消耗性资源</strong></p><ul><li>可重用性资源：可供用户重复使用多次的资源。特点：<ul><li>互斥访问</li><li>系统中此资源数目相对固定</li><li>系统中大多数资源属于此类</li></ul></li><li>可消耗性资源：临时性资源<ul><li>由进程动态创建和消耗，数目是可以不断变化的，比如信号量、进程通信的信息等。</li></ul></li></ul><p><strong>可抢占性资源和不可抢占性资源</strong></p><ul><li>可抢占性资源：CPU和主存，不会引起死锁。</li><li>不可抢占性资源：只能进程自行释放。如打印机，因为如果打印到一半，打印机被抢占，造成的结果只能是此次打印作废，所以它是不可抢占资源。</li></ul><p><br></p><h3 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h3><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a6d26310-9d83-4d38-be3d-a50cbac353cb"></div><p><br></p><h3 id="死锁的起因"><a href="#死锁的起因" class="headerlink" title="死锁的起因"></a>死锁的起因</h3><h4 id="竞争不可抢占性资源引起死锁"><a href="#竞争不可抢占性资源引起死锁" class="headerlink" title="竞争不可抢占性资源引起死锁"></a>竞争不可抢占性资源引起死锁</h4><p>一个资源只能同时被一个进程使用，但是下图P1在获得R1后还去申请R2，同时P2获得R2后还去申请R1，陷入僵局，引发死锁。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/2bd54ddc-e4fa-46d0-a593-dd95f202ada5"></div><h4 id="竞争可消耗性资源引起死锁"><a href="#竞争可消耗性资源引起死锁" class="headerlink" title="竞争可消耗性资源引起死锁"></a>竞争可消耗性资源引起死锁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P1：receive(p3,m3)； send(p2,m1)；</span><br><span class="line">P2：receive(p1,m1)； send(p3,m2)；</span><br><span class="line">P3：receive(p2,m2)； send(p1,m3)；</span><br></pre></td></tr></table></figure><p>如上代码，P1在等待P3给P1发消息，P2在等待P1给它P2发消息，P3在等待P2给P3发消息。造成一个死循环。</p><p><br></p><h3 id="进程推进顺序非法"><a href="#进程推进顺序非法" class="headerlink" title="进程推进顺序非法"></a>进程推进顺序非法</h3><p>在下图中，X轴表示进程P1推进图，Y轴表示进程P2推进图。如果按照4号路线推进，可以看出P1在经过b、d段的执行之后，获得R1，P2在进过a、c、e段的执行之后获得R2。此时如果不加以处理，系统一定会进入死锁状态，因为接下来P1在拥有R1后又去申请R2，P2在拥有R2后又去申请R1。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/fd646fa0-a793-4943-9249-c10e0e09e73b"></div><p><br></p><h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><ul><li>互斥条件：某段时间内，某资源只能由一个进程使用；</li><li>请求和保持条件：进程因请求资源而阻塞时，对已分配给它的资源保持不放；</li><li>不可抢占条件 ：资源在未使用完前，不能被剥夺，由使用进程释放；</li><li>循环等待条件 ：发生死锁时，有向图必构成一环路。</li></ul><p><br></p><h3 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h3><p>共有三类做法：</p><ul><li>第一类是预防死锁，也就是破坏死锁产生的条件（破坏其中一个就可以），这样系统就永远不会产生死锁。</li><li>第二类是死锁避免，死锁产生的根本原因是系统资源分配出现问题，如果能进行合理的资源分配就能避免死锁的发生。</li><li>第三类是死锁发生后的检测和解除。</li></ul><p><br></p><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>预防死锁是给系统施加一个条件使其永远不可能满足死锁产生的必要条件，但是互斥条件是不能被破坏的条件，所以预防死锁有三类做法：</p><p><strong>破坏“请求和保持”条件</strong></p><p>即进程在请求资源时，它不能持有不可抢占资源。有两种做法：</p><ol><li>所有进程在开始运行之前，一次性的申请其在整个运行过程中的全部资源，如果申请成功，进程便陷入等待。这样进程在运行的时候就不会再发出请求。</li><li>进程在只获得运行初期所需的资源后便开始运行，但是进程在运行过程中需要逐步释放以分配给自己的资源，等初期获得所有资源都被释放后才能请求其他资源。</li></ol><p><strong>破坏“不可抢占”条件</strong></p><p>当进程保持了某些不可被抢占资源，且提出的新需求又不能被满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这种预防策略的代价非常昂贵，比如进程请求的打印机被强制剥夺后，之前的工作等于作废。</p><p><strong>破坏“循环等待”条件</strong></p><p>常见的方法是“资源有序分配”。其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号升序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程，在拥有大编号资源再申请小编号资源时需要释放和小资源编号相等及以上的编号。</p><p><br></p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>避免死锁讲道理是属于死锁的预防，但是它和预防死锁不同，预防死锁是破坏死锁产生的条件，避免死锁是防止系统进入不安全状态。所以我们就要明白什么是安全状态，它和死锁产生的必要条件有什么区别。</p><h4 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h4><p>安全状态指的是系统能按某种进程推进顺序<code>(P1, P2, …, Pn)</code>为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。此时，序列<code>(P1, P2, …, Pn)</code>为安全序列。如果系统无法找到这样一个序列，则称系统处于不安全状态。<br>为什么能找到这样的序列系统就是安全的呢？其实它是一个递推的关系，假如系统在时刻<code>i</code>发起申请资源请求，其此时状态为<code>a</code>，系统会判断它申请成功后是否还能寻找到一个安全序列，如果能找到便可以分配，否则便是系统不安全状态。假如系统申请到了资源，还想发出申请请求，便会再次判断请求成功之后能否找到安全序列，由此递推下去可保证整个系统能避免死锁。</p><h4 id="安全状态和死锁必要条件的区别"><a href="#安全状态和死锁必要条件的区别" class="headerlink" title="安全状态和死锁必要条件的区别"></a>安全状态和死锁必要条件的区别</h4><p>仍以此图为例。假如我们采用的是预防死锁策略中的破坏“请求和保持”条件里的第一个做法，那么推进顺序就不可能为4，因为进程P1在执行的时候需要获取全部资源才能执行。但对于避免死锁来说，系统可以按照4号推进顺序推进到e段和阴影区的交界处，然后进程P2在申请资源R2的时候会去判断分配R2给P2之后系统能否找到安全序列，事实上是找不到的，所以R2便不会分配给P2，这样系统就进入不了阴影区，从而可以避免死锁。<br>所以预防死锁和避免死锁的区别是：</p><ul><li>预防死锁是每个进程在执行之前确保其自身不陷入死锁状态，如果每个进程都能不陷入死锁状态，系统便能永远安全。即从单个进程角度静态解决问题。</li><li>但避免死锁是在每一次进行资源分配时判断分配之后是否系统处于安全状态，如果处于安全状态便可分配，否则便不能分配。即从系统整体角度动态解决问题。</li></ul><p><br></p><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ol><li>可利用资源向量$Available$：是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果$Available[j]=K$，则表示系统中现有$R_j$类资源K个。</li><li>最大需求矩阵$Max$：这是一个$n×m$的矩阵，它定义了系统中$n$个进程中的每一个进程对$m$类资源的最大需求。如果$Max[i, j]=K$，则表示进程$i$需要$R_j$类资源的最大数目为K。</li><li>分配矩阵$Allocation$：这也是一个$n×m$的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果$Allocation[i,j]=K$，则表示进程i当前已分得$R_j$类资源的 数目为K。</li><li>需求矩阵$Need$：这也是一个$n×m$的矩阵，用以表示每一个进程尚需的各类资源数。如果$Need[i,j]=K$，则表示进程$i$还需要$R_j$类资源K个，方能完成其任务。<br>可得：$Need[i,j]=Max[i,j]-Allocation[i,j]$</li></ol><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>设进程$cusneed$提出请求$REQUEST[i]$，则银行家算法按如下规则进行判断。</p><ol><li>如果$REQUEST[cusneed] [i]&lt;= Need[cusneed][i]$，则转2；否则，出错。</li><li>如果$REQUEST [cusneed] [i]&lt;= Available[i]$，则转3；否则，等待。</li><li>系统试探分配资源，修改相关数据：<ol><li>$Available[i]-=REQUEST[cusneed][i]$;</li><li>$Allocation[cusneed][i]+=REQUEST[cusneed][i]$;</li><li>$Need[cusneed][i]-=REQUEST[cusneed][i]$;</li></ol></li><li>系统执行安全性检查算法，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。</li></ol><h4 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h4><ol><li>设置两个工作向量$Work=Available$、$Finish=false$。</li><li>从进程集合中找到一个满足下述条件的进程$i$，$Finish[i]==false;$$Need[i, j]&lt;=Work[j];$，如找到，执行3；否则，执行4。</li><li>设进程获得资源，可顺利执行，直至完成，从而释放资源。$Work[i]=Work[i]+Allocation[i,j];$，$Finish[i]=true;$，循环2。</li><li>如所有的进程$Finish= true$，则表示安全；否则系统不安全。</li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li>假定系统中有五个进程$\lbrace P0, P1, P2, P3, P4\rbrace$和三类资源$\lbrace A,B, C\rbrace$，各种资源的数量分别为10、5、7，在$T0$时刻的资源分配情况如图所示。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/ee046284-dee0-41b3-9fdb-18efbcd663a8"></div><ul><li>$T0$时刻的安全性</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/d87f5050-6673-4f43-9841-fd8e20ae086d"></div><ul><li>$P1$请求资源：$P1$发出请求向量$Request1(1,0,2)$，系统按银行家算法进行检查。<ul><li>$Request_1(1, 0, 2)≤Need_1(1, 2, 2)$</li><li>$Request_1(1, 0, 2)≤Available_1(3, 3, 2)$</li><li>系统先假定可为$P1$分配资源，并修改$Available,Allocation_1和Need_1$向量。由此得到的资源变换情况如上上图括号所示。</li><li>再利用安全性算法检查此时系统是否安全。</li></ul></li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/93c661fb-3c05-470c-ae0f-ef075f462e2c"></div><ul><li>$P4$请求资源：$P4$发出请求向量$Request_4(3,3,0)$，系统按银行家算法进行检查。<ul><li>$Request_4(3, 3, 0)≤Need_4(4, 3, 1);$。</li><li>$Request_4(3, 3, 0)&gt;Available(2, 3, 0)$，让$P4$等待。</li></ul></li><li><p>$P0$请求资源：$P0$发出请求向量$Requst_0(0,2,0)$，系统按银行家算法进行检查。</p><ul><li>$Request_0(0, 2, 0)≤Need_0(7, 4, 3);$</li><li>$Request_0(0, 2, 0)≤Available(2, 3, 0);$</li><li>系统暂时先假定可为$P0$分配资源，并修改有关数据，如下图所示。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/b3f54307-9e0e-4913-92fd-ae8e2379ef32"></div></li><li><p>进行安全性检查：此时可用资源$Available(2,1,0)$已经不能满足任何进程的需要，进入不安全状态，因此系统不分配资源。</p></li></ul><p><br></p><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p>在图中找一既非阻塞又非独立的进程节点$P_i$，如顺利，$P_i$可获得所有资源直至运行完毕。消去$P_i$所有的请求边和分配边，即释放占有的所有资源，同理再选下一进程节点$P_{i+1}, …, $若能消去所有的边，那么该图是可完全简化的，否则该图是不可完全简化的。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/05a53765-99c3-465d-97e1-e6240f500337"></div><p>具体做法如下：</p><ol><li>可利用资源向量$Available[]$，它表示了m类资源中每一类资源的可用数目。</li><li>把不占用资源的进程（向量$Allocation[i]∶= 0$）记入L表中，即$L_i \bigcup L$。</li><li>从进程集合中找到一个$Request_i≤Work$的进程，做如下处理：<ol><li>将其资源分配图简化，释放出资源，增加工作向量$Work∶ =Work+Allocation_i$。</li><li>将它记入L表中。</li></ol></li><li>若不能把所有进程都记入L表中， 便表明系统状态S的资源分配图是不可完全简化的。 因此，该系统状态将发生死锁。</li></ol><h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><p>死锁解除有多种做法，如下是按代价递减排序的几种。</p><ol><li>撤销所有死锁的进程。</li><li>将每个进程回退到先前定义的某个检查点，再重新启动所有进程。</li><li>逐个撤销死锁进程，直至死锁不存在。撤销进程的顺序应是基于某种最小代价原则，每次撤销后，死锁检测算法应该重新检测死锁是否依然存在。</li><li>剥夺进程P的资源交给进程Q，P同时会退到获得此资源的节点上。<br>对于3和4，选择的标准可以如下：</li></ol><ul><li>以占用处理器的时间最小；</li><li>以产生的输出少；</li><li>所估计的剩余运行时间最长；</li><li>所占用的资源最少；</li><li>优先权最低。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>06.02-进程调度</title>
    <link href="https://isjinhao.github.io/posts/58.html/"/>
    <id>https://isjinhao.github.io/posts/58.html/</id>
    <published>2019-12-20T09:19:38.000Z</published>
    <updated>2019-12-20T09:29:23.866Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><h3 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h3><p>数据结构中的有向无环图。箭头表示进程之间执行的先后关系。结点表示一个程序或一个进程，甚至一条语句。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/5f58725a-616a-4a24-90c5-9896c8172650"></div><p><br></p><h3 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h3><p>不存在前趋关系的程序之间才有可能并发执行。特征：</p><ul><li>间断性：程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系，进而导致并发程序具有“执行-暂停-执行”这种间断性的活动规律。</li><li>失去封闭性：由于资源共享，所以当某程序的运行影响资源的状态时，其他程序的运行环境就会被破坏。</li><li>不可再现性：计算结果与并发程序各自执行速度有关。即同一程序，使用相同输入、在相同环境下运行，却可能获得完全不同的结果。</li></ul><p><br></p><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><p>在多道程序环境下，程序的执行属于并发执行，此时他们将失去其封闭性，并具有间断性，以及运行结果的不可再现性。由此，决定了通常的程序是不能参与并发执行的。为了能使程序并发执行，引入了进程。</p><ul><li>进程实体：程序+数据+进程控制块（Process Control Block，PCB）。</li><li>进程：运行态的进程实体是就是进程，是系统进行资源分配和调度的一个独立单位。<br>PCB是为了使程序能并发执行而诞生的一种数据结构，它用来控制和管理进程。由于数据和程序本来就存在，所以创建/撤销进程也就是创建/撤销PCB。至于如何并发执行，见下面的进程同步。<br>区别于作业：进程是程序在数据集上的一次作执行，作业是用户提交给系统的一个任务，包含一个或多个进程。</li></ul><p><br></p><h3 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h3><ul><li>动态性：由创建而产生，由调度而执行，由撤销而消亡。</li><li>并发性：进程的重要特征，操作系统的重要特征。</li><li>独立性：独立运行、独立分配资源、独立接受调度。</li><li>异步性：按各自独立、不可预知的速度向前推进。</li></ul><p><br></p><h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><h3 id="PCB中保存的信息"><a href="#PCB中保存的信息" class="headerlink" title="PCB中保存的信息"></a>PCB中保存的信息</h3><ul><li>进程标识符。用于唯一的标识某个进程。<ul><li>外部标识符：不仅可以标识进程，还指明其父进程、子进程以及拥有该进程的用户。</li><li>内部标识符：方便系统使用进程，仅能标识进程。</li></ul></li><li>处理机状态。用于在进程切换时保存处理机中各个寄存器的内容。以便在该进程重新调度时能再从断点执行。</li><li>进程调度信息。<ul><li>进程状态：指明进程的状态，方便进程调度和对换时的依据。</li><li>进程优先级：进程优先级高的更容易获得处理机。</li><li>进程调度所需信息：保存的内容和进程调度算法有关，如进程等待了多久CPU，使用了多长CPU。</li><li>事件：进程因何由执行状态转变为阻塞状态，即阻塞原因。</li></ul></li><li>进程控制信息。<ul><li>程序和数据的地址。</li><li>进程同步的通信机制。</li><li>资源清单。进程已分配到的除处理机之外的资源。</li><li>链接指针。用于指向下一个PCB的首地址。用于进程调度。</li></ul></li></ul><p><br></p><h3 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h3><ul><li>线性方式：所有的PCB都保存在一张表中，每次寻找PCB都在表中查找。效率低。</li><li>链接方式：把具有相同状态的PCB链接起来。</li><li>索引方式：把具有相同状态的PCB保存在相应的表中。<div align="center"><img src="http://blogfileqiniu.isjinhao.site/3094cb7a-bffa-4d13-8d8a-9e6458c2098b"></div></li></ul><p><br></p><h2 id="OS内核"><a href="#OS内核" class="headerlink" title="OS内核"></a>OS内核</h2><h3 id="系统态-amp-用户态"><a href="#系统态-amp-用户态" class="headerlink" title="系统态 &amp; 用户态"></a>系统态 &amp; 用户态</h3><p>对于处理机来说，根据其执行的指令不同，可以将其分成系统态（管态、内核态）和用户态。处理机处于系统态时可以执行任意的指令，访问所有的寄存器和存储区，而处于用户态的时候会受到相应的限制。所以计算机中的程序可以分成系统程序和用户程序，用户程序运行在用户态，这样就可以防止用户程序对操作系统进行破坏。</p><p><br></p><h3 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h3><p>操作系统把CPU指令分成两类：</p><ul><li>特权指令：在系统态执行的指令。执行几乎不受限制，如启动外部设备、设置系统时钟等。</li><li>非特权指令：在用户态执行的指令。限制较多，比如不能操作硬件等。</li></ul><p><br></p><h3 id="内核概念"><a href="#内核概念" class="headerlink" title="内核概念"></a>内核概念</h3><p>现代操作系统采用分层设计模式，不同权重的程序分别设置在不同的层次中。通常与<strong>硬件紧密相关的程序</strong>、<strong>设备驱动程序</strong>和<strong>运行频率高的程序</strong>等放置在高级别层次中，操作系统会将它们常驻内存，这些程序便被称为OS内核。OS内核运行在系统态中。</p><h4 id="内核的功能"><a href="#内核的功能" class="headerlink" title="内核的功能"></a>内核的功能</h4><p>不同操作系统的内核在功能上有一定的差异，但是一般都包含两类功能：</p><ul><li>支撑功能<ul><li>中断处理：是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，且处理完毕后又返回原被暂停的程序继续运行。人机交互、设备驱动和进程调度等都需要依赖中断处理。</li><li>时钟管理：系统中很多活动都需要用到时钟，如定时任务、时间片轮转调度算法等。</li><li>原语操作：原语是若干条机器指令构成的，用以完成特定功能的一段程序。而原语操作便是原语的执行，其在执行期间是不可分割的。</li></ul></li><li>资源管理功能<ul><li>进程管理：进程的创建、撤销、调度等操作。</li><li>存储器管理：空间的分配、撤销、逻辑地址转换为物理地址等。</li><li>设备管理：进行设备分配、缓和CPU和I/O速度不匹配矛盾的缓冲管理等。</li></ul></li></ul><p><br></p><h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><ol><li>为新进程申请内部标识符，同时从PCB集合中索取一个空白的PCB。</li><li>为新进程分配其运行所需的资源。这些资源直接来自操作系统或者父进程。</li><li>初始化PCB。如处理机状态信息、标识符和进程优先级等。</li><li>若就绪队列还能接受进程，则插入就绪队列。不能接受则执行相应处理机制。</li></ol><p><br></p><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><ol><li>从PCB集合中获得某进程的PCB，并读出该进程的状态。<ul><li>若进程正处于执行状态，应立即终止该进程的执行。</li><li>若此进程有子进程则一并终止，防止其成为不可控进程。</li></ul></li><li>将进程拥有的所有资源归还给其父进程或操作系统。</li><li>将被终止的进程从所在队列或链表（指PCB的组织方式）中移出，等待其他程序收集信息，释放空间等。</li></ol><p><br></p><h3 id="三种基本状态"><a href="#三种基本状态" class="headerlink" title="三种基本状态"></a>三种基本状态</h3><ul><li>就绪状态：分配到出处理机之外的其他所有必要资源。此时可运行，但其他进程正在占用CPU。</li><li>执行状态：就绪状态的进程获得CPU，正在执行的状态。</li><li>阻塞状态：进程发出的请求没有及时得到满足而无法继续执行的状态，此时会引起进程调度，OS把处理机分配给其他就绪进程，原进程暂停。<div align="center"><img src="http://blogfileqiniu.isjinhao.site/f044ec2c-345b-430b-bd6d-8e84ce65d839"></div></li></ul><p><br></p><h3 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h3><p>进程暂停执行或不接受调度的状态。原因有如下几点：</p><ul><li>用户的需要：用户想暂停正在的进程，观察其状态或修改程序等。</li><li>父进程请求：父进程为了完成某项任务，协调其各子进程间的活动。</li><li>负荷调节的需要：系统压力过大或实时操作系统不能很好的满足可靠性时会挂起一些进程。</li><li>操作系统的需要：操作系统挂起某些进程来更方便的检查系统资源。<br>挂起和阻塞不同在于阻塞是客观条件不能得到满足，即资源不足引起暂停。挂起是主观需要引起暂停。<div align="center"><img src="http://blogfileqiniu.isjinhao.site/e1bf9eb8-939f-4235-b97d-6f9ffcaecd1e"></div></li></ul><p><br></p><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a><span id="jump">进程同步</span></h2><p>进程同步的主要任务是使并发执行的诸进程之间能有效的共享资源和相互合作，从而使程序的执行具有可再现性。</p><p><br></p><h3 id="同步-amp-互斥"><a href="#同步-amp-互斥" class="headerlink" title="同步 &amp; 互斥"></a>同步 &amp; 互斥</h3><p>并发执行的诸进程之间既有独立性又有制约性。</p><ul><li>独立性：各进程都可独立地向前推进；</li><li>制约性：由于资源共享和进程合作引起的进程之间的相互依赖和相互制约的关系。可归结为互斥和同步。<ul><li>同步：两个或多个事件的发生有着某种时序上的关系。按照这种时序关系进行能保证各任务安全的完成。</li><li>互斥：资源的使用要排它使用，防止冲突（不同时使用，但无先后次序。一种特殊同步）。</li></ul></li></ul><p><br></p><h3 id="临界资源-amp-临界区"><a href="#临界资源-amp-临界区" class="headerlink" title="临界资源 &amp; 临界区"></a>临界资源 &amp; 临界区</h3><ul><li>临界资源：需要被各进程互斥访问的资源。</li><li>临界区：各进程中访问临界资源的代码。<br>若能保证各进程互斥地进入自己的临界区，便可以保证互斥地访问临界资源，进而保证进程同步。常用的方式有硬件同步机制和信号量机制。</li></ul><p><br></p><h3 id="同步准则"><a href="#同步准则" class="headerlink" title="同步准则"></a>同步准则</h3><ul><li>空闲让进：当无进程处于临界区时，应当允许一个进程进入自己的临界区。</li><li>忙则等待：当有进程处于临界区时其他请求就如临界区的进程必须等待。</li><li>有限等待：对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区。</li><li>让权等待：当进程不能进入临界区时，应立即释放处理机避免进程陷入“忙等”的状态。</li></ul><p><br></p><h2 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h2><h3 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h3><p>当进程在临界区执行期间，计算机系统不响应中断，因此不会引发调度，临界资源只会被一个进程占据，这样就不会发生进程同步问题。</p><p><br></p><h3 id="利用Test-and-Set指令实现互斥"><a href="#利用Test-and-Set指令实现互斥" class="headerlink" title="利用Test-and-Set指令实现互斥"></a>利用Test-and-Set指令实现互斥</h3><p>指令的描述如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TS</span><span class="params">(boolean *lock)</span></span>&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>为临界资源设置一个布尔变量<code>lock = false</code>。在进程进入临界区之前利用TS指令测试，如果得到的值为<code>false</code>表示资源未被使用，如果得到的值为<code>true</code>，则一直测试到结果为<code>false</code>。使用TS指令实现互斥描述如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (TS(&amp;lock));</span><br><span class="line">...</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="利用Swap指令实现互斥"><a href="#利用Swap指令实现互斥" class="headerlink" title="利用Swap指令实现互斥"></a>利用Swap指令实现互斥</h3><p>指令描述如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(boolean *a, boolean *b)</span></span>&#123;</span><br><span class="line">    boolean temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>为每个临界资源设置一个全局变量<code>lock=false</code>。每个进程设置一个局部变量<code>key</code>。实现互斥的描述如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">...</span><br><span class="line">    key = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        swap(&amp;lock, &amp;key);</span><br><span class="line">    &#125;<span class="keyword">while</span>(key != <span class="literal">false</span>)</span><br><span class="line">    critical section;</span><br><span class="line">    lock = <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>关中断：效率低下且不适用于多处理机系统。且其他进行会”忙等“，不符合让权等待。</li><li>TS指令 &amp; Swap指令：其他进行会”忙等“，不符合让权等待。</li></ul><p><br></p><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p>整型信号量是一个用于描述资源数目的整型量（S）。但除了初始化以外，仅能通过两个原子操作来访问。</p><ul><li><p>wait(S)：P操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wait(S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>);</span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>signal(S)：V操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S)&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>P操作用于分配资源，V操作用于释放资源。</p><p><br></p><h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>整型信号量未遵循让权等待原则。只要<code>S &lt;= 0</code>就会不断的循环。此时需要增加一个进程链表指针链接等待进程。</p><ul><li><p>数据结构的描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;<span class="comment">// 资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process_control_block</span> *<span class="title">list</span>;</span><span class="comment">// 阻塞队列</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure></li><li><p>wait(S)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    if(S-&gt;value &lt; 0)</span><br><span class="line">    block(S-&gt;list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>signal(S)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">signal(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">    wakeup(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当进程被阻塞时会被加入阻塞对列，资源被满足时唤醒阻塞对列中的某个资源。</p><p><br></p><h3 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h3><p>记录型信号量只能解决共享一个临界资源的情况，若有多个临界资源则需要使用多个记录型信号量。但是信号量越多，系统死锁的概率越大，且大量的同步操作会给系统的管理带来麻烦。AND型信号量的思想是一次性分配进程所需的全部资源，如果有一个没有分配成功，则其他所有可能为之分配的资源亦不分配。</p><ul><li><p>Swait(S)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1, S2, ..., Sn) &#123;</span><br><span class="line">    <span class="keyword">if</span>(Si &gt;= <span class="number">1</span> &amp;&amp; ... &amp;&amp; Sn &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            Si--;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 把进程阻塞在请求第一次未能得到满足的资源Si所对应的阻塞队列里，同时把进程的程序计数器</span></span><br><span class="line">        <span class="comment">// （放置CPU下一条要执行的指令地址）放置在本操作的开始处（下一次再调度到此进程，需要再次</span></span><br><span class="line">        <span class="comment">// 检查所有的资源）。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Ssignal(S)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ssignal(S1, S2, ..., Sn) &#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        Si++;</span><br><span class="line">        <span class="comment">// 唤醒等待Si资源的阻塞队列。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h3><p>之前的信号量都是一次申请或释放某资源一份，若申请或释放N份资源需要进行N次操作，效率比较低下。此外，当资源数量低于某一下限值时，为了系统安全，就不能再予以分配。所以产生信号量集解决以上问题。描述如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1, t1, d1, ..., Sn, tn, dn)&#123;</span><br><span class="line">    <span class="keyword">if</span> (S1 &gt;= t1 &amp;&amp; ... &amp;&amp; Sn &gt;= tn)</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            Si -= di;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 把进程阻塞在请求第一次未能得到满足的资源Si所对应的阻塞队列里，同时把进程的程序计数器</span></span><br><span class="line">        <span class="comment">// （放置CPU下一条要执行的指令地址）放置在本操作的开始处（下一次再调度到此进程，需要再次</span></span><br><span class="line">        <span class="comment">// 检查所有的资源）。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里有个问题，就是 Si &gt; ti 之后，能保证Si &gt; di吗？我个人的理解是di和ti的资源量是动态的，比如di为4，</span></span><br><span class="line"><span class="comment">// 原始ti为2，那程序在运行到Swait之前，si会被修改为6。</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Ssignal(S1, S2, ..., Sn) &#123;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        Si += di;</span><br><span class="line">        <span class="comment">// 唤醒等待Si资源的阻塞队列。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>特殊的信号量集</strong></p><ul><li><code>Swait(S1, d, d)</code>：每次申请d份资源，资源少于d时不分配。</li><li><code>Swait(S, 1, 1)</code>：退化成一般的记录型信号量。</li><li><code>Swait(S, 1, 0)</code>：<code>S &gt;= 1</code>时运行多个进行进入特定区。<code>S &lt;= 0</code>时禁止进程进入特定区。</li></ul><p><br></p><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>直接使用信号量机制会把大量的同步操作分散在各个进程中，这会增加系统死锁的概率并且不方便系统的管理。而管程就是把代表共享资源的数据结构和对共享数据结构的操作（包括同步机制）封装起来以更好的为进程使用。这时所有请求访问共享资源的进程都只能通过管程间接访问，同时管程每次只允许一个进程进入管程。<br>此时的管程可以使用面相对象的操作来完成整型信号量的功能。但是此时无法解决“让权等待”的问题，所以再按照面相对象的思想将<code>block</code>和<code>wakeup</code>操作封装起来来解决这个问题，即构成条件变量。条件变量的操作如下：</p><ul><li><code>condition.wait()</code>：使进程在因某条件不能满足时阻塞在其所对应的条件变量上。</li><li><code>condition.signal()</code>：唤醒因某条件不能满足而阻塞的进程。<br>可以很容易看出来，设置不同的条件变量能使由不同原因等待的进程阻塞在不同的队列中。使用时把<code>signal()</code>操作放在函数/过程的最后，这样保证在唤醒其他进程后本进程能直接退出而不再产生冲突。</li></ul><p><strong>管程的描述如下：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、局部数据和条件变量组成管程内的数据结构。</span></span><br><span class="line"><span class="comment">2、过程/函数1~过程/函数k组成管程内的一组过程对管程内的数据结构进行操作。</span></span><br><span class="line"><span class="comment">3、初始化代码：对管程内的数据结构进行初始化。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Monitor monitor_name&#123;</span><br><span class="line">    share variable declartions; <span class="comment">//共享变量说明</span></span><br><span class="line">    condition declarations;<span class="comment">//条件变量说明</span></span><br><span class="line">    &#123;<span class="comment">//管程主体</span></span><br><span class="line">        initialization code;    <span class="comment">//初始化代码</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//能被进程调用的过程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pn</span><span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="信号量的应用"><a href="#信号量的应用" class="headerlink" title="信号量的应用"></a>信号量的应用</h2><h3 id="互斥访问资源"><a href="#互斥访问资源" class="headerlink" title="互斥访问资源"></a>互斥访问资源</h3><p>设某共享资源的信号量是<code>mutex</code>，PA和PB进程并发时需互斥访问。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">PA()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">        wait(mutex);</span><br><span class="line">        ...</span><br><span class="line">        signal(mutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">PB()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        wait(mutex);</span><br><span class="line">        ...</span><br><span class="line">        signal(mutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="利用信号量实现前趋关系"><a href="#利用信号量实现前趋关系" class="headerlink" title="利用信号量实现前趋关系"></a>利用信号量实现前趋关系</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e6058fc8-cf80-40ae-bec9-123125d36b92"></div><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">P1（）&#123;...V(f1);V(f1);V(f1);&#125;</span><br><span class="line">P2（）&#123;P(f1)；... V(f2);&#125;</span><br><span class="line">P3（）&#123;P(f1)；... V(f3);&#125;</span><br><span class="line">P4（）&#123;P(f1)；... V(f4);&#125;</span><br><span class="line">P5（）&#123;P(f2)；... V(f5);&#125;</span><br><span class="line">P6（）&#123;P(f3);P(f4);P(f5);...;&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    semaphore f1=f2=f3=f4=f5=<span class="number">0</span>；</span><br><span class="line">    Cobegin</span><br><span class="line">    P1(); P2();P3(); P4();P5(); P6();</span><br><span class="line">    Coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>在并发时，如果<code>P1</code>的功能代码未执行完，<code>f1</code>为0，每次对<code>f1</code>进行V操作能使<code>P2</code>、<code>P3</code>、<code>P4</code>运行一个。其他亦然。<br><br><br><br>### 生产者—消费者问题<br><br><br><strong>问题描述</strong><br><br>多个生产者进程生产产品以供多个消费者消费。通过由n个环形缓冲区构成的缓冲池（循环队列），把多个生产者和多个消费者联系起来。不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未取走的缓冲区中投放产品。<br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/f23286c5-6773-4bd1-9e94-fc96dc382ed3"></div><p><strong>分析</strong></p><ul><li>任何时刻，只能有一个进程在缓冲区中操作。</li><li>对于“生产者”而言，缓冲区满则应等待。</li><li>对于“消费者”而言，缓冲区空则应等待。</li></ul><p><strong>利用记录型信号量解决问题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;<span class="comment">// in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。</span></span><br><span class="line">item buffer[n];<span class="comment">// 缓存区大小为n，地址为[0, n-1]。</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;<span class="comment">// mutex用于互斥访问缓存区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        produce an item nextproducer;</span><br><span class="line">        ...</span><br><span class="line">        wait(empty);<span class="comment">//消耗一个empty，当empty&lt;=0时等待</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        buffer[in] = nextproducer;</span><br><span class="line">        in = (in+<span class="number">1</span>) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(full);<span class="comment">//增加一个full</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(full);<span class="comment">//消耗一个full，当full&lt;=0时等待</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        nextconsumer = buffer[out];</span><br><span class="line">        out = (out+<span class="number">1</span>) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);<span class="comment">//增加一个empty</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        produce();consumer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>互斥信号量 &amp; 资源信号量</strong></p><p>互斥使用的资源设置一个互斥信号量，资源数为1。资源信号量的资源数和资源的意义有关。资源信号量的资源为1时退化成互斥信号量。<br>在使用时互斥信号量的P操作需要紧邻其对应共享资源的临界区使用，否则可能造成同步问题。比如互换上面代码的第8行和第9行之后，若生产者进程和消费者进程都只有一个，且生产者通过了<code>P(mutex)</code>，阻塞在<code>P(empty)</code>，消费者通过了<code>P(full)</code>，阻塞在<code>P(mutex)</code>，此时生产者等待消费者的<code>V(empty)</code>，消费者等待生产者的<code>V(mutex)</code>，发生死锁。而V操作不需要注意顺序。</p><p><strong>利用AND型信号量解决问题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;<span class="comment">//in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。</span></span><br><span class="line">item buffer[n];<span class="comment">//缓存区大小为n，地址为[0, n-1]。</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;<span class="comment">//mutex用于互斥访问缓存区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        produce an item nextproducer;</span><br><span class="line">        ...</span><br><span class="line">        Swait(empty, mutex);<span class="comment">//消耗一个empty，当empty&lt;=0时等待</span></span><br><span class="line">        buffer[in] = nextproducer;</span><br><span class="line">        in = (in+<span class="number">1</span>) % n;</span><br><span class="line">        signal(empty, mutex);<span class="comment">//增加一个full</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(full, mutex);<span class="comment">//消耗一个full，当full&lt;=0时等待</span></span><br><span class="line">        nextconsumer = buffer[out];</span><br><span class="line">        out = (out+<span class="number">1</span>) % n;</span><br><span class="line">        signal(full, mutex);<span class="comment">//增加一个empty</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        produce();consumer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>利用管程解决问题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Monitor monitor&#123;</span><br><span class="line">    item buffer[n];</span><br><span class="line">    <span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    condition notfull, notempty;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">static</span> <span class="title">put</span><span class="params">(item x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= n)</span><br><span class="line">            cwait(notfull);<span class="comment">//阻塞在队列满的条件下</span></span><br><span class="line">            buffer[in] = x;</span><br><span class="line">            in = (in+<span class="number">1</span>) % n;</span><br><span class="line">            count++;</span><br><span class="line">            csignal(notempty);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="keyword">static</span> <span class="title">get</span><span class="params">(item &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count &lt;= <span class="number">0</span>)</span><br><span class="line">                cwait(notempty);<span class="comment">//阻塞在队列空的条件下</span></span><br><span class="line">            x = buffer[out];</span><br><span class="line">            out = (out+<span class="number">1</span>) % n;</span><br><span class="line">            count--;</span><br><span class="line">            csignal(notfull);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    item x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        produce an item in nextproducer;</span><br><span class="line">        monitor.put(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    item x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        monitor.get(x);</span><br><span class="line">        consume the item in nextconsumer;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        produce();consumer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><p><strong>问题描述</strong></p><p>五个哲学家坐在圆桌前，每人一份饭，每个哲学家两侧各有一支筷子,只有拿到左右两只筷子才能进餐，哲学家处于吃饭和思考两种状态。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/61be3b33-61a2-4e94-b617-a00e297a83aa"></div><p><strong>分析</strong></p><ul><li>同一时刻一只筷子只能有一个哲学家拿起。</li><li>只有获得两个筷子后才能进餐。</li><li>如果每个哲学家都拿起一只筷子，都饿死。</li><li>并行程度：五只筷子允许两人同时进餐。</li></ul><p><strong>利用AND型信号量解决问题</strong></p><p>每次必须拿到两只筷子才能拿起，否则不拿起筷子。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Swait(chopstick[i], chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    ...</span><br><span class="line">    Ssignal(chopstick[i], chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><p><strong>问题描述</strong></p><ul><li>写者向共享数据区放数据，读者从共享数据区读数据。</li><li>多个读者可同时读取数据，多个写者不能同时写数据。<div align="center"><img src="http://blogfileqiniu.isjinhao.site/b63a44fd-5493-49d5-9586-30d2cd091a55"></div></li></ul><p><strong>分析</strong></p><ul><li>读者进入共享数据区，写者必须等待。</li><li>读者进入共享数据区，读者可以进入。</li><li>写者进入共享数据区，读者必须等待。</li></ul><p><strong>利用记录型信号量解决问题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore readmutex = <span class="number">1</span>, writemutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(readmutex);</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            wait(writemutex);</span><br><span class="line">        readcount++;</span><br><span class="line">        signal(readmutex);</span><br><span class="line">        ...<span class="comment">//read opreation</span></span><br><span class="line">        wait(readmutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            signal(writemutex);</span><br><span class="line">        signal(readmutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(writemutex);<span class="comment">//当写者进入共享数据区，reader会阻塞在</span></span><br><span class="line">        ... <span class="comment">//write operation</span></span><br><span class="line">        signal(writemutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        reader();writer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码分析</strong></p><p>最开始并发的时候：</p><ul><li>假如读者先抢到资源，<code>readcount == 0</code>，<code>P(writemutex)</code>，<code>writer()</code>会阻塞在第20行，但其他<code>reader()</code>仍可以运行，只是不会再<code>P(writemutex)</code>。同时每个<code>reader()</code>都<code>readcount++</code>，直到<code>readcount == 0</code>时<code>V(writemutex)</code>，然后<code>writer()</code>才有可能能进入。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。</li><li>假如写者先抢到资源，<code>P(writemutex)</code>，此时<code>readcount == 0</code>，所有<code>reader()</code>阻塞在第7行。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。<br>综上，完成了要求。</li></ul><p><br></p><h3 id="读者-写者问题拓展"><a href="#读者-写者问题拓展" class="headerlink" title="读者-写者问题拓展"></a>读者-写者问题拓展</h3><p><strong>问题描述</strong></p><ul><li>拓展就是又增加一个条件，最多只允许RN个读者同时读。</li></ul><p><strong>利用信号量集解决问题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">semaphore L = RN, mx = <span class="number">1</span>;<span class="comment">//L用来控制访问数，mx控制写者访问时所有读者阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        Swait(L, <span class="number">1</span>, <span class="number">1</span>);<span class="comment">//第RN+1个读者进入时会阻塞</span></span><br><span class="line">        Swait(mx, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//mx &gt;= 1时才可以进入</span></span><br><span class="line">        ...<span class="comment">//read operation</span></span><br><span class="line">        Ssignal(L, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        Swait(mx, <span class="number">1</span>, <span class="number">1</span>; L, RN, <span class="number">0</span>);<span class="comment">//mx &gt;= 1 &amp;&amp; L &gt;= RN时进入</span></span><br><span class="line">        ...<span class="comment">//write operation</span></span><br><span class="line">        Ssignal(mx, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        reader();writer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码分析</strong></p><p>最开始并发的时候：</p><ul><li>假如读者先抢到资源，<code>L = L - 1</code>，写者阻塞在第12行，但其他<code>reader()</code>仍可以运行，直至没有读者进程在访问共享数据区。当所有的读者进程都退出时，共享数据区中停留的个进程数都为0，即重新开始。</li><li>假如写者先抢到资源，<code>mx = mx - 1</code>，所有读者进程和其他写者进程都要被阻塞，写者进程退出时，共享数据区中停留的个进程数都为0，即重新开始。</li></ul><p><br></p><h3 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h3><p><strong>问题描述</strong></p><p>一把理发椅，N把等待座位。理发师为理发椅上的顾客理发，没有顾客就在理发椅上睡觉，有一个顾客时需要叫醒理发师，多个顾客时需要在等待座位上等候。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/2b2ae3cd-36cf-4a84-a300-a0854dc51275"></div><p><strong>分析</strong></p><ul><li>理发椅上只能有一位顾客。</li><li>等待座位是有限缓冲区。</li><li>只要存在顾客，理发师就不能睡觉。</li></ul><p><strong>利用记录型信号量解决问题</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semaphore customer = <span class="number">0</span>, barber = <span class="number">0</span>, mutex = <span class="number">1</span>; <span class="comment">//barber使理发师只能为一个顾客服务</span></span><br><span class="line"><span class="keyword">int</span> waiting = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">barber</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(customer);<span class="comment">//没有顾客的时候理发师睡觉</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        waiting –= <span class="number">1</span>;<span class="comment">//等待的人少一个</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(barber);</span><br><span class="line">        ...<span class="comment">//获得被激活进程的信息并给相应的顾客剪发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    wait(mutex);</span><br><span class="line">    <span class="keyword">if</span>(waiting &lt; CHAIRS)&#123;<span class="comment">//顾客到来的时候，还有座位就进去等待</span></span><br><span class="line">        waiting += <span class="number">1</span>;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(customer);</span><br><span class="line">        wait(barber);</span><br><span class="line">        ...  <span class="comment">//将被激活进程的信息发送给barber()</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        signal(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>代码分析</strong></p><p>在最开始并发的时候<code>barber()</code>会等待到有顾客时才醒来。顾客一来就需要访问<code>waiting</code>，所以获得<code>mutex</code>。</p><ul><li>如果位置不够就立即释放<code>mutex</code>。</li><li>如果位置够，就让等待的人加1，再释放<code>mutex</code>。然后顾客人数<code>customer += 1</code>来激活理发师进程。理发师进程激活后会<code>V(barber)</code>，然后等待着的<code>customer()</code>进程争夺资源，争夺到<code>P(barber)</code>的进程将被激活进程的信息发送给<code>barber()</code>，<code>barber()</code>获得被激活进程的信息并给相应的顾客剪发。</li></ul><p><br></p><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程之间合作完成工作不仅仅需要有时序关系，还需要进程信息交互，比如刚才的理发师问题中就设计到了信息交互。从概念上说进程通信是指进程之间的信息交换，所以信号量机制本身就涉及到了信息交换，不过我们把这种信息交换叫做低级进程通信，因为其效率低且需要用户大量的干预。真正的进程通信需要满足使用方便且能高效传输大量数据的需求。</p><p><br></p><h3 id="共享存储器系统"><a href="#共享存储器系统" class="headerlink" title="共享存储器系统"></a>共享存储器系统</h3><ul><li>基于共享数据结构的通信方式：诸进程公用某些数据结构来实现进行通信 ，如生产者—消费者问题中的有界缓冲区，属于低级通信方式。</li><li>基于共享存储区的通信方式：在存储器中划出一块共享存储区，诸进程通过对共享存储区中数据的读或写实现通信，此时数据的形式、位置和访问控制仍是进程实现。适用于传输大量数据，属于高级通信。</li></ul><p><br></p><h3 id="管道通信系统"><a href="#管道通信系统" class="headerlink" title="管道通信系统"></a>管道通信系统</h3><p>所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件。向管道提供输入的发送进程（即写进程）以字符流形式将大量的数据送入管道，而接收进程（即读进程），可从管道中接收数据。管道通信系统必须满足以下三个要求：</p><ul><li>互斥：管道的使用必须互斥。因为存数据和取数据可归于写文件的添加和删除。</li><li>同步：写进程把一定数量的数据写入管道后去睡眠，读进程读完后将其唤醒。读进程读空的管道时需要睡眠。</li><li>确定对方存在：如果写进程不存在，读进程就会一直等待。如果读进程不存在，写进程写完数据后也会一直等待，所以通信双方必须同时存在。</li></ul><p><br></p><h3 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a>消息传递系统</h3><p>指进程可以利用一组通信命令（原语）把数据封装在消息中传送，不需要显示的指定共享存储区或数据结构等。它隐藏了通信的细节，也是目前使用最广泛的进程间通信机制。通常有两种实现方式：</p><ul><li>直接通信方式：OS提供原语给进程使用。</li><li>间接通信方式：借助共享中间实体（称为邮箱）完成进程间的通信。<ul><li>和共享存储器系统的区别是进程不再需要指定数据的形式、位置和访问控制等，信箱内部自有实现。</li></ul></li></ul><p><br></p><h3 id="客户机-服务器系统"><a href="#客户机-服务器系统" class="headerlink" title="客户机-服务器系统"></a>客户机-服务器系统</h3><p>前三种都是单机下的通信机制，这种是网络环境中的通信机制。主要有套接字和RPC两种方式。</p><ul><li>套接字：一个套接字是一个通信标识类型的数据结构，包含了通信目的地址、通信端口号、通信的网络协议、进程自身的地址以及对外提供的系统调用等。使用套接字可以在不同主机上的进程建立连接进而进行通信。</li><li>RPC：Remote Procedure Call，它是一个通信协议，可以使本地进程调用其他主机的进程对程序员表现为常规方法调用。<div align="center"><img src="http://blogfileqiniu.isjinhao.site/44d61e32-6054-4fdd-9bb2-6c911e4720c6"></div></li></ul><p><br></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的由来"><a href="#线程的由来" class="headerlink" title="线程的由来"></a>线程的由来</h3><p>进程解决了程序不能并发执行的问题，但是由于进程是拥有资源的基本单位，所以在创建、撤销和切换时所需的时空开销很大，因为处理机势必要付出更大的代价来保存现场。所以把拥有资源和独立运行两项功能分开，让线程作为独立运行的基本单位，进程作为拥有资源的基本单位。不过线程也拥有一些能保证其独立运行的资源，如TCB。</p><p><br></p><h3 id="TCB（Thread-Control-Block）"><a href="#TCB（Thread-Control-Block）" class="headerlink" title="TCB（Thread Control Block）"></a>TCB（Thread Control Block）</h3><p>所有用于控制和管理线程的信息都会被记录在线程控制块中，通常包含：</p><ul><li>线程标识符：每个线程都有唯一的线程标识符。</li><li>处理机信息：包括程序计数器、状态寄存器、通用寄存器的内容。</li><li>线程运行状态：线程和进程一样也有多种运行状态，就绪、阻塞、运行等。详见<code>103-网络编程</code>。</li><li>优先级：和调度算法有关，优先级越高，得到处理机的机会越大。</li><li>线程专有存储区：用于在线程切换时保存现场状态和保存线程的统计信息。</li><li>信号屏蔽：屏蔽某些发送给线程的信号。</li><li>堆栈指针：线程调用别的过程时需要保存局部变量和返回地址等来供返回时能继续执行。</li></ul><p><br></p><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>线程是为了解决进程调度时过于笨重的问题，所以在不同的环境中实现线程的方式不同。根据内核能否感知到线程的存在可分为内核支持线程（Kernel Supported Threads，KST）和用户级线程（User Level Threads，ULT）。它俩的区别是能否直接调用系统服务，前者可以而后者需要借助中间系统。</p><p><br></p><h3 id="内核支持线程"><a href="#内核支持线程" class="headerlink" title="内核支持线程"></a>内核支持线程</h3><p>若线程是由内核直接调度，线程资源也是保存在内核空间，就可以说此类线程为内核支持线程。此类线程的创建、撤销和切换等操作都是在内核空间完成的，此时线程可以直接调用系统服务。一种可能的实现方式是在创建进程时分配一个任务数据区（Per Task Data Area，PTDA），各个线程的TCB保存在其中即可。不过仅实现内核支持线程的系统对用户进程创建的线程很不友好，每次线程调度处理机都要从用户态转换到核心态。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/cc3840cb-d3dd-4d60-a36d-d3663b3510ae"></div><p><br></p><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>用户级线程是指线程虽客观存在但对内核来说是透明的，此时不能再直接调用系统服务，间接调用系统服务需要有中间系统的支持，通常的中间系统有运行时系统和内核控制线程。</p><ul><li><p>运行时系统：把创建线程、撤销线程和线程同步等只能由OS内核完成的操作封装起来作为运行时系统，而运行时系统停留在用户空间供其他进程调用来实现线程调度。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/c1c7f79c-7ac9-4638-8b4c-ec81b238378f"></div></li><li>内核控制线程：这种线程又被称作轻量进程（Light Weight Process，LWP），它既可以共享进程的资源，又可以使用内核提供的服务。虽然下图中LWP和用户线程是1对1关系，但实际上多个用户级线程可以复用一个LWP，但每个轻型线程都要连接到一个内核线程中。所以此种方式系统需要同时实现内核支持线程。<div align="center"><img src="http://blogfileqiniu.isjinhao.site/1ef49c0f-824d-47e5-8511-67b5b12a0bae" width="80%"></div></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;进程概念&quot;&gt;&lt;a href=&quot;#进程概念&quot; class=&quot;headerlink&quot; title=&quot;进程概念&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>06.04-内存管理</title>
    <link href="https://isjinhao.github.io/posts/19078.html/"/>
    <id>https://isjinhao.github.io/posts/19078.html/</id>
    <published>2019-12-20T09:19:38.000Z</published>
    <updated>2019-12-20T09:29:23.875Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="存储器的层次"><a href="#存储器的层次" class="headerlink" title="存储器的层次"></a>存储器的层次</h2><p>我们都知道存储器的容量和速度是限制计算机发展的一大原因，人们对存储器的要求需要既快又大，但是这样带来的结果就是存储器的造价非常昂贵，所以不可能在计算机中全部配置既快又大的存储器。所以现代的计算机系统中都配置了多层结构的存储器系统来平衡速度差异问题。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/57187fc9-7345-44d6-af47-47ab8b2f4256"></div><p>存储器一般被分成六层，不过在只有前四层属于内存，所以此篇只介绍前四层。</p><p><strong>主存储器</strong></p><ul><li>用于保存进程运行时的程序和数据。</li><li>对于微机系统和大中型机，容量为数十MB到数GB；对于嵌入式系统，容量为数十KB到数MB。</li><li>CPU从主存读取指令和数据。</li><li>CPU与外设交换信息要依托主存。</li><li>为缓解CPU执行指令速度和主存访问速度的矛盾，引入寄存器和高速缓冲。</li></ul><p><strong>寄存器</strong></p><ul><li>访问速度做快，完全与CPU协调工作，价格十分昂贵，容量不可能很大。</li><li>长度一般以字为单位。</li><li>对于微机系统和大中型机，可能有几十个甚至上百个；对于嵌入式系统，仅有几个到几十个。</li></ul><p><strong>高速缓冲</strong></p><ul><li>容量大于或远大于寄存器，比内存小两到三个数量级左右，从几十KB到几MB。</li><li>访问速度快于主存。</li><li>将主存中经常访问的信息存放在高速缓冲，减少访问主存次数。</li></ul><p><strong>磁盘缓冲</strong></p><ul><li>将一部分频繁使用的磁盘数据和信息，暂时存放在磁盘缓冲中，减少访问磁盘次数。</li><li>不是实际存在的存储介质，利用主存的存储空间，暂存从磁盘读出或写入的信息。<br>总结一下：磁盘缓冲是为了解决内存和外存的速度差异而在内存中开辟的一块用于暂存磁盘数据的存储介质。主存储器是保存进程运行时的程序和数据的。寄存器是和CPU速度匹配的存储器，直接给CPU提供数据。虽然CPU是直接从寄存器去取指令和数据，但是寄存器的数据来源最终还是主存储器，所以为了减少访问CPU的次数，产生了高速缓冲来缓和寄存器和主存储器的矛盾。至于为什么能缓和呢？这是由于<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/15572003">程序局部性原理</a>。</li></ul><p><strong>程序局部性原理</strong></p><p>指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。 局部性原理又表现为：时间局部性和空间局部性。</p><ul><li>时间局部性：如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。</li><li>空间局部性：一旦程序访问了某个存储单元，则不久之后。其附近的存储单元也将被访问。<br>另外，根据程序的局部性理论，Denning提出了工作集理论。所谓工作集是指进程运行时被频繁访问的页面集合。显然我们知道只要使程序的工作集全部集中在内存中，就可以大大减少进程的缺页次数；否则会使进程在运行过程中频繁出现缺页中断，从而出现频繁的页面调入/调出现象，造成系统性能的下降，甚至出现“抖动”。<br>划分工作集可以按定长时间或定长页面两种方法进行划分。当颠簸现象发生时，说明系统的负荷过大，通常采用处理器均衡调度。另一种是控制缺页率，当缺页率达到上限时，则增加内存分配量；当缺页率达到下限时，就减少内存的分配量。</li></ul><p><br></p><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>用户程序要在系统中运行，必须将它装入内存，其中有三个过程。</p><ul><li>编译：由编译程序（Complier）将用户源代码编译成若干个目标模块（Object Module）；</li><li>链接：由链接程序（Linker）将编译后形成的目标模块以及它们所需要的库函数，链接在一起，形成一个装入模块（Load Module）；</li><li>装入：由装入程序(Loader)将装入模块装入内存。</li></ul><p><br></p><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接程序的功能是将经过编译后得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块。</p><h4 id="静态链接方式"><a href="#静态链接方式" class="headerlink" title="静态链接方式"></a>静态链接方式</h4><p>生成可执行文件时进行链接。主要有两步。</p><ol><li>修改相对地址。</li><li>变换外部调用符号。</li></ol><h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><p>目标模块是在装入内存时，边装入边链接的。装入时动态链接方式有以下优点：</p><ul><li>便于修改和更新。</li><li>便于实现对目标模块的共享。</li></ul><h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><p>将对某些模块的链接推迟到执行时才执行，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存， 把它链接到调用者模块上。<br>凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。</p><p><br></p><h3 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h3><p>装入是将一个具有执行资格的模块加载进内存。</p><h4 id="绝对装入方式"><a href="#绝对装入方式" class="headerlink" title="绝对装入方式"></a>绝对装入方式</h4><p>在可执行文件中指定内存地址，装入时直接定位在上述（即文件中记录的地址）内存地址。逻辑地址和物理地址完全相同。</p><h4 id="可重定位装入方式"><a href="#可重定位装入方式" class="headerlink" title="可重定位装入方式"></a>可重定位装入方式</h4><p>编译程序所生成的目标模块中采用逻辑地址，根据当前内存情况，将装入模块装入到适当位置。地址映射是在装入模块装入内存时一次性进行的，即是静态重定位。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/828b8bca-cc39-4f95-b638-ac687aed4c82"></div><h4 id="动态运行时装入方式"><a href="#动态运行时装入方式" class="headerlink" title="动态运行时装入方式"></a>动态运行时装入方式</h4><p>静态重定位时程序装入内存后不能移动，而且通常需要占用连续的内存空间。所以与其对应的动态重定位是将地址映射工作推迟到程序真正执行时才进行。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/0dd5a600-9e18-4e30-ac2b-4ed1ae698a76"></div><p><br></p><h3 id="现代计算机运行过程"><a href="#现代计算机运行过程" class="headerlink" title="现代计算机运行过程"></a>现代计算机运行过程</h3><ul><li>预处理<ul><li>把存储在不同文件中的源程序聚合在一起。</li><li>把被称为宏的缩写语句转换为原始语句。</li></ul></li><li>编译：将高级语言翻译成汇编语言或机器语言。</li><li>链接<ul><li>将多个可重定位的机器代码文件（包括库文件）连接到一起。</li><li>解决外部内存地址（一个文件中的代码会引用其他文件中的数据对象或过程，这些数据对象或过程的地址对于此文件来说就是外部地址）问题。</li></ul></li><li>装入<br>确定程序在内中的绝对地址（即修改程序起始地址），将修改后的指令和数据放到内存中适当的位置。</li></ul><p><br></p><h3 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h3><p>连续分配是指为一个用户程序分配空间的时候，将所有程序装入到一段连续的物理内存中。在早期（20世纪60-80<br>年代）的操作系统中，这种分配内存的方式曾经被广泛的使用。</p><h4 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h4><p>这是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。内存分为以下两个分区：系统区和用户区。操作系统使用系统区；应用程序装入到用户区，可使用用户区全部空间。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6832a4fb-0a2c-4580-9d61-53421c11028f"></div><h4 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h4><p>固定分区式分配，是最早使用的一种可运行多道程序的存储管理方式。它将内存空间划分为若干个固定大小的区域，每个分区大小可相同，也可不同。OS占一区，其余每个分区中可以装入一道作业。<br>为了便于内存分配，系统需建立一张分区使用表。当有一用户程序要装入时，从表中找出一个能满足要求的、尚未分配的分区分配给该程序，然后修改分区使用表。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/3dedf899-aaec-438b-8000-1697086bf1d5"></div><h4 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h4><p><strong>数据结构</strong></p><ul><li>空闲分区表<ul><li>每个空闲分区占用一个表项。</li><li>分区表的表项中包含分区号、分区始址及分区大小等表目。</li><li>表长不易确定。</li><li>占用额外内存。</li></ul></li><li>空闲分区链表<ul><li>利用各空闲分区自身的单元组成双向链表。</li><li>操作速度较慢。</li></ul></li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/50d0b9cb-d452-4651-be2f-ec582dcbf9a3"></div><p><strong>分区分配</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/f97ae2b8-f686-472d-b570-dd787528f453"></div><p><strong>分区回收</strong></p><ul><li>如果回收区的前后有空闲区，可分为图示三种情况。回收时将空闲区和回收区合并。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/903e731f-002e-47b0-8bd7-6a8fa4ece434"></div><ul><li>如果回收区的前后无空闲区，新建一个表项，填写信息插入。</li></ul><h4 id="分区检索算法"><a href="#分区检索算法" class="headerlink" title="分区检索算法"></a>分区检索算法</h4><p><strong>顺序检索算法</strong></p><ul><li>首次适应算法：按各空闲分区首址的升序的方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从头查找，找到符合要求的第一个分区。</li><li>循环首次适应算法：分配空闲空间时，不是从链首（或表头）开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找。</li><li>最佳适应算法：按空闲区大小的升序方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从<br>头查找，找到符合要求的第一个分区。就说明它是最适合的（即最佳的）。</li><li>最坏适应算法：按空闲区大小的降序方法组织，分配时总是取空闲分区表（或空闲分区链）中的第一项，<br>若大小不能满足申请者的要求，则表示系统中无满足要求的空闲区，分配失败；否则分配。</li></ul><p><strong>索引检索算法</strong></p><ul><li>快速适应算法：将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应一种空闲分区类型，并记录其表头指针。空闲分区的分类是根据进程常用的空间大小进行划分，对于其他大小的分区，可以放在一个特殊的空闲区链表中。</li><li>伙伴系统：分区大小均为2的K次幂。假设系统可利用空间容量为$2^m$个字，系统运行过程中，不断划分，将空闲分区根据大小分类。为长度为n的进程分配分区时，首先计算$i$值使得$2^{i-1}≦n≦2^i$。先找大小为$2^i$的分区分配，否则找大小为$2^{i+1}$的分区分配，把$2^{i+1}$分区分成两个$2^i$分区（互称伙伴），一个分配，另一个加入$2^i$的空闲分区链表。分配可能经过多次分割，回收可能进行多次合并。</li><li>哈希算法：根据空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最近分配策略。</li></ul><h4 id="紧凑"><a href="#紧凑" class="headerlink" title="紧凑"></a>紧凑</h4><p>可变式分区也有零头问题。在系统不断地分配和回收中，必定会出现一些不连续的小的空闲区，称为外零头。虽然可能所有零头的总和超过某一个作业的要求，但是由于不连续而无法分配。解决零头的方法是拼接（或称紧凑），即向一个方向（例如向低地址端）移动已分配的作业，使那些零散的小空闲区在另一方向连成一片。分区的拼接技术，一方面是要求能够对作业进行重定位，另一方面系统在拼接时要耗费较多的时间。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/14408d45-b0be-4d64-96a0-7dbca67e8a9c"></div><p><br></p><h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><strong>页面</strong></p><p>将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。</p><p><strong>物理块</strong></p><p>把内存空间分成与页面相同大小的若干个存储块，称为（物理）块或页框（frame）。</p><p><strong>页面碎片</strong></p><p>由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。</p><p><strong>页面大小</strong></p><p>每一页可进行编址的地址数目。页面大小应该满足2的n此幂。</p><ul><li>方便计算：如果要将（线性）地址转换为<code>page：offset</code>，则需要将地址除以页面大小，并将整数答案作为页面，将余数作为偏移量。 这是使用编程语言中的整数除法和模数运算符完成的。 计算机将地址表示为数字，存储为二进制位。 这是一个示例地址：<code>12</code>是二进制<code>1100</code>。 如果页面大小为<code>3</code>，那么我们需要计算<code>12/3</code>和<code>12%3</code>来查找页面和偏移量（分别为<code>4</code>、<code>0</code>）。 但是，如果页面大小为<code>4</code>（<code>2</code>的幂），则二进制中的<code>4</code>为<code>100</code>，此时使用特殊的“快捷方式”计算整数除法和模数：右移进行除法，按位与进行取模。所以： <code>12/4 == 12&gt;&gt;2</code>（右移两位） <code>12%4 == 12&amp;(4-1)</code>（<code>1100</code>和<code>11</code>按位与）。同时页面大小转为2进制可以使用左移，可以减小时间开销。</li><li>充分利用空间：如果页面大小不满足2的n次幂，假如是5，则页内偏移地址，采用2位则每页有一个地址不能使用，采用3位则<code>111</code>、<code>110</code>、<code>101</code>未被使用。怎么做都不能完全利用地址空间。</li></ul><p><strong>逻辑地址</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/59533072-5531-4107-b7c6-5f20e3bc7e61"></div><p><strong>页表</strong></p><p>系统为每个进程建一张页表，其在内存的起始地址和长度记录在该进程的PCB中。页表的每一行是一个页表项。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/afba25ae-a6a3-49e5-b02e-8232928d59bd"></div><p><strong>页表项长度</strong></p><p>每个页表项占用的编址个数。从逻辑地址那里我们可以看到页号占用了20位，对应的块号也要占用20位，当然块号本身可能不止$2^{20}$个。又由于为了控制对物理块的读写等操作，会在页表项中加上控制字段。如果内存按字节编址，即每个编址可以存储8个二进制位，那么页表项占用的二进制位总数大于内存的字长度。我们需要把一个页表项拆开存放在多个编址后的空间中。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a1fad94a-ee4e-4421-97e1-eb7004253ca0" style="width:80%"></div><p><br></p><h3 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h3><h4 id="普通地址变换"><a href="#普通地址变换" class="headerlink" title="普通地址变换"></a>普通地址变换</h4><div align="center"><img src="http://blogfileqiniu.isjinhao.site/7dac4487-37f0-436c-a5b6-7d59d47be7b6"></div><p>$物理地址=块号+块内地址=F(逻辑地址的页号*页表项长度+页表始址)+业内地址$。<br>每次进行地址变换需要访问两次内存，内存速度较慢，所以影响计算机整体性能。</p><h4 id="具有快表的地址变换"><a href="#具有快表的地址变换" class="headerlink" title="具有快表的地址变换"></a>具有快表的地址变换</h4><p>根据程序局部性原理，把最近使用的页表项存放在快表中，下次再进行地址变换时先去快表中查找对应项，如果没找到再去内存中查找，然后把新找到的页表项存放在快表中，如果快表已满，采用某种算法淘汰一份。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/4d110b83-5a36-468b-a971-57a6b99da83a"></div><h4 id="有效访问时间"><a href="#有效访问时间" class="headerlink" title="有效访问时间"></a>有效访问时间</h4><p>设t是访问内存的时间，a是快表命中率，λ是查找快表所需的时间。</p><ul><li>普通地址变换时间：<code>t+t</code></li><li>具有快表的地址变换时间：$ a \ast \lambda + (1-a) \ast (t+\lambda)$。</li></ul><h4 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h4><p>对于两级页表，是将页表再进行分页，页面的大小与内存物理块的大小相同。逻辑地址结构可描述如下：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/9be850db-8e21-4a1d-8dbe-4a8d76194017"></div><p><strong>两级页表地址变换</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/3ec51dd1-5b26-4d98-bfb5-18d567e4c164"></div><p>可推广至N级页表。</p><h4 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h4><p>页表是按每个进程的页号排序，指示出物理块号的位置，反置页表是按物理块号排序，指示出每个页隶属的进程和页号。<br>此方法需要为每个进程创建一个外部页表，即将页表建立在外存中。进程进行地址变换时先从反置页表里查找，如果查找不到则去外村中查找，再将查找到的页表项调入内存。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/3984a943-8925-44e0-b30d-b9aace27fe66"></div><p><br></p><h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><p>之前的分区管理都是为了更好的利用内存。为了满足程序员在编程上的要求引入了分段管理方式。</p><p><strong>方便编程</strong></p><p>通常，用户把自己的作业按照逻辑关系划分为若干个段，每个段都是从0开始编址，并有自己的名字和长度。因此，希望要访问的逻辑地址是由段名（段号）和段内偏移量（段内地址）决定的。例如，下述的两条指令便是使用段名和段内地址：其中，前一条指令的含义是将分段A中D单元内的值读入寄存器1；后一条指令的含义是将寄存器1的内容存入B分段的C单元中。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD 1，[A] |〈D〉；</span><br><span class="line">STORE 1，[B] |〈C〉；</span><br></pre></td></tr></table></figure><p></p><p><strong>信息共享</strong></p><p>在实现对程序和数据的共享时，是以信息的逻辑单位为基础的。比如，共享某个例程和函数。分页系统中的“页”只是存放信息的物理单位（块），并无完整的意义，不便于实现共享；然而段却是信息的逻辑单位。由此可知，为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适应。</p><p><strong>信息保护</strong></p><p>信息保护同样是对信息的逻辑单位进行保护，因此，分段管理方式能更有效和方便地实现信息保护功能。</p><p><strong>动态增长</strong></p><p>在实际应用中，往往有些段，特别是数据段，在使用过程中会不断地增长，而事先又无法确切地知道数据段会增长到多大。前述的其它几种存储管理方式，都难以应付这种动态增长的情况，而分段存储管理方式却能较好地解决这一问题。</p><p><strong>动态链接</strong></p><p>动态链接是指在作业运行之前，并不把几个目标程序段链接起来。要运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段（目标程序）调入内存并进行链接。可见，动态链接也要求以段作为管理的单位。</p><p><br></p><h3 id="分段地址"><a href="#分段地址" class="headerlink" title="分段地址"></a>分段地址</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/4a8347b6-2f86-4db6-99a4-7c8100267182"></div><h4 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h4><div align="center"><img src="http://blogfileqiniu.isjinhao.site/0d0640e3-74c5-4d3d-8541-171c13c8e495"></div><h4 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h4><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e9f3f706-b819-440d-b3a4-f69756e1b5f7"></div><h4 id="地址变换-1"><a href="#地址变换-1" class="headerlink" title="地址变换"></a>地址变换</h4><div align="center"><img src="http://blogfileqiniu.isjinhao.site/374a427d-4223-4e49-88e4-eb5563dd9fd4"></div><h4 id="分页和分段的主要区别"><a href="#分页和分段的主要区别" class="headerlink" title="分页和分段的主要区别"></a>分页和分段的主要区别</h4><ul><li>页是信息的物理单位，段则是信息的逻辑单位；</li><li>页的的大小固定且由系统决定，而段的长度不固定，由用户所编写的程序决定；</li><li>分页的地址空间是一维的，而分段的地址空间是二维的。</li><li>分页是系统管理的需要；分段是为了更好满足用户的需要。</li></ul><p><br></p><h2 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h2><p>分段结构具有逻辑上清晰的优点，但它的一个致命弱点是每个段必须占据主存储器的连续区域，于是，要装入一个分段时可能要移动已在主存储器中的信息，为了克服这个缺点，可兼用分段和分页的方法，构成段页式存储管理。每个作业仍按逻辑分段，但对每一段不是按单一的连续整体存放到存储器中，而是把每个段再分成若干个页面，每一段不必占据连续的主存空间，可把它按页存放在不连续的主存块中。</p><p><br></p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>逻辑地址空间分段，段内分页，内存分块（页框），存储管理的分配单位是：物理块（页框）</li><li>地址结构：段号，页号，页内偏移地址。</li><li>每个作业一张段表，每段一张页表。地址变换：先查段表，再查该段的页表。</li></ul><p><br></p><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/d4ab1762-e6c8-4a13-8eea-e841c471df50"></div><p><br></p><h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/aaacf025-9204-4019-9bdc-18399f121b3a"></div><p><br></p><h2 id="传统存储器的问题"><a href="#传统存储器的问题" class="headerlink" title="传统存储器的问题"></a>传统存储器的问题</h2><p>传统的内存管理方式要求将一个作业全部装入内存才可以运行，由此造成了以下两种情况：</p><ul><li>大作业对内存的要求超出物理内存总容量，致使其无法运行。</li><li>内存由于容量的限制，只能装入少量的作业使其运行，而其它大量作业留在外存。</li></ul><p><br></p><h3 id="解决原理"><a href="#解决原理" class="headerlink" title="解决原理"></a>解决原理</h3><h4 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h4><ol><li>程序执行时， 除了少部分的转移和过程调用指令外，在大多数情况下仍是顺序执行的。</li><li>过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域， 但经研究看出，过程调用的深度在大多数情况下都不超过5。</li><li>程序中存在许多循环结构， 这些虽然只由少数指令构成， 但是它们将多次执行。</li><li>程序中还包括许多对数据结构的处理， 如对数组进行操作， 它们往往都局限于很小的范围内。</li></ol><p><strong>表现两个方面</strong></p><ol><li>时间局限性。如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环。</li><li>空间局限性。一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</li></ol><p><strong>基于局部性原理</strong></p><p>在程序装入时，不必将其全部读入到内存，而只需将当前需要执行的部分页或段读入到内存，就可让程序开始执行。在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统，将相应的页或段调入到内存，然后继续执行程序。</p><p><br></p><h3 id="虚拟存储器定义"><a href="#虚拟存储器定义" class="headerlink" title="虚拟存储器定义"></a>虚拟存储器定义</h3><p>所谓虚拟存储器， 是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、 中、 小型机器和微型机中。</p><p><br></p><h3 id="实现虚拟存储器的条件"><a href="#实现虚拟存储器的条件" class="headerlink" title="实现虚拟存储器的条件"></a>实现虚拟存储器的条件</h3><p>由于一个作业被分成多次地调入内存运行，所以在内存分配时必须采用离散分配方式。同时需要解决以下问题：</p><ul><li>页表（段表）的设计（软件支持）</li><li>程序不在内存时去外存调度需要中断（硬件支持）</li><li>逻辑地址转换为物理地址（软件硬件支持）</li><li>如何给每个进程分配物理块</li><li>一个页（段）进入内存时，淘汰哪个页（段）</li></ul><p><br></p><h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>用于将用户逻辑地址空间变换为内存的物理地址空间。在页表中增加若干项，以便于标志程序或数据的状态。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/fa041bc8-d719-4aa7-9ba8-4baa6918ac91"></div><ul><li>状态位（存在位）P：表示该页是否调入内存。</li><li>访问字段A：用于记录该页在某段时间内被访问的次数。</li><li>修改位M：表示该页在调入内存后是否被修改过。未修改过不必写回外存，修改要写回外存。</li><li>外存地址：该页在外存上的地址，通常是物理块号。</li></ul><p><br></p><h3 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h3><ul><li>在地址映射过程中，在页表中发现所要访问的页不在内存，则产生缺页中断。操作系统接到此中断信号后，就调出缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使进程继续运行下去。</li><li>如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应页表项目的状态位及相应的内存块号。</li><li>若此时内存中没有空闲块，则要淘汰某页，若该页在内存期间被修改过，则要将其写回外存。</li><li>缺页中断发生在指令执行期间，而通常情况下，CPU是在一条指令执行完后，才检查是否有中断请求到达；一条指令在执行期间，可能产生多次缺页中断。所以硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处，继续执行。</li></ul><p><br></p><h3 id="地址转换机构"><a href="#地址转换机构" class="headerlink" title="地址转换机构"></a>地址转换机构</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/b164ab99-02d0-494b-bb7f-f787c2613fc0"></div><p><br></p><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="最小物理块数的确定"><a href="#最小物理块数的确定" class="headerlink" title="最小物理块数的确定"></a>最小物理块数的确定</h4><p>最小物理块数：保证进程正常运行所需的最小物理块数。与计算机的硬件机构有关，取决于指令的格式、功能和寻址方式。</p><h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p>在请求分页中，可采取两种分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置<br>换和局部置换（置换范围不同）。于是组合出三种适用的策略：</p><ul><li>固定分配局部置换：分配固定数目的内存空间，在整个运行期间都不改变。如果缺页，则先从该进程在内存的页面中选中一页，进行换出操作，然后再调入一页。</li><li>可变分配全局置换：每个进程预先分配一定数目的物理块，同时OS也保持一个空闲物理块队列。当缺页时，首先将对OS所占有的空闲块进行分配，从而增加了各进程的物理块数。当OS的空闲块全部用完，将引起换出操作。</li><li>可变分配局部置换：系统根据缺页率动态调整各进程占有的物理块数目，使其保持在一个较低的缺页率状态。</li></ul><h4 id="物理块分配算法"><a href="#物理块分配算法" class="headerlink" title="物理块分配算法"></a>物理块分配算法</h4><ul><li>平均分配算法：将系统中所有可供分配的物理块，平均分配给各个进程。</li><li>按比例分配算法：按照进程的大小比例分配物理块。</li><li>考虑优先权的分配算法：为了对于紧迫的作业，能够尽快完成。可以将内存的物理块分成两部分，一部分按照比例分配给各进程，另一部分根据进程优先级，适当增加其相应的份额，分配给各进程。</li></ul><p><br></p><h3 id="页面调入"><a href="#页面调入" class="headerlink" title="页面调入"></a>页面调入</h3><h4 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h4><ul><li>提前取页：预先装入主存一页或几页（提前页）。</li><li>请求取页：当用到某页而不在主存时即缺页时取页。</li></ul><h4 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h4><p>外存有两个部分：文件区和对换区。对换区I/O操作速度比文件区相对快一些，因此一般应当尽量使用对换区来调入页面。对于不同情况，采用不同的策略：</p><ul><li>系统有足够的对换空间：全部从对换区调入。</li><li>系统对换空间不足：未修改的从文件区调入，修改的从对换区调入。</li><li>UNIX的调入方式：未运行过的从文件区调入，运行过的放在对换区，允许页面共享。</li></ul><h4 id="页面调入过程"><a href="#页面调入过程" class="headerlink" title="页面调入过程"></a>页面调入过程</h4><ol><li>进程需要的页面不在内存，引起缺页中断</li><li>中断处理程序保留现场环境，转入缺页中断处理程序</li><li>中断处理程序查找页表，得到对应的外存物理块号。如果内存有空闲，则启动磁盘操作，将所缺的页面读入，并修改页表。否则，到4。</li><li>执行置换算法，选出要换出的页面，如果该页修改过，应将其写入磁盘，然后将所缺页调入内存，修改相应表项，将其存在位置为<code>1</code>，并放入快表。</li><li>利用修改后的页表，形成物理地址，访问内存数据。</li></ol><h4 id="缺页率"><a href="#缺页率" class="headerlink" title="缺页率"></a>缺页率</h4><ul><li>假设进程逻辑空间为n页，系统为其分配物理块数为<code>m</code>。</li><li>如果进程运行过程中，访问页面成功次数为S，访问页面失败次数为F，总页面访问次数<code>A=S+F</code>，则进程运行过程中 缺页率<code>f=F/A</code>。<br>影响缺页率的主要因素：</li><li>页面大小：页面越大，缺页率越小</li><li>进程所分配物理块数：物理块越多，缺页率越小</li><li>页面置换算法：合理的置换算法能更少将页面调入调出</li><li>程序固有特性：比如做循环操作时，缺页率较低，因为执行的命令都是一系列大致相同的指令。</li></ul><p><br></p><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h4><p>所选择的被淘汰页面，将是以后永不使用的， 或许是在最长（未来）时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。这是一种理想情况，是实际执行中无法预知的，因而不能实现。可用作性能评价的依据。<br>例：假定系统为某进程分配了三个物理块， 并考虑有以下的页面号引用串<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure><p></p><p>进程运行时， 先将7，0，1三个页面装入内存。 以后， 当进程要访问页面2时， 将会产生缺页中断。此时OS根据最佳置换算法， 将选择页面7予以淘汰。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/2979051c-7252-4c91-b6d5-2836841ad7be"></div><h4 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h4><p>选择装入最早的页面被置换。可以通过链表来表示各页的建立时间先后。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6c79128c-993d-4689-8b24-c0ed1222742a"></div><h4 id="最近最久未使用置换算法"><a href="#最近最久未使用置换算法" class="headerlink" title="最近最久未使用置换算法"></a>最近最久未使用置换算法</h4><p>选择内存中最久未使用的页面被置换。这是局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/f0576a05-7e3b-4c25-8f85-e23d186f6df5"></div><h5 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h5><p><strong>寄存器</strong></p><p>每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，于是寄存器数<br>值最小的是最久未使用页面。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/8781a6ff-ee5c-4bd5-8c39-72bafb68e249"></div><p><strong>栈</strong></p><p>一个特殊的栈，每当进程访问某页面时，便把被访问的页面移到栈顶，于是栈底的是最久未使用页面。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/deec2ffc-d896-4e78-bcaf-3f1d69815ac7"></div><h4 id="最少使用置换算法"><a href="#最少使用置换算法" class="headerlink" title="最少使用置换算法"></a>最少使用置换算法</h4><p>选择到当前时间为止被访问次数最少的页面被置换。</p><ul><li>实现方法1：每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，这样，在最近一段时间内时用最少的页面将是$\sum_{R_i}$最小的页。</li><li>实现方法2：每页设置访问计数器，每当页面被访问时，该页面的访问计数器加1；发生缺页中断时，淘汰计数值最小的页面，并将所有计数清零。</li></ul><h4 id="Clock置换算法"><a href="#Clock置换算法" class="headerlink" title="Clock置换算法"></a>Clock置换算法</h4><p>也称最近未使用算法（NRU, Not Recently Used），它是LRU（最近最久未使用算法）和FIFO的折衷。<br>内存中所有页面通过链接指针形成一个循环队列，每页有一个使用访问位，若该页被访问则置1。置换时采用一个指针，从当前指针位置开始按地址先后检查各页，寻找访问位为0的页面作为被置换页。指针经过的访问位为1的页都修改0，最后指针停留在被置换页的下一个页。</p><h4 id="改进Clock置换算法"><a href="#改进Clock置换算法" class="headerlink" title="改进Clock置换算法"></a>改进Clock置换算法</h4><p>由于Clock算法不考虑换出页面时，页面是否修改过的问题。这样在换出的页面如果被修改过的话，则必须做拷回磁盘处理，开销比较大。于是，改进型的Clock算法为每个页又增加了一个修改位。选择页面时，尽量选择既未使用又没有修改的页面。<br>访问位A，修改位M有四种不同情形：</p><ul><li>1类(A=0，M=0）既未访问，又没有修改，最佳淘汰页</li><li>2类(A=0，M=1）未访问，但是有修改，效率低的淘汰页</li><li>3类(A=1，M=0）被访问，但没有修改</li><li>4类(A=1，M=1）既被访问，又有修改<br>算法：</li></ul><ol><li>指针从当前位置开始，开始第一轮扫描循环队列，寻找A=0且M=0的页面，找到则可换出。</li><li>如果找不到，则开始第二轮扫描，寻找A=0且M=1的页面，并且每经过一个页面时，将其访问位A设置为0。如果找到一个第2类页面，则可换出。</li><li>如果仍旧未找到合适的换出页面，则此时指针回到初始位置，且所有页面其访问位A为0。再转回1继续工作。</li></ol><h4 id="页面缓冲算法"><a href="#页面缓冲算法" class="headerlink" title="页面缓冲算法"></a>页面缓冲算法</h4><p>在请求分页系统中，进程在运行的时候经常会发生页面换进换出的情况。而影响换进换出效率的原因如下：</p><ul><li>页面置换算法：好的页面置换算法能使进程运行中具有较低的缺页率，从而可以减少换进换出的开销。</li><li>写会磁盘的频率。</li><li>读入内存的频率。<br>而页面缓存算法就是降低读写磁盘的频率来降低开销。做法如下：</li><li>空闲页面链表：当有一个未被修改的页要换出时，实际上并不将其换出到外存，而是把它们所在的物理块挂在空闲链表的末尾。如果以后某进程请求此页时，便将其从空闲页面链表上取下。</li><li>修改页面链表：和空闲页面链表的功能一样，只是说此链表是存放已修改页面的。<br>当链表上挂有足够多的页面时，将它们一齐写入磁盘，这样可以降低读写磁盘的频率。</li></ul><p><br></p><h3 id="访问内存的有效时间"><a href="#访问内存的有效时间" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3><ul><li>被访问页在主存，且相应页表项在快表：$EAT= \lambda +t$<ul><li>查找快表+访问实际物理地址</li></ul></li><li>被访问页在主存，但相应页表项不在快表：$ EAT= \lambda +t + t + \lambda$<ul><li>查找快表+读取页表+读取数据+更新快表</li></ul></li><li>被访问页不在主存：$EAT= \lambda + t + \varepsilon + t + \lambda$<ul><li>查找快表+读取页表+缺页中断处理+读取数据+等新快表</li></ul></li><li>内存的有效访问时间为：$EAT= \lambda + t + (1 - a ) \ast [f \ast ( \varepsilon + \lambda + t)+(1-f) \ast(\lambda+t)]$<ul><li><code>a</code>为命中率，<code>f</code>为缺页率。</li><li>查找快表+访问内存一次+未命中不需要请求缺页访问快表+未命中时不需要请求缺页访问内存+未命中需要请求缺页访问快表+未命中时需要请求缺页访问内存+未命中时需要请求缺页开销。</li></ul></li></ul><p><br></p><h2 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h2><h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>由于只装入一个进程的部分程序和数据便可开始运行，故希望运行更多进程，增加多道程序度。但在多道程序环境下，并不是多道程序的度越高，系统吞吐量越大。当CPU的利用率达到某一峰值后，若继续增加多道程度，将产生“抖动”。<br>抖动是指同时运行进程太多，分配给每个进程物理块太少，进程在运行时频繁缺页，必须请求调页，等待页面调进调出的进程增多，磁盘访问时间急剧增加，进程大部分时间用于页面换进换出，处理机利用率急剧下降并趋于0。</p><p><br></p><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>基于程序运行的局部性原理，程序运行时，对页面的访问并不均匀，一段时间仅局限于较少的页面；另一段时间，有可能局限于另一些较少的页面，如果能预知这些页面，并提前调入，将大大减少缺页率工作集，是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。</p><ul><li>方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。<br>定义：是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。</li><li>方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。<br>工作集$ \omega (t, \Delta) $是二元函数。某进程在时间<code>t</code>的工作集记为$ \omega (t, \Delta) $，其中，$\Delta$为工作集的窗口尺寸。</li></ul><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><ul><li>窗口大小$\Delta$选择得过小，频繁产生缺页中断。</li><li>窗口大小$\Delta$选择得很大，失去了虚拟存储器的意义</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/58a68c04-867c-4616-836b-6442f8dc42dc"></div><p><br></p><h3 id="抖动的预防方法"><a href="#抖动的预防方法" class="headerlink" title="抖动的预防方法"></a>抖动的预防方法</h3><ul><li>采取局部置换策略：仅允许进程在自身范围内进行置换，不影响其他进程</li><li>在CPU调度程序中引入工作集算法：调入新作业时，应该检查每个进程在内存中的驻留集是否足够大</li><li><code>L=S</code>准则：<code>产生缺页的平均时间L=系统处理进程缺页的平均时间S</code></li><li>选择暂停的进程：使某些低优先级的进程进程挂起，从而腾出内存空间</li></ul><p><br></p><h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><ul><li>请求分页系统建立的虚拟存储器，是以页面为单位进行换入、换出操作的。</li><li>在请求分段系统中实现的虚拟存储器，以分段为单位进行换入和换出。</li><li>程序在运行之前，只需要装入必要的若干个分段即可运行。当访问的分段不在内存时，可由OS将所缺少的段调入内存。<br>使用请求分段存储管理方式可以对动态链接有很好的支持。</li></ul><p><br></p><h3 id="请求段表机制"><a href="#请求段表机制" class="headerlink" title="请求段表机制"></a>请求段表机制</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/01222d76-e106-4c18-adc8-d19b9a59e4d6"></div><ul><li>存取方式：标记本段存取属性。如读R，写W，执行X</li><li>访问字段A：记录本段使用的频繁程度</li><li>修改位：是否在调入内存后做过修改</li><li>存在位：本段是否装入内存</li><li>增补位：该段是否动态增长过</li></ul><p><br></p><h3 id="缺段中断机构"><a href="#缺段中断机构" class="headerlink" title="缺段中断机构"></a>缺段中断机构</h3><p>要有专门的缺段中断处理程序。特点：</p><ul><li>指令和操作数必定不会跨越在段边界上。</li><li>由于段的长度是不固定的，处理比缺页系统复杂。</li><li>调入一个段可能要淘汰几个内存中的段。</li></ul><p><br></p><h3 id="请求中断处理"><a href="#请求中断处理" class="headerlink" title="请求中断处理"></a>请求中断处理</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e70e650f-81ae-4000-b670-06c210adabd8"></div><p><br></p><h3 id="地址中断机构"><a href="#地址中断机构" class="headerlink" title="地址中断机构"></a>地址中断机构</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/986886e7-0ca3-4c6c-a3ff-02082cee3a70"></div><p><br></p><h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3><h4 id="共享段表"><a href="#共享段表" class="headerlink" title="共享段表"></a>共享段表</h4><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6ff2d558-015d-4051-848b-74903bb4ef9f"></div><ul><li>共享进程计数：多少进程在使用此段。</li><li>存取控制手段：每个共享段，应为不同进程赋予不同的存取权限。</li><li>断号：同一个共享段在不同进程那有不同的断号。</li></ul><h4 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h4><p>第一个请求的进程，由系统分配一物理块，调入共享段，设置相关表项信息，并置<code>count=1</code>； 以后的进程，在自己的段表中增加一项，填入共享段的信息，在共享段表项中做<code>count=count+1</code>，填写进程相关信息。</p><h4 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h4><ol><li>做count=count-1；</li><li>若count=0 ，则该共享段被回收。</li></ol><h4 id="分段保护"><a href="#分段保护" class="headerlink" title="分段保护"></a>分段保护</h4><ul><li>越界检查：在进行存储访问时，要将逻辑地址的段号与段表长度进行比较，如果超出则发生越界中断信号；其次，将段内地址与段表中该段的长度进行比较，如果有效才进行转换，否则产生越界中断信号。</li><li>存取控制检查：用于规定对该段的访问权限。通常的访问方式有：<ul><li>读：允许用户对该段/页内任何信息或其副本进行读操作。</li><li>写：允许用户修改该段/页内任何信息直至撤消整个段/页。</li><li>执行：用户可以执行该段/页程序，数据段/页除外。</li><li>增加：用户可在段/页的末尾添加信息，但不允许修改已存在于段/页中的信息。</li></ul></li><li>环保护检查：是一种功能较完善的保护机制。<ul><li>思想：将所有的程序分成不同的级别，分别放置在不同的环上。内环（编号小，在内侧）的程序具有高优先权，外环的程序优先权低。</li><li>操作系统核心安排在0环内；重要程序和操作系统服务安排在中间环；一般应用程序安排在外环。</li><li>一个程序可以直接访问在相同环或低优先级环（比自身相对靠外的环）上的数据。</li><li>一个程序访问高优先级（比自己靠内的环）时，通过系统调用方式实现。</li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;存储器的层次&quot;&gt;&lt;a href=&quot;#存储器的层次&quot; class=&quot;headerlink&quot; title=&quot;存储器的
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>06.05-输入输出系统</title>
    <link href="https://isjinhao.github.io/posts/3774.html/"/>
    <id>https://isjinhao.github.io/posts/3774.html/</id>
    <published>2019-12-20T09:19:38.000Z</published>
    <updated>2019-12-20T09:29:23.880Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>输入输出系统和OS中的其他部分有很大区别，因为其他部分都是在说计算机接受任务后该怎么运行能又快又可靠的完成任务并把结果输出。而输入输出系统是怎么快速稳定的将任务的需求输入和任务的结果输出。<br>又由于输入输出设备种类繁多，比如输入设备中的键盘、鼠标、网卡、摄像头，输出设备中的打印机、音频等。所以输入输出系统被划分很多层次来尽可能屏蔽物理细节。</p><p><br></p><h3 id="IO系统的基本功能"><a href="#IO系统的基本功能" class="headerlink" title="IO系统的基本功能"></a>IO系统的基本功能</h3><ul><li>隐藏物理设备的细节：只需要使用简单的命令就能操作各种具有不同实现的硬件完成相应需求。</li><li>与设备的无关性：用户不需要指定哪些设备完成功能，只需要描述需求，OS会选择一个设备完成功能。</li><li>提高处理机和IO设备的利用率：IO设备之间一般是相互独立的，因此设备之间能够并行操作，所以OS应让处理机和设备之间能并行操作。</li><li>对IO设备进行控制：<ul><li>轮询的可编程IO方式。</li><li>采用中断你的可编程IO方式。</li><li>直接存储器访问方式。</li><li>IO通道方式。</li></ul></li><li>确保对设备的正确共享。</li><li>错误处理。</li></ul><p><br></p><h2 id="IO软件的层次结构"><a href="#IO软件的层次结构" class="headerlink" title="IO软件的层次结构"></a>IO软件的层次结构</h2><div align="center"><img src="http://blogfileqiniu.isjinhao.site/933ea414-24d5-4dfd-8201-8cacf6cbeff1"></div><ul><li>用户层软件：提供设备与用户交互的接口，用户可以使用该层提供的功能直接控制设备。</li><li>设备独立性软件：设备分配，设备保护，设备分配，设备回收，数据缓存等。</li><li>设备驱动软件：发出控制设备的命令。</li><li>中断处理程序：保存被中断的进程的CPU环境，转入相应的中断处理程序仅需处理，处理完毕后再恢复被中断进程的现场，返回到被中断的进程。</li></ul><p><br></p><h2 id="IO系统各模块层次视图"><a href="#IO系统各模块层次视图" class="headerlink" title="IO系统各模块层次视图"></a>IO系统各模块层次视图</h2><div align="center"><img src="http://blogfileqiniu.isjinhao.site/770f375c-c73f-46e5-828a-bbf0938c241a"></div><ul><li>块设备：输入输出以数据块为单位的设备。如磁盘。</li><li>流设备：字符设备的输入输出，如键盘。</li><li>网络通信接口：网卡。</li></ul><p><br></p><h2 id="IO设备和设备控制器"><a href="#IO设备和设备控制器" class="headerlink" title="IO设备和设备控制器"></a>IO设备和设备控制器</h2><p>直接和IO设备对接的是设备控制器。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/953ad1c7-eacf-4d86-9a95-87cf7a978c62"></div><p><strong>作用</strong></p><ol><li>接收和识别命令（控制寄存器、命令译码器）：设备控制器将CPU送来的命令写入控制器寄存器中，并进行译码。</li><li>数据交换（数据寄存器）。</li><li>设备状态的了解和报告（状态寄存器）。</li><li>地址识别（地址译码器）：系统中的每个设备都有自己的地址段，设备接口电路中有多个寄存器，一个寄存器有唯一的一个地址，每个地址为I/O端口，该地址称为I/O端口地址。设备控制器必须能识别每个设备的地址。</li><li>数据缓冲：缓冲器。</li><li>差错控制：差错检测码。</li></ol><p><strong>组成</strong></p><ul><li>设备控制器和处理机的接口：用于实现CPU与设备控制器之间的通信。</li><li>设备控制器和设备的接口。</li><li>IO逻辑：在一个设备控制器上，可以连一个或多个设备。相应的，在控制器中就有一个或多个设备接口，一个接口连一台设备，控制器中的I/O逻辑根据处理机发来的地址信号，去选择一个设备接口。控制器中的I/O逻辑用来实现对设备的控制。通过接收CPU 发来的命令和地址信息，对所选设备进行控制</li></ul><p><br></p><h3 id="CPU如何控制设备控制器"><a href="#CPU如何控制设备控制器" class="headerlink" title="CPU如何控制设备控制器"></a>CPU如何控制设备控制器</h3><p>CPU控制内存时需要指定指令地址、数据地址等。控制设备控制器亦如此，一般有两种控制方式：</p><ul><li>利用特定IO指令：利用特殊的IO指令控制设备控制器。</li><li>内存映像IO：不再区分内存和控制器中的寄存器地址。假如有一个地址K，当0&lt;=K&lt;N时被认为是内存地址，K&gt;=N时被认为是寄存器地址。</li></ul><p><br></p><h3 id="IO通道"><a href="#IO通道" class="headerlink" title="IO通道"></a>IO通道</h3><p>有了设备控制器之后，CPU便可以操作控制器完成对IO设备的控制，但是此时数据交换仍然需要CPU的全程参与，所以引入IO通道来使数据传送、IO设备的组织管理等都独立于CPU。<br>通道是独立于CPU的专门负责数据输入/输出传输工作的处理机，对外部设备实现统一管理，代替CPU对输入/输出操作进行控制，从而使输入，输出操作可与CPU并行操作。通道执行通道程序来控制IO操作。与CPU的区别：</p><ul><li>通道程序指令类型单一</li><li>通道没有自己的内存，通道程序在主机的内存中，即通道与CPU共享内存。</li></ul><h4 id="字节多路通道"><a href="#字节多路通道" class="headerlink" title="字节多路通道"></a>字节多路通道</h4><p>主要连接以字节为单位的低速IO设备。如打印机，终端。</p><ul><li>按字节交叉方式工作的通道。通常含有许多非分配型子通道，其数量从几十个到数百个，每一个子通道连接一台I/O设备。这些子通道按时间片轮转方式共享主通道。</li><li>字节多路通道以字节为单位传输信息，它可以分时地执行多个通道程序。当一个通道程序控制某台设备传送一个字节后，通道硬件就控制转去执行另一个通道程序，控制另一台设备传送信息。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e84be910-3765-4aaf-9fad-4129b1ac7442"></div><h4 id="数组选择通道"><a href="#数组选择通道" class="headerlink" title="数组选择通道"></a>数组选择通道</h4><p>主要连接磁盘，磁带等高速I/O设备<br>选择通道是按数组方式进行数据传送，每次传送一批数据，故传送速度很高。<br>选择通道在一段时间内只能执行一个通道程序，只允许一台设备进行数据传输。当这台设备数据传输完成后，再选择与通道连接的另一台设备，执行它的相应的通道程序。这种独占性又使得通道利用率很低。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/bcbc610f-941b-4b1f-b16c-70e915f25f26"></div><h4 id="数组多路通道"><a href="#数组多路通道" class="headerlink" title="数组多路通道"></a>数组多路通道</h4><p>主要连接高速设备。</p><ul><li>结合了数组选择通道传送速度高和字节多路通道能进行分时并行操作的优点。它先为一台设备执行一条通道指令，然后自动转接，为另一台设备执行一条通道指令。它含有多个非分配型的子通道，既有很高的数据传输率，又能获得令人满意的通道利用率</li><li>对通道程序采用多道程序设计的硬件实现</li><li>可以连接多台高速设备，数据传输按数组方式，一段时间内可以执行多道通道程序</li></ul><h4 id="解决瓶颈"><a href="#解决瓶颈" class="headerlink" title="解决瓶颈"></a>解决瓶颈</h4><p>通道执行通道程序，向控制器发出命令，并具有向CPU发中断信号的功能。一旦CPU发出指令，启动通道，则通道独立于CPU工作。但是，由于通道价格贵，通道数量少，往往使之成为IO的“瓶颈”。解决办法是在不增加通道的前提下，增加设备到主机间的通路，一个通道可连接多个控制器，一个控制器可连接多个设备，形成树形交叉连接。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/916c4771-7b35-43bc-8723-c55e7c4c6162"></div><p><br></p><h2 id="中断机构"><a href="#中断机构" class="headerlink" title="中断机构"></a>中断机构</h2><h3 id="中断的理解"><a href="#中断的理解" class="headerlink" title="中断的理解"></a>中断的理解</h3><p>说到中断还不得不从现代操作系统的特性说起，无论是桌面PC操作系统还是嵌入式都是多任务的操作系统，而很遗憾，处理器往往是单个的，即使在硬件成本逐渐下降，但处理器的数量依然不可能做到每个任务一个CPU，所以CPU必须作为一种全局的资源让所有任务共享。即什么时候给任务A用，什么时候给任务B用……这就是进程调度，具体的安排就由调度算法决定了。<br>进程如何去调度？现代操作系统一般都是采用基于时间片的优先级调度算法，把CPU的时间划分为很细粒度的时间片，一个任务每次只能时间这么多的时间，时间到了就必须交出使用权，即换其他的任务使用。这种要看操作系统的定时器机制了。那么时间片到之后，系统做了什么呢？这就要用到我们的中断了，时间片到了由定时器触发一个软中断，然后进入相应的处理历程。当然这一点不足以表明中断的重要，计算机操作系统自然离不开外部设备：鼠标、键盘、网卡、磁盘等等。就拿网卡来讲，我计算机并不知道时候数据包会来到，我能保证的就是数据来了我能正常接收就行了。但是我又不可能一直等着接收数据包，要是这样其他任务就死完了。所以合理的办法是，你数据包来到之后，通知我，然后我再对你处理，怎么通知呢？？答：中断！键盘、鼠标亦是如此！</p><p><br></p><h3 id="中断的定义"><a href="#中断的定义" class="headerlink" title="中断的定义"></a>中断的定义</h3><p>指处理机处理程序运行中出现的紧急事件的整个过程。程序运行过程中，系统外部、系统内部或者现行程序本身若出现紧急事件，处理机立即中止现行程序的运行，自动转入相应的处理程序（中断服务程序），待处理完后，再返回原来的程序运行，这整个过程称为程序中断。可分为两类：</p><h4 id="硬中断（Hardware-Interrupt）"><a href="#硬中断（Hardware-Interrupt）" class="headerlink" title="硬中断（Hardware Interrupt）"></a>硬中断（Hardware Interrupt）</h4><ul><li>外部中断：一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断是可屏蔽的。</li><li>内部中断是指因硬件出错（如突然掉电、奇偶校验错等）,或运算出错（除数为零、运算溢出、单步中断等）所引起的中断，内部中断是不可屏蔽的。</li></ul><h4 id="软中断（Software-Interrupt）"><a href="#软中断（Software-Interrupt）" class="headerlink" title="软中断（Software Interrupt）"></a>软中断（Software Interrupt）</h4><p>软中断是利用硬中断的概念，用软件方式进行模拟，实现宏观上的异步执行效果。很多情况下，软中断和”信号”有些类似，同时，软中断又是和硬中断相对应的，硬中断是外部设备对CPU的中断，软中断通常是硬中断服务程序（模拟硬件发出中断的程序）对内核的中断，信号则是由内核（或其他进程）对某个进程的中断。</p><p><br></p><h3 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h3><p>在Linux的0号中断是一个定时器中断。在固定的时间间隔都发生一次中断，也是说每秒发生该中断的频率都是固定的。该频率是常量HZ，该值一般是在100 ~ 1000之间。该中断的作用是为了定时更新系统日期和时间，使系统时间不断地得到跳转。另外该中断的中断处理函数除了更新系统时间外，还需要更新本地CPU统计数。若进程的时间片递减到0，进程则被调度出去而放弃CPU使用权。<br>Linux的OS时钟的物理产生原因是可编程定时/计数器产生的输出脉冲，这个脉冲送入CPU，就可以引发一个中断请求信号，我们就把它叫做<code>时钟中断</code>。<br><code>时钟中断</code>是特别重要的一个中断，因为整个操作系统的活动都受到它的激励。系统利用时钟中断维持系统时间、促使环境的切换，以保证所有进程共享CPU；利用时钟中断进行记帐、监督系统工作以及确定未来的调度优先级等工作。可以说，<code>时钟中断</code>是整个操作系统的脉搏。</p><p><br></p><h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol><li>接受设备独立性软件发来的命令和参数，将接收到的抽象要求转换为具体要求</li><li>检查用户IO请求的合法性，了解IO设备的状态，传递有关参数，设置设备的工作方式</li><li>发出IO命令，如果设备空闲，启动IO设备完成指定的IO操作；如果设备忙碌，则将请求挂在设备队列上等待</li><li>及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。</li><li>对于设置有通道的计算机系统，驱动程序还应能够根据用户的IO请求，自动地构成通道程序。</li></ol><p><br></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>驱动程序主要是在设备无关性软件和设备控制器之间的一个通信程序</li><li>驱动程序与IO设备特性密切相关：通常由硬件厂商提供</li><li>驱动程序与I/O控制方式密切相关:中断驱动和DMA方式</li><li>驱动程序与硬件相关,部分代码需用汇编语言编写</li><li>驱动程序应允许可重入</li></ol><p><br></p><h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><ol><li>将抽象要求转换为具体要求<ol><li>通常设备控制器中都有若干个寄存器，分别用于暂存命令、数据和参数等；</li><li>用户及上层软件对设备控制器的具体情况毫无了解，因而只能向它们发出抽象的要求(命令)，但不能直接传送给设备控制器。需要将抽象要求转换为具体要求(命令码，数据，参数)。例如，将抽象要求中的盘块号转换为磁盘的盘面、磁道号及扇区。这一转换工作只能由驱动程序来完成；</li><li>在OS中只有驱动程序才同时了解抽象要求和设备控制器中的寄存器情况；也只有它才知道命令、数据和参数应分别送往哪个寄存器。</li></ol></li><li>检查IO请求的合法性</li><li>读出和检查设备的状态</li><li>传送必要的参数，设置工作方式</li><li>启动I/O设备<ol><li>在完成上述准备工作后，驱动程序可以向控制器中的命令寄存器传送相应的控制命令</li><li>对于字符设备，若发出的是写命令，驱动程序将把一个数据传送给控制器；若发出的是读命令，则驱动程序等待接收数据，并通过从控制器中的状态寄存器读入状态字的方法，来确定数据是否到达。</li><li>驱动程序发出IO命令后，基本的IO是在设备控制器的控制下进行的，通常IO操作所要完成的工作较多，需要一定的时间，如读/写一个盘块中的数据，此时，驱动程序进程把自己阻塞起来，直至中断到来时才将它唤醒。</li></ol></li></ol><p><br></p><h3 id="对IO设备的控制方式"><a href="#对IO设备的控制方式" class="headerlink" title="对IO设备的控制方式"></a>对IO设备的控制方式</h3><h4 id="使用轮询的可编程I-O方式"><a href="#使用轮询的可编程I-O方式" class="headerlink" title="使用轮询的可编程I/O方式"></a>使用轮询的可编程I/O方式</h4><p>CPU发出启动外设的I/O指令，同时将忙/闲标志置为1。如果外设的工作没有完成，则标志一直为1，CPU不断循环检测该标志，直到标志为不忙为止。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/71de03d5-8111-44f5-96fa-15ee82e189c0"></div><h4 id="使用中断的可编程I-O方式"><a href="#使用中断的可编程I-O方式" class="headerlink" title="使用中断的可编程I/O方式"></a>使用中断的可编程I/O方式</h4><p>CPU设定I/O设备的初始值，然后不再忙等待，运行其他进程，当前进程阻塞；I/O设备完成对当前数据的处理后，向CPU发出中断，I/O中断处理程序将负责传送剩余数据。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/5019de9a-b7c9-4eeb-a0a9-d00882dbd3ea"></div><h4 id="直接存储器访问-DMA-方式"><a href="#直接存储器访问-DMA-方式" class="headerlink" title="直接存储器访问(DMA)方式"></a>直接存储器访问(DMA)方式</h4><p>采用中断驱动IO方式时的CPU，是以字为单位进行干预的。如果将这种方式用于块设备的I／O，是极其低效的。如：为了从磁盘中读出1KB的数据块；需要中断1K次CPU。而DMA方式使用独立的DMA控制器代替CPU的工作，I/O设备与DMA通信，DMA在传输完成一个数据缓冲区之后再向CPU发中断。</p><ul><li>数据传输的基本单位是数据块，即CPU与IO设备之间，每次传送至少是一个数据块，主要用在块设备的IO操作中。</li><li>在DMA方式中，利用总线直接连接外设和内存，由DMA控制机构窃取总线占有权，完成外设与内存间的成批数据交换。所传送的数据是从设备直接送入内存的，或者相反。</li><li>仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的，不再需要CPU进行干预。</li></ul><h4 id="I-O通道控制方式"><a href="#I-O通道控制方式" class="headerlink" title="I/O通道控制方式"></a>I/O通道控制方式</h4><p>使用DMA方式，CPU每发出一条I/O指令，只能读写一个连续的数据块。如果需要一次去读多个离散的数据块且将它们分别送到不同的内存区域，则需要CPU分别发出多条I/O指令及进行多次中断处理，才能完成。<br>而IO通道可实现CPU、通道和I/O设备三者的并行操作，进一步提高CPU与外设之间的并行工作能力，使I/O操作形成独立于CPU的体系，减少CPU的负担，使外设与内存的数据交换更加灵活，从而更有效地提高整个系统的资源利用率。</p><p><br></p><h2 id="与设备无关的I-O软件"><a href="#与设备无关的I-O软件" class="headerlink" title="与设备无关的I/O软件"></a>与设备无关的I/O软件</h2><p>为了便于对外设进行管理，系统对每台进入计算机系统中的设备都给定一个对应的编号，作为调用时识别和区分设备用。这种编号无任何重复，一般被称为设备的绝对号（或物理设备名）。早期操作系统，应用程序直接使用物理设备名称，非常不灵活。所以引入逻辑设备名，规定用户申请外设时，只需要向系统说明所需用的某类设备真正在实际中使用哪台设备，由系统根据这类设备的应用情况作出分配。</p><p><br></p><h3 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h3><p>在多道程序环境下，设备不允许用户自行使用，而必须由系统分配。对于进程的IO请求，只要是安全（无死锁），设备分配程序便按照一定的策略进行设备分配。数据结构：</p><p><strong>系统设备表SDT（System Device Table）</strong></p><ul><li>整个系统中只有一张，全面反映了系统中的外设资源的类型、数量、占用情况等。</li><li>在SDT表中，每个接入系统中的外围设备都占有一个表目项。登录了该设备的名称、标识、设备控制表DCT的入口地址、设备驱动程序的入口地址及占用设备的进程名称等相关信息。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/539d5402-4cc5-490c-985c-fad795ce64ac"></div><p><strong>设备控制表DCT（Device Control Table）</strong></p><p>每台设备都有一张设备控制表DCT，用于记录本设备的情况。</p><ul><li>Type：设备类型</li><li>Deviceid:设备标识符</li><li>设备队列队首指针</li><li>设备状态：标识设备忙或者空闲；</li><li>与设备连接的控制器表指针。</li><li>重复执行次数</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/2c6655c2-822f-4ab3-9687-fcd81f033f9d"></div><p><strong>控制器控制表COCT（Controller Control Table）</strong></p><p>每个控制器都有一张，用于记录某控制器的使用分配情况及与该控制器相连的通道的情况。</p><ul><li>控制器号：控制器的内部标识符。</li><li>控制器状态：控制器忙/闲，好/坏的状态标志。</li><li>通道指针：指向与该控制器相联的通道控制表CHCT，当控制器与若干通道连接时该项内含多个指针。</li><li>等待队列指针：指向等待该控制器的I/O进程队列</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/5a78bf33-edc8-44fa-a002-b0353ed26c29"></div><p><strong>通道控制表CHCT（Channel Control Table）</strong></p><p>反映了通道的情况，系统中的每个通道一张CHCT。</p><ul><li>通道号：通道内部标识符</li><li>通道状态：通道的各种状态（好/坏，已分/未分等）的反映</li><li>等待队列指针：等待该通道的I/O进程队列的首位置</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/bace2576-4035-437b-a4ac-30414ffea488"></div><p><br></p><h3 id="设备分配算法"><a href="#设备分配算法" class="headerlink" title="设备分配算法"></a>设备分配算法</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6b9fe6d2-8133-4526-82a3-08a24238ae27"></div><p><br></p><h2 id="用户层的I-O软件"><a href="#用户层的I-O软件" class="headerlink" title="用户层的I/O软件"></a>用户层的I/O软件</h2><h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>用户层软件必须使用一组系统调用来取得操作系统服务，在高级语言中都提供了相应的库函数来完成此功能。</p><p><br></p><h3 id="SPOOLing程序"><a href="#SPOOLing程序" class="headerlink" title="SPOOLing程序"></a>SPOOLing程序</h3><p>多道程序技术将一台CPU虚拟为多台CPU，从而可以提高CPU的利用率。而SPOOLing系统是模拟脱机输入输出系统来实现多个用户共享一台物理IO设备。</p><ul><li>脱机输入输出系统的IO处理机 对应 SPOOLing程序。</li><li>脱机输入输出系统的高速缓冲 对应 内存。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e7324c67-1eb4-4616-a966-8e8b29021a1e"></div><p><br></p><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><p><strong>单缓冲区</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/92ffc296-47a4-4a11-9bd8-8ab8b45505cc"></div><p><strong>双缓冲区</strong></p><p>为输入或输出分配两个缓冲区，让两个缓冲区交替工作，形成并行操作的方式。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/11af4878-bdf2-4196-ae83-b8365f4e09ae"></div><p><strong>环形缓冲区</strong></p><ul><li>空缓冲区R：用于存放数据（指针：Nexti）</li><li>已装满数据的缓冲区G：其中的数据提供给进程使用。（指针：Nextg）</li><li>现行工作缓冲区C：当前进程使用的缓冲区。（指针：Current）</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/7da390f7-d59f-4fb1-8ce8-f5eac19bd508"></div><p><br></p><h2 id="磁盘存储器的性能和调度"><a href="#磁盘存储器的性能和调度" class="headerlink" title="磁盘存储器的性能和调度"></a>磁盘存储器的性能和调度</h2><div align="center"><img src="http://blogfileqiniu.isjinhao.site/fcb16fbb-dee2-4438-ae5c-070fa08106e0"></div><p>当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头（又叫磁头）下通过，就可以进行数据的读/写了。<br>一般磁盘分为固定头盘（磁头固定）和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。<br>活动头盘 （如上图）的磁头是可移动的。每一个盘面上只有一个磁头（磁头是双向的，因此正反盘面都能读写）。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的（行动整齐划一）。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。</p><p><br></p><h3 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h3><ol><li>寻道时间$T_s$：$T_s = s$</li><li>旋转延迟时间$T_τ$：$T_t = \frac{1}{2r}$</li><li>磁盘访问时间 ：$T_t=\frac{b}{rN}$<br>$s$是指磁头从当前位置定位到开始点的时间，$b$是传输的字节数，$r$是每秒的转数，$N$是一条磁道上的字节数。$总时间 = T_s + \frac{1}{2r} + \frac{b}{rN}$</li></ol><p><br></p><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>假设磁盘访问序列：98，183，37，122，14，124，65，67，读写头起始位置：53。</p><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>按访问请求到达的先后次序服务。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/3d7fcac5-9594-490a-8922-5591670a9fe7"></div><h4 id="最短寻道时间优先"><a href="#最短寻道时间优先" class="headerlink" title="最短寻道时间优先"></a>最短寻道时间优先</h4><div align="center"><img src="http://blogfileqiniu.isjinhao.site/4f6b90ae-cda1-4121-a194-e5d05c399f1e"></div><h4 id="扫描算法"><a href="#扫描算法" class="headerlink" title="扫描算法"></a>扫描算法</h4><p>当设备无访问请求时，磁头不动；当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/5d8e546a-f8a3-4325-b885-2888c59c10ac"></div><h4 id="循环扫描算法"><a href="#循环扫描算法" class="headerlink" title="循环扫描算法"></a>循环扫描算法</h4><p>CSCAN算法规定磁头单向移动，例如由里向外移动，当磁头移到最外的磁道并访问后磁头立即返回到最里的欲访<br>问磁道，即最小磁道号紧接最大磁道号构成循环，进行循环扫描。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>06.07-外存管理</title>
    <link href="https://isjinhao.github.io/posts/43988.html/"/>
    <id>https://isjinhao.github.io/posts/43988.html/</id>
    <published>2019-12-20T09:19:38.000Z</published>
    <updated>2019-12-20T09:29:23.884Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><em>外存管理分成两块，文件系统和磁盘管理</em></p><p><br></p><h2 id="文件管理概述"><a href="#文件管理概述" class="headerlink" title="文件管理概述"></a>文件管理概述</h2><p>计算机中有很多的程序和数据都是保存在外存中，在需要使用的时候才调入内存中。而如何保存这些信息是很重要的问题，因为不同类型的文件存储的数据格式不同，但这些格式却必须“迎合”硬件只能存储二进制数据的硬性条件。所以操作系统提供了文件管理的功能，让使用者能在不了解文件特性和外存特性的情况下完成文件的存储和查找等功能。同时还提供了文件共享和安全管理等功能。</p><p><br></p><h3 id="文件系统-amp-文件"><a href="#文件系统-amp-文件" class="headerlink" title="文件系统 &amp; 文件"></a>文件系统 &amp; 文件</h3><p>操作系统中负责管理和存储文件信息的软件称为文件管理系统，简称文件系统。包含：文件系统的接口，对对象操纵和管理的软件集合，对象及属性三部分。它负责对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。包含创建文件、删除文件等功能。<br>文件是指具有文件名的若干相关元素的集合，可以分成有结构文件和无结构文件，无结构文件可以看成一个字符流。有结构文件是由一组记录的集合，记录又是一组数据项的集合。</p><ul><li>数据项：用来描述一个对象的某种属性的字符集。例如学生的学号、姓名等。</li><li>记录：一组数据项的集合，用来描述一个对象在某方面的属性，例如学生的成绩。能唯一标识一个记录的一个或多个数据项叫做关键字。</li></ul><p><br></p><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>不同的文件类型由于本身存储的信息具有不同的结构，在管理的时候也是不同。所以文件会被分成很多类型，下面是常用的文件分类方法：</p><ul><li>按用途分类：系统文件、库文件、用户文件。</li><li>按文件中数据的形式分类：源文件、目标文件、可执行文件。</li><li>按存储控制属性分类：可读、可写、可执行文件。</li><li>按组织形式和处理方法分类：普通文件、目录文件、特殊文件。</li></ul><p><br></p><h3 id="剖析文件和目录"><a href="#剖析文件和目录" class="headerlink" title="剖析文件和目录"></a>剖析文件和目录</h3><p>我们刚才在定义中说道，文件是指具有文件名的若干相关元素的集合，在有结构文件中这些元素是数据项集合的集合，在无结构文件指的是字符流。所以文件的概念中本身是：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/48e07c68-5ff3-4076-9203-a310cb6e99e0"></div><p><br></p><h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p>文件系统从底层到高层可分成三部分：对象及其属性、对对象操纵和管理的软件集合、文件系统接口：</p><p><strong>对象及其属性</strong></p><p>文件管理系统管理的文件如下：</p><ul><li>文件：在文件管理系统中有着各种不同类型的文件，它们都作为文件管理的直接对象。</li><li>目录：用于对文件的存储和检索，目录的每个目录项包含了一个文件或目录的信息。</li><li>磁盘存储空间：文件和目录必定占用存储空间，对这部分空间的有效管理不仅能提高外存的利用率，而且能提高对文件的存取速度。</li></ul><p><strong>对对象操纵和管理的软件集合</strong></p><p>该层是文件管理系统的核心部分。文件系统的功能大多是在这一层实现的。如：文件存储的管理、文件目录的管理、将文件的逻辑地址转换为物理地址的机制、文件读写控制的管理、文件的共享和保护等功能。这些功能被可分为四层：</p><ul><li>I/O控制层：文件系统的最底层、主要由磁盘驱动程序等组成。</li><li>基本文件系统层：主要用于处理内存和磁盘之间数据块的交换。</li><li>基本I/O管理程序：完成与磁盘I/O有关的事务，如将文件的逻辑块号转换为物理块号、管理磁盘中的空闲盘块、I/O缓冲的指定等。</li><li>逻辑文件系统：管控对文件的操作，如控制用户或应用程序对文件的读写等。</li></ul><p><strong>文件系统的接口</strong></p><p>操作系统提供给用户或应用程序用来使用文件系统的接口：</p><ul><li>命令接口：用户与文件系统直接交互的接口，如Shell命令。</li><li>程序接口：应用程序可以通过一系列命令调用文件系统的服务。</li></ul><p><br></p><h2 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h2><p>当用户要求对一个文件实施多次读/写操作时，如果每次都检索目录效率较低，所以为了避免多次重复的检索目录，OS提供了“打开（Open）”操作，当此操作被执行时，OS会把被打开文件的信息存为“打开文件表”的一个条目，然后把这个条目编号返回用户，这样用户就可以通过这个编号和文件之间建立一个连接，也就可以进行文件的读写等操作。当用户再次向系统发出请求时，把这个编号提交给OS，OS通过这个编号在打开文件表中查找文件信息就可以减少检索时间。而关闭就是OS从“打开文件表”上删除此条目，这样断开了用户和文件之间的连接。</p><p><br></p><h2 id="文件的逻辑结构和物理结构"><a href="#文件的逻辑结构和物理结构" class="headerlink" title="文件的逻辑结构和物理结构"></a>文件的逻辑结构和物理结构</h2><ul><li>逻辑结构：从用户的角度来看，文件是能被存取的基本单位。</li><li>物理结构：文件在磁盘上存储时的组织形式。</li></ul><p><br></p><h3 id="逻辑文件按结构分类"><a href="#逻辑文件按结构分类" class="headerlink" title="逻辑文件按结构分类"></a>逻辑文件按结构分类</h3><ul><li>有结构文件：每个文件用于描述实体集中的一个实体。每个记录的长度对OS来说都是可知的。但记录之间可以分为定长和变长两种。<ul><li>定长记录：所有记录的长度都是相同的、所有记录中的各数据项都处在记录中相同的位置具有相同的顺序和长度。</li><li>变长记录：各记录的长度不相同。比如论文的摘要可能长度差距很大，不能在存储之前估计出所需要的空间。</li></ul></li><li>无结构文件：系统中运行的大量的源程序、可执行文件、文本文件等都是无结构文件，即流式文件。其文件长度是以字节为单位的。</li></ul><p><br></p><h3 id="逻辑文件按组织方式分类"><a href="#逻辑文件按组织方式分类" class="headerlink" title="逻辑文件按组织方式分类"></a>逻辑文件按组织方式分类</h3><p>组织方式指的是文件中记录的组织方式。只对有结构文件有效。可以分成：顺序文件、索引文件、索引顺序文件。</p><p><br></p><h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><p>指由一系列记录按某种顺序排列所形成的的文件。</p><ul><li>串结构：按存入时间的先后顺序排列。所以检索时必须从头挨个查找，效率低。</li><li>顺序结构：用户指定一个字段作为关键字，他可以是任意类型的变量。如sql文件。</li></ul><p><br></p><h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>为变长记录文件创建一张索引表，索引表是定长记录文件，检索时，先查找索引表，再根据指针所指的地址读取记录。可以解决变长文件记录较难直接存取的问题。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/453ddfa5-648b-4d80-a82f-8c23075d486e"></div><p><br></p><h3 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h3><p>将顺序文件的所有记录分成若干组，为顺序文件建立一张索引表，索引表中为每组的第一个记录建立一个索引项。检索时，先检索索引表，找到记录所在记录组的第一个记录的表项，再顺序查找主文件，得到要求的记录。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e955a679-4e9f-47fe-a922-5c340b31e898"></div><p><br></p><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><p>包含三类信息</p><ul><li>基本信息类：文件名、文件物理位置、文件逻辑结构、文件物理结构</li><li>控制信息类：各类用户的读、写、可执行文件等。</li><li>使用信息类：文件的建立时间，当前的使用信息，上一次修改的时间，是否被进程锁住等。</li></ul><p><br></p><h3 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h3><p>为了唯一确定外存中的一个文件，必须要把文件的FCB加载进内存，而每次加载的数据大小是一定的，所以为了一次能多加载进内存一个文件标识。将FCB分成两部分：</p><h4 id="磁盘索引节点"><a href="#磁盘索引节点" class="headerlink" title="磁盘索引节点"></a>磁盘索引节点</h4><ul><li>文件主标识符</li><li>文件类型</li><li>文件存取权限</li><li>文件物理地址</li><li>文件长度</li><li>文件连接计数：本人理解为硬链接计数</li><li>文件存取时间</li></ul><h4 id="内存索引节点。"><a href="#内存索引节点。" class="headerlink" title="内存索引节点。"></a>内存索引节点。</h4><ul><li>索引节点编号</li><li>状态</li><li>访问计数</li><li>文件所属文件系统的逻辑设备号：不明白</li><li>链接指针：不明白</li></ul><p><br></p><h3 id="树形结构目录"><a href="#树形结构目录" class="headerlink" title="树形结构目录"></a>树形结构目录</h3><p>在树形结构目录中，目录应该保存文件的信息。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/48c2c8df-2f08-420a-9ebc-6ced18b6e735"></div><p>同时目录的目录项要能既作为目录文件的FCB，又作为数据文件的FCB。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/3558f5fe-43a4-4902-9f69-a6debd7a99d3"></div><p><br></p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><h3 id="基于有向无循环图实现文件共享"><a href="#基于有向无循环图实现文件共享" class="headerlink" title="基于有向无循环图实现文件共享"></a>基于有向无循环图实现文件共享</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/063db2c4-3e1a-4042-985a-a4bc2c41e36a" style="width:80%"></div><p>此种方法存在问题：<br>比如对于文件<code>F8</code>，<code>D5:p</code>、<code>D6:e</code>、<code>D3:p</code>都保存了<code>F8</code>的物理地址，即从某个盘块开始，总长度多少等。此时如果<code>D6:e</code>对<code>F8</code>进行了删除操作，<code>D5:p</code>和<code>D3:P</code>都无法察觉，仍然会认为在它们存储的位置上有文件，即一个目录项对文件的操作对其他目录项来说是不可见的。</p><p><br></p><h3 id="利用索引节点"><a href="#利用索引节点" class="headerlink" title="利用索引节点"></a>利用索引节点</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/b49d3d0c-b042-4a62-8f43-40519ca0023b" style="width:60%"></div><p>引入索引结点，将文件的物理地址和其他的属性放在索引结点中，只在目录项中存放文件名和指向索引结点的指针。由任何用户对文件进行Append操作或修改，引起相应索引结点内容的改变。此种方法即Linux中的硬链接。</p><p><br></p><h3 id="利用符号链接实现文件共享"><a href="#利用符号链接实现文件共享" class="headerlink" title="利用符号链接实现文件共享"></a>利用符号链接实现文件共享</h3><p>建立符号链接文件，它是一种特殊类型的文件，其内容是被链接文件的路径名。建立符号链接文件，并不影响原文件，实际上它们各是一个文件。可以建立任意的别名关系，甚至原文件是在其他计算机上。只有文件主才有指向索引结点的指针，而其他共享用户只有该文件的路径名。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/dcb09a0e-6f1f-46da-a87b-9a8d3ef5e046"></div><p><br></p><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><h3 id="访问权-amp-保护域"><a href="#访问权-amp-保护域" class="headerlink" title="访问权&amp;保护域"></a>访问权&amp;保护域</h3><ul><li>访问权：一个进程能对某对象执行操作的权利，用&lt;对象名，权集&gt;表示，如<code>&lt;F1, {R/W}&gt;</code>表示进程对F1有读和写的权利。</li><li>保护域：进程对一组对象访问权的集合，进程只能在域内进行操作。</li></ul><p><br></p><h3 id="进程和域的联系方式"><a href="#进程和域的联系方式" class="headerlink" title="进程和域的联系方式"></a>进程和域的联系方式</h3><p>进程和域之间是一对多的关系，即一个进程可以联系多个域。此时进程的运行分为多个阶段，每个阶段联系一个域，这样就可以根据运行的实际需要规定进程每个阶段所能访问的对象。</p><p><br></p><h3 id="访问矩阵"><a href="#访问矩阵" class="headerlink" title="访问矩阵"></a>访问矩阵</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/bbf7a827-4fa5-4eac-9010-4012650b2ffd"></div><ul><li>R：在域内运行的进程对文件具有读权限</li><li>W：在域内运行的进程对文件具有写权限</li><li>$R^\ast$：在域内运行的进程能把其对文件的读权限扩展到其他域中，但在其他域中是R权限，不再是$R^\ast$。</li><li>$W^\ast$：在域内运行的进程能把其对文件的写权限扩展到其他域中，但在其他域中是W权限，不再是$W^\ast$。</li><li>S：在域Di中运行的进程能转移到域Dj中运行，如图中在域D3运行的进程能转移到域D2中运行。</li><li>O：在域中运行的进程能增加或删除对某文件的访问权。</li><li>Control：在域Di中运行的进程能删除在域Dj中运行进程对各对象的访问权。如图中在D2中运行的进程能删除在D3中运行进程的访问权。</li></ul><p><br></p><h3 id="访问矩阵的实现"><a href="#访问矩阵的实现" class="headerlink" title="访问矩阵的实现"></a>访问矩阵的实现</h3><p><strong>访问控制表</strong></p><p>将访问对象按列划分，为每一列建立一张访问控制表，在该表中把属于对象的所有空项都删除。此时表中的每一项都是一个有序对<code>&lt;域，权集&gt;</code>构成。</p><p><strong>访问权限表</strong></p><p>将访问矩阵按行划分，每一行是一个访问权限表，表中的每一项表示该域对某对象的访问权限。<br>文件管理的目标是管理文件的组织方式，管理文件的访问权等。而磁盘存储器的管理是管理存储器的使用，如何高效利用存储器。他俩是棋与棋盘的关系。</p><p><br></p><h2 id="连续组织方式"><a href="#连续组织方式" class="headerlink" title="连续组织方式"></a>连续组织方式</h2><p>文件的信息存放在若干连续的物理块中。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/d6f4358a-b197-4d60-a80c-d60b4e096bc8" style="width:70%"></div><ul><li>优点<ul><li>简单</li><li>支持顺序存取和随机存取</li><li>顺序存取速度快，所需的磁盘寻道次数和寻道时间最少</li></ul></li><li>缺点<ul><li>文件不能动态增长（预留空间：浪费、重新分配和移动）</li><li>不利于文件插入和删除</li><li>外部碎片问题</li></ul></li></ul><p><br></p><h2 id="链接组织方式"><a href="#链接组织方式" class="headerlink" title="链接组织方式"></a>链接组织方式</h2><h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>在文件的目录中记录该文件的第一和最后一个盘块的指针，每一个盘块的指针指向文件的下一物理块号。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/3c2e3657-42eb-4d81-9cf4-ea51597deeb9"></div><ul><li>优点<ul><li>文件可动态增长</li><li>有利于文件的插入和删除</li><li>提高了磁盘空间利用率,不存在外部碎片问题</li></ul></li><li>缺点<ul><li>存取速度慢，不适于随机存取</li><li>可靠性问题，如指针出错</li><li>更多的寻道次数和寻道时间</li><li>链接指针占用一定的空间</li></ul></li></ul><p><br></p><h3 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h3><p>将链接文件各物理块的指针显示地放在内存的一张链接表（文件分配表，File Allocation Table）中。在FCB的物理地址中填写其首指针所对应的盘块号。由于文件分配表示存储在内存中的，可以大大减少访问磁盘的次数。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/c6a74b5e-0bd6-4213-8fc6-98d18c1e05d3" style="width:70%"></div><p><br></p><h3 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h3><p>微软公司早、中期推出的操作系统一直都是采用的FAT技术，即利用文件分配表FAT来记录每个文件中所有盘块之间的链接。FAT中引入了“卷”的概念，支持将一个物理磁盘分成四个逻辑磁盘，每个逻辑磁盘就是一个卷（也称为分区），每个卷都可以被单独格式化和使用。把盘块作为基本分配单位，同时每个分区中都配有两张相同的文件分配表FAT1和FAT2。<br>FAT技术的发展有三个阶段：FAT12、FAT16和FAT32</p><p><strong>FAT12</strong></p><p>FAT表的每个表项占用12个bit。所以最多有$2^{12}$个表项，每个盘块的大小是512B，则每个磁盘分区的容量是2MB，能处理的磁盘最大容量是8MB。<br>为了增大FAT能管理的最大容量，引入了“簇”的概念，每个簇是一组相邻的扇区，这样如果分配时以簇为单位进行分配就能管理更大的磁盘容量，但是相应的簇内零头也会更大，降低磁盘的利用率。</p><p><strong>FAT16</strong></p><p>FAT表的每个表项占用16个bit。最多有$2^{16}$个表项。</p><p><strong>FAT32</strong></p><p>FAT表的每个表项占用32个bit。最多有$2^{32}$个表项。同时每个簇固定为4KB。所以最大可管理$4 \ast 2^{10} \ast 2^{32} = 2TB$大小的空间。</p><p><br></p><h2 id="索引组织方式"><a href="#索引组织方式" class="headerlink" title="索引组织方式"></a>索引组织方式</h2><h3 id="单级索引组织方式"><a href="#单级索引组织方式" class="headerlink" title="单级索引组织方式"></a>单级索引组织方式</h3><p>一个文件的信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构索引表，并将这些块的块号存放在一个索引表中。一个索引表就是磁盘块地址数组，其中第i个条目指向文件的第i块。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a1e85fd4-81bc-47e2-a25e-7efd96482df9" style="width:60%"></div>·<br><br><br><br><br>### 多级索引组织方式<br><br><br><div align="center"><img src="http://blogfileqiniu.isjinhao.site/3d242750-4183-4a06-9f11-38d1002c71e8"></div><p><br></p><h3 id="增量式索引组织方式"><a href="#增量式索引组织方式" class="headerlink" title="增量式索引组织方式"></a>增量式索引组织方式</h3><p>可以更好的满足大、中、小文件的组织。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/1982b12b-d189-41d1-abf2-024ebfb94ed9"></div><p><br></p><h2 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h2><p>文件存储空间的管理包括空闲块的组织分配和回收。</p><p><br></p><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>把一个连续未分配区域称为“空闲文件”，系统为所有空闲文件单独建立一个目录。表目内容：序号，第一个空白块号，空白块个数。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/57c8df64-d3ca-4136-8432-a9da5117dc0f"></div><ul><li>分配算法：内存管理中的首次适应算法、循环首次适应算法。</li><li>合并：空闲区邻接合并</li></ul><p><br></p><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>空闲盘块链：所有空闲盘块拉成一条链，分配时从头分配，回收时链接在尾部。<br>空闲盘区链：每个连续的盘块组成一个盘区，每个盘区包含本盘区的大小和下一个盘区的地址。</p><p><br></p><h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><p>用一串二进制位反映磁盘空间中分配使用情况，每个物理块对应一位，分配物理块为1，否则为0。申请物理块时，可以在位示图中查找为0的位，返回对应物理块号；归还时；将对应位转置0。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/d269b94c-777a-4ab3-a839-483808396ace"></div><p><br></p><h3 id="成组链接法（重点）"><a href="#成组链接法（重点）" class="headerlink" title="成组链接法（重点）"></a>成组链接法（重点）</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/c4490525-02ba-48a7-8662-6ae97c00ece7"></div><ul><li>把所有的空闲盘块按每n个一组分成m个组。</li><li>最后一个组放在内存的空闲盘块号栈中，其他组存在外存上。空闲盘块号栈是一个临界资源，只允许一个进程同时访问。</li><li>数据结构，一个size为n+1的栈。图上是一个倒着的的栈（栈底在上方，栈顶在下方）</li><li>一个n+1的栈实际可用盘块只有n（图上只有99个可用盘块），因为栈底是一个计数器，指示当前有多少个可用盘块，但是可用盘块中有一个是指向下一个组，即stack[1]指向下一个组。如果stack[1]==0表示此时是最后一组。</li><li>分配时从栈顶开始向下分配，直至分配出n-1个盘块，此时如果再想分配一个块就需要把下一个组调入空闲盘块号栈。调入后新组覆盖旧组。<strong>然后把新组在外存中占用的盘块分配出去。</strong></li><li>回收时从栈底向上回收，如果计数器==100时还有空闲盘块（设这个盘块编号为p）要回收，就把空闲盘块号栈内的组取出来存在p中，在空闲盘块号栈内新开辟一个组，新组的stack[1]指向p。</li></ul><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>此题题目及来源：<a href="https://blog.csdn.net/ajay666/article/details/73569654">https://blog.csdn.net/ajay666/article/details/73569654</a></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/fc7e0c9e-a0b5-42ae-a986-7fd6c42c7473"></div><p>分配3个盘块后，回收它所占的5个盘块，回收的盘块号依次为700、711、703、788、701，画出分配回收过程。</p><h5 id="第一次分配"><a href="#第一次分配" class="headerlink" title="第一次分配"></a>第一次分配</h5><div align="center"><img src="http://blogfileqiniu.isjinhao.site/2c6b8991-4667-4937-a800-6354c3a2893f"></div><h5 id="第二次分配"><a href="#第二次分配" class="headerlink" title="第二次分配"></a>第二次分配</h5><p>注意：300号盘块中存储的组信息调入空闲盘块号栈之后其自己也可以被分配。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/4f6799e5-a774-4141-ae40-30f0bdc4fc03"></div><h5 id="第三次分配"><a href="#第三次分配" class="headerlink" title="第三次分配"></a>第三次分配</h5><div align="center"><img src="http://blogfileqiniu.isjinhao.site/8954e673-34e3-422a-94cb-181adf554aef"></div><h5 id="第一次回收"><a href="#第一次回收" class="headerlink" title="第一次回收"></a>第一次回收</h5><div align="center"><img src="http://blogfileqiniu.isjinhao.site/9cc9d4da-b64d-46cb-87bb-6c77b94421cf"></div><h5 id="第二次回收"><a href="#第二次回收" class="headerlink" title="第二次回收"></a>第二次回收</h5><div align="center"><img src="http://blogfileqiniu.isjinhao.site/7cc820f8-0269-4c40-a50b-cb672cbc7d8a"></div><h5 id="第三次-amp-第四次-amp-第五次回收"><a href="#第三次-amp-第四次-amp-第五次回收" class="headerlink" title="第三次&amp;第四次&amp;第五次回收"></a>第三次&amp;第四次&amp;第五次回收</h5><div align="center"><img src="http://blogfileqiniu.isjinhao.site/4043faec-7325-4382-8de2-742f72598ae1"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;em&gt;外存管理分成两块，文件系统和磁盘管理&lt;/em&gt;&lt;/p&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;文件管理概述&quot;&gt;&lt;a href=&quot;#文件管理
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>html5_handle_camera_image</title>
    <link href="https://isjinhao.github.io/posts/1237.html/"/>
    <id>https://isjinhao.github.io/posts/1237.html/</id>
    <published>2019-12-17T02:48:41.000Z</published>
    <updated>2019-12-20T09:29:23.891Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="H5启用默认摄像头"><a href="#H5启用默认摄像头" class="headerlink" title="H5启用默认摄像头"></a>H5启用默认摄像头</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bootstrap/jquery-3.2.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"bootstrap/css/bootstrap.min.css"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bootstrap/holder.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> video = <span class="built_in">document</span>.getElementById(<span class="string">"video"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">/**</span></span><br><span class="line"><span class="undefined"> * constraints：打开摄像头时约束，下面的约束对video没有约束，它选择设备的默认摄像头，但是禁止了音频</span></span><br><span class="line"><span class="undefined"> */</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> constraints = &#123;</span></span><br><span class="line"><span class="undefined">       video: &#123;&#125;,</span></span><br><span class="line"><span class="javascript">       audio : <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> promise;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(navigator.mediaDevices.getUserMedia)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//最新标准API</span></span></span><br><span class="line"><span class="undefined">        promise = navigator.mediaDevices.getUserMedia(constraints);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.webkitGetUserMedia)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//webkit内核浏览器</span></span></span><br><span class="line"><span class="undefined">        promise = navigator.webkitGetUserMedia(constraints);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.mozGetUserMedia)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//Firefox浏览器</span></span></span><br><span class="line"><span class="undefined">        promise = navagator.mozGetUserMedia(constraints);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.getUserMedia)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//旧版API</span></span></span><br><span class="line"><span class="undefined">        promise = navigator.getUserMedia(constraints);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">MediaStream</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        video.srcObject = MediaStream;</span></span><br><span class="line"><span class="undefined">        video.play();</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">class</span>=<span class="string">"myvideo"</span> <span class="attr">style</span>=<span class="string">"border-radius: 10%;"</span> <span class="attr">id</span>=<span class="string">"video"</span> <span class="attr">autoplay</span>=<span class="string">"autoplay"</span> &gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><ul><li>上面的代码只能打开设备默认摄像头，在手机上会是前置摄像头。</li><li>此博文代码测试时间为<code>2019.4.7</code>。在开启摄像头这一块，不同的浏览器兼容性很差，而且标准进年来改动过大，很多的<code>API</code>都被弃用，所以不能使用时请勿喷。</li></ul><p><br></p><h2 id="H5启用手机后置摄像头"><a href="#H5启用手机后置摄像头" class="headerlink" title="H5启用手机后置摄像头"></a>H5启用手机后置摄像头</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bootstrap/jquery-3.2.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"bootstrap/css/bootstrap.min.css"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bootstrap/holder.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> video = <span class="built_in">document</span>.getElementById(<span class="string">"video"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">// 此API请求可用媒体输入和输出设备的列表，例如麦克风，摄像头，耳机等。</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> promoseDevs = navigator.mediaDevices.enumerateDevices();</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> exArray = [];</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">promoseDevs.then(<span class="function"><span class="keyword">function</span>(<span class="params">devices</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">        devices.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">dv</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">var</span> kind = dv.kind;</span></span><br><span class="line"><span class="undefined">            </span></span><br><span class="line"><span class="javascript">            <span class="comment">//我们需要的是摄像头，所以匹配video</span></span></span><br><span class="line"><span class="javascript">            <span class="keyword">if</span> (kind.match(<span class="regexp">/^video.*/</span>)) &#123;</span></span><br><span class="line"><span class="undefined">            exArray.push(dv.deviceId);</span></span><br><span class="line"><span class="javascript">                <span class="built_in">console</span>.log(dv);</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">            </span></span><br><span class="line"><span class="undefined">        &#125;);</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">    alert(<span class="string">"摄像头个数："</span> + exArray.length);</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">     <span class="comment">// 设置启用摄像头时的约束，在手机端约束摄像头为后置</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> constraints = &#123;</span></span><br><span class="line"><span class="undefined">    video: &#123;</span></span><br><span class="line"><span class="javascript">                        <span class="comment">// 如果电脑插入了多个摄像头，在这里可以进行选择</span></span></span><br><span class="line"><span class="undefined">    deviceId: exArray[exArray.length - 1]</span></span><br><span class="line"><span class="undefined">    &#125;,</span></span><br><span class="line"><span class="javascript">    audio : <span class="literal">false</span>  </span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> promise;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (navigator.mediaDevices.getUserMedia) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//最新的标准API</span></span></span><br><span class="line"><span class="undefined">        promise = navigator.mediaDevices.getUserMedia(constraints);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.webkitGetUserMedia) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//webkit核心浏览器</span></span></span><br><span class="line"><span class="undefined">        promise = navigator.webkitGetUserMedia(constraints, success, error)</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.mozGetUserMedia) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//firfox浏览器</span></span></span><br><span class="line"><span class="undefined">        promise = navigator.mozGetUserMedia(constraints, success, error);</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.getUserMedia) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//旧版API</span></span></span><br><span class="line"><span class="undefined">        promise = navigator.getUserMedia(constraints, success, error);</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">        </span></span><br><span class="line"><span class="javascript">        promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">MediaStream</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">            video.srcObject = MediaStream;</span></span><br><span class="line"><span class="undefined">            video.play();</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="undefined"> &#125;)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">class</span>=<span class="string">"myvideo"</span> <span class="attr">style</span>=<span class="string">"border-radius: 10%;"</span> <span class="attr">id</span>=<span class="string">"video"</span> <span class="attr">autoplay</span>=<span class="string">"autoplay"</span> &gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="H5实现图片预览"><a href="#H5实现图片预览" class="headerlink" title="H5实现图片预览"></a>H5实现图片预览</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bootstrap/jquery-3.2.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"bootstrap/css/bootstrap.min.css"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bootstrap/holder.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">select_file</span>(<span class="params">fileid</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">document</span>.getElementById(fileid).click();</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">//预览图片并获得图片的base64编码</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">imgPreview</span>(<span class="params">fileDom</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//判断是否支持FileReader</span></span></span><br><span class="line"><span class="undefined">    /**</span></span><br><span class="line"><span class="undefined">     * FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件</span></span><br><span class="line"><span class="undefined">     */</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (<span class="built_in">window</span>.FileReader) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> reader = <span class="keyword">new</span> FileReader();</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">"请更新您的浏览器！"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//获取文件</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> file = fileDom.files[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> imageType = <span class="regexp">/^image\//</span>;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//是否是图片</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (!imageType.test(file.type)) &#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">"请选择图片文件！"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span>;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    /*</span></span><br><span class="line"><span class="undefined">     * readAsDataURL 方法会读取指定的 Blob 或 File 对象。返回文件的base64编码</span></span><br><span class="line"><span class="undefined">     */</span></span><br><span class="line"><span class="undefined">    reader.readAsDataURL(file);</span></span><br><span class="line"><span class="undefined">    /**</span></span><br><span class="line"><span class="undefined">     * 当文件读取完成的时候会回调此函数，e就是获取的文件</span></span><br><span class="line"><span class="undefined">     */</span></span><br><span class="line"><span class="javascript">    reader.onload = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//获取图片dom</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">"img"</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">//e是获取的文件，reader.readAsDataURL(file);读取的Base64编码存放在target.result中</span></span></span><br><span class="line"><span class="undefined">        img.src = e.target.result;</span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"row"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"panel-title"</span> <span class="attr">style</span>=<span class="string">"text-align: center;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">class</span>=<span class="string">"hidden"</span> <span class="attr">id</span>=<span class="string">"image"</span> <span class="attr">onchange</span>=<span class="string">"imgPreview(this)"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">style</span>=<span class="string">"height: 200px; border-radius: 50%;"</span></span></span><br><span class="line"><span class="tag"><span class="attr">src</span>=<span class="string">"holder.js/300x300"</span> <span class="attr">onclick</span>=<span class="string">"select_file('image');"</span> <span class="attr">id</span>=<span class="string">"img"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="canvas把摄像头拍摄到的视频保存为图片"><a href="#canvas把摄像头拍摄到的视频保存为图片" class="headerlink" title="canvas把摄像头拍摄到的视频保存为图片"></a>canvas把摄像头拍摄到的视频保存为图片</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bootstrap/jquery-3.2.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"bootstrap/css/bootstrap.min.css"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bootstrap/holder.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> video = <span class="built_in">document</span>.getElementById(<span class="string">"video"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">/**</span></span><br><span class="line"><span class="undefined"> * constraints：打开摄像头时约束，下面的约束对video没有约束，它选择设备的默认摄像头，但是禁止了音频</span></span><br><span class="line"><span class="undefined"> */</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> constraints = &#123;</span></span><br><span class="line"><span class="undefined">       video: &#123;&#125;,</span></span><br><span class="line"><span class="javascript">       audio : <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> promise;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(navigator.mediaDevices.getUserMedia)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//最新标准API</span></span></span><br><span class="line"><span class="undefined">        promise = navigator.mediaDevices.getUserMedia(constraints);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.webkitGetUserMedia)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//webkit内核浏览器</span></span></span><br><span class="line"><span class="undefined">        promise = navigator.webkitGetUserMedia(constraints);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.mozGetUserMedia)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//Firefox浏览器</span></span></span><br><span class="line"><span class="undefined">        promise = navagator.mozGetUserMedia(constraints);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.getUserMedia)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//旧版API</span></span></span><br><span class="line"><span class="undefined">        promise = navigator.getUserMedia(constraints);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">MediaStream</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        video.srcObject = MediaStream;</span></span><br><span class="line"><span class="undefined">        video.play();</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">class</span>=<span class="string">"myvideo"</span> <span class="attr">style</span>=<span class="string">"border-radius: 10%;"</span> <span class="attr">id</span>=<span class="string">"video"</span> <span class="attr">autoplay</span>=<span class="string">"autoplay"</span> &gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span>画图<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"b"</span>);  </span></span><br><span class="line"><span class="javascript">    btn.onclick =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> c=<span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</span></span><br><span class="line"><span class="javascript">    ctx=c.getContext(<span class="string">'2d'</span>);</span></span><br><span class="line"><span class="undefined">        ctx.drawImage(video, 0, 0, 270, 135);</span></span><br><span class="line"><span class="undefined">    &#125;  </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>转化为file</strong></p><p>此标题中说的<code>file</code>是表单中<code>&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; /&gt;</code>。<br></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bootstrap/jquery-3.2.1.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"bootstrap/css/bootstrap.min.css"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bootstrap/holder.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"application/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="built_in">window</span>.onload=<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> video = <span class="built_in">document</span>.getElementById(<span class="string">"video"</span>);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">/**</span></span><br><span class="line"><span class="undefined"> * constraints：打开摄像头时约束，下面的约束对video没有约束，它选择设备的默认摄像头，但是禁止了音频</span></span><br><span class="line"><span class="undefined"> */</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> constraints = &#123;</span></span><br><span class="line"><span class="undefined">       video: &#123;&#125;,</span></span><br><span class="line"><span class="javascript">       audio : <span class="literal">false</span></span></span><br><span class="line"><span class="undefined">    &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> promise;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span>(navigator.mediaDevices.getUserMedia)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//最新标准API</span></span></span><br><span class="line"><span class="undefined">        promise = navigator.mediaDevices.getUserMedia(constraints);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.webkitGetUserMedia)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//webkit内核浏览器</span></span></span><br><span class="line"><span class="undefined">        promise = navigator.webkitGetUserMedia(constraints);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.mozGetUserMedia)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//Firefox浏览器</span></span></span><br><span class="line"><span class="undefined">        promise = navagator.mozGetUserMedia(constraints);</span></span><br><span class="line"><span class="javascript">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (navigator.getUserMedia)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">//旧版API</span></span></span><br><span class="line"><span class="undefined">        promise = navigator.getUserMedia(constraints);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    </span></span><br><span class="line"><span class="javascript">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">MediaStream</span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">        video.srcObject = MediaStream;</span></span><br><span class="line"><span class="undefined">        video.play();</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">getBase64</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">//获得Canvas对象</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> cas = <span class="built_in">document</span>.getElementById(<span class="string">"myCanvas"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> ctx = cas.getContext(<span class="string">"2d"</span>);</span></span><br><span class="line"><span class="javascript"><span class="keyword">let</span> video = <span class="built_in">document</span>.getElementById(<span class="string">"video"</span>);</span></span><br><span class="line"><span class="undefined">    ctx.drawImage(video, 0, 0, 500, 400);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> data = cas.toDataURL(<span class="string">'image/png'</span>, <span class="number">0.1</span>);<span class="comment">//1表示质量(无损压缩)</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> data;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//'file'  等价于   浏览本地文件上传时本地文件的名字</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">dataURLtoFile</span>(<span class="params">dataurl, filename = <span class="string">'file'</span></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">dataurl = dataurl + <span class="string">""</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> arr = dataurl.split(<span class="string">','</span>), mime = arr[<span class="number">0</span>].match(<span class="regexp">/:(.*?);/</span>)[<span class="number">1</span>],</span></span><br><span class="line"><span class="javascript">        bstr = atob(arr[<span class="number">1</span>]), n = bstr.length, u8arr = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(n);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">while</span>(n--)&#123;</span></span><br><span class="line"><span class="undefined">        u8arr[n] = bstr.charCodeAt(n);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="keyword">new</span> File([u8arr], filename, &#123;<span class="attr">type</span>:mime&#125;);</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">id</span>=<span class="string">"video"</span> <span class="attr">autoplay</span>=<span class="string">"autoplay"</span> &gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"b"</span>&gt;</span>画图<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">"myCanvas"</span> <span class="attr">width</span>=<span class="string">"500px"</span> <span class="attr">height</span>=<span class="string">"500px"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">"b"</span>);  </span></span><br><span class="line"><span class="javascript">    btn.onclick =<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(dataURLtoFile(getBase64()));</span></span><br><span class="line"><span class="undefined">    &#125;  </span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><a href="https://github.com/isjinhao/html5-handle-img">https://github.com/isjinhao/html5-handle-img</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;H5启用默认摄像头&quot;&gt;&lt;a href=&quot;#H5启用默认摄像头&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="前端" scheme="https://isjinhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://isjinhao.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>opencv实现人脸识别、人脸打框、人脸剪切</title>
    <link href="https://isjinhao.github.io/posts/38658.html/"/>
    <id>https://isjinhao.github.io/posts/38658.html/</id>
    <published>2019-12-17T02:48:41.000Z</published>
    <updated>2019-12-20T09:29:23.898Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="Opencv在各平台上的配置"><a href="#Opencv在各平台上的配置" class="headerlink" title="Opencv在各平台上的配置"></a>Opencv在各平台上的配置</h2><p><a href="https://opencv-java-tutorials.readthedocs.io/en/latest/01-installing-opencv-for-java.html。">https://opencv-java-tutorials.readthedocs.io/en/latest/01-installing-opencv-for-java.html。</a><br>下面的代码使用opencv3.4.5</p><p><br></p><h2 id="测试图片"><a href="#测试图片" class="headerlink" title="测试图片"></a>测试图片</h2><div align="center"><img src="http://blogfileqiniu.isjinhao.site/475f4c0c-dbef-4a66-88fd-3ed9f781886f"></div><p><br></p><h2 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h2><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Core;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Mat;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.MatOfRect;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Rect;</span><br><span class="line"><span class="keyword">import</span> org.opencv.imgcodecs.Imgcodecs;</span><br><span class="line"><span class="keyword">import</span> org.opencv.objdetect.CascadeClassifier;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetImgFace</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String classifier = <span class="string">"D:/opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">// 必须要加载Opencv的Library</span></span><br><span class="line">System.loadLibrary(Core.NATIVE_LIBRARY_NAME);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图片路径不能有中文...</span></span><br><span class="line">GetImgFace.getImgFace(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\test.jpg"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Rect&gt; <span class="title">getImgFace</span><span class="params">(String imgPath)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 加载分类器，选择已经训练好的opencv分类器，训练器路径：%OPENCV_HOME%/sources/data/haarcascades/</span></span><br><span class="line"><span class="comment">  * 分类器包含眼睛，人脸，人体，微笑等等，其中对于仅仅识别人脸来说，最好的训练器是：</span></span><br><span class="line"><span class="comment">  * haarcascade_frontalface_default.xml</span></span><br><span class="line"><span class="comment">  * haarcascade_frontalface_alt.xml</span></span><br><span class="line"><span class="comment">  * haarcascade_frontalface_alt2.xml</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类器路径不要有中文...</span></span><br><span class="line">CascadeClassifier faceDetector = <span class="keyword">new</span> CascadeClassifier(classifier);</span><br><span class="line"><span class="keyword">if</span> (faceDetector.empty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"请选择正确的分类器！"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建Mat，Mat是用来保存图片信息的类。Imgcodecs是用来读取图片的工具类</span></span><br><span class="line">Mat image = Imgcodecs.imread(imgPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测人脸，检测结果存在faceDetections中</span></span><br><span class="line">MatOfRect faceDetections = <span class="keyword">new</span> MatOfRect();</span><br><span class="line">faceDetector.detectMultiScale(image, faceDetections);</span><br><span class="line">List&lt;Rect&gt; faceList = Arrays.asList(faceDetections.toArray());</span><br><span class="line">System.out.println(faceList);</span><br><span class="line"><span class="keyword">return</span> faceList;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e4b50851-240f-4ca4-909b-906b949115da"></div><p><br></p><h2 id="人脸打框"><a href="#人脸打框" class="headerlink" title="人脸打框"></a>人脸打框</h2><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Mat;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Point;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Rect;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Scalar;</span><br><span class="line"><span class="keyword">import</span> org.opencv.imgcodecs.Imgcodecs;</span><br><span class="line"><span class="keyword">import</span> org.opencv.imgproc.Imgproc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FaceRect</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String imgPath = <span class="string">"C:\\Users\\ISJINHAO\\Desktop\\test.jpg"</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Rect&gt; faceRects = GetImgFace.getImgFace(imgPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把识别出来的图片分别打框</span></span><br><span class="line">Iterator&lt;Rect&gt; iterator1 = faceRects.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator1.hasNext()) &#123;</span><br><span class="line">Rect rect = iterator1.next();</span><br><span class="line">FaceRect.imageMark(imgPath, <span class="string">"D:\\test\\"</span> + UUID.randomUUID() + <span class="string">".jpg"</span>, rect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在一张图片中把所有识别出来的人脸都打框</span></span><br><span class="line">Mat image = Imgcodecs.imread(imgPath);</span><br><span class="line">Iterator&lt;Rect&gt; iterator2 = faceRects.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator2.hasNext()) &#123;</span><br><span class="line">Rect rect = iterator2.next();</span><br><span class="line">Imgproc.rectangle(image, <span class="keyword">new</span> Point(rect.x, rect.y), <span class="comment">// 左上点</span></span><br><span class="line"><span class="keyword">new</span> Point(rect.x + rect.width, rect.y + rect.height), <span class="comment">// 右下点</span></span><br><span class="line"><span class="keyword">new</span> Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>); <span class="comment">// 框的颜色和粗细</span></span><br><span class="line">&#125;</span><br><span class="line">Imgcodecs.imwrite(<span class="string">"D:\\test\\"</span> + UUID.randomUUID() + <span class="string">".jpg"</span>, image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">imageMark</span><span class="params">(String imagePath, String outFilePath, Rect rect)</span> </span>&#123;</span><br><span class="line">Mat image = Imgcodecs.imread(imagePath);<span class="comment">// 原始图片</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Imgproc.rectangle的作用是在修改image中的数据，把相应的位置打上框</span></span><br><span class="line">Imgproc.rectangle(image, <span class="keyword">new</span> Point(rect.x, rect.y), <span class="comment">// 左上点</span></span><br><span class="line"><span class="keyword">new</span> Point(rect.x + rect.width, rect.y + rect.height), <span class="comment">// 右下点</span></span><br><span class="line"><span class="keyword">new</span> Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>); <span class="comment">// 框的颜色和粗细</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把mat写入图片</span></span><br><span class="line">Imgcodecs.imwrite(outFilePath, image);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> File(outFilePath);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/8c536395-fde0-4623-9f60-b774f185df2a"></div><p><br></p><h2 id="人脸剪切"><a href="#人脸剪切" class="headerlink" title="人脸剪切"></a>人脸剪切</h2><p><strong>代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Mat;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Rect;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Size;</span><br><span class="line"><span class="keyword">import</span> org.opencv.imgcodecs.Imgcodecs;</span><br><span class="line"><span class="keyword">import</span> org.opencv.imgproc.Imgproc;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FaceCut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String imgPath = <span class="string">"C:\\Users\\ISJINHAO\\Desktop\\test.jpg"</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Rect&gt; faceRects = GetImgFace.getImgFace(imgPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把识别出来的图片分别打框</span></span><br><span class="line">Iterator&lt;Rect&gt; iterator1 = faceRects.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator1.hasNext()) &#123;</span><br><span class="line">Rect rect = iterator1.next();</span><br><span class="line">FaceCut.imageCut(imgPath, <span class="string">"D:\\test\\"</span> + UUID.randomUUID() + <span class="string">".jpg"</span>, rect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">imageCut</span><span class="params">(String imagePath, String outFilePath, Rect rect)</span> </span>&#123;</span><br><span class="line">Mat image = Imgcodecs.imread(imagePath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照原始图片中的人脸提取出来</span></span><br><span class="line">Mat sub = image.submat(rect);</span><br><span class="line">Mat mat = <span class="keyword">new</span> Mat();</span><br><span class="line">Size size = <span class="keyword">new</span> Size(rect.width, rect.height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改提取出来的人脸信息sub在坐标轴的位置。</span></span><br><span class="line">Imgproc.resize(sub, mat, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将截图保存</span></span><br><span class="line">Imgcodecs.imwrite(outFilePath, mat);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> File(outFilePath);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a966abaa-95c7-4e78-9eac-b8d1d8ee9859"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;Opencv在各平台上的配置&quot;&gt;&lt;a href=&quot;#Opencv在各平台上的配置&quot; class=&quot;headerl
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>仅使用Servlet3完成文件上传下载</title>
    <link href="https://isjinhao.github.io/posts/36072.html/"/>
    <id>https://isjinhao.github.io/posts/36072.html/</id>
    <published>2019-12-17T02:48:41.000Z</published>
    <updated>2019-12-20T09:29:23.906Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="上传文件的html界面"><a href="#上传文件的html界面" class="headerlink" title="上传文件的html界面"></a>上传文件的html界面</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>单文件上传<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/servlet3-upload-and-download/uploadone"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"upload"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>多文件上传<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/servlet3-upload-and-download/uploadmany"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"upload"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>文件下载<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/servlet3-upload-and-download/download"</span>&gt;</span>点击下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> download;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/download"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">download</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">resp.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//filepath</span></span><br><span class="line">String filePath = <span class="string">"D:\\我.jpg"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>(</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(filePath));</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(resp.getOutputStream());</span><br><span class="line"></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> fileLength = <span class="keyword">new</span> File(filePath).length();</span><br><span class="line">resp.setHeader(<span class="string">"Content-disposition"</span>, <span class="string">"attachment; filename="</span> + <span class="keyword">new</span> String(<span class="keyword">new</span> File(filePath).getName().getBytes(<span class="string">"utf-8"</span>), <span class="string">"ISO8859-1"</span>));</span><br><span class="line">resp.setHeader(<span class="string">"Content-Length"</span>, String.valueOf(fileLength));</span><br><span class="line"><span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line"><span class="keyword">int</span> bytesRead;</span><br><span class="line"><span class="keyword">while</span> (-<span class="number">1</span> != (bytesRead = bis.read(buff, <span class="number">0</span>, buff.length))) &#123;</span><br><span class="line">bos.write(buff, <span class="number">0</span>, bytesRead);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">doGet(req, resp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><h3 id="单文件"><a href="#单文件" class="headerlink" title="单文件"></a>单文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> upload;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.MultipartConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Part;</span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/uploadone"</span>)</span><br><span class="line"><span class="meta">@MultipartConfig</span><span class="comment">//Servlet3中处理multipart/form-data类型请求的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadOne</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.doPost(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line"><span class="comment">//说明输入的请求信息采用UTF-8编码方式</span></span><br><span class="line">request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">response.setContentType(<span class="string">"text/html; charset=UTF-8"</span>);</span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Servlet3.0中新引入的方法，用来处理multipart/form-data类型编码的表单</span></span><br><span class="line">Part part = request.getPart(<span class="string">"file"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取HTTP头信息headerInfo=（form-data; name="file" filename="文件名"）</span></span><br><span class="line">String headerInfo = part.getHeader(<span class="string">"content-disposition"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"headinfo  ==&gt;  "</span> + headerInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从HTTP头信息中获取文件名fileName=（文件名）</span></span><br><span class="line">String fileName = headerInfo.substring(headerInfo.lastIndexOf(<span class="string">"="</span>) + <span class="number">2</span>, headerInfo.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得存储上传文件的文件夹路径</span></span><br><span class="line">String fileSavingFolder = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">"/upload"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得存储上传文件的完整路径（文件夹路径+文件名）</span></span><br><span class="line"><span class="comment">//文件夹位置固定，文件夹采用与上传文件的原始名字相同</span></span><br><span class="line">String fileSavingPath = fileSavingFolder + File.separator + fileName;</span><br><span class="line">System.out.println(<span class="string">"filePath  ==&gt;  "</span> + fileSavingPath);</span><br><span class="line"><span class="comment">//如果存储上传文件的文件夹不存在，则创建文件夹</span></span><br><span class="line">File f = <span class="keyword">new</span> File(fileSavingFolder + File.separator);</span><br><span class="line"><span class="keyword">if</span>(!f.exists())&#123;</span><br><span class="line">f.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将上传的文件内容写入服务器文件中</span></span><br><span class="line">part.write(fileSavingPath);</span><br><span class="line"><span class="comment">//输出上传成功信息</span></span><br><span class="line">out.println(<span class="string">"文件上传成功~！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="多文件"><a href="#多文件" class="headerlink" title="多文件"></a>多文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> upload;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.MultipartConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Part;</span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/uploadmany"</span>)</span><br><span class="line"><span class="meta">@MultipartConfig</span><span class="comment">//Servlet3中处理multipart/form-data类型请求的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadMany</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.doPost(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line"><span class="comment">//说明输入的请求信息采用UTF-8编码方式</span></span><br><span class="line">request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">response.setContentType(<span class="string">"text/html; charset=UTF-8"</span>);</span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Servlet3.0中新引入的方法，用来处理multipart/form-data类型编码的表单</span></span><br><span class="line">Collection&lt;Part&gt; parts = request.getParts();</span><br><span class="line">Iterator&lt;Part&gt; iterator = parts.iterator();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得存储上传文件的文件夹路径</span></span><br><span class="line">String fileSavingFolder = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">"/upload"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">Part next = iterator.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得文件大小</span></span><br><span class="line"><span class="keyword">long</span> size = next.getSize();</span><br><span class="line"></span><br><span class="line">System.out.println(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取HTTP头信息headerInfo=（form-data; name="file" filename="文件名"）</span></span><br><span class="line">String headerInfo = next.getHeader(<span class="string">"content-disposition"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"headinfo  ==&gt;  "</span> + headerInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从HTTP头信息中获取文件名fileName=（文件名）</span></span><br><span class="line">String fileName = headerInfo.substring(headerInfo.lastIndexOf(<span class="string">"="</span>) + <span class="number">2</span>, headerInfo.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得存储上传文件的完整路径（文件夹路径+文件名）</span></span><br><span class="line"><span class="comment">//文件夹位置固定，文件夹采用与上传文件的原始名字相同</span></span><br><span class="line">String fileSavingPath = fileSavingFolder + File.separator + fileName;</span><br><span class="line">System.out.println(<span class="string">"filePath  ==&gt;  "</span> + fileSavingPath);</span><br><span class="line"><span class="comment">//如果存储上传文件的文件夹不存在，则创建文件夹</span></span><br><span class="line">File f = <span class="keyword">new</span> File(fileSavingFolder + File.separator);</span><br><span class="line"><span class="keyword">if</span>(!f.exists())&#123;</span><br><span class="line">f.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将上传的文件内容写入服务器文件中</span></span><br><span class="line">next.write(fileSavingPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出上传成功信息</span></span><br><span class="line">out.println(<span class="string">"文件上传成功~！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo下载：<a href="https://github.com/isjinhao/servlet3-upload-and-download。">https://github.com/isjinhao/servlet3-upload-and-download。</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;上传文件的html界面&quot;&gt;&lt;a href=&quot;#上传文件的html界面&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="Servlet" scheme="https://isjinhao.github.io/tags/Servlet/"/>
    
  </entry>
  
  <entry>
    <title>动态代理</title>
    <link href="https://isjinhao.github.io/posts/41590.html/"/>
    <id>https://isjinhao.github.io/posts/41590.html/</id>
    <published>2019-12-17T02:48:41.000Z</published>
    <updated>2019-12-20T09:29:23.909Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="理解代理"><a href="#理解代理" class="headerlink" title="理解代理"></a>理解代理</h2><p>代理这个词对于广告满天飞的现代社会应该是很常见了，和它具有相同意义还有中介、经纪人等词。我们就以找影视明星拍片为例来理解代理。<br>假如你有一个很好的剧本，现在想找A明星来做主角，可以两种方式：第一种是直接找A明星本人，第二种是找A明星的经纪人。但是明星的主要功能是拍戏，如果诸如报酬、档期、宣传等工作也让A明星来负责，势必会减少他/她的拍戏时间，所以更好的方式是去寻求他/她的经纪人，让经纪人来做这些拍戏以外的工作。<br>但同时经济人也得有和明星A一样的功能，比如A会演戏、唱歌、跳舞，那么经纪人也得有这些功能，只不过经纪人的功能是让明星A去完成的，经纪人本身只提供这种服务的接口。而我们所说的明星A便是目标对象，经纪人便是代理对象。<br>对于Java中的代理，假如有一个方法（设为M1）的功能是把UTF-8编码下的字符转化成GBK编码下的字符。那么这个方法的功能就是进行转化、对于判断传入的是不是UTF-8编码下的字符这种事情应该传入之前就处理完成，所以这时候就要有一个代理方法（设为M2）在M1执行之前做个处理。当然M1执行完毕之后也可能存在M3进行一些处理。</p><p><br></p><h3 id="代理对象的要点"><a href="#代理对象的要点" class="headerlink" title="代理对象的要点"></a>代理对象的要点</h3><blockquote><ol><li>代理对象存在的价值主要用于拦截对目标对象的访问。</li><li>代理对象应该具有和目标对象相同的方法。</li></ol></blockquote><p><br></p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><p>在我们刚才的解释中，每个目标对象都要有一个实在的代理对象，这在实际开发中是很耗费精力的一件事，但如果说能在程序运行期间给我们动态生成一个代理对象可以大大减小编写的代码的压力。所以动态代理的概念就是：不用手动编写一个代理对象，不需要编写与目标对象相同的方法，运行时在内存中<strong>动态生成代理对象</strong>（字节码对象级别的代理对象）。</p><p><br></p><h2 id="JDK提供的动态代理"><a href="#JDK提供的动态代理" class="headerlink" title="JDK提供的动态代理"></a>JDK提供的动态代理</h2><p>JDK1.5之后为我们提供了用于专用于动态生成代理对象的类：java.lang.reflect.Proxy。有一个很重要的静态方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object newProxyInstance</span><br><span class="line">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHander h)</span><br></pre></td></tr></table></figure><p></p><p>在解释参数之前，我们先看一个接口InvocationHander，JDK对它的解释是：</p><blockquote><p>Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the method of its invocation handler.（每个代理实例都有一个关联的调用处理程序。当在代理实例上调用方法时，将方法调用编码并调度到其调用处理程序的方法。） 它只有一个invoke()方法。我们之后执行时真正起作用的也是这个方法。<br><code>public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;</code><br>对<code>newProxyInstance()</code>方法参数的解释在下面的例子中。</p><ul><li>明星接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BrightStar</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">dancing</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ShootFilm</span><span class="params">(String filmName)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><ul><li><p>A明星类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StarA</span> <span class="keyword">implements</span> <span class="title">BrightStar</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"A is singing..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">dancing</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Hai cao wu"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">ShootFilm</span><span class="params">(String filmName)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> filmName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试动态代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">StarA starA = <span class="keyword">new</span> StarA();</span><br><span class="line">BrightStar newProxyInstance = (BrightStar)Proxy.newProxyInstance(</span><br><span class="line"><span class="comment">//代理类的类加载器，获取目标类加载器即可</span></span><br><span class="line">StarA.class.getClassLoader(), </span><br><span class="line"><span class="comment">//代理类应该实现的接口，由于代理类和目标类需要继承相同的接口，使用目标类的接口即可</span></span><br><span class="line">StarA.class.getInterfaces(), </span><br><span class="line"><span class="comment">//使用匿名内部类传入InvocationHandler的实例</span></span><br><span class="line"><span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * proxy：传入代理对象。</span></span><br><span class="line"><span class="comment"> * method：被执行的方法。</span></span><br><span class="line"><span class="comment"> * args：传入的参数。</span></span><br><span class="line"><span class="comment"> * 例子：newProxyInstance.ShootFilm("我不是药神");</span></span><br><span class="line"><span class="comment"> * proxy：newProxyInstance；      method：ShootFilm；       args："我不是药神"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="comment">//执行前的操作</span></span><br><span class="line">System.out.println(<span class="string">"before"</span>);</span><br><span class="line">Object invoke = method.invoke(starA, args);</span><br><span class="line"><span class="comment">//执行后的操作</span></span><br><span class="line">System.out.println(<span class="string">"after"</span>);</span><br><span class="line"><span class="keyword">return</span> invoke;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用方法</span></span><br><span class="line">newProxyInstance.sing();</span><br><span class="line">System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">String dancing = newProxyInstance.dancing();</span><br><span class="line">System.out.println(dancing);</span><br><span class="line">System.out.println(<span class="string">"------------------------------------"</span>);</span><br><span class="line">String film = newProxyInstance.ShootFilm(<span class="string">"我不是药神"</span>);</span><br><span class="line">System.out.println(film);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> Console : </span></span><br><span class="line"><span class="comment"> before</span></span><br><span class="line"><span class="comment">A is singing...</span></span><br><span class="line"><span class="comment">after</span></span><br><span class="line"><span class="comment">------------------------------------</span></span><br><span class="line"><span class="comment">before</span></span><br><span class="line"><span class="comment">after</span></span><br><span class="line"><span class="comment">Hai cao wu</span></span><br><span class="line"><span class="comment">------------------------------------</span></span><br><span class="line"><span class="comment">before</span></span><br><span class="line"><span class="comment">after</span></span><br><span class="line"><span class="comment">我不是药神</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>下面介绍一个经典案例，使用动态代理解决Web工程的全局编码问题。</p><ul><li><p>前端代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert_Title_Here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--主体部分--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>get方式<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/ProxySolveCoding/test"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"text"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>post方式<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/ProxySolveCoding/test"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">type</span>=<span class="string">"text"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Servlet</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">String name = request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">System.out.println(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">doGet(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>filter</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(urlPatterns=<span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterCoding</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line"><span class="keyword">final</span> HttpServletRequest req = (HttpServletRequest)request;</span><br><span class="line">HttpServletRequest proReq = (HttpServletRequest)Proxy.newProxyInstance(</span><br><span class="line">req.getClass().getClassLoader(),</span><br><span class="line">req.getClass().getInterfaces(),</span><br><span class="line"><span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(method.getName().equalsIgnoreCase(<span class="string">"getParameter"</span>)) &#123;</span><br><span class="line">String gm = req.getMethod();</span><br><span class="line"><span class="keyword">if</span>(gm.equalsIgnoreCase(<span class="string">"get"</span>)) &#123;</span><br><span class="line"><span class="comment">//处理get方式的请求</span></span><br><span class="line">String before = (String) method.invoke(req, args);</span><br><span class="line">System.out.println(before);</span><br><span class="line">String after = <span class="keyword">new</span> String(before.getBytes(<span class="string">"iso-8859-1"</span>), <span class="string">"utf-8"</span>);</span><br><span class="line"><span class="keyword">return</span> after;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//处理post形式的请求</span></span><br><span class="line">req.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> method.invoke(req, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">chain.doFilter(proReq, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>JDK动态代理的特点</strong></p><p>能被代理的对象必须存在接口，否则会报错。且被增强的方法一定是在接口中有相同的方法签名。因为它生成代理对象的方式是拿到类的所有接口，然后根据这些接口和我们实现的<code>InvocationHandler</code>中的<code>invoke()</code>动态创建一个对象。</p><p><br></p><h2 id="Cglib概述"><a href="#Cglib概述" class="headerlink" title="Cglib概述"></a>Cglib概述</h2><p>是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。它是第三方实现的，所以需要导入<code>jar</code>包。</p><p><strong>特点</strong></p><p>和JDK提供的动态代理相比，Cglib更加灵活，不需要类上存在接口，因为它生成代理对象是通过现有的类派生出一个子类，在子类中加入我们新的条件。所以被代理的类不能使用final修饰。</p><p><strong>使用的例子</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"HelloWorld"</span>)</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"保存..."</span>);&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">talk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"接口中没有我"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"UserDaoImpl [name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> com.spring.secondday.UserDao;</span><br><span class="line"><span class="keyword">import</span> com.spring.secondday.UserDaoImpl;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> UserDao ud;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CglibProxy</span><span class="params">(UserDao ud)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.ud = ud;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> UserDaoImpl <span class="title">getProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">Enhancer en = <span class="keyword">new</span> Enhancer();</span><br><span class="line">en.setSuperclass(ud.getClass());</span><br><span class="line">en.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line"><span class="comment">//proxy：被代理的对象   m：被增强的方法   args：方法所需的参数  methodProxy：增强后的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method m, Object[] args, MethodProxy methodProxy)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"before"</span>);</span><br><span class="line">Object super1 = methodProxy.invokeSuper(proxy, args);</span><br><span class="line">System.out.println(<span class="string">"after"</span>);</span><br><span class="line"><span class="keyword">return</span> super1;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">UserDaoImpl proxy = (UserDaoImpl)en.create();</span><br><span class="line"><span class="keyword">return</span> proxy;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">UserDaoImpl ud = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">UserDaoImpl proxy = <span class="keyword">new</span> CglibProxy(ud).getProxy();</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment"> before</span></span><br><span class="line"><span class="comment">接口中没有我</span></span><br><span class="line"><span class="comment">after */</span></span><br><span class="line">proxy.talk();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;理解代理&quot;&gt;&lt;a href=&quot;#理解代理&quot; class=&quot;headerlink&quot; title=&quot;理解代理&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于winpcap的cpp控制台网络协议分析</title>
    <link href="https://isjinhao.github.io/posts/38170.html/"/>
    <id>https://isjinhao.github.io/posts/38170.html/</id>
    <published>2019-12-17T02:48:41.000Z</published>
    <updated>2019-12-20T09:29:23.912Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h3><ul><li>winpcap4.1.3</li><li>vs2015</li></ul><p><br></p><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><ul><li><code>新建项目-&gt;Visual C++项目-&gt;Win32控制台项目</code>，在<code>Win32应用程序向导</code>窗口中的<code>应用程序设置-&gt;附加选项</code>选中<code>空项目</code>。</li><li>将<code>WinPcap</code>开发包中的Include和Lib两个文件夹复制到新建项目所在文件夹下。</li><li>点击项目，右击，然后点击属性<ul><li><code>C/C++-&gt;常规-&gt;附加包含目录</code>：如 ..\include</li><li><code>链接器-&gt;常规-&gt;附加库目录</code>：如 ..\lib</li><li><code>链接器-&gt;输入-&gt;附加依赖项</code>：wpcap.lib（winpcap的包），ws2_32.lib（windows的socket）</li></ul></li></ul><p><br></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pcap.h"</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">eth_address</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_char byte1;</span><br><span class="line">u_char byte2;</span><br><span class="line">u_char byte3;</span><br><span class="line">u_char byte4;</span><br><span class="line">u_char byte5;</span><br><span class="line">u_char byte6;</span><br><span class="line">&#125;eth_address;</span><br><span class="line"><span class="comment">/* 4 bytes IP address */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_address</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_char byte1;</span><br><span class="line">u_char byte2;</span><br><span class="line">u_char byte3;</span><br><span class="line">u_char byte4;</span><br><span class="line">&#125;ip_address;</span><br><span class="line"><span class="comment">/* IPv4 header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_charver_ihl;<span class="comment">// Version (4 bits) + Internet header length (4 bits)</span></span><br><span class="line">u_chartos;<span class="comment">// Type of service </span></span><br><span class="line">u_short tlen;<span class="comment">// Total length </span></span><br><span class="line">u_short identification; <span class="comment">// Identification</span></span><br><span class="line">u_short flags_fo;<span class="comment">// Flags (3 bits) + Fragment offset (13 bits)</span></span><br><span class="line">u_charttl;<span class="comment">// Time to live</span></span><br><span class="line">u_charproto;<span class="comment">// Protocol</span></span><br><span class="line">u_short crc;<span class="comment">// Header checksum</span></span><br><span class="line">ip_addresssaddr;<span class="comment">// Source address</span></span><br><span class="line">ip_addressdaddr;<span class="comment">// Destination address</span></span><br><span class="line">u_intop_pad;<span class="comment">// Option + Padding</span></span><br><span class="line">&#125;ip_header;</span><br><span class="line"><span class="comment">/* UDP header*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">udp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_short sport;<span class="comment">// Source port</span></span><br><span class="line">u_short dport;<span class="comment">// Destination port</span></span><br><span class="line">u_short len;<span class="comment">// Datagram length</span></span><br><span class="line">u_short crc;<span class="comment">// Checksum</span></span><br><span class="line">&#125;udp_header;</span><br><span class="line"><span class="comment">/* MAC header*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">eth_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">eth_address daddr;</span><br><span class="line">eth_address saddr;</span><br><span class="line">u_short type;</span><br><span class="line">&#125;eth_header;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_short hardtype;<span class="comment">//硬件类型字段</span></span><br><span class="line">u_short prototype;<span class="comment">//协议类型字段</span></span><br><span class="line">u_char htlen;<span class="comment">//硬件地址的长度,以字节为单位.对于以太网上IP地址的ARP请求或应答来说,它们的值为6</span></span><br><span class="line">u_char ptlen;<span class="comment">//协议地址的长度,以字节为单位.对于以太网上IP地址的ARP请求或应答来说,它们的值为4</span></span><br><span class="line">u_short op;<span class="comment">//操作字段</span></span><br><span class="line">eth_address arp_esa;<span class="comment">//发送端MAC地址</span></span><br><span class="line">ip_address arp_isa;<span class="comment">//发送端IP地址</span></span><br><span class="line">eth_address arp_eda;<span class="comment">//目的端MAC地址</span></span><br><span class="line">ip_address arp_ida;<span class="comment">//目的端IP地址</span></span><br><span class="line">&#125;arp_header;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">icmp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_char type;<span class="comment">//ICMP报文类型</span></span><br><span class="line">u_char code;<span class="comment">//代码</span></span><br><span class="line">u_short checksum;<span class="comment">//校验和</span></span><br><span class="line">u_short identifier;<span class="comment">//标识符</span></span><br><span class="line">u_short sequence_number;<span class="comment">//序列号</span></span><br><span class="line">&#125;icmp_header;</span><br><span class="line"><span class="comment">/* TCP header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_shortsport;<span class="comment">//源端口</span></span><br><span class="line">u_short dport;<span class="comment">//目的端口</span></span><br><span class="line">u_long  sequence_number;<span class="comment">//序号（4字节ntohl）  </span></span><br><span class="line">u_long  acknowlegement_number;<span class="comment">//确认号</span></span><br><span class="line">u_short hlen_bl_flags;<span class="comment">//数据偏移+保留+控制位</span></span><br><span class="line">u_short window_size;<span class="comment">//窗口（发送方自己的接收窗口）</span></span><br><span class="line">u_short checksum;<span class="comment">//检验和（首部+数据）</span></span><br><span class="line">u_short urg;<span class="comment">//紧急指针</span></span><br><span class="line">u_long  option;<span class="comment">//可选+填充</span></span><br><span class="line">&#125;tcp_header;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dns_packet</span> //报文<span class="title">head</span>+<span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u_short id;<span class="comment">//每一个占2个字节，共12个字节</span></span><br><span class="line">    u_short flags;<span class="comment">//标志第一个为0代表查询报文</span></span><br><span class="line">    u_short ques;</span><br><span class="line">    u_short answer;</span><br><span class="line">    u_short author;</span><br><span class="line">    u_short addition;</span><br><span class="line">    u_char dns_data;<span class="comment">//查询问题部分</span></span><br><span class="line">&#125;dns_packet;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pcap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers.c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DNSPORT 53</span></span><br><span class="line"><span class="comment">//输出基本信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintBaseInfo</span><span class="params">(<span class="keyword">const</span> struct pcap_pkthdr *header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">ltime</span>;</span></span><br><span class="line"><span class="keyword">char</span> timestr[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">time_t</span> local_tv_sec;</span><br><span class="line"></span><br><span class="line">local_tv_sec = header-&gt;ts.tv_sec;</span><br><span class="line">ltime=localtime(&amp;local_tv_sec);</span><br><span class="line">strftime(timestr, <span class="keyword">sizeof</span> timestr, <span class="string">"%H:%M:%S"</span>, ltime);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n\n\n监听到Mac帧的时间：%s   MAC帧长度:%d Byte(s)\n"</span>, timestr, header-&gt;len * <span class="number">4</span>);  <span class="comment">/* 以四字节为单位 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出硬件地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintEthAddress</span><span class="params">(eth_address eth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02X:%02X:%02X:%02X:%02X:%02X"</span>, </span><br><span class="line">eth.byte1,</span><br><span class="line">eth.byte2,</span><br><span class="line">eth.byte3,</span><br><span class="line">eth.byte4,</span><br><span class="line">eth.byte5,</span><br><span class="line">eth.byte6</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出IP地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintIPAddress</span><span class="params">(ip_address ia)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d.%d.%d.%d"</span>, </span><br><span class="line">ia.byte1,</span><br><span class="line">ia.byte2,</span><br><span class="line">ia.byte3,</span><br><span class="line">ia.byte4</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出网络层协议类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintNetType</span><span class="params">(u_short type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"网络层协议： "</span>);</span><br><span class="line"><span class="keyword">if</span>(type==<span class="number">0x0800</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"IP协议"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">0x0806</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ARP协议"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">0x8035</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"RARP协议"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"接收到非本程序能处理的网络层协议类型！"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析Mac帧：</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">网络层协议类型：源MAC -&gt; 目的MAC</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">网络层协议类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u_short <span class="title">handleMac</span><span class="params">(eth_header *eth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short type=ntohs(eth-&gt;type);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Mac地址： "</span>);</span><br><span class="line">myPrintEthAddress(eth-&gt;saddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-&gt;"</span>);</span><br><span class="line">myPrintEthAddress(eth-&gt;daddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleARPAndRARP</span><span class="params">(arp_header *ah)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short arp_ht;<span class="comment">//硬件地址的类型.它的值为1即表示以太网地址</span></span><br><span class="line">u_short arp_pt;<span class="comment">//要映射的协议地址类型.它的值为0x0800，即表示IP地址</span></span><br><span class="line">u_short arp_op;<span class="comment">//四种操作类型,它们是ARP请求(值为1)、ARP应答(值为2)、RARP请求(值为3)和RARP应答(值为4)</span></span><br><span class="line">arp_ht=ntohs(ah-&gt;hardtype);<span class="comment">//硬件地址的类型.它的值为1即表示以太网地址</span></span><br><span class="line">arp_pt=ntohs(ah-&gt;prototype);<span class="comment">//要映射的协议地址类型.它的值为0x0800，即表示IP地址</span></span><br><span class="line">arp_op=ntohs(ah-&gt;op);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"硬件地址类型为：%d\t\t\t"</span>,arp_ht);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"协议地址类型为：0x%04X\n"</span>,arp_pt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"硬件地址长度为：%d\t\t\t"</span>,ah-&gt;htlen);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"协议地址长度为：%d\n"</span>,ah-&gt;ptlen);</span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：ARP请求报文。\n本机Mac地址："</span>);</span><br><span class="line">myPrintEthAddress(ah-&gt;arp_esa);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t正在请求"</span>);</span><br><span class="line">myPrintIPAddress(ah-&gt;arp_ida);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"的Mac地址\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：ARP应答报文。\n应答方的Mac地址："</span>);</span><br><span class="line">myPrintEthAddress(ah-&gt;arp_eda);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t应答方的IP地址"</span>);</span><br><span class="line">myPrintIPAddress(ah-&gt;arp_ida);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">3</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：RARP请求报文\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">4</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：RARP应答报文\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> all_ip_len = <span class="number">20</span>;</span><br><span class="line"><span class="function">u_short <span class="title">handleIP</span><span class="params">(ip_header *ih)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_int ip_ver;<span class="comment">//版本</span></span><br><span class="line">u_int ip_len;<span class="comment">//首部长度</span></span><br><span class="line">u_short ip_tlen;    <span class="comment">//总长度</span></span><br><span class="line">u_short ip_ident;<span class="comment">//标识</span></span><br><span class="line">u_short ip_flag_fo; <span class="comment">//标志和片偏移</span></span><br><span class="line">u_int ip_flag;<span class="comment">//标志（3位，值为2还有分片且允许分片,1不能分片,0没有分片且允许分片）</span></span><br><span class="line">u_int ip_fo;<span class="comment">//片偏移</span></span><br><span class="line">u_short ip_type;<span class="comment">//协议</span></span><br><span class="line">u_short ip_crc;<span class="comment">//首部检验和</span></span><br><span class="line">u_long ip_op_pad;<span class="comment">//可选项</span></span><br><span class="line"><span class="comment">/* retireve the position of the ip header */</span><span class="comment">//检索IP首部的位置</span></span><br><span class="line">ip_ver = (ih-&gt;ver_ihl &gt;&gt; <span class="number">4</span>);<span class="comment">//版本</span></span><br><span class="line">ip_len = (ih-&gt;ver_ihl &amp; <span class="number">0xf</span>) * <span class="number">4</span>;<span class="comment">//首部长度，与运算，可以只取ip头部的版本长度字段的后4位</span></span><br><span class="line">ip_tlen=ntohs(ih-&gt;tlen);<span class="comment">//总长度</span></span><br><span class="line">ip_ident=ntohs(ih-&gt;identification);<span class="comment">//标识</span></span><br><span class="line">ip_flag_fo = ntohs(ih-&gt;flags_fo);<span class="comment">//2字节存放，会有字节序问题</span></span><br><span class="line">ip_flag = (ip_flag_fo &gt;&gt; <span class="number">13</span>);<span class="comment">//标志</span></span><br><span class="line">ip_fo = (ip_flag_fo &amp; <span class="number">0x1fff</span>);<span class="comment">//片偏移</span></span><br><span class="line">ip_type = ih-&gt;proto;<span class="comment">//上层协议类型</span></span><br><span class="line">ip_crc = ntohs(ih-&gt;crc);<span class="comment">//首部校验和</span></span><br><span class="line"><span class="comment">/*打印IP数据报首部*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"版本：%d\t\t\t"</span>,ip_ver);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部长度：%d\n"</span>,ip_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"区分服务：%d\t\t"</span>, ih-&gt;tos);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"总长度：%d\n"</span>, ip_tlen);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标识：%d\t\t"</span>, ip_ident);</span><br><span class="line"><span class="keyword">if</span> (ip_flag == <span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：DF=1（不能分片），MF=0（没有后续分片）\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (ip_flag == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：DF=0（允许分片），MF=1（还有后续分片）\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (ip_flag == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：DF=0（允许分片），MF=0（没有后续分片）\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"片偏移：%d\t\t"</span>,ip_fo*<span class="number">8</span>);<span class="comment">//片偏移以8字节为单位</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"生存时间：%d\n"</span>,ih-&gt;ttl);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"协议：%d\t\t\t"</span>,ih-&gt;proto);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部校验和：%d\n"</span>,ip_crc);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"IP地址：  "</span>);</span><br><span class="line">myPrintIPAddress(ih-&gt;saddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" -&gt; "</span>);</span><br><span class="line">myPrintIPAddress(ih-&gt;daddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (ip_len == <span class="number">20</span>)<span class="comment">//IP首部长度&gt;20时才有</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部长度为20，IP报文首部没有可选字段。\n"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ip_op_pad = ntohl(ih-&gt;op_pad);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"可选自段内容为：%u\n"</span>, ip_op_pad);</span><br><span class="line">&#125;</span><br><span class="line">all_ip_len = ip_len;</span><br><span class="line"><span class="keyword">return</span> ip_type;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleICMP</span><span class="params">(icmp_header *ich)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short icmp_checksum;<span class="comment">//校验和</span></span><br><span class="line">u_short icmp_ident;<span class="comment">//标识符</span></span><br><span class="line">u_short icmp_seqnum;<span class="comment">//序列号</span></span><br><span class="line">icmp_checksum = ntohs(ich-&gt;checksum);<span class="comment">//校验和</span></span><br><span class="line">icmp_ident = ntohs(ich-&gt;identifier);<span class="comment">//标识符</span></span><br><span class="line">icmp_seqnum = ntohs(ich-&gt;sequence_number);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n运输层协议：  ICMP协议\n"</span>);</span><br><span class="line"><span class="comment">/*打印ICMP报文首部*/</span></span><br><span class="line"><span class="keyword">if</span> (ich-&gt;type == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ICMP类型：回显应答\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ich-&gt;type == <span class="number">8</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ICMP类型：回显请求\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ICMP类型：其他\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"代码：%d\t\t"</span>,ich-&gt;code);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"校验和：%d\n"</span>,icmp_checksum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标识符：%d\t\t"</span>,icmp_ident);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"序列号：%d\n"</span>,icmp_seqnum);</span><br><span class="line">&#125;</span><br><span class="line">u_int udp_len;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handleUDP</span><span class="params">(udp_header *uh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short sport, dport;<span class="comment">//端口</span></span><br><span class="line">u_short uh_len; <span class="comment">//长度</span></span><br><span class="line">u_short uh_crc; <span class="comment">//校验和</span></span><br><span class="line">sport = ntohs( uh-&gt;sport );<span class="comment">//源端口</span></span><br><span class="line">dport = ntohs( uh-&gt;dport );<span class="comment">//目的端口</span></span><br><span class="line">uh_len = ntohs(uh-&gt;len);<span class="comment">//长度</span></span><br><span class="line">uh_crc = ntohs(uh-&gt;crc);<span class="comment">//校验和</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n运输层协议：  UDP协议\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"端口号：%d -&gt; %d\n"</span>, sport, dport);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"长度：%d\t\t"</span>, uh_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"校验和：%d\n"</span>, uh_crc);</span><br><span class="line">udp_len = uh_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sport == DNSPORT || dport == DNSPORT)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleTCP</span><span class="params">(tcp_header *th)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_shorttcp_sport;<span class="comment">//源端口</span></span><br><span class="line">u_short tcp_dport;<span class="comment">//目的端口</span></span><br><span class="line">u_long  tcp_seqnum;<span class="comment">//序号（4字节ntohl）  </span></span><br><span class="line">u_long  tcp_acknum;<span class="comment">//确认号</span></span><br><span class="line">u_short tcp_hlen_bl_flags;<span class="comment">//数据偏移+保留+控制位</span></span><br><span class="line">u_short  tcp_hlen;</span><br><span class="line">u_short  tcp_bl;</span><br><span class="line">u_short  tcp_flags_urg;<span class="comment">//紧急1有效 </span></span><br><span class="line">u_short  tcp_flags_ack;<span class="comment">//确认=1时，确认号有效</span></span><br><span class="line">u_short  tcp_flags_psh;<span class="comment">//推送1有效，可以不用填满缓存就发报</span></span><br><span class="line">u_short  tcp_flags_rst;<span class="comment">//复位1有效，重新建立连接</span></span><br><span class="line">u_short  tcp_flags_syn;<span class="comment">//同步syn=1,ack=0时，表明这是一个连接请求报文；syn=1,ack=1,接受连接请求</span></span><br><span class="line">u_short  tcp_flags_fin;<span class="comment">//释放连接=1时，表示数据报</span></span><br><span class="line">u_short tcp_window_size;<span class="comment">//窗口（发送方自己的接收窗口）</span></span><br><span class="line">u_short tcp_checksum;<span class="comment">//检验和（首部+数据）</span></span><br><span class="line">u_short tcp_urg;<span class="comment">//紧急指针</span></span><br><span class="line">u_long tcp_option;</span><br><span class="line">tcp_sport=ntohs(th-&gt;sport);<span class="comment">//源端口</span></span><br><span class="line">tcp_dport=ntohs(th-&gt;dport);<span class="comment">//目的端口</span></span><br><span class="line">tcp_seqnum=ntohl(th-&gt;sequence_number);<span class="comment">//序号（4字节ntohl）  </span></span><br><span class="line">tcp_acknum=ntohl(th-&gt;acknowlegement_number);<span class="comment">//确认号</span></span><br><span class="line">tcp_hlen_bl_flags=ntohs(th-&gt;hlen_bl_flags);<span class="comment">//数据偏移4+保留6+控制位6</span></span><br><span class="line">tcp_hlen=(tcp_hlen_bl_flags &gt;&gt; <span class="number">12</span>)*<span class="number">4</span>;<span class="comment">//以4字节为单位</span></span><br><span class="line">tcp_bl=(tcp_hlen_bl_flags &amp; <span class="number">0x0fc0</span>);<span class="comment">//保留</span></span><br><span class="line">tcp_flags_urg=(tcp_hlen_bl_flags &amp; <span class="number">0x0020</span>);<span class="comment">//紧急1有效                                                    ----- </span></span><br><span class="line">tcp_flags_ack=(tcp_hlen_bl_flags &amp; <span class="number">0x0010</span>);<span class="comment">//确认=1时，确认号有效</span></span><br><span class="line">tcp_flags_psh=(tcp_hlen_bl_flags &amp; <span class="number">0x0008</span>);<span class="comment">//推送1有效，可以不用填满缓存就发报</span></span><br><span class="line">tcp_flags_rst=(tcp_hlen_bl_flags &amp; <span class="number">0x0004</span>);<span class="comment">//复位1有效，重新建立连接</span></span><br><span class="line">tcp_flags_syn=(tcp_hlen_bl_flags &amp; <span class="number">0x0002</span>);<span class="comment">//同步syn=1,ack=0时，表明这是一个连接请求报文；syn=1,ack=1,接受连接请求</span></span><br><span class="line">tcp_flags_fin=(tcp_hlen_bl_flags &amp; <span class="number">0x0001</span>);<span class="comment">//释放连接=1时，表示数据报</span></span><br><span class="line">tcp_window_size=ntohs(th-&gt;window_size);<span class="comment">//窗口（发送方自己的接收窗口）</span></span><br><span class="line">tcp_checksum=ntohs(th-&gt;checksum);<span class="comment">//检验和（首部+数据）</span></span><br><span class="line">tcp_urg=ntohs(th-&gt;urg);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n运输层协议：  TCP协议\n"</span>);</span><br><span class="line"><span class="comment">/*打印TCP数据报首部*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"端口号：%d -&gt; %d\n"</span>,tcp_sport,tcp_dport);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"序号：%u\t"</span>,tcp_seqnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"确认号：%u\n"</span>,tcp_acknum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数据偏移：%d\t\t"</span>,tcp_hlen);<span class="comment">//首部长度</span></span><br><span class="line"><span class="comment">//printf("保留：%d\n",tcp_bl);</span></span><br><span class="line"><span class="comment">/*控制字段,标志位*/</span></span><br><span class="line"><span class="keyword">if</span> (tcp_flags_urg == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：URG\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_ack == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：ACK\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_psh == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：PSH\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_rst == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：RST\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_syn == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：SYN\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_fin == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：FIN\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"窗口：%d\t\t"</span>,tcp_window_size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"检验和：%d\n"</span>,tcp_checksum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"紧急指针：%d\t\t"</span>,tcp_urg);<span class="comment">//URG=1时才有用，窗口大小为0也能发送</span></span><br><span class="line"><span class="keyword">if</span>(tcp_hlen == <span class="number">20</span>)<span class="comment">//数据偏移(TCP首部长度)&gt;20时才有</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部长度为20字节，没有填充字段。\n"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tcp_option = ntohl(th-&gt;option);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"填充字段:%u\n"</span>, tcp_option);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Callback function invoked by libpcap for every incoming packet */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_handler</span><span class="params">(u_char *param, <span class="keyword">const</span> struct pcap_pkthdr *header, <span class="keyword">const</span> u_char *pkt_data)</span>   <span class="comment">//param 无用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">eth_header *eth;</span><br><span class="line">u_short macType;</span><br><span class="line">myPrintBaseInfo(header);</span><br><span class="line">eth=(eth_header *) (pkt_data);</span><br><span class="line"><span class="comment">//过滤以太网头部</span></span><br><span class="line">pkt_data += <span class="number">14</span>;</span><br><span class="line"><span class="comment">//HandleMac</span></span><br><span class="line">macType=handleMac(eth);</span><br><span class="line">myPrintNetType(macType);</span><br><span class="line"><span class="comment">// 处理ARP 和 RARP</span></span><br><span class="line"><span class="keyword">if</span>(macType==<span class="number">0x0806</span> || macType==<span class="number">0x8035</span>)</span><br><span class="line">&#123;</span><br><span class="line">arp_header *ap;</span><br><span class="line">ap = (arp_header *)(pkt_data);</span><br><span class="line">handleARPAndRARP(ap);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 处理IP</span></span><br><span class="line"><span class="keyword">if</span>(macType==<span class="number">0x0800</span>)</span><br><span class="line">&#123;</span><br><span class="line">u_short ip_type;</span><br><span class="line">ip_header *ih;</span><br><span class="line">ih = (ip_header *) (pkt_data);</span><br><span class="line">ip_type = handleIP(ih);</span><br><span class="line"><span class="keyword">if</span> (ip_type == <span class="number">1</span>) &#123;</span><br><span class="line">icmp_header *ich;</span><br><span class="line">ich = (icmp_header *)((u_char*)ih + all_ip_len);</span><br><span class="line">handleICMP(ich);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">17</span>)&#123;</span><br><span class="line">udp_header *uh;</span><br><span class="line">uh = (udp_header *) ((u_char*)ih + all_ip_len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(handleUDP(uh))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct dns_packet *pdns;</span></span><br><span class="line"><span class="comment">pdns = (struct dns_packet *)(pkt_data + all_ip_len + udp_len); // sport+dport+length+checksum,DNS头指针</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">u_char *query=&amp;(pdns-&gt;dns_data);//定位到查询部分头部</span></span><br><span class="line"><span class="comment">printf("QueryDomain=");</span></span><br><span class="line"><span class="comment">u_char domainname[100]=&#123;0&#125;;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">u_int i=0;</span></span><br><span class="line"><span class="comment">//query++;//把点去了</span></span><br><span class="line"><span class="comment">while(*query)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">printf("%d", *query);</span></span><br><span class="line"><span class="comment">if(*query &lt; 0x10)//48以后出现数字和英文字母</span></span><br><span class="line"><span class="comment">printf(".");</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">printf("%c", *query);</span></span><br><span class="line"><span class="comment">query++;</span></span><br><span class="line"><span class="comment">i++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">printf("\n"); */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">6</span>)&#123;</span><br><span class="line">tcp_header *th;</span><br><span class="line">th=(tcp_header *) ((u_char*)ih + all_ip_len);</span><br><span class="line">handleTCP(th);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pcap_if_t</span> *alldevs;</span><br><span class="line"><span class="keyword">pcap_if_t</span> *d;</span><br><span class="line"><span class="keyword">int</span> inum;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">pcap_t</span> *adhandle;</span><br><span class="line"><span class="keyword">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line">u_int netmask;</span><br><span class="line"><span class="keyword">char</span> packet_filter[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析IP数据报输入：\t1\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析ARP数据报输入：\t2\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析TCP数据报输入：\t3\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析UDP数据报输入：\t4\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析ICMP数据报输入：\t5\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析MAC、IP、ARP、TCP、UDP、IMCP输入\t6\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">packet_filter = <span class="string">"ip"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)</span><br><span class="line">packet_filter = <span class="string">"arp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">packet_filter = <span class="string">"ip and tcp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">4</span>)</span><br><span class="line">packet_filter = <span class="string">"ip and udp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">5</span>)</span><br><span class="line">packet_filter = <span class="string">"ip and icmp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">packet_filter = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"InputError : check the number you input! exit(1)"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_program</span> <span class="title">fcode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pcap_findalldevs(&amp;alldevs, errbuf) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error in pcap_findalldevs: %s\n"</span>, errbuf);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(d=alldevs; d; d=d-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d. %s"</span>, ++i, d-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (d-&gt;description)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" (%s)\n"</span>, d-&gt;description);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" (No description available)\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter the interface number (1-%d):"</span>,i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;inum);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if the user specified a valid adapter */</span></span><br><span class="line"><span class="keyword">if</span>(inum &lt; <span class="number">1</span> || inum &gt; i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nAdapter number out of range.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Jump to the selected adapter */</span></span><br><span class="line"><span class="keyword">for</span>(d=alldevs, i=<span class="number">0</span>; i&lt; inum<span class="number">-1</span> ;d=d-&gt;next, i++);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open the adapter */</span></span><br><span class="line"><span class="keyword">if</span> ((adhandle= pcap_open_live(d-&gt;name,<span class="comment">// name of the device</span></span><br><span class="line"> <span class="number">65536</span>,<span class="comment">// portion of the packet to capture. </span></span><br><span class="line"><span class="comment">// 65536 grants that the whole packet will be captured on all the MACs.</span></span><br><span class="line"> <span class="number">1</span>,<span class="comment">// promiscuous mode (nonzero means promiscuous)</span></span><br><span class="line"> <span class="number">1000</span>,<span class="comment">// read timeout</span></span><br><span class="line"> errbuf<span class="comment">// error buffer</span></span><br><span class="line"> )) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the link layer. We support only Ethernet for simplicity. */</span></span><br><span class="line"><span class="keyword">if</span>(pcap_datalink(adhandle) != DLT_EN10MB)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nThis program works only on Ethernet networks.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(d-&gt;addresses != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">/* Retrieve the mask of the first address of the interface */</span></span><br><span class="line">netmask=((struct sockaddr_in *)(d-&gt;addresses-&gt;netmask))-&gt;sin_addr.S_un.S_addr;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">/* If the interface is without addresses we suppose to be in a C class network */</span></span><br><span class="line">netmask=<span class="number">0xffffff</span>; </span><br><span class="line"><span class="comment">//compile the filter</span></span><br><span class="line"><span class="keyword">if</span> (pcap_compile(adhandle, &amp;fcode, packet_filter, <span class="number">1</span>, netmask) &lt;<span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nUnable to compile the packet filter. Check the syntax.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set the filter</span></span><br><span class="line"><span class="keyword">if</span> (pcap_setfilter(adhandle, &amp;fcode)&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nError setting the filter.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nlistening on %s...\n"</span>, d-&gt;description);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* At this point, we don't need any more the device list. Free it */</span></span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* start the capture */</span></span><br><span class="line">pcap_loop(adhandle, <span class="number">0</span>, packet_handler, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li><p>听到网卡上Mac帧时的回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_handler</span><span class="params">(u_char *param, </span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">const</span> struct pcap_pkthdr *header, <span class="keyword">const</span> u_char *pkt_data)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出基本信息：包括监听到帧的时间，帧的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintBaseInfo</span><span class="params">(<span class="keyword">const</span> struct pcap_pkthdr *header)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出硬件地址，格式：<code>xx:xx:xx:xx:xx:xx</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintEthAddress</span><span class="params">(eth_address eth)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出IP地址，格式：<code>xx.xx.xx.xx</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintIPAddress</span><span class="params">(ip_address ia)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出网络层协议类型，格式：<code>网络层协议：xxxx</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintNetType</span><span class="params">(u_short type)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析Mac帧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u_short <span class="title">handleMac</span><span class="params">(eth_header *eth)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析ARP和RARP帧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleARPAndRARP</span><span class="params">(arp_header *ah)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析IP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u_short <span class="title">handleIP</span><span class="params">(ip_header *ih)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析ICMP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleICMP</span><span class="params">(icmp_header *ich)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析UDP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handleUDP</span><span class="params">(udp_header *uh)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析TCP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleTCP</span><span class="params">(tcp_header *th)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:07 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="网络" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://isjinhao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="cpp" scheme="https://isjinhao.github.io/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>方法功能的增强</title>
    <link href="https://isjinhao.github.io/posts/18731.html/"/>
    <id>https://isjinhao.github.io/posts/18731.html/</id>
    <published>2019-12-17T02:48:41.000Z</published>
    <updated>2019-12-20T09:29:23.916Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:08 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>方法功能的增强是开发时常做的事情，当官方或者第三方提供的API不能满足我们的需要时，可以在原有API的基础上加上我们自定义的功能来实现需求。<br>常见的功能增强的方式有三种：继承、装饰者模式、动态代理。</p><p><br></p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>现在有一个很火的概念：无人驾驶。假设无人驾驶的标准是Oracle公司制定的，Google想使用Java语言来开发无人驾驶系统，那么首先它需要创建一个类实现Oracle公司提供的无人驾驶的接口（接口为AIDriving，类为GoogleAIDriving）。</p><ul><li><p>AIDriving</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AIDriving</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;  <span class="comment">//无人驾驶汽车启动的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;   <span class="comment">//无人驾驶汽车停止的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>GoogleAIDriving</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoogleAIDriving</span> <span class="keyword">implements</span> <span class="title">AIDriving</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Google汽车启动了..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Google汽车停止了..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>这个时候国内某汽车制造公司（设为A公司）想使用Google提供的无人驾驶系统。但是Google提供的系统不太适合我国国情，所以A公司的工程师就想在Google系统的基础上进行定制。他们选择的方式是继承GoogleAIDriving，创建一个自己的类：A1GoogleAIDriving。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A1GoogleAIDriving</span> <span class="keyword">extends</span> <span class="title">GoogleAIDriving</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"在中国启动汽车"</span>);</span><br><span class="line"><span class="keyword">super</span>.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"在中国停止汽车"</span>);</span><br><span class="line"><span class="keyword">super</span>.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>但理想很美好，现实很残忍。GoogleAIDriving被定义为一个final类（不能被继承），这个是可以理解的，因为如果GoogleAIDriving不是一个final类，任何继承GoogleAIDriving的类都可以对其start()、stop()方法进行覆盖，如果覆盖时出现bug就可能会出现大问题。所以像启动、停止这种核心功能是不允许汽车制造商随意修改的。A公司的工程师就想到了使用装饰者模式来增强功能（设类为A2GoogleAIDriving）。<br>装饰者模式该怎么做呢？</p><ol><li>首先，装饰类得和被装饰类实现相同的接口，即AIDriving；</li><li>第二，在装饰类中定义一个AIDriving类型的属性，即AIDriving car；</li><li>第三，有一个参数为AIDriving类型的构造函数，即A2GoogleAIDriving(AIDriving car)；</li><li>第四，装饰类的每个方法都要调用被装饰类相应的方法；</li><li>第五，使用第三步中的构造函数创建装饰类；</li><li>第六，在装饰类的方法中自定义功能。</li></ol><ul><li><p>创建装饰类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A2GoogleAIDriving</span> <span class="keyword">implements</span> <span class="title">AIDriving</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> AIDriving car;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A2GoogleAIDriving</span><span class="params">(AIDriving car)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"在中国启动汽车..."</span>);</span><br><span class="line">car.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"在中国停止汽车..."</span>);</span><br><span class="line">car.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>调用装饰类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">GoogleAIDriving car = <span class="keyword">new</span> GoogleAIDriving();</span><br><span class="line">A2GoogleAIDriving aCar = <span class="keyword">new</span> A2GoogleAIDriving(car);</span><br><span class="line">aCar.start();</span><br><span class="line"> <span class="comment">/* Console : </span></span><br><span class="line"><span class="comment">  在中国启动汽车...</span></span><br><span class="line"><span class="comment">Google汽车启动了... */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>A公司工程师正沉浸在胜利到来前的喜悦中，突然他们发现AIDriving接口有1000个方法，所以在装饰类中其他不需要加入自定义动能的998个方法我们也要调用。这一看就不是一个好的解决方案，A公司的某大佬就想起来动态代理。<br>动态代理中可以使用反射技术得到方法的信息，如果是<code>start()</code>或者<code>stop()</code>方法就加上自定义的功能，其他方法直接执行。</p><ul><li><p>A3GoogleAIDriving</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A3GoogleAIDriving</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> AIDriving car;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A3GoogleAIDriving</span><span class="params">(AIDriving car)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> AIDriving <span class="title">getIns</span><span class="params">()</span> </span>&#123;</span><br><span class="line">AIDriving a3GoogleAIDriving = (AIDriving)Proxy.newProxyInstance(</span><br><span class="line">GoogleAIDriving.class.getClassLoader(), </span><br><span class="line">GoogleAIDriving.class.getInterfaces(), </span><br><span class="line"><span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(method.getName().equals(<span class="string">"start"</span>)</span><br><span class="line">&amp;&amp;method.getParameterTypes().length == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"在中国启动汽车..."</span>);</span><br><span class="line"><span class="keyword">return</span> method.invoke(car, args);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (method.getName().equals(<span class="string">"stop"</span>)</span><br><span class="line">&amp;&amp;method.getParameterTypes().length == <span class="number">0</span>) &#123;</span><br><span class="line">System.out.println(<span class="string">"在中国停止汽车..."</span>);</span><br><span class="line"><span class="keyword">return</span> method.invoke(car, args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> method.invoke(car, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">return</span> a3GoogleAIDriving;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行A3GoogleAIDriving</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">GoogleAIDriving car = <span class="keyword">new</span> GoogleAIDriving();</span><br><span class="line">A3GoogleAIDriving a3GoogleAIDriving = <span class="keyword">new</span> A3GoogleAIDriving(car);</span><br><span class="line">AIDriving ins = a3GoogleAIDriving.getIns();</span><br><span class="line">ins.start();</span><br><span class="line">ins.stop();</span><br><span class="line"><span class="comment">/*   Console : </span></span><br><span class="line"><span class="comment">  在中国启动汽车...</span></span><br><span class="line"><span class="comment">Google汽车启动了...</span></span><br><span class="line"><span class="comment">在中国停止汽车...</span></span><br><span class="line"><span class="comment">Google汽车停止了...  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="三种方式总结"><a href="#三种方式总结" class="headerlink" title="三种方式总结"></a>三种方式总结</h2><p>分析了三种方式的功能增强，各位大腿是不是被博主带入了一个误区：后者比前者更好？按照存在即合理的解释，肯定不是这样的。相反，三种方法中继承却是最常见的增强方式，因为它结构简单、易于理解。而后两种都是设计模式，一般在大型软件开发时才会用到。<br>而且对于装饰者模式和动态代理的区别是：装饰者模式一般用于增强功能，动态代理一般用于拦截对方法的请求。</p><p><br></p><h2 id="装饰者模式解决Web开发乱码"><a href="#装饰者模式解决Web开发乱码" class="headerlink" title="装饰者模式解决Web开发乱码"></a>装饰者模式解决Web开发乱码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: RequestEncodingUtils </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO(解决request乱码的工具类)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 詹金浩 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年3月11日 下午2:27:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestEncodingUtils</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line"><span class="keyword">private</span> Boolean isEncoded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestEncodingUtils</span><span class="params">(HttpServletRequest request)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>(request);</span><br><span class="line"><span class="keyword">this</span>.request = request;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Map&lt;String, String[]&gt; getParameterMap() &#123;</span><br><span class="line"></span><br><span class="line">String method = request.getMethod();</span><br><span class="line"></span><br><span class="line">Map&lt;String, String[]&gt; parameterMap = request.getParameterMap();</span><br><span class="line"><span class="comment">//处理Post请求</span></span><br><span class="line"><span class="keyword">if</span>(method.equalsIgnoreCase(<span class="string">"post"</span>)) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">parameterMap =  request.getParameterMap();</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (method.equalsIgnoreCase(<span class="string">"get"</span>)) &#123;  <span class="comment">//处理Get请求</span></span><br><span class="line"><span class="comment">//保证编码只被执行一次</span></span><br><span class="line"><span class="keyword">if</span>(!isEncoded) &#123;</span><br><span class="line"><span class="keyword">for</span>(String key : parameterMap.keySet()) &#123;</span><br><span class="line">String []values = parameterMap.get(key);</span><br><span class="line"><span class="keyword">if</span>(values != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">values[i] = <span class="keyword">new</span> String(values[i].getBytes(<span class="string">"ISO-8859-1"</span>),<span class="string">"utf-8"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">isEncoded = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> parameterMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">Map&lt;String, String[]&gt; parameterMap = <span class="keyword">this</span>.getParameterMap();</span><br><span class="line">String []values = parameterMap.get(name);</span><br><span class="line"><span class="keyword">return</span> values;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">String []values = getParameterValues(name);</span><br><span class="line"><span class="keyword">return</span> values!=<span class="keyword">null</span>?values[<span class="number">0</span>]:<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span>: GlobalEncoding </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: TODO(解决全局编码的filter) </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> 詹金浩 </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018年3月10日 下午10:26:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@WebFilter</span>(<span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalEncoding</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default constructor. </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GlobalEncoding</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">    RequestEncodingUtils myRequest = <span class="keyword">new</span> RequestEncodingUtils((HttpServletRequest)request);</span><br><span class="line">    chain.doFilter(myRequest, response);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Filter#destroy()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Filter#doFilter(ServletRequest, ServletResponse, FilterChain)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> Filter#init(FilterConfig)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig fConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:08 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>电子邮件&amp;Java完成发送</title>
    <link href="https://isjinhao.github.io/posts/65368.html/"/>
    <id>https://isjinhao.github.io/posts/65368.html/</id>
    <published>2019-12-17T02:48:41.000Z</published>
    <updated>2019-12-20T09:29:23.919Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:08 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h2><p>邮件服务器邮件服务器的功能是发送和接收邮件，邮件服务器按照客户服务器方式工作。邮件服务器需要使用发送和读取两个不同的协议。发送时使用了两次SMTP协议（简单邮件传送协议SMTP），负责发送邮件的SMTP进程就是SMTP客户，而负责接收邮件的SMTP进程就是SMTP服务器。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/f7da17b4-3d36-436b-a5ca-1c93dbd55efb"></div><p><strong>电子邮件发送和接收的流程</strong></p><ol><li>发信人使用用户代理（例如：Outlook）编辑要发送的信件。</li><li>发件人的 Outlook 软件使用SMTP协议，把邮件“推送”给发送方邮件服务器，SMTP服务器把邮件临时存放在缓冲区内,等待发送。</li><li>发送方邮件服务器的SMTP客户与接收方邮件服务器的SMTP服务器建立TCP连接，然后发送邮件。</li><li>运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，把邮件放入收件人的邮箱中，等待收件人进行读取。</li><li>收件人在打算收信时，就打开自己PC机中的软件, Outlook 使用POP3（或IMAP）协议，将自己邮箱内的邮件“拉取”回来。<br>注意：当张三给李四发电子邮件时，李四的电脑可能是关机的，这时就没办法联通。所以电子邮件的客户/服务器编程的思想有一点另类，使用了一些中间计算机，就是邮件服务器，邮件服务器始终运行，当要发信或收信时，需先连接到邮件服务器上。</li></ol><p><strong>邮件协议</strong></p><p>电子邮件需要在邮件客户端和邮件服务器之间，以及两个邮件服务器之间进行邮件传递，那就必须要遵守一定的规则，这个规则就是邮件传输协议：</p><ol><li>SMTP协议：全称为 Simple Mail Transfer Protocol，简单邮件传输协议。它定义了邮件客户端软件和SMTP邮件服务器之间，以及两台SMTP邮件服务器之间的通信规则。</li><li>POP3协议：全称为 Post Office Protocol，邮局协议。它定义了邮件客户端软件和POP3邮件服务器的通信规则。</li><li>IMAP协议：全称为 Internet Message Access Protocol，Internet消息访问协议，它是对POP3协议的一种扩展，也是定义了邮件客户端软件和IMAP邮件服务器的通信规则。</li></ol><p><strong>邮件的格式</strong></p><p>一个邮件含有这么几个部分：收件人、发件人、抄送人、密送人、主题、内容（现在很多邮箱服务器的内容都支持富文本）、附件。收件人、主题就不说了。内容和附件的话我们等下看怎么用代码把文字&amp;图片&amp;附件发出去。我们现在解释抄送和密送：<br>如果A 发送邮件给B、C，抄送给D、E，密送给F、G，那么：</p><ul><li>B、C、D、E、F、G都能收到这封邮件。</li><li>B知道这是A发送给他和C的邮件，并且抄送给了D、E，但不知道密送给了F、G。</li><li>D知道这是A发送给B、C的邮件，并且抄送给了他和E，但也不知道密送给了F、G。</li><li>F知道这是A发送给B、C的邮件，并且抄送给了D、E，密送给了他，但不知道同时还密送给了G。</li></ul><p><br></p><h2 id="Java完成发送"><a href="#Java完成发送" class="headerlink" title="Java完成发送"></a>Java完成发送</h2><p><strong>jar包引入</strong></p><p>这个工具的jar包非常乱，为了避免问题，请严格使用下面的依赖。<br></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.mail<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>类分析</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/6f246906-8ed8-487b-aeb1-4e047e529c08"></div><p><strong>发送文本文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMailText</span> </span>&#123;</span><br><span class="line">    <span class="comment">//发件人地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String senderAddress = <span class="string">"@163.com"</span>;</span><br><span class="line">    <span class="comment">//收件人地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String recipientAddress = <span class="string">"@qq.com"</span>;</span><br><span class="line">    <span class="comment">//发件人账户名</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String senderAccount = <span class="string">"@163.com"</span>;</span><br><span class="line">    <span class="comment">//发件人账户密码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String senderPassword = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1、连接邮件服务器的参数配置</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//设置用户的认证方式</span></span><br><span class="line">        props.setProperty(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>);</span><br><span class="line">        <span class="comment">//设置传输协议</span></span><br><span class="line">        props.setProperty(<span class="string">"mail.transport.protocol"</span>, <span class="string">"smtp"</span>);</span><br><span class="line">        <span class="comment">//设置发件人的SMTP服务器地址</span></span><br><span class="line">        props.setProperty(<span class="string">"mail.smtp.host"</span>, <span class="string">"smtp.163.com"</span>);</span><br><span class="line">        <span class="comment">//2、创建定义整个应用程序所需的环境信息的 Session 对象</span></span><br><span class="line">        Session session = Session.getInstance(props);</span><br><span class="line">        <span class="comment">//设置调试信息在控制台打印出来</span></span><br><span class="line">        session.setDebug(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//3、创建邮件的实例对象</span></span><br><span class="line">        Message msg = getMimeMessage(session);</span><br><span class="line">        <span class="comment">//4、根据session对象获取邮件传输对象Transport</span></span><br><span class="line">        Transport transport = session.getTransport();</span><br><span class="line">        <span class="comment">//设置发件人的账户名和密码</span></span><br><span class="line">        transport.connect(senderAccount, senderPassword);</span><br><span class="line">        <span class="comment">//发送邮件，并发送到所有收件人地址，message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人</span></span><br><span class="line">        transport.sendMessage(msg, msg.getAllRecipients());</span><br><span class="line">        <span class="comment">//如果只想发送给指定的人，可以如下写法</span></span><br><span class="line">        <span class="comment">//transport.sendMessage(msg, new Address[]&#123;new InternetAddress("xxx@qq.com")&#125;);</span></span><br><span class="line">        <span class="comment">//5、关闭邮件连接</span></span><br><span class="line">        transport.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得创建一封邮件的实例对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AddressException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MimeMessage <span class="title">getMimeMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建一封邮件的实例对象</span></span><br><span class="line">        MimeMessage msg = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">        <span class="comment">//设置发件人地址</span></span><br><span class="line">        msg.setFrom(<span class="keyword">new</span> InternetAddress(senderAddress));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置收件人地址（可以增加多个收件人、抄送、密送），即下面这一行代码书写多行</span></span><br><span class="line"><span class="comment">         * MimeMessage.RecipientType.TO：发送</span></span><br><span class="line"><span class="comment">         * MimeMessage.RecipientType.CC：抄送</span></span><br><span class="line"><span class="comment">         * MimeMessage.RecipientType.BCC：密送</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        msg.setRecipient(MimeMessage.RecipientType.TO, <span class="keyword">new</span> InternetAddress(recipientAddress));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 为了防止邮箱服务器认定为垃圾邮件，抄送一份给自己，会大大降低失效概率</span></span><br><span class="line">        msg.setRecipient(MimeMessage.RecipientType.CC, <span class="keyword">new</span> InternetAddress(senderAddress));</span><br><span class="line">        <span class="comment">//设置邮件主题</span></span><br><span class="line">        msg.setSubject(<span class="string">"邮件主题"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">//设置邮件正文，邮件正文可以支持html</span></span><br><span class="line">        msg.setContent(<span class="string">"&lt;h1&gt;简单的纯文本邮件！&lt;/h1&gt;"</span>, <span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        <span class="comment">//设置邮件的发送时间,默认立即发送</span></span><br><span class="line">        msg.setSentDate(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>发送带附件和图片的邮件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMailText_Picture_Enclosure</span> </span>&#123;</span><br><span class="line">    <span class="comment">//发件人地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String senderAddress = <span class="string">"@163.com"</span>;</span><br><span class="line">    <span class="comment">//收件人地址</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String recipientAddress = <span class="string">"@qq.com"</span>;</span><br><span class="line">    <span class="comment">//发件人账户名，账户名和密码一般是一样的，至于Sun公司为什么给他分开，需要去看smtp、pop3协议的了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String senderAccount = <span class="string">"@163.com"</span>;</span><br><span class="line">    <span class="comment">//发件人账户密码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String senderPassword = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1、连接邮件服务器的参数配置</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//设置用户的认证方式</span></span><br><span class="line">        props.setProperty(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>);</span><br><span class="line">        <span class="comment">//设置传输协议</span></span><br><span class="line">        props.setProperty(<span class="string">"mail.transport.protocol"</span>, <span class="string">"smtp"</span>);</span><br><span class="line">        <span class="comment">//设置发件人的SMTP服务器地址</span></span><br><span class="line">        props.setProperty(<span class="string">"mail.smtp.host"</span>, <span class="string">"smtp.163.com"</span>);</span><br><span class="line">        <span class="comment">//2、创建定义整个应用程序所需的环境信息的 Session 对象</span></span><br><span class="line">        Session session = Session.getInstance(props);</span><br><span class="line">        <span class="comment">//设置调试信息在控制台打印出来</span></span><br><span class="line">        session.setDebug(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//3、创建邮件的实例对象</span></span><br><span class="line">        Message msg = getMimeMessage(session);</span><br><span class="line">        <span class="comment">//4、根据session对象获取邮件传输对象Transport</span></span><br><span class="line">        Transport transport = session.getTransport();</span><br><span class="line">        <span class="comment">//设置发件人的账户名和密码</span></span><br><span class="line">        transport.connect(senderAccount, senderPassword);</span><br><span class="line">        <span class="comment">//发送邮件，并发送到所有收件人地址，message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人</span></span><br><span class="line">        transport.sendMessage(msg, msg.getAllRecipients());</span><br><span class="line">        <span class="comment">//5、关闭邮件连接</span></span><br><span class="line">        transport.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得创建一封邮件的实例对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> AddressException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MimeMessage <span class="title">getMimeMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//1.创建一封邮件的实例对象</span></span><br><span class="line">        MimeMessage msg = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line">        <span class="comment">//2.设置发件人地址</span></span><br><span class="line">        msg.setFrom(<span class="keyword">new</span> InternetAddress(senderAddress));</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3.设置收件人地址（可以增加多个收件人、抄送、密送），即下面这一行代码书写多行</span></span><br><span class="line"><span class="comment">         * MimeMessage.RecipientType.TO：发送</span></span><br><span class="line"><span class="comment">         * MimeMessage.RecipientType.CC：抄送</span></span><br><span class="line"><span class="comment">         * MimeMessage.RecipientType.BCC：密送</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        msg.setRecipient(MimeMessage.RecipientType.TO, <span class="keyword">new</span> InternetAddress(recipientAddress));</span><br><span class="line">        msg.setRecipient(MimeMessage.RecipientType.CC, <span class="keyword">new</span> InternetAddress(senderAddress));</span><br><span class="line">        <span class="comment">//4.设置邮件主题</span></span><br><span class="line">        msg.setSubject(<span class="string">"毕业设计答辩论文"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="comment">//下面是设置邮件正文</span></span><br><span class="line">        <span class="comment">//msg.setContent("简单的纯文本邮件！", "text/html;charset=UTF-8");</span></span><br><span class="line">        <span class="comment">// 5. 创建图片"节点"</span></span><br><span class="line">        MimeBodyPart image = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        <span class="comment">// 读取本地文件</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\3.jpg"</span>);</span><br><span class="line">        DataHandler dh = <span class="keyword">new</span> DataHandler(<span class="keyword">new</span> FileDataSource(file));</span><br><span class="line">        <span class="comment">// 将图片数据添加到"节点"</span></span><br><span class="line">        image.setDataHandler(dh);</span><br><span class="line">        <span class="comment">// 为"节点"设置一个唯一编号（在文本"节点"将引用该ID）</span></span><br><span class="line">        image.setContentID(<span class="string">"mailTestPic"</span>);</span><br><span class="line">        <span class="comment">// 6. 创建文本"节点"</span></span><br><span class="line">        MimeBodyPart text = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        <span class="comment">// 这里添加图片的方式是将整个图片包含到邮件内容中, 实际上也可以以http链接的形式添加网络图片</span></span><br><span class="line">        text.setContent(<span class="string">"这是一张图片&lt;br/&gt;&lt;a href='http://www.cnblogs.com/ysocean/p/7666061.html'&gt;&lt;img src='cid:mailTestPic'/&gt;&lt;/a&gt;"</span>, <span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line">        <span class="comment">// 7. （文本+图片）设置 文本 和 图片"节点"的关系（将 文本 和 图片"节点"合成一个混合"节点"）</span></span><br><span class="line">        MimeMultipart mm_text_image = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line">        mm_text_image.addBodyPart(text);</span><br><span class="line">        mm_text_image.addBodyPart(image);</span><br><span class="line">        mm_text_image.setSubType(<span class="string">"related"</span>);    <span class="comment">// 关联关系</span></span><br><span class="line">        <span class="comment">// 8. 将 文本+图片 的混合"节点"封装成一个普通"节点"</span></span><br><span class="line">        <span class="comment">// 最终添加到邮件的 Content 是由多个 BodyPart 组成的 Multipart, 所以我们需要的是 BodyPart,</span></span><br><span class="line">        <span class="comment">// 上面的 mailTestPic 并非 BodyPart, 所有要把 mm_text_image 封装成一个 BodyPart</span></span><br><span class="line">        MimeBodyPart text_image = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        text_image.setContent(mm_text_image);</span><br><span class="line">        <span class="comment">// 9. 创建附件"节点"</span></span><br><span class="line">        MimeBodyPart attachment = <span class="keyword">new</span> MimeBodyPart();</span><br><span class="line">        <span class="comment">// 读取本地文件</span></span><br><span class="line">        DataHandler dh2 = <span class="keyword">new</span> DataHandler(<span class="keyword">new</span> FileDataSource(<span class="keyword">new</span> File(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\4.jpg"</span>)));</span><br><span class="line">        <span class="comment">// 将附件数据添加到"节点"</span></span><br><span class="line">        attachment.setDataHandler(dh2);</span><br><span class="line">        <span class="comment">// 设置附件的文件名（需要编码）</span></span><br><span class="line">        attachment.setFileName(MimeUtility.encodeText(dh2.getName()));</span><br><span class="line">        <span class="comment">// 10. 设置（文本+图片）和 附件 的关系（合成一个大的混合"节点" / Multipart ）</span></span><br><span class="line">        MimeMultipart mm = <span class="keyword">new</span> MimeMultipart();</span><br><span class="line">        mm.addBodyPart(text_image);</span><br><span class="line">        mm.addBodyPart(attachment);     <span class="comment">// 如果有多个附件，可以创建多个多次添加</span></span><br><span class="line">        mm.setSubType(<span class="string">"mixed"</span>);         <span class="comment">// 混合关系</span></span><br><span class="line">        <span class="comment">// 11. 设置整个邮件的关系（将最终的混合"节点"作为邮件的内容添加到邮件对象）</span></span><br><span class="line">        msg.setContent(mm);</span><br><span class="line">        <span class="comment">//设置邮件的发送时间,默认立即发送</span></span><br><span class="line">        msg.setSentDate(<span class="keyword">new</span> Date());</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="部分转至"><a href="#部分转至" class="headerlink" title="部分转至"></a>部分转至</h2><p><a href="https://www.cnblogs.com/ysocean/p/7666061.html">https://www.cnblogs.com/ysocean/p/7666061.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:08 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;电子邮件&quot;&gt;&lt;a href=&quot;#电子邮件&quot; class=&quot;headerlink&quot; title=&quot;电子邮件&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>计算机体系结构</title>
    <link href="https://isjinhao.github.io/posts/60393.html/"/>
    <id>https://isjinhao.github.io/posts/60393.html/</id>
    <published>2019-12-17T02:48:41.000Z</published>
    <updated>2019-12-20T09:29:23.922Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Fri Dec 20 2019 17:30:08 GMT+0800 (GMT+08:00) --><div align="center"><img src="http://blogfileqiniu.isjinhao.site/9f75c222-797e-43c6-8d05-2355435770f2"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/668f8d35-bd5f-4807-afd5-329713fd597d"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/30701b0e-d235-4fac-a502-5f4d227c0c58"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/7c71fd55-b6ba-463b-ab08-f50594348314"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/7d436421-cd00-434d-8892-f2e06bb1a3de"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/562f2d96-2a05-4b72-842a-caecc2646422"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/c8284d8e-2c0a-465b-87ec-48d9106194c8"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/38c2190a-472a-4d24-992b-1e2488925930"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a6bf8b62-6160-4c4f-b15d-1c9a409af20d"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/5a08a767-b18f-4b1d-9c42-b5f58437283d"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/71918083-5a05-4f4d-a002-027c056ea965"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/1c8dbe60-ae6b-460d-9ab4-f89246c68f78"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/323a2022-6f04-44ee-936a-10d2955a4889"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/06dc6fc4-9bcd-4dac-b5e3-b53ac9da073a"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/44e48e3b-2871-4c03-abe4-35f6ff4e7659"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e207d200-503f-4a98-8d27-1825cd643cac"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a8b8171f-2338-44e1-aa15-17cfad3905b7"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/cfd25cfa-b171-4e93-b8ac-acd69950c000"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/8f50d795-4ddd-4db0-82b9-5850cafd4f30"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/c3090aca-387f-49cc-8aca-cf509a78cf82"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Fri Dec 20 2019 17:30:08 GMT+0800 (GMT+08:00) --&gt;&lt;div align=&quot;center&quot;&gt;&lt;img src=&quot;http://blogfileqiniu.isjinhao.site/9f75c222-7
      
    
    </summary>
    
      <category term="课内学习" scheme="https://isjinhao.github.io/categories/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="计算机体系结构" scheme="https://isjinhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
