<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ISJINHAO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://isjinhao.github.io/"/>
  <updated>2019-03-17T12:29:46.043Z</updated>
  <id>https://isjinhao.github.io/</id>
  
  <author>
    <name>ISJINHAO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>06-虚拟存储器</title>
    <link href="https://isjinhao.github.io/2019/06-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>https://isjinhao.github.io/2019/06-虚拟存储器/</id>
    <published>2019-03-17T06:43:36.000Z</published>
    <updated>2019-03-17T12:29:46.043Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="传统存储器的问题"><a href="#传统存储器的问题" class="headerlink" title="传统存储器的问题"></a>传统存储器的问题</h2><p>传统的内存管理方式要求将一个作业全部装入内存才可以运行，由此造成了以下两种情况：</p><ul><li><p>大作业对内存的要求超出物理内存总容量，致使其无法运行。</p></li><li><p>内存由于容量的限制，只能装入少量的作业使其运行，而其它大量作业留在外存。</p></li></ul><h3 id="解决原理"><a href="#解决原理" class="headerlink" title="解决原理"></a>解决原理</h3><h4 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h4><ol><li>程序执行时， 除了少部分的转移和过程调用指令外，在大多数情况下仍是顺序执行的。</li><li>过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域， 但经研究看出，过程调用的深度在大多数情况下都不超过5。</li><li>程序中存在许多循环结构， 这些虽然只由少数指令构成， 但是它们将多次执行。</li><li>程序中还包括许多对数据结构的处理， 如对数组进行操作， 它们往往都局限于很小的范围内。</li></ol><h4 id="表现两个方面"><a href="#表现两个方面" class="headerlink" title="表现两个方面"></a>表现两个方面</h4><ol><li>时间局限性。如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环。</li><li>空间局限性。一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</li></ol><h4 id="基于局部性原理"><a href="#基于局部性原理" class="headerlink" title="基于局部性原理"></a>基于局部性原理</h4><p>在程序装入时，不必将其全部读入到内存，而只需将当前需要执行的部分页或段读入到内存，就可让程序开始执行。在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统，将相应的页或段调入到内存，然后继续执行程序。</p><h3 id="虚拟存储器定义"><a href="#虚拟存储器定义" class="headerlink" title="虚拟存储器定义"></a>虚拟存储器定义</h3><p>所谓虚拟存储器， 是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、 中、 小型机器和微型机中。</p><h3 id="实现虚拟存储器的条件"><a href="#实现虚拟存储器的条件" class="headerlink" title="实现虚拟存储器的条件"></a>实现虚拟存储器的条件</h3><p>由于一个作业被分成多次地调入内存运行，所以在内存分配时必须采用离散分配方式。同时需要解决以下问题：</p><ul><li>页表（段表）的设计（软件支持）</li><li>程序不在内存时去外存调度需要中断（硬件支持）</li><li>逻辑地址转换为物理地址（软件硬件支持）</li><li>如何给每个进程分配物理块</li><li>一个页（段）进入内存时，淘汰哪个页（段）</li></ul><h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>用于将用户逻辑地址空间变换为内存的物理地址空间。在页表中增加若干项，以便于标志程序或数据的状态。</p><div align="center"><img src="/2019/06-虚拟存储器/页表设计.jpg"></div><ul><li>状态位（存在位）P：表示该页是否调入内存。</li><li>访问字段A：用于记录该页在某段时间内被访问的次数。</li><li>修改位M：表示该页在调入内存后是否被修改过。未修改过不必写回外存，修改要写回外存。</li><li>外存地址：该页在外存上的地址，通常是物理块号。</li></ul><h3 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h3><ul><li>在地址映射过程中，在页表中发现所要访问的页不在内存，则产生缺页中断。操作系统接到此中断信号后，就调出缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使进程继续运行下去。</li><li>如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应页表项目的状态位及相应的内存块号。</li><li>若此时内存中没有空闲块，则要淘汰某页，若该页在内存期间被修改过，则要将其写回外存。</li><li>缺页中断发生在指令执行期间，而通常情况下，CPU是在一条指令执行完后，才检查是否有中断请求到达；一条指令在执行期间，可能产生多次缺页中断。所以硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处，继续执行。</li></ul><h3 id="地址转换机构"><a href="#地址转换机构" class="headerlink" title="地址转换机构"></a>地址转换机构</h3><div align="center"><img src="/2019/06-虚拟存储器/请求分页地址转换机构.jpg"></div><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="最小物理块数的确定"><a href="#最小物理块数的确定" class="headerlink" title="最小物理块数的确定"></a>最小物理块数的确定</h4><p>最小物理块数：保证进程正常运行所需的最小物理块数。与计算机的硬件机构有关，取决于指令的格式、功能和寻址方式。</p><h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p>在请求分页中，可采取两种分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置<br>换和局部置换（置换范围不同）。于是组合出三种适用的策略：</p><ul><li>固定分配局部置换：分配固定数目的内存空间，在整个运行期间都不改变。如果缺页，则先从该进程在内存的页面中选中一页，进行换出操作，然后再调入一页。</li><li>可变分配全局置换：每个进程预先分配一定数目的物理块，同时OS也保持一个空闲物理块队列。当缺页时，首先将对OS所占有的空闲块进行分配，从而增加了各进程的物理块数。当OS的空闲块全部用完，将引起换出操作。</li><li>可变分配局部置换：系统根据缺页率动态调整各进程占有的物理块数目，使其保持在一个比较低的缺页率状态下。</li></ul><h4 id="物理块分配算法"><a href="#物理块分配算法" class="headerlink" title="物理块分配算法"></a>物理块分配算法</h4><ul><li><p>平均分配算法：将系统中所有可供分配的物理块，平均分配给各个进程。</p></li><li><p>按比例分配算法：按照进程的大小比例分配物理块。</p></li><li><p>考虑优先权的分配算法：为了对于紧迫的作业，能够尽快完成。可以将内存的物理块分成两部分，一部分按照比例分配给各进程，另一部分根据进程优先级，适当增加其相应的份额，分配给各进程。</p></li></ul><h3 id="页面调入"><a href="#页面调入" class="headerlink" title="页面调入"></a>页面调入</h3><h4 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h4><ul><li><p>提前取页：预先装入主存一页或几页（提前页）。</p></li><li><p>请求取页：当用到某页而不在主存时即缺页时取页。</p></li></ul><h4 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h4><p>外存有两个部分：文件区和对换区。对换区I/O操作速度比文件区相对快一些，因此一般应当尽量使用对换区来调入页面。对于不同情况，采用不同的策略：</p><ul><li><p>系统有足够的对换空间：全部从对换区调入。</p></li><li><p>系统对换空间不足：未修改的从文件区调入，修改的从对换区调入。</p></li><li><p>UNIX的调入方式：未运行过的从文件区调入，运行过的放在对换区，允许页面共享。</p></li></ul><h4 id="页面调入过程"><a href="#页面调入过程" class="headerlink" title="页面调入过程"></a>页面调入过程</h4><ol><li>进程需要的页面不在内存，引起缺页中断</li><li>中断处理程序保留现场环境，转入缺页中断处理程序</li><li>中断处理程序查找页表，得到对应的外存物理块号。如果内存有空闲，则启动磁盘操作，将所缺的页面读入，并修改页表。否则，到4。</li><li>执行置换算法，选出要换出的页面，如果该页修改过，应将其写入磁盘，然后将所缺页调入内存，修改相应表项，将其存在位置为<code>1</code>，并放入快表。</li><li>利用修改后的页表，形成物理地址，访问内存数据。</li></ol><h4 id="缺页率"><a href="#缺页率" class="headerlink" title="缺页率"></a>缺页率</h4><ul><li><p>假设进程逻辑空间为n页，系统为其分配物理块数为<code>m</code>。</p></li><li><p>如果进程运行过程中，访问页面成功次数为S，访问页面失败次数为F，总页面访问次数<code>A=S+F</code>，则进程运行过程中 缺页率<code>f=F/A</code>。</p></li></ul><p>影响缺页率的主要因素：</p><ul><li><p>页面大小：页面越大，缺页率越小</p></li><li><p>进程所分配物理块数：物理块越多，缺页率越小</p></li><li><p>页面置换算法：合理的置换算法能更少将页面调入调出</p></li><li><p>程序固有特性：比如做循环操作时，缺页率较低，因为执行的命令都是一系列大致相同的指令。</p></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h4><p>所选择的被淘汰页面，将是以后永不使用的， 或许是在最长（未来）时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。这是一种理想情况，是实际执行中无法预知的，因而不能实现。可用作性能评价的依据。</p><p>例：假定系统为某进程分配了三个物理块， 并考虑有以下的页面号引用串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure><p>进程运行时， 先将7，0，1三个页面装入内存。 以后， 当进程要访问页面2时， 将会产生缺页中断。此时OS根据最佳置换算法， 将选择页面7予以淘汰。</p><div align="center"><img src="/2019/06-虚拟存储器/最佳置换算法.jpg"></div><h4 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h4><p>选择装入最早的页面被置换。可以通过链表来表示各页的建立时间先后。</p><div align="center"><img src="/2019/06-虚拟存储器/先进先出算法.jpg"></div><h4 id="最近最久未使用置换算法"><a href="#最近最久未使用置换算法" class="headerlink" title="最近最久未使用置换算法"></a>最近最久未使用置换算法</h4><p>选择内存中最久未使用的页面被置换。这是局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。</p><div align="center"><img src="/2019/06-虚拟存储器/LRU.jpg"></div><h5 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h5><ul><li><p>寄存器：每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，于是寄存器数<br>值最小的是最久未使用页面。</p><div align="center"><img src="/2019/06-虚拟存储器/寄存器LRU.jpg"></div></li></ul><ul><li><p>栈：一个特殊的栈，每当进程访问某页面时，便把被访问的页面移到栈顶，于是栈底的是最久未使用页面。</p><div align="center"><img src="/2019/06-虚拟存储器/栈LRU.jpg"></div></li></ul><h4 id="最少使用置换算法"><a href="#最少使用置换算法" class="headerlink" title="最少使用置换算法"></a>最少使用置换算法</h4><p>选择到当前时间为止被访问次数最少的页面被置换。</p><ul><li>实现方法1：每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，这样，在最近一段时间内时用最少的页面将是$\sum_{R_i}$最小的页。</li><li>实现方法2：每页设置访问计数器，每当页面被访问时，该页面的访问计数器加1；发生缺页中断时，淘汰计数值最小的页面，并将所有计数清零。</li></ul><h4 id="Clock置换算法"><a href="#Clock置换算法" class="headerlink" title="Clock置换算法"></a>Clock置换算法</h4><p>也称最近未使用算法（NRU, Not Recently Used），它是LRU（最近最久未使用算法）和FIFO的折衷。</p><p>内存中所有页面通过链接指针形成一个循环队列，每页有一个使用访问位，若该页被访问则置1。置换时采用一个指针，从当前指针位置开始按地址先后检查各页，寻找访问位为0的页面作为被置换页。指针经过的访问位为1的页都修改0，最后指针停留在被置换页的下一个页。</p><h4 id="改进Clock置换算法"><a href="#改进Clock置换算法" class="headerlink" title="改进Clock置换算法"></a>改进Clock置换算法</h4><p>由于Clock算法不考虑换出页面时，页面是否修改过的问题。这样在换出的页面如果被修改过的话，则必须做拷回磁盘处理，开销比较大。于是，改进型的Clock算法为每个页又增加了一个修改位。选择页面时，尽量选择既未使用又没有修改的页面。</p><p>访问位A，修改位M有四种不同情形：</p><ul><li><p>1类(A=0，M=0）既未访问，又没有修改，最佳淘汰页</p></li><li><p>2类(A=0，M=1）未访问，但是有修改，效率低的淘汰页</p></li><li><p>3类(A=1，M=0）被访问，但没有修改</p></li><li><p>4类(A=1，M=1）既被访问，又有修改</p></li></ul><p>算法：</p><ol><li>指针从当前位置开始，开始第一轮扫描循环队列，寻找A=0且M=0的页面，找到则可换出。</li><li>如果找不到，则开始第二轮扫描，寻找A=0且M=1的页面，并且每经过一个页面时，将其访问位A设置为0。如果找到一个第2类页面，则可换出。</li><li>如果仍旧未找到合适的换出页面，则此时指针回到初始位置，且所有页面其访问位A为0。再转回1继续工作。</li></ol><h4 id="页面缓冲算法"><a href="#页面缓冲算法" class="headerlink" title="页面缓冲算法"></a>页面缓冲算法</h4><p>在请求分页系统中，进程在运行的时候经常会发生页面换进换出的情况。而影响换进换出效率的原因如下：</p><ul><li>页面置换算法：好的页面置换算法能使进程运行中具有较低的缺页率，从而可以减少换进换出的开销。</li><li>写会磁盘的频率。</li><li>读入内存的频率。</li></ul><p>而页面缓存算法就是降低读写磁盘的频率来降低开销。做法如下：</p><ul><li>空闲页面链表：当有一个未被修改的页要换出时，实际上并不将其换出到外存，而是把它们所在的物理块挂在空闲链表的末尾。如果以后某进程请求此页时，便将其从空闲页面链表上取下。</li><li>修改页面链表：和空闲页面链表的功能一样，只是说此链表是存放已修改页面的。</li></ul><p>当链表上挂有足够多的页面时，将它们一齐写入磁盘，这样可以降低读写磁盘的频率。</p><h3 id="访问内存的有效时间"><a href="#访问内存的有效时间" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3><ul><li><p>被访问页在主存，且相应页表项在快表：$EAT= \lambda +t$</p><ul><li>查找快表+访问实际物理地址</li></ul></li><li><p>被访问页在主存，但相应页表项不在快表：$ EAT= \lambda +t + t + \lambda$</p><ul><li>查找快表+读取页表+读取数据+更新快表</li></ul></li><li><p>被访问页不在主存：$EAT= \lambda + t + \varepsilon + t + \lambda​$</p><ul><li>查找快表+读取页表+缺页中断处理+读取数据+等新快表</li></ul></li><li><p>内存的有效访问时间为：$EAT= \lambda + t + (1 - a ) \ast [f \ast ( \varepsilon + \lambda + t)+(1-f) \ast(\lambda+t)]$</p><ul><li><code>a</code>为命中率，<code>f</code>为缺页率。</li><li>查找快表+访问内存一次+未命中不需要请求缺页访问快表+未命中时不需要请求缺页访问内存+未命中需要请求缺页访问快表+未命中时需要请求缺页访问内存+未命中时需要请求缺页开销。</li></ul></li></ul><h2 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h2><h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>由于只装入一个进程的部分程序和数据便可开始运行，故希望运行更多进程，增加多道程序度。但在多道程序环境下，并不是多道程序的度越高，系统吞吐量越大。当CPU的利用率达到某一峰值后，若继续增加多道程度，将产生“抖动”。</p><p>抖动是指同时运行进程太多，分配给每个进程物理块太少，进程在运行时频繁缺页，必须请求调页，等待页面调进调出的进程增多，磁盘访问时间急剧增加，进程大部分时间用于页面换进换出，处理机利用率急剧下降并趋于0。</p><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>基于程序运行的局部性原理，程序运行时，对页面的访问并不均匀，一段时间仅局限于较少的页面；另一段时间，有可能局限于另一些较少的页面，如果能预知这些页面，并提前调入，将大大减少缺页率工作集，是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。</p><ul><li>方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。</li></ul><p>定义：是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。</p><ul><li>方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。</li></ul><p>工作集$ \omega (t, \Delta) $是二元函数。某进程在时间<code>t</code>的工作集记为$ \omega (t, \Delta) $，其中，$\Delta$为工作集的窗口尺寸。</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><ul><li><p>窗口大小$\Delta$选择得过小，频繁产生缺页中断。</p></li><li><p>窗口大小$\Delta$选择得很大，失去了虚拟存储器的意义</p></li></ul><div align="center"><img src="/2019/06-虚拟存储器/工作集.jpg"></div><h3 id="抖动的预防方法"><a href="#抖动的预防方法" class="headerlink" title="抖动的预防方法"></a>抖动的预防方法</h3><ul><li><p>采取局部置换策略：仅允许进程在自身范围内进行置换，不影响其他进程</p></li><li><p>在CPU调度程序中引入工作集算法：调入新作业时，应该检查每个进程在内存中的驻留集是否足够大</p></li><li><p><code>L=S</code>准则：<code>产生缺页的平均时间L=系统处理进程缺页的平均时间S</code></p></li><li><p>选择暂停的进程：使某些低优先级的进程进程挂起，从而腾出内存空间</p></li></ul><h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><ul><li><p>请求分页系统建立的虚拟存储器，是以页面为单位进行换入、换出操作的。</p></li><li><p>在请求分段系统中实现的虚拟存储器，以分段为单位进行换入和换出。</p></li><li><p>程序在运行之前，只需要装入必要的若干个分段即可运行。当访问的分段不在内存时，可由OS将所缺少的段调入内存。</p></li></ul><p>使用请求分段存储管理方式可以对动态链接有很好的支持。</p><h3 id="请求段表机制"><a href="#请求段表机制" class="headerlink" title="请求段表机制"></a>请求段表机制</h3><div align="center"><img src="/2019/06-虚拟存储器/段表.jpg"></div><ul><li><p>存取方式：标记本段存取属性。如读R，写W，执行X</p></li><li><p>访问字段A：记录本段使用的频繁程度</p></li><li><p>修改位：是否在调入内存后做过修改</p></li><li><p>存在位：本段是否装入内存</p></li><li><p>增补位：该段是否动态增长过</p></li></ul><h3 id="缺段中断机构"><a href="#缺段中断机构" class="headerlink" title="缺段中断机构"></a>缺段中断机构</h3><p>要有专门的缺段中断处理程序。特点：</p><ul><li>指令和操作数必定不会跨越在段边界上。</li><li>由于段的长度是不固定的，处理比缺页系统复杂。</li><li>调入一个段可能要淘汰几个内存中的段。</li></ul><h3 id="请求中断处理"><a href="#请求中断处理" class="headerlink" title="请求中断处理"></a>请求中断处理</h3><div align="center"><img src="/2019/06-虚拟存储器/请求中断处理.jpg"></div><h3 id="地址中断机构"><a href="#地址中断机构" class="headerlink" title="地址中断机构"></a>地址中断机构</h3><div align="center"><img src="/2019/06-虚拟存储器/地址变换机构.jpg"></div><h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3><h4 id="共享段表"><a href="#共享段表" class="headerlink" title="共享段表"></a>共享段表</h4><div align="center"><img src="/2019/06-虚拟存储器/共享段表.jpg"></div><ul><li>共享进程计数：多少进程在使用此段。</li><li>存取控制手段：每个共享段，应为不同进程赋予不同的存取权限。</li><li>断号：同一个共享段在不同进程那有不同的断号。</li></ul><h4 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h4><p>第一个请求的进程，由系统分配一物理块，调入共享段，设置相关表项信息，并置<code>count=1</code>； 以后的进程，在自己的段表中增加一项，填入共享段的信息，在共享段表项中做<code>count=count+1</code>，填写进程相关信息。</p><h4 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h4><ol><li>做count=count-1；</li><li>若count=0 ，则该共享段被回收。</li></ol><h4 id="分段保护"><a href="#分段保护" class="headerlink" title="分段保护"></a>分段保护</h4><ul><li>越界检查：在进行存储访问时，要将逻辑地址的段号与段表长度进行比较，如果超出则发生越界中断信号；其次，将段内地址与段表中该段的长度进行比较，如果有效才进行转换，否则产生越界中断信号。</li><li><p>存取控制检查：用于规定对该段的访问权限。通常的访问方式有：</p><ul><li>读：允许用户对该段/页内任何信息或其副本进行读操作。</li><li>写：允许用户修改该段/页内任何信息直至撤消整个段/页。</li><li>执行：用户可以执行该段/页程序，数据段/页除外。</li><li>增加：用户可在段/页的末尾添加信息，但不允许修改已存在于段/页中的信息。</li></ul></li><li><p>环保护检查：是一种功能较完善的保护机制。</p><ul><li>思想：将所有的程序分成不同的级别，分别放置在不同的环上。内环（编号小，在内侧）的程序具有高优先权，外环的程序优先权低。</li><li>操作系统核心安排在0环内；重要程序和操作系统服务安排在中间环；一般应用程序安排在外环。</li><li>一个程序可以直接访问在相同环或低优先级环（比自身相对靠外的环）上的数据。</li><li>一个程序访问高优先级（比自己靠内的环）时，通过系统调用方式实现。</li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;传统存储器的问题&quot;&gt;&lt;a href=&quot;#传统存储器的问题&quot; class=&quot;headerlink&quot; title=&quot;传统存储器的问题&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>redis入门</title>
    <link href="https://isjinhao.github.io/2019/redis%E5%85%A5%E9%97%A8/"/>
    <id>https://isjinhao.github.io/2019/redis入门/</id>
    <published>2019-03-16T03:06:04.000Z</published>
    <updated>2019-03-16T11:33:11.558Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>本人使用的是<code>redis-3.0.0</code>和<code>阿里云centos7</code>服务器。</p><ul><li><p>上传<code>redis-3.0.0</code>到服务器。</p></li><li><p>安装<code>gcc</code>环境：<code>yum install gcc-g++</code></p></li><li><p>解压<code>redis-3.0.0</code>：<code>tar -zxvf ...</code></p></li><li><p>进入解压后的<code>redis</code>文件夹</p></li><li><p>执行：<code>make</code></p></li><li><p>安装：<code>make PREFIX=/usr/local/redis install</code></p></li><li><p>拷贝<code>redis</code>文件夹的<code>redis.conf</code>到<code>/usr/local/redis</code>下</p></li><li><p>修改<code>/usr/local/redis</code>下的<code>redis.conf</code>，搜索以<code>daemonize</code>开头的行，将此行修改为<code>daemonize yes</code>。修改后<code>redis</code>以后台进程运行。</p></li><li><p>开放端口：<code>redis</code>默认端口是<code>6379</code>。</p><ol><li><p><code>/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT</code></p></li><li><div align="center"><img src="/2019/redis入门/开放端口.jpg"></div></li></ol></li><li><p>启动服务器：<code>./xxx/redis-server xxx/redis.conf</code></p></li><li><p>使用客户端连接服务器：<code>./xxx/redis-cli -h ip地址 -p 6379</code></p></li><li><p>连接测试：<code>ping</code>显示<code>PONG</code>表名成功</p><div align="center"><img src="/2019/redis入门/连接成功.jpg"></div></li><li><p>关闭客户端：<code>quit</code></p></li><li><p>关闭服务器：<code>./bin/redis-cli shutdown</code></p></li></ul><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><h3 id="存储string"><a href="#存储string" class="headerlink" title="存储string"></a>存储<code>string</code></h3><ul><li><p>设置：<code>set key value</code></p></li><li><p>取值：<code>get key</code></p></li><li><p>删除：<code>del username</code></p></li></ul><div align="center"><img src="/2019/redis入门/string赋值取值删除.jpg"></div><ul><li>数值相加减<ul><li>加一：<code>incr key</code></li><li>减一：<code>decr key</code></li><li>加x：<code>incrby key x</code></li><li>减x：<code>decrby key x</code></li></ul></li></ul><div align="center"><img src="/2019/redis入门/string数值相加减.jpg"></div><ul><li>字符串拼接</li></ul><div align="center"><img src="/2019/redis入门/string拼接.jpg"></div><h3 id="存储Map"><a href="#存储Map" class="headerlink" title="存储Map"></a>存储<code>Map</code></h3><ul><li><p>赋值：</p></li><li><p>赋多值：</p><div align="center"><img src="/2019/redis入门/map赋值.jpg"></div></li><li><p>取值：</p><div align="center"><img src="/2019/redis入门/map取值.jpg"></div></li><li><p>删除字段：</p></li><li><p>删除map：</p><div align="center"><img src="/2019/redis入门/map删除.jpg"></div></li><li><p>判断字段存在：</p></li><li><p>获取全部entry：</p></li><li><p>获取全部key：</p></li><li><p>获取全部value：</p><div align="center"><img src="/2019/redis入门/map补充.jpg"></div></li></ul><h3 id="存储list"><a href="#存储list" class="headerlink" title="存储list"></a>存储list</h3><ul><li><p>头部添加：</p></li><li><p>尾部添加：</p><div align="center"><img src="/2019/redis入门/list两端添加.jpg"></div><div align="center"><img src="/2019/redis入门/查看列表值个数.jpg"></div></li><li><p>查看列表：</p><div align="center"><img src="/2019/redis入门/查看链表.jpg"></div></li><li><p>头部弹出：</p></li><li><p>尾部弹出：</p><div align="center"><img src="/2019/redis入门/两端弹出.jpg"></div></li><li><p><code>lpushx key value</code>：仅当<code>key</code>存在时才向头部插入</p></li><li><p><code>rpush key value</code>：仅当<code>key</code>存在时才向尾部插入</p></li><li><p>删除：<code>irem key count value</code>：<code>count&gt;0</code>时从头部开始删除<code>|count|</code>个值为<code>value</code>的元素；<code>count&lt;0</code>时从尾部开始删除<code>|count|</code>个值为<code>value</code>的元素；<code>count=0</code>时删除全部的值为<code>|value|</code>的元素。</p></li><li><p>设置：<code>lset key index value</code>：设置链表中索引值为<code>index</code>的元素，<code>0</code>是链表头，<code>-1</code>是链表尾。索引值不存在抛异常。</p></li><li><p><code>lindex key index</code>：通过索引获取列表中的元素</p></li><li><p><code>linsert key before|after pivot value</code>：在列表的元素前或者后插入元素</p></li><li><p><code>rpoplpush source destination</code>：移除列表的最后一个元素，并将该元素添加到另一个列表并返回</p></li></ul><h3 id="存储set"><a href="#存储set" class="headerlink" title="存储set"></a>存储<code>set</code></h3><ul><li><code>SADD key member1 member2...</code>：向集合添加一个或多个成员</li><li><p><code>SREM key member1 member2...</code>：移除集合中一个或多个成员</p></li><li><p><code>SISMEMBER key member</code>：判断 member 元素是否是集合 key 的成员</p><ul><li>1：存在</li><li>0：key不存在或member不存在</li></ul></li><li><p><code>sdiff key1 key2</code>：返回集合<code>key1-key2</code>的数据</p></li><li><p><code>sinter key1 key2 ...</code>：返回集合<code>key1,key2,...</code>的交集</p></li><li><p><code>sunion key1 key2 ...</code>：返回集合<code>key1,key2,...</code>的并集</p></li><li><p><code>scard key</code>：返回集合的数量</p></li><li><p><code>srandmember key</code>：随机返回集合中的一个数据</p></li><li><p>集合运算拓展</p><div align="center"><img src="/2019/redis入门/集合运算拓展.jpg"></div></li></ul><h3 id="存储sortedset"><a href="#存储sortedset" class="headerlink" title="存储sortedset"></a>存储<code>sortedset</code></h3><p>有序集合和集合一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><ul><li><code>ZADD key score1 member1 [score2 member2]</code>：向有序集合添加一个或多个成员，或者更新已存在成员的分数。</li><li><code>ZSCORE key member</code>：返回有序集中，成员的分数值。</li><li><code>ZREM key member1 member2 ...</code>：移除有序集合中的一个或多个成员</li><li><code>ZRANGE key start stop [WITHSCORES]</code>：通过索引区间返回有序集合成指定区间内的成员。<code>withscores</code>表示返回的成员包含分数。</li><li><code>ZREVRANGE key start stop [WITHSCORES]</code>：返回有序集中指定区间内的成员，通过索引，分数从高到底。<code>withscores</code>表示返回的成员包含分数。</li><li><code>ZREMRANGEBYRANK key start stop</code>：移除有序集合中给定的排名区间的所有成员</li><li><code>ZREMRANGEBYSCORE key min max</code>：移除有序集合中给定的分数区间的所有成员</li></ul><h2 id="keys的通用操作"><a href="#keys的通用操作" class="headerlink" title="keys的通用操作"></a>keys的通用操作</h2><ul><li><code>keys pattern</code>：获取所有和<code>pattern</code>匹配的key。</li><li><code>del key1, key2, ...</code>：删除指定key。</li><li><code>exists key</code>：<code>key</code>是否存在。</li><li><code>rename key newkey</code>：为当前的<code>key</code>重命名。</li><li><code>expire key</code>：为<code>key</code>设置过期时间，单位：秒。</li><li><code>ttl key</code>：获取<code>key</code>所剩的时间，如果没有设置超时，返回<code>-1</code>，<code>key</code>不存在返回<code>-2</code>。</li><li><code>type key</code>：以字符串形式返回<code>key</code>的类型。<code>key</code>不存在返回<code>none</code>。</li></ul><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p><code>jedis</code>是<code>Java</code>操作<code>redis</code>的一套规范。使用<code>jedis</code>需要有两个包。<code>commons-pool2-2.3.jar</code>和<code>jedis-2.7.0.jar</code>。</p><h3 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"59.110.143.226"</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.set(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">String string = jedis.get(<span class="string">"name"</span>);</span><br><span class="line">System.out.println(string);</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工具类连接"><a href="#工具类连接" class="headerlink" title="工具类连接"></a>工具类连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maxTotal=20</span><br><span class="line">maxWaitMillis=7000</span><br><span class="line">host=59.110.143.226</span><br><span class="line">port=6379</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisPoolConfig jc = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxTotal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> maxWaitMillis = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String host = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisPool pool=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">jc=<span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line"><span class="comment">//获取properties中的配置数据</span></span><br><span class="line">ResourceBundle re = ResourceBundle.getBundle(<span class="string">"jedis"</span>);</span><br><span class="line">maxTotal=Integer.parseInt(re.getString(<span class="string">"maxTotal"</span>));</span><br><span class="line">maxWaitMillis=Long.parseLong(re.getString(<span class="string">"maxWaitMillis"</span>));</span><br><span class="line"></span><br><span class="line">jc.setMaxTotal(maxTotal);</span><br><span class="line">jc.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line">host = re.getString(<span class="string">"host"</span>);</span><br><span class="line">port = Integer.parseInt(re.getString(<span class="string">"port"</span>));</span><br><span class="line"><span class="comment">//创建Jedis池</span></span><br><span class="line">    pool=<span class="keyword">new</span> JedisPool(jc, host, port);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> pool.getResource();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUtils</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Jedis jedis=JedisPoolUtils.getJedis();</span><br><span class="line">jedis.set(<span class="string">"username2"</span>, <span class="string">"xiaowang"</span>);</span><br><span class="line">String string = jedis.get(<span class="string">"username2"</span>);</span><br><span class="line">System.out.println(string);</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h2><p><code>redis</code>的一个实例可以有多个数据库，就像一个<code>mysql</code>可以有多个数据库一样。一个<code>redis</code>实例最多可以提供16个数据库，下标从0到15，默认是0号数据库，连接其他数据库使用<code>select num</code>。</p><div align="center"><img src="/2019/redis入门/redis选择数据库.jpg"></div><ul><li>移动<code>key</code>到指定数据库</li></ul><div align="center"><img src="/2019/redis入门/移动key.jpg"></div><h2 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h2><p>订阅就是一个客户端在某个频道里发消息，其它订阅到此频道的客户端接收消息。</p><ul><li><p>订阅：</p><div align="center"><img src="/2019/redis入门/订阅到单频道.jpg"></div></li><li><p>发布消息：</p><div align="center"><img src="/2019/redis入门/发布消息.jpg"></div></li><li><p>批量订阅：</p><div align="center"><img src="/2019/redis入门/批量订阅.jpg"></div></li><li><p>发布消息：</p><div align="center"><img src="/2019/redis入门/批量订阅发布.jpg"></div></li></ul><h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>每隔指定时间自动把内存中数据写入一个文件，下次启动时加载文件，这样内存中就有上次的数据。<code>redis</code>默认的持久化方式。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在<code>redis.conf</code>的140多行有如下配置是RDB配置。</p><div align="center"><img src="/2019/redis入门/RDB配置.jpg"></div><ul><li><code>save 900 1</code>：每900秒至少有1个key发生变化，则备份内存快照。</li><li><code>save 300 10</code>：每300秒至少有10个key发生变化，则备份内存快照。</li><li><code>save 60 10000</code>：每60秒至少有10000个key发生变化，则备份内存快照。</li></ul><p>位置：</p><div align="center"><img src="/2019/redis入门/RDB位置.jpg"></div><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>把对<code>redis</code>的操作存在一个文件中，下次开机时按照文件的记录再次将数据存在内存中。</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p><code>appendonly no</code>改为<code>appendonly yes</code>。</p><div align="center"><img src="/2019/redis入门/aof开启.jpg"></div><div align="center"><img src="/2019/redis入门/aof配置2.jpg"></div><ul><li><code>appendfsync always</code>：每次有数据修改时，都会写入AOF文件</li><li><code>appendfsync everysec</code>：每秒同步一次，写入AOF文件</li><li><code>appendfsynv no</code>：从不同步。</li></ul><p>手动重写aof文件命令：<code>bgrewriteaof</code>。</p><h2 id="启动多个redis"><a href="#启动多个redis" class="headerlink" title="启动多个redis"></a>启动多个redis</h2><ol><li>拷贝安装目录下的<code>redis</code>文件夹</li><li>修改<code>redis.conf</code>文件的端口号</li><li>启动<code>redis</code>时指定配置文件，保证端口号不同</li><li>关闭时指定端口号，如：<code>./bin/redis-cli -p 端口号 shutdown</code></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;环境安装&quot;&gt;&lt;a href=&quot;#环境安装&quot; class=&quot;headerlink&quot; title=&quot;环境安装&quot;&gt;&lt;/a&gt;环境安装&lt;/h2&gt;
      
    
    </summary>
    
      <category term="redis" scheme="https://isjinhao.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="https://isjinhao.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>05-内存管理</title>
    <link href="https://isjinhao.github.io/2019/05-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://isjinhao.github.io/2019/05-内存管理/</id>
    <published>2019-03-15T04:23:48.000Z</published>
    <updated>2019-03-17T06:31:25.253Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="存储器的层次"><a href="#存储器的层次" class="headerlink" title="存储器的层次"></a>存储器的层次</h2><p>我们都知道存储器的容量和速度是限制计算机发展的一大原因，人们对存储器的要求需要既快又大，但是这样带来的结果就是存储器的造价非常昂贵，所以不可能在计算机中全部配置既快又大的存储器。所以现代的计算机系统中都配置了多层结构的存储器系统来平衡速度差异问题。</p><div align="center"><img src="/2019/05-内存管理/存储器分级.jpg"></div><p>存储器一般被分成六层，不过在只有前四层属于内存，所以此篇只介绍前四层：</p><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><ul><li><p>用于保存进程运行时的程序和数据。</p></li><li><p>对于微机系统和大中型机，容量为数十MB到数GB；对于嵌入式系统，容量为数十KB到数MB。</p></li><li>CPU从主存读取指令和数据。</li><li>CPU与外设交换信息要依托主存。</li><li>为缓解CPU执行指令速度和主存访问速度的矛盾，引入寄存器和高速缓冲。</li></ul><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ul><li><p>访问速度做快，完全与CPU协调工作，价格十分昂贵，容量不可能很大。</p></li><li><p>长度一般以字为单位。</p></li><li><p>对于微机系统和大中型机，可能有几十个甚至上百个；对于嵌入式系统，仅有几个到几十个。</p></li></ul><h3 id="高速缓冲"><a href="#高速缓冲" class="headerlink" title="高速缓冲"></a>高速缓冲</h3><ul><li><p>容量大于或远大于寄存器，比内存小两到三个数量级左右，从几十KB到几MB。</p></li><li><p>访问速度快于主存。</p></li><li><p>将主存中经常访问的信息存放在高速缓冲，减少访问主存次数。</p></li></ul><h3 id="磁盘缓冲"><a href="#磁盘缓冲" class="headerlink" title="磁盘缓冲"></a>磁盘缓冲</h3><ul><li><p>将一部分频繁使用的磁盘数据和信息，暂时存放在磁盘缓冲中，减少访问磁盘次数。</p></li><li><p>不是实际存在的存储介质，利用主存的存储空间，暂存从磁盘读出或写入的信息。</p></li></ul><p>总结一下：磁盘缓冲是为了解决内存和外存的速度差异而在内存中开辟的一块用于暂存磁盘数据的存储介质。主存储器是保存进程运行时的程序和数据的。寄存器是和CPU速度匹配的存储器，直接给CPU提供数据。虽然CPU是直接从寄存器去取指令和数据，但是寄存器的数据来源最终还是主存储器，所以为了减少访问CPU的次数，产生了高速缓冲来缓和寄存器和主存储器的矛盾。至于为什么能缓和呢？这是由于<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/15572003" target="_blank" rel="noopener">程序局部性原理</a>。</p><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>用户程序要在系统中运行，必须将它装入内存，其中有三个过程。</p><ul><li><p>编译：由编译程序（Complier）将用户源代码编译成若干个目标模块（Object Module）；</p></li><li><p>链接：由链接程序（Linker）将编译后形成的目标模块以及它们所需要的库函数，链接在一起，形成一个装入模块（Load Module）；</p></li><li>装入：由装入程序(Loader)将装入模块装入内存。</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接程序的功能是将经过编译或汇编后得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块。</p><h4 id="静态链接方式"><a href="#静态链接方式" class="headerlink" title="静态链接方式"></a>静态链接方式</h4><p>生成可执行文件时进行链接。主要有两步。</p><ol><li>修改相对地址。</li><li>变换外部调用符号。</li></ol><h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><p>目标模块是在装入内存时，边装入边链接的。装入时动态链接方式有以下优点：</p><ul><li><p>便于修改和更新。</p></li><li><p>便于实现对目标模块的共享。</p></li></ul><h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><p>将对某些模块的链接推迟到执行时才执行，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存， 把它链接到调用者模块上。</p><p>凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。</p><h3 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h3><p>装入是将一个具有执行资格的模块加载进内存。</p><h4 id="绝对装入方式"><a href="#绝对装入方式" class="headerlink" title="绝对装入方式"></a>绝对装入方式</h4><p>在可执行文件中指定内存地址，装入时直接定位在上述（即文件中记录的地址）内存地址。逻辑地址和物理地址完全相同。</p><h4 id="可重定位装入方式"><a href="#可重定位装入方式" class="headerlink" title="可重定位装入方式"></a>可重定位装入方式</h4><p>编译程序所生成的目标模块中采用逻辑地址，根据当前内存情况，将装入模块装入到适当位置。地址映射是在装入模块装入内存时一次性进行的，即是静态重定位。</p><div align="center"><img src="/2019/05-内存管理/静态重定位.jpg"></div><h4 id="动态运行时装入方式"><a href="#动态运行时装入方式" class="headerlink" title="动态运行时装入方式"></a>动态运行时装入方式</h4><p>静态重定位时程序装入内存后不能移动，而且通常需要占用连续的内存空间。所以与其对应的动态重定位是将地址映射工作推迟到程序真正执行时才进行。</p><div align="center"><img src="/2019/05-内存管理/动态重定位.jpg"></div><h3 id="现代计算机运行过程"><a href="#现代计算机运行过程" class="headerlink" title="现代计算机运行过程"></a>现代计算机运行过程</h3><ul><li><p>预处理</p><ul><li>把存储在不同文件中的源程序聚合在一起。</li><li>把被称为宏的缩写语句转换为原始语句。</li></ul></li><li><p>编译：将高级语言翻译成汇编语言或机器语言。</p></li><li><p>链接</p><ul><li>将多个可重定位的机器代码文件（包括库文件）连接到一起。</li><li>解决外部内存地址（一个文件中的代码会引用其他文件中的数据对象或过程，这些数据对象或过程的地址对于此文件来说就是外部地址）问题。</li></ul></li><li><p>装入</p><p>确定程序在内中的绝对地址（即修改程序起始地址），将修改后的指令和数据放到内存中适当的位置。</p></li></ul><h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>连续分配是指为一个用户程序分配空间的时候，将所有程序装入到一段连续的物理内存中。在早期（20世纪60-80<br>年代）的操作系统中，这种分配内存的方式曾经被广泛的使用。</p><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>这是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。内存分为以下两个分区：系统区和用户区。操作系统使用系统区；应用程序装入到用户区，可使用用户区全部空间。</p><div align="center"><img src="/2019/05-内存管理/单一连续分配.jpg"></div><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>固定分区式分配，是最早使用的一种可运行多道程序的存储管理方式。它将内存空间划分为若干个固定大小的区域，每个分区大小可相同，也可不同。OS占一区，其余每个分区中可以装入一道作业。</p><p>为了便于内存分配，系统需建立一张分区使用表。当有一用户程序要装入时，从表中找出一个能满足要求的、尚未分配的分区分配给该程序，然后修改分区使用表。</p><div align="center"><img src="/2019/05-内存管理/固定分区分配.jpg"></div><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>空闲分区表<ul><li>每个空闲分区占用一个表项。</li><li>分区表的表项中包含分区号、分区始址及分区大小等表目。</li><li>表长不易确定。</li><li>占用额外内存。</li></ul></li><li>空闲分区链表<ul><li>利用各空闲分区自身的单元组成双向链表。</li><li>操作速度较慢。</li></ul></li></ul><div align="center"><img src="/2019/05-内存管理/动态分区数据结构.jpg"></div><h4 id="分区分配"><a href="#分区分配" class="headerlink" title="分区分配"></a>分区分配</h4><div align="center"><img src="/2019/05-内存管理/分区分配.jpg"></div><h4 id="分区回收"><a href="#分区回收" class="headerlink" title="分区回收"></a>分区回收</h4><ul><li>如果回收区的前后有空闲区，可分为图示三种情况。回收时将空闲区和回收区合并。</li></ul><div align="center"><img src="/2019/05-内存管理/分区回收.jpg"></div><ul><li>如果回收区的前后无空闲区，新建一个表项，填写信息插入。</li></ul><h4 id="分区检索算法"><a href="#分区检索算法" class="headerlink" title="分区检索算法"></a>分区检索算法</h4><h5 id="顺序检索算法"><a href="#顺序检索算法" class="headerlink" title="顺序检索算法"></a>顺序检索算法</h5><ul><li>首次适应算法：按各空闲分区首址的升序的方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从头查找，找到符合要求的第一个分区。</li><li>循环首次适应算法：分配空闲空间时，不是从链首（或表头）开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找。</li><li>最佳适应算法：按空闲区大小的升序方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从<br>头查找，找到符合要求的第一个分区。就说明它是最适合的（即最佳的）。</li><li>最坏适应算法：按空闲区大小的降序方法组织，分配时总是取空闲分区表（或空闲分区链）中的第一项，<br>若大小不能满足申请者的要求，则表示系统中无满足要求的空闲区，分配失败；否则分配。</li></ul><h5 id="索引检索算法"><a href="#索引检索算法" class="headerlink" title="索引检索算法"></a>索引检索算法</h5><ul><li>快速适应算法：将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应一种空闲分区类型，并记录其表头指针。空闲分区的分类是根据进程常用的空间大小进行划分，对于其他大小的分区，可以放在一个特殊的空闲区链表中。</li><li>伙伴系统：分区大小均为2的K次幂。假设系统可利用空间容量为$2^m$个字，系统运行过程中，不断划分，将空闲分区根据大小分类。为长度为n的进程分配分区时，首先计算$i$值使得$2^{i-1}≦n≦2^i$。先找大小为$2^i$的分区分配，否则找大小为$2^{i+1}$的分区分配，把$2^{i+1}$分区分成两个$2^i$分区（互称伙伴），一个分配，另一个加入$2^i​$的空闲分区链表。分配可能经过多次分割，回收可能进行多次合并。</li><li>哈希算法：根据空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最近分配策略。</li></ul><h4 id="紧凑"><a href="#紧凑" class="headerlink" title="紧凑"></a>紧凑</h4><p>可变式分区也有零头问题。在系统不断地分配和回收中，必定会出现一些不连续的小的空闲区，称为外零头。虽然可能所有零头的总和超过某一个作业的要求，但是由于不连续而无法分配。解决零头的方法是拼接（或称紧凑），即向一个方向（例如向低地址端）移动已分配的作业，使那些零散的小空闲区在另一方向连成一片。分区的拼接技术，一方面是要求能够对作业进行重定位，另一方面系统在拼接时要耗费较多的时间。</p><div align="center"><img src="/2019/05-内存管理/紧凑.jpg"></div><h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>页面：将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。</p></li><li><p>物理块：把内存空间分成与页面相同大小的若干个存储块，称为（物理）块或页框（frame）。</p></li><li><p>页面碎片：由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。</p></li><li><p>页面大小：每一页可进行编址的地址数目。</p></li><li><p>逻辑地址：</p><div align="center"><img src="/2019/05-内存管理/分页逻辑地址.jpg"></div></li><li><p>页表：系统为每个进程建一张页表，其在内存的起始地址和长度记录在该进程的PCB中。</p><div align="center"><img src="/2019/05-内存管理/页表.jpg"></div></li><li><p>页表项：页表的每一行。</p></li><li>页表项长度：每个页表项占用的编址个数。从逻辑地址那里我们可以看到页号占用了20位，对应的块号也要占用20位，当然块号本身可能不止$2^{20}$个。又由于为了控制对物理块的读写等操作，会在页表项中加上控制字段。如果内存按字节编址，即每个编址可以存储8个二进制位，那么页表项占用的二进制位总数大于内存的字长度。我们需要把一个页表项拆开存放在多个编址后的空间中。</li></ul><div align="center"><img src="/2019/05-内存管理/页表项.jpg" style="width:80%"></div><h3 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h3><div align="center"><img src="/2019/05-内存管理/页表基本地址变换.jpg"></div><p>$物理地址=块号+块内地址=F(逻辑地址的页号*页表项长度+页表始址)+业内地址$。</p><p>每次进行地址变换需要访问两次内存，内存速度较慢，所以影响计算机整体性能。</p><h3 id="具有快表的地址变换"><a href="#具有快表的地址变换" class="headerlink" title="具有快表的地址变换"></a>具有快表的地址变换</h3><p>根据程序局部性原理，把最近使用的页表项存放在快表中，下次再进行地址变换时先去快表中查找对应项，如果没找到再去内存中查找，然后把新找到的页表项存放在快表中，如果快表已满，采用某种算法淘汰一份。</p><div align="center"><img src="/2019/05-内存管理/具有快表的页表地址变换.jpg"></div><h3 id="有效访问时间"><a href="#有效访问时间" class="headerlink" title="有效访问时间"></a>有效访问时间</h3><p>设t是访问内存的时间，a是快表命中率，λ是查找快表所需的时间。</p><ul><li><p>普通地址变换时间：<code>t+t</code></p></li><li><p>具有快表的地址变换时间：$ a \ast \lambda + (1-a) \ast (t+\lambda)$。</p></li></ul><h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><p>对于两级页表，是将页表再进行分页，页面的大小与内存物理块的大小相同。逻辑地址结构可描述如下：</p><div align="center"><img src="/2019/05-内存管理/两级页表.jpg"></div><h3 id="两级页表地址变换"><a href="#两级页表地址变换" class="headerlink" title="两级页表地址变换"></a>两级页表地址变换</h3><div align="center"><img src="/2019/05-内存管理/两级页表地址变换.jpg"></div><p>可推广至N级页表。</p><h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><p>页表是按每个进程的页号排序，指示出物理块号的位置，反置页表是按物理块号排序，指示出每个页隶属的进程和页号。</p><p>此方法需要为每个进程创建一个外部页表，即将页表建立在外存中。进程进行地址变换时先从反置页表里查找，如果查找不到则去外村中查找，再将查找到的页表项调入内存。</p><div align="center"><img src="/2019/05-内存管理/反置页表.jpg"></div><h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><p>之前的分区管理都是为了更好的利用内存。为了满足程序员在编程上的要求引入了分段管理方式。</p><ul><li><p>方便编程：通常，用户把自己的作业按照逻辑关系划分为若干个段，每个段都是从0开始编址，并有自己的名字和长度。因此，希望要访问的逻辑地址是由段名（段号）和段内偏移量（段内地址）决定的。例如，下述的两条指令便是使用段名和段内地址：其中，前一条指令的含义是将分段A中D单元内的值读入寄存器1；后一条指令的含义是将寄存器1的内容存入B分段的C单元中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD 1，[A] |〈D〉；</span><br><span class="line">STORE 1，[B] |〈C〉；</span><br></pre></td></tr></table></figure></li><li><p>信息共享：在实现对程序和数据的共享时，是以信息的逻辑单位为基础的。比如，共享某个例程和函数。分页系统中的“页”只是存放信息的物理单位（块），并无完整的意义，不便于实现共享；然而段却是信息的逻辑单位。由此可知，为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适应。</p></li><li><p>信息保护：信息保护同样是对信息的逻辑单位进行保护，因此，分段管理方式能更有效和方便地实现信息保护功能。</p></li><li>动态增长：在实际应用中，往往有些段，特别是数据段，在使用过程中会不断地增长，而事先又无法确切地知道数据段会增长到多大。前述的其它几种存储管理方式，都难以应付这种动态增长的情况，而分段存储管理方式却能较好地解决这一问题。</li><li>动态链接：动态链接是指在作业运行之前，并不把几个目标程序段链接起来。要运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段（目标程序）调入内存并进行链接。可见，动态链接也要求以段作为管理的单位。</li></ul><h3 id="分段地址"><a href="#分段地址" class="headerlink" title="分段地址"></a>分段地址</h3><div align="center"><img src="/2019/05-内存管理/分段地址.jpg"></div><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><div align="center"><img src="/2019/05-内存管理/段表.jpg"></div><h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><div align="center"><img src="/2019/05-内存管理/分段地址映射.jpg"></div><h3 id="地址变换-1"><a href="#地址变换-1" class="headerlink" title="地址变换"></a>地址变换</h3><div align="center"><img src="/2019/05-内存管理/分段地址变换.jpg"></div><h3 id="分页和分段的主要区别"><a href="#分页和分段的主要区别" class="headerlink" title="分页和分段的主要区别"></a>分页和分段的主要区别</h3><ul><li>页是信息的物理单位，段则是信息的逻辑单位；</li><li>页的的大小固定且由系统决定，而段的长度不固定，由用户所编写的程序决定；</li><li>分页的地址空间是一维的，而分段的地址空间是二维的。</li><li>分页是系统管理的需要；分段是为了更好满足用户的需要。</li></ul><h2 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h2><p>分段结构具有逻辑上清晰的优点，但它的一个致命弱点是每个段必须占据主存储器的连续区域，于是，要装入一个分段时可能要移动已在主存储器中的信息，为了克服这个缺点，可兼用分段和分页的方法，构成段页式存储管理。每个作业仍按逻辑分段，但对每一段不是按单一的连续整体存放到存储器中，而是把每个段再分成若干个页面，每一段不必占据连续的主存空间，可把它按页存放在不连续的主存块中。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>逻辑地址空间分段，段内分页，内存分块（页框），存储管理的分配单位是：物理块（页框）</li><li>地址结构：段号，页号，页内偏移地址。</li><li>每个作业一张段表，每段一张页表。地址变换：先查段表，再查该段的页表。</li></ul><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><div align="center"><img src="/2019/05-内存管理/段表地址映射.jpg"></div><h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><div align="center"><img src="/2019/05-内存管理/段表地址变换.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;存储器的层次&quot;&gt;&lt;a href=&quot;#存储器的层次&quot; class=&quot;headerlink&quot; title=&quot;存储器的层次&quot;&gt;&lt;/a&gt;存储器
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>04-死锁及处理</title>
    <link href="https://isjinhao.github.io/2019/04-%E6%AD%BB%E9%94%81%E5%8F%8A%E5%A4%84%E7%90%86/"/>
    <id>https://isjinhao.github.io/2019/04-死锁及处理/</id>
    <published>2019-03-14T03:23:45.000Z</published>
    <updated>2019-03-15T04:12:49.326Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h2><h3 id="可重用资源和消耗性资源"><a href="#可重用资源和消耗性资源" class="headerlink" title="可重用资源和消耗性资源"></a>可重用资源和消耗性资源</h3><ul><li>可重用性资源：可供用户重复使用多次的资源。特点：<ul><li>互斥访问</li><li>系统中此资源数目相对固定</li><li>系统中大多数资源属于此类</li></ul></li><li>可消耗性资源：临时性资源<ul><li>由进程动态创建和消耗，数目是可以不断变化的，比如信号量、进程通信的信息等。</li></ul></li></ul><h3 id="可抢占性资源和不可抢占性资源"><a href="#可抢占性资源和不可抢占性资源" class="headerlink" title="可抢占性资源和不可抢占性资源"></a>可抢占性资源和不可抢占性资源</h3><ul><li>可抢占性资源：CPU和主存，不会引起死锁。</li><li>不可抢占性资源：只能进程自行释放。如打印机，因为如果打印到一半，打印机被抢占，造成的结果只能是此次打印作废，所以它是不可抢占资源。</li></ul><h2 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h2><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。</p><div align="center"><img src="/2019/04-死锁及处理/死锁举例.jpg"></div><h2 id="死锁的起因"><a href="#死锁的起因" class="headerlink" title="死锁的起因"></a>死锁的起因</h2><h3 id="竞争不可抢占性资源引起死锁"><a href="#竞争不可抢占性资源引起死锁" class="headerlink" title="竞争不可抢占性资源引起死锁"></a>竞争不可抢占性资源引起死锁</h3><p>一个资源只能同时被一个进程使用，但是下图P1在获得R1后还去申请R2，同时P2获得R2后还去申请R1，陷入僵局，引发死锁。</p><div align="center"><img src="/2019/04-死锁及处理/竞争不可抢占资源.jpg"></div><h3 id="竞争可消耗性资源引起死锁"><a href="#竞争可消耗性资源引起死锁" class="headerlink" title="竞争可消耗性资源引起死锁"></a>竞争可消耗性资源引起死锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P1：receive(p3,m3)； send(p2,m1)；</span><br><span class="line">P2：receive(p1,m1)； send(p3,m2)；</span><br><span class="line">P3：receive(p2,m2)； send(p1,m3)；</span><br></pre></td></tr></table></figure><p>如上代码，P1在等待P3给P1发消息，P2在等待P1给它P2发消息，P3在等待P2给P3发消息。造成一个死循环。</p><h3 id="进程推进顺序非法"><a href="#进程推进顺序非法" class="headerlink" title="进程推进顺序非法"></a>进程推进顺序非法</h3><p>在下图中，X轴表示进程P1推进图，Y轴表示进程P2推进图。如果按照4号路线推进，可以看出P1在经过b、d段的执行之后，获得R1，P2在进过a、c、e段的执行之后获得R2。此时如果不加以处理，系统一定会进入死锁状态，因为接下来P1在拥有R1后又去申请R2，P2在拥有R2后又去申请R1。</p><div align="center"><img src="/2019/04-死锁及处理/进程推进顺序非法.jpg"></div><h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><ul><li>互斥条件：某段时间内，某资源只能由一个进程使用；</li><li>请求和保持条件：进程因请求资源而阻塞时，对已分配给它的资源保持不放；</li><li>不可抢占条件 ：资源在未使用完前，不能被剥夺，由使用进程释放；</li><li>循环等待条件 ：发生死锁时，有向图必构成一环路。</li></ul><h2 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h2><p>共有三类做法：</p><ul><li>第一类是预防死锁，也就是破坏死锁产生的条件（破坏其中一个就可以），这样系统就永远不会产生死锁。</li></ul><ul><li>第二类是死锁避免，死锁产生的根本原因是系统资源分配出现问题，如果能进行合理的资源分配就能避免死锁的发生。</li></ul><ul><li>第三类是死锁发生后的检测和解除。</li></ul><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p>预防死锁是给系统施加一个条件使其永远不可能满足死锁产生的必要条件，但是互斥条件是不能被破坏的条件，所以预防死锁有三类做法：</p><h3 id="破坏“请求和保持”条件"><a href="#破坏“请求和保持”条件" class="headerlink" title="破坏“请求和保持”条件"></a>破坏“请求和保持”条件</h3><p>即进程在请求资源时，它不能持有不可抢占资源。有两种做法：</p><ol><li>所有进程在开始运行之前，一次性的申请其在整个运行过程中的全部资源，如果申请成功，进程便陷入等待。这样进程在运行的时候就不会再发出请求。</li><li>进程在只获得运行初期所需的资源后便开始运行，但是进程在运行过程中需要逐步释放以分配给自己的资源，等初期获得所有资源都被释放后才能请求其他资源。</li></ol><h3 id="破坏“不可抢占”条件"><a href="#破坏“不可抢占”条件" class="headerlink" title="破坏“不可抢占”条件"></a>破坏“不可抢占”条件</h3><p>当进程保持了某些不可被抢占资源，且提出的新需求又不能被满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这种预防策略的代价非常昂贵，比如进程请求的打印机被强制剥夺后，之前的工作等于作废。</p><h3 id="破坏“循环等待”条件"><a href="#破坏“循环等待”条件" class="headerlink" title="破坏“循环等待”条件"></a>破坏“循环等待”条件</h3><p>常见的方法是“资源有序分配”。其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号升序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程，在拥有大编号资源再申请小编号资源时需要释放和小资源编号相等及以上的编号。</p><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>避免死锁讲道理是属于死锁的预防，但是它和预防死锁不同，预防死锁是破坏死锁产生的条件，避免死锁是防止系统进入不安全状态。所以我们就要明白什么是安全状态，它和死锁产生的必要条件有什么区别。</p><h3 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h3><p>安全状态指的是系统能按某种进程推进顺序<code>(P1, P2, …, Pn)</code>为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。此时，序列<code>(P1, P2, …, Pn)</code>为安全序列。如果系统无法找到这样一个序列，则称系统处于不安全状态。</p><p>为什么能找到这样的序列系统就是安全的呢？其实它是一个递推的关系，假如系统在时刻<code>i</code>发起申请资源请求，其此时状态为<code>a</code>，系统会判断它申请成功后是否还能寻找到一个安全序列，如果能找到便可以分配，否则便是系统不安全状态。假如系统申请到了资源，还想发出申请请求，便会再次判断请求成功之后能否找到安全序列，由此递推下去可保证整个系统能避免死锁。</p><h3 id="安全状态和死锁必要条件的区别"><a href="#安全状态和死锁必要条件的区别" class="headerlink" title="安全状态和死锁必要条件的区别"></a>安全状态和死锁必要条件的区别</h3><p>仍以此图为例。假如我们采用的是预防死锁策略中的破坏“请求和保持”条件里的第一个做法，那么推进顺序就不可能为4，因为进程P1在执行的时候需要获取全部资源才能执行。但对于避免死锁来说，系统可以按照4号推进顺序推进到e段和阴影区的交界处，然后进程P2在申请资源R2的时候会去判断分配R2给P2之后系统能否找到安全序列，事实上是找不到的，所以R2便不会分配给P2，这样系统就进入不了阴影区，从而可以避免死锁。</p><p>所以预防死锁和避免死锁的区别是：</p><ul><li><p>预防死锁是每个进程在执行之前确保其自身不陷入死锁状态，如果每个进程都能不陷入死锁状态，系统便能永远安全。即从单个进程角度静态解决问题。</p></li><li><p>但避免死锁是在每一次进行资源分配时判断分配之后是否系统处于安全状态，如果处于安全状态便可分配，否则便不能分配。即从系统整体角度动态解决问题。</p></li></ul><div align="center"><img src="/2019/04-死锁及处理/进程推进顺序非法.jpg"></div><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ol><li>可利用资源向量$Available$：是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果$Available[j]=K$，则表示系统中现有$R_j$类资源K个。</li><li>最大需求矩阵$Max$：这是一个$n×m$的矩阵，它定义了系统中$n$个进程中的每一个进程对$m$类资源的最大需求。如果$Max[i, j]=K$，则表示进程$i$需要$R_j$类资源的最大数目为K。</li><li>分配矩阵$Allocation$：这也是一个$n×m$的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果$Allocation[i,j]=K$，则表示进程i当前已分得$R_j$类资源的 数目为K。</li><li>需求矩阵$Need$：这也是一个$n×m$的矩阵，用以表示每一个进程尚需的各类资源数。如果$Need[i,j]=K$，则表示进程$i$还需要$R_j$类资源K个，方能完成其任务。</li></ol><p>可得：$Need[i,j]=Max[i,j]-Allocation[i,j]​$</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>设进程$cusneed$提出请求$REQUEST[i]$，则银行家算法按如下规则进行判断。</p><ol><li>如果$REQUEST[cusneed] [i]&lt;= Need[cusneed][i]​$，则转2；否则，出错。</li><li>如果$REQUEST [cusneed] [i]&lt;= Available[i]$，则转3；否则，等待。</li><li>系统试探分配资源，修改相关数据：<ol><li>$Available[i]-=REQUEST[cusneed][i]$;</li><li>$Allocation[cusneed][i]+=REQUEST[cusneed][i]$;</li><li>$Need[cusneed][i]-=REQUEST[cusneed][i]$;</li></ol></li><li>系统执行安全性检查算法，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。</li></ol><h4 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h4><ol><li>设置两个工作向量$Work=Available​$、$Finish=false​$。</li><li>从进程集合中找到一个满足下述条件的进程$i$，$Finish[i]==false;$$Need[i, j]&lt;=Work[j];$，如找到，执行3；否则，执行4。</li><li>设进程获得资源，可顺利执行，直至完成，从而释放资源。$Work[i]=Work[i]+Allocation[i,j];​$，$Finish[i]=true;​$，循环2。</li><li>如所有的进程$Finish= true​$，则表示安全；否则系统不安全。</li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li>假定系统中有五个进程$\lbrace P0, P1, P2, P3, P4\rbrace$和三类资源$\lbrace A,B, C\rbrace$，各种资源的数量分别为10、5、7，在$T0$时刻的资源分配情况如图所示。</li></ul><div align="center"><img src="/2019/04-死锁及处理/T0.jpg"></div><ul><li>$T0​$时刻的安全性</li></ul><div align="center"><img src="/2019/04-死锁及处理/T1.jpg"></div><ul><li>$P1$请求资源：$P1$发出请求向量$Request1(1,0,2)​$，系统按银行家算法进行检查。<ul><li>$Request_1(1, 0, 2)≤Need_1(1, 2, 2)​$</li><li>$Request_1(1, 0, 2)≤Available_1(3, 3, 2)$</li><li>系统先假定可为$P1​$分配资源，并修改$Available,Allocation_1和Need_1​$向量。由此得到的资源变换情况如上上图括号所示。</li><li>再利用安全性算法检查此时系统是否安全。</li></ul></li></ul><div align="center"><img src="/2019/04-死锁及处理/T2.jpg"></div><ul><li><p>$P4$请求资源：$P4$发出请求向量$Request_4(3,3,0)$，系统按银行家算法进行检查。</p><ul><li>$Request_4(3, 3, 0)≤Need_4(4, 3, 1);$。</li><li>$Request_4(3, 3, 0)&gt;Available(2, 3, 0)​$，让$P4​$等待。</li></ul></li><li><p>$P0$请求资源：$P0$发出请求向量$Requst_0(0,2,0)$，系统按银行家算法进行检查。</p><ul><li>$Request_0(0, 2, 0)≤Need_0(7, 4, 3);$</li><li>$Request_0(0, 2, 0)≤Available(2, 3, 0);$</li><li>系统暂时先假定可为$P0$分配资源，并修改有关数据，如下图所示。</li></ul><div align="center"><img src="/2019/04-死锁及处理/T3.jpg"></div></li><li><p>进行安全性检查：此时可用资源$Available(2,1,0)$已经不能满足任何进程的需要，进入不安全状态，因此系统不分配资源。</p></li></ul><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p>在图中找一既非阻塞又非独立的进程节点$P_i$，如顺利，$P_i$可获得所有资源直至运行完毕。消去$P_i$所有的请求边和分配边，即释放占有的所有资源，同理再选下一进程节点$P_{i+1}, …, $若能消去所有的边，那么该图是可完全简化的，否则该图是不可完全简化的。</p><div align="center"><img src="/2019/04-死锁及处理/死锁的检测.jpg"></div><p>具体做法如下：</p><ol><li>可利用资源向量$Available[]$，它表示了m类资源中每一类资源的可用数目。</li><li>把不占用资源的进程（向量$Allocation[i]∶= 0$）记入L表中，即$L_i \bigcup L$。</li><li>从进程集合中找到一个$Request_i≤Work$的进程，做如下处理：<ol><li>将其资源分配图简化，释放出资源，增加工作向量$Work∶ =Work+Allocation_i$。</li><li>将它记入L表中。</li></ol></li><li>若不能把所有进程都记入L表中， 便表明系统状态S的资源分配图是不可完全简化的。 因此，该系统状态将发生死锁。</li></ol><h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><p>死锁解除有多种做法，如下是按代价递减排序的几种。</p><ol><li>撤销所有死锁的进程。</li><li>将每个进程回退到先前定义的某个检查点，再重新启动所有进程。</li><li>逐个撤销死锁进程，直至死锁不存在。撤销进程的顺序应是基于某种最小代价原则，每次撤销后，死锁检测算法应该重新检测死锁是否依然存在。</li><li>剥夺进程P的资源交给进程Q，P同时会退到获得此资源的节点上。</li></ol><p>对于3和4，选择的标准可以如下：</p><ul><li>以占用处理器的时间最小；</li><li>以产生的输出少；</li><li>所估计的剩余运行时间最长；</li><li>所占用的资源最少；</li><li>优先权最低。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;资源分类&quot;&gt;&lt;a href=&quot;#资源分类&quot; class=&quot;headerlink&quot; title=&quot;资源分类&quot;&gt;&lt;/a&gt;资源分类&lt;/h2&gt;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>时钟中断</title>
    <link href="https://isjinhao.github.io/2019/%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD/"/>
    <id>https://isjinhao.github.io/2019/时钟中断/</id>
    <published>2019-03-13T13:28:43.000Z</published>
    <updated>2019-03-17T12:30:08.971Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="中断的理解"><a href="#中断的理解" class="headerlink" title="中断的理解"></a>中断的理解</h2><p>说到中断还不得不从现代操作系统的特性说起，无论是桌面PC操作系统还是嵌入式都是多任务的操作系统，而很遗憾，处理器往往是单个的，即使在硬件成本逐渐下降，但处理器的数量依然不可能做到每个任务一个CPU，所以CPU必须作为一种全局的资源让所有任务共享。即什么时候给任务A用，什么时候给任务B用……这就是进程调度，具体的安排就由调度算法决定了。</p><p>进程如何去调度？现代操作系统一般都是采用基于时间片的优先级调度算法，把CPU的时间划分为很细粒度的时间片，一个任务每次只能时间这么多的时间，时间到了就必须交出使用权，即换其他的任务使用。这种要看操作系统的定时器机制了。那么时间片到之后，系统做了什么呢？这就要用到我们的中断了，时间片到了由定时器触发一个软中断，然后进入相应的处理历程。当然这一点不足以表明中断的重要，计算机操作系统自然离不开外部设备：鼠标、键盘、网卡、磁盘等等。就拿网卡来讲，我计算机并不知道时候数据包会来到，我能保证的就是数据来了我能正常接收就行了。但是我又不可能一直等着接收数据包，要是这样其他任务就死完了。所以合理的办法是，你数据包来到之后，通知我，然后我再对你处理，怎么通知呢？？答：中断！键盘、鼠标亦是如此！</p><h2 id="中断的定义"><a href="#中断的定义" class="headerlink" title="中断的定义"></a>中断的定义</h2><p>指处理机处理程序运行中出现的紧急事件的整个过程.程序运行过程中，系统外部、系统内部或者现行程序本身若出现紧急事件，处理机立即中止现行程序的运行，自动转入相应的处理程序（中断服务程序），待处理完后，再返回原来的程序运行，这整个过程称为程序中断。可分为两类：</p><h3 id="硬中断（Hardware-Interrupt）"><a href="#硬中断（Hardware-Interrupt）" class="headerlink" title="硬中断（Hardware Interrupt）"></a>硬中断（Hardware Interrupt）</h3><ul><li>外部中断：一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断是可屏蔽的。</li><li>内部中断是指因硬件出错（如突然掉电、奇偶校验错等）,或运算出错（除数为零、运算溢出、单步中断等）所引起的中断，内部中断是不可屏蔽的。</li></ul><h3 id="软中断（Software-Interrupt）"><a href="#软中断（Software-Interrupt）" class="headerlink" title="软中断（Software Interrupt）"></a>软中断（Software Interrupt）</h3><p>软中断是利用硬中断的概念，用软件方式进行模拟，实现宏观上的异步执行效果。很多情况下，软中断和”信号”有些类似，同时，软中断又是和硬中断相对应的，硬中断是外部设备对CPU的中断，软中断通常是硬中断服务程序（模拟硬件发出中断的程序）对内核的中断，信号则是由内核（或其他进程）对某个进程的中断。</p><h2 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h2><p>在Linux的0号中断是一个定时器中断。在固定的时间间隔都发生一次中断，也是说每秒发生该中断的频率都是固定的。该频率是常量HZ，该值一般是在100 ~ 1000之间。该中断的作用是为了定时更新系统日期和时间，使系统时间不断地得到跳转。另外该中断的中断处理函数除了更新系统时间外，还需要更新本地CPU统计数。若进程的时间片递减到0，进程则被调度出去而放弃CPU使用权。</p><p>Linux的OS时钟的物理产生原因是可编程定时/计数器产生的输出脉冲，这个脉冲送入CPU，就可以引发一个中断请求信号，我们就把它叫做<code>时钟中断</code>。</p><p><code>时钟中断</code>是特别重要的一个中断，因为整个操作系统的活动都受到它的激励。系统利用时钟中断维持系统时间、促使环境的切换，以保证所有进程共享CPU；利用时钟中断进行记帐、监督系统工作以及确定未来的调度优先级等工作。可以说，<code>时钟中断</code>是整个操作系统的脉搏。</p><p>参考：</p><ul><li><p><a href="https://www.jb51.net/article/133782.htm" target="_blank" rel="noopener">https://www.jb51.net/article/133782.htm</a></p></li><li><p><a href="https://blog.csdn.net/wlf_go/article/details/80237491" target="_blank" rel="noopener">https://blog.csdn.net/wlf_go/article/details/80237491</a></p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;中断的理解&quot;&gt;&lt;a href=&quot;#中断的理解&quot; class=&quot;headerlink&quot; title=&quot;中断的理解&quot;&gt;&lt;/a&gt;中断的理解&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="计算机组成原理" scheme="https://isjinhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>c与cpp</title>
    <link href="https://isjinhao.github.io/2019/c%E4%B8%8Ecpp/"/>
    <id>https://isjinhao.github.io/2019/c与cpp/</id>
    <published>2019-03-13T00:01:36.000Z</published>
    <updated>2019-03-13T10:00:54.572Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>绝对值在$10^9$范围以内或者是32位的整数都可以定义成<code>int</code>型。</li><li><p>绝对值在$10^{18}$范围以内或者是64位以内的整数可以定义为<code>long long</code>型。</p></li><li><p>如果<code>long long</code>型赋大于$2^{31}-1$的初值，则需要在初值后面加上<code>LL</code>。</p></li><li>遇到浮点型数据不要使用<code>float</code>，都应该使用<code>double</code>。</li><li>小写字母的ASCII值开始于97，大写字母的ASCII值开始于65。小写字母比大写字母大32。</li><li><code>\0</code>表示NULL。</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">含义</th><th style="text-align:center">语法</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;&lt;</code></td><td style="text-align:center">左移</td><td style="text-align:center"><code>a &lt;&lt; x</code></td><td style="text-align:center">整数a按二进制位左移x位</td></tr><tr><td style="text-align:center"><code>&gt;&gt;</code></td><td style="text-align:center">右移</td><td style="text-align:center"><code>a &gt;&gt; x</code></td><td style="text-align:center">整数a按二进制位右移x位</td></tr><tr><td style="text-align:center"><code>&amp;</code></td><td style="text-align:center">位与</td><td style="text-align:center"><code>a &amp; b</code></td><td style="text-align:center">整数a和b按二进制对齐，进行按位与运算</td></tr><tr><td style="text-align:center">$\mid$</td><td style="text-align:center">位或</td><td style="text-align:center">$a \mid b$</td><td style="text-align:center">整数a和b按二进制对齐，进行按位或运算</td></tr><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center">位异或</td><td style="text-align:center"><code>a ^ b</code></td><td style="text-align:center">整数a和b按二进制对齐，进行按位或运算</td></tr><tr><td style="text-align:center"><code>~</code></td><td style="text-align:center">位取反</td><td style="text-align:center"><code>~a</code></td><td style="text-align:center">整数a在二进制下各位取反</td></tr></tbody></table><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li>按位与：除了11为1，其他都是0；</li><li>按位或：除了00为0，其他都是1；</li><li>按位异或：相同为0，不同为1。</li></ul><h3 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h3><ul><li><p><code>const int INF = (1 &lt;&lt; 30) - 1;</code></p></li><li><p><code>const int INF = 0x3fffffff;</code></p></li></ul><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a><code>scanf</code></h2><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">格式符</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center"><code>%d</code></td><td style="text-align:center"><code>scanf(&quot;%d&quot;, &amp;n)</code></td></tr><tr><td style="text-align:center"><code>long long</code></td><td style="text-align:center"><code>%lld</code></td><td style="text-align:center"><code>scanf(&quot;%lld&quot;, &amp;ll)</code></td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center"><code>%f</code></td><td style="text-align:center"><code>scanf(&quot;%f&quot;, &amp;fl)</code></td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center"><code>%lf</code></td><td style="text-align:center"><code>scanf(&quot;%lf&quot;, &amp;db)</code></td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center"><code>%c</code></td><td style="text-align:center"><code>scanf(&quot;%d&quot;, &amp;c)</code></td></tr><tr><td style="text-align:center"><code>字符串（char数组）</code></td><td style="text-align:center"><code>%s</code></td><td style="text-align:center"><code>scanf(&quot;%d&quot;, str)</code></td></tr></tbody></table><p><code>scanf</code>双引号之内的字符串其实类似一个匹配模式，我们输入的参数只要能匹配这个模式其实都算对。比如在输入时间时：<code>scanf(&quot;%d:%d:%d&quot;, &amp;hour, &amp;minute, &amp;second)</code>。输入的参数只要是：<code>h​:m:​d</code>的形式就行。</p><p>除了字符类型（<code>%c</code>），<code>scanf</code>对于其他类型都是默认以空白符（空格、换行等）判断结束标志的。但是在使用字符类型时可以读入空白符。如对于<code>scanf(&quot;%d%c%s&quot;, &amp;a, %c, str)</code>，我们输入<code>1 a bad</code>，得到的结果是<code>a=1, c= , str=a</code>。</p><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a><code>printf</code></h2><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">格式符</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center"><code>%d</code></td><td style="text-align:center"><code>printf(&quot;%d&quot;, n)</code></td></tr><tr><td style="text-align:center"><code>long long</code></td><td style="text-align:center"><code>%lld</code></td><td style="text-align:center"><code>printf(&quot;%lld&quot;, ll)</code></td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center"><code>%f</code></td><td style="text-align:center"><code>printf(&quot;%f&quot;, fl)</code></td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center"><code>%f</code></td><td style="text-align:center"><code>printf(&quot;%f&quot;, db)</code></td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center"><code>%c</code></td><td style="text-align:center"><code>ptintf(&quot;%d&quot;, c)</code></td></tr><tr><td style="text-align:center"><code>字符串（char数组）</code></td><td style="text-align:center"><code>%s</code></td><td style="text-align:center"><code>ptintf(&quot;%d&quot;, str)</code></td></tr></tbody></table><p>输出<code>%</code>和<code>\</code>：<code>printf(&quot;%%&quot;)</code>，<code>printf(&quot;\\&quot;)</code></p><h3 id="md-amp-0md-amp-md"><a href="#md-amp-0md-amp-md" class="headerlink" title="%md &amp; %0md &amp; %.md"></a><code>%md</code> &amp; <code>%0md</code> &amp; <code>%.md</code></h3><ul><li><p><code>%md</code>：使不足m位的int型变量以m位且右对齐输出，高位以空格补齐，若变量本身超过m位，则保持原样。</p></li><li><p><code>%0md</code>：使不足m位的int型变量以m位且右对齐输出，高位以0补齐，若变量本身超过m位，则保持原样。</p></li><li><code>%.mf</code>：让浮点数保留m位小数输出。如果题目要求保留xx位小数，使用这个格式便是正确的。<ul><li>这种格式不是四舍五入：它是<a href="https://baike.baidu.com/item/%E5%9B%9B%E8%88%8D%E5%85%AD%E5%85%A5%E4%BA%94%E6%88%90%E5%8F%8C/9062547?fr=aladdin" target="_blank" rel="noopener">四舍六入偶成双</a>。</li></ul></li></ul><h2 id="getchar-amp-putchar"><a href="#getchar-amp-putchar" class="headerlink" title="getchar &amp; putchar"></a><code>getchar</code> &amp; <code>putchar</code></h2><p><code>getchar()</code>输入单个字符，<code>putchar(char c)</code>输出单个字符。如<code>char c = getchar();</code>，<code>getchar()</code>可以读入换行符。</p><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a><code>typedef</code></h2><p>给复杂的数据类型定义一个别名。如：<code>typedef long long ll</code>。</p><h2 id="常用math函数"><a href="#常用math函数" class="headerlink" title="常用math函数"></a>常用math函数</h2><ul><li>double类型取绝对值：<code>fabs(double x)</code></li><li>double类型向上取整：<code>floor(double x)</code></li><li>double类型向下取整：<code>ceil(double x)</code></li><li>求$r_p$：<code>pow(double r, double p)</code></li><li>取double类型的算术平方根：<code>sqrt(double x)</code></li><li>得到以自然对数为底的对数：<code>log(double x)</code><ul><li>得到以a为底b的对数：$log_ab$=<code>log(b)/log(a)</code></li></ul></li><li>四舍五入：<code>round (double x)</code></li><li>三角函数：<ul><li><code>sin(double x)</code>，<code>cos(double x)</code>，<code>tan(double x)</code>：参数是弧度制。</li><li><code>asin(double x)</code>，<code>acos(double x)</code>，<code>atan(double x)</code>。</li></ul></li></ul><h2 id="memset"><a href="#memset" class="headerlink" title="memset"></a><code>memset</code></h2><p><code>memset(数组名, 值, sizeof(数组名));</code>。<code>memset</code>是按字节赋值，也就是说所有的字节都会被赋值为相同的数值，比如对于<code>int a[10]</code>，使用<code>memset(a, 1, sizeof(a);</code>，则四十个字节上的二进制结果都是<code>00000001</code>。由于0的二进制补码全为0，-1的二进制补码全为1，所以memset一般只用于赋值0和-1。</p><h2 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h2><ul><li>仅在初始化的时候可以直接赋值字符串，如：<code>char str[4] = &quot;PAT&quot;;</code></li><li><code>gets(str)</code>：读入一行字符串，以换行符作为输入结束。</li><li><code>puts(str)</code>：输出一行字符串，即输出字符串+换行符。</li><li><code>gets()</code>和<code>scanf()</code>在读入字符串时会自动添加结束符（<code>\0</code>）。</li></ul><h2 id="string-h头文件"><a href="#string-h头文件" class="headerlink" title="string.h头文件"></a><code>string.h</code>头文件</h2><ul><li><code>strlen()</code>：获得字符数组中第一个<code>\0</code>前的字符个数（不包含<code>\0</code>）。</li><li><p><code>strcmp(str1, str2)</code>：比较两个字符串的大小（字典序）：</p><ul><li><code>str1 &lt; str2</code>：返回负整数；</li><li><code>str1 == str2</code>：返回0；</li><li><code>str1 &gt; str2</code>：返回正整数；</li></ul></li><li><p><code>strcpy(str1, str2)</code>：把<code>str2</code>复制给<code>str1</code>，包含结束符<code>\0</code>。</p></li><li><code>strcat(str1, str2)</code>：把<code>str2</code>粘贴在<code>str1</code>后面（覆盖<code>str1</code>的<code>\0</code>）。</li></ul><h2 id="sscanf-amp-sprintf"><a href="#sscanf-amp-sprintf" class="headerlink" title="sscanf &amp; sprintf"></a><code>sscanf</code> &amp; <code>sprintf</code></h2><p>用于处理字符串问题：</p><ul><li><code>sscanf(原位置，格式符，目的位置)</code>：把原位置里的数据输入到目的位置中。</li><li><code>sprintf(目的位置, 格式符, 原位置)</code>：把原位置里的数据输出到目的位置中。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d"</span>, &amp;n);<span class="comment">//字符转int时不是强转为ASCII，是字面值相同。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n);<span class="comment">//123</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理复杂的字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">100</span>] = <span class="string">"2048:3.14,hello"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sscanf</span>(str1, <span class="string">"%d:%lf,%s"</span>, &amp;n, &amp;db, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n=%d, db=%.2f, str2=%s\n"</span>, n, db, str2); <span class="comment">//n=2048, db=3.14, str2=hello</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">double</span> db = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">100</span>] = <span class="string">"good"</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str1, <span class="string">"%d:%.2lf,%s"</span>, n, db, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2=%s\n"</span>, str1);<span class="comment">//str2=12:3.14,good</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li><p>指针存储的地址的类型称为基类型。</p></li><li><p>基类型必须和指针变量存储的地址类型相同。</p></li><li><p>进行加减法得到的是其基类型偏移的位数。如，两个int型指针相减，等价于两个指针之间差了几个int。</p></li><li><p>指针作为函数的参数，传递的是地址的拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testPointer</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> * p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p1 = p1 + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">testPointer(&amp;a[<span class="number">1</span>], &amp;a[<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指针在创建的时候赋予初值。否则可能出现问题。如<code>int *temp;</code>，temp会被赋予一个随机空间，可能指向系统功能区，此时程序运行就会问题。</p></li></ul><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul><li><p>结构体限制：结构体内部不能定义本类型，但可以定义本类型的指针。</p></li><li><p>结构体的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> gender;</span><br><span class="line">studentInfo()&#123;&#125;</span><br><span class="line">studentInfo(<span class="keyword">char</span> _gender): gender(_gender) &#123;&#125;</span><br><span class="line">studentInfo(<span class="keyword">int</span> _id, <span class="keyword">char</span> _gender): id(_id), gender(_gender) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">studentInfo stu = studentInfo(<span class="number">10086</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; stu.id &lt;&lt; <span class="string">" "</span> &lt;&lt; stu.gender &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="浮点数的比较"><a href="#浮点数的比较" class="headerlink" title="浮点数的比较"></a>浮点数的比较</h2><p>计算机采用有限位的二进制代码，因此浮点数在计算机中的存储并不总是精确的，具体参考<code>IEEE754</code>规则。所以我们需要定义一个极小数<code>eps</code>（一般定义为$10^{-8}$）对这种误差进行修正。</p><ul><li><p>等于运算</p><div align="center"><img src="/2019/c与cpp/等于.jpg"></div></li><li><p>大于运算</p><div align="center"><img src="/2019/c与cpp/大于.jpg"></div></li><li><p>小于运算</p><div align="center"><img src="/2019/c与cpp/小于.jpg"></div></li><li><p>大于等于运算</p><div align="center"><img src="/2019/c与cpp/大于等于.jpg"></div></li><li><p>小于等于运算</p><div align="center"><img src="/2019/c与cpp/小于等于.jpg"></div></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Equ(a, b) ((fabs((a) - (b))) &lt; (eps))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> More(a, b) ((a) &gt; (b + (eps)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Less(a, b) ((a) &lt; (b - (eps)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MoreEqu(a, b) ((a) &gt; (b - (eps)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LessEqu(a, b) ((a) &lt; (b + (eps)))</span></span><br></pre></td></tr></table></figure><h2 id="单点测试"><a href="#单点测试" class="headerlink" title="单点测试"></a>单点测试</h2><p>提交的程序被执行多次，每次执行会输入一组数据，得到输出后和此组数据的结果做比较，如果相同则判断此测试点通过，总成绩等于N次执行的成绩之和。PAT采用的是单点测试的方案。</p><h2 id="多点测试"><a href="#多点测试" class="headerlink" title="多点测试"></a>多点测试</h2><p>提交的程序被执行一次，会把所有的测试数据都输入，如果其中一组输出出错，则此题错误。所以此时需要程序能有循环读入多组数据的能力。大多数OJ系统采用这种方案，如<code>codeup</code>。下面介绍三种读入方案：</p><h3 id="while-EOF"><a href="#while-EOF" class="headerlink" title="while ... EOF"></a><code>while ... EOF</code></h3><p>应用于没有给定输入的结束条件，默认读到文件末尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while-break"><a href="#while-break" class="headerlink" title="while ... break"></a><code>while ... break</code></h3><p>应用于题目要求输入的数据满足某个条件时停止输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while-T"><a href="#while-T" class="headerlink" title="while(T--)"></a><code>while(T--)</code></h3><p>当题目给出测试数据组数时采用这种方案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T = <span class="number">20</span>；</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;
      
    
    </summary>
    
      <category term="算法笔记" scheme="https://isjinhao.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C" scheme="https://isjinhao.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://isjinhao.github.io/tags/C/"/>
    
      <category term="PAT" scheme="https://isjinhao.github.io/tags/PAT/"/>
    
  </entry>
  
  <entry>
    <title>05-Shell</title>
    <link href="https://isjinhao.github.io/2019/05-Shell/"/>
    <id>https://isjinhao.github.io/2019/05-Shell/</id>
    <published>2019-03-12T11:12:06.000Z</published>
    <updated>2019-03-12T14:21:31.138Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Shell是一个命令解释器，用户输入命令来获得自己想要的结果，但是终端中输入的命令很难进行高级语言的选择、循环等操作。不过Shell程序可以存放在文件上，称为Shell脚本（虽然Linux文件不以后缀名区分文件类型，但是一般编写Shell脚本时文件名会命名为以<code>.sh</code>结尾）。在脚本中可以较方便的进行类似高级语言的操作。</p><h2 id="最简单的Shell脚本"><a href="#最简单的Shell脚本" class="headerlink" title="最简单的Shell脚本"></a>最简单的Shell脚本</h2><div align="center"><img src="/2019/05-Shell/最简单shell脚本.jpg"></div><p>我们都知道，直接在终端输入<code>echo</code>命令是回显参数，把<code>echo</code>命令放在shell脚本中有相同的效果。</p><h2 id="设置成可执行文件"><a href="#设置成可执行文件" class="headerlink" title="设置成可执行文件"></a>设置成可执行文件</h2><div align="center"><img src="/2019/05-Shell/设置为可执行文件.png"></div><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Shell脚本中的变量直接使用<code>=</code>便可创建，使用<code>$</code>解析变量名。<code>{}</code>是分组命令，表示<code>H</code>是一个变量，这里不加也可以。</p><div align="center"><img src="/2019/05-Shell/变量.jpg"></div><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><ul><li><p><code>$#</code>：除脚本名外，命令行上参数的个数。</p></li><li><p><code>$*</code>：表示在命令行上实际给出的所有实参。</p><ul><li>如：<code>exam3.sh A B C D E F G H I J K</code>。<code>$#</code>是11。<code>$*</code>是： A B C D E F G H I J K</li></ul></li><li><p><code>$n</code>：表示命令行上第n个参数</p><ul><li><code>$0</code>表示文件名 <code>$1</code>表示第一个参数 …</li></ul></li><li><p><code>$@</code>：表示在命令行上实际给出的所有实参。</p><ul><li>如：<code>exam3.sh A B C D E F G H I J K</code>。<code>$@</code>就是： “A” “B” “C” “D” “E” “F” “G” “H” “I” “J” “K”</li></ul></li><li><p><code>$$</code>：当前进程的进程号</p></li><li><p><code>$!</code>：上一个后台命令对应的进程号。</p></li><li><p><code>$?</code>：上一条前台命令执行后的返回值。</p></li></ul><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><p>执行算术运算需要使用let，如<code>let c=$a+$b</code>。可以使用<code>c=$(($a+$b))</code>代替。其中算术运算符及优先级等同于C语言。同时多了个<code>**</code>表示幂运算。（运算符前后不要有空格）</p><div align="center"><img src="/2019/05-Shell/算术运算符.jpg"></div><h2 id="从命令行读入参数"><a href="#从命令行读入参数" class="headerlink" title="从命令行读入参数"></a>从命令行读入参数</h2><p>直接使用read，命令行中的参数会读到read后面跟的参数（相当于变量）里。</p><div align="center"><img src="/2019/05-Shell/read.jpg"></div><p>读入时输出提示信息：</p><div align="center"><img src="/2019/05-Shell/readp.jpg"></div><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><ul><li><p>双引号：由双引号引起来的字符（除<code>$</code>、<code>`和`\`）都被当做普通字符对待。</code></p><ul><li><code>$</code>表示变量替换；</li><li><code></code> `表示命令替换；</li><li><code>\</code>之后的字符只有是<code>$</code>、<code></code> <code>、</code>双引号<code>、</code>`或<code>换行符</code>之一时会成为转义字符。其他情况都是<code>\</code>本身。</li></ul><div align="center"><img src="/2019/05-Shell/引号.jpg"></div></li><li><p>单引号：单引号引起来的字符都是普通字符。特殊字符也失效。</p><div align="center"><img src="/2019/05-Shell/单引号.jpg"></div></li><li><p>倒引号：被到引号引起来的字符被解释为命令。如上上图中所示。</p></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>变量之间使用空格隔开各个元素。如果元素中有空格，使用双引号引起来。</p><div align="center"><img src="/2019/05-Shell/数组.jpg"></div><h2 id="测试条件"><a href="#测试条件" class="headerlink" title="测试条件"></a>测试条件</h2><p>任何命令都可以作为条件，shell会执行这个命令并检查返回值，如果命令成功（返回值为0），表示真。</p><ul><li><p><code>test &lt;条件&gt;</code>：如<code>test n1 -eq n2</code></p></li><li><p><code>[ 条件 ]</code>：如<code>[ n1 -eq n2 ]</code></p></li></ul><h3 id="有关文件方面的测试"><a href="#有关文件方面的测试" class="headerlink" title="有关文件方面的测试"></a>有关文件方面的测试</h3><ul><li><code>-r 文件名</code>：真 &lt;==&gt; 文件存在并且是用户可读</li><li><code>-w 文件名</code>：真 &lt;==&gt; 文件存在并且是用户可写</li><li><code>-x 文件名</code>：真 &lt;==&gt; 文件存在并且用户可执行</li><li><code>-f 文件名</code>：真 &lt;==&gt; 文件存在且是普通文件</li><li><code>-d 文件名</code>：真 &lt;==&gt; 文件存在且是目录文件</li><li><code>-s 文件名</code>：真 &lt;==&gt; 文件存在且长度大于0</li></ul><h3 id="有关字符串方面的测试"><a href="#有关字符串方面的测试" class="headerlink" title="有关字符串方面的测试"></a>有关字符串方面的测试</h3><ul><li><code>-z s1</code>：真 &lt;==&gt; 字符串长度为0</li><li><code>-n s1</code>：真 &lt;==&gt; 字符串长度大于0</li><li><code>s1</code>：真 &lt;==&gt; 字符串不是空字符串</li><li><code>s1 = s2</code>（在“=”前后应有空格）：真 &lt;==&gt; 字符串相等</li><li><code>s1 != s2</code>：真 &lt;==&gt; 字符串不等</li><li><code>s1 &lt; s2</code>：真 &lt;==&gt; 按字典顺序s1在s2之后</li><li><code>s1 &gt; s2</code>：真 &lt;==&gt; 按字典顺序s1在s2之前</li></ul><h3 id="数值方面的测试"><a href="#数值方面的测试" class="headerlink" title="数值方面的测试"></a>数值方面的测试</h3><ul><li><code>n1 -eq n2</code>：真 &lt;==&gt; 数值相等</li><li><code>n1 -ne n2</code>：真 &lt;==&gt; 数值不等</li><li><code>n1 -lt n2</code>：真 &lt;==&gt; n1小于n2</li><li><code>n1 -le n2</code>：真 &lt;==&gt; n1小于或等于n2</li><li><code>n1 -gt n2</code>：真 &lt;==&gt; n1大于n2</li><li><code>n1 -ge n2</code>：真 &lt;==&gt; n1大于或等于n2</li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><code>!</code>：逻辑非</li><li><code>-a</code>：逻辑与</li><li><code>-o</code>：逻辑或</li><li><code>(表达式)</code>：圆括号括起来表示为一条语句</li></ul><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><div align="center"><img src="/2019/05-Shell/选择结构.jpg"></div><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><div align="center"><img src="/2019/05-Shell/循环结构.png"></div><h2 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h2><p>和C语言一致。</p><h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><p>参数跳转命令：不跟数组默认跳转1位，跟了跳转n位。</p><table><thead><tr><th style="text-align:center">命令行</th><th style="text-align:center">ex.sh</th><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">F</th></tr></thead><tbody><tr><td style="text-align:center">原位置参数</td><td style="text-align:center">$0</td><td style="text-align:center">$1</td><td style="text-align:center">$2</td><td style="text-align:center">$3</td><td style="text-align:center">$4</td><td style="text-align:center">$5</td><td style="text-align:center">$6</td></tr><tr><td style="text-align:center">移位后参数</td><td style="text-align:center">$0</td><td style="text-align:center"></td><td style="text-align:center">$1</td><td style="text-align:center">$2</td><td style="text-align:center">$3</td><td style="text-align:center">$4</td><td style="text-align:center">$5</td></tr></tbody></table><p>还可以用于循环结构的done上面，表示每次选择指定参数。</p><h2 id="参数置换变量"><a href="#参数置换变量" class="headerlink" title="参数置换变量"></a>参数置换变量</h2><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">var1为空</th><th style="text-align:center">var1不空</th></tr></thead><tbody><tr><td style="text-align:center"><code>var2=${var1:-str}</code></td><td style="text-align:center">var2=str。var1不变</td><td style="text-align:center">var2=$var1。var1不变</td></tr><tr><td style="text-align:center"><code>var2=${var1:=str}</code></td><td style="text-align:center">var2=var1=str</td><td style="text-align:center">var2=$var1。var1不变</td></tr><tr><td style="text-align:center"><code>var2=${var1:+str}</code></td><td style="text-align:center">var2为空。var1不变</td><td style="text-align:center">var2=str。var1不变</td></tr><tr><td style="text-align:center"><code>var2=${var1:?str}</code></td><td style="text-align:center">输出：“shell 脚本名:var1:str”并退出shell。var2不变</td><td style="text-align:center">var2=$var1。var1不变</td></tr></tbody></table><h2 id="ex1"><a href="#ex1" class="headerlink" title="ex1"></a>ex1</h2><p>编写ex1.sh，参数为一个大于 20 的正整数。先检查参数是否符合要求。如果不符合要求，请给出提示；如果符合要求，输出这个参数的平方。</p><div align="center"><img src="/2019/05-Shell/ex1.jpg"></div><h2 id="ex2"><a href="#ex2" class="headerlink" title="ex2"></a>ex2</h2><p>编写ex2.sh，首先显示当天日期，然后查找给定的用户是否在系统中工作（who 命令）。如果在系统中，就输出一条欢迎语句（例如 hello，xxxx！）；如果不在系统中，就输出一条语句（waiting for xxx！）</p><div align="center"><img src="/2019/05-Shell/ex2.jpg"></div><h2 id="ex3"><a href="#ex3" class="headerlink" title="ex3"></a>ex3</h2><p>编写 ex3.sh，该脚本接受一个参数。若改参数不是目录，则给出提示信息；否则使用<code>ll</code>命令列出该目录下的内容，并输出有多少个子目录（<code>d</code>开头），多少个普通文件（<code>-</code>开头）。</p><div align="center"><img src="/2019/05-Shell/ex3.jpg"></div><h2 id="ex4"><a href="#ex4" class="headerlink" title="ex4"></a>ex4</h2><p>编写 ex4.sh，将第一个参数指定的内容 copy 到第二个参数指定地点。</p><ul><li><p>若第一个参数是目录，自动添加<code>-r</code>选项（即把目录下的所有内容都 copy 过去）；</p></li><li><p>若第一个参数是普通文件，则将其 copy 到指定地点；</p></li><li>若第一个参数指定的文件或目录不存在，则报错；</li><li>若第二个参数指定的文件或目录已经存在，则提示是否替换，若选择 yes，则先删除原来的文件或目录，然后再执行 copy 操作，否则放弃。</li></ul><div align="center"><img src="/2019/05-Shell/ex41.png"></div><div align="center"><img src="/2019/05-Shell/ex42.png"></div><h2 id="ex5"><a href="#ex5" class="headerlink" title="ex5"></a>ex5</h2><p>编写 ex5.sh。检查命令行的第一个参数是否是<code>-b</code>或者<code>-s</code>。</p><ul><li>如果是<code>-b</code>，则计算由第二个参数指定的文件中以 b 开头的行数。</li><li>如果是<code>-s</code>，则计算由第二个参数指定的文件中以 s 开头的行数。否则显示选择有错的信息。</li></ul><div align="center"><img src="/2019/05-Shell/ex5.jpg"></div><h2 id="ex6"><a href="#ex6" class="headerlink" title="ex6"></a>ex6</h2><p>编写 ex6.sh。该脚本需要输入两个文件的名称，然后由用户选择相应的操作（若两个参数中任何一个不是普通文件，则报错）。</p><div align="center"><img src="/2019/05-Shell/ex61.png"></div><h3 id="cat：输出两个文件的内容"><a href="#cat：输出两个文件的内容" class="headerlink" title="cat：输出两个文件的内容"></a>cat：输出两个文件的内容</h3><div align="center"><img src="/2019/05-Shell/ex62.png"></div><h3 id="statistic：统计两个文件分别有多少行"><a href="#statistic：统计两个文件分别有多少行" class="headerlink" title="statistic：统计两个文件分别有多少行"></a>statistic：统计两个文件分别有多少行</h3><div align="center"><img src="/2019/05-Shell/ex63.png"></div><h3 id="merge：将第-1-个文件的内容合并到第-2-个文件后面"><a href="#merge：将第-1-个文件的内容合并到第-2-个文件后面" class="headerlink" title="merge：将第 1 个文件的内容合并到第 2 个文件后面"></a>merge：将第 1 个文件的内容合并到第 2 个文件后面</h3><div align="center"><img src="/2019/05-Shell/ex64.png"></div><h3 id="copy：将第-1-个文件的内容-copy-到第-2-个文件（覆盖原文件）"><a href="#copy：将第-1-个文件的内容-copy-到第-2-个文件（覆盖原文件）" class="headerlink" title="copy：将第 1 个文件的内容 copy 到第 2 个文件（覆盖原文件）"></a>copy：将第 1 个文件的内容 copy 到第 2 个文件（覆盖原文件）</h3><div align="center"><img src="/2019/05-Shell/ex65.png"></div><h3 id="bye：退出"><a href="#bye：退出" class="headerlink" title="bye：退出"></a>bye：退出</h3><div align="center"><img src="/2019/05-Shell/ex66.png"></div><h2 id="1ex"><a href="#1ex" class="headerlink" title="1ex"></a>1ex</h2><p>编写 1ex.sh，利用 for 循环将当前目录下的.c 文件移动到指定的目录下，完成后显示指定目录下的文件内容，并按文件从小到大排序。(ll -r -S）</p><div align="center"><img src="/2019/05-Shell/1ex.jpg"></div><h2 id="2ex"><a href="#2ex" class="headerlink" title="2ex"></a>2ex</h2><p>编写 2ex.sh，显示 Fibonacci 数列的前 10 项及其总和。</p><div align="center"><img src="/2019/05-Shell/2ex.jpg"></div><h2 id="3ex"><a href="#3ex" class="headerlink" title="3ex"></a>3ex</h2><p>编写 ex3.sh，判断给定的参数是否是素数。</p><div align="center"><img src="/2019/05-Shell/3ex.jpg"></div><h2 id="4ex"><a href="#4ex" class="headerlink" title="4ex"></a>4ex</h2><p>编写 ex4.sh，将给定的参数转换成二进制表示。</p><div align="center"><img src="/2019/05-Shell/4ex.jpg"></div><h2 id="5ex"><a href="#5ex" class="headerlink" title="5ex"></a>5ex</h2><p>ex5.sh假设存在一个<code>/homework</code>的文件夹，其中包含一个 studentlist.csv的文件，当中存放了若干学生的学号，每个一行。例如：150341101、150341102、150341105、150341106，编写 ex11.sh。查看/homework 文件夹下学生是否提交了作业，假设作业名的格式为：学号_homework.txt。最后输出没提交作业的学号名单。</p><div align="center"><img src="/2019/05-Shell/5ex.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Shell
      
    
    </summary>
    
      <category term="Linux" scheme="https://isjinhao.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://isjinhao.github.io/tags/Linux/"/>
    
      <category term="服务器" scheme="https://isjinhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>04-进程管理</title>
    <link href="https://isjinhao.github.io/2019/04-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>https://isjinhao.github.io/2019/04-进程管理/</id>
    <published>2019-03-12T09:56:55.000Z</published>
    <updated>2019-03-12T13:45:22.702Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="Linux的进程状态"><a href="#Linux的进程状态" class="headerlink" title="Linux的进程状态"></a>Linux的进程状态</h2><div align="center"><img src="/2019/04-进程管理/Linux进程管理.png"></div><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p><code>Process Status</code>。查看进程状态的最常用的命令，它可以提供关于进程的许多信息。</p><ul><li><p>直接用ps命令可以列出每个与你的当前Shell有关的进程的基本信息。</p><div align="center"><img src="/2019/04-进程管理/ps.png"></div></li><li><p><code>ps -ef</code>：显示系统中所有进程的全面信息。</p><ul><li><p><code>-e</code>：显示所有进程</p></li><li><p><code>-f</code>：全格式</p></li><li><p>用户ID、进程ID、父进程ID、CPU占用率、开始时间、开始此进程的终端设备、此进程运行的总时间、命令名。</p><div align="center"><img src="/2019/04-进程管理/psef.png"></div></li></ul></li><li><p><code>ps aux</code>显示所有终端上所有用户的有关进程的所有信息。</p></li></ul><h2 id="终结进程"><a href="#终结进程" class="headerlink" title="终结进程"></a>终结进程</h2><ul><li>通常来说，终结一个前台进程可以使用<code>Ctrl+C</code>。</li><li>终结一个后台进程得使用<code>kill</code>命令。<code>kill &lt;进程号&gt;</code>。如果想强制杀掉一个进程需要使用-9：<code>kill -9 &lt;进程号&gt;</code></li></ul><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>使进程暂停由时间值所指定的秒数。此命令大多用于shell程序设计中，使两条命令执行之间停顿指定的时间。如：<code>sleep 100; who | grep &#39;root&#39;</code>。</p><h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p><code>wait</code>是用来阻塞当前进程的执行，直至指定的子进程执行结束后，才继续执行。</p><ul><li><code>wait [进程号 或 作业号]</code>：eg：wait 23 or wait %1</li><li>如果<code>wait</code>后面不带任何的进程号或作业号，那么<code>wait</code>会阻塞当前进程的执行，直至当前进程的所有子进程都执行结束后，才继续执行。</li></ul><h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p>fork()函数会创建一个和原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事。但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。fork()调用一次，<strong>分别向父子进程返回</strong>，它可能有三种不同的返回值：</p><ul><li><p>在父进程中，fork()返回新创建子进程的进程ID；</p></li><li><p>在子进程中，fork()返回0；</p></li><li><p>如果出现错误，fork()返回一个负值；</p></li></ul><p>所以我们可以通过fork返回的值来判断当前进程是子进程还是父进程。同时每个进程都有一个互不相同的进程标识符（process ID），可以通过getpid()函数获得，还有一个记录父进程pid的变量，可以通过getppid()函数获得变量的值。</p><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><div align="center"><img src="/2019/04-进程管理/t1代码.png"></div><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><div align="center"><img src="/2019/04-进程管理/t1结果.png"></div><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>程序运行到第7行，创建一个新的进程，克隆一份当前进程。向父进程返回子进程的pid，向子进程返回0。所以执行后父进程进入第3个分支，子进程进入第2个分支。</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><h3 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h3><div align="center"><img src="/2019/04-进程管理/t2代码.png"></div><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><div align="center"><img src="/2019/04-进程管理/t2结果.png"></div><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><div align="center"><img src="/2019/04-进程管理/t2分析.png"></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><h3 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h3><div align="center"><img src="/2019/04-进程管理/t3代码.png"></div><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><div align="center"><img src="/2019/04-进程管理/t3结果.png"></div><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><div align="center"><img src="/2019/04-进程管理/t3分析.png"></div><h2 id="题4"><a href="#题4" class="headerlink" title="题4"></a>题4</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div align="center"><img src="/2019/04-进程管理/t4.jpg"></div><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>执行第5行之后，向父进程返回真，向子进程返回假，但是没有任何影响，此时创建了一个进程，之后父子进程创建的进程个数相同，所以只分析一个再乘以2即可。第一个子进程分析结果如下图。注意，对于<code>A &amp;&amp; B || C</code>：</p><ul><li>表达式A为假，B不执行，C执行；</li><li>表达式A为真，B执行：<ul><li>B为真：C不执行；</li><li>B为假：C执行。</li></ul></li></ul><p>所以答案是<code>1+9*2=19</code>个。</p><div align="center"><img src="/2019/04-进程管理/t4图.png"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Linux的进程状态&quot;&gt;&lt;a href=&quot;#Linux的进程状态&quot; class=&quot;headerlink&quot; title=&quot;Linux的进
      
    
    </summary>
    
      <category term="Linux" scheme="https://isjinhao.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://isjinhao.github.io/tags/Linux/"/>
    
      <category term="服务器" scheme="https://isjinhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>03-vim</title>
    <link href="https://isjinhao.github.io/2019/03-vim/"/>
    <id>https://isjinhao.github.io/2019/03-vim/</id>
    <published>2019-03-12T07:27:18.000Z</published>
    <updated>2019-03-12T14:01:53.470Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="vi-amp-vim"><a href="#vi-amp-vim" class="headerlink" title="vi &amp; vim"></a>vi &amp; vim</h2><p>这俩都是文本编辑器。vi是Linux默认的编辑器，类似于windows的记事本。vim是vi的拓展，比vi更强大。可以用于在Linux中编辑文件内容。笔记中使用vim。它有两种模式，命令模式和编辑模式，在命令模式中可以做一些检索、筛选等操作。在编辑模式中可以对文档进行修改。</p><h2 id="进入-amp-退出"><a href="#进入-amp-退出" class="headerlink" title="进入 &amp; 退出"></a>进入 &amp; 退出</h2><h3 id="进入命令模式"><a href="#进入命令模式" class="headerlink" title="进入命令模式"></a>进入命令模式</h3><p>方法：<code>vim &lt;文件名&gt;</code>。此时进入命令模式，不能对文件内容进行操作。对文档的检索是在这种模式下进行的。</p><div align="center"><img src="/2019/03-vim/vima.png"></div><h3 id="进入编辑模式："><a href="#进入编辑模式：" class="headerlink" title="进入编辑模式："></a>进入编辑模式：</h3><h4 id="i：编辑位置在当前光标位置之前"><a href="#i：编辑位置在当前光标位置之前" class="headerlink" title="i：编辑位置在当前光标位置之前"></a><code>i</code>：编辑位置在当前光标位置之前</h4><p>按下<code>i</code>再按<code>_</code></p><div align="center"><img src="/2019/03-vim/i1.png"></div><div align="center"><img src="/2019/03-vim/i2.png"></div><h4 id="I：在光标所在行的行首插入新增文本"><a href="#I：在光标所在行的行首插入新增文本" class="headerlink" title="I：在光标所在行的行首插入新增文本"></a>I：在光标所在行的行首插入新增文本</h4><p>按下<code>I</code>再按<code>_</code></p><div align="center"><img src="/2019/03-vim/I11.png"></div><div align="center"><img src="/2019/03-vim/I22.png"></div><h4 id="a：在该命令之后输入的字符都插到光标之后"><a href="#a：在该命令之后输入的字符都插到光标之后" class="headerlink" title="a：在该命令之后输入的字符都插到光标之后"></a><code>a</code>：在该命令之后输入的字符都插到光标之后</h4><p>按下<code>a</code>再按<code>_</code></p><div align="center"><img src="/2019/03-vim/a1.png"></div><div align="center"><img src="/2019/03-vim/a1.png"></div><h4 id="A：在光标所在行的行尾添加文本"><a href="#A：在光标所在行的行尾添加文本" class="headerlink" title="A：在光标所在行的行尾添加文本"></a>A：在光标所在行的行尾添加文本</h4><p>按下<code>A</code>再按<code>_</code></p><div align="center"><img src="/2019/03-vim/A11.png"></div><div align="center"><img src="/2019/03-vim/a22.png"></div><h4 id="o：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行"><a href="#o：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行" class="headerlink" title="o：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行"></a><code>o</code>：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行</h4><p>按下<code>o</code>再按<code>_</code></p><div align="center"><img src="/2019/03-vim/o1.png"></div><div align="center"><img src="/2019/03-vim/o2.png"></div><h4 id="O：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上"><a href="#O：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上" class="headerlink" title="O：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上"></a><code>O</code>：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上</h4><p>按下<code>O</code>再按<code>_</code></p><div align="center"><img src="/2019/03-vim/o11.png"></div><div align="center"><img src="/2019/03-vim/o2.png"></div><h4 id="r：替换光标所在的哪一个字符"><a href="#r：替换光标所在的哪一个字符" class="headerlink" title="r：替换光标所在的哪一个字符"></a><code>r</code>：替换光标所在的哪一个字符</h4><p>按下<code>r</code>再按<code>_</code></p><div align="center"><img src="/2019/03-vim/r1.png"></div><div align="center"><img src="/2019/03-vim/r2.png"></div><h4 id="R：一直替换光标所在的文字，直到按下ESC为止"><a href="#R：一直替换光标所在的文字，直到按下ESC为止" class="headerlink" title="R：一直替换光标所在的文字，直到按下ESC为止"></a><code>R</code>：一直替换光标所在的文字，直到按下ESC为止</h4><p>按下<code>R</code>再按三次<code>_</code>再按<code>Esc</code></p><div align="center"><img src="/2019/03-vim/r11.png"></div><div align="center"><img src="/2019/03-vim/r22.png"></div><h3 id="退出编辑模式"><a href="#退出编辑模式" class="headerlink" title="退出编辑模式"></a>退出编辑模式</h3><p>在编辑模式下按 Esc 键。</p><h3 id="退出命令模式"><a href="#退出命令模式" class="headerlink" title="退出命令模式"></a>退出命令模式</h3><p>需要使用转义字符<code>:</code></p><ul><li><p><code>:q</code>：若未修改文件，此命令可以退出编辑器。</p></li><li><p><code>:wq</code>：把编辑缓冲区的内容写入文件中，退出编辑器，回到Shell下。</p></li><li><p><code>:ZZ</code>或<code>:x</code>：仅当作过修改时才将缓冲区内容写到文件上。</p></li><li><p><code>:q!</code>： 强行退出vi。告诉vi，无条件退出，丢弃缓冲区内容。</p></li></ul><h2 id="vim流程图"><a href="#vim流程图" class="headerlink" title="vim流程图"></a>vim流程图</h2><div align="center"><img src="/2019/03-vim/vim流程图.png"></div><h2 id="命令模式下的光标跳转"><a href="#命令模式下的光标跳转" class="headerlink" title="命令模式下的光标跳转"></a>命令模式下的光标跳转</h2><ol><li>方向键和Backspace键的使用和正常情况下相同。</li><li>移动到上一行，列不变：<code>k</code></li><li>移动到上一行行头：<code>-</code></li><li>移动到下一行，列不变：<code>j</code></li><li>移动到下一行行头：<code>+</code></li><li>如果在相应命令的前面加上一个数字<code>n</code>，相应命令执行<code>n</code>次。如<code>2k</code>表示向上移动两行，列不变。</li><li>移至行首：<code>^</code>或<code>0</code></li><li>移至行尾：<code>$</code></li><li>移至指定行：行号<code>G</code>。如<code>2G</code>，移动到第二行行首。</li><li>移至指定列：列号<code>|</code>。如<code>2|</code>，移动到本行第2列。</li></ol><h2 id="文本删除"><a href="#文本删除" class="headerlink" title="文本删除"></a>文本删除</h2><ol><li>命令<code>x</code>（小写字母）删除光标所在的字符。</li><li>命令<code>X</code>（大写字母）删除光标前面的那个字符</li><li>命令<code>dd</code>删除光标所在的整行</li><li>命令<code>D</code>从光标位置开始删除到行尾</li><li><code>d&lt;光标移动命令&gt;</code>删除从光标位置开始至光标移动命令之间的所有字符。如：<ol><li><code>d0</code>：从光标位置（不包括光标位）删至行首。</li><li><code>d3l</code>：从光标位置（包括光标位）向右删3个字符。</li><li><code>d$</code>：从光标位置（包括光标位）删至行尾。与D相同。</li><li><code>d5G</code>：将光标所在行至第5行都删除。</li></ol></li></ol><h2 id="复原命令"><a href="#复原命令" class="headerlink" title="复原命令"></a>复原命令</h2><ol><li><code>u</code>：取消前面刚执行的插入或删除命令的效果，恢复到此前的情况。</li><li><code>U</code>：总是把当前行恢复成它被编辑之前的状态。</li></ol><h2 id="重复命令"><a href="#重复命令" class="headerlink" title="重复命令"></a>重复命令</h2><p><code>.</code>：在命令模式下，重复执行前一次插入命令或删除命令</p><h2 id="补充文本编辑"><a href="#补充文本编辑" class="headerlink" title="补充文本编辑"></a>补充文本编辑</h2><h3 id="命令方式下"><a href="#命令方式下" class="headerlink" title="命令方式下"></a>命令方式下</h3><ol><li><code>d0</code>：删至行首</li><li><code>d$</code>：删至行尾</li><li><code>ndd</code>：删除当前行及其后的n-1行</li><li><code>yy</code>：复制当前行的文本</li><li><code>10yy</code>：复制包括当前行及其后面9行文本</li><li><code>p</code>：在当前行后面插入一个空行，把缓冲区的内容粘贴过来</li><li><code>P</code>：在当前行前面插入一个空行，把缓冲区的内容粘贴过来</li></ol><h3 id="ex转移方式下"><a href="#ex转移方式下" class="headerlink" title="ex转移方式下"></a>ex转移方式下</h3><ol><li><code>:n1,n2 d</code>：将n1行到n2行的内容删除</li><li><code>:n1,n2 co n3</code>：将n1行到n2行的内容复制到n3行下</li><li><code>:n1,n2 m n3</code>：将n1行到n2行的内容移到n3行下</li></ol><h2 id="字符串检索"><a href="#字符串检索" class="headerlink" title="字符串检索"></a>字符串检索</h2><ul><li>向下检索：/模式〈Enter〉。例如：/int</li><li>向上检索：?模式〈Enter〉。例如：?flout</li></ul><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><ol><li><code>:n1,n2s/word1/word2/g</code>：<code>n1</code>和<code>n2</code>为数字。在<code>n1</code>与<code>n2</code>行之间寻找<code>word1</code>这个字符串，并将该字符串替换为<code>word2</code>。例如<code>:100,200s/a/A</code>在100行到200行之间搜索a并替换成A。</li><li><code>:1,$s/word1/word2/gc</code>：全局搜索word1，替换成word2。<code>g</code>改成<code>gc</code>表示要用户确认。</li><li><code>:%s/$/s2/g</code>：在整个行的末尾添加s2。</li><li>全局替换命令g：<code>:g/模式/命令表</code>。</li><li><code>:g/s1/p</code>：打印文本中有s1的行。p命令表示打印。</li></ol><h2 id="块选择"><a href="#块选择" class="headerlink" title="块选择"></a>块选择</h2><p><code>ctrl+v</code>，然后使用方向键选择块。</p><ol><li><code>y</code>：复制反白的地方</li><li><code>d</code>：将反白的地方删除掉</li><li><code>p</code>：插入复制的内容</li></ol><p>参考：<a href="https://jingyan.baidu.com/article/84b4f565c6b9e560f6da3291.html。" target="_blank" rel="noopener">https://jingyan.baidu.com/article/84b4f565c6b9e560f6da3291.html。</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;vi-amp-vim&quot;&gt;&lt;a href=&quot;#vi-amp-vim&quot; class=&quot;headerlink&quot; title=&quot;vi &amp;amp
      
    
    </summary>
    
      <category term="Linux" scheme="https://isjinhao.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://isjinhao.github.io/tags/Linux/"/>
    
      <category term="服务器" scheme="https://isjinhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
      <category term="vim" scheme="https://isjinhao.github.io/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>02-Linux常用命令</title>
    <link href="https://isjinhao.github.io/2019/02-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://isjinhao.github.io/2019/02-Linux常用命令/</id>
    <published>2019-03-12T01:05:41.000Z</published>
    <updated>2019-03-12T15:27:36.477Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>终端窗口中的命令以Enter键结束，且Shell命令区分大小写。如果命令太长，一行放不下时，在行尾输入<code>\</code>并按Enter键。这时Shell会返回一个大于号（&gt;）作为提示符，表示该命令行尚未结束，允许继续输入有关信息。</p><div align="center"><img src="/2019/02-Linux常用命令/输入.png"></div><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>echo命令把命令行中的参数全部显示到标准输出（终端）中。如果参数用引号引起来，会按原样输出。否则会把各个单词按字符串输出，字符串之间用空格隔开。单引号/双引号的区别请看Shell那一部分。</p><div align="center"><img src="/2019/02-Linux常用命令/echo.png"></div><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>Linux的标准输出是屏幕，把结果输出到指定的文件叫做输出重定向。</p><ul><li><p><code>&gt;</code>：目标文件不存在，系统将建立该文件；文件存在，重定向将会删除该文件，并重新建立一个新文件存放结果。</p></li><li><p><code>&gt;&gt;</code>：目标文件不存在，系统将建立该文件；如果目标文件存在，新的输出结果将会追加到文件末尾。</p></li></ul><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>显示出当前所在目录的路径。</p><h2 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h2><p><code>history</code>命令可以看到用户所有曾经输入过的命令。</p><ul><li><p><code>!!</code>：执行上一个命令；</p></li><li><p>`!n：执行第n个命令；</p></li><li><p><code>!-n</code>：执行倒数第n个命令；</p></li><li><p><code>!xxx</code>：执行以xxx开头的命令，如之前使用过clear，<code>!cle</code>会执行clear。</p></li></ul><p><code>~/.bash_history</code>文件中会存储你近期使用过的命令。查看此文件：<code>cat ~/.bash_history</code></p><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><ul><li><p><code>date</code>命令在屏幕上显示或设置系统的日期和时间：</p><ul><li><code>date [+格式控制字符串]格式控制字符串常用单引号引起来。年:Y 月:m 日:d 小时:H 分:M 秒:S</code></li></ul><div align="center"><img src="/2019/02-Linux常用命令/date1.png"></div></li><li><p>有且只有超级用户能设置或修改系统时钟，语法如下：</p><ul><li><code>date -s “year-month-day hour:minute:second”</code></li></ul><div align="center"><img src="/2019/02-Linux常用命令/date2.png"></div></li></ul><p>系统在启动的时候是从CMOS（用来存储计算机某些参数的芯片）中加载时钟，为了保持系统时间与CMOS时间的一致性，Linux每隔一段时间会将系统时间写入CMOS。由于该同步是每隔一段时间进行的，在我们执行<code>date -s</code>后，如果马上重起机器，修改时间就有可能没有被写入CMOS，而<code>hwclock –w</code>强制把系统时间写入CMOS。</p><h2 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h2><p>列出日历信息。</p><ul><li>单独一个cal：列出当前月的日历信息。</li><li>cal xxxx：列出xxxx年的日历信息。</li><li>cal yy xxxx：列出xxxx年yy月的日历信息。</li><li>cal dd yy xxxx：列出xxxx年yy月xx日所在月的日历信息。</li></ul><div align="center"><img src="/2019/02-Linux常用命令/cal1.png"></div><h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>clear命令清除屏幕上的信息，清屏后，提示符移到屏幕左上角。</p><h2 id="关机-amp-重启"><a href="#关机-amp-重启" class="headerlink" title="关机 &amp; 重启"></a>关机 &amp; 重启</h2><ul><li><code>shutdown -h now</code>：立刻关机</li><li><code>shutdown -h 15:30</code>：15:30 关机</li><li><code>shutdown -h +30</code>：30 分钟后关机</li><li><code>reboot</code>：重启</li><li><code>shutdown -k +2 &quot;一会要关机，抓紧保存&quot;</code>：向所有用户输出关机通知，但不做真正操作。<code>+2</code>表示通知的关机时间是现在之后的两分钟。</li></ul><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>如果我们忘记某些命令或其参数如何使用，需要使用帮助命令。</p><ul><li><p><code>whatis &lt;命令&gt;</code>：显示命令的简短描述。</p></li><li><p><code>&lt;命令&gt; -help</code>：显示使用方法概述和参数列表。</p></li><li><p><code>man &lt;命令&gt;</code>：为命令提供相关帮助文档，页面分成章节。</p></li><li><p><code>info &lt;命令&gt;</code>：类似man命令，但是通常比它更详细。</p></li></ul><h2 id="切换路径命令"><a href="#切换路径命令" class="headerlink" title="切换路径命令"></a>切换路径命令</h2><ul><li><p><code>cd &lt;位置&gt;</code>：切换到指定位置；</p></li><li><p><code>cd ~</code>：切换到用户家目录；</p></li><li><p><code>cd -</code>：切换到上一个所在目录；</p></li></ul><h2 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h2><p>修改密码。</p><ul><li><p><code>单独的passwd</code>：修改使用该命令的用户的密码。</p></li><li><p><code>passwd 用户名</code>：root用户可以使用该命令修改其他用户的密码。</p></li></ul><h2 id="Linux用户"><a href="#Linux用户" class="headerlink" title="Linux用户"></a>Linux用户</h2><p>登录Linux系统时，必须通过指定的用户名和密码进行登录。不过所有的用户在Linux眼中都是一个数字，用userid（一个32位的二进制整数）来表示。可以通过id命令，查看自己的userid。userid为0的表示根用户。同时，在系统运行的每个进程、所创建的每个文件都有一个userid，这个userid代表运行这个程序的用户，或者文件的所有者。Linux系统中，用户被保存在<code>/etc/passwd</code>文件中。用户又分成三类：一般用户（userid&gt;=500）、超级用户（userid=0）和系统用户（userid&lt;500）。</p><div align="center"><img src="/2019/02-Linux常用命令/linux用户.png"></div><h2 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h2><p>Linux是一个多用户系统，即很多个用户同时操作一个设备中的资源，但不同的用户有不同的权限。这些用户中有一个是超级用户（root），它是权限最高的用户。root用户在终端中的输入命令以#开头，其他的用户以$开头。</p><div align="center"><img src="/2019/02-Linux常用命令/root.png"></div><div align="center"><img src="/2019/02-Linux常用命令/user.png"></div><ul><li><p><code>who</code>：列出正在使用系统的<strong>所有</strong>用户、所用的终端名和注册到系统的时间。</p><div align="center"><img src="/2019/02-Linux常用命令/who.png"></div></li><li><p><code>who am i</code>：列出<strong>使用该命令</strong>的用户、所用的终端名和注册到系统的时间。</p><div align="center"><img src="/2019/02-Linux常用命令/whoi.png"></div></li></ul><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><p>由于不同的用户有不同的权限。为了给不同的用户赋予相同的权限更加方便，诞生了用户组的概念。即同一个用户组里的人员可以有相同的某些权限。<strong>Linux中的用户或文件至少属于一个用户组</strong>。</p><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p><code>useradd</code>或者<code>adduser</code>。执行后的具体操作（不同发行版有区别）：</p><ul><li><p>分配一个新的userid，数值等于之前所有userid中数值最大的加一。</p></li><li><p>在/etc/passwd中添加一行。</p></li><li><p>为用户在/home下建立一个新的目录（用户的家目录），目录名和用户名相同。</p><div align="center"><img src="/2019/02-Linux常用命令/adduser.png"></div></li><li><p>在/etc/group中为用户建立一个新的个人组。</p></li><li><p>在/var/spool/mail中创建用户的邮件文件。</p><div align="center"><img src="/2019/02-Linux常用命令/addmail.png"></div></li></ul><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><p><code>userdel &lt;用户&gt;</code>。删除用户及部分相关信息，家目录和邮件文件还会存在。</p><ul><li><code>-r</code>：包括家目录和邮件池等在内的所有用户信息都会被删除。</li></ul><h2 id="添加-删除组"><a href="#添加-删除组" class="headerlink" title="添加/删除组"></a>添加/删除组</h2><ul><li><p><code>groupadd &lt;组名&gt;</code>。所有的组都保存在/etc/group文件中。</p></li><li><p><code>groupdel &lt;组名&gt;</code>。删除组。</p></li></ul><h2 id="etc-passwd-amp-etc-shadow"><a href="#etc-passwd-amp-etc-shadow" class="headerlink" title="/etc/passwd &amp; /etc/shadow"></a>/etc/passwd &amp; /etc/shadow</h2><ul><li><p><code>/etc/passwd</code>有7列：用户名、密码、用户id、主要组id、备注信息、主目录、登录shell。</p><ul><li>各列之间使用<code>:</code>分割。同时密码一般都是x（被加密了），加密后的密码在/etc/shadow中。</li></ul><div align="center"><img src="/2019/02-Linux常用命令/passwd.png"></div></li><li><p><code>/etc/shadow</code>有9列：用户名、加密密码、最近更改密码的日期、密码不可更改的天数、密码需要重新更改的天使、密码更改期限前的警告期限、密码过期的宽限时间、帐号失效日期、保留字段。但这里显示的密码是加密的。</p><div align="center"><img src="/2019/02-Linux常用命令/shadow.png"></div></li></ul><h2 id="查看用户所属的组"><a href="#查看用户所属的组" class="headerlink" title="查看用户所属的组"></a>查看用户所属的组</h2><ul><li><p><code>groups</code>：查看使用此命令的用户所属组；</p></li><li><p><code>groups &lt;用户&gt;</code>：查看指定用户所属组。用户可多选，使用空格隔开。</p></li></ul><h2 id="etc-group-amp-etc-gshadow"><a href="#etc-group-amp-etc-gshadow" class="headerlink" title="/etc/group &amp; /etc/gshadow"></a>/etc/group &amp; /etc/gshadow</h2><ul><li><code>/etc/group</code>：组名、组密码、组id、组中附加用户。</li></ul><div align="center"><img src="/2019/02-Linux常用命令/group.png"></div><ul><li><code>/etc/gshadow</code>：组名、密码、组管理者、组中附加用户。</li></ul><div align="center"><img src="/2019/02-Linux常用命令/gshadow.png"></div><h2 id="为用户添加备注"><a href="#为用户添加备注" class="headerlink" title="为用户添加备注"></a>为用户添加备注</h2><ul><li><p>在创建的时候添加：<code>useradd -c &lt;备注&gt; 用户名</code>。</p></li><li><p>创建后修改：<code>usermod -c &lt;备注&gt; 用户名</code>。（会清除之前的备注信息）。</p></li></ul><h2 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h2><p>改变用户某些属性的命令。</p><ul><li><p><code>-l</code>：改变用户的名称；</p></li><li><p><code>-G</code>：改变用户支持的用户组，会退出原来的附属组，配合<code>-a</code>不会删除之前组；</p><div align="center"><img src="/2019/02-Linux常用命令/usermodag.png"></div></li><li><p><code>-L</code>：不让该用户登录；</p></li><li><p><code>-e</code>：设定用户失效日期。日期格式：“YYYY-MM-DD”。</p></li><li><p><code>-s</code>：改变Shell。新创建的用户默认使用bash，此选项修改登录Shell。</p><ul><li>如：<code>usermod -aG 组名 用户</code></li></ul></li></ul><h2 id="gpasswd"><a href="#gpasswd" class="headerlink" title="gpasswd"></a>gpasswd</h2><p><code>gpasswd -d userName groupNam</code>e：从组中删除用户</p><h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><ul><li><p>超级用户输入<code>su 用户名</code>可以不用输入密码切换到其他用户。</p></li><li><p>普通用户切换到其他所有用户（<code>su 用户名</code>）需要输入密码。</p></li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。</p><ul><li><p>文件：文件系统中存储数据的一个命名的对象。即使是空文件（不包含用户数据）也会为操作系统提供其他信息。</p></li><li><p>目录：包含文件项目的一类特殊文件。Linux中在应用层上来看目录和文件是被区分开来的。</p><div align="center"><img src="/2019/02-Linux常用命令/filesys.png"></div></li></ul><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><p><code>find &lt;路径&gt; -name &#39;正则表达式&#39;</code>：如<code>find . -name &#39;*.so&#39;</code>，查找当前目录下以<code>.so</code>结尾的文件。</p><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><ul><li><p><code>cat &lt;文件&gt;</code>：显示文件的内容。文件可以多选，之间用空格隔开。</p></li><li><p><code>cat f1 &gt; f2</code>：把f1文件的内容合并到f2文件中。</p></li></ul><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><ul><li>文件不存在：则创建一个空的新文件；</li></ul><ul><li>文件存在：把文件的时间标签更新为系统当前时间。</li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>命令的意思：global search regular expression and print out the line。</p><h3 id="部分选项如下："><a href="#部分选项如下：" class="headerlink" title="部分选项如下："></a>部分选项如下：</h3><ul><li><p><code>-a</code>：将 binary 文件以 text 文件的方式搜寻数据</p></li><li><p><code>-c</code>：计算找到 ‘搜寻字符串’ 的次数</p></li><li><p><code>-i</code>：忽略大小写的不同，所以大小写视为相同</p></li><li><p><code>-n</code>：顺便输出行号</p></li><li><p><code>-v</code>：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！</p></li><li><p><code>--color=auto</code>：可以将找到的关键词部分加上颜色的显示喔！</p></li></ul><h3 id="举例如下："><a href="#举例如下：" class="headerlink" title="举例如下："></a>举例如下：</h3><div align="center"><img src="/2019/02-Linux常用命令/grep.jpg"></div><h2 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h2><p>管道命令是用来过滤信息的，比如我们之前<code>grep -n root /etc/passwd</code>之后显示带有root的行，如果想在结果中再按其他条件过滤就要使用管道命令：“|”。</p><div align="center"><img src="/2019/02-Linux常用命令/管道.png"></div><h2 id="统计文件信息"><a href="#统计文件信息" class="headerlink" title="统计文件信息"></a>统计文件信息</h2><p><code>wc</code>：统计指定文件的字节数（<code>-c</code>）、字数（<code>-w</code>）、行数（<code>-l</code>）</p><ul><li>例子：统计文件a中以b开头的行数：<code>cat a | grep ^b | wc -l</code></li></ul><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p><code>mkdir &lt;文件名&gt;</code>。</p><ul><li><code>-p</code>：父目录不存在时也可以创建。</li></ul><h2 id="删除文件-目录"><a href="#删除文件-目录" class="headerlink" title="删除文件/目录"></a>删除文件/目录</h2><p><code>rm -rf &lt;文件名&gt;</code>。<code>-r</code>表示递归删除；<code>-f</code>表示强制删除，不询问。</p><h2 id="列出文件"><a href="#列出文件" class="headerlink" title="列出文件"></a>列出文件</h2><p><code>ls</code>命令列出指定目录的内容。</p><div align="center"><img src="/2019/02-Linux常用命令/ls.png"></div><ul><li><p><code>-l</code>：文件的详细信息。输出的信息分成多列，它们依次是：文件类型与权限、链接数、文件主、文件组、文件大小、建立或最近修改的时间、文件名。total的计算：<a href="https://yq.aliyun.com/ziliao/264744" target="_blank" rel="noopener">https://yq.aliyun.com/ziliao/264744</a>。</p><div align="center"><img src="/2019/02-Linux常用命令/ll.png"></div></li><li><p><code>-a</code>：显示所有文件。之前显示的没有隐藏文件（以<code>.</code>开头）。</p></li><li><p><code>-h</code>：文件大小以人类可读的方式显示。需要配合<code>-l</code>使用。</p></li></ul><h2 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h2><p><code>cp &lt;文件&gt; &lt;目录&gt;</code>。</p><div align="center"><img src="/2019/02-Linux常用命令/cp.png"></div><h2 id="剪切文件"><a href="#剪切文件" class="headerlink" title="剪切文件"></a>剪切文件</h2><p><code>mv &lt;文件&gt; &lt;目录&gt;</code>。</p><div align="center"><img src="/2019/02-Linux常用命令/mv.png"></div><h2 id="修改文件名"><a href="#修改文件名" class="headerlink" title="修改文件名"></a>修改文件名</h2><p><code>mv &lt;文件&gt; &lt;新文件名&gt;</code>。</p><div align="center"><img src="/2019/02-Linux常用命令/mvname.png"></div><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>Linux中所有的文件都由两部分构成。</p><ul><li>索引结点：包含此文件的信息，如文件权限、文件主、文件大小等。</li></ul><ul><li><p>数据：文件的实际内容，有没有数据都可以。</p><div align="center"><img src="/2019/02-Linux常用命令/文件结构.png"></div></li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接就是把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。</p><ul><li><p>硬链接：硬链接是多一个文件名和inode结点关联。由于它依赖于inode，所以不能在不同的文件系统之间做硬链接。硬链接不能用于目录。用法：<code>ln &lt;被链接的文件&gt; &lt;新的文件名&gt;</code></p><div align="center"><img src="/2019/02-Linux常用命令/hardlink.png"></div></li><li><p>软连接：软连接是再拓展出一份inode，这个inode指向的区域保存如何找到真正数据的信息。用法：<code>ln -s &lt;被链接的文件&gt; &lt;新的文件名&gt;</code></p><div align="center"><img src="/2019/02-Linux常用命令/software.png"></div></li></ul><h2 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a>用户和权限</h2><ul><li><p>文件主：文件所有者，并赋予唯一的注册名。只有文件主或root才有权利用<code>chown</code>命令改变文件的所有关系（UID）。</p></li><li><p>用户组：通常，组中包含了有相同需求的用户。文件主或超级用户（root）可以利用<code>chgrp</code>命令改变文件的GID。</p></li><li><p>用户存取权限：Linux系统中规定了4种不同类型的用户：文件主、同组用户、其他用户、超级用户。</p></li><li><p>3种访问文件或目录的方式：r（读）、w（写）、 x（可执行或查找）。</p><div align="center"><img src="/2019/02-Linux常用命令/用户与权限.png"></div></li></ul><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><ul><li><p>只有文件主或超级用户root才有权用<code>chmod</code>命令改变文件或目录的存取权限。</p></li><li><p>使用格式：<code>chmod [选项] MODE 文件</code>。MODE可多选，之间用<code>,</code>隔开。</p><ul><li>MODE：<code>&lt;who&gt;&lt;操作符号&gt;&lt;权限&gt;</code>。<ul><li>who：u——user、g——group、o——others、a——all（可叠加）。</li><li>操作符号：<code>+ 添加</code>、<code>- 取消</code>、<code>= 赋予</code>；</li><li>权限：r 读、w 写、x 执行。（可叠加）</li></ul></li></ul></li><li><p>举例</p><div align="center"><img src="/2019/02-Linux常用命令/chmod.png"></div></li><li><p>以绝对方式改变权限</p><ul><li><p>置为1表示有相应权限，置为0表示没有相应权限。例如：</p><p><code>r w x r - x r - -</code></p><p><code>1 1 1 1 0 1 1 0 0</code></p></li><li><p>转换成十进制是754。<code>chmod 754 aa</code>和<code>chmod u=rwx,g=rx,o=r aa</code>一致。</p></li></ul><div align="center"><img src="/2019/02-Linux常用命令/chmod绝对.png"></div></li></ul><h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><p>官方的解释是掩码，其实就是用户创建文件或目录后它们的默认权限。不过和<code>chomd</code>有区别的是它把有权限设置为0，没权限设置为1，而且<code>umask</code>命令显示的是八进制数字。我的<code>umask</code>显示的是0022，转换成二进制就是000 010 010，转换成权限就是<code>rwx r-x r-x</code>。所以创建的目录的默认权限就是这个。但是Linux不允许新创建的文件有可执行权限，所以创建的文件的默认权限是<code>rw- r-- r--</code>。</p><div align="center"><img src="/2019/02-Linux常用命令/umask.png"></div><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p>改变某个文件或目录的所有者。<code>chown &lt;用户&gt; &lt;文件&gt;/&lt;目录&gt;</code></p><h2 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h2><p>改变文件或目录所属的用户组。<code>chgrp &lt;用户组&gt; &lt;文件&gt;/&lt;目录&gt;</code></p><h2 id="文件权限的理解"><a href="#文件权限的理解" class="headerlink" title="文件权限的理解"></a>文件权限的理解</h2><ul><li><p>可读（r）：浏览文件中的内容；</p></li><li><p>可写（w）：修改文件中的内容；</p></li><li><p>可执行（x）：将文件作为命令使用。</p></li></ul><h2 id="目录权限的理解"><a href="#目录权限的理解" class="headerlink" title="目录权限的理解"></a>目录权限的理解</h2><ul><li>可读：只能查看到目录下的子目录名和文件名；</li></ul><ul><li>可执行：可以访问目录中的文件，包括子目录；</li></ul><ul><li>可写：要在目录下添加删除目录和文件，必须有可执行的权利。</li></ul><h2 id="压缩-amp-打包-amp-解压缩"><a href="#压缩-amp-打包-amp-解压缩" class="headerlink" title="压缩 &amp; 打包 &amp; 解压缩"></a>压缩 &amp; 打包 &amp; 解压缩</h2><ul><li><p><code>tar -zcvf</code>：打包压缩后的文件名 要打包压缩的文件（多个之间用space分开）</p><ul><li><code>z</code>：调用gzip压缩命令进行压缩</li><li><code>c</code>：create，打包文件</li><li><code>v</code>：显示运行过程</li><li><code>f</code>：指定文件名</li></ul></li><li><p><code>tar -xvf xxx.tar.gz -C 位置</code></p><ul><li><code>x</code>：extract，解包</li><li><code>v</code>：显示允许过程</li><li><code>f</code>：指定文件名</li></ul></li></ul><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>我们可以使用ll代替<code>ls -l</code>。但是对于<code>ls -a</code>，系统并没有提供<code>la</code>命令，不过我们可以使用<code>alias</code>定义<code>la</code>。</p><div align="center"><img src="/2019/02-Linux常用命令/别名.png"></div><p>取消别名使用<code>unalias 别名</code></p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p><code>cron</code>工具允许用户配置要定期运行的任务，通过配置<code>crontab</code>的文件可以指定要运行哪些作业以及何时运行。配置<code>crontab</code>文件使用命令<code>crontab</code>。命令由6个用空白分隔的字段组成：</p><table><thead><tr><th>字段</th><th>minute</th><th>hour</th><th>day of month</th><th>month</th><th>day of week</th><th>command to run</th></tr></thead><tbody><tr><td>举例</td><td>45</td><td>16</td><td>*</td><td>*</td><td>*</td><td>date&gt;/tmp/date.txt</td></tr><tr><td>范围</td><td>0-59</td><td>0-23</td><td>1-31</td><td>1-12</td><td>0-7</td><td>*</td></tr></tbody></table><p>corntab命令的参数：</p><ul><li><code>-e</code>：编辑<code>crontab</code>的内容（会打开一个文件）；</li></ul><div align="center"><img src="/2019/02-Linux常用命令/crone.png"></div><ul><li>设置定期任务（16:45时把当前时间写入<code>/tmp/date.txt</code>文件中）：</li></ul><div align="center"><img src="/2019/02-Linux常用命令/设置定期任务.png"></div><ul><li><p>过一段时间之后查看<code>/tmp</code>文件夹：</p><div align="center"><img src="/2019/02-Linux常用命令/查看定时任务.png"></div></li><li><p><code>-u</code>：只有root才能执行这个选项，帮助其他用户建立/删除<code>crontab</code>；</p></li><li><p><code>-l</code>：查看crontab的工作内容:</p><div align="center"><img src="/2019/02-Linux常用命令/cronl.png"></div></li><li><p><code>-r</code>：删除crontab的工作内容；</p><div align="center"><img src="/2019/02-Linux常用命令/cronr.png"></div></li></ul><h2 id="成组命令"><a href="#成组命令" class="headerlink" title="成组命令"></a>成组命令</h2><p>被成组命令约束的命令被认为是一条命令。</p><ul><li><p><code>{ 命令; }</code>：需要有空格和命令隔开，且命令后面需要“<code>;</code>”。不创建子进程。</p></li><li><p><code>(命令)</code>：不强制需要有空格和命令隔开，不强制需要“<code>;</code>”。创建子进程完成功能。</p></li></ul><p>例如下例把两条ls命令的值全部由管道输入给grep。</p><div align="center"><img src="/2019/02-Linux常用命令/成组命令.png"></div><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>sort lines of text files，将文本文件内容加以排序，以行为单位来排序，但不改变文件原始内容。</p><ul><li>默认排序规则：从第每行一个字符开始，依次按照ASCII码值进行比较。</li></ul><ul><li><p><code>-n</code>：按数字的大小排序，默认情况下把数字看成字符。</p></li><li><p><code>-r</code>：反转排序效果。</p><div align="center"><img src="/2019/02-Linux常用命令/testsort.jpg"></div></li></ul><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p>文件输出时，删除重复行或列。但如果重复的行不连续则不起作用。</p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><ul><li>-：普通文件</li><li>l：符号链接文件</li><li>d：目录</li><li>s：套接字文件（socket）</li><li>b：块设备文件</li><li>p：命名管道文件（pipe）</li><li>c：字符设备文件</li></ul><h2 id="ex1：用户管理"><a href="#ex1：用户管理" class="headerlink" title="ex1：用户管理"></a>ex1：用户管理</h2><h3 id="在系统中添加三个用户：Blondie、Prince和Madonna"><a href="#在系统中添加三个用户：Blondie、Prince和Madonna" class="headerlink" title="在系统中添加三个用户：Blondie、Prince和Madonna"></a>在系统中添加三个用户：Blondie、Prince和Madonna</h3><div align="center"><img src="/2019/02-Linux常用命令/ex11.png"></div><h3 id="他们都希望属于次要组music"><a href="#他们都希望属于次要组music" class="headerlink" title="他们都希望属于次要组music"></a>他们都希望属于次要组music</h3><div align="center"><img src="/2019/02-Linux常用命令/ex12.png"></div><h3 id="Blondie要求在他的条目中添加特殊备注“heart-of-glass”"><a href="#Blondie要求在他的条目中添加特殊备注“heart-of-glass”" class="headerlink" title="Blondie要求在他的条目中添加特殊备注“heart of glass”"></a>Blondie要求在他的条目中添加特殊备注“heart of glass”</h3><div align="center"><img src="/2019/02-Linux常用命令/ex13.png"></div><h3 id="Prince要求使用-bin-csh作为登录shell"><a href="#Prince要求使用-bin-csh作为登录shell" class="headerlink" title="Prince要求使用/bin/csh作为登录shell"></a>Prince要求使用/bin/csh作为登录shell</h3><div align="center"><img src="/2019/02-Linux常用命令/ex14.png"></div><h3 id="Madonna的使用期限为2020-12-1。"><a href="#Madonna的使用期限为2020-12-1。" class="headerlink" title="Madonna的使用期限为2020-12-1。"></a>Madonna的使用期限为2020-12-1。</h3><div align="center"><img src="/2019/02-Linux常用命令/ex15.png"></div><h3 id="Blondie决定加入摔跤俱乐部wrestle组。"><a href="#Blondie决定加入摔跤俱乐部wrestle组。" class="headerlink" title="Blondie决定加入摔跤俱乐部wrestle组。"></a>Blondie决定加入摔跤俱乐部wrestle组。</h3><div align="center"><img src="/2019/02-Linux常用命令/ex161.png"></div><div align="center"><img src="/2019/02-Linux常用命令/ex162.png"></div><h3 id="Prince要将他的用户名改为tafkap。"><a href="#Prince要将他的用户名改为tafkap。" class="headerlink" title="Prince要将他的用户名改为tafkap。"></a>Prince要将他的用户名改为tafkap。</h3><div align="center"><img src="/2019/02-Linux常用命令/ex17.png"></div><h3 id="Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。"><a href="#Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。" class="headerlink" title="Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。"></a>Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。</h3><ul><li><p><code>groupadd fengshui</code></p></li><li><p><code>usermod -a –G fengshui Madonna</code></p></li><li><p><code>usermod –u 888 Madonna</code></p></li></ul><h3 id="Prince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。"><a href="#Prince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。" class="headerlink" title="Prince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。"></a>Prince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。</h3><ul><li><code>usermod –L Prince</code></li></ul><h3 id="Blondie最近表现不好，我们决定将他踢出去。"><a href="#Blondie最近表现不好，我们决定将他踢出去。" class="headerlink" title="Blondie最近表现不好，我们决定将他踢出去。"></a>Blondie最近表现不好，我们决定将他踢出去。</h3><ul><li><code>userdel –r Blondie</code>（想把该用户所有信息都一起删除可以使用-r）</li></ul><h2 id="ex2：文件目录管理"><a href="#ex2：文件目录管理" class="headerlink" title="ex2：文件目录管理"></a>ex2：文件目录管理</h2><h3 id="Ventura同时属于次要组governor和wrestle。"><a href="#Ventura同时属于次要组governor和wrestle。" class="headerlink" title="Ventura同时属于次要组governor和wrestle。"></a>Ventura同时属于次要组governor和wrestle。</h3><div align="center"><img src="/2019/02-Linux常用命令/ex21.png"></div><h3 id="Ventura撰写了自己的摔跤计划plans-txt，并将它放到目录-tmp下。"><a href="#Ventura撰写了自己的摔跤计划plans-txt，并将它放到目录-tmp下。" class="headerlink" title="Ventura撰写了自己的摔跤计划plans.txt，并将它放到目录/tmp下。"></a>Ventura撰写了自己的摔跤计划plans.txt，并将它放到目录/tmp下。</h3><div align="center"><img src="/2019/02-Linux常用命令/ex22.png"></div><h3 id="Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。"><a href="#Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。" class="headerlink" title="Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。"></a>Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。</h3><div align="center"><img src="/2019/02-Linux常用命令/ex22.png"></div><h3 id="用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？"><a href="#用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？" class="headerlink" title="用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？"></a>用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？</h3><div align="center"><img src="/2019/02-Linux常用命令/ex24.png"></div><h3 id="用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？"><a href="#用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？" class="headerlink" title="用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？"></a>用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？</h3><p>不可以，只有root和文件主能修改文件访问权。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;输入&quot;&gt;&lt;a href=&quot;#输入&quot; class=&quot;headerlink&quot; title=&quot;输入&quot;&gt;&lt;/a&gt;输入&lt;/h2&gt;&lt;p&gt;终端窗口中
      
    
    </summary>
    
      <category term="Linux" scheme="https://isjinhao.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://isjinhao.github.io/tags/Linux/"/>
    
      <category term="服务器" scheme="https://isjinhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>01-Linux入门</title>
    <link href="https://isjinhao.github.io/2019/01-Linux%E5%85%A5%E9%97%A8/"/>
    <id>https://isjinhao.github.io/2019/01-Linux入门/</id>
    <published>2019-03-12T00:48:58.000Z</published>
    <updated>2019-03-17T06:51:53.242Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="Linux介绍"><a href="#Linux介绍" class="headerlink" title="Linux介绍"></a>Linux介绍</h2><p>Linux是一套免费使用和自由传播的操作系统。严格来讲，Linux这个词本身只表示Linux内核，但一般来说使用Linux内核的操作系统都被称为Linux。而不同的厂家使用相同的Linux内核所构建的操作系统叫做Linux发行版。常见的Linux发行版有Ubuntu、Centos、Debian等。这些发行版的使用方法大同小异。</p><p>但Linux不仅限于使用在PC机上，移动端（安卓系统是由Linux改写而来）、路由器（只保留少许功能的Linux系统）等终端都在使用Linux。</p><h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><ul><li><p>虚拟机安装：<a href="https://blog.csdn.net/qq_38206090/article/details/82559358" target="_blank" rel="noopener">blog.csdn.net/qq_38206090/article/details/82559358</a></p></li><li><p>双系统：笔者没有安装过，因为怕系统出问题导致文件损失。</p></li><li><p>云服务器：云服务器系统配置Linux版本我认为是最简单的方式，所以以下实例均采用阿里云服务器。</p><div align="center"><img src="/2019/01-Linux入门/阿里云服务器.png"></div></li></ul><h2 id="连接服务器工具"><a href="#连接服务器工具" class="headerlink" title="连接服务器工具"></a>连接服务器工具</h2><ul><li><p>SecureCRT：去 <a href="http://59.110.143.226/Sharing-Your-Story/" target="_blank" rel="noopener">http://59.110.143.226/Sharing-Your-Story/</a> 搜索。</p></li><li><p>Termius：<a href="https://www.microsoft.com/store/productId/9NK1GDVPX09V" target="_blank" rel="noopener">https://www.microsoft.com/store/productId/9NK1GDVPX09V</a></p></li></ul><p>推荐使用Termius，好看也好用。SecureCRT是破解版，Termius是免费使用。</p><h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p>Linux的目录结构是一个树形结构，树根是一个/。直接子目录包括root、home等。</p><div align="center"><img src="/2019/01-Linux入门/根目录.png"></div><p>如我的阿里云服务器根目录：</p><div align="center"><img src="/2019/01-Linux入门/根目录格式.jpg"></div><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>Shell是指“为使用者提供操作界面”的软件（命令解析器）。Shell翻译过来叫做“壳”，用来区别于“核”，也就是说它把底层的东西封装成命令，使用者键入命令就能得到相应的结果。比如上面的这张图中，我在根目录下输入<code>ll</code>命令，就在终端上给我显示根目录下的文件信息。也就是说Shell解析了我输入的<code>ll</code>命令，返回我想要的信息（根目录文件信息）。</p><h2 id="Bash命令"><a href="#Bash命令" class="headerlink" title="Bash命令"></a>Bash命令</h2><p>Shell是命令解释器，自然会有不同的分类，就类比于同是循环结构，Java和Python却有不同的语法。但是Bash（Bourne-Again SHell）是Linux默认的Shell交互类型，也就是说在Linux中打开一个终端，就启动一个Bash进程。</p><h2 id="Bash命令格式"><a href="#Bash命令格式" class="headerlink" title="Bash命令格式"></a>Bash命令格式</h2><p>格式：命令名 [选项] [参数1] [参数2] … 有如下特点：</p><ul><li>命令名必须是小写英文字母。</li><li>一般格式中，方括号括起来的部分是可选选项。</li><li>选项是对命令的特别定义，以“-”开始。一个命令<strong>可以使用多个选项</strong>且多个选项连接起来同样有效（部分发行版不支持）。如：<code>ls -al</code>和<code>ls -a -l</code>效果相同。</li><li>命令正常执行后返回一个0表示执行成功，返回非0值表示执行过程出错。在终端上很难体现出来，但在shell脚本（后续会介绍）中可作为控制逻辑流程的一部分（用$?查看）。</li></ul><h2 id="Bash举例"><a href="#Bash举例" class="headerlink" title="Bash举例"></a>Bash举例</h2><p>查看内核版本号：<code>uname -a</code>:</p><div align="center"><img src="/2019/01-Linux入门/查看内核版本号.jpg"></div><p><code>uname</code>是命令名，<code>-a</code>是选项，这个命令没有参数。</p><h2 id="uname解释"><a href="#uname解释" class="headerlink" title="uname解释"></a>uname解释</h2><div align="center"><img src="/2019/01-Linux入门/uname.png"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Linux介绍&quot;&gt;&lt;a href=&quot;#Linux介绍&quot; class=&quot;headerlink&quot; title=&quot;Linux介绍&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="Linux" scheme="https://isjinhao.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://isjinhao.github.io/tags/Linux/"/>
    
      <category term="服务器" scheme="https://isjinhao.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>opencv实现人脸识别、人脸打框、人脸剪切</title>
    <link href="https://isjinhao.github.io/2019/opencv%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E3%80%81%E4%BA%BA%E8%84%B8%E6%89%93%E6%A1%86%E3%80%81%E4%BA%BA%E8%84%B8%E5%89%AA%E5%88%87/"/>
    <id>https://isjinhao.github.io/2019/opencv实现人脸识别、人脸打框、人脸剪切/</id>
    <published>2019-03-12T00:26:50.000Z</published>
    <updated>2019-03-12T00:39:15.338Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="Opencv在各平台上的配置"><a href="#Opencv在各平台上的配置" class="headerlink" title="Opencv在各平台上的配置"></a>Opencv在各平台上的配置</h2><p><a href="https://opencv-java-tutorials.readthedocs.io/en/latest/01-installing-opencv-for-java.html。" target="_blank" rel="noopener">https://opencv-java-tutorials.readthedocs.io/en/latest/01-installing-opencv-for-java.html。</a></p><h2 id="测试图片"><a href="#测试图片" class="headerlink" title="测试图片"></a>测试图片</h2><div align="center"><img src="/2019/opencv实现人脸识别、人脸打框、人脸剪切/test.jpg"></div><h2 id="人脸识别"><a href="#人脸识别" class="headerlink" title="人脸识别"></a>人脸识别</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Core;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Mat;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.MatOfRect;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Rect;</span><br><span class="line"><span class="keyword">import</span> org.opencv.imgcodecs.Imgcodecs;</span><br><span class="line"><span class="keyword">import</span> org.opencv.objdetect.CascadeClassifier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetImgFace</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String classifier = <span class="string">"D:/opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="comment">// 必须要加载Opencv的Library</span></span><br><span class="line">System.loadLibrary(Core.NATIVE_LIBRARY_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//图片路径不能有中文...</span></span><br><span class="line">GetImgFace.getImgFace(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\test.jpg"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Rect&gt; <span class="title">getImgFace</span><span class="params">(String imgPath)</span></span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 加载分类器，选择已经训练好的opencv分类器，训练器路径：%OPENCV_HOME%/sources/data/haarcascades/</span></span><br><span class="line"><span class="comment">  * 分类器包含眼睛，人脸，人体，微笑等等，其中对于仅仅识别人脸来说，最好的训练器是：</span></span><br><span class="line"><span class="comment">  * haarcascade_frontalface_default.xml</span></span><br><span class="line"><span class="comment">  * haarcascade_frontalface_alt.xml</span></span><br><span class="line"><span class="comment">  * haarcascade_frontalface_alt2.xml</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分类器路径不要有中文...</span></span><br><span class="line">CascadeClassifier faceDetector = <span class="keyword">new</span> CascadeClassifier(classifier);</span><br><span class="line"><span class="keyword">if</span> (faceDetector.empty()) &#123;</span><br><span class="line">System.out.println(<span class="string">"请选择正确的分类器！"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建Mat，Mat是用来保存图片信息的类。Imgcodecs是用来读取图片的工具类</span></span><br><span class="line">Mat image = Imgcodecs.imread(imgPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检测人脸，检测结果存在faceDetections中</span></span><br><span class="line">MatOfRect faceDetections = <span class="keyword">new</span> MatOfRect();</span><br><span class="line">faceDetector.detectMultiScale(image, faceDetections);</span><br><span class="line"></span><br><span class="line">List&lt;Rect&gt; faceList = Arrays.asList(faceDetections.toArray());</span><br><span class="line"></span><br><span class="line">System.out.println(faceList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> faceList;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><div align="center"><img src="/2019/opencv实现人脸识别、人脸打框、人脸剪切/人脸识别.jpg"></div><h2 id="人脸打框"><a href="#人脸打框" class="headerlink" title="人脸打框"></a>人脸打框</h2><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Mat;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Point;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Rect;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Scalar;</span><br><span class="line"><span class="keyword">import</span> org.opencv.imgcodecs.Imgcodecs;</span><br><span class="line"><span class="keyword">import</span> org.opencv.imgproc.Imgproc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FaceRect</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String imgPath = <span class="string">"C:\\Users\\ISJINHAO\\Desktop\\test.jpg"</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Rect&gt; faceRects = GetImgFace.getImgFace(imgPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把识别出来的图片分别打框</span></span><br><span class="line">Iterator&lt;Rect&gt; iterator1 = faceRects.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator1.hasNext()) &#123;</span><br><span class="line">Rect rect = iterator1.next();</span><br><span class="line">FaceRect.imageMark(imgPath, <span class="string">"D:\\test\\"</span> + UUID.randomUUID() + <span class="string">".jpg"</span>, rect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在一张图片中把所有识别出来的人脸都打框</span></span><br><span class="line">Mat image = Imgcodecs.imread(imgPath);</span><br><span class="line">Iterator&lt;Rect&gt; iterator2 = faceRects.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator2.hasNext()) &#123;</span><br><span class="line">Rect rect = iterator2.next();</span><br><span class="line">Imgproc.rectangle(image, <span class="keyword">new</span> Point(rect.x, rect.y), <span class="comment">// 左上点</span></span><br><span class="line"><span class="keyword">new</span> Point(rect.x + rect.width, rect.y + rect.height), <span class="comment">// 右下点</span></span><br><span class="line"><span class="keyword">new</span> Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>); <span class="comment">// 框的颜色和粗细</span></span><br><span class="line">&#125;</span><br><span class="line">Imgcodecs.imwrite(<span class="string">"D:\\test\\"</span> + UUID.randomUUID() + <span class="string">".jpg"</span>, image);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">imageMark</span><span class="params">(String imagePath, String outFilePath, Rect rect)</span> </span>&#123;</span><br><span class="line">Mat image = Imgcodecs.imread(imagePath);<span class="comment">// 原始图片</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Imgproc.rectangle的作用是在修改image中的数据，把相应的位置打上框</span></span><br><span class="line">Imgproc.rectangle(image, <span class="keyword">new</span> Point(rect.x, rect.y), <span class="comment">// 左上点</span></span><br><span class="line"><span class="keyword">new</span> Point(rect.x + rect.width, rect.y + rect.height), <span class="comment">// 右下点</span></span><br><span class="line"><span class="keyword">new</span> Scalar(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>); <span class="comment">// 框的颜色和粗细</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 把mat写入图片</span></span><br><span class="line">Imgcodecs.imwrite(outFilePath, image);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> File(outFilePath);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><div align="center"><img src="/2019/opencv实现人脸识别、人脸打框、人脸剪切/人脸打框.jpg"></div><h2 id="人脸剪切"><a href="#人脸剪切" class="headerlink" title="人脸剪切"></a>人脸剪切</h2><h3 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Mat;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Rect;</span><br><span class="line"><span class="keyword">import</span> org.opencv.core.Size;</span><br><span class="line"><span class="keyword">import</span> org.opencv.imgcodecs.Imgcodecs;</span><br><span class="line"><span class="keyword">import</span> org.opencv.imgproc.Imgproc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FaceCut</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String imgPath = <span class="string">"C:\\Users\\ISJINHAO\\Desktop\\test.jpg"</span>;</span><br><span class="line"></span><br><span class="line">List&lt;Rect&gt; faceRects = GetImgFace.getImgFace(imgPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把识别出来的图片分别打框</span></span><br><span class="line">Iterator&lt;Rect&gt; iterator1 = faceRects.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator1.hasNext()) &#123;</span><br><span class="line">Rect rect = iterator1.next();</span><br><span class="line">FaceCut.imageCut(imgPath, <span class="string">"D:\\test\\"</span> + UUID.randomUUID() + <span class="string">".jpg"</span>, rect);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> File <span class="title">imageCut</span><span class="params">(String imagePath, String outFilePath, Rect rect)</span> </span>&#123;</span><br><span class="line">Mat image = Imgcodecs.imread(imagePath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照原始图片中的人脸提取出来</span></span><br><span class="line">Mat sub = image.submat(rect);</span><br><span class="line">Mat mat = <span class="keyword">new</span> Mat();</span><br><span class="line">Size size = <span class="keyword">new</span> Size(rect.width, rect.height);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改提取出来的人脸信息sub在坐标轴的位置。</span></span><br><span class="line">Imgproc.resize(sub, mat, size);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将截图保存</span></span><br><span class="line">Imgcodecs.imwrite(outFilePath, mat);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> File(outFilePath);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><div align="center"><img src="/2019/opencv实现人脸识别、人脸打框、人脸剪切/人脸剪切.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Opencv在各平台上的配置&quot;&gt;&lt;a href=&quot;#Opencv在各平台上的配置&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="大学生创新创业项目" scheme="https://isjinhao.github.io/categories/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%88%9B%E6%96%B0%E5%88%9B%E4%B8%9A%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="opencv" scheme="https://isjinhao.github.io/tags/opencv/"/>
    
      <category term="人脸识别" scheme="https://isjinhao.github.io/tags/%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>03-处理机调度</title>
    <link href="https://isjinhao.github.io/2019/03-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6/"/>
    <id>https://isjinhao.github.io/2019/03-处理机调度/</id>
    <published>2019-03-11T14:15:32.000Z</published>
    <updated>2019-03-14T03:25:14.450Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>处理机调度是指通过对处理机资源进程的合理分配来提升系统资源的利用率、降低作业周转时间等。但是由于不同操作系统的目标不同，所以处理机调度的策略和目标也不相同。</p><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ul><li><p>高级调度：又称作业调度或长程调度。它的主要功能是根据某种算法决定把外存上处于后备队列中的哪些作业调入内存，并为他们创建进程、分配资源等，然后放入就绪进程队列。主要用于批处理系统，分时系统的实时系统中不设置高级调度。</p></li><li><p>低级调度：又称进程调度或断层调度。它的主要功能是根据某种算法决定让哪些就绪队列获得处理机，并由分配程序将处理机分配给被选中的进程。在批处理系统、实时系统和分时系统中都设置低级调度。</p></li><li><p>中级调度：又称内存调度。它的主要功能是根据某种算法决定将哪些暂时不能运行的进程调至外存等待，当它们具备运行条件且内存又有空闲时再调入内存。这实际上是存储器管理中的对换功能，在下一章再展开介绍，</p><div align="center"><img src="/2019/03-处理机调度/处理机调度层次.jpg"></div></li></ul><h3 id="处理机调度的目标"><a href="#处理机调度的目标" class="headerlink" title="处理机调度的目标"></a>处理机调度的目标</h3><ul><li>共同目标：<ul><li>提升资源利用率：$CPU的利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}​$。</li><li>公平：每个进程都应获得合理的CPU时间，不发生进程饥饿现象。</li><li>平衡：进程可以分成多个类型，如计算型、I/O型等等。平衡是指系统中不同的设备都能处于忙碌状态。</li><li>策略强制执行：指某些强制型任务，比如安全策略等，即使会造成其他工作的延迟。</li></ul></li><li>批处理系统的目标：<ul><li>平均周转时间短：<ul><li>周转时间：从作业进入系统到作业完成退出系统所用的时间。</li><li>平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NT_i]​$</li><li>带权周转时间：作业的周转时间（$T​$）和系统为它提供服务的时间（$T_S​$）。$W=\frac{T}{T_s}​$</li><li>平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NW_i]​$</li></ul></li><li>系统吞吐量高：单位时间内系统完成的作业数尽量多。</li><li>处理机利用率高。</li></ul></li><li>分时系统的目标：<ul><li>响应时间快：指终端提交一个请求到主机返回结果至终端的时间短。</li><li>均衡：不同请求的复杂度不同，所以响应时间必定不同，均衡是指响应时间应和请求复杂度相适应。</li></ul></li><li>实时系统的目标：<ul><li>截止时间的保证：对于HRT任务截止时间必须满足要求，SRT也要尽可能满足。</li><li>可预测性：如在观看电影时一般都会连续播放帧，所以请求是可预测的，假如采用双缓冲实现第<code>i</code>帧和第<code>i+1</code>帧并行处理就能提高实时性。</li></ul></li></ul><h2 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h2><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ul><li>作业：比程序更为广泛的概念，不仅包含了通常的程序和数据，还有一份作业说明书。在批处理系统中，是以作业为基本单位从外存调入内存的。</li><li>作业步：在作业运行期间，每个作业都必须经过若干个相对独立。又相互关联的顺序加工步骤才能得到结果。期中每一个加工步骤成为一个作业步。</li></ul><h3 id="作业控制块"><a href="#作业控制块" class="headerlink" title="作业控制块"></a>作业控制块</h3><p>Job Control Block，JCB。是作业在系统中存在的标志。保存了系统对作业进行管理和调度所需的全部信息。如：作业标识、用户名称、用户账号、作业类型（CPU繁忙型、I/O繁忙型、批量型、终端型等）、作业状态、调度信息（优先级、作业运行时间）、资源需求（预计运行时间、要求内存大小等）、已申请到资源的使用情况。</p><h3 id="作业运行的三个阶段"><a href="#作业运行的三个阶段" class="headerlink" title="作业运行的三个阶段"></a>作业运行的三个阶段</h3><ul><li><p>收容阶段：每一个作业进入系统时（即输入到硬盘），便由“作业注册”程序为该作业建立一个作业控制块JCB并把它放入作业后备队列中。</p></li><li><p>运行阶段：后备队列中的作业被选中后，系统会为其分配必要的资源和建立进程，然后将其放入就绪队列。一个作业从第一次进入就绪状态开始到它运行结束前都是处于运行阶段。</p></li><li><p>完成阶段：当作业完成或发生异常而终止时，作业便处于完成阶段，此时系统会撤销进程和资源，并将运行结果通过某种方式输入，如输出到文件中。</p><div align="center"><img src="/2019/03-处理机调度/批处理系统调度.jpg"></div></li></ul><h3 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h3><p>First-Come First-served，FCFS。每次调度都是选择一个或多个最先进入队列的作业或进程，为它们分配资源，创建进程和分配CPU，使之投入运行。它是最简单的调度算法，同时也可用于进程调度。效率不高，所以一般不作为主调度算法。</p><p>适用于CPU繁忙型而不适用于I/O繁忙型。因为CPU繁忙型长时间占用CPU很少有I/O操作，一旦获得CPU，就会运行很长时间，就是会长时间占用CPU，而I/O繁忙型由于要频繁访问IO端口，每次访问都要放弃CPU，等I/O访问完后要重新等待下一次调度（此时排到了就绪队列的队尾），所以要等待很久才能重新被调度。因此先来先服务有利于CPU繁忙型而不利于I/O繁忙型。</p><h3 id="短作业优先算法"><a href="#短作业优先算法" class="headerlink" title="短作业优先算法"></a>短作业优先算法</h3><p>Short Job First，SJF。指对短作业优先调度的算法，它从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。</p><p>此种算法对长作业非常不利而且实际使用上很难预估每个作业的运行时间。</p><h3 id="静态优先级调度算法"><a href="#静态优先级调度算法" class="headerlink" title="静态优先级调度算法"></a>静态优先级调度算法</h3><p>为照顾紧迫性作业，使之进入系统后获得优先处理，引入优先级调度算法。按照进程的优先级大小来调度，使高优先级进程得到优先处理的策略称为优先权调度算法。</p><p>静态优先级调度算法是指在输入前作业为其赋予优先级且一直保持不变。虽然可以照顾紧迫性作业，但是没有考虑到作业本身的运行时间和作业的等待时间等，所以产生了更好的动态优先级算法。</p><h3 id="高响应比算法"><a href="#高响应比算法" class="headerlink" title="高响应比算法"></a>高响应比算法</h3><p>高响应比算法是动态优先级算法的一种，其中$优先级 = \frac{响应时间}{要求服务时间} = \frac{等待时间+要求服务时间}{要求服务时间}​$。这样可以得到：</p><ul><li>对于短作业：其要求服务时间短，优先级相对较高。</li><li>对于长作业：在等待一段时间之后，其优先级会增长，直至够高而能获得服务。</li><li>对于先来作业：假如在某一时刻其仍未获得服务，和后来的作业相比其优先级相对较高。</li></ul><p>相应时间与周转时间的对比，假如作业运行完了，两者相等，假如没有则 $响应时间&lt;周转时间$</p><ul><li>周转时间：从作业进入系统到作业完成退出系统所用的时间。</li><li>响应时间：等待时间+要求服务时间。</li></ul><h2 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h2><h3 id="进程调度的任务和机制"><a href="#进程调度的任务和机制" class="headerlink" title="进程调度的任务和机制"></a>进程调度的任务和机制</h3><ul><li>保存处理机的现场信息：比如程序计数器、通用寄存器里的内容。</li><li>按某种算法选取进程。</li><li>把处理机分配给进程：把选中进程的PCB中的有关处理机调度的信息装入处理器的寄存器中，把处理器的控制权交给进程使其能从上次的断点处恢复运行。</li></ul><h3 id="进程调度机制"><a href="#进程调度机制" class="headerlink" title="进程调度机制"></a>进程调度机制</h3><div align="center"><img src="/2019/03-处理机调度/进程调度机制.jpg"></div><ul><li>排队器：每当有进程转入就绪状态时，排队器会将它插入到相应的就绪队列。</li><li>分派器：分派器依据进程调度程序（更直接的说，进程调度算法）所选定的进程，将其从就绪队列中取出。</li><li>上下文切换器：会产生两次上下文切换：<ul><li>旧进程和分配程序之间的切换；</li><li>分配程序和新进程之间的切换。</li></ul></li></ul><p>排队器、分派器、上下文切换器本身也是程序，但是它们是处于系统态的程序，而被调度的进程一般是用户态的程序，从系统态到用户态进行上下文切换需要很大的耗费，所以一般采用两组（或多组）寄存器，一组用于处理机在系统态时使用，一组用于系统在用户态时使用，这样在系统态和用户态之间切换时就可以只改变指针（用于从寄存器中存取数据和指令）使其指向指定寄存器就行。</p><h3 id="进程调度方式"><a href="#进程调度方式" class="headerlink" title="进程调度方式"></a>进程调度方式</h3><h3 id="非抢占方式"><a href="#非抢占方式" class="headerlink" title="非抢占方式"></a>非抢占方式</h3><p>一旦某进程获得处理机，就会一直运行下去，直至该进程完成或者因发生某种事件而被阻塞其他进程才能获得处理机。此时引起进程调度的因素：</p><ul><li>正在执行的进程运行完毕。</li><li>外部环境的改变使其不能再继续运行，如程序运行发生异常。</li><li>进程通信或进程同步时执行了某种原语，如<code>Block</code>。</li><li>正在执行的进程发出I/O请求。</li></ul><h3 id="抢占方式"><a href="#抢占方式" class="headerlink" title="抢占方式"></a>抢占方式</h3><p>允许调度程序根据某种原则去暂停某个正在执行的进程，将处理机分配给其他进程。这些原则一般有三种：</p><ul><li>高优先级原则；</li><li>短进程优先原则；</li><li>时间片原则。</li></ul><p>我们后面所提到的进程调度算法其实都是抢占方式下的策略。</p><h2 id="轮转调度算法"><a href="#轮转调度算法" class="headerlink" title="轮转调度算法"></a>轮转调度算法</h2><p>将CPU的处理时间分成固定大小的时间片q， q的大小从几ms到几百ms。系统将所有就绪进程按先来先服务的原则排成队列。每次调度时，把CPU分配给队首进程，令其执行一个时间片，时间片用完后若进程未结束，则送回就需队列尾部重新调度，在一给定的时间内，就绪进程均能获得一时间片的执行时间。</p><p>此时时间片大小是关键问题，一般来说时间片q正比于响应时间，反比于就绪进程数目。计算机的处理能力。速度快，q可小些。通常q值是这样决定的：</p><ul><li>批处理系统:80%的CPU周期在一个时间片内完成</li><li>分时系统：$q=T/N_{max}$，（$T-响应时间上限，N_{max}-最大进程数$）</li></ul><h2 id="优先级调度算法"><a href="#优先级调度算法" class="headerlink" title="优先级调度算法"></a>优先级调度算法</h2><h3 id="非抢占式优先级调度算法"><a href="#非抢占式优先级调度算法" class="headerlink" title="非抢占式优先级调度算法"></a>非抢占式优先级调度算法</h3><p>即一旦某个高优先级的进程占有了处理机，就一直运行下去，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件）才让另一高优先级进程运行。主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p><h3 id="抢占式优先级调度算法"><a href="#抢占式优先级调度算法" class="headerlink" title="抢占式优先级调度算法"></a>抢占式优先级调度算法</h3><p>任何时刻都严格按照高优先级进程在处理机上运行的原则进行进程的调度。常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。</p><h4 id="静态优先权"><a href="#静态优先权" class="headerlink" title="静态优先权"></a>静态优先权</h4><p>静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，这些整数被称为优先数。确定优先权大小的依据：</p><ul><li>进程类型；</li><li>进程对资源的需求；</li><li>用户要求。</li></ul><h4 id="动态优先权"><a href="#动态优先权" class="headerlink" title="动态优先权"></a>动态优先权</h4><p>动态优先权是指，在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得<br>更好的调度性能。例如，我们可以规定，在就绪队列中的进程，随其等待时间的增长，其优先权以速率<code>a</code>提高。若所有的进程都具有相同的优先权初值，则显然是最先进入就绪队列的进程，将因其动态优先权变得最高而优先获得处理机，此即<code>FCFS算法</code>。若所有的就绪进程具有各不相同的优先权初值，那么，对于优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机。当采用抢占式优先权调度算法时，如果再规定当前进程的优先权以速率b下降，则可防止一个长作业长期地垄断处理机。</p><h2 id="多队列调度算法"><a href="#多队列调度算法" class="headerlink" title="多队列调度算法"></a>多队列调度算法</h2><p>之前介绍的调度算法都是用一个算法来解决所有的进程调度，这样无法满足系统中不同用户对进程调度策略的不同要求。而多队列调度算法就是将就绪队列从一个分成多个，将不同性质或类型的进程放在不同的就绪队列，这样不同的队列之间设置优先级，和队列内部也可以设置优先级，能更好的满足用户的需求。</p><p>同时在多处理机系统中，可以方便的给每个处理机设置单独的就绪队列。</p><h2 id="多级反馈队列调度算法"><a href="#多级反馈队列调度算法" class="headerlink" title="多级反馈队列调度算法"></a>多级反馈队列调度算法</h2><ol><li>设置多个就绪队列，每个队列赋予不同的优先级，一个队列的优先级最高，第二个队列次之，其余各队列的优先级逐个降低，各队列内部使用FCFS原则排列。</li><li>优先级越高的进程时间片越短。</li><li>当一个进程进入内存后，首先放在第一队列的尾部，按FCFS的原则调度，如果该时间片内未结束，进程调度时将此进程转入第二队列队尾，直至第N个对列，若进程仍未结束，在第N个对列上采用时间片轮转算法。</li><li>仅当第<code>i</code>队列空闲时才调度第<code>i+1</code>队列，如果有新进程进入优先级较高的队列，剥夺CPU执行新进程，旧进程放入原队列尾部。</li></ol><p>此算法不必事先知道各进程执行的所需时间，可满足各种进程需要，是目前公认较好的进程调度算法。</p><div align="center"><img src="/2019/03-处理机调度/多级队列反馈调度算法.jpg"></div><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>第<code>i</code>个对列的时间片为$2^{i-1}$。</p><div align="center"><img src="/2019/03-处理机调度/多级反馈队列.jpg"></div><h2 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h2><h3 id="保证调度算法"><a href="#保证调度算法" class="headerlink" title="保证调度算法"></a>保证调度算法</h3><p>保证每个进程都获得相同的处理机时间：</p><ol><li>跟踪计算每个进程自创建以来已经执行的时间。</li><li>计算每个进程应该获得的处理机时间，即自创建以来的时间除以n。</li><li>比较各进程获得处理机时间的比率，即实际执行时间除以应获得的处理机时间。</li><li>比较各进程获得处理机时间的比率，如A：0.5；B：0.9；C：1.2。</li><li>调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率，然后把处理机让给此时比率最小的进程。</li></ol><h3 id="公平调度算法"><a href="#公平调度算法" class="headerlink" title="公平调度算法"></a>公平调度算法</h3><p>在上个算法中，如果用户A有4个进程，用户B有1各进程，那用户A获得处理机的时间是用户B的四倍。而公平调度算法的目标是保证每个用户都获得相同的处理机时间。</p><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><p>实时调度必须能满足实时任务对截止时间的要求。所以实时任务的算法和优先级算法有些区别。</p><h3 id="实时算法的分类"><a href="#实时算法的分类" class="headerlink" title="实时算法的分类"></a>实时算法的分类</h3><h4 id="非抢占式调度算法"><a href="#非抢占式调度算法" class="headerlink" title="非抢占式调度算法"></a>非抢占式调度算法</h4><ul><li>非抢占式轮转调度算法；</li><li>非抢占式优先调度算法。</li></ul><h4 id="抢占式调度算法"><a href="#抢占式调度算法" class="headerlink" title="抢占式调度算法"></a>抢占式调度算法</h4><ul><li>基于<a href="https://isjinhao.github.io/2019/%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD/#more">时钟中断</a>的抢占式优先级调度算法：在某实时任务到达后，如果它的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断发生时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先级任务。</li><li>立即抢占式优先级调度算法：一旦出现外部中断，只要当前任务未处于临界区，便立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。</li></ul><div align="center"><img src="/2019/03-处理机调度/实时调度.jpg"></div><h3 id="最早截止时间优先算法"><a href="#最早截止时间优先算法" class="headerlink" title="最早截止时间优先算法"></a>最早截止时间优先算法</h3><p>Earliest Deadline First，EDF。可用于非抢占式算法，也可用于抢占式算法。</p><h4 id="非抢占式"><a href="#非抢占式" class="headerlink" title="非抢占式"></a>非抢占式</h4><div align="center"><img src="/2019/03-处理机调度/非抢占式EDF.jpg"></div><h4 id="抢占式"><a href="#抢占式" class="headerlink" title="抢占式"></a>抢占式</h4><p>有两个周期任务，A、B的周期分别是20ms，50ms。A、B的执行时间分别是10ms和25ms。</p><div align="center"><img src="/2019/03-处理机调度/抢占式EDF.jpg"></div><h3 id="最低松弛度优先即算法"><a href="#最低松弛度优先即算法" class="headerlink" title="最低松弛度优先即算法"></a>最低松弛度优先即算法</h3><p>Least Laxity First，LLF。$松弛度=截止时间-当前时间-任务执行时间$。主要用于抢占式调度。</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>有两个周期任务，A、B的周期分别是20ms，50ms。A、B的执行时间分别是10ms和25ms。</p><div align="center"><img src="/2019/03-处理机调度/LLF.jpg"></div><h2 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h2><p>即高优先级进程（或线程）被低优先级（或线程）延迟或阻塞。例，假如有三个完全独立的进程P1、P2和P3，优先级P1&gt;P2&gt;P3。P1和P3通过共享一个临界资源进行交互。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P1：...P(mutex); CS<span class="number">-1</span>; V(mutex);... </span><br><span class="line">P2: ...Program2...;</span><br><span class="line">P3：...P(mutex); CS<span class="number">-3</span>; V(mutex);...</span><br></pre></td></tr></table></figure><p>假如P3最先执行，在执行了P(mutex)操作后，进入临界区CS-3。在时刻a，P2就绪，因为它比P3的优先级高，P2抢占了P3的处理机而运行，在时刻b，P1就绪，因为它比P2的优先级高，抢占处理机执行，但P1执行P(mutex)之后被阻塞，处理机被P2获得，P2执行结束后，P1仍不能进入临界区，处理机被P3获得，等P3退出临界区，P1才能获得处理机。所以本应该高优先级的P1优先执行，但是由于存在临界资源而导致优先级倒置。</p><div align="center"><img src="/2019/03-处理机调度/优先级倒置.jpg"></div><h3 id="优先级倒置的解决"><a href="#优先级倒置的解决" class="headerlink" title="优先级倒置的解决"></a>优先级倒置的解决</h3><p>遵循动态优先级继承原则：当高优先级进程P1要进入临界区去使用临界资源，如果已经有一个低优先级进程P3正在使用该资源，此时一方面P1被阻塞，一方面P3继承P1的优先级并一直保持到P3退出临界区。这样做就能保证不会有比P3优先级高但比P1优先级低的进程插进来。</p><div align="center"><img src="/2019/03-处理机调度/优先级倒置.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;处理机调度
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>仅使用Servlet3实现文件上传下载</title>
    <link href="https://isjinhao.github.io/2019/%E4%BB%85%E4%BD%BF%E7%94%A8Servlet3%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD/"/>
    <id>https://isjinhao.github.io/2019/仅使用Servlet3实现文件上传下载/</id>
    <published>2019-03-11T14:02:18.000Z</published>
    <updated>2019-03-12T00:10:42.326Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="上传文件的html界面"><a href="#上传文件的html界面" class="headerlink" title="上传文件的html界面"></a>上传文件的html界面</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>Insert title here<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>单文件上传<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/servlet3-upload-and-download/uploadone"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"upload"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>多文件上传<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"/servlet3-upload-and-download/uploadmany"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"file2"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"upload"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>文件下载<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/servlet3-upload-and-download/download"</span>&gt;</span>点击下载<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> download;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/download"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">download</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">resp.setContentType(<span class="string">"text/html;charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//filepath</span></span><br><span class="line">String filePath = <span class="string">"D:\\我.jpg"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>(</span><br><span class="line">BufferedInputStream bis = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(filePath));</span><br><span class="line">BufferedOutputStream bos = <span class="keyword">new</span> BufferedOutputStream(resp.getOutputStream());</span><br><span class="line"></span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> fileLength = <span class="keyword">new</span> File(filePath).length();</span><br><span class="line">resp.setHeader(<span class="string">"Content-disposition"</span>, <span class="string">"attachment; filename="</span> + <span class="keyword">new</span> String(<span class="keyword">new</span> File(filePath).getName().getBytes(<span class="string">"utf-8"</span>), <span class="string">"ISO8859-1"</span>));</span><br><span class="line">resp.setHeader(<span class="string">"Content-Length"</span>, String.valueOf(fileLength));</span><br><span class="line"><span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2048</span>];</span><br><span class="line"><span class="keyword">int</span> bytesRead;</span><br><span class="line"><span class="keyword">while</span> (-<span class="number">1</span> != (bytesRead = bis.read(buff, <span class="number">0</span>, buff.length))) &#123;</span><br><span class="line">bos.write(buff, <span class="number">0</span>, bytesRead);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">doGet(req, resp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><h3 id="单文件"><a href="#单文件" class="headerlink" title="单文件"></a>单文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> upload;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.MultipartConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Part;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/uploadone"</span>)</span><br><span class="line"><span class="meta">@MultipartConfig</span><span class="comment">//Servlet3中处理multipart/form-data类型请求的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadOne</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.doPost(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line"><span class="comment">//说明输入的请求信息采用UTF-8编码方式</span></span><br><span class="line">request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">response.setContentType(<span class="string">"text/html; charset=UTF-8"</span>);</span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Servlet3.0中新引入的方法，用来处理multipart/form-data类型编码的表单</span></span><br><span class="line">Part part = request.getPart(<span class="string">"file"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取HTTP头信息headerInfo=（form-data; name="file" filename="文件名"）</span></span><br><span class="line">String headerInfo = part.getHeader(<span class="string">"content-disposition"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"headinfo  ==&gt;  "</span> + headerInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从HTTP头信息中获取文件名fileName=（文件名）</span></span><br><span class="line">String fileName = headerInfo.substring(headerInfo.lastIndexOf(<span class="string">"="</span>) + <span class="number">2</span>, headerInfo.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得存储上传文件的文件夹路径</span></span><br><span class="line">String fileSavingFolder = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">"/upload"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得存储上传文件的完整路径（文件夹路径+文件名）</span></span><br><span class="line"><span class="comment">//文件夹位置固定，文件夹采用与上传文件的原始名字相同</span></span><br><span class="line">String fileSavingPath = fileSavingFolder + File.separator + fileName;</span><br><span class="line">System.out.println(<span class="string">"filePath  ==&gt;  "</span> + fileSavingPath);</span><br><span class="line"><span class="comment">//如果存储上传文件的文件夹不存在，则创建文件夹</span></span><br><span class="line">File f = <span class="keyword">new</span> File(fileSavingFolder + File.separator);</span><br><span class="line"><span class="keyword">if</span>(!f.exists())&#123;</span><br><span class="line">f.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将上传的文件内容写入服务器文件中</span></span><br><span class="line">part.write(fileSavingPath);</span><br><span class="line"><span class="comment">//输出上传成功信息</span></span><br><span class="line">out.println(<span class="string">"文件上传成功~！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多文件"><a href="#多文件" class="headerlink" title="多文件"></a>多文件</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> upload;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.MultipartConfig;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Part;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/uploadmany"</span>)</span><br><span class="line"><span class="meta">@MultipartConfig</span><span class="comment">//Servlet3中处理multipart/form-data类型请求的注解</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UploadMany</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line"><span class="keyword">this</span>.doPost(request, response);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ServletException,IOException</span>&#123;</span><br><span class="line"><span class="comment">//说明输入的请求信息采用UTF-8编码方式</span></span><br><span class="line">request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">response.setContentType(<span class="string">"text/html; charset=UTF-8"</span>);</span><br><span class="line">PrintWriter out = response.getWriter();</span><br><span class="line"></span><br><span class="line"><span class="comment">//Servlet3.0中新引入的方法，用来处理multipart/form-data类型编码的表单</span></span><br><span class="line">Collection&lt;Part&gt; parts = request.getParts();</span><br><span class="line">Iterator&lt;Part&gt; iterator = parts.iterator();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//获得存储上传文件的文件夹路径</span></span><br><span class="line">String fileSavingFolder = <span class="keyword">this</span>.getServletContext().getRealPath(<span class="string">"/upload"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext()) &#123;</span><br><span class="line">Part next = iterator.next();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得文件大小</span></span><br><span class="line"><span class="keyword">long</span> size = next.getSize();</span><br><span class="line"></span><br><span class="line">System.out.println(size);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取HTTP头信息headerInfo=（form-data; name="file" filename="文件名"）</span></span><br><span class="line">String headerInfo = next.getHeader(<span class="string">"content-disposition"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"headinfo  ==&gt;  "</span> + headerInfo);</span><br><span class="line"></span><br><span class="line"><span class="comment">//从HTTP头信息中获取文件名fileName=（文件名）</span></span><br><span class="line">String fileName = headerInfo.substring(headerInfo.lastIndexOf(<span class="string">"="</span>) + <span class="number">2</span>, headerInfo.length() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获得存储上传文件的完整路径（文件夹路径+文件名）</span></span><br><span class="line"><span class="comment">//文件夹位置固定，文件夹采用与上传文件的原始名字相同</span></span><br><span class="line">String fileSavingPath = fileSavingFolder + File.separator + fileName;</span><br><span class="line">System.out.println(<span class="string">"filePath  ==&gt;  "</span> + fileSavingPath);</span><br><span class="line"><span class="comment">//如果存储上传文件的文件夹不存在，则创建文件夹</span></span><br><span class="line">File f = <span class="keyword">new</span> File(fileSavingFolder + File.separator);</span><br><span class="line"><span class="keyword">if</span>(!f.exists())&#123;</span><br><span class="line">f.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将上传的文件内容写入服务器文件中</span></span><br><span class="line">next.write(fileSavingPath);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出上传成功信息</span></span><br><span class="line">out.println(<span class="string">"文件上传成功~！"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>demo下载：<a href="https://github.com/isjinhao/servlet3-upload-and-download。" target="_blank" rel="noopener">https://github.com/isjinhao/servlet3-upload-and-download。</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;上传文件的html界面&quot;&gt;&lt;a href=&quot;#上传文件的html界面&quot; class=&quot;headerlink&quot; title=&quot;上传文件的
      
    
    </summary>
    
      <category term="Java Web" scheme="https://isjinhao.github.io/categories/Java-Web/"/>
    
    
      <category term="servlet3" scheme="https://isjinhao.github.io/tags/servlet3/"/>
    
      <category term="文件上传" scheme="https://isjinhao.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="文件下载" scheme="https://isjinhao.github.io/tags/%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/"/>
    
  </entry>
  
  <entry>
    <title>基于Face++人脸识别系统项目结构</title>
    <link href="https://isjinhao.github.io/2019/%E5%9F%BA%E4%BA%8EFacepp%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84/"/>
    <id>https://isjinhao.github.io/2019/基于Facepp人脸识别系统项目结构/</id>
    <published>2019-03-11T07:38:37.000Z</published>
    <updated>2019-03-11T08:48:59.253Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="要求"><a href="#要求" class="headerlink" title="要求"></a>要求</h2><p><code>AngularJS+Bootstrap3+SSM+Opencv+Face++</code>开发一套人脸签到系统，使用电脑摄像头获取人脸并进行签到。</p><h2 id="识别方式"><a href="#识别方式" class="headerlink" title="识别方式"></a>识别方式</h2><ul><li><p>验证方式：人脸图片+保存人脸至服务器+到场离场时间。</p><ul><li>到场离场时间：第一次截取到的人脸是到场，最后一次截取到的人脸是离场。</li><li>人脸图片、保存至服务器：使用Opencv 识别图片中的人脸得到所有的Rect，一个人脸在图片中的位置会储存在一个Rect（x轴、y轴、width、height）对象中。然后循环以下做法：剪切出每个Rect在图片中对应的子图片，调用Face++的接口搜索与子图片最相近的一个人，如果最相近的人置信度 &gt;= 80，认为是同一个人，复制一份原图片，然后把Rect对应的位置画上框，保存在指定文件夹（每个活动有唯一的存储文件夹）下，如果置信度 &lt; 80，处理下一个Rect。</li></ul><div align="center"><img src="/2019/基于Facepp人脸识别系统项目结构/画框.jpg"></div></li><li><p>上传方式：客户端一秒截一张图上传。</p></li></ul><h2 id="实体-amp-表结构"><a href="#实体-amp-表结构" class="headerlink" title="实体 &amp; 表结构"></a>实体 &amp; 表结构</h2><p>组织创建活动，学生参与活动。活动分为两种，使用组的和不使用组的。使用组的应用场景是教学班签到，教学班的人数是固定的，不属于教学班的人即使识别成功也不算为签到。不使用组的应用场景是社团活动签到，只要识别成功，就算为签到。</p><div align="center"><img src="/2019/基于Facepp人脸识别系统项目结构/表结构.jpg"></div><h2 id="组织功能"><a href="#组织功能" class="headerlink" title="组织功能"></a>组织功能</h2><h3 id="组织注册"><a href="#组织注册" class="headerlink" title="组织注册"></a>组织注册</h3><div align="center"><img src="/2019/基于Facepp人脸识别系统项目结构/oregister.jpg"></div><h3 id="发布活动"><a href="#发布活动" class="headerlink" title="发布活动"></a>发布活动</h3><div align="center"><img src="/2019/基于Facepp人脸识别系统项目结构/发布活动.jpg"></div><h3 id="查看组信息"><a href="#查看组信息" class="headerlink" title="查看组信息"></a>查看组信息</h3><div align="center"><img src="/2019/基于Facepp人脸识别系统项目结构/查看组信息.jpg"></div><h3 id="查看举办的活动信息："><a href="#查看举办的活动信息：" class="headerlink" title="查看举办的活动信息："></a>查看举办的活动信息：</h3><div align="center"><img src="/2019/基于Facepp人脸识别系统项目结构/查看举办的活动信息.jpg"></div><h3 id="查看每场活动用户："><a href="#查看每场活动用户：" class="headerlink" title="查看每场活动用户："></a>查看每场活动用户：</h3><div align="center"><img src="/2019/基于Facepp人脸识别系统项目结构/查看每场活动的参与者.jpg"></div><h3 id="录入和导出记录"><a href="#录入和导出记录" class="headerlink" title="录入和导出记录"></a>录入和导出记录</h3><div align="center"><img src="/2019/基于Facepp人脸识别系统项目结构/录入和导出记录.jpg"></div><h3 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h3><div align="center"><img src="/2019/基于Facepp人脸识别系统项目结构/签到.jpg"></div><h2 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h2><h3 id="用户注册"><a href="#用户注册" class="headerlink" title="用户注册"></a>用户注册</h3><div align="center"><img src="/2019/基于Facepp人脸识别系统项目结构/用户注册.jpg"></div><p>###</p><h3 id="用户查看签到"><a href="#用户查看签到" class="headerlink" title="用户查看签到"></a>用户查看签到</h3><div align="center"><img src="/2019/基于Facepp人脸识别系统项目结构/用户签到.jpg"></div><h3 id="用户查看组"><a href="#用户查看组" class="headerlink" title="用户查看组"></a>用户查看组</h3><div align="center"><img src="/2019/基于Facepp人脸识别系统项目结构/用户查看组.jpg"></div><h2 id="管理员"><a href="#管理员" class="headerlink" title="管理员"></a>管理员</h2><div align="center"><img src="/2019/基于Facepp人脸识别系统项目结构/管理员.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;要求&quot;&gt;&lt;a href=&quot;#要求&quot; class=&quot;headerlink&quot; title=&quot;要求&quot;&gt;&lt;/a&gt;要求&lt;/h2&gt;&lt;p&gt;&lt;code
      
    
    </summary>
    
      <category term="大学生创新创业项目" scheme="https://isjinhao.github.io/categories/%E5%A4%A7%E5%AD%A6%E7%94%9F%E5%88%9B%E6%96%B0%E5%88%9B%E4%B8%9A%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="SSM" scheme="https://isjinhao.github.io/tags/SSM/"/>
    
      <category term="Face++" scheme="https://isjinhao.github.io/tags/Face/"/>
    
      <category term="Opencv" scheme="https://isjinhao.github.io/tags/Opencv/"/>
    
  </entry>
  
  <entry>
    <title>markdown数学公式</title>
    <link href="https://isjinhao.github.io/2019/markdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F/"/>
    <id>https://isjinhao.github.io/2019/markdown数学公式/</id>
    <published>2019-03-11T04:09:00.000Z</published>
    <updated>2019-03-11T04:42:29.563Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">代码</th><th style="text-align:center">符号</th><th style="text-align:center">代码</th></tr></thead><tbody><tr><td style="text-align:center">$\sum$</td><td style="text-align:center"><code>\sum</code></td><td style="text-align:center">$\sum_{i=0}^n$</td><td style="text-align:center"><code>\sum_{i=0}^n</code></td></tr><tr><td style="text-align:center">$\pm$</td><td style="text-align:center"><code>\pm</code></td><td style="text-align:center">$\div$</td><td style="text-align:center"><code>\div</code></td></tr><tr><td style="text-align:center">$\cdot$</td><td style="text-align:center"><code>\cdot</code></td><td style="text-align:center">$\times$</td><td style="text-align:center"><code>\times</code></td></tr><tr><td style="text-align:center">$\mid$</td><td style="text-align:center"><code>\mid</code></td><td style="text-align:center">$\circ$</td><td style="text-align:center"><code>\circ</code></td></tr><tr><td style="text-align:center">$\ast$</td><td style="text-align:center"><code>\ast</code></td><td style="text-align:center">$\bigotimes$</td><td style="text-align:center"><code>\bigotimes</code></td></tr><tr><td style="text-align:center">$\bigoplus$</td><td style="text-align:center"><code>\bigoplus</code></td><td style="text-align:center">$\leq$</td><td style="text-align:center"><code>\leq</code></td></tr><tr><td style="text-align:center">$\geq$</td><td style="text-align:center"><code>\geq</code></td><td style="text-align:center">$\neq$</td><td style="text-align:center"><code>\neq</code></td></tr><tr><td style="text-align:center">$\approx$</td><td style="text-align:center"><code>\approx</code></td><td style="text-align:center">$\prod$</td><td style="text-align:center"><code>\prod</code></td></tr><tr><td style="text-align:center">$\coprod$</td><td style="text-align:center"><code>\coprod</code></td><td style="text-align:center">$\cdots$</td><td style="text-align:center"><code>\cdots</code></td></tr><tr><td style="text-align:center">$\int$</td><td style="text-align:center"><code>\int</code></td><td style="text-align:center">$\iint$</td><td style="text-align:center"><code>\iint</code></td></tr><tr><td style="text-align:center">$\oint$</td><td style="text-align:center"><code>\oint</code></td><td style="text-align:center">$\infty$</td><td style="text-align:center"><code>\infty</code></td></tr><tr><td style="text-align:center">$\nabla$</td><td style="text-align:center"><code>\nabla</code></td><td style="text-align:center">$\because$</td><td style="text-align:center"><code>\because</code></td></tr><tr><td style="text-align:center">$\therefore$</td><td style="text-align:center"><code>\therefore</code></td><td style="text-align:center">$\forall$</td><td style="text-align:center"><code>\forall</code></td></tr><tr><td style="text-align:center">$\exists$</td><td style="text-align:center"><code>\exists</code></td><td style="text-align:center">$\not=$</td><td style="text-align:center"><code>\not=</code></td></tr><tr><td style="text-align:center">$\not&gt;$</td><td style="text-align:center"><code>\not&gt;</code></td><td style="text-align:center">$\leq$</td><td style="text-align:center"><code>\leq</code></td></tr><tr><td style="text-align:center">$\geq$</td><td style="text-align:center"><code>\geq</code></td><td style="text-align:center">$\not\subset$</td><td style="text-align:center"><code>\not\subset</code></td></tr><tr><td style="text-align:center">$\emptyset$</td><td style="text-align:center"><code>\emptyset</code></td><td style="text-align:center">$\in$</td><td style="text-align:center"><code>\in</code></td></tr><tr><td style="text-align:center">$\notin$</td><td style="text-align:center"><code>\notin</code></td><td style="text-align:center">$\subset$</td><td style="text-align:center"><code>\subset</code></td></tr><tr><td style="text-align:center">$\subseteq$</td><td style="text-align:center"><code>\subseteq</code></td><td style="text-align:center">$\bigcup$</td><td style="text-align:center"><code>\bigcup</code></td></tr><tr><td style="text-align:center">$\bigcap$</td><td style="text-align:center"><code>\bigcap</code></td><td style="text-align:center">$\bigvee$</td><td style="text-align:center"><code>\bigvee</code></td></tr><tr><td style="text-align:center">$\bigwedge$</td><td style="text-align:center"><code>\bigwedge</code></td><td style="text-align:center">$\biguplus$</td><td style="text-align:center"><code>\biguplus</code></td></tr><tr><td style="text-align:center">$\bigsqcup$</td><td style="text-align:center"><code>\bigsqcup</code></td><td style="text-align:center">$\hat{y}$</td><td style="text-align:center"><code>\hat{y}</code></td></tr><tr><td style="text-align:center">$\check{y}$</td><td style="text-align:center"><code>\check{y}</code></td><td style="text-align:center">$\breve{y}$</td><td style="text-align:center"><code>\breve{y}</code></td></tr><tr><td style="text-align:center">$\overline{a+b+c+d}$</td><td style="text-align:center"><code>\overline{a+b+c+d}</code></td><td style="text-align:center">$\underline{a+b+c+d}$</td><td style="text-align:center"><code>\underline{a+b+c+d}</code></td></tr><tr><td style="text-align:center">$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$</td><td style="text-align:center"><code>\overbrace{a+\underbrace</code><br><code>{b+c}_{1.0}+d}^{2.0}</code></td><td style="text-align:center">$\uparrow$</td><td style="text-align:center"><code>\uparrow</code></td></tr><tr><td style="text-align:center">$\downarrow$</td><td style="text-align:center"><code>\downarrow</code></td><td style="text-align:center">$\Uparrow$</td><td style="text-align:center"><code>\Uparrow</code></td></tr><tr><td style="text-align:center">$\Downarrow$</td><td style="text-align:center"><code>\Downarrow</code></td><td style="text-align:center">$\rightarrow$</td><td style="text-align:center"><code>\rightarrow</code></td></tr><tr><td style="text-align:center">$\leftarrow$</td><td style="text-align:center"><code>\leftarrow</code></td><td style="text-align:center">$\Rightarrow$</td><td style="text-align:center"><code>\Rightarrow</code></td></tr><tr><td style="text-align:center">$\Longleftarrow$</td><td style="text-align:center"><code>\Longleftarrow</code></td><td style="text-align:center">$\longleftarrow$</td><td style="text-align:center"><code>\longleftarrow</code></td></tr><tr><td style="text-align:center">$\longrightarrow$</td><td style="text-align:center"><code>\longrightarrow</code></td><td style="text-align:center">$\Longrightarrow$</td><td style="text-align:center"><code>\Longrightarrow</code></td></tr><tr><td style="text-align:center">$\alpha$</td><td style="text-align:center"><code>\alpha</code></td><td style="text-align:center">$\beta$</td><td style="text-align:center"><code>\beta</code></td></tr><tr><td style="text-align:center">$\gamma$</td><td style="text-align:center"><code>\gamma</code></td><td style="text-align:center">$\Gamma$</td><td style="text-align:center"><code>\Gamma</code></td></tr><tr><td style="text-align:center">$\delta$</td><td style="text-align:center"><code>\delta</code></td><td style="text-align:center">$\Delta$</td><td style="text-align:center"><code>\Delta</code></td></tr><tr><td style="text-align:center">$\epsilon$</td><td style="text-align:center"><code>\epsilon</code></td><td style="text-align:center">$\varepsilon$</td><td style="text-align:center"><code>\varepsilon</code></td></tr><tr><td style="text-align:center">$\zeta$</td><td style="text-align:center"><code>\zeta</code></td><td style="text-align:center">$\eta$</td><td style="text-align:center"><code>\eta</code></td></tr><tr><td style="text-align:center">$\theta$</td><td style="text-align:center"><code>\theta</code></td><td style="text-align:center">$\Theta$</td><td style="text-align:center"><code>\Theta</code></td></tr><tr><td style="text-align:center">$\vartheta$</td><td style="text-align:center"><code>\vartheta</code></td><td style="text-align:center">$\iota$</td><td style="text-align:center"><code>\iota</code></td></tr><tr><td style="text-align:center">$\pi$</td><td style="text-align:center"><code>\pi</code></td><td style="text-align:center">$\phi$</td><td style="text-align:center"><code>\phi</code></td></tr><tr><td style="text-align:center">$\Phi$</td><td style="text-align:center"><code>\Phi</code></td><td style="text-align:center">$\psi$</td><td style="text-align:center"><code>\psi</code></td></tr><tr><td style="text-align:center">$\Psi$</td><td style="text-align:center"><code>\Psi</code></td><td style="text-align:center">$\omega$</td><td style="text-align:center"><code>\omega</code></td></tr><tr><td style="text-align:center">$\Omega$</td><td style="text-align:center"><code>\Omega</code></td><td style="text-align:center">$\chi$</td><td style="text-align:center"><code>\chi</code></td></tr><tr><td style="text-align:center">$\rho$</td><td style="text-align:center"><code>\rho</code></td><td style="text-align:center">$\omicron$</td><td style="text-align:center"><code>\omicron</code></td></tr><tr><td style="text-align:center">$\sigma$</td><td style="text-align:center"><code>\sigma</code></td><td style="text-align:center">$\Sigma$</td><td style="text-align:center"><code>\Sigma</code></td></tr><tr><td style="text-align:center">$\nu$</td><td style="text-align:center"><code>\nu</code></td><td style="text-align:center">$\xi$</td><td style="text-align:center"><code>\xi</code></td></tr><tr><td style="text-align:center">$\tau$</td><td style="text-align:center"><code>\tau</code></td><td style="text-align:center">$\lambda$</td><td style="text-align:center"><code>\lambda</code></td></tr><tr><td style="text-align:center">$\Lambda$</td><td style="text-align:center"><code>\Lambda</code></td><td style="text-align:center">$\mu$</td><td style="text-align:center"><code>\mu</code></td></tr><tr><td style="text-align:center">$\partial$</td><td style="text-align:center"><code>\partial</code></td><td style="text-align:center">$\lbrace$</td><td style="text-align:center"><code>\lbrace</code></td></tr><tr><td style="text-align:center">$\rbrace$</td><td style="text-align:center"><code>\rbrace</code></td><td style="text-align:center">$\overline{a}$</td><td style="text-align:center"><code>\overline{a}</code></td></tr><tr><td style="text-align:center">$\frac{7x+5}{1+y^2}$</td><td style="text-align:center"><code>\frac{7x+5}{1+y^2}</code></td><td style="text-align:center">$\int ^2_3 x^2 {\rm d}x$</td><td style="text-align:center"><code>\int ^2_3 x^2 {\rm d}x</code></td></tr><tr><td style="text-align:center">$\sqrt[n]{3}$</td><td style="text-align:center"><code>\sqrt[n]{3}</code></td><td style="text-align:center">$\vec{a} \cdot \vec{b}=0$</td><td style="text-align:center"><code>\vec{a} \cdot \vec{b}=0</code></td></tr><tr><td style="text-align:center">$\iiint$</td><td style="text-align:center"><code>\iiint</code></td><td style="text-align:center">$\oint$</td><td style="text-align:center"><code>\oint</code></td></tr><tr><td style="text-align:center">$\lim$</td><td style="text-align:center"><code>\lim</code></td><td style="text-align:center">$\infty$</td><td style="text-align:center"><code>\infty</code></td></tr><tr><td style="text-align:center">$\partial$</td><td style="text-align:center"><code>\partial</code></td><td style="text-align:center">$\ln15$</td><td style="text-align:center"><code>\ln15</code></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">$\log_2^{10}$</td><td style="text-align:center"><code>\log_2^{10}</code></td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style=&quot;text-align:center&quot;&gt;符号&lt;/th&gt;&lt;th style=&quot;text-alig
      
    
    </summary>
    
      <category term="markdown" scheme="https://isjinhao.github.io/categories/markdown/"/>
    
    
      <category term="markdown" scheme="https://isjinhao.github.io/tags/markdown/"/>
    
      <category term="Latex" scheme="https://isjinhao.github.io/tags/Latex/"/>
    
  </entry>
  
  <entry>
    <title>02-语言及其文法</title>
    <link href="https://isjinhao.github.io/2019/02-%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95/"/>
    <id>https://isjinhao.github.io/2019/02-语言及其文法/</id>
    <published>2019-03-10T07:43:41.000Z</published>
    <updated>2019-03-17T06:43:42.405Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="字母表"><a href="#字母表" class="headerlink" title="字母表"></a>字母表</h2><p>字母表（$\sum​$）是一个有穷符号集合，符号包括字母、数字、标点符号、…。例如，二进制字母表：{0,1}、ASCII字符集，Unicode字符集等。</p><h3 id="字母表上的运算"><a href="#字母表上的运算" class="headerlink" title="字母表上的运算"></a>字母表上的运算</h3><ul><li>乘积运算：<ul><li>$\sum_{1} \sum_{2} = \lbrace{ab | a \in \sum_{1}, b \in \sum_{2} \rbrace}​$</li><li>例： $\lbrace0 , 1\rbrace \lbrace a, b \rbrace = \lbrace 0a, 0b, 1a, 1b \rbrace$</li></ul></li><li>幂运算<ul><li>字母表的n次幂：长度为n的符号串构成的集合</li><li>$\sum_{}^0 = \lbrace \varepsilon \rbrace​$</li><li>$\sum_{}^n = \sum_{}^{n-1}\sum_{} n \geq 1$</li><li>${\lbrace 0, 1 \rbrace}^3 = \lbrace0, 1\rbrace \lbrace0, 1\rbrace \lbrace0, 1\rbrace = \lbrace000, 001, 010, 011, 100, 101, 110, 111\rbrace$</li></ul></li><li>正闭包运算<ul><li>字母表的正闭包：长度正数的符号串构成的集合</li><li>$\sum_{}^+ = \sum_{}^1 \bigcup \sum_{}^2 \bigcup \sum_{}^3 \bigcup \cdots​$</li></ul></li><li>克林闭包运算<ul><li>字母表的克林闭包：任意符号串（长度可以为零）构成的集合</li><li>$\sum_{}^* = \sum_{}^0 \bigcup \sum_{}^1 \bigcup \sum_{}^2 \bigcup \sum_{}^3 \bigcup \cdots$</li></ul></li></ul><h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><p>设$\sum_{}​$是一个字母表，$\forall x \in \sum_{}^*​$，$x​$称为是$\sum_{}​$上的一个串。</p><ul><li>串是字母表中符号的一个有穷序列。</li><li>串$s$的长度，通常记作$|s|$，是指$s$中符号的个数。例：$|aab|$=3。</li><li>空串是长度为0的串，用 $ \varepsilon$表示$|\varepsilon|= 0$</li></ul><h3 id="串上的运算"><a href="#串上的运算" class="headerlink" title="串上的运算"></a>串上的运算</h3><ul><li>连接<ul><li>如果$x$和$y$是串，那么$x$和$y$的连接（concatenation）是把$y$附加到$x$后面而形成的串，记作$xy$。<br>例如，如果$x=dog$且$y=house$，那么$xy=doghouse$</li><li>空串是连接运算的单位元（identity），即，对于任何串$s$都有，$εs = sε = s$。设$x$, $y$, $z$是三个字符串，如果$x=yz$，则称$y$是$x$的前缀，$z$是$x​$的后缀。</li></ul></li><li>幂<ul><li>串s的n次幂：将$n$个$s$连接起来</li><li>$s^0 = \varepsilon$，</li><li>$s^n = s^{n-1}s, n \geq 1​$</li><li>如果 $s = ba$，那么$s^1= ba$，$s^2=baba$，$s^3=bababa$，…</li></ul></li></ul><h2 id="文法的定义"><a href="#文法的定义" class="headerlink" title="文法的定义"></a>文法的定义</h2><h3 id="文法的直观概念"><a href="#文法的直观概念" class="headerlink" title="文法的直观概念"></a>文法的直观概念</h3><p>当人们表述一门语言时，无非是说明这种语言的句子，如果语言只含有有穷多个句子，则只需要列出句子的有穷集就行。但对于含有无穷多个句子的语言来讲，采用的做法是给出一些规则，符合规则的句子是语言的一个句子。我们以简化版的汉语（句子的结构只有主谓结构）规则来说明：</p><div align="center"><img src="/2019/02-语言及其文法/简易汉语文法.jpg"></div><p>其中用尖括号括起来的部分称为<strong>语法成分</strong>，未用尖括号括起来的部分称为<strong>语言的基本符号</strong>。</p><h3 id="文法的形式化定义"><a href="#文法的形式化定义" class="headerlink" title="文法的形式化定义"></a>文法的形式化定义</h3><p>定义：$G=(V_{T}, V_{N}, P, S)$，</p><ul><li>$V_{T}$：终结符集合。文法所定义的语言的基本符号，也称为token。终结是指其不能再被改变。</li><li>$V_{N}​$：非终结符集合。用来表示语法成分的符号，也称为”语法变量“。非终结指可以由他们推导出句子。<ul><li>$V_{T} \bigcap V_{N} = \phi​$。</li><li>$V_{T}\bigcup V_{N}$：文法符号集。</li></ul></li><li>P：产生式集合：描述了将终结符和非终结符组合成串的方法，产生式的一般形式：$\alpha \rightarrow \beta​$。<ul><li>$α∈(V_T∪V_N)^*​$，且$\alpha​$中至少包含$V_N​$中的一个元素。称为产生式的头（head）或左部（left side）。</li><li>${\beta \in (V_T \bigcup V_N)}^*​$，称为产生式的体（body）或右部（right side）。</li></ul></li><li>S：开始符号。$S\in V_N​$。开始符号（start symbol）表示的是该文法中最大的语法成分。例：$S = &lt;句子&gt;​$</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>$G = ( \lbrace id, +, *, (, ) \rbrace, \lbrace E \rbrace, P, E )$ &nbsp; $P =\lbrace E \rightarrow E + E , E \rightarrow E \ast E, E \rightarrow ( E ), E \rightarrow id \rbrace $</p><h4 id="产生式的简写"><a href="#产生式的简写" class="headerlink" title="产生式的简写"></a>产生式的简写</h4><p>对一组有相同左部的 $\alpha$ 产生式$\alpha \rightarrow \beta_1,\alpha \rightarrow \beta_2 , … , \alpha \rightarrow \beta_n$。可以简记为：$\alpha \rightarrow \beta_1 | \beta_2 | , … , | \beta_n​$。</p><h4 id="符号约定"><a href="#符号约定" class="headerlink" title="符号约定"></a>符号约定</h4><ul><li>终结符：<ul><li>字母表中排在前面的小写字母，如 a、b、c；</li><li>运算符，如 +、*等；</li><li>标点符号，如括号、逗号等；</li><li>数字0、1、. . . 、9；</li><li>粗体字符串，如<strong>id</strong>、<strong>if</strong>等；</li></ul></li><li><p>非终结符：</p><ul><li>字母表中排在前面的大写字母，如A、B、 C；</li><li>字母S。通常表示开始符号；</li><li>小写、斜体的名字，如 <em>expr</em>、<em>stmt</em>等；</li><li>代表程序构造的大写字母。如E（表达式）、T（项）和F（因子）；</li></ul></li><li><p>文法符号（即终结符或非终结符）：</p><ul><li>字母表中排在后面的大写字母（如X、Y、Z）</li></ul></li><li><p>终结符号串：</p><ul><li>字母表中排在后面的小写字母（主要是u、v、. . . 、z）。包括空串。</li></ul></li><li><p>文法符号串：</p><ul><li>小写希腊字母，如α、β、γ，表示。包括空串。</li></ul></li><li><p>开始符号：</p><ul><li>除非特别说明，第一个产生式的左部。</li></ul><div align="center"><img src="/2019/02-语言及其文法/符号约定.jpg"></div></li></ul><h2 id="语言的定义"><a href="#语言的定义" class="headerlink" title="语言的定义"></a>语言的定义</h2><h3 id="推导-（Derivations）"><a href="#推导-（Derivations）" class="headerlink" title="推导 （Derivations）"></a>推导 （Derivations）</h3><ul><li>给定文法$G=(V_T , V_N , P , S )$，如果 $\alpha→\beta \in P$，那么可以将符号串$\gamma \alpha \delta$中的$ \alpha$替换为$\beta$，也就是说，将$\gamma \alpha \delta$重写为$\gamma \beta \delta$，记作 $\gamma \alpha \delta \Rightarrow \gamma \beta \delta$γ。此时，称文法中的符号串 $\gamma \alpha \delta$ 直接推导（directly derive）出$\gamma \beta \delta$。简而言之，就是用产生式的右部替换产生式的左部。</li><li>如果$\alpha_0 \Rightarrow \alpha_1, \alpha_1 \Rightarrow \alpha_2, \cdots, \alpha_{n-1} \Rightarrow \alpha_{n}​$。则称符号串$\alpha_0​$经过$n​$步推导出$\alpha_n​$，可简记为$\alpha_0 \Rightarrow^n \alpha_n​$。<ul><li>$\alpha \Rightarrow^0 \alpha$；</li><li>$\Rightarrow^+​$表示“经过正数步推导”；</li><li>$\Rightarrow^*$表示“经过若干（可以是0）步推导。</li></ul></li></ul><h3 id="归约（Reductions）"><a href="#归约（Reductions）" class="headerlink" title="归约（Reductions）"></a>归约（Reductions）</h3><p>规约是推导的逆过程。</p><h3 id="句型"><a href="#句型" class="headerlink" title="句型"></a>句型</h3><ul><li><p>如果$S \Rightarrow^\ast \alpha $，$ \alpha \in (V_T \bigcup V_N)^\ast $，则称$ \alpha $是G的一个句型（sentential form）。</p><ul><li>一个句型中既可以包含终结符，又可以包含非终结符，也可能是空串。</li></ul></li><li><p>如果$S \Rightarrow^\ast \omega $，$\omega \in V_T\ast$，则称$ \omega $ 是G的一个句子（sentence）。</p><ul><li>句子是不包含非终结符的句型。</li></ul><div align="center"><img src="/2019/02-语言及其文法/句型句子举例.jpg"></div></li></ul><h3 id="语言的形式化定义"><a href="#语言的形式化定义" class="headerlink" title="语言的形式化定义"></a>语言的形式化定义</h3><p>由文法$G$的开始符号$S$推导出的所有句子构成的集合称为文法$G$生成的语言，记为$L(G )$。即：$L(G)= \lbrace \omega \Rightarrow^\ast \omega \rbrace, \omega \in {V_T}^\ast$。</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><ul><li>字母数字串的文法（T）：<ol><li>$T \rightarrow L | D | TL | TD​$</li><li>$L \rightarrow a | b | c | \cdots | z​$</li><li>$ D \rightarrow 0 | 1 | 2 | 3 | \cdots | 9​$</li></ol></li><li><p>标识符的文法（S）：和T区别的是S必须以字母或_开头。</p><ol><li>$ S \rightarrow L | LT​$</li><li>$T \rightarrow L | D | TL | TD​$</li><li>$ L \rightarrow a \mid b \mid c \mid \cdots \mid z \mid _ ​$</li><li>$ D \rightarrow 0 | 1 | 2 | 3 | \cdots | 9​$</li></ol></li><li><p>无符号整数（S）：</p><ol><li>$S \rightarrow SN ​$</li><li>$S\rightarrow \varepsilon​$</li><li>$N \rightarrow 0|1|\cdots|9​$</li></ol></li><li>浮点数（T）：<ol><li>$S \rightarrow STN | SN $</li><li>$S\rightarrow \varepsilon​$</li><li>$ T \rightarrow .$</li><li>$N \rightarrow 0|1|\cdots|9​$</li></ol></li></ul><h3 id="语言上的运算"><a href="#语言上的运算" class="headerlink" title="语言上的运算"></a>语言上的运算</h3><div align="center"><img src="/2019/02-语言及其文法/语言上的运算.jpg"></div><p>例：令$L=\lbrace A, B, \cdots Z, a, b, \cdots, z\rbrace$，$D=\lbrace 0, 1, \cdots, 9\rbrace$。则$L(L\bigcap D)^*$表示的语言是标识符。</p><h2 id="文法的分类"><a href="#文法的分类" class="headerlink" title="文法的分类"></a>文法的分类</h2><p>Chomsky（形式语言的建立者）把文法分成四类，0型、1型、2型和3型。区别在于在不同文法的产生式上施加的限制不同。</p><h3 id="0型文法"><a href="#0型文法" class="headerlink" title="0型文法"></a>0型文法</h3><p>被叫做，无限制文法（Unrestricted Grammar）或 短语结构文法（Phrase Structure Grammar, PSG）。</p><ol><li>$\forall α \rightarrow \beta \in P​$，$\alpha, \beta \in {(V_N \bigcup V_T)}^\ast​$，且$\alpha​$中至少包含1个非终结符（即$\mid \alpha \mid \geq 1​$）。</li></ol><h3 id="1型文法"><a href="#1型文法" class="headerlink" title="1型文法"></a>1型文法</h3><p>被叫做，上下文有关文法（Context-Sensitive Grammar , CSG）。</p><ol><li>$\forall \alpha \rightarrow \beta \in P，\mid \alpha \mid \leq \mid \beta \mid ​$。</li><li>产生式的一般形式：$ \alpha_1 A \alpha_2 \rightarrow \alpha_1 \beta \alpha_2$ （$ \alpha_1, \alpha_2, \beta \in (V_N \bigcup V_T)^\ast$且$\beta \ne \varepsilon$）。</li><li>和0型文法相比，0型文法要求$\mid \alpha \mid \geq 1​$，1型文法要求$1 \leq \mid \alpha \mid \leq \mid \beta \mid ​$。</li></ol><h3 id="2型文法"><a href="#2型文法" class="headerlink" title="2型文法"></a>2型文法</h3><p>被叫做，上下文无关文法（Context-Free Grammar, CFG）</p><ol><li>$\forall \alpha \rightarrow \beta \in P$ （$\alpha \in V_N, \beta \in {(V_N \bigcup V_T)}^\ast$）。</li><li>产生式的一般形式：$A \rightarrow \beta$。</li><li>和1型文法相比，当1型文法的$\alpha_1, \alpha_2 \rightarrow \varepsilon$且$ \alpha $只属于非终结符集时，就是2型文法。</li></ol><h3 id="3型文法"><a href="#3型文法" class="headerlink" title="3型文法"></a>3型文法</h3><p>被叫做，正则文法（Regular Grammar, RG），分为右线性文法和左线性文法。</p><ol><li>右线性（Right Linear）文法： $A \rightarrow a B$ 或 $A \rightarrow a $（$a \in {V_T}^ \ast$）</li><li>左线性（Left Linear）文法： $A \rightarrow B a $ 或 $A \rightarrow a $（$a \in {V_T}^ \ast$）</li><li>和2型文法相比，3型文法右侧形式必须是<code>非终结符+终结符</code>、<code>终结符+非终结符</code>、<code>终结符</code>三种之一。</li></ol><h3 id="三种文法的区别"><a href="#三种文法的区别" class="headerlink" title="三种文法的区别"></a>三种文法的区别</h3><p>参考：<a href="https://blog.csdn.net/cjsy_2011/article/details/32412967。" target="_blank" rel="noopener">https://blog.csdn.net/cjsy_2011/article/details/32412967。</a></p><h4 id="1型文法-1"><a href="#1型文法-1" class="headerlink" title="1型文法"></a>1型文法</h4><ul><li>式子左边可以有多个字符，但必须有一个终结符</li><li>式子右边可以有多个字符，可以是终结符，也可以是非终结符，但必须是有限个字符</li></ul><h4 id="2型文法-1"><a href="#2型文法-1" class="headerlink" title="2型文法"></a>2型文法</h4><ul><li>式子左边只能有一个字符，而且必须是非终结符</li><li>式子右边可以有多个字符，可以是终结符，也可以是非终结符，8但必须是有限个字符</li></ul><h4 id="3型文法-1"><a href="#3型文法-1" class="headerlink" title="3型文法"></a>3型文法</h4><ul><li><p>式子左边只能有一个字符，而且必须是非终结符</p></li><li><p>式子右边最多有二个字符，而且如果有二个字符必须是一个终结符和一个非终结符，如果只有一个字符，那么必须是终结符</p><ul><li>左线性文法：式子右边的产生是（非终结符+终结符）的格式</li><li>右线型文法：式子右边的产生式是（终结符+非终结符）的格式</li></ul></li><li><p>式子右边的格式一定要一致，也就是说如果有一个是（终结符+非终结符）那么所有的式子都必须是（终结符+非终结符）。如果有一个是（非终结符+终结符），那么所有的式子都必须是（非终结符+终结符）</p></li></ul><h3 id="右线性文法、左线性文法举例"><a href="#右线性文法、左线性文法举例" class="headerlink" title="右线性文法、左线性文法举例"></a>右线性文法、左线性文法举例</h3><h4 id="右线性文法"><a href="#右线性文法" class="headerlink" title="右线性文法"></a>右线性文法</h4><ul><li>S → a | b | c | d</li><li>S → aT | bT | cT | dT</li><li>T → a | b | c | d | 0 | 1 | 2 | 3 | 4 | 5</li><li>T → aT | bT | cT | dT | 0T | 1T | 2T | 3T | 4T | 5T</li></ul><h4 id="左线性文法"><a href="#左线性文法" class="headerlink" title="左线性文法"></a>左线性文法</h4><ul><li>R → Ra | Rb | Rc | Rd | R0 | R1 | R2 | R3 | R4 | R5</li><li>R → a | b | c | d</li></ul><p>文法S和R都是标识符。</p><h2 id="CFG-的分析树"><a href="#CFG-的分析树" class="headerlink" title="CFG 的分析树"></a>CFG 的分析树</h2><p>上下文无关文法有足够的能力描述当今程序设计语言结构，所以以下分析CFG的分析树。</p><ul><li>根节点的标号为文法开始符号。</li><li>内部结点表示对一个产生式A→β的应用，该结点的标号是此产生式左部A 。该结点的子结点的标号从左到右构成了产生式的右部β。</li><li>叶结点的标号既可以是非终结符，也可以是终结符。从左到右排列叶节点得到的符号串称为是这棵树的产出（ yield）或边缘（frontier）。</li></ul><div align="center"><img src="/2019/02-语言及其文法/CFG语法树.jpg"></div><h3 id="句型的）短语"><a href="#句型的）短语" class="headerlink" title="(句型的）短语"></a>(句型的）短语</h3><p>给定一个句型，其分析树中的每一棵子树的边缘称为该句型的一个短语（phrase）。如果子树只有父子两代结点，那么这棵子树的边缘称为该句型的一个直接短语（immediate phrase）。</p><div align="center"><img src="/2019/02-语言及其文法/短语.jpg"></div><h3 id="二义性文法"><a href="#二义性文法" class="headerlink" title="二义性文法"></a>二义性文法</h3><p>如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的。</p><div align="center"><img src="/2019/02-语言及其文法/二义性文法.jpg"></div><h4 id="二义性文法的判定"><a href="#二义性文法的判定" class="headerlink" title="二义性文法的判定"></a>二义性文法的判定</h4><p>对于任意一个上下文无关文法，不存在一个算法，判定它是无二义性的；但能给出一组充分条件，满足这组充分条件的文法是无二义性的。</p><ul><li>满足，肯定无二义性</li><li>不满足，也未必就是有二义性的</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;字母表&quot;&gt;&lt;a href=&quot;#字母表&quot; class=&quot;headerlink&quot; title=&quot;字母表&quot;&gt;&lt;/a&gt;字母表&lt;/h2&gt;&lt;p&gt;字
      
    
    </summary>
    
      <category term="编译原理" scheme="https://isjinhao.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="https://isjinhao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>01-编译原理绪论</title>
    <link href="https://isjinhao.github.io/2019/01-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/"/>
    <id>https://isjinhao.github.io/2019/01-编译原理绪论/</id>
    <published>2019-03-10T05:15:23.000Z</published>
    <updated>2019-03-10T07:42:28.648Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="计算机程序设计语言及编译"><a href="#计算机程序设计语言及编译" class="headerlink" title="计算机程序设计语言及编译"></a>计算机程序设计语言及编译</h2><h3 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h3><ul><li>可以被计算机直接理解，如：<code>C706 0000 0002</code>（16进制）。</li><li>与人类表达习惯相去甚远、难记忆、难编写、难阅读、易写错。</li></ul><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ul><li>引入助记符，如<code>MOV X, 2</code>。</li><li>依赖于特定机器，非计算机专业人员使用受限制、编写效率依然很低。</li></ul><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ul><li>类似于数学定义或自然语言的简洁形式，如<code>x = 2</code>。</li><li>接近人类表达习惯、不依赖于特定机器、编写效率高。</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>将高级语言翻译成汇编语言或机器语言的过程。</p><div align="center"><img src="/2019/01-编译原理绪论/编译.jpg"></div><h2 id="编译器在语言处理系统中的位置"><a href="#编译器在语言处理系统中的位置" class="headerlink" title="编译器在语言处理系统中的位置"></a>编译器在语言处理系统中的位置</h2><div align="center"><img src="/2019/01-编译原理绪论/编译器在语言处理系统中的位置.jpg"></div><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><ul><li>把存储在不同文件中的源程序聚合在一起。</li><li>把被称为宏的缩写语句转换为原始语句。</li></ul><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><ul><li>将多个可重定位的机器代码文件（包括库文件）连接到一起。</li><li>解决外部内存地址（一个文件中的代码会引用其他文件中的数据对象或过程，这些数据对象或过程的地址对于此文件来说就是外部地址）问题。</li></ul><h3 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h3><p>确定程序在内中的绝对地址（即修改程序起始地址），将修改后的指令和数据放到内存中适当的位置。</p><h2 id="编译系统的结构"><a href="#编译系统的结构" class="headerlink" title="编译系统的结构"></a>编译系统的结构</h2><div align="center"><img src="/2019/01-编译原理绪论/编译器的结构.jpg"></div><h2 id="词法分析-扫描-Scanning"><a href="#词法分析-扫描-Scanning" class="headerlink" title="词法分析/扫描(Scanning)"></a>词法分析/扫描(Scanning)</h2><p>从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词转换成统一的机内表示，即词法单元（token）形式。token格式：&lt; 种别码, 属性值&gt;</p><div align="center"><img src="/2019/01-编译原理绪论/token.jpg"></div><ul><li>一词一码：可以枚举的单词，比如关键字和运算符。使用token的种别码确定。</li><li>多词一码：不能枚举的单词，比如变量名，使用token的种别码标识出是变量，属性值标识变量名称。</li><li>一型一码：不能枚举但能被分类的单词，比如数据类型和运算符类别，使用token的种别码标识类型，属性值标识值。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><div align="center"><img src="/2019/01-编译原理绪论/词法分析举例.jpg"></div><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>语法分析器（parser）从词法分析器输出的token序列中识别出各类短语，并构造语法分析树（parse tree）。语法分析树描述了句子的语法结构。</p><h3 id="赋值语句分析树"><a href="#赋值语句分析树" class="headerlink" title="赋值语句分析树"></a>赋值语句分析树</h3><div align="center"><img src="/2019/01-编译原理绪论/赋值语句分析树.jpg"></div><h3 id="变量声明语句的分析树"><a href="#变量声明语句的分析树" class="headerlink" title="变量声明语句的分析树"></a>变量声明语句的分析树</h3><div align="center"><img src="/2019/01-编译原理绪论/变量声明语句分析树.jpg"></div><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><h3 id="收集标识符的属性信息："><a href="#收集标识符的属性信息：" class="headerlink" title="收集标识符的属性信息："></a>收集标识符的属性信息：</h3><ul><li><p>种属：</p><ul><li>简单变量、复合变量（数组，记录…）、过程、…</li></ul></li><li><p>类型：</p><ul><li>整型、实型（浮点型）、字符型、布尔型、指针型、…</li></ul></li><li><p>存储位置、长度：</p><div align="center"><img src="/2019/01-编译原理绪论/存储位置长度.jpg"></div></li><li><p>变量的值</p></li><li><p>过程的作用域</p></li><li><p>过程的参数和返回值信息</p></li></ul><h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><div align="center"><img src="/2019/01-编译原理绪论/符号表.jpg"></div><p>字符串表的作用：高级语言中一般不限制标识符长度，故name字段的长度不便预先固定，将标识符的字面值单独放在字符串表中，其位置索引放在name字段中，可保证name长度固定，由此带来存储效率高，查询方便等优点。此外，在语义分析中标识符的值很少被使用，这样就只用读取标识符的id，不用频繁读取标识符本身。</p><h3 id="语义检查"><a href="#语义检查" class="headerlink" title="语义检查"></a>语义检查</h3><ul><li>变量或过程未经声明就使用</li><li>变量或过程名重复声明</li><li>运算分量类型不匹配，如String类型 + int类型</li><li>操作符与操作数之间的类型不匹配<ul><li>数组下标不是整数</li><li>对非数组变量使用数组访问操作符</li><li>对非过程名使用过程调用操作符</li><li>过程调用的参数类型或数目不匹配</li><li>函数返回类型有误</li></ul></li></ul><h2 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h2><p>常见的中间表示形式</p><ul><li><p>语法结构树/语法树 (Syntax Trees)</p><p>注意不是语法分析树，第八章介绍…</p></li><li><p>三地址码 (Three-address Code)</p><p>三地址码由类似于汇编语言的指令序列组成，每个指令最多有三个操作数(operand)。</p></li></ul><h3 id="常用的三地址指令"><a href="#常用的三地址指令" class="headerlink" title="常用的三地址指令"></a>常用的三地址指令</h3><div align="center"><img src="/2019/01-编译原理绪论/常用的三地址指令.jpg"></div><h3 id="三地址指令的表示"><a href="#三地址指令的表示" class="headerlink" title="三地址指令的表示"></a>三地址指令的表示</h3><ul><li>四元式 (Quadruples)：(op, y, z, x)</li></ul><div align="center"><img src="/2019/01-编译原理绪论/常用三地址指令的四元式表示.jpg"></div><ul><li><p>三元式 (Triples)</p><p>以后再说…</p></li><li><p>间接三元式 (Indirect triples)</p><p>以后再说…</p></li></ul><h3 id="中间代码生成的例子"><a href="#中间代码生成的例子" class="headerlink" title="中间代码生成的例子"></a>中间代码生成的例子</h3><div align="center"><img src="/2019/01-编译原理绪论/中间代码生成的例子.jpg"></div><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>为改进代码所进行的等价程序变换，使其运行得更快一些、占用空间更少一些，或者二者兼顾。</p><h2 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h2><p>目标代码生成以源程序的中间表示形式作为输入，并把它映射到目标语言目标代码生成的一个重要任务是为程序中使用的变量合理分配。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;计算机程序设计语言及编译&quot;&gt;&lt;a href=&quot;#计算机程序设计语言及编译&quot; class=&quot;headerlink&quot; title=&quot;计算机
      
    
    </summary>
    
      <category term="编译原理" scheme="https://isjinhao.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="https://isjinhao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>01-Spring入门</title>
    <link href="https://isjinhao.github.io/2019/01-Spring%E5%85%A5%E9%97%A8/"/>
    <id>https://isjinhao.github.io/2019/01-Spring入门/</id>
    <published>2019-02-12T09:48:33.843Z</published>
    <updated>2019-03-11T11:50:59.449Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="Spring-概述（00）"><a href="#Spring-概述（00）" class="headerlink" title="Spring - 概述（00）"></a>Spring - 概述（00）</h2><h3 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h3><p>Spring是一个一站式框架。它为Java EE开发的三层架构中每一层都提供了解决方案</p><ul><li>Web层：Spring MVC；</li><li>Service层：Spring的Bean管理，Spring声明式事务；</li><li>DAO层：Spring的JDBC模板，Spring的ORM模块。（后期会用Mybatis替换Spring的DAO层）</li></ul><h3 id="Spring下载"><a href="#Spring下载" class="headerlink" title="Spring下载"></a>Spring下载</h3><ul><li>Spring现在是在github上托管的开源项目：<a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">地址</a>。</li><li>Spring各版本下载：<a href="https://repo.spring.io/libs-release-local/org/springframework/spring/" target="_blank" rel="noopener">地址</a>。</li></ul><h3 id="Spring环境搭建"><a href="#Spring环境搭建" class="headerlink" title="Spring环境搭建"></a>Spring环境搭建</h3><p>我的Spring文集中使用的是Spring 4.2版本，下方这张图是Spring官方给的架构图，想运行Spring项目，必须得导入<code>Core Container</code>中的包，但是也需要日志包。</p><div align="center"><img src="/2019/01-Spring入门/图解.png"><div><br><div align="center"><img src="/2019/01-Spring入门/基础包.jpg"><div><br><br><br>## Spring初体验<br><br><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"UserService执行了..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring的入门的配置==================== --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.isjinhao.Demo1.UserDaoImpl"</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传统方法的获得UserDao对象</span></span><br><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">UserDao dao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">dao.save();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Spring获得UserDao对象</span></span><br><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">UserDao bean = (UserDao)applicationContext.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">bean.save();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>开发的一个规则是在后期维护的时候少修改源代码。如果没有Spring我们更换UserDao的实现类，比如更换为<code>UserMybatisDaoImpl</code>，我们在源代码中就要改为<code>UserDao dao = new UserMybatisDaoImpl();</code>。但有了Spring之后就只需要修改配置文件中的class为<code>xxx.UserMybatisDaoImpl</code>，被Spring管理的类叫做bean。<br><br><br><br>## DI（Dependency Injection）<br><br>### 依赖关系<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class A&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Class B&#123;</span><br><span class="line">    A a;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xxx</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>如果在类B中使用到了类A，就说类B依赖类A，上图就是其中一种情况。<br><br>### Spring解决依赖<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"UserService执行了..."</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring的入门的配置==================== --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.isjinhao.Demo1.UserDaoImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"isjinhao"</span> /&gt;</span> //name的值和属性名称相同</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过Spring获得UserDao对象</span></span><br><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">UserDao dao = (UserDao)applicationContext.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">dao.save();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>所谓解决依赖，就是在使用时给其设置一个被依赖的对象，如果不使用Spring，设置name的值需要把dao转换为UserDaoImpl，再使用setName()方法，但是用了Spring我们就能在配置文件中设置，Spring帮我们完成设置。此时就叫做依赖注入。<br><br><br>## ApplicationContext继承体系<br><div align="center"><img src="/2019/01-Spring入门/applicationcontext继承体系.png"></div><h2 id="bean配置"><a href="#bean配置" class="headerlink" title="bean配置"></a>bean配置</h2><h3 id="id-amp-name"><a href="#id-amp-name" class="headerlink" title="id &amp; name"></a>id &amp; name</h3><p>name和id的功能类似，作用如图：</p><div align="center"><img src="/2019/01-Spring入门/id&name.png"></div><p>从语法上说name属性可以不唯一，而id必须唯一，但是实际使用时name标签和id标签通常都标识唯一值，而且优先使用name。</p><h3 id="初始化时执行的方法-amp-销毁的时候执行的方法"><a href="#初始化时执行的方法-amp-销毁的时候执行的方法" class="headerlink" title="初始化时执行的方法 &amp; 销毁的时候执行的方法"></a>初始化时执行的方法 &amp; 销毁的时候执行的方法</h3><ul><li>init-method=””：指定的方法在bean被创建时执行。</li><li>destroy-method=””：指定的方法在bean被销毁时创建的，但要求bean是单例的且手动关闭工厂。</li></ul><h3 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h3><p>bean标签有一个属性scope=””，可以设置bean的作用范围，五种值如下：</p><ul><li>singleton ：<strong>默认的</strong>，Spring会采用单例模式创建这个对象。</li><li>prototype ：多例模式。</li><li>request ：应用在web项目中，Spring创建这个类以后，将这个类存入到request范围中。</li><li>session ：应用在web项目中，Spring创建这个类以后，将这个类存入到session范围中。</li><li>globalsession ：应用在web项目中，必须在porlet环境下使用。但是如果没有这种环境，相当于session。（笔者不懂，抄过来的…）</li></ul></div></div></div></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Spring-概述（00）&quot;&gt;&lt;a href=&quot;#Spring-概述（00）&quot; class=&quot;headerlink&quot; title=&quot;S
      
    
    </summary>
    
      <category term="SSM" scheme="https://isjinhao.github.io/categories/SSM/"/>
    
    
      <category term="SSM" scheme="https://isjinhao.github.io/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>04-单表DQL</title>
    <link href="https://isjinhao.github.io/2019/04-%E5%8D%95%E8%A1%A8DQL/"/>
    <id>https://isjinhao.github.io/2019/04-单表DQL/</id>
    <published>2019-02-06T07:14:05.180Z</published>
    <updated>2019-02-07T01:16:44.415Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">pid <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">pname <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">price <span class="keyword">double</span>,</span><br><span class="line">category_id <span class="built_in">varchar</span>(<span class="number">32</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'联想'</span>,<span class="number">5000</span>,<span class="string">'c001'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">'海尔'</span>,<span class="number">3000</span>,<span class="string">'c001'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">'雷神'</span>,<span class="number">5000</span>,<span class="string">'c001'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">'JACK JONES'</span>,<span class="number">800</span>,<span class="string">'c002'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">'真维斯'</span>,<span class="number">200</span>,<span class="string">'c002'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">'花花公子'</span>,<span class="number">440</span>,<span class="string">'c002'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">7</span>,<span class="string">'劲霸'</span>,<span class="number">2000</span>,<span class="string">'c002'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">8</span>,<span class="string">'香奈儿'</span>,<span class="number">800</span>,<span class="string">'c003'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">9</span>,<span class="string">'相宜本草'</span>,<span class="number">200</span>,<span class="string">'c003'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">10</span>,<span class="string">'面霸'</span>,<span class="number">5</span>,<span class="string">'c003'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">11</span>,<span class="string">'好想你枣'</span>,<span class="number">56</span>,<span class="string">'c004'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">12</span>,<span class="string">'香飘飘奶茶'</span>,<span class="number">1</span>,<span class="string">'c005'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">13</span>,<span class="string">'果9'</span>,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><ul><li>查询表的所有字段信息：<code>select * from 表名;</code></li><li>查询表中某字段信息：<code>select 字段1, 字段2 from 表名;</code></li><li>去掉重复值：<code>select distinct 字段1, 字段2, ... from 表名;</code><ul><li>若有多个字段则所有字段相等才被算为重复值。</li></ul></li><li>查询结果是表达式（运算查询）：将商品的价格+10元进行显示，<code>select pname,price+10 from product;</code></li><li>别名查询，使用的关键字是as（as可以省略的）：<ul><li>表别名：<code>select * from product as p;</code></li><li>列别名：<code>select pname as pn from product;</code></li></ul></li></ul><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">&gt; &lt; &lt;= &gt;= = &lt;&gt;!=</td><td style="text-align:center">大于、小于、大于(小于)等于、不等于</td></tr><tr><td style="text-align:center">BETWEEN …AND…</td><td style="text-align:center">显示在某一区间的值(含头含尾)(也可以是日期)</td></tr><tr><td style="text-align:center">IN(set)</td><td style="text-align:center">显示在in列表中的值，例：<code>in(100,200)</code></td></tr><tr><td style="text-align:center">LIKE ‘张%’</td><td style="text-align:center">%代表零个或多个任意字符，_代表一个字符。例如：<code>first_name like ‘_a%’</code></td></tr><tr><td style="text-align:center">IS NULL / IS NOT NULL</td><td style="text-align:center">判断为空/不为空</td></tr><tr><td style="text-align:center">and</td><td style="text-align:center">多个条件同时成立</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">多个条件任一成立</td></tr><tr><td style="text-align:center">not</td><td style="text-align:center">不成立，例：<code>where not(salary&gt;100);</code></td></tr></tbody></table><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><ul><li>查询商品名称为“花花公子”的商品所有信息：<code>SELECT * FROM product WHERE pname = &#39;花花公子&#39;</code></li><li>查询价格为800商品：<code>SELECT * FROM product WHERE price = 800</code></li><li>查询价格不是800的所有商品：<ul><li><code>SELECT * FROM product WHERE price != 800</code></li><li><code>SELECT * FROM product WHERE price &lt;&gt; 800</code></li><li><code>SELECT * FROM product WHERE NOT(price = 800)</code></li></ul></li><li>查询商品价格大于60元的所有商品信息：<code>SELECT * FROM product WHERE price &gt; 60;</code></li><li>查询商品价格在200到1000之间所有商品：<ul><li><code>SELECT * FROM product WHERE price &gt;= 200 AND price &lt;=1000;</code></li><li><code>SELECT * FROM product WHERE price BETWEEN 200 AND 1000;</code></li></ul></li><li>查询商品价格是200或800的所有商品：<ul><li><code>SELECT * FROM product WHERE price = 200 OR price = 800;</code></li><li><code>SELECT * FROM product WHERE price IN (200,800);</code></li></ul></li><li>查询含有’霸’字的所有商品：<code>SELECT * FROM product WHERE pname LIKE &#39;%霸%&#39;;</code></li><li>查询以’香’开头的所有商品：<code>SELECT * FROM product WHERE pname LIKE &#39;香%&#39;;</code></li><li>查询第二个字为’想’的所有商品：<code>SELECT * FROM product WHERE pname LIKE &#39;_想%&#39;;</code></li><li>查询没有分类的商品：<code>SELECT * FROM product WHERE category_id IS NULL;</code></li><li>查询有分类的商品：<code>SELECT * FROM prod quct WHERE category_id IS NOT NULL</code></li><li>查询所有价格大于2000的电脑商品或者价格大于1000的服装商品：<code>SELECT * FROM product WHERE (price &gt; 2000 AND category_id=&#39;c001&#39;) OR (price &gt;1000 AND category_id=&#39;c002&#39;);</code></li></ul><h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><h3 id="SELECT-FROM-表名-ORDER-BY-排序字段-ASC-DESC"><a href="#SELECT-FROM-表名-ORDER-BY-排序字段-ASC-DESC" class="headerlink" title="SELECT * FROM 表名 ORDER BY 排序字段 ASC|DESC;"></a><code>SELECT * FROM 表名 ORDER BY 排序字段 ASC|DESC;</code></h3><ul><li>ASC： 升序 (默认)</li><li>DESC：降序</li></ul><h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><ul><li>查询所有商品信息，使用价格排序(降序)：<br><code>SELECT * FROM product ORDER BY price DESC;</code></li><li>在价格排序(降序)的基础上，以分类排序(降序)：<br><code>SELECT * FROM product ORDER BY price DESC, category_id DESC;</code></li><li>显示商品的价格(去重复)，并排序(降序)：<br><code>SELECT DISTINCT price FROM product ORDER BY price DESC;</code></li></ul><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ul><li>SELECT不仅可以作用于字段，还可以作用于聚合函数。<ul><li>count(…)：统计指定列不为NULL的记录行数；</li><li>sum(…)：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；</li><li>max(…)：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；</li><li>min(…)：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</li><li>avg(…)：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；</li></ul></li><li>例：<ul><li>查询商品的总条数：<code>SELECT COUNT(*) FROM product;</code></li><li>查询价格大于200的商品总条数：<code>SELECT COUNT(*) FROM product WHERE price &gt; 200;</code></li><li>查询分类为’c001’的商品价格总和：<br><code>SELECT SUM(price) FROM product WHERE category_id = &#39;c001&#39;;</code></li><li>查询分类为’c002’商品的平均价格：<br><code>SELECT AVG(price) FROM product WHERE category_id = &#39;c002&#39;;</code></li><li>查询商品的最大价格和最小价格：<code>SELECT MAX(price),MIN(price) FROM product;</code></li></ul></li></ul><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul><li>分组查询是指使用group by字句对查询信息进行分组。<br>​ <code>SELECT 字段1, 字段2… FROM 表名 GROUP BY 分组字段 HAVING 分组条件;</code></li><li>HAVING：<br>分组操作中的having子语句，是用于在分组后对数据进行过滤的，作用类似于where条件。与where的区别:<ul><li>having是在分组后对数据进行过滤。where是在分组前对数据进行过滤。</li><li>having后面可以使用聚合函数过滤数据。where后面不可以使用聚合函数。</li></ul></li><li>例：<ul><li>统计各个分类商品的个数：<br><code>SELECT category_id ,COUNT(*) FROM product GROUP BY category_id;</code></li><li>统计各个分类商品的个数,且只显示个数大于1的信息：<br><code>SELECT category_id, COUNT(*) FROM product GROUP BY category_id HAVING COUNT(*) &gt; 1;</code></li></ul></li></ul><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>由于数据量很大，显示屏长度有限，因此对数据需要采取分页显示方式。例如数据共有30条，每页显示5条。</p><ul><li>格式：<br><code>SELECT 字段1，字段2... FROM 表明 LIMIT M, N;</code><ul><li>M: 整数，表示从第几条索引开始，计算方式 （当前页-1）*每页显示条数</li><li>N: 整数，表示查询多少条数据</li></ul></li><li>例：<ul><li><code>SELECT 字段1，字段2... FROM 表明 LIMIT 0,5;</code></li><li><code>SELECT 字段1，字段2... FROM 表明 LIMIT 5,5;</code></li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 17 2019 20:30:19 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;数据准备&quot;&gt;&lt;a href=&quot;#数据准备&quot; class=&quot;headerlink&quot; title=&quot;数据准备&quot;&gt;&lt;/a&gt;数据准备&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
