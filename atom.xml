<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ISJINHAO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://isjinhao.github.io/"/>
  <updated>2019-03-10T07:42:28.648Z</updated>
  <id>https://isjinhao.github.io/</id>
  
  <author>
    <name>ISJINHAO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>01-编译原理绪论</title>
    <link href="https://isjinhao.github.io/2019/01-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA/"/>
    <id>https://isjinhao.github.io/2019/01-编译原理绪论/</id>
    <published>2019-03-10T05:15:23.000Z</published>
    <updated>2019-03-10T07:42:28.648Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 10 2019 15:42:38 GMT+0800 (GMT+08:00) --><h2 id="计算机程序设计语言及编译"><a href="#计算机程序设计语言及编译" class="headerlink" title="计算机程序设计语言及编译"></a>计算机程序设计语言及编译</h2><h3 id="机器语言"><a href="#机器语言" class="headerlink" title="机器语言"></a>机器语言</h3><ul><li>可以被计算机直接理解，如：<code>C706 0000 0002</code>（16进制）。</li><li>与人类表达习惯相去甚远、难记忆、难编写、难阅读、易写错。</li></ul><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><ul><li>引入助记符，如<code>MOV X, 2</code>。</li><li>依赖于特定机器，非计算机专业人员使用受限制、编写效率依然很低。</li></ul><h3 id="高级语言"><a href="#高级语言" class="headerlink" title="高级语言"></a>高级语言</h3><ul><li>类似于数学定义或自然语言的简洁形式，如<code>x = 2</code>。</li><li>接近人类表达习惯、不依赖于特定机器、编写效率高。</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>将高级语言翻译成汇编语言或机器语言的过程。</p><div align="center"><img src="/2019/01-编译原理绪论/编译.jpg"></div><h2 id="编译器在语言处理系统中的位置"><a href="#编译器在语言处理系统中的位置" class="headerlink" title="编译器在语言处理系统中的位置"></a>编译器在语言处理系统中的位置</h2><div align="center"><img src="/2019/01-编译原理绪论/编译器在语言处理系统中的位置.jpg"></div><h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><ul><li>把存储在不同文件中的源程序聚合在一起。</li><li>把被称为宏的缩写语句转换为原始语句。</li></ul><h3 id="链接器"><a href="#链接器" class="headerlink" title="链接器"></a>链接器</h3><ul><li>将多个可重定位的机器代码文件（包括库文件）连接到一起。</li><li>解决外部内存地址（一个文件中的代码会引用其他文件中的数据对象或过程，这些数据对象或过程的地址对于此文件来说就是外部地址）问题。</li></ul><h3 id="加载器"><a href="#加载器" class="headerlink" title="加载器"></a>加载器</h3><p>确定程序在内中的绝对地址（即修改程序起始地址），将修改后的指令和数据放到内存中适当的位置。</p><h2 id="编译系统的结构"><a href="#编译系统的结构" class="headerlink" title="编译系统的结构"></a>编译系统的结构</h2><div align="center"><img src="/2019/01-编译原理绪论/编译器的结构.jpg"></div><h2 id="词法分析-扫描-Scanning"><a href="#词法分析-扫描-Scanning" class="headerlink" title="词法分析/扫描(Scanning)"></a>词法分析/扫描(Scanning)</h2><p>从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词转换成统一的机内表示，即词法单元（token）形式。token格式：&lt; 种别码, 属性值&gt;</p><div align="center"><img src="/2019/01-编译原理绪论/token.jpg"></div><ul><li>一词一码：可以枚举的单词，比如关键字和运算符。使用token的种别码确定。</li><li>多词一码：不能枚举的单词，比如变量名，使用token的种别码标识出是变量，属性值标识变量名称。</li><li>一型一码：不能枚举但能被分类的单词，比如数据类型和运算符类别，使用token的种别码标识类型，属性值标识值。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><div align="center"><img src="/2019/01-编译原理绪论/词法分析举例.jpg"></div><h2 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h2><p>语法分析器（parser）从词法分析器输出的token序列中识别出各类短语，并构造语法分析树（parse tree）。语法分析树描述了句子的语法结构。</p><h3 id="赋值语句分析树"><a href="#赋值语句分析树" class="headerlink" title="赋值语句分析树"></a>赋值语句分析树</h3><div align="center"><img src="/2019/01-编译原理绪论/赋值语句分析树.jpg"></div><h3 id="变量声明语句的分析树"><a href="#变量声明语句的分析树" class="headerlink" title="变量声明语句的分析树"></a>变量声明语句的分析树</h3><div align="center"><img src="/2019/01-编译原理绪论/变量声明语句分析树.jpg"></div><h2 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h2><h3 id="收集标识符的属性信息："><a href="#收集标识符的属性信息：" class="headerlink" title="收集标识符的属性信息："></a>收集标识符的属性信息：</h3><ul><li><p>种属：</p><ul><li>简单变量、复合变量（数组，记录…）、过程、…</li></ul></li><li><p>类型：</p><ul><li>整型、实型（浮点型）、字符型、布尔型、指针型、…</li></ul></li><li><p>存储位置、长度：</p><div align="center"><img src="/2019/01-编译原理绪论/存储位置长度.jpg"></div></li><li><p>变量的值</p></li><li><p>过程的作用域</p></li><li><p>过程的参数和返回值信息</p></li></ul><h4 id="符号表"><a href="#符号表" class="headerlink" title="符号表"></a>符号表</h4><div align="center"><img src="/2019/01-编译原理绪论/符号表.jpg"></div><p>字符串表的作用：高级语言中一般不限制标识符长度，故name字段的长度不便预先固定，将标识符的字面值单独放在字符串表中，其位置索引放在name字段中，可保证name长度固定，由此带来存储效率高，查询方便等优点。此外，在语义分析中标识符的值很少被使用，这样就只用读取标识符的id，不用频繁读取标识符本身。</p><h3 id="语义检查"><a href="#语义检查" class="headerlink" title="语义检查"></a>语义检查</h3><ul><li>变量或过程未经声明就使用</li><li>变量或过程名重复声明</li><li>运算分量类型不匹配，如String类型 + int类型</li><li>操作符与操作数之间的类型不匹配<ul><li>数组下标不是整数</li><li>对非数组变量使用数组访问操作符</li><li>对非过程名使用过程调用操作符</li><li>过程调用的参数类型或数目不匹配</li><li>函数返回类型有误</li></ul></li></ul><h2 id="中间代码生成"><a href="#中间代码生成" class="headerlink" title="中间代码生成"></a>中间代码生成</h2><p>常见的中间表示形式</p><ul><li><p>语法结构树/语法树 (Syntax Trees)</p><p>注意不是语法分析树，第八章介绍…</p></li><li><p>三地址码 (Three-address Code)</p><p>三地址码由类似于汇编语言的指令序列组成，每个指令最多有三个操作数(operand)。</p></li></ul><h3 id="常用的三地址指令"><a href="#常用的三地址指令" class="headerlink" title="常用的三地址指令"></a>常用的三地址指令</h3><div align="center"><img src="/2019/01-编译原理绪论/常用的三地址指令.jpg"></div><h3 id="三地址指令的表示"><a href="#三地址指令的表示" class="headerlink" title="三地址指令的表示"></a>三地址指令的表示</h3><ul><li>四元式 (Quadruples)：(op, y, z, x)</li></ul><div align="center"><img src="/2019/01-编译原理绪论/常用三地址指令的四元式表示.jpg"></div><ul><li><p>三元式 (Triples)</p><p>以后再说…</p></li><li><p>间接三元式 (Indirect triples)</p><p>以后再说…</p></li></ul><h3 id="中间代码生成的例子"><a href="#中间代码生成的例子" class="headerlink" title="中间代码生成的例子"></a>中间代码生成的例子</h3><div align="center"><img src="/2019/01-编译原理绪论/中间代码生成的例子.jpg"></div><h2 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h2><p>为改进代码所进行的等价程序变换，使其运行得更快一些、占用空间更少一些，或者二者兼顾。</p><h2 id="目标代码生成"><a href="#目标代码生成" class="headerlink" title="目标代码生成"></a>目标代码生成</h2><p>目标代码生成以源程序的中间表示形式作为输入，并把它映射到目标语言目标代码生成的一个重要任务是为程序中使用的变量合理分配。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 10 2019 15:42:38 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;计算机程序设计语言及编译&quot;&gt;&lt;a href=&quot;#计算机程序设计语言及编译&quot; class=&quot;headerlink&quot; title=&quot;计算机
      
    
    </summary>
    
      <category term="编译原理" scheme="https://isjinhao.github.io/categories/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="编译原理" scheme="https://isjinhao.github.io/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>01-Spring入门</title>
    <link href="https://isjinhao.github.io/2019/01-Spring%E5%85%A5%E9%97%A8/"/>
    <id>https://isjinhao.github.io/2019/01-Spring入门/</id>
    <published>2019-02-12T09:48:33.843Z</published>
    <updated>2019-03-02T12:24:02.517Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 10 2019 15:42:38 GMT+0800 (GMT+08:00) --><h2 id="Spring-概述（00）"><a href="#Spring-概述（00）" class="headerlink" title="Spring - 概述（00）"></a>Spring - 概述（00）</h2><h3 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h3><p>Spring是一个一站式框架。它为Java EE开发的三层架构中每一层都提供了解决方案</p><ul><li>Web层：Spring MVC；</li><li>Service层：Spring的Bean管理，Spring声明式事务；</li><li>DAO层：Spring的JDBC模板，Spring的ORM模块。（后期会用Mybatis替换Spring的DAO层）</li></ul><h3 id="Spring下载"><a href="#Spring下载" class="headerlink" title="Spring下载"></a>Spring下载</h3><ul><li>Spring现在是在github上托管的开源项目：<a href="https://github.com/spring-projects/spring-framework" target="_blank" rel="noopener">地址</a>。</li><li>Spring各版本下载：<a href="https://repo.spring.io/libs-release-local/org/springframework/spring/" target="_blank" rel="noopener">地址</a>。</li></ul><h3 id="Spring环境搭建"><a href="#Spring环境搭建" class="headerlink" title="Spring环境搭建"></a>Spring环境搭建</h3><p>我的Spring文集中使用的是Spring 4.2版本，下方这张图是Spring官方给的架构图，想运行Spring项目，必须得导入<code>Core Container</code>中的包，但是也需要日志包。</p><div align="center"><img src="/2019/01-Spring入门/图解.png"><div><br><div align="center"><img src="/2019/01-Spring入门/基础包.jpg"><div><br><br><br>## Spring初体验<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"UserService执行了..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring的入门的配置==================== --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.isjinhao.Demo1.UserDaoImpl"</span> &gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//传统方法的获得UserDao对象</span></span><br><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">UserDao dao = <span class="keyword">new</span> UserDaoImpl();</span><br><span class="line">dao.save();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过Spring获得UserDao对象</span></span><br><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">UserDao bean = (UserDao)applicationContext.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">bean.save();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>开发的一个规则是在后期维护的时候少修改源代码。如果没有Spring我们更换UserDao的实现类，比如更换为<code>UserMybatisDaoImpl</code>，我们在源代码中就要改为<code>UserDao dao = new UserMybatisDaoImpl();</code>。但有了Spring之后就只需要修改配置文件中的class为<code>xxx.UserMybatisDaoImpl</code>，被Spring管理的类叫做bean。<br><br><br>## DI（Dependency Injection）<br><br>### 依赖关系<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Class A&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">Class B&#123;</span><br><span class="line">    A a;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">xxx</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>如果在类B中使用到了类A，就说类B依赖类A，上图就是其中一种情况。<br><br>### Spring解决依赖<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title">UserDao</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"UserService执行了..."</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> </span></span><br><span class="line"><span class="tag"><span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:p</span>=<span class="string">"http://www.springframework.org/schema/p"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans </span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring的入门的配置==================== --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">"userDao"</span> <span class="attr">class</span>=<span class="string">"com.isjinhao.Demo1.UserDaoImpl"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"isjinhao"</span> /&gt;</span> //name的值和属性名称相同</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="comment">//通过Spring获得UserDao对象</span></span><br><span class="line"><span class="meta">@org</span>.junit.Test</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"applicationContext.xml"</span>);</span><br><span class="line">UserDao dao = (UserDao)applicationContext.getBean(<span class="string">"userDao"</span>);</span><br><span class="line">dao.save();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>所谓解决依赖，就是在使用时给其设置一个被依赖的对象，如果不使用Spring，设置name的值需要把dao转换为UserDaoImpl，再使用setName()方法，但是用了Spring我们就能在配置文件中设置，Spring帮我们完成设置。此时就叫做依赖注入。<br><br><br>## ApplicationContext继承体系<br><div align="center"><img src="/2019/01-Spring入门/applicationcontext继承体系.png"></div><h2 id="bean配置"><a href="#bean配置" class="headerlink" title="bean配置"></a>bean配置</h2><h3 id="id-amp-name"><a href="#id-amp-name" class="headerlink" title="id &amp; name"></a>id &amp; name</h3><p>name和id的功能类似，作用如图：</p><div align="center"><img src="/2019/01-Spring入门/id&name.png"></div><p>从语法上说name属性可以不唯一，而id必须唯一，但是实际使用时name标签和id标签通常都标识唯一值，而且优先使用name。</p><h3 id="初始化时执行的方法-amp-销毁的时候执行的方法"><a href="#初始化时执行的方法-amp-销毁的时候执行的方法" class="headerlink" title="初始化时执行的方法 &amp; 销毁的时候执行的方法"></a>初始化时执行的方法 &amp; 销毁的时候执行的方法</h3><ul><li>init-method=””：指定的方法在bean被创建时执行。</li><li>destroy-method=””：指定的方法在bean被销毁时创建的，但要求bean是单例的且手动关闭工厂。</li></ul><h3 id="bean的作用域"><a href="#bean的作用域" class="headerlink" title="bean的作用域"></a>bean的作用域</h3><p>bean标签有一个属性scope=””，可以设置bean的作用范围，五种值如下：</p><ul><li>singleton ：<strong>默认的</strong>，Spring会采用单例模式创建这个对象。</li><li>prototype ：多例模式。</li><li>request ：应用在web项目中，Spring创建这个类以后，将这个类存入到request范围中。</li><li>session ：应用在web项目中，Spring创建这个类以后，将这个类存入到session范围中。</li><li>globalsession ：应用在web项目中，必须在porlet环境下使用。但是如果没有这种环境，相当于session。（笔者不懂，抄过来的…）</li></ul></div></div></div></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 10 2019 15:42:38 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Spring-概述（00）&quot;&gt;&lt;a href=&quot;#Spring-概述（00）&quot; class=&quot;headerlink&quot; title=&quot;S
      
    
    </summary>
    
      <category term="SSM" scheme="https://isjinhao.github.io/categories/SSM/"/>
    
    
      <category term="SSM" scheme="https://isjinhao.github.io/tags/SSM/"/>
    
  </entry>
  
  <entry>
    <title>04-单表DQL</title>
    <link href="https://isjinhao.github.io/2019/04-%E5%8D%95%E8%A1%A8DQL/"/>
    <id>https://isjinhao.github.io/2019/04-单表DQL/</id>
    <published>2019-02-06T07:14:05.180Z</published>
    <updated>2019-02-07T01:16:44.415Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 10 2019 15:42:39 GMT+0800 (GMT+08:00) --><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">pid <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">pname <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">price <span class="keyword">double</span>,</span><br><span class="line">category_id <span class="built_in">varchar</span>(<span class="number">32</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'联想'</span>,<span class="number">5000</span>,<span class="string">'c001'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">'海尔'</span>,<span class="number">3000</span>,<span class="string">'c001'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">'雷神'</span>,<span class="number">5000</span>,<span class="string">'c001'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">'JACK JONES'</span>,<span class="number">800</span>,<span class="string">'c002'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">'真维斯'</span>,<span class="number">200</span>,<span class="string">'c002'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">'花花公子'</span>,<span class="number">440</span>,<span class="string">'c002'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">7</span>,<span class="string">'劲霸'</span>,<span class="number">2000</span>,<span class="string">'c002'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">8</span>,<span class="string">'香奈儿'</span>,<span class="number">800</span>,<span class="string">'c003'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">9</span>,<span class="string">'相宜本草'</span>,<span class="number">200</span>,<span class="string">'c003'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">10</span>,<span class="string">'面霸'</span>,<span class="number">5</span>,<span class="string">'c003'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">11</span>,<span class="string">'好想你枣'</span>,<span class="number">56</span>,<span class="string">'c004'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">12</span>,<span class="string">'香飘飘奶茶'</span>,<span class="number">1</span>,<span class="string">'c005'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">13</span>,<span class="string">'果9'</span>,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><ul><li>查询表的所有字段信息：<code>select * from 表名;</code></li><li>查询表中某字段信息：<code>select 字段1, 字段2 from 表名;</code></li><li>去掉重复值：<code>select distinct 字段1, 字段2, ... from 表名;</code><ul><li>若有多个字段则所有字段相等才被算为重复值。</li></ul></li><li>查询结果是表达式（运算查询）：将商品的价格+10元进行显示，<code>select pname,price+10 from product;</code></li><li>别名查询，使用的关键字是as（as可以省略的）：<ul><li>表别名：<code>select * from product as p;</code></li><li>列别名：<code>select pname as pn from product;</code></li></ul></li></ul><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">&gt; &lt; &lt;= &gt;= = &lt;&gt;!=</td><td style="text-align:center">大于、小于、大于(小于)等于、不等于</td></tr><tr><td style="text-align:center">BETWEEN …AND…</td><td style="text-align:center">显示在某一区间的值(含头含尾)(也可以是日期)</td></tr><tr><td style="text-align:center">IN(set)</td><td style="text-align:center">显示在in列表中的值，例：<code>in(100,200)</code></td></tr><tr><td style="text-align:center">LIKE ‘张%’</td><td style="text-align:center">%代表零个或多个任意字符，_代表一个字符。例如：<code>first_name like ‘_a%’</code></td></tr><tr><td style="text-align:center">IS NULL / IS NOT NULL</td><td style="text-align:center">判断为空/不为空</td></tr><tr><td style="text-align:center">and</td><td style="text-align:center">多个条件同时成立</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">多个条件任一成立</td></tr><tr><td style="text-align:center">not</td><td style="text-align:center">不成立，例：<code>where not(salary&gt;100);</code></td></tr></tbody></table><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><ul><li>查询商品名称为“花花公子”的商品所有信息：<code>SELECT * FROM product WHERE pname = &#39;花花公子&#39;</code></li><li>查询价格为800商品：<code>SELECT * FROM product WHERE price = 800</code></li><li>查询价格不是800的所有商品：<ul><li><code>SELECT * FROM product WHERE price != 800</code></li><li><code>SELECT * FROM product WHERE price &lt;&gt; 800</code></li><li><code>SELECT * FROM product WHERE NOT(price = 800)</code></li></ul></li><li>查询商品价格大于60元的所有商品信息：<code>SELECT * FROM product WHERE price &gt; 60;</code></li><li>查询商品价格在200到1000之间所有商品：<ul><li><code>SELECT * FROM product WHERE price &gt;= 200 AND price &lt;=1000;</code></li><li><code>SELECT * FROM product WHERE price BETWEEN 200 AND 1000;</code></li></ul></li><li>查询商品价格是200或800的所有商品：<ul><li><code>SELECT * FROM product WHERE price = 200 OR price = 800;</code></li><li><code>SELECT * FROM product WHERE price IN (200,800);</code></li></ul></li><li>查询含有’霸’字的所有商品：<code>SELECT * FROM product WHERE pname LIKE &#39;%霸%&#39;;</code></li><li>查询以’香’开头的所有商品：<code>SELECT * FROM product WHERE pname LIKE &#39;香%&#39;;</code></li><li>查询第二个字为’想’的所有商品：<code>SELECT * FROM product WHERE pname LIKE &#39;_想%&#39;;</code></li><li>查询没有分类的商品：<code>SELECT * FROM product WHERE category_id IS NULL;</code></li><li>查询有分类的商品：<code>SELECT * FROM prod quct WHERE category_id IS NOT NULL</code></li><li>查询所有价格大于2000的电脑商品或者价格大于1000的服装商品：<code>SELECT * FROM product WHERE (price &gt; 2000 AND category_id=&#39;c001&#39;) OR (price &gt;1000 AND category_id=&#39;c002&#39;);</code></li></ul><h2 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h2><h3 id="SELECT-FROM-表名-ORDER-BY-排序字段-ASC-DESC"><a href="#SELECT-FROM-表名-ORDER-BY-排序字段-ASC-DESC" class="headerlink" title="SELECT * FROM 表名 ORDER BY 排序字段 ASC|DESC;"></a><code>SELECT * FROM 表名 ORDER BY 排序字段 ASC|DESC;</code></h3><ul><li>ASC： 升序 (默认)</li><li>DESC：降序</li></ul><h3 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h3><ul><li>查询所有商品信息，使用价格排序(降序)：<br><code>SELECT * FROM product ORDER BY price DESC;</code></li><li>在价格排序(降序)的基础上，以分类排序(降序)：<br><code>SELECT * FROM product ORDER BY price DESC, category_id DESC;</code></li><li>显示商品的价格(去重复)，并排序(降序)：<br><code>SELECT DISTINCT price FROM product ORDER BY price DESC;</code></li></ul><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><ul><li>SELECT不仅可以作用于字段，还可以作用于聚合函数。<ul><li>count(…)：统计指定列不为NULL的记录行数；</li><li>sum(…)：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；</li><li>max(…)：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；</li><li>min(…)：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</li><li>avg(…)：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；</li></ul></li><li>例：<ul><li>查询商品的总条数：<code>SELECT COUNT(*) FROM product;</code></li><li>查询价格大于200的商品总条数：<code>SELECT COUNT(*) FROM product WHERE price &gt; 200;</code></li><li>查询分类为’c001’的商品价格总和：<br><code>SELECT SUM(price) FROM product WHERE category_id = &#39;c001&#39;;</code></li><li>查询分类为’c002’商品的平均价格：<br><code>SELECT AVG(price) FROM product WHERE category_id = &#39;c002&#39;;</code></li><li>查询商品的最大价格和最小价格：<code>SELECT MAX(price),MIN(price) FROM product;</code></li></ul></li></ul><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><ul><li>分组查询是指使用group by字句对查询信息进行分组。<br>​ <code>SELECT 字段1, 字段2… FROM 表名 GROUP BY 分组字段 HAVING 分组条件;</code></li><li>HAVING：<br>分组操作中的having子语句，是用于在分组后对数据进行过滤的，作用类似于where条件。与where的区别:<ul><li>having是在分组后对数据进行过滤。where是在分组前对数据进行过滤。</li><li>having后面可以使用聚合函数过滤数据。where后面不可以使用聚合函数。</li></ul></li><li>例：<ul><li>统计各个分类商品的个数：<br><code>SELECT category_id ,COUNT(*) FROM product GROUP BY category_id;</code></li><li>统计各个分类商品的个数,且只显示个数大于1的信息：<br><code>SELECT category_id, COUNT(*) FROM product GROUP BY category_id HAVING COUNT(*) &gt; 1;</code></li></ul></li></ul><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>由于数据量很大，显示屏长度有限，因此对数据需要采取分页显示方式。例如数据共有30条，每页显示5条。</p><ul><li>格式：<br><code>SELECT 字段1，字段2... FROM 表明 LIMIT M, N;</code><ul><li>M: 整数，表示从第几条索引开始，计算方式 （当前页-1）*每页显示条数</li><li>N: 整数，表示查询多少条数据</li></ul></li><li>例：<ul><li><code>SELECT 字段1，字段2... FROM 表明 LIMIT 0,5;</code></li><li><code>SELECT 字段1，字段2... FROM 表明 LIMIT 5,5;</code></li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 10 2019 15:42:39 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;数据准备&quot;&gt;&lt;a href=&quot;#数据准备&quot; class=&quot;headerlink&quot; title=&quot;数据准备&quot;&gt;&lt;/a&gt;数据准备&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>03-DDL与DML</title>
    <link href="https://isjinhao.github.io/2019/03-DDL%E4%B8%8EDML/"/>
    <id>https://isjinhao.github.io/2019/03-DDL与DML/</id>
    <published>2019-02-06T07:03:36.101Z</published>
    <updated>2019-03-02T12:14:56.076Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 10 2019 15:42:39 GMT+0800 (GMT+08:00) --><h2 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul><li><code>create database 数据库名;</code><ul><li>例：<code>CREATE DATABASE db1;</code></li></ul></li><li><code>create database 数据库名 charset 字符集;</code><ul><li>例：<code>CREATE DATABASE db2 CHARSET utf8;</code><br><div align="center"><img src="/2019/03-DDL与DML/创建数据库.jpg"><div></div></div></li></ul></li></ul><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><ul><li><code>drop database 数据库名</code></li></ul><h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><p></p><div align="center"><img src="/2019/03-DDL与DML/使用数据库.jpg"><div></div></div><p></p><h3 id="查看数据库的定义信息"><a href="#查看数据库的定义信息" class="headerlink" title="查看数据库的定义信息"></a>查看数据库的定义信息</h3><ul><li><code>show create database 数据库名;</code><br><div align="center"><img src="/2019/03-DDL与DML/查看数据库定义信息.png"><div></div></div></li></ul><h2 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h2><h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> &lt;表名&gt;(</span><br><span class="line">字段名<span class="number">1</span> 类型(长度) [列级完整性约束条件], </span><br><span class="line"> 字段名<span class="number">2</span> 类型(长度) [列级完整性约束条件],</span><br><span class="line"> ...</span><br><span class="line"> 字段名n 类型(长度) [列级完整性约束条件]</span><br><span class="line">    [,&lt;表级完整性约束条件&gt;]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>先不涉及约束条件，后面会有详细分析。<br></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">category</span> (</span><br><span class="line">    cid <span class="built_in">INT</span> PRIMARY <span class="keyword">KEY</span>, <span class="comment">#分类ID </span></span><br><span class="line">    cname <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="comment">#分类名称</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p></p><h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><ul><li>查看数据库中的所有表：<code>SHOW TABLES;</code></li><li>查看表结构：<code>DESC 表名;</code><br><div align="center"><img src="/2019/03-DDL与DML/表结构.jpg"><div></div></div></li></ul><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><ul><li><code>drop table 表名</code></li></ul><h3 id="修改表名"><a href="#修改表名" class="headerlink" title="修改表名"></a>修改表名</h3><ul><li><code>rename table 表名 to 新表名;</code></li></ul><h2 id="增改删"><a href="#增改删" class="headerlink" title="增改删"></a>增改删</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul><li>向表中插入某些字段：<code>insert into 表 (字段1,字段2,字段3..) values (值1,值2,值3..);</code></li><li>向表中插入所有字段，字段的顺序为创建表时的顺序：<code>insert into 表 values (值1,值2,值3..);</code><br>注意：</li><li>值与字段必须对应，个数相同，类型相同</li><li>值的数据大小必须在字段的长度范围内</li><li>除了数值类型外，其它的字段类型的值必须使用引号引起。（建议单引号）</li><li>如果要插入空值，可以不写字段，或者插入 null。</li></ul><h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3><ul><li>更新所有记录的指定字段：<code>update 表名 set 字段名=值, 字段名=值, ...;</code></li><li>更新符号条件记录的指定字段：<code>update 表名 set 字段名=值, 字段名=值, ... where 条件;</code><br>注意：</li><li>列名的类型与修改的值要一致</li><li>修改值得时候不能超过最大长度</li><li>除了数值类型外，其它的字段类型的值必须使用引号引起</li></ul><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><ul><li>删除所有数据：<code>delete from 表名;</code>或者<code>truncate table 表名;</code><ul><li>delete 一条一条删除，不清空auto_increment记录数。</li><li>truncate 直接将表删除，重新建表，auto_increment将置为零，从新开始。</li></ul></li><li>删除某些数据：<code>delete from 表名 where 条件</code></li></ul><h2 id="操作表结构"><a href="#操作表结构" class="headerlink" title="操作表结构"></a>操作表结构</h2><ul><li>添加列：<code>alter table 表名 add 列名 类型(长度) [约束];</code><ul><li><code>ALTER TABLE category ADD cdesc VARCHAR(20);</code></li></ul></li><li>删除列：<code>alter table 表名 drop 列名;</code><ul><li><code>ALTER TABLE category DROP cdesc;</code></li></ul></li><li>修改列名：<code>alter table 表名 change 旧列名 新列名 类型(长度) 约束;</code><ul><li><code>ALTER TABLE category CHANGE cdesc description VARCHAR(30);</code></li></ul></li><li>修改列的类型长度及约束：<code>alter table 表名 modify 列名 类型(长度) 约束;</code><ul><li><code>ALTER TABLE category MODIFY cdesc VARCHAR(50) NOT NULL;</code></li></ul></li><li>修改表的字符集：<code>alter table 表名 character set 字符集;</code><ul><li><code>ALTER TABLE category CHARACTER SET gbk;</code></li></ul></li></ul><h2 id="数据完整性"><a href="#数据完整性" class="headerlink" title="数据完整性"></a>数据完整性</h2><p>指数据库中存储的数据是有意义的或正确的。</p><h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>若属性A是基本关系R的主属性，则属性A不能取空值。</p><h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><p>若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码相对应，则对于R中每个元组在F上的值必须为：</p><ul><li>或者取空值（S的每个属性值均为空值）。</li><li>或者等于S中某个元组的主码值。<br><code>EMP(E#, ESEX, D#) -参照关系； DEPT(D# ,DNAME,LOCATION) -被参照关系</code></li></ul><h3 id="用户定义的完整性"><a href="#用户定义的完整性" class="headerlink" title="用户定义的完整性"></a>用户定义的完整性</h3><p>针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。</p><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><h3 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h3><ul><li>唯一标识一条记录的属性值。<ul><li>主键必须是唯一的值。</li><li>主键列不能是 NULL 值。</li><li>每个表都应该有且只能有一个主键。</li></ul></li><li><p>添加主键约束。</p><ul><li><p>方式一：创建表时，在字段描述处，声明指定字段为主键</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons(</span><br><span class="line">    Id_P <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    LastName <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    FirstName <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    City <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>方式二：创建表时，在表级约束区域，声明指定字段为主键</p><ul><li>格式：<code>[constraint 名称] primary key (字段列表)</code></li><li>关键字constraint可以省略，如果需要为主键命名，constraint不能省略。</li><li>字段列表需要使用小括号括住，如果有多字段需要使用逗号分隔。这时多个字段联合构成主键。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons(</span><br><span class="line">    FirstName <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    LastName <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    [<span class="keyword">CONSTRAINT</span> pk_PersonID] PRIMARY <span class="keyword">KEY</span> (FirstName,LastName)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>方式三：创建表之后，通过修改表结构，声明指定字段为主键</p><ul><li><code>ALTER TABLE Persons ADD [CONSTRAINT 名称] PRIMARY KEY (字段列表)</code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons(</span><br><span class="line">    FirstName <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    LastName <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    City <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> Persons <span class="keyword">ADD</span> PRIMARY <span class="keyword">KEY</span> (FirstName);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>撤销主键约束：</p><ul><li><code>ALTER TABLE Persons DROP PRIMARY KEY</code></li></ul></li></ul><h3 id="自动增长列"><a href="#自动增长列" class="headerlink" title="自动增长列"></a>自动增长列</h3><ul><li>设置某列的值自动增长。<ul><li>使用 auto_increment（自动增长列）关键字。</li><li>自动增长列类型必须是整形。</li><li>自动增长列必须为键(一般是主键)。</li></ul></li><li><p>添加自动增长：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons(</span><br><span class="line">    P_Id <span class="built_in">int</span> PRIMARY <span class="keyword">KEY</span> AUTO_INCREMENT,</span><br><span class="line">    LastName <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    FirstName <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    City <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>添加数据时，可以不设置值，也可以设置成null，数据库将自动维护主键值：</p><ul><li><code>INSERT INTO Persons (FirstName,LastName) VALUES (&#39;Bill&#39;,&#39;Gates&#39;)</code>;</li><li><code>INSERT INTO Persons (P_Id,FirstName,LastName) VALUES (NULL,&#39;Bill&#39;,&#39;Gates&#39;)</code>;</li></ul></li><li><p>修改起始值</p><ul><li><code>ALTER TABLE Persons AUTO_INCREMENT=100;</code></li></ul></li></ul><h3 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h3><p>约束不接受NULL值，意味着如果不向字段添加值，就无法插入新记录或者更新记录。</p><ul><li><p>添加方式</p><ul><li><p>方式一：创建表，下面的 SQL 语句强制 “Id_P” 列和 “LastName” 列不接受 NULL 值</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons(</span><br><span class="line">    Id_P <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    LastName <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    FirstName <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    City <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>方式二：修改表结构<br><code>ALTER TABLE student MODIFY LastName varchar(255) NOT NULL</code></p></li></ul></li><li><p>删除非空约束</p><ul><li><code>ALTER TABLE student MODIFY LastName varchar(255);</code></li></ul></li></ul><h3 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h3><p>UNIQUE约束唯一标识数据库表中的每条记录。PRIMARY KEY拥有自动定义的UNIQUE约束。每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。</p><ul><li><p>添加唯一约束</p><ul><li><p>方式1：创建表时，在字段描述处，声明唯一</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons(</span><br><span class="line">    Id_P <span class="built_in">int</span> <span class="keyword">UNIQUE</span>,</span><br><span class="line">    LastName <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    FirstName <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    City <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>方式2：创建表时，在约束区域，声明唯一</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons(</span><br><span class="line">    Id_P <span class="built_in">int</span>,</span><br><span class="line">    LastName <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    FirstName <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    Address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    City <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    <span class="keyword">CONSTRAINT</span> 名称 <span class="keyword">UNIQUE</span> (Id_P)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>方式3：创建表后，修改表结构，声明字段唯一<br><code>ALTER TABLE Persons ADD [CONSTRAINT 名称] UNIQUE (Id_P);</code></p></li></ul></li><li>删除唯一约束<ul><li><code>ALTER TABLE Persons DROP INDEX 约束名称</code></li><li>如果添加唯一约束时，没有设置约束名称，默认是当前字段的字段名。</li></ul></li></ul><h3 id="默认约束"><a href="#默认约束" class="headerlink" title="默认约束"></a>默认约束</h3><p>在添加数据中，如果该字段不指定值，采用默认值处理。</p><ul><li><p>添加方式</p><ul><li><p>方式一： 创建表，字段处声明</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Persons(</span><br><span class="line">    Id_P <span class="built_in">int</span>,</span><br><span class="line">    LastName <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    FirstName <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    Address <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">'北京'</span>,</span><br><span class="line">    City <span class="built_in">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>方式二： 修改表结构<br><code>ALTER TABLE Persons MODIFY Address VARCHAR(255) DEFAULT &#39;北京&#39;;</code></p></li></ul></li><li>删除方式<br><code>ALTER TABLE Persons MODIFY Address VARCHAR(255);</code></li></ul><h3 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h3><p>参照关系对应的表是从表。被参照关系对应的表是主表。</p><ul><li><p>声明外键约束</p><ul><li><p>创建表时添加。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE Persons(</span><br><span class="line">    Id_P int,</span><br><span class="line">    LastName varchar(255) NOT NULL,</span><br><span class="line">    FirstName varchar(255),</span><br><span class="line">    Address varchar(255) DEFAULT &apos;北京&apos;,</span><br><span class="line">    City varchar(255),</span><br><span class="line">    [CONSTRAINT FK_DEPTNO] FOREIGN KEY (Address) REFERENCES CITY(Address)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>修改表结构<br><code>alter table 从表 add [constraint 名称] foreign key (外键字段) references 主表 (主表主键);</code></p></li></ul></li><li><p>删除外键</p><ul><li><code>alter table 从表 drop foreign key 外键名称;</code></li></ul></li></ul><h2 id="备份-amp-恢复"><a href="#备份-amp-恢复" class="headerlink" title="备份 &amp; 恢复"></a>备份 &amp; 恢复</h2><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p></p><div align="center"><img src="/2019/03-DDL与DML/转储1.jpg"><div></div></div><p></p><p></p><div align="center"><img src="/2019/03-DDL与DML/转储2.jpg"><div></div></div><p></p><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p></p><div align="center"><img src="/2019/03-DDL与DML/恢复1.jpg">&gt;<div></div></div><p></p><p></p><div align="center"><img src="/2019/03-DDL与DML/恢复2.jpg"><div></div></div><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 10 2019 15:42:39 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;操作数据库&quot;&gt;&lt;a href=&quot;#操作数据库&quot; class=&quot;headerlink&quot; title=&quot;操作数据库&quot;&gt;&lt;/a&gt;操作数据库&lt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>02-MySQL环境安装</title>
    <link href="https://isjinhao.github.io/2019/02-MySQL%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <id>https://isjinhao.github.io/2019/02-MySQL环境安装/</id>
    <published>2019-02-06T06:52:05.182Z</published>
    <updated>2019-03-02T12:24:11.850Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 10 2019 15:42:39 GMT+0800 (GMT+08:00) --><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><p>MySQL有两种安装方式，解压配置和安装程序安装。在这使用解压配置但是资源里有<a href="资源\MySQL安装图解.docx">使用安装程序安装的教程</a>。</p><h3 id="解压至指定目录"><a href="#解压至指定目录" class="headerlink" title="解压至指定目录"></a>解压至指定目录</h3><p>解压至自己选定的目录，一般不选择系统盘。我是解压至D盘根目录：<code>D:\mysql-5.5\</code>。</p><h3 id="写配置文件"><a href="#写配置文件" class="headerlink" title="写配置文件"></a>写配置文件</h3><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置字符集为utf8 </span></span><br><span class="line"><span class="attr">character-set-server</span> = utf8</span><br><span class="line"><span class="attr">basedir</span> = D:/mysql-<span class="number">5.5</span>#指定为自己选定的目录</span><br><span class="line"><span class="attr">datadir</span> = D:/mysql-<span class="number">5.5</span>/data #指定为选定目录下的data文件夹</span><br><span class="line"><span class="section">[client]</span> </span><br><span class="line"><span class="comment">#设置客户端字符集</span></span><br><span class="line"><span class="attr">default-character-set</span> = utf8</span><br><span class="line"><span class="section">[WinMySQLadmin]</span> </span><br><span class="line"><span class="attr">Server</span> = D:/mysql-<span class="number">5.5</span>/bin/mysqld.exe #指定至mysqld.exe文件</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p></p><div align="center"><img src="/2019/02-MySQL环境安装/配置环境.jpg" alt=""><div></div></div><p></p><h3 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h3><p>在管理员下的cmd命令下进入<code>%MYSQL_HOME%/bin</code>目录执行<code>mysqld -install</code>。如果想要卸载服务执行命令<code>mysqld -remove</code>。</p><ul><li>启动服务<ul><li><code>net start mysql</code></li><li>第一次进入<ul><li><code>mysql -u root</code>。</li><li><code>mysql&gt; update mysql.user set password=PASSWORD(‘root’) where User=’root’;</code></li><li><code>mysql&gt; flush privileges;</code></li></ul></li><li>后续进入<ul><li><code>mysql -u username -p</code></li><li>按提示输入密码</li></ul></li><li>退出<ul><li>exit</li></ul></li></ul></li><li>停止服务<ul><li><code>net stop mysql</code></li></ul></li></ul><h3 id="查看编码集"><a href="#查看编码集" class="headerlink" title="查看编码集"></a>查看编码集</h3><ul><li><code>mysql&gt; show variables like ‘%char%’;</code></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like &apos;%char%&apos;;</span><br><span class="line">+--------------------------+------------------------------+</span><br><span class="line">| Variable_name            | Value                        |</span><br><span class="line">+--------------------------+------------------------------+</span><br><span class="line">| character_set_client     | utf8                         |</span><br><span class="line">| character_set_connection | utf8                         |</span><br><span class="line">| character_set_database   | utf8                         |</span><br><span class="line">| character_set_filesystem | binary                       |</span><br><span class="line">| character_set_results    | utf8                         |</span><br><span class="line">| character_set_server     | utf8                         |</span><br><span class="line">| character_set_system     | utf8                         |</span><br><span class="line">| character_sets_dir       | D:\mysql-5.5\share\charsets\ |</span><br><span class="line">+--------------------------+------------------------------+</span><br><span class="line">8 rows in set (0.01 sec)</span><br></pre></td></tr></table></figure></li><li><p>编码集如图上表示编码集配置正确。</p></li></ul><h2 id="安装SQLyog"><a href="#安装SQLyog" class="headerlink" title="安装SQLyog"></a>安装SQLyog</h2><p>SQLyog是一个可视化操作数据库工具。解压后就可使用：</p><ul><li>点击<code>SQLyog.exe</code></li><li>连接数据库<br><div align="center"><img src="/2019/02-MySQL环境安装/sqlyog连接mysql.png" alt=""><div></div></div></li><li>使用<br><div align="center"><img src="/2019/02-MySQL环境安装/sqlyog使用.jpg" alt=""><div></div></div></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 10 2019 15:42:39 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;安装MySQL&quot;&gt;&lt;a href=&quot;#安装MySQL&quot; class=&quot;headerlink&quot; title=&quot;安装MySQL&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>01-关系型数据库绪论</title>
    <link href="https://isjinhao.github.io/2019/01-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%AA%E8%AE%BA/"/>
    <id>https://isjinhao.github.io/2019/01-关系型数据库绪论/</id>
    <published>2019-02-06T06:11:49.245Z</published>
    <updated>2019-03-02T12:20:40.334Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 10 2019 15:42:38 GMT+0800 (GMT+08:00) --><h2 id="数据、数据库、数据库管理系统"><a href="#数据、数据库、数据库管理系统" class="headerlink" title="数据、数据库、数据库管理系统"></a>数据、数据库、数据库管理系统</h2><ul><li>数据：描述事物的符号记录称为数据，如文字、图形、图象、声音、学生的档案记录、货物的运输情况等。数据的含义称为数据的语义，数据与其语义是不可分的。</li><li>数据库：数据按一定的方式组织、描述和存储后形成的数据集合叫做数据库。数据库具有三个特点：<ul><li>永久存储：不随程序的结束而结束。</li><li>有组织：数据之间有一定的格式，可以通过格式知道数据所代表的的意义。</li><li>可共享：数据库里的信息不是只为某一用户或某一程序所使用。</li></ul></li><li>数据库管理系统：数据库管理系统是位于用户与操作系统之间的一层用来管理数据库的软件。常用的数据库管理系统有MySQL、Oracle、Redis、MongoDB等。</li></ul><h2 id="关系数据库系统"><a href="#关系数据库系统" class="headerlink" title="关系数据库系统"></a>关系数据库系统</h2><p>数据库是由数据按某种形式组织所形成，按照不同的组织方式可以分为不同的类型。所以<strong>关系型数据库</strong>就是指以关系数学模型来组织数据的数据库，关系数学模型中以<strong>二维表</strong>的形式来描述数据。也就是一个关系对应一个二维表。</p><div align="center"><img src="/2019/01-关系型数据库绪论/01-绪论/层次结构.jpg"></div><h3 id="实体-联系"><a href="#实体-联系" class="headerlink" title="实体-联系"></a>实体-联系</h3><ul><li>实体：客观存在并可相互区别的事物。二维表非首行。</li><li>属性：实体所具有的某一特性。二维表的一格。</li><li>码：唯一标识实体的属性。</li><li>域：属性的取值范围。</li><li>实体型：用实体名及其属性名集合来抽象和刻画同类实体。</li><li>实体集：同型实体的集合称为实体集</li><li>联系：现实世界中事物内部以及事物之间的联系在信息世界中反映为实体内部的联系和实体之间的联系。</li></ul><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><h3 id="DDL、DML、DCL、DQL"><a href="#DDL、DML、DCL、DQL" class="headerlink" title="DDL、DML、DCL、DQL"></a>DDL、DML、DCL、DQL</h3><p>常见的关系数据库系统有MySQL、Oracle等，可以使用结构化查询语言（Structured Query Language，SQL）进行操作。不同的数据库生产厂商都支持SQL语句，但都有特有内容（称为方言）。SQL可分为四类：</p><ul><li>数据定义语言（Data Definition Language，DDL）：用来定义数据库中的对象：数据库，表，列等。关键字有create、alter、drop、 show等。</li><li>数据操作语言（Data Manipulation Language，DML）：用来对数据库中表的记录进行更新。关键字有insert、delete、update等。</li><li>数据查询语言（Data Query Language，DQL）：用来查询数据库中表的记录。关键字：select，from，where等。</li><li>数据控制语言（Data Control Language，DCL）：用来定义数据库的访问权限和安全级别，及创建用户。关键字有grant、revoke等。</li></ul><h3 id="SQL通用语法"><a href="#SQL通用语法" class="headerlink" title="SQL通用语法"></a>SQL通用语法</h3><ul><li>SQL语句可以单行或多行书写，以分号结尾，可使用空格和缩进来增强语句的可读性。</li><li>MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。例如：SELECT * FROM user。</li><li>使用<code>/* ... */</code>的方式完成注释。</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><table><thead><tr><th style="text-align:center">类型</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">int</td><td style="text-align:center">整型</td></tr><tr><td style="text-align:center">double</td><td style="text-align:center">浮点型</td></tr><tr><td style="text-align:center">varchar</td><td style="text-align:center">变长字符串型（指定为10个字节长度，存储<code>abc</code>只占用3个字节）</td></tr><tr><td style="text-align:center">char</td><td style="text-align:center">定长字符串型（指定为10个字节长度，存储<code>abc</code>也占用10个字节）</td></tr><tr><td style="text-align:center">datetime</td><td style="text-align:center">YYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00~ 9999-12-31 23:59:59）</td></tr></tbody></table><h2 id="实体型之间的联系"><a href="#实体型之间的联系" class="headerlink" title="实体型之间的联系"></a>实体型之间的联系</h2><ul><li>一对一联系：如果对于实体集A中的每一个实体，实体集B中至多有一个实体与之联系，反之亦然，称实体集A与实体集B有一对一联系。记为1：1。</li><li>一对多联系：如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，称实体集A与实体B有一对多联系。记为1：n。</li><li>多对多联系：如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中有m个实体（m≥0）与之联系，称实体集A与实体B有多对多联系。记为m：n。<ul><li>多对多联系能经由一个中间表拆分成两个一对多关系。</li></ul></li></ul><h2 id="Entity-Relationship-Model"><a href="#Entity-Relationship-Model" class="headerlink" title="Entity-Relationship Model"></a>Entity-Relationship Model</h2><p>E-R图提供了表示实体型、属性和联系的方法。先把需求转化成E-R图，可以方便的化简和建表。</p><ul><li>实体型：用矩形表示，矩形框内写明实体名。</li><li>属性：用椭圆形表示，并用无向边将其与相应的实体连接起来。</li><li>联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上。联系的类型: 1：1、1：n或m：n。联系本身也是一种实体型，也可以有属性。如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来。</li></ul><h2 id="E-R图转换成关系"><a href="#E-R图转换成关系" class="headerlink" title="E-R图转换成关系"></a>E-R图转换成关系</h2><p>转换原则：实体和联系分别转换为关系，再合并具有相同主键的关系。</p><ul><li>实体转换为关系：<ul><li>一个实体型 转换成 一个关系。</li><li>实体型的名称 转换成 构成关系的名称。</li><li>实体型的属性 转换成 构成关系的属性（也叫字段）。</li><li>实体型的主键 转换成 关系的主键。</li></ul></li><li>联系转换为关系：<ul><li>一个联系 转换成 一个关系。</li><li>与该联系相关联的各实体的码属性以及联系本身的属性 构成 关系的属性。</li><li>联系转换为关系的码的取决于联系的类型。<ul><li>1：1联系，任一实体的码。</li><li>1：n联系，n端实体的码。</li><li>m：n联系，双方实体的码</li></ul></li></ul></li><li>相同码的关系合并为一个关系。</li></ul><h2 id="E-R图实例"><a href="#E-R图实例" class="headerlink" title="E-R图实例"></a>E-R图实例</h2><ul><li>数据：<ul><li>科室：科名，科地址，科电话</li><li>病房：病房号，床位号</li><li>医生：姓名，职称，年龄，工作证</li><li>病人：病历号，姓名，性别，诊断</li></ul></li><li>联系：<ul><li>一个科室有多个病房、多个医生</li><li>一个病房只能属于一个科室</li><li>一个医生只属于一个科室，但可负责多个病人的诊治</li><li>一个病人的主管医生只有一个</li></ul></li><li>E-R图<div align="center"><img src="/2019/01-关系型数据库绪论/e-r图.jpg"></div></li><li>转换<ul><li>科室（科名，地址，电话）</li><li>医生（医生名，职称，年龄，工作证号）</li><li>病房（病房号，床位号）</li><li>病人（病历号，姓名，性别，诊断）</li><li>负责（床位号，科名）</li><li>拥有（医生名，科名）</li><li>诊治（病历号，医生名）</li></ul></li><li>合并<ul><li>科室（科名，地址，电话）</li><li>医生（医生名，职称，科名，年龄，工作证号）</li><li>病房（床位号，病房号，科名）</li><li>病人（病历号，姓名，性别，诊断，医生名）</li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 10 2019 15:42:38 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;数据、数据库、数据库管理系统&quot;&gt;&lt;a href=&quot;#数据、数据库、数据库管理系统&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>03-进程的描述与控制</title>
    <link href="https://isjinhao.github.io/2019/03-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/"/>
    <id>https://isjinhao.github.io/2019/03-进程的描述与控制/</id>
    <published>2019-02-06T06:01:56.984Z</published>
    <updated>2019-02-07T04:49:06.508Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 10 2019 15:42:39 GMT+0800 (GMT+08:00) --><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><h3 id="前趋图"><a href="#前趋图" class="headerlink" title="前趋图"></a>前趋图</h3><p>数据结构中的有向无环图。箭头表示进程之间执行的先后关系。结点表示一个程序或一个进程，甚至一条语句。</p><p></p><div align="center"><img src="/2019/03-进程的描述与控制/前趋图.jpg" alt=""><div></div></div><p></p><h3 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h3><p>不存在前趋关系的程序之间才有可能并发执行。特征：</p><ul><li>间断性：程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系，进而导致并发程序具有“执行-暂停-执行”这种间断性的活动规律。</li><li>失去封闭性：由于资源共享，所以当某程序的运行影响资源的状态时，其他程序的运行环境就会被破坏。</li><li>不可再现性：计算结果与并发程序各自执行速度有关。即同一程序，使用相同输入、在相同环境下运行，却可能获得完全不同的结果。</li></ul><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><p>在多道程序环境下，程序的执行属于并发执行，此时他们将失去其封闭性，并具有间断性，以及运行结果的不可再现性。由此，决定了通常的程序是不能参与并发执行的。为了能使程序并发执行，引入了进程。</p><ul><li>进程实体：程序+数据+进程控制块（Process Control Block，PCB）。</li><li>进程：运行态的进程实体是就是进程，是系统进行资源分配和调度的一个独立单位。<br>PCB是为了使程序能并发执行而诞生的一种数据结构，它用来控制和管理进程。由于数据和程序本来就存在，所以创建/撤销进程也就是创建/撤销PCB。至于如何并发执行，见下面的<a href="#jump">进程同步</a>。<br>区别于作业：进程是程序在数据集上的一次作执行，作业是用户提交给系统的一个任务，包含一个或多个进程。</li></ul><h3 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h3><ul><li>动态性：由创建而产生，由调度而执行，由撤销而消亡。</li><li>并发性：进程的重要特征，操作系统的重要特征。</li><li>独立性：独立运行、独立分配资源、独立接受调度。</li><li>异步性：按各自独立、不可预知的速度向前推进。</li></ul><h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><h3 id="PCB中保存的信息"><a href="#PCB中保存的信息" class="headerlink" title="PCB中保存的信息"></a>PCB中保存的信息</h3><ul><li>进程标识符。用于唯一的标识某个进程。<ul><li>外部标识符：不仅可以标识进程，还指明其父进程、子进程以及拥有该进程的用户。</li><li>内部标识符：方便系统使用进程，仅能标识进程。</li></ul></li><li>处理机状态。用于在进程切换时保存处理机中各个寄存器的内容。以便在该进程重新调度时能再从断点执行。</li><li>进程调度信息。<ul><li>进程状态：指明进程的状态，方便进程调度和对换时的依据。</li><li>进程优先级：进程优先级高的更容易获得处理机。</li><li>进程调度所需信息：保存的内容和进程调度算法有关，如进程等待了多久CPU，使用了多长CPU。</li><li>事件：进程因何由执行状态转变为阻塞状态，即阻塞原因。</li></ul></li><li>进程控制信息。<ul><li>程序和数据的地址。</li><li>进程同步的通信机制。</li><li>资源清单。进程已分配到的除处理机之外的资源。</li><li>链接指针。用于指向下一个PCB的首地址。用于进程调度。</li></ul></li></ul><h3 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h3><ul><li>线性方式：所有的PCB都保存在一张表中，每次寻找PCB都在表中查找。效率低。</li><li>链接方式：把具有相同状态的PCB链接起来。</li><li>索引方式：把具有相同状态的PCB保存在相应的表中。<br><div align="center"><img src="/2019/03-进程的描述与控制/pcb的组织方式.jpg" alt=""><div></div></div></li></ul><h2 id="OS内核"><a href="#OS内核" class="headerlink" title="OS内核"></a>OS内核</h2><h3 id="系统态-amp-用户态"><a href="#系统态-amp-用户态" class="headerlink" title="系统态 &amp; 用户态"></a>系统态 &amp; 用户态</h3><p>对于处理机来说，根据其执行的指令不同，可以将其分成系统态（管态、内核态）和用户态。处理机处于系统态时可以执行任意的指令，访问所有的寄存器和存储区，而处于用户态的时候会受到相应的限制。所以计算机中的程序可以分成系统程序和用户程序，用户程序运行在用户态，这样就可以防止用户程序对操作系统进行破坏。</p><h3 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h3><p>操作系统把CPU指令分成两类：</p><ul><li>特权指令：在系统态执行的指令。执行几乎不受限制，如启动外部设备、设置系统时钟等。</li><li>非特权指令：在用户态执行的指令。限制较多，比如不能操作硬件等。</li></ul><h3 id="内核概念"><a href="#内核概念" class="headerlink" title="内核概念"></a>内核概念</h3><p>现代操作系统采用分层设计模式，不同权重的程序分别设置在不同的层次中。通常与<strong>硬件紧密相关的程序</strong>、<strong>设备驱动程序</strong>和<strong>运行频率高的程序</strong>等放置在高级别层次中，操作系统会将它们常驻内存，这些程序便被称为OS内核。OS内核运行在系统态中。</p><h3 id="内核的功能"><a href="#内核的功能" class="headerlink" title="内核的功能"></a>内核的功能</h3><p>不同操作系统的内核在功能上有一定的差异，但是一般都包含两类功能：</p><ul><li>支撑功能<ul><li>中断处理：是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，且处理完毕后又返回原被暂停的程序继续运行。人机交互、设备驱动和进程调度等都需要依赖中断处理。</li><li>时钟管理：系统中很多活动都需要用到时钟，如定时任务、时间片轮转调度算法等。</li><li>原语操作：原语是若干条机器指令构成的，用以完成特定功能的一段程序。而原语操作便是原语的执行，其在执行期间是不可分割的。</li></ul></li><li>资源管理功能<ul><li>进程管理：进程的创建、撤销、调度等操作。</li><li>存储器管理：空间的分配、撤销、逻辑地址转换为物理地址等。</li><li>设备管理：进行设备分配、缓和CPU和I/O速度不匹配矛盾的缓冲管理等。</li></ul></li></ul><h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><ol><li>为新进程申请内部标识符，同时从PCB集合中索取一个空白的PCB。</li><li>为新进程分配其运行所需的资源。这些资源直接来自操作系统或者父进程。</li><li>初始化PCB。如处理机状态信息、标识符和进程优先级等。</li><li>若就绪队列还能接受进程，则插入就绪队列。不能接受则执行相应处理机制。</li></ol><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><ol><li>从PCB集合中获得某进程的PCB，并读出该进程的状态。<ul><li>若进程正处于执行状态，应立即终止该进程的执行。</li><li>若此进程有子进程则一并终止，防止其成为不可控进程。</li></ul></li><li>将进程拥有的所有资源归还给其父进程或操作系统。</li><li>将被终止的进程从所在队列或链表（指PCB的组织方式）中移出，等待其他程序收集信息，释放空间等。</li></ol><h3 id="三种基本状态"><a href="#三种基本状态" class="headerlink" title="三种基本状态"></a>三种基本状态</h3><ul><li>就绪状态：分配到出处理机之外的其他所有必要资源。此时可运行，但其他进程正在占用CPU。</li><li>执行状态：就绪状态的进程获得CPU，正在执行的状态。</li><li>阻塞状态：进程发出的请求没有及时得到满足而无法继续执行的状态，此时会引起进程调度，OS把处理机分配给其他就绪进程，原进程暂停。<br><div align="center"><img src="/2019/03-进程的描述与控制/五种进程状态.jpg" alt=""><div></div></div></li></ul><h3 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h3><p>进程暂停执行或不接受调度的状态。原因有如下几点：</p><ul><li>用户的需要：用户想暂停正在的进程，观察其状态或修改程序等。</li><li>父进程请求：父进程为了完成某项任务，协调其各子进程间的活动。</li><li>负荷调节的需要：系统压力过大或实时操作系统不能很好的满足可靠性时会挂起一些进程。</li><li>操作系统的需要：操作系统挂起某些进程来更方便的检查系统资源。<br>挂起和阻塞不同在于阻塞是客观条件不能得到满足，即资源不足引起暂停。挂起是主观需要引起暂停。<br><div align="center"><img src="/2019/03-进程的描述与控制/引入挂起的进程状态图.jpg" alt=""><div></div></div></li></ul><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a><span id="jump">进程同步</span></h2><p>进程同步的主要任务是使并发执行的诸进程之间能有效的共享资源和相互合作，从而使程序的执行具有可再现性。</p><h3 id="同步-amp-互斥"><a href="#同步-amp-互斥" class="headerlink" title="同步 &amp; 互斥"></a>同步 &amp; 互斥</h3><p>并发执行的诸进程之间既有独立性又有制约性。</p><ul><li>独立性：各进程都可独立地向前推进；</li><li>制约性：由于资源共享和进程合作引起的进程之间的相互依赖和相互制约的关系。可归结为互斥和同步。<ul><li>同步：两个或多个事件的发生有着某种时序上的关系。按照这种时序关系进行能保证各任务安全的完成。</li><li>互斥：资源的使用要排它使用，防止冲突（不同时使用，但无先后次序。一种特殊同步）。</li></ul></li></ul><h3 id="临界资源-amp-临界区"><a href="#临界资源-amp-临界区" class="headerlink" title="临界资源 &amp; 临界区"></a>临界资源 &amp; 临界区</h3><ul><li>临界资源：需要被各进程互斥访问的资源。</li><li>临界区：各进程中访问临界资源的代码。<br>若能保证各进程互斥地进入自己的临界区，便可以保证互斥地访问临界资源，进而保证进程同步。常用的方式有硬件同步机制和信号量机制。</li></ul><h3 id="同步准则"><a href="#同步准则" class="headerlink" title="同步准则"></a>同步准则</h3><ul><li>空闲让进：当无进程处于临界区时，应当允许一个进程进入自己的临界区。</li><li>忙则等待：当有进程处于临界区时其他请求就如临界区的进程必须等待。</li><li>有限等待：对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区。</li><li>让权等待：当进程不能进入临界区时，应立即释放处理机避免进程陷入“忙等”的状态。</li></ul><h2 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h2><h3 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h3><p>当进程在临界区执行期间，计算机系统不响应中断，因此不会引发调度，临界资源只会被一个进程占据，这样就不会发生进程同步问题。</p><h3 id="利用Test-and-Set指令实现互斥"><a href="#利用Test-and-Set指令实现互斥" class="headerlink" title="利用Test-and-Set指令实现互斥"></a>利用Test-and-Set指令实现互斥</h3><p>指令的描述如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TS</span><span class="params">(boolean *lock)</span></span>&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>为临界资源设置一个布尔变量<code>lock = false</code>。在进程进入临界区之前利用TS指令测试，如果得到的值为<code>false</code>表示资源未被使用，如果得到的值为<code>true</code>，则一直测试到结果为<code>false</code>。使用TS指令实现互斥描述如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (TS(&amp;lock));</span><br><span class="line">...</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p></p><h3 id="利用Swap指令实现互斥"><a href="#利用Swap指令实现互斥" class="headerlink" title="利用Swap指令实现互斥"></a>利用Swap指令实现互斥</h3><p>指令描述如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(boolean *a, boolean *b)</span></span>&#123;</span><br><span class="line">    boolean temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>为每个临界资源设置一个全局变量<code>lock=false</code>。每个进程设置一个局部变量<code>key</code>。实现互斥的描述如下：<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">...</span><br><span class="line">    key = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        swap(&amp;lock, &amp;key);</span><br><span class="line">    &#125;<span class="keyword">while</span>(key != <span class="literal">false</span>)</span><br><span class="line">    critical section;</span><br><span class="line">    lock = <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>关中断：效率低下且不适用于多处理机系统。且其他进行会”忙等“，不符合让权等待。</li><li>TS指令 &amp; Swap指令：其他进行会”忙等“，不符合让权等待。</li></ul><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p>整型信号量是一个用于描述资源数目的整型量（S）。但除了初始化以外，仅能通过两个原子操作来访问。</p><ul><li><p>wait(S)：P操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wait(S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>);</span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>signal(S)：V操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S)&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>P操作用于分配资源，V操作用于释放资源。</p><h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>整型信号量未遵循让权等待原则。只要<code>S &lt;= 0</code>就会不断的循环。此时需要增加一个进程链表指针链接等待进程。</p><ul><li><p>数据结构的描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;<span class="comment">//资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process_control_block</span> *<span class="title">list</span>;</span><span class="comment">//阻塞队列</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure></li><li><p>wait(S)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    if(S-&gt;value &lt; 0)</span><br><span class="line">    block(S-&gt;list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>signal(S)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">signal(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">    wakeup(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当进程被阻塞时会被加入阻塞对列，资源被满足时唤醒阻塞对列中的某个资源。</p><h3 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h3><p>记录型信号量只能解决共享一个临界资源的情况，若有多个临界资源则需要使用多个记录型信号量。但是信号量越多，系统死锁的概率越大，且大量的同步操作会给系统的管理带来麻烦。AND型信号量的思想是一次性分配进程所需的全部资源，如果有一个没有分配成功，则其他所有可能为之分配的资源亦不分配。</p><ul><li><p>Swait(S)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1, S2, ..., Sn)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Si &gt;= <span class="number">1</span> &amp;&amp; ... &amp;&amp; Sn &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            Si--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            把进程阻塞在请求未能得到满足的资源Si所对应的阻塞队列里，同时把进程的程序计数器（放  置CPU下一条要执行的指令地址）放置在本操作的开始处（下一次再调度到此进程，需要再次</span><br><span class="line">            检查所有的资源）。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Ssignal(S)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ssignal(S1, S2, ..., Sn)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            Si++;</span><br><span class="line">            唤醒等待Si资源的阻塞队列。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h3><p>之前的信号量都是一次申请或释放某资源一份，若申请或释放N份资源需要进行N次操作，效率比较低下。此外，当资源数量低于某一下限值时，为了系统安全，就不能再予以分配。所以产生信号量集解决以上问题。描述如下：</p><ul><li><code>Swait(S1, t1, d1, ..., Sn, tn, dn)</code>：当<code>Si &gt;= ti</code>时<code>Si = Si - di</code>。（<code>di &gt;= ti</code>）</li><li><code>Ssignal(S1, d1, ..., Sn, dn)</code>：<code>Si = Si + di</code>。<br>特殊的信号量集：</li><li><code>Swait(S1, d, d)</code>：每次申请d份资源，资源少于d时不分配。</li><li><code>Swait(S, 1, 1)</code>：退化成一般的记录型信号量。</li><li><code>Swait(S, 1, 0)</code>：<code>S &gt;= 1</code>时运行多个进行进入特定区。<code>S &lt;= 0</code>时禁止进程进入特定区。</li></ul><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>直接使用信号量机制会把大量的同步操作分散在各个进程中，这会增加系统死锁的概率并且不方便系统的管理。而管程就是把代表共享资源的数据结构和对共享数据结构的操作（包括同步机制）封装起来以更好的为进程使用。这时所有请求访问共享资源的进程都只能通过管程间接访问，同时管程每次只允许一个进程进入管程。<br>此时的管程可以使用面相对象的操作来完成整型信号量的功能。但是此时无法解决“让权等待”的问题，所以再按照面相对象的思想将<code>block</code>和<code>wakeup</code>操作封装起来来解决这个问题，即构成条件变量。条件变量的操作如下：</p><ul><li><code>condition.wait()</code>：使进程在因某条件不能满足时阻塞在其所对应的条件变量上。</li><li><code>condition.signal()</code>：唤醒因某条件不能满足而阻塞的进程。<br>可以很容易看出来，设置不同的条件变量能使由不同原因等待的进程阻塞在不同的队列中。<br>使用时把<code>signal()</code>操作放在函数/过程的最后，这样保证在唤醒其他进程后本进程能直接退出而不再产生冲突。<br><strong>管程的描述如下：</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、局部数据和条件变量组成管程内的数据结构。</span></span><br><span class="line"><span class="comment">2、过程/函数1~过程/函数k组成管程内的一组过程对管程内的数据结构进行操作。</span></span><br><span class="line"><span class="comment">3、初始化代码：对管程内的数据结构进行初始化。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Monitor monitor_name&#123;</span><br><span class="line">    share variable declartions; <span class="comment">//共享变量说明</span></span><br><span class="line">    condition declarations;<span class="comment">//条件变量说明</span></span><br><span class="line">    &#123;<span class="comment">//管程主体</span></span><br><span class="line">        initialization code;    <span class="comment">//初始化代码</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//能被进程调用的过程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pn</span><span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="信号量的应用"><a href="#信号量的应用" class="headerlink" title="信号量的应用"></a>信号量的应用</h2><h3 id="互斥访问资源"><a href="#互斥访问资源" class="headerlink" title="互斥访问资源"></a>互斥访问资源</h3><p>设某共享资源的信号量是<code>mutex</code>，PA和PB进程并发时需互斥访问。<br></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">PA()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">        wait(mutex);</span><br><span class="line">        ...</span><br><span class="line">        signal(mutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">PB()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        wait(mutex);</span><br><span class="line">        ...</span><br><span class="line">        signal(mutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h3 id="利用信号量实现前趋关系"><a href="#利用信号量实现前趋关系" class="headerlink" title="利用信号量实现前趋关系"></a>利用信号量实现前趋关系</h3><p></p><div align="center"><img src="/2019/03-进程的描述与控制/前趋图例题.jpg" alt=""><div><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">P1（）&#123;...V(f1);V(f1);V(f1);&#125;</span><br><span class="line">P2（）&#123;P(f1)；... V(f2);&#125;</span><br><span class="line">P3（）&#123;P(f1)；... V(f3);&#125;</span><br><span class="line">P4（）&#123;P(f1)；... V(f4);&#125;</span><br><span class="line">P5（）&#123;P(f2)；... V(f5);&#125;</span><br><span class="line">P6（）&#123;P(f3);P(f4);P(f5);...;&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    semaphore f1=f2=f3=f4=f5=<span class="number">0</span>；</span><br><span class="line">    Cobegin</span><br><span class="line">    P1(); P2();P3(); P4();P5(); P6();</span><br><span class="line">    Coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></div><p></p><p>在并发时，如果<code>P1</code>的功能代码未执行完，<code>f1</code>为0，每次对<code>f1</code>进行V操作能使<code>P2</code>、<code>P3</code>、<code>P4</code>运行一个。其他亦然。</p><h3 id="生产者—消费者问题"><a href="#生产者—消费者问题" class="headerlink" title="生产者—消费者问题"></a>生产者—消费者问题</h3><ul><li>问题描述：多个生产者进程生产产品以供多个消费者消费。通过由n个环形缓冲区构成的缓冲池（循环队列），把多个生产者和多个消费者联系起来。不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未取走的缓冲区中投放产品。<br><div align="center"><img src="/2019/03-进程的描述与控制/生产者消费者.jpg" alt=""><div></div></div></li><li>分析：<ul><li>任何时刻，只能有一个进程在缓冲区中操作。</li><li>对于“生产者”而言，缓冲区满则应等待。</li><li>对于“消费者”而言，缓冲区空则应等待。</li></ul></li><li><p>利用记录型信号量解决问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;<span class="comment">//in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。</span></span><br><span class="line">item buffer[n];<span class="comment">//缓存区大小为n，地址为[0, n-1]。</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;<span class="comment">//mutex用于互斥访问缓存区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        produce an item nextproducer;</span><br><span class="line">        ...</span><br><span class="line">        wait(empty);<span class="comment">//消耗一个empty，当empty&lt;=0时等待</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        buffer[in] = nextproducer;</span><br><span class="line">        in = (in+<span class="number">1</span>) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(full);<span class="comment">//增加一个full</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(full);<span class="comment">//消耗一个full，当full&lt;=0时等待</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        nextconsumer = buffer[out];</span><br><span class="line">        out = (out+<span class="number">1</span>) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);<span class="comment">//增加一个empty</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        produce();consumer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>互斥信号量 &amp; 资源信号量<br>互斥使用的资源设置一个互斥信号量，资源数为1。资源信号量的资源数和资源的意义有关。资源信号量的资源为1时退化成互斥信号量。<br>在使用时互斥信号量的P操作需要紧邻其对应共享资源的临界区使用，否则可能造成同步问题。比如互换上面代码的第8行和第9行之后，若生产者进程和消费者进程都只有一个，且生产者通过了<code>P(mutex)</code>，阻塞在<code>P(empty)</code>，消费者通过了<code>P(full)</code>，阻塞在<code>P(mutex)</code>，此时生产者等待消费者的<code>V(empty)</code>，消费者等待生产者的<code>V(mutex)</code>，发生死锁。而V操作不需要注意顺序。</li></ul></li><li><p>利用AND型信号量解决问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;<span class="comment">//in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。</span></span><br><span class="line">item buffer[n];<span class="comment">//缓存区大小为n，地址为[0, n-1]。</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;<span class="comment">//mutex用于互斥访问缓存区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        produce an item nextproducer;</span><br><span class="line">        ...</span><br><span class="line">        Swait(empty, mutex);<span class="comment">//消耗一个empty，当empty&lt;=0时等待</span></span><br><span class="line">        buffer[in] = nextproducer;</span><br><span class="line">        in = (in+<span class="number">1</span>) % n;</span><br><span class="line">        signal(empty, mutex);<span class="comment">//增加一个full</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(full, mutex);<span class="comment">//消耗一个full，当full&lt;=0时等待</span></span><br><span class="line">        nextconsumer = buffer[out];</span><br><span class="line">        out = (out+<span class="number">1</span>) % n;</span><br><span class="line">        signal(full, mutex);<span class="comment">//增加一个empty</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        produce();consumer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>利用管程解决问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Monitor monitor&#123;</span><br><span class="line">    item buffer[n];</span><br><span class="line">    <span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    condition notfull, notempty;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">static</span> <span class="title">put</span><span class="params">(item x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= n)</span><br><span class="line">            cwait(notfull);<span class="comment">//阻塞在队列满的条件下</span></span><br><span class="line">            buffer[in] = x;</span><br><span class="line">            in = (in+<span class="number">1</span>) % n;</span><br><span class="line">            count++;</span><br><span class="line">            csignal(notempty);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="keyword">static</span> <span class="title">get</span><span class="params">(item &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count &lt;= <span class="number">0</span>)</span><br><span class="line">                cwait(notempty);<span class="comment">//阻塞在队列空的条件下</span></span><br><span class="line">            x = buffer[out];</span><br><span class="line">            out = (out+<span class="number">1</span>) % n;</span><br><span class="line">            count--;</span><br><span class="line">            csignal(notfull);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    item x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        produce an item in nextproducer;</span><br><span class="line">        monitor.put(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    item x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        monitor.get(x);</span><br><span class="line">        consume the item in nextconsumer;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        produce();consumer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="哲学家进餐问题"><a href="#哲学家进餐问题" class="headerlink" title="哲学家进餐问题"></a>哲学家进餐问题</h3><ul><li>问题描述：五个哲学家坐在圆桌前，每人一份饭，每个哲学家两侧各有一支筷子,只有拿到左右两只筷子才能进餐，哲学家处于吃饭和思考两种状态。<br><div align="center"><img src="/2019/03-进程的描述与控制/哲学家进餐.jpg" alt=""><div></div></div></li><li>分析<ul><li>同一时刻一只筷子只能有一个哲学家拿起。</li><li>只有获得两个筷子后才能进餐。</li><li>如果每个哲学家都拿起一只筷子，都饿死。</li><li>并行程度：五只筷子允许两人同时进餐。</li></ul></li><li>利用AND型信号量解决问题<br>每次必须拿到两只筷子才能拿起，否则不拿起筷子。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Swait(chopstick[i], chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    ...</span><br><span class="line">    Ssignal(chopstick[i], chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><ul><li>问题描述：<ul><li>写者向共享数据区放数据，读者从共享数据区读数据。</li><li>多个读者可同时读取数据，多个写者不能同时写数据。<br><div align="center"><img src="/2019/03-进程的描述与控制/读者-写者.jpg" alt=""><div></div></div></li></ul></li><li>分析：<ul><li>读者进入共享数据区，写者必须等待。</li><li>读者进入共享数据区，读者可以进入。</li><li>写者进入共享数据区，读者必须等待。</li></ul></li><li><p>利用记录型信号量解决问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore readmutex = <span class="number">1</span>, writemutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(readmutex);</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            wait(writemutex);</span><br><span class="line">        readcount++;</span><br><span class="line">        signal(readmutex);</span><br><span class="line">        ...<span class="comment">//read opreation</span></span><br><span class="line">        wait(readmutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            signal(writemutex);</span><br><span class="line">        signal(readmutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(writemutex);<span class="comment">//当写者进入共享数据区，reader会阻塞在</span></span><br><span class="line">        ... <span class="comment">//write operation</span></span><br><span class="line">        signal(writemutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        reader();writer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码分析：<br>最开始并发的时候：</p><ul><li>假如读者先抢到资源，<code>readcount == 0</code>，<code>P(writemutex)</code>，<code>writer()</code>会阻塞在第20行，但其他<code>reader()</code>仍可以运行，只是不会再<code>P(writemutex)</code>。同时每个<code>reader()</code>都<code>readcount++</code>，直到<code>readcount == 0</code>时<code>V(writemutex)</code>，然后<code>writer()</code>才有可能能进入。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。</li><li>假如写者先抢到资源，<code>P(writemutex)</code>，此时<code>readcount == 0</code>，所有<code>reader()</code>阻塞在第7行。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。<br>综上，完成了要求。</li></ul></li></ul><h3 id="读者-写者问题拓展"><a href="#读者-写者问题拓展" class="headerlink" title="读者-写者问题拓展"></a>读者-写者问题拓展</h3><ul><li>问题描述：拓展就是又增加一个条件，最多只允许RN个读者同时读。</li><li><p>利用信号量集解决问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">semaphore L = RN, mx = <span class="number">1</span>;<span class="comment">//L用来控制访问数，mx控制写者访问时所有读者阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        Swait(L, <span class="number">1</span>, <span class="number">1</span>);<span class="comment">//第RN+1个读者进入时会阻塞</span></span><br><span class="line">        Swait(mx, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//mx &gt;= 1时才可以进入</span></span><br><span class="line">        ...<span class="comment">//read operation</span></span><br><span class="line">        Ssignal(L, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        Swait(mx, <span class="number">1</span>, <span class="number">1</span>; L, RN, <span class="number">0</span>);<span class="comment">//mx &gt;= 1 &amp;&amp; L &gt;= RN时进入</span></span><br><span class="line">        ...<span class="comment">//write operation</span></span><br><span class="line">        Ssignal(mx, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        reader();writer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码分析：<br>最开始并发的时候：</p><ul><li>假如读者先抢到资源，<code>L = L - 1</code>，写者阻塞在第12行，但其他<code>reader()</code>仍可以运行，直至没有读者进程在访问共享数据区。当所有的读者进程都退出时，共享数据区中停留的个进程数都为0，即重新开始。</li><li>假如写者先抢到资源，<code>mx = mx - 1</code>，所有读者进程和其他写者进程都要被阻塞，写者进程退出时，共享数据区中停留的个进程数都为0，即重新开始。</li></ul></li></ul><h3 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h3><ul><li>问题描述：一把理发椅，N把等待座位。理发师为理发椅上的顾客理发，没有顾客就在理发椅上睡觉，有一个顾客时需要叫醒理发师，多个顾客时需要在等待座位上等候。<br><div align="center"><img src="/2019/03-进程的描述与控制/理发师问题.jpg" alt=""><div></div></div></li><li>分析：<ul><li>理发椅上只能有一位顾客。</li><li>等待座位是有限缓冲区。</li><li>只要存在顾客，理发师就不能睡觉。</li></ul></li><li><p>利用记录型信号量解决问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semaphore customer = <span class="number">0</span>, barber = <span class="number">0</span>, mutex = <span class="number">1</span>; <span class="comment">//barber使理发师只能为一个顾客服务</span></span><br><span class="line"><span class="keyword">int</span> waiting = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">barber</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(customer);<span class="comment">//没有顾客的时候理发师睡觉</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        waiting –= <span class="number">1</span>;<span class="comment">//等待的人少一个</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(barber);</span><br><span class="line">        ...<span class="comment">//获得被激活进程的信息并给相应的顾客剪发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    wait(mutex);</span><br><span class="line">    <span class="keyword">if</span>(waiting &lt; CHAIRS)&#123;<span class="comment">//顾客到来的时候，还有座位就进去等待</span></span><br><span class="line">        waiting += <span class="number">1</span>;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(customer);</span><br><span class="line">        wait(barber);</span><br><span class="line">        ...  <span class="comment">//将被激活进程的信息发送给barber()</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        signal(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码分析<br>在最开始并发的时候<code>barber()</code>会等待到有顾客时才醒来。顾客一来就需要访问<code>waiting</code>，所以获得<code>mutex</code>。</p><ul><li>如果位置不够就立即释放<code>mutex</code>。</li><li>如果位置够，就让等待的人加1，再释放<code>mutex</code>。然后顾客人数<code>customer += 1</code>来激活理发师进程。理发师进程激活后会<code>V(barber)</code>，然后等待着的<code>customer()</code>进程争夺资源，争夺到<code>P(barber)</code>的进程将被激活进程的信息发送给<code>barber()</code>，<code>barber()</code>获得被激活进程的信息并给相应的顾客剪发。</li></ul></li></ul><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程之间合作完成工作不仅仅需要有时序关系，还需要进程信息交互，比如刚才的理发师问题中就设计到了信息交互。从概念上说进程通信是指进程之间的信息交换，所以信号量机制本身就涉及到了信息交换，不过我们把这种信息交换叫做低级进程通信，因为其效率低且需要用户大量的干预。真正的进程通信需要满足使用方便且能高效传输大量数据的需求。</p><h3 id="共享存储器系统"><a href="#共享存储器系统" class="headerlink" title="共享存储器系统"></a>共享存储器系统</h3><ul><li>基于共享数据结构的通信方式：诸进程公用某些数据结构来实现进行通信 ，如生产者—消费者问题中的有界缓冲区，属于低级通信方式。</li><li>基于共享存储区的通信方式：在存储器中划出一块共享存储区，诸进程通过对共享存储区中数据的读或写实现通信，此时数据的形式、位置和访问控制仍是进程实现。适用于传输大量数据，属于高级通信。</li></ul><h3 id="管道通信系统"><a href="#管道通信系统" class="headerlink" title="管道通信系统"></a>管道通信系统</h3><p>所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件。向管道提供输入的发送进程（即写进程）以字符流形式将大量的数据送入管道，而接收进程（即读进程），可从管道中接收数据。管道通信系统必须满足以下三个要求：</p><ul><li>互斥：管道的使用必须互斥。因为存数据和取数据可归于写文件的添加和删除。</li><li>同步：写进程把一定数量的数据写入管道后去睡眠，读进程读完后将其唤醒。读进程读空的管道时需要睡眠。</li><li>确定对方存在：如果写进程不存在，读进程就会一直等待。如果读进程不存在，写进程写完数据后也会一直等待，所以通信双方必须同时存在。</li></ul><h3 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a>消息传递系统</h3><p>指进程可以利用一组通信命令（原语）把数据封装在消息中传送，不需要显示的指定共享存储区或数据结构等。它隐藏了通信的细节，也是目前使用最广泛的进程间通信机制。通常有两种实现方式：</p><ul><li>直接通信方式：OS提供原语给进程使用。</li><li>间接通信方式：借助共享中间实体（称为邮箱）完成进程间的通信。<ul><li>和共享存储器系统的区别是进程不再需要指定数据的形式、位置和访问控制等，信箱内部自有实现。</li></ul></li></ul><h3 id="客户机-服务器系统"><a href="#客户机-服务器系统" class="headerlink" title="客户机-服务器系统"></a>客户机-服务器系统</h3><p>前三种都是单机下的通信机制，这种是网络环境中的通信机制。主要有套接字和RPC两种方式。</p><ul><li>套接字：一个套接字是一个通信标识类型的数据结构，包含了通信目的地址、通信端口号、通信的网络协议、进程自身的地址以及对外提供的系统调用等。使用套接字可以在不同主机上的进程建立连接进而进行通信。</li><li>RPC：Remote Procedure Call，它是一个通信协议，可以使本地进程调用其他主机的进程对程序员表现为常规方法调用。<br><div align="center"><img src="/2019/03-进程的描述与控制/rpc.jpg" alt=""><div></div></div></li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的由来"><a href="#线程的由来" class="headerlink" title="线程的由来"></a>线程的由来</h3><p>进程解决了程序不能并发执行的问题，但是由于进程是拥有资源的基本单位，所以在创建、撤销和切换时所需的时空开销很大，因为处理机势必要付出更大的代价来保存现场。所以把拥有资源和独立运行两项功能分开，让线程作为独立运行的基本单位，进程作为拥有资源的基本单位。不过线程也拥有一些能保证其独立运行的资源，如TCB。</p><h3 id="TCB（Thread-Control-Block）"><a href="#TCB（Thread-Control-Block）" class="headerlink" title="TCB（Thread Control Block）"></a>TCB（Thread Control Block）</h3><p>所有用于控制和管理线程的信息都会被记录在线程控制块中，通常包含：</p><ul><li>线程标识符：每个线程都有唯一的线程标识符。</li><li>处理机信息：包括程序计数器、状态寄存器、通用寄存器的内容。</li><li>线程运行状态：线程和进程一样也有多种运行状态，就绪、阻塞、运行等。详见<code>103-网络编程</code>。</li><li>优先级：和调度算法有关，优先级越高，得到处理机的机会越大。</li><li>线程专有存储区：用于在线程切换时保存现场状态和保存线程的统计信息。</li><li>信号屏蔽：屏蔽某些发送给线程的信号。</li><li>堆栈指针：线程调用别的过程时需要保存局部变量和返回地址等来供返回时能继续执行。</li></ul><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>线程是为了解决进程调度时过于笨重的问题，所以在不同的环境中实现线程的方式不同。根据内核能否感知到线程的存在可分为内核支持线程（Kernel Supported Threads，KST）和用户级线程（User Level Threads，ULT）。它俩的区别是能否直接调用系统服务，前者可以而后者需要借助中间系统。</p><h3 id="内核支持线程"><a href="#内核支持线程" class="headerlink" title="内核支持线程"></a>内核支持线程</h3><p>若线程是由内核直接调度，线程资源也是保存在内核空间，就可以说此类线程为内核支持线程。此类线程的创建、撤销和切换等操作都是在内核空间完成的，此时线程可以直接调用系统服务。一种可能的实现方式是在创建进程时分配一个任务数据区（Per Task Data Area，PTDA），各个线程的TCB保存在其中即可。不过仅实现内核支持线程的系统对用户进程创建的线程很不友好，每次线程调度处理机都要从用户态转换到核心态。</p><p></p><div align="center"><img src="/2019/03-进程的描述与控制/内核级线程.jpg"><div></div></div><p></p><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>用户级线程是指线程虽客观存在但对内核来说是透明的，此时不能再直接调用系统服务，间接调用系统服务需要有中间系统的支持，通常的中间系统有运行时系统和内核控制线程。</p><ul><li>运行时系统：把创建线程、撤销线程和线程同步等只能由OS内核完成的操作封装起来作为运行时系统，而运行时系统停留在用户空间供其他进程调用来实现线程调度。<br><div align="center"><img src="/2019/03-进程的描述与控制/运行时系统.jpg" alt=""><div></div></div></li><li>内核控制线程：这种线程又被称作轻量进程（Light Weight Process，LWP），它既可以共享进程的资源，又可以使用内核提供的服务。虽然下图中LWP和用户线程是1对1关系，但实际上多个用户级线程可以复用一个LWP，但每个轻型线程都要连接到一个内核线程中。所以此种方式系统需要同时实现内核支持线程。<br><div align="center"><img src="/2019/03-进程的描述与控制/内核控制线程.png" width="80%"><div></div></div></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 10 2019 15:42:39 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;进程概念&quot;&gt;&lt;a href=&quot;#进程概念&quot; class=&quot;headerlink&quot; title=&quot;进程概念&quot;&gt;&lt;/a&gt;进程概念&lt;/h2&gt;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>01-操作系统引论</title>
    <link href="https://isjinhao.github.io/2019/01-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA/"/>
    <id>https://isjinhao.github.io/2019/01-操作系统引论/</id>
    <published>2019-02-06T05:25:58.829Z</published>
    <updated>2019-03-10T05:34:42.767Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 10 2019 15:42:39 GMT+0800 (GMT+08:00) --><h2 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h2><p>操作系统（Operating System，简称OS）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是管理硬件设备来提高利用率和吞吐量，同时为用户和应用系统提供易于使用的接口。</p><ul><li>提高利用率：使系统中各设备的空闲时间尽可能短。</li><li>提高吞吐量：使单位时间内完成的业务更多。</li><li>提供易于使用的接口：即是方便使用计算机资源。例如没有操作系统，操纵计算机可能需要用户输入二进制代码，有了操作系统，用户可以点击图标，操作系统就会将其转换成二进制代码。</li></ul><h2 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h2><ul><li>方便性：即对用户和应用程序提供易于使用的接口。</li><li>有效性：提高利用率和吞吐量。</li><li>可扩充性：计算机硬件和体系结构等都在不断发展中，OS需要有好的可扩充性来满足不断发展的需求。</li><li>开放性：为了使计算机的应用环境从单机转换成网络，OS需要满足相应的软硬件标准来实现设备的互联。</li></ul><h2 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h2><ul><li>提供易于使用的接口，如Shell、图形界面等。</li><li>管理计算机所有的资源，负责计算机系统全部资源的分配、控制、调度和回收。</li><li>隐蔽硬件特性，如计算2*3，某些机器的实现是使用加法器做2+2+2，而有的机器是乘法器实现2*3。操作系统屏蔽这些细节，用户只需要输入2*3就能完成。</li></ul><h2 id="未配置操作系统的计算机系统"><a href="#未配置操作系统的计算机系统" class="headerlink" title="未配置操作系统的计算机系统"></a>未配置操作系统的计算机系统</h2><ul><li>人工操作：程序员把程序和数据通过穿孔的方式记录在纸带上，再启动机器读入纸带，运行完成并取走计算结果后，才允许下一个用户上机。缺点：<ul><li>用户独占整机：计算机上的资源为上机用户独占。</li><li>设备空闲率高：用户装卡，卸卡等人工操作时，设备资源是空闲的。</li></ul></li><li>脱机输入/输出（Off-Line I/O）：为了解决人机矛盾及CPU、I/O等设备之间速度的不匹配。它是先把纸带通过输入设备在外围机（与主机相比处于次要地位的计算机）的控制下输入到磁带上，当CPU需要这些信息时再从磁带上高速地调取。类似的，在输出时把信息输出到磁盘中，在外围机的控制下通过输出设备输出。也就是说主机直接对磁盘进行操作，输入输出和程序运行脱离。<ul><li>減少了CPU的空闲时间：主机不必依赖输入输出，可以从磁盘中读取数据。</li><li>提升了I/O速度：主机读取信息不再是从卡片中读取，从磁盘读取速度较快。<div align="center"><img src="/2019/01-操作系统引论/脱机输入输出.jpg"></div></li></ul></li></ul><h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><p>为了提升计算机资源的利用率和提升计算机的吞吐量研发出了批操作系统。</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>作业：程序+数据+作业说明书（系统根据说明书来对程序的运行进行控制）。</li><li>周转时间：从作业进入系统到作业完成退出系统所用的时间。</li><li>平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NT_i]​$</li><li>带权周转时间：作业的周转时间（$T​$）和系统为它提供服务的时间（$T_S​$）。$W=\frac{T}{T_s}​$</li><li>平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NW_i]​$</li></ul><h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><p>设计一个常驻内存的程序（监督程序），操作员有选择地把若干作业合成一批，安装输入设备上，并启动监督程序，然后由监督程序自动控制这批作业运行，从而减少部分人工干预，有效地缩短了作业运行前的准备时间，相对的提高CPU的利用率。同一时刻只有一个硬件在运行。特点：自动性、顺序性、单道性。缺点：</p><ul><li>I/O的慢速与CPU 的高速不匹配，且输入时需要CPU等待。</li><li>用户交互性差。作业安装输入后，就不能再交互。<div align="center"><img src="/2019/01-操作系统引论/单道批处理系统.jpg"></div></li></ul><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><p>把一个以上的作业存放在主存中，并且同时处于运行状态，使这些作业共享处理机和外部设备等其它系统资源。对于一个单处理机系统来说，作业同时处于运行状态只是宏观的概念，其含义是指每个作业都已开始运行，但尚未完成。就微观而言，在任意特定时刻，处理机上运行的作业只有一个。特点：多道性、无序性、调度性。优缺点：</p><ul><li>优点：资源利用率高、系统吞吐量大。</li><li>缺点：作业仍然要排队处理，所以平均周转时间长、无交互能力。<br>此时如何调度程序已经不是再用一张简单的流程图能说明了，<a href="02-进程&amp;线程.md">第二章</a>会有介绍。下图只是说明处理器利用率高。<br><div align="center"><img src="/2019/01-操作系统引论/多道批处理.jpg"></div><h3 id="举例证明资源利用率高和系统吞吐量大"><a href="#举例证明资源利用率高和系统吞吐量大" class="headerlink" title="举例证明资源利用率高和系统吞吐量大"></a>举例证明资源利用率高和系统吞吐量大</h3></li></ul><p>设内存中有三道程序 A、B、C，它们的计算和I/O操作的时间如下表所示：</p><table><thead><tr><th style="text-align:center">程序操作</th><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th></tr></thead><tbody><tr><td style="text-align:center">计算</td><td style="text-align:center">30</td><td style="text-align:center">60</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">I/O</td><td style="text-align:center">40</td><td style="text-align:center">30</td><td style="text-align:center">40</td></tr><tr><td style="text-align:center">计算</td><td style="text-align:center">10</td><td style="text-align:center">10</td><td style="text-align:center">20</td></tr></tbody></table><ul><li>单道<div align="center"><img src="/2019/01-操作系统引论/单道举例.jpg" width="100%"></div></li><li>多道</li></ul><div align="center"><img src="/2019/01-操作系统引论/多道举例.jpg" width="100%"></div><h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><p>批处理系统中，作业一旦提交就不能进行更改，所以人机交互性很差。为了满足人机交互的需求诞生分时系统。每一个用户通过一台终端与计算机相连，以交互式的命令使用系统，采用分享CPU的方法，由于CPU的速度比人在终端输入指令的时间快得多，所以用户感到自己独占了整个计算机系统。系统规定一个称之为“时间片”的时间单位，所有终端用户轮流享用一个时间片的CPU。需要解决的问题：</p><ul><li>及时接受：所有终端用户输入的信息都要能够被及时的送到处理器上。所以主机会以很快的速度循环扫描各个终端。每个终端也要拥有缓存区来保存输入的信息。</li><li>及时处理：用户需要能对自己的作业及其允许及时地实施控制。所以所有的作业必须驻留在内存中，因此批作业系统不能被使用。它采用的方式是：作业直接进入内存。但每个用户只连续使用一个“时间片”的时间，对所有用户进行循环。这样每个用户都能及时地与自己的作业进行交互。<div align="center"><img src="/2019/01-操作系统引论/分时系统.jpg"></div></li></ul><h3 id="分时系统与多道批处理系统的不同特性"><a href="#分时系统与多道批处理系统的不同特性" class="headerlink" title="分时系统与多道批处理系统的不同特性"></a>分时系统与多道批处理系统的不同特性</h3><ul><li>多路性：允许多个用户共享一台计算机，提高资源利用率。</li><li>独立性：每个用户之间互不干扰，感觉就是一个人在独占一台计算机。</li><li>及时性：用户的请求能在很短的时间内得到回应。</li><li>交互性：用户可以通过终端和计算机进行及时交互。</li></ul><h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2><p>指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。实时系统强调程序运行的时间，它需对接收到的某些信号做出及时地反应。大多数的实时系统是专用系统，如：工业（武器）控制系统、信息查询系统、多媒体系统、嵌入式系统等。最大的特点就是可靠性：系统必须高度可靠，因为任何可能的差错都可能带来灾难性后果，所以系统一般都有多级容错措施。</p><ul><li>按是否周期执行分类：<ul><li>周期性实时任务：如外部设备周期性地发出状态信号给计算机使其状态能被实时感知。</li><li>非周期性实时任务：提交给系统时需要指定开始截止时间和完成截止时间。</li></ul></li><li>硬实时任务&amp;软实时任务：<ul><li>硬实时任务（Hard Real-time Task）：截止时间到达时任务必须完成，比如武器控制系统。</li><li>软实时任务（Soft Real-time Task）：截止时间到达时任务没有完成没有太大影响，比如多媒体系统。</li></ul></li></ul><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ul><li>进程：在系统中能独立运行并作为资源分配的基本单位。</li><li>线程：独立运行的基本单位，比进程更小，基本上不拥有系统资源。通常在一个进程中包含了若干个线程。</li></ul><h2 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a>操作系统的基本特性</h2><ul><li>并发：宏观上是多个进程同时运行，微观上是每一时刻只有一道进程在执行。</li><li>共享：系统中的资源可供内存中多个并发执行的进程（线程）共同使用。有两种共享方式：<ul><li>互斥共享方式，如打印机；</li><li>同时访问方式，如共享文件夹、网络资源。</li></ul></li><li>虚拟：通过某种技术把一个物理实体变为若干个逻辑上的对应物。这样可以避免一个进程单独占用某个物理设备，一个物理设备被分配给多个进程便可以提升物理设备的使用率。</li><li>不确定性（异步性）：进程以人们不可预知的速度向前推进，即为进程的不确定性。这样的话很可能是先进入内存的作业后完成；而后进入内存的作业先完成。尽管如此，但只要有合理的进程同步方式且运行环境相同，作业经多次运行，都会获得完全相同的结果。因此，异步运行方式是允许的。</li></ul><h2 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h2><h3 id="传统操作系统结构"><a href="#传统操作系统结构" class="headerlink" title="传统操作系统结构"></a>传统操作系统结构</h3><ul><li>无结构OS：<ul><li>关注功能的实现和获得高的效率操作系统是为数众多的一组过程的集合，各过程之间可以相互调用，在操作系统内部不存在任何结构。</li><li>程序设计的技巧，只是如何编制紧凑的程序，以便于有效地利用内存。</li><li>操作系统既庞大又杂乱，缺乏清晰的程序结构。</li><li>程序错误很多，给调试工作带来很多困难；另一方面也使程序难以阅读和理解，增加了维护人员的负担。</li></ul></li><li>模块化结构OS<ul><li>模块化程序设计技术，是最早（20世纪60年代）出现的一种程序设计技术。该技术是基于“分解”和“模块”原则来控制大型软件的复杂度的。</li><li>将OS按其功能划分为若干个具有一定独立性和大小的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口， 使各模块之间能通过该接口实现交互，然后再进一步将各模块细分为若干个具有一定管理功能的子模块。（会导致模块之间的依赖关系很重，OS结构不清晰）</li><li>若子模块较大时，再进一步将它细分。<div align="center"><img src="/2019/01-操作系统引论/模块式os结构.jpg"></div></li></ul></li><li>分层式结构OS：<ul><li>改进设计方式，使每一步设计都是建立在可靠的基础上一层一层地自底向上增添软件层，每一层都实现若干功能，最后总能构成一个能满足需要的OS。</li><li>每一层都仅使用其底层所提供的功能和服务，这样可使系统的调试和验证都变得容易。</li><li>一旦发现错误后，通常该错误只会局限于某一层，因为它与所有其高层的软件无关，而此层以下的各层软件，又都经过仔细的调试，bug修复较为容易。</li></ul></li></ul><h3 id="客户-服务器结构"><a href="#客户-服务器结构" class="headerlink" title="客户/服务器结构"></a>客户/服务器结构</h3><ul><li>为了提高OS的灵活性和可扩充性而将OS划分为两部分。</li><li>一部分是用于提供各种服务的一组服务器（进程），所有这些服务器（进程）都运行在用户态。当有一用户进程（现在称为客户进程）要求读文件的一个盘块时，该进程便向文件服务器（进程）发出一个请求；当服务器完成了该客户的请求后，便给该客户回送一个响应。</li><li>另一部分是内核，用来处理客户和服务器之间的通信， 即由内核来接收客户的请求，再将该请求送至相应的服务器；同时它也接收服务器的应答， 并将此应答回送给请求客户。</li><li>此外，在内核中还应具有其它一些机构，用于实现与硬件紧密相关的和一些较基本的功能。</li></ul><h3 id="面向对象结构（20世纪80年代）"><a href="#面向对象结构（20世纪80年代）" class="headerlink" title="面向对象结构（20世纪80年代）"></a>面向对象结构（20世纪80年代）</h3><ul><li>该技术是基于“抽象”和“隐蔽”原则来控制大型软件的复杂度的。所谓对象，是指在现实世界中具有相同属性、服从相同规则的一系列事物的抽象，而把其中的具体事物称为对象的实例。</li><li>OS中的各类实体如进程、线程、消息、存储器等，都使用了对象这一概念，相应地，便有进程对象、线程对象、 存储器对象等。<ul><li>由于隐蔽了表示实体的数据和操作，因而可以改变对象的表示而不会影响其它部分， 从而可以方便地改变老的对象和增加新的对象。</li><li>继承性。继承性是面向对象技术所具有的重要特性。继承性是指子对象可以继承父对象的属性，这样，在创建一个新的对象时， 便可减少大量的时空开销。</li><li>正确性和可靠性。由于对象是构成操作系统的基本单元，可以独立地对它进行测试，这样，比较易于保证其正确性和可靠性，从而比较容易保证整个系统的正确性和可靠性。</li></ul></li></ul><h3 id="微服务结构（20世纪90年代）"><a href="#微服务结构（20世纪90年代）" class="headerlink" title="微服务结构（20世纪90年代）"></a>微服务结构（20世纪90年代）</h3><ul><li>能有效支持多处理机，适用于分布式系统环境。</li><li>以微内核为操作系统核心，以客户/服务器为基础，采用了面向对象的程序设计方法。<ul><li>所谓微内核技术，是指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS(程序)不同， 它更小更精炼，它不仅运行在核心态，而且开机后常驻内存， 它不会因内存紧张而被换出内存。</li><li>微内核并非是一个完整的OS， 而只是为构建通用OS提供一个重要基础。</li><li>在微内核OS结构中，通常都采用了客户/服务器模式，因此OS的大部分功能和服务，都是由若干服务器来提供的， 如文件服务器、作业服务器和网络服务器等。</li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 10 2019 15:42:39 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;操作系统的定义&quot;&gt;&lt;a href=&quot;#操作系统的定义&quot; class=&quot;headerlink&quot; title=&quot;操作系统的定义&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
