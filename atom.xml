<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ISJINHAO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://isjinhao.github.io/"/>
  <updated>2019-08-28T07:50:11.965Z</updated>
  <id>https://isjinhao.github.io/</id>
  
  <author>
    <name>ISJINHAO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>07-中间件</title>
    <link href="https://isjinhao.github.io/2019/07-%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    <id>https://isjinhao.github.io/2019/07-中间件/</id>
    <published>2019-08-22T08:18:49.000Z</published>
    <updated>2019-08-28T07:50:11.965Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --><h2 id="消息队列的作用"><a href="#消息队列的作用" class="headerlink" title="消息队列的作用"></a>消息队列的作用</h2><ul><li>削峰：当大量请求到来时，先存入消息队列中，在异步的去消费，可以防止系统的崩溃。</li><li>解耦：消费者无需关注消息是从哪个生产者发出的，它只需要监听自己的队列接收消息即可。</li><li>异步：用户的请求将消息提交到队列中然后就可以返回，剩下的只需要等待消费被消费，如发送验证码。</li></ul><h2 id="RabbitMQ消息模型"><a href="#RabbitMQ消息模型" class="headerlink" title="RabbitMQ消息模型"></a>RabbitMQ消息模型</h2><h3 id="测试的配置"><a href="#测试的配置" class="headerlink" title="测试的配置"></a>测试的配置</h3><h4 id="pom文件"><a href="#pom文件" class="headerlink" title="pom文件"></a>pom文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.rabbitmq<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>itcast-rabbitmq<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-lang3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>3.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="RabbitMQ连接的工具类"><a href="#RabbitMQ连接的工具类" class="headerlink" title="RabbitMQ连接的工具类"></a>RabbitMQ连接的工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//定义连接工厂</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line">        <span class="comment">//设置服务地址</span></span><br><span class="line">        factory.setHost(<span class="string">"192.168.56.101"</span>);</span><br><span class="line">        <span class="comment">//端口</span></span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line">        <span class="comment">//设置账号信息，用户名、密码、vhost</span></span><br><span class="line">        factory.setVirtualHost(<span class="string">"/leyou"</span>);</span><br><span class="line">        factory.setUsername(<span class="string">"leyou"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"leyou"</span>);</span><br><span class="line">        <span class="comment">// 通过工程获取连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息模型类别"><a href="#消息模型类别" class="headerlink" title="消息模型类别"></a>消息模型类别</h3><h4 id="基本消息模型"><a href="#基本消息模型" class="headerlink" title="基本消息模型"></a>基本消息模型</h4><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/2019-08-25_094042.jpg"></div><br>- P（producer/ publisher）：生产者，一个发送消息的用户应用程序。<br><br>- C（consumer）：消费者，消费和接收有类似的意思，消费者是一个主要用来等待接收消息的用户应用程序<br><br>- 队列（红色区域）：rabbitmq内部类似于邮箱的一个概念。虽然消息流经rabbitmq和你的应用程序，但是它们只能存储在队列中。队列只受主机的内存和磁盘限制，实质上是一个大的消息缓冲区。许多生产者可以发送消息到一个队列，许多消费者可以尝试从一个队列接收数据。<br><br>生产者将消息发送到队列，消费者从队列中获取消息，队列是存储消息的缓冲区。<br><br>##### 生产者<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"simple_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 从连接中创建通道，这是完成大部分API的地方。</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明（创建）队列，必须声明队列才能够发送消息，我们可以把消息发送到队列中。</span></span><br><span class="line">        <span class="comment">// 声明一个队列是幂等的 - 只有当它不存在时才会被创建</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>##### 消费者<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"simple_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接以及mq通道</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 从连接中创建通道，这是完成大部分API的地方。</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 声明（创建）队列，必须声明队列才能够发送消息，我们可以把消息发送到队列中。</span></span><br><span class="line">        <span class="comment">// 声明一个队列是幂等的 - 只有当它不存在时才会被创建</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"Hello World!"</span>;</span><br><span class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### work消息模型<br><br><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/2019-08-25_094457.jpg"></div><br>工作队列，又称任务队列。主要思想就是避免执行资源密集型任务时，必须等待它执行完成。相反我们稍后完成任务，我们将任务封装为消息并将其发送到队列。 在后台运行的工作进程将获取任务并最终执行作业。当你运行许多消费者时，任务将在他们之间共享，但是<strong>一个消息只能被一个消费者获取</strong>。<br><br>##### 生产者<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_work_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 循环发布任务</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 消息内容</span></span><br><span class="line">            String message = <span class="string">"task .. "</span> + i;</span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">            System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(i * <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭通道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>##### 消费者<br><br>- 性能差的消费者<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_work_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者1] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 模拟完成任务的耗时：1000ms</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 手动ACK</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列。</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>- 性能好的消费者<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"test_work_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者2] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">                <span class="comment">// 手动ACK</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列。</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>##### 结果<br><br><div align="center"><img width="100%" src="//isjinhao.github.io/2019/07-中间件/2019-08-25_095904.jpg"></div><br>可以发现，两个消费者各自消费了25条消息，而且各不相同，这就实现了任务的分发。<br><br>##### 能者多劳<br><br>我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ一次不要向工作人员发送多于一条消息。 或者换句话说，不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/07-中间件/2019-08-25_100603.jpg"></div><br>再次测试：<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/07-中间件/2019-08-25_100830.jpg"></div><br>#### 订阅模型-Fanout<br><br>Fanout，也称为广播。<br><br><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/2019-08-25_101011.jpg"></div><br>在广播模式下，消息发送流程是这样的：<br><br>- 可以有多个消费者<br>- 每个<strong>消费者有自己的queue</strong>（队列）<br>- 每个<strong>队列都要绑定到Exchange</strong>（交换机）<br>- <strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。<br>- 交换机把消息发送给绑定过的所有队列<br>- 队列的消费者都能拿到消息。实现一条消息被多个消费者消费<br><br>##### 生产者<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"fanout_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为fanout</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"fanout"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"Hello everyone"</span>;</span><br><span class="line">        <span class="comment">// 发布消息到Exchange</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">""</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [生产者] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>##### 消费者<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"fanout_exchange_queue_1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"fanout_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者1] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"fanout_exchange_queue_2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"fanout_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 绑定队列到交换机</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">""</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者2] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，手动返回完成</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/07-中间件/2019-08-25_101417.jpg"></div><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/07-中间件/2019-08-25_101453.jpg"></div><br>#### 订阅模型-Direct<br><br>在路由模式中，我们将添加一个功能 - 我们将只能订阅一部分消息。 例如，我们只能将重要的错误消息引导到日志文件（以节省磁盘空间），同时仍然能够在控制台上打印所有日志消息。<br><br>但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）。消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。<br><br><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/2019-08-25_101653.jpg"></div><br>- P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。<br><br>- X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列<br><br>- C1：消费者，其所在队列指定了需要routing key 为 error 的消息<br><br>- C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息<br><br>##### 生产者<br><br>此处我们模拟商品的增删改，发送消息的RoutingKey分别是：insert、update、delete<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"direct_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为direct</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"direct"</span>);</span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"商品新增了， id = 1001"</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routing key 为：insert ,代表新增商品</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">"insert"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [商品服务：] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>##### 消费者<br><br>- 只接收两种类型的消息：更新商品和删除商品。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"direct_exchange_queue_1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"direct_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。假设此处需要update和delete消息</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"update"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"delete"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者1] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>- 接收所有类型的消息：新增商品，更新商品和删除商品。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"direct_exchange_queue_2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"direct_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"insert"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"update"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"delete"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者2] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### 订阅模型-Topic<br><br><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！<br><br><code>Routingkey</code> 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： <code>item.insert</code><br><br>通配符规则：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`#`：匹配一个或多个词</span><br><span class="line"></span><br><span class="line">`*`：匹配不多不少恰好1个词</span><br></pre></td></tr></table></figure><br><br>举例：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`audit.#`：能够匹配`audit.irs.corporate` 或者 `audit.irs`</span><br><span class="line"></span><br><span class="line">`audit.*`：只能匹配`audit.irs`</span><br></pre></td></tr></table></figure><br><br><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/2019-08-25_102200.jpg"></div><br>在这个例子中，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：<code>&lt;speed&gt;.&lt;color&gt;.&lt;species&gt;</code>。<br><br>我们创建了三个绑定：Q1绑定了绑定键“<em> .orange.</em>”，Q2绑定了“<em>.</em>.rabbit”和“lazy.＃”。<br><br>Q1匹配所有的橙色动物。<br><br>Q2匹配关于兔子以及懒惰动物的消息。<br><br>##### 生产者<br><br>使用topic类型的Exchange，发送消息的routing key有3种： <code>item.isnert</code>、<code>item.update</code>、<code>item.delete</code>：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"topic_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明exchange，指定类型为topic</span></span><br><span class="line">        channel.exchangeDeclare(EXCHANGE_NAME, <span class="string">"topic"</span>);</span><br><span class="line">        <span class="comment">// 消息内容</span></span><br><span class="line">        String message = <span class="string">"新增商品 : id = 1001"</span>;</span><br><span class="line">        <span class="comment">// 发送消息，并且指定routing key 为：insert ,代表新增商品</span></span><br><span class="line">        channel.basicPublish(EXCHANGE_NAME, <span class="string">"item.insert"</span>, <span class="keyword">null</span>, message.getBytes());</span><br><span class="line">        System.out.println(<span class="string">" [商品服务：] Sent '"</span> + message + <span class="string">"'"</span>);</span><br><span class="line"></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>##### 消费者<br><br>我们此处假设消费者1只接收两种类型的消息：更新商品和删除商品<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"topic_exchange_queue_1"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"topic_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。需要 update、delete</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"item.update"</span>);</span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"item.delete"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者1] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>接收所有类型的消息：新增商品，更新商品和删除商品。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"topic_exchange_queue_2"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String EXCHANGE_NAME = <span class="string">"topic_exchange_test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connection = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 获取通道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绑定队列到交换机，同时指定需要订阅的routing key。订阅 insert、update、delete</span></span><br><span class="line">        channel.queueBind(QUEUE_NAME, EXCHANGE_NAME, <span class="string">"item.*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [消费者2] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，自动ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>## 消息确认机制<br><br>### 消费者<br><br>消息一旦被消费者接收，队列中的消息就会被删除。那么问题来了：RabbitMQ怎么知道消息被接收了呢？如果消费者领取消息后，还没执行操作就挂掉了呢？或者抛出了异常？消息消费失败，但是RabbitMQ无从得知，这样消息就丢失了！<br><br>因此，RabbitMQ有一个ACK机制。当消费者获取消息后，会向RabbitMQ发送回执ACK，告知消息已经被接收。不过这种回执ACK分两种情况：<br><br>- 自动ACK：消息一旦被接收，消费者自动发送ACK<br>- 手动ACK：消息接收后，不会发送ACK，需要手动调用<br><br>大家觉得哪种更好呢？这需要看消息的重要性：<br><br>- 如果消息不太重要，丢失也没有影响，那么自动ACK会比较方便<br>- 如果消息非常重要，不容丢失。那么最好在消费完成后手动ACK，否则接收消息后就自动ACK，RabbitMQ就会把消息从队列中删除。如果此时消费者宕机，那么消息就丢失了。<br><br>如果要手动ACK，需要改动我们的代码：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"simple_queue"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] argv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 获取到连接</span></span><br><span class="line">        Connection connecti on = ConnectionUtil.getConnection();</span><br><span class="line">        <span class="comment">// 创建通道</span></span><br><span class="line">        <span class="keyword">final</span> Channel channel = connection.createChannel();</span><br><span class="line">        <span class="comment">// 声明队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 定义队列的消费者</span></span><br><span class="line">        DefaultConsumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</span><br><span class="line">            <span class="comment">// 获取消息，并且处理，这个方法类似事件监听，如果有消息的时候，会被自动调用</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, BasicProperties properties,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                <span class="comment">// body 即消息体</span></span><br><span class="line">                String msg = <span class="keyword">new</span> String(body);</span><br><span class="line">                System.out.println(<span class="string">" [x] received : "</span> + msg + <span class="string">"!"</span>);</span><br><span class="line">                <span class="comment">// 手动进行ACK</span></span><br><span class="line">                channel.basicAck(envelope.getDeliveryTag(), <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">// 监听队列，第二个参数false，手动进行ACK</span></span><br><span class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">false</span>, consumer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>手动拒绝或不成功主要使用以下方法：<br><br>- basicRecover：是路由不成功的消息可以使用recovery重新发送到队列中。<br>- basicReject：是接收端告诉服务器这个消息我拒绝接收，不处理，可以设置是否放回到队列中还是丢掉，而且只能一次拒绝一个消息，官网中有明确说明不能批量拒绝消息，为解决批量拒绝消息才有了basicNack。<br>- basicNack：可以一次拒绝N条消息，客户端可以设置basicNack方法的multiple参数为true，服务器会拒绝指定了delivery_tag的所有未确认的消息(tag是一个64位的long值，最大值是9223372036854775807)。<br><br><br><br>### 生产者<br><br>#### 事务机制<br><br>RabbitMQ中与事务机制有关的方法有三个：txSelect()、txCommit()以及txRollback()、txSelect用于将当前channel设置成transaction模式，txCommit用于提交事务，txRollback用于回滚事务，在通过txSelect开启事务之后，我们便可以发布消息给broker代理服务器了，如果txCommit提交成功了，则消息一定到达了broker了，如果在txCommit执行之前broker异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback回滚事务了。关键代码：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">channel.txSelect();</span><br><span class="line">channel.basicPublish(ConfirmConfig.exchangeName, ConfirmConfig.routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, ConfirmConfig.msg_10B.getBytes());</span><br><span class="line">channel.txCommit();</span><br></pre></td></tr></table></figure><br><br>通过wirkshark抓包（<a href="http://ip.addr%3D%3Dxxx.xxx.xxx.xxx/" target="_blank" rel="noopener">ip.addr==xxx.xxx.xxx.xxx</a> &amp;&amp; amqp）：<br><br><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/20170217163039667.png"></div><br>可以看到：带事务的多了四个步骤：<br><br>- client发送Tx.Select<br>- broker发送Tx.Select-Ok(之后publish)<br>- client发送Tx.Commit<br>- broker发送Tx.Commit-Ok<br><br>下面我们来看下事务回滚是什么样子的。关键代码如下：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    channel.txSelect();</span><br><span class="line">    channel.basicPublish(exchange, routingKey, MessageProperties.PERSISTENT_TEXT_PLAIN, msg.getBytes());</span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">    channel.txCommit();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">    channel.txRollback();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>同样通过wireshark抓包可以看到：<br><br><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/20170217163110083.png"></div><br>代码中先是发送了消息至broker中但是这时候发生了异常，之后在捕获异常的过程中进行事务回滚。<br><br>事务确实能够解决producer与broker之间消息确认的问题，只有消息成功被broker接受，事务提交才能成功，否则我们便可以在捕获异常进行事务回滚操作同时进行消息重发，但是使用事务机制的话会降低RabbitMQ的性能，那么有没有更好的方法既能保障producer知道消息已经正确送到，又能基本上不带来性能上的损失呢？从AMQP协议的层面看是没有更好的方法，但是RabbitMQ提供了一个更好的方案，即将channel信道设置成confirm模式。<br><br>#### 信道确认机制<br><br>生产者将信道设置成confirm模式，一旦信道进入confirm模式，所有在该信道上面发布的消息都会被指派一个唯一的ID（从1开始），一旦消息被投递到所有匹配的队列之后，broker就会发送一个确认给生产者（包含消息的唯一ID），这就使得生产者知道消息已经正确到达目的队列了，如果消息和队列是可持久化的，那么确认消息会将消息写入磁盘之后发出，broker回传给生产者的确认消息中deliver-tag域包含了确认消息的序列号，此外broker也可以设置basic.ack的multiple域，表示到这个序列号之前的所有消息都已经得到了处理。<br><br>confirm模式最大的好处在于他是异步的，一旦发布一条消息，生产者应用程序就可以在等信道返回确认的同时继续发送下一条消息，当消息最终得到确认之后，生产者应用便可以通过回调方法来处理该确认消息，如果RabbitMQ因为自身内部错误导致消息丢失，就会发送一条nack消息，生产者应用程序同样可以在回调方法中处理该nack消息。<br><br>在channel 被设置成 confirm 模式之后，所有被 publish 的后续消息都将被 confirm（即 ack） 或者被nack一次。但是没有对消息被 confirm 的快慢做任何保证，并且同一条消息不会既被 confirm又被nack 。<br><br>##### 开启confirm模式的方法<br><br>生产者通过调用channel的confirmSelect方法将channel设置为confirm模式，如果没有设置no-wait标志的话，broker会返回confirm.select-ok表示同意发送者将当前channel信道设置为confirm模式。从目前RabbitMQ最新版本3.6来看，如果调用了channel.confirmSelect方法，默认情况下是直接将no-wait设置成false的，也就是默认情况下broker是必须回传confirm.select-ok的，注：已经在transaction事务模式的channel是不能再设置成confirm模式的，即这两种模式是不能共存的。<br><br>##### confirm实现<br><br>对于固定消息体大小和线程数，如果消息持久化，生产者confirm(或者采用事务机制)，消费者ack那么对性能有很大的影响。消息持久化的优化没有太好方法，用更好的物理存储（SAS, SSD, RAID卡）总会带来改善。生产者confirm这一环节的优化则主要在于客户端程序的优化之上。归纳起来，客户端实现生产者confirm有三种编程方式：<br><br>- 普通confirm模式：每发送一条消息后，调用waitForConfirms()方法，等待服务器端confirm。实际上是一种串行confirm了。<br>- 批量confirm模式：每发送一批消息后，调用waitForConfirms()方法，等待服务器端confirm。<br>- 异步confirm模式：提供一个回调方法，服务端confirm了一条或者多条消息后Client端会回调这个方法。<br><br>###### 普通模式<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是java原生类支持RabbitMQ，直接运行该类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfirmSender1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"confirm"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 创建连接连接到RabbitMQ</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置RabbitMQ所在主机ip或者主机名</span></span><br><span class="line">        factory.setUsername(<span class="string">"guest"</span>);</span><br><span class="line">        factory.setPassword(<span class="string">"guest"</span>);</span><br><span class="line">        factory.setHost(<span class="string">"127.0.0.1"</span>);</span><br><span class="line">        factory.setVirtualHost(<span class="string">"/"</span>);</span><br><span class="line">        factory.setPort(<span class="number">5672</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个连接</span></span><br><span class="line">        Connection connection = factory.newConnection();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个频道</span></span><br><span class="line">        Channel channel = connection.createChannel();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指定一个队列</span></span><br><span class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 发送的消息</span></span><br><span class="line">        String message = <span class="string">"This is a confirm message！"</span>;</span><br><span class="line"></span><br><span class="line">        channel.confirmSelect();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//发送持久化消息</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//第一个参数是exchangeName(默认情况下代理服务器端是存在一个""名字的exchange的,</span></span><br><span class="line">            <span class="comment">//因此如果不创建exchange的话我们可以直接将该参数设置成"",如果创建了exchange的话</span></span><br><span class="line">            <span class="comment">//我们需要将该参数设置成创建的exchange的名字),第二个参数是路由键</span></span><br><span class="line">            channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, MessageProperties.PERSISTENT_BASIC, (<span class="string">" Confirm模式， 第"</span> + (i + <span class="number">1</span>) + <span class="string">"条消息"</span>).getBytes());</span><br><span class="line">            <span class="keyword">if</span> (channel.waitForConfirms()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"发送成功"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 进行消息重发</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"执行waitForConfirms耗费时间: "</span> + (System.currentTimeMillis() - start) + <span class="string">"ms"</span>);</span><br><span class="line">        <span class="comment">// 关闭频道和连接</span></span><br><span class="line">        channel.close();</span><br><span class="line">        connection.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>###### 批量confirm模式<br><br>客户端程序需要定期（每隔多少秒）或者定量（达到多少条）或者两则结合起来publish消息，然后等待服务器端confirm, 相比普通confirm模式，批量极大提升confirm效率，但是问题在于一旦出现confirm返回false或者超时的情况时，客户端需要将这一批次的消息全部重发，这会带来明显的重复消息数量，并且，当消息经常丢失时，批量confirm性能应该是不升反降的。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">channel.confirmSelect();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>;i++)&#123;</span><br><span class="line">     channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, MessageProperties.PERSISTENT_BASIC, (<span class="string">" Confirm模式， 第"</span> + (i + <span class="number">1</span>) + <span class="string">"条消息"</span>).getBytes());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(channel.waitForConfirms())&#123;</span><br><span class="line">    System.out.println(<span class="string">"发送成功"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">// 进行消息重发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>###### 异步confirm模式<br><br>Channel对象提供的ConfirmListener()回调方法只包含deliveryTag（当前Chanel发出的消息序号），我们需要自己为每一个Channel维护一个unconfirm的消息序号集合，每publish一条数据，集合中元素加1，每回调一次handleAck方法，unconfirm集合删掉相应的一条（multiple=false）或多条（multiple=true）记录。从程序运行效率上看，这个unconfirm集合最好采用有序集合SortedSet存储结构。实际上，SDK中的waitForConfirms()方法也是通过SortedSet维护消息序号的。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SortedSet&lt;Long&gt; confirmSet = Collections.synchronizedSortedSet(<span class="keyword">new</span> TreeSet&lt;Long&gt;());</span><br><span class="line">channel.confirmSelect();</span><br><span class="line">channel.addConfirmListener(<span class="keyword">new</span> ConfirmListener() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleAck</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                  confirmSet.headSet(deliveryTag + <span class="number">1L</span>).clear();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    confirmSet.remove(deliveryTag);</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleNack</span><span class="params">(<span class="keyword">long</span> deliveryTag, <span class="keyword">boolean</span> multiple)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">"Nack, SeqNo: "</span> + deliveryTag + <span class="string">", multiple: "</span> + multiple);</span><br><span class="line">             <span class="keyword">if</span> (multiple) &#123;</span><br><span class="line">                 confirmSet.headSet(deliveryTag + <span class="number">1L</span>).clear();</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  confirmSet.remove(deliveryTag);</span><br><span class="line">              &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">long</span> nextSeqNo = channel.getNextPublishSeqNo();</span><br><span class="line">     channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, MessageProperties.PERSISTENT_BASIC, (<span class="string">" Confirm模式， 第"</span> + (i + <span class="number">1</span>) + <span class="string">"条消息"</span>).getBytes());</span><br><span class="line">            confirmSet.add(nextSeqNo);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>## 消息持久化<br><br>### queue的持久化<br><br>queue的持久化是通过durable=true来实现的。一般程序中这么使用：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection connection = connectionFactory.newConnection();</span><br><span class="line">Channel channel = connection.createChannel();</span><br><span class="line">channel.queueDeclare(<span class="string">"queue.persistent.name"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><br><br>Channel类中queueDeclare的完整定义如下：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Declare a queue</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> com.rabbitmq.client.AMQP.Queue.Declare</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@see</span> com.rabbitmq.client.AMQP.Queue.DeclareOk</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> queue the name of the queue</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> durable true if we are declaring a durable queue (the queue will survive a server restart)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> exclusive true if we are declaring an exclusive queue (restricted to this connection)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> autoDelete true if we are declaring an autodelete queue (server will delete it when no longer in use)</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> arguments other properties (construction arguments) for the queue</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> a declaration-confirm method to indicate the queue was successfully declared</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> java.io.IOException if an error is encountered</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><br><br>参数说明：<br><br>- queue：queue的名称<br><br><br>- exclusive：排他队列，如果一个队列被声明为排他队列，该队列仅对首次申明它的连接可见，并在连接断开时自动删除。这里需要注意三点：1. 排他队列是基于连接可见的，同一连接的不同信道是可以同时访问同一连接创建的排他队列；2.“首次”，如果一个连接已经声明了一个排他队列，其他连接是不允许建立同名的排他队列的，这个与普通队列不同；3.即使该队列是持久化的，一旦连接关闭或者客户端退出，该排他队列都会被自动删除的，这种队列适用于一个客户端发送读取消息的应用场景。<br><br><br>- autoDelete：自动删除，如果该队列没有任何订阅的消费者的话，该队列会被自动删除。这种队列适用于临时队列。<br><br>queueDeclare相关的有4种方法，分别是：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclare</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">queueDeclareNoWait</span><span class="params">(String queue, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> exclusive, <span class="keyword">boolean</span> autoDelete, Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line">Queue.<span class="function">DeclareOk <span class="title">queueDeclarePassive</span><span class="params">(String queue)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><br><br>其中需要说明的是queueDeclarePassive(String queue)可以用来检测一个queue是否已经存在。如果该队列存在，则会返回true；如果不存在，就会返回异常，但是不会创建新的队列。<br><br><br><br>### 持久化设置<br><br>如过将queue的持久化标识durable设置为true,则代表是一个持久的队列，那么在服务重启之后，也会存在，因为服务会把持久化的queue存放在硬盘上，当服务重启的时候，会重新什么之前被持久化的queue。队列是可以被持久化，但是里面的消息是否为持久化那还要看消息的持久化设置。也就是说，重启之前那个queue里面还没有发出去的消息的话，重启之后那队列里面是不是还存在原来的消息，这个就要取决于发生着在发送消息时对消息的设置了。如果要在重启后保持消息的持久化必须设置消息是持久化的标识。设置消息的持久化：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.basicPublish(<span class="string">"exchange.persistent"</span>, <span class="string">"persistent"</span>, MessageProperties.PERSISTENT_TEXT_PLAIN, <span class="string">"persistent_test_message"</span>.getBytes());</span><br></pre></td></tr></table></figure><br><br>这里的关键是：MessageProperties.PERSISTENT_TEXT_PLAIN，首先看一下basicPublish的方法：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, BasicProperties props, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, <span class="keyword">boolean</span> mandatory, BasicProperties props, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, <span class="keyword">boolean</span> mandatory, <span class="keyword">boolean</span> immediate, BasicProperties props, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><br><br>- exchange表示exchange的名称<br>- routingKey表示routingKey的名称<br>- body代表发送的消息体<br><br>这里关键的是BasicProperties props这个参数了，这里看下BasicProperties的定义：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BasicProperties</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            String contentType,//消息类型如：text/plain</span></span></span><br><span class="line"><span class="function"><span class="params">            String contentEncoding,//编码</span></span></span><br><span class="line"><span class="function"><span class="params">            Map&lt;String,Object&gt; headers,</span></span></span><br><span class="line"><span class="function"><span class="params">            Integer deliveryMode,//<span class="number">1</span>:nonpersistent <span class="number">2</span>:persistent</span></span></span><br><span class="line"><span class="function"><span class="params">            Integer priority,//优先级</span></span></span><br><span class="line"><span class="function"><span class="params">            String correlationId,</span></span></span><br><span class="line"><span class="function"><span class="params">            String replyTo,//反馈队列</span></span></span><br><span class="line"><span class="function"><span class="params">            String expiration,//expiration到期时间</span></span></span><br><span class="line"><span class="function"><span class="params">            String messageId,</span></span></span><br><span class="line"><span class="function"><span class="params">            Date timestamp,</span></span></span><br><span class="line"><span class="function"><span class="params">            String type,</span></span></span><br><span class="line"><span class="function"><span class="params">            String userId,</span></span></span><br><span class="line"><span class="function"><span class="params">            String appId,</span></span></span><br><span class="line"><span class="function"><span class="params">            String clusterId)</span></span></span><br></pre></td></tr></table></figure><br><br>这里的deliveryMode=1代表不持久化，deliveryMode=2代表持久化。上面的实现代码使用的是MessageProperties.PERSISTENT_TEXT_PLAIN，那么这个又是什么呢？<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> BasicProperties PERSISTENT_TEXT_PLAIN =</span><br><span class="line">    <span class="keyword">new</span> BasicProperties(<span class="string">"text/plain"</span>,</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>,</span><br><span class="line">                        <span class="number">2</span>,</span><br><span class="line">                        <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><br><br>可以看到这其实就是讲deliveryMode设置为2的BasicProperties的对象，为了方便编程而出现的一个东东。换一种实现方式：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AMQP.BasicProperties.Builder builder = <span class="keyword">new</span> AMQP.BasicProperties.Builder();</span><br><span class="line">builder.deliveryMode(<span class="number">2</span>);</span><br><span class="line">AMQP.BasicProperties properties = builder.build();</span><br><span class="line">channel.basicPublish(<span class="string">"exchange.persistent"</span>, <span class="string">"persistent"</span>,properties, <span class="string">"persistent_test_message"</span>.getBytes());</span><br></pre></td></tr></table></figure><br><br>设置了队列和消息的持久化之后，当broker服务重启的之后，消息依旧存在。单只设置队列持久化，重启之后消息会丢失；单只设置消息的持久化，重启之后队列消失，既而消息也丢失。单单设置消息持久化而不设置队列的持久化显得毫无意义。<br><br><br><br>### exchange的持久化<br><br>上面阐述了队列的持久化和消息的持久化，如果不设置exchange的持久化对消息的可靠性来说没有什么影响，但是同样如果exchange不设置持久化，那么当broker服务重启之后，exchange将不复存在，那么既而发送方rabbitmq producer就无法正常发送消息。这里博主建议，同样设置exchange的持久化。exchange的持久化设置也特别简单，方法如下：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange, String type, <span class="keyword">boolean</span> durable)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange, String type, <span class="keyword">boolean</span> durable, <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange, String type)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclare</span><span class="params">(String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          String type,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> durable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">boolean</span> internal,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exchangeDeclareNoWait</span><span class="params">(String exchange,</span></span></span><br><span class="line"><span class="function"><span class="params">                           String type,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> durable,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> autoDelete,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> internal,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Map&lt;String, Object&gt; arguments)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">Exchange.<span class="function">DeclareOk <span class="title">exchangeDeclarePassive</span><span class="params">(String name)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><br><br>一般只需要：channel.exchangeDeclare(exchangeName, “direct/topic/header/fanout”, true);即在声明的时候讲durable字段设置为true即可。<br><br><br><br>### 进一步讨论<br><br>#### 手动确认<br><br>将queue，exchange, message等都设置了持久化之后就能保证100%保证数据不丢失了嚒？答案是否定的。<br><br>首先，从consumer端来说，如果这时autoAck=true，那么当consumer接收到相关消息之后，还没来得及处理就crash掉了，那么这样也算数据丢失，这种情况也好处理，只需将autoAck设置为false（方法定义如下），然后在正确处理完消息之后进行手动ack（channel.basicAck）。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">basicConsume</span><span class="params">(String queue, <span class="keyword">boolean</span> autoAck, Consumer callback)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><br><br>#### 同步到磁盘<br><br>其次，关键的问题是消息在正确存入RabbitMQ之后，还需要有一段时间（这个时间很短，但不可忽视）才能存入磁盘之中，RabbitMQ并不是为每条消息都做fsync（同步到磁盘）的处理，可能仅仅保存到cache中而不是物理磁盘上，在这段时间内RabbitMQ broker发生crash，消息保存到cache但是还没来得及落盘，那么这些消息将会丢失。那么这个怎么解决呢？首先可以引入RabbitMQ的mirrored-queue即镜像队列，这个相当于配置了副本，当master在此特殊时间内crash掉，可以自动切换到slave，这样有效的保障了HA, 除非整个集群都挂掉，这样也不能完全的100%保障RabbitMQ不丢消息，但比没有mirrored-queue的要好很多，很多现实生产环境下都是配置了mirrored-queue的。还有要在producer引入事务机制或者Confirm机制来确保消息已经正确的发送至broker端，有关RabbitMQ的事务机制或者Confirm机制可以参考：RabbitMQ之消息确认机制（事务+Confirm）。幸亏本文的主题是讨论RabbitMQ的持久化而不是可靠性，不然就一发不可收拾了。RabbitMQ的可靠性涉及producer端的确认机制、broker端的镜像队列的配置以及consumer端的确认机制，要想确保消息的可靠性越高，那么性能也会随之而降，鱼和熊掌不可兼得，关键在于选择和取舍。<br><br>##### 消息什么时候刷到磁盘？<br><br>写入文件前会有一个Buffer，大小为1M，数据在写入文件时，首先会写入到这个Buffer，如果Buffer已满，则会将Buffer写入到文件（未必刷到磁盘）。<br><br>有个固定的刷盘时间：25ms，也就是不管Buffer满不满，每个25ms，Buffer里的数据及未刷新到磁盘的文件内容必定会刷到磁盘。<br><br>每次消息写入后，如果没有后续写入请求，则会直接将已写入的消息刷到磁盘：使用Erlang的receive x after 0实现，只要进程的信箱里没有消息，则产生一个timeout消息，而timeout会触发刷盘操作。<br><br><br><br>## Redis数据类型及基本操作<br><br>### 存储<code>string</code><br><br>key最好不要超过1024字节，value最大可支持512M。<br><br>- 设置：<code>set key value</code>。设定key持有指定的字符串value，如果该key存在则进行覆盖操作。总是返回”OK”。<br>- 取值：<code>get key</code>。获取key的value，如果与该key关联的value不是String类型，redis将返回错误信息，因为get命令只能用于获取String value；如果该key不存在，返回（nil）。<br>- <code>getset key value</code>：先获取该key的值，然后在设置该key的值。<br><br><div align="center"><img width="50%;" src="//isjinhao.github.io/2019/07-中间件/2019-08-28_094253.jpg"></div><br>- 删除：<code>del username</code>。<br><br><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/string赋值取值删除.jpg"></div><br>- 数值相加减<br>- 加一：<code>incr key</code>。将指定的key的value原子性的递增1，如果该key不存在，其初始值为0，在incr之后其值为1。如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/07-中间件/2019-08-28_094409.jpg"></div><br>- 减一：<code>decr key</code>。将指定的key的value原子性的递减1，如果该key个存在，其初始值为0，在incr之后其值为-1。如果value的值不能转成整型，如hello，该操作将执行失败并返回相应的错误信息。<br>- 加x：<code>incrby key x</code>。将指定的key的value原子性增加increment，如果该key不存在，器初始值为0，在incrby之后，该值为increment。如果该值不能转成整型，如hello则失败并返回错误信息<br>- 减x：<code>decrby key x</code>。将指定的key的value原子性减少decrement，如果该key不存在，器初始值为0，在decrby之后，该值为decrement。如果该值不能转成整型，如hello则失败并返回错误信息<br><br><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/string数值相加减.jpg"></div><br>- 字符串拼接：<code>append key value</code>，拼凑字符串。如果该key存在，则在原有的value后追加该值；如果该key不存在，则重新创建一个key/value。<br><br><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/string拼接.jpg"></div><br>### 存储<code>Map</code><br><br>最多可支持4294967295键值对。<br><br>- 赋值：<br><br>- 赋多值：<br><br><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/map赋值.jpg"></div><ul><li><p>取值：</p></li><li><p>取多个值：</p></li><li><p>取所有的值：</p><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/map取值.jpg"></div></li><li><p>删除字段：</p></li><li><p>删除map：</p><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/map删除.jpg"></div></li><li><p>判断字段存在：<code>hexists key field</code></p></li><li><p>获取全部entry：</p></li><li><p>获取全部key：</p></li><li><p>获取全部value：</p><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/map补充.jpg"></div></li></ul><h3 id="存储list"><a href="#存储list" class="headerlink" title="存储list"></a>存储list</h3><p>redis的list是双向链表。</p><ul><li><p>头部添加：</p></li><li><p>尾部添加：</p><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/list两端添加.jpg"></div><br><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/查看列表值个数.jpg"></div></li><li><p>查看列表：获取链表中从start到end的元素的值，start、end从0开始计数；也可为负数，若为-1则表示链表尾部的元素，-2则表示倒数第二个，依次类推…</p><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/查看链表.jpg"></div></li><li><p>头部弹出：</p></li><li><p>尾部弹出：</p><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/两端弹出.jpg"></div></li><li><p><code>lpushx key value</code>：仅当参数中指定的key存在时，向关联的list的头部插入value。如果不存在，将不进行插入。</p></li><li><p><code>rpush key value</code>：仅当<code>key</code>存在时才向尾部插入。如果不存在，将不进行插入。</p></li><li><p>删除：<code>irem key count value</code>：<code>count&gt;0</code>时从头部开始删除<code>|count|</code>个值为<code>value</code>的元素；<code>count&lt;0</code>时从尾部开始删除<code>|count|</code>个值为<code>value</code>的元素；<code>count=0</code>时删除全部的值为<code>|value|</code>的元素。</p></li><li><p>设置：<code>lset key index value</code>：设置链表中索引值为<code>index</code>的元素，<code>0</code>是链表头，<code>-1</code>是链表尾。索引值不存在抛异常。</p></li><li><p><code>lindex key index</code>：通过索引获取列表中的元素</p></li><li><p><code>linsert key before|after pivot value</code>：在列表的元素前或者后插入元素</p></li><li><p><code>rpoplpush source destination</code>：移除列表的最后一个元素，并将该元素添加到另一个列表并返回</p></li></ul><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/2019-08-28_102432.jpg"></div><br>### 存储<code>set</code><br><br>- <code>SADD key member1 member2...</code>：向集合添加一个或多个成员<br>- <code>SREM key member1 member2...</code>：移除集合中一个或多个成员<br><br>- <code>SISMEMBER key member</code>：判断 member 元素是否是集合 key 的成员<br><br>- 1：存在<br>- 0：key不存在或member不存在<br><br>- <code>sdiff key1 key2</code>：返回集合<code>key1-key2</code>的数据<br><br>- <code>sinter key1 key2 ...</code>：返回集合<code>key1,key2,...</code>的交集<br><br>- <code>sunion key1 key2 ...</code>：返回集合<code>key1,key2,...</code>的并集<br><br>- <code>scard key</code>：返回集合的数量<br><br>- <code>srandmember key</code>：随机返回集合中的一个数据<br><br>- 集合运算拓展<br><br><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/集合运算拓展.jpg"></div><h3 id="存储sortedset"><a href="#存储sortedset" class="headerlink" title="存储sortedset"></a>存储<code>sortedset</code></h3><p>有序集合和集合一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的，但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">命令及描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3609.html" target="_blank" rel="noopener">ZADD key score1 member1 [score2 member2]</a> 向有序集合添加一个或多个成员，或者更新已存在成员的分数</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3610.html" target="_blank" rel="noopener">ZCARD key</a> 获取有序集合的成员数</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3611.html" target="_blank" rel="noopener">ZCOUNT key min max</a> 计算在有序集合中指定区间分数的成员数</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3612.html" target="_blank" rel="noopener">ZINCRBY key increment member</a> 有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3613.html" target="_blank" rel="noopener">ZINTERSTORE destination numkeys key [key …]</a> 计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3614.html" target="_blank" rel="noopener">ZLEXCOUNT key min max</a> 在有序集合中计算指定字典区间内成员数量</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3615.html" target="_blank" rel="noopener">ZRANGE key start stop [WITHSCORES]</a> 通过索引区间返回有序集合成指定区间内的成员</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3616.html" target="_blank" rel="noopener">ZRANGEBYLEX key min max [LIMIT offset count]</a> 通过字典区间返回有序集合的成员</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3617.html" target="_blank" rel="noopener">ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT]</a> 通过分数返回有序集合指定区间内的成员</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3618.html" target="_blank" rel="noopener">ZRANK key member</a> 返回有序集合中指定成员的索引</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3619.html" target="_blank" rel="noopener">ZREM key member [member …]</a> 移除有序集合中的一个或多个成员</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3620.html" target="_blank" rel="noopener">ZREMRANGEBYLEX key min max</a> 移除有序集合中给定的字典区间的所有成员</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3621.html" target="_blank" rel="noopener">ZREMRANGEBYRANK key start stop</a> 移除有序集合中给定的排名区间的所有成员</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3622.html" target="_blank" rel="noopener">ZREMRANGEBYSCORE key min max</a> 移除有序集合中给定的分数区间的所有成员</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3623.html" target="_blank" rel="noopener">ZREVRANGE key start stop [WITHSCORES]</a> 返回有序集中指定区间内的成员，通过索引，分数从高到底</td></tr><tr><td style="text-align:left">16</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3624.html" target="_blank" rel="noopener">ZREVRANGEBYSCORE key max min [WITHSCORES]</a> 返回有序集中指定分数区间内的成员，分数从高到低排序</td></tr><tr><td style="text-align:left">17</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3625.html" target="_blank" rel="noopener">ZREVRANK key member</a> 返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序</td></tr><tr><td style="text-align:left">18</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3626.html" target="_blank" rel="noopener">ZSCORE key member</a> 返回有序集中，成员的分数值</td></tr><tr><td style="text-align:left">19</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3627.html" target="_blank" rel="noopener">ZUNIONSTORE destination numkeys key [key …]</a> 计算给定的一个或多个有序集的并集，并存储在新的 key 中</td></tr><tr><td style="text-align:left">20</td><td style="text-align:left"><a href="https://www.redis.net.cn/order/3628.html" target="_blank" rel="noopener">ZSCAN key cursor [MATCH pattern] [COUNT count]</a> 迭代有序集合中的元素（包括元素成员和元素分值）</td></tr></tbody></table><h3 id="keys的通用操作"><a href="#keys的通用操作" class="headerlink" title="keys的通用操作"></a>keys的通用操作</h3><ul><li><code>keys pattern</code>：获取所有和<code>pattern</code>匹配的key。</li><li><code>del key1, key2, ...</code>：删除指定key。</li><li><code>exists key</code>：<code>key</code>是否存在。</li><li><code>rename key newkey</code>：为当前的<code>key</code>重命名。</li><li><code>expire key</code>：为<code>key</code>设置过期时间，单位：秒。</li><li><code>ttl key</code>：获取<code>key</code>所剩的时间，如果没有设置超时，返回<code>-1</code>，<code>key</code>不存在返回<code>-2</code>。</li><li><code>type key</code>：以字符串形式返回<code>key</code>的类型。<code>key</code>不存在返回<code>none</code>。</li></ul><h2 id="Redis的持久化"><a href="#Redis的持久化" class="headerlink" title="Redis的持久化"></a>Redis的持久化</h2><p>Redis支持两种不同的持久化操作。<strong>Redis的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file,AOF）</strong>。这两种方法各有千秋。</p><h3 id="快照（snapshotting）持久化（RDB）"><a href="#快照（snapshotting）持久化（RDB）" class="headerlink" title="快照（snapshotting）持久化（RDB）"></a><strong>快照（snapshotting）持久化（RDB）</strong></h3><p>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>快照持久化是Redis默认采用的持久化方式，在<code>redis.conf</code>的140多行有如下配置是RDB配置：</p><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/RDB配置.jpg"></div><br>- <code>save 900 1</code>：每900秒至少有1个key发生变化，则备份内存快照。<br>- <code>save 300 10</code>：每300秒至少有10个key发生变化，则备份内存快照。<br>- <code>save 60 10000</code>：每60秒至少有10000个key发生变化，则备份内存快照。<br><br>快照存储的位置：<br><br><div align="center"><img src="//isjinhao.github.io/2019/07-中间件/RDB位置.jpg"></div><br>### AOF（append-only file）持久化<br><br>与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><br><br>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。<br><br>在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure><br><br>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。<br><br><strong>Redis 4.0 对于持久化机制的优化</strong><br><br>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。<br><br>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。<br><br><br><br>## 设置过期时间<br><br>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。<br><br>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？<br><br><strong>定期删除+惰性删除。</strong><br><br>通过名字大概就能猜出这两个删除方式的意思了。<br><br>- <strong>定期删除</strong>：redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！<br>- <strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！<br><br>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ <strong>redis 内存淘汰机制。</strong><br><br><strong>如果有大量的key需要设置同一时间过期，一般需要注意什么？</strong><br><br>如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。<br><br><br><br>### 内存淘汰机制<br><br>MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?<br><br>redis 配置文件 redis.conf 中有相关注释，我这里就不贴了，大家可以自行查阅或者通过这个网址查看： <a href="http://download.redis.io/redis-stable/redis.conf。" target="_blank" rel="noopener">http://download.redis.io/redis-stable/redis.conf。</a><br><br>redis 提供 6种数据淘汰策略：<br><br>1. <strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰<br>2. <strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰<br>3. <strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰<br>4. <strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）<br>5. <strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰<br>6. <strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！<br><br>4.0版本后增加以下两种：<br><br>1. <strong>volatile-lfu</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰<br>2. <strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key<br><br><br><br>## 如何防止缓存穿透<br><br>有一个更为简单粗暴的方法，如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。<br><br><br><br>### 布隆过滤器<br><br><strong>问题</strong>：不安全网页的黑名单里有100亿个URL，每一个网页的URL最多占用64B。要求实现一种过滤系统，可以根据网页的URL判断是否在这个黑名单中。<br><br><strong>布隆过滤器本质上是一个bit数组，可以用极少的空间解决“判断在不在”这种问题。</strong><br><br>以这道题为例，思路是将所有的URL整个都存储起来，但是这个题目其实只需要我们判断在不在，我们根本无需存整个URL，甚至无需在意一个URL是多少字节，<strong>只需要存这个URL是“在”还是“不在”这两种状态就好了。</strong>重头戏来了，<strong>当我们需要判断一个URL在不在黑名单里，只需要判断URL在经过hash函数后对应的bit数组下标的位置是“0”还是“1”。</strong>如果对应位置是0，意味这个位置仍是初始化状态，没有被标记过，所以这个URL不在黑名单里。如果对应位置是1，意味这个位置已经被标记过，所以这个URL在黑名单里。<br><br>#### <strong>hash函数</strong><br><br>上面所提到的“100亿个URL每一个都做hash运算”，这里的hash运算在现实中不只是一个hash函数，而是一组hash函数。顺便说一句hash函数不需要自己实现，经典的哈希函数已经有很多了，比如MD5、SHAI。但为什么URL经过hash函数的出来的值一定会是bit数组下标？打个比方，一个最简单的hash运算：%3。集合里的数经过%3的hash运算后，是只可能得出0或1或2，这三种情况。也就是说hash运算得出的输出域是固定的。这是hash函数的一个重要性质：<strong>哈希函数有无限的输入域，但只有固定有限输出域。</strong><br><br>#### <strong>布隆过滤器误判类型</strong><br><br>布隆过滤器是有一定失误率。它的误判类型是——宁可错杀一百，也不能放过一个。也就是说如果URL在黑名单，判断结果一定会表示在。可能失误的情况是：某个URL不在黑名单里，也被判断在。为什么布隆过滤器会失误？并且只会“冤枉”，不会“漏判”？<br><br>这是因为hash函数的另一个性质：不同的输入值hash运算后得到的散列输出值可能不同，也可能相同。但是不同的散列输出值对应的输入值一定不同。假如要判断的两个URLhash运算得到了相同的结果，但一个在黑名单里，一个不在黑名单里，对应的数组下标位置已经被描黑，那么两个URL都会被判为在黑名单里。<br><br>#### <strong>计算误判率</strong><br><br><strong>误判率与数组长度、哈希函数的个数成负相关，与样本量成正相关。</strong>举一个极端的例子，如果样本量很大而bit数组太小，经过100亿和URL的标记后，数组里的所有元素都被“描黑”。此时任意一个URL都会被判断在黑名单里。想要减少失误率就需根据<strong>三个公式</strong>设计一个长度合适的bit数组。还是上面那道题为例，<strong>n是样本量，即100亿；p预期失误率，即0.0001，m是数组元素个数。</strong><br><br>##### <strong>公式一：计算布隆过滤器的大小</strong><br><br>$m=-\frac{n<em>lnp}{(ln2)^2}$<br><br>把p和n代入公式match，lnp等于-9.21，（ln2）的平方是0.7，n是100亿。计算出来m等于19.19n，转为GB,等于bit数组大小要开25G。<br><br>##### <strong>公式二</strong>：我们还得确定hash函数的个数，哈希函数的个数k公式：<br><br>$k=ln2</em>\frac{m}{n}$<br><br>算出k为14，需要14个hash函数<br><br>##### <strong>公式三</strong>：计算失误率，p公式：<br><br>$p=(1-e^{-\frac{nk}{m}})^k$<br><br>算出失误率是0.006%。<br><br>#### 用布隆过滤器着手解决缓冲穿透<br><br>请求过来，<strong>先调用布隆过滤器判断数据是否存在</strong>。如果不存在的数据，就不要把请求引向数据库。直接过滤掉了大量不存在的数据攻击。总的来说，当<strong>数据量比较大并且重复率不高</strong>的时候，布隆过滤器的成本比一般解决方案成本更低。<br><br>#### 布隆过滤器的题<br><br>32位无符号整数的范围是0 - 4294967295，现在有一个正好包含40亿个无符号整数的文件，所以在整个范围中必然有没出现过的数。可以使用最多1GB的内存，怎么找到所有出现过两次的数？<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/07-中间件/mmexport1566974778930.jpg"></div><h2 id="Redis分布式锁"><a href="#Redis分布式锁" class="headerlink" title="Redis分布式锁"></a>Redis分布式锁</h2><p>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</p><p>这时候对方会告诉你说你回答得不错，然后接着问如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？</p><p>这时候你要给予惊讶的反馈：唉，是喔，这个锁就永远得不到释放了。紧接着你需要抓一抓自己得脑袋，故作思考片刻，好像接下来的结果是你主动思考出来的，然后回答：我记得set指令有非常复杂的参数，这个应该是可以同时把setnx和expire合成一条指令来用的！对方这时会显露笑容，心里开始默念：嗯，这小子还不错。</p><h2 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h2><p>Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？使用keys指令可以扫出指定模式的key列表。 但如果这个redis正在给线上的业务提供服务，由于redis是单线程的，keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。</p><p>这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p><code>SCAN cursor MATCH pattern COUNT count</code>。其中cursor为游标，MATCH和COUNT为可选参数。SCAN命令和SSCAN、HSCAN、ZSCAN命令都用于增量的迭代元素集，它每次返回小部分数据，不会像KEYS那样阻塞Redis。SCAN命令是基于游标的，每次调用后，都会返回一个游标，用于下一次迭代。当游标返回0时，表示迭代结束。SCAN每次返回的数量并不固定，也有可能返回数据为空。另外，SCAN命令和KEYS命令一样支持匹配。我们在Redis里存入10000个key用于测试。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; scan 0 match key24* count 1000</span><br><span class="line">1) "1688"</span><br><span class="line">2) 1) "key2411"</span><br><span class="line">   2) "key2475"</span><br><span class="line">   3) "key2494"</span><br><span class="line">   4) "key2406"</span><br><span class="line">   5) "key2478"</span><br><span class="line">127.0.0.1:6379&gt; scan 1688 match key24* count 1000</span><br><span class="line">1) "2444"</span><br><span class="line">2)  1) "key2458"</span><br><span class="line">    2) "key249"</span><br><span class="line">    3) "key2407"</span><br><span class="line">    4) "key2434"</span><br><span class="line">    5) "key241"</span><br><span class="line">    6) "key2497"</span><br><span class="line">    7) "key2435"</span><br><span class="line">    8) "key2413"</span><br><span class="line">    9) "key2421"</span><br><span class="line">   10) "key248"</span><br><span class="line">127.0.0.1:6379&gt; scan 2444 match key24* count 1000</span><br><span class="line">1) "818"</span><br><span class="line">2)  1) "key2459"</span><br><span class="line">    2) "key2462"</span><br><span class="line">    3) "key2409"</span><br><span class="line">    4) "key2454"</span><br><span class="line">    5) "key2431"</span><br><span class="line">    6) "key2423"</span><br><span class="line">    7) "key2476"</span><br><span class="line">    8) "key2428"</span><br><span class="line">    9) "key2493"</span><br><span class="line">   10) "key2420"</span><br><span class="line">127.0.0.1:6379&gt; scan 818 match key24* count 1000</span><br><span class="line">1) "9190"</span><br><span class="line">2)  1) "key2402"</span><br><span class="line">    2) "key2415"</span><br><span class="line">    3) "key2429"</span><br><span class="line">    4) "key2424"</span><br><span class="line">    5) "key2425"</span><br><span class="line">    6) "key2400"</span><br><span class="line">    7) "key2472"</span><br><span class="line">    8) "key2479"</span><br><span class="line">    9) "key2448"</span><br><span class="line">   10) "key245"</span><br><span class="line">   11) "key2487"</span><br><span class="line">   12) "key2430"</span><br><span class="line">   13) "key2405"</span><br><span class="line">127.0.0.1:6379&gt; scan 9190 match key24* count 1000</span><br><span class="line">1) "12161"</span><br><span class="line">2)  1) "key2488"</span><br><span class="line">    2) "key2437"</span><br><span class="line">    3) "key2404"</span><br><span class="line">    4) "key2440"</span><br><span class="line">    5) "key2461"</span><br><span class="line">    6) "key2416"</span><br><span class="line">    7) "key2436"</span><br><span class="line">    8) "key2403"</span><br><span class="line">    9) "key2460"</span><br><span class="line">   10) "key2452"</span><br><span class="line">   11) "key2449"</span><br><span class="line">   12) "key2482"</span><br><span class="line">127.0.0.1:6379&gt; scan 12161 match key24* count 1000</span><br><span class="line">1) "11993"</span><br><span class="line">2)  1) "key2483"</span><br><span class="line">    2) "key2491"</span><br><span class="line">    3) "key242"</span><br><span class="line">    4) "key2466"</span><br><span class="line">    5) "key2446"</span><br><span class="line">    6) "key2465"</span><br><span class="line">    7) "key243"</span><br><span class="line">    8) "key2438"</span><br><span class="line">    9) "key2457"</span><br><span class="line">   10) "key246"</span><br><span class="line">   11) "key2422"</span><br><span class="line">   12) "key2418"</span><br><span class="line">127.0.0.1:6379&gt; scan 11993 match key24* count 1000</span><br><span class="line">1) "7853"</span><br><span class="line">2) 1) "key2498"</span><br><span class="line">   2) "key2451"</span><br><span class="line">   3) "key2439"</span><br><span class="line">   4) "key2495"</span><br><span class="line">   5) "key2408"</span><br><span class="line">   6) "key2410"</span><br><span class="line">127.0.0.1:6379&gt; scan 7853 match key24* count 1000</span><br><span class="line">1) "5875"</span><br><span class="line">2)  1) "key2486"</span><br><span class="line">    2) "key2490"</span><br><span class="line">    3) "key244"</span><br><span class="line">    4) "key2401"</span><br><span class="line">    5) "key2463"</span><br><span class="line">    6) "key2481"</span><br><span class="line">    7) "key2477"</span><br><span class="line">    8) "key2468"</span><br><span class="line">    9) "key2433"</span><br><span class="line">   10) "key2489"</span><br><span class="line">   11) "key2455"</span><br><span class="line">   12) "key2426"</span><br><span class="line">   13) "key24"</span><br><span class="line">   14) "key2450"</span><br><span class="line">   15) "key2414"</span><br><span class="line">   16) "key2442"</span><br><span class="line">   17) "key2473"</span><br><span class="line">   18) "key2467"</span><br><span class="line">   19) "key2469"</span><br><span class="line">   20) "key2456"</span><br><span class="line">127.0.0.1:6379&gt; scan 5875 match key24* count 1000</span><br><span class="line">1) "14311"</span><br><span class="line">2)  1) "key2453"</span><br><span class="line">    2) "key2492"</span><br><span class="line">    3) "key2480"</span><br><span class="line">    4) "key2427"</span><br><span class="line">    5) "key2443"</span><br><span class="line">    6) "key2417"</span><br><span class="line">    7) "key2432"</span><br><span class="line">    8) "key240"</span><br><span class="line">    9) "key2445"</span><br><span class="line">   10) "key2484"</span><br><span class="line">   11) "key2444"</span><br><span class="line">   12) "key247"</span><br><span class="line">   13) "key2485"</span><br><span class="line">127.0.0.1:6379&gt; scan 14311 match key24* count 1000</span><br><span class="line">1) "16383"</span><br><span class="line">2)  1) "key2441"</span><br><span class="line">    2) "key2474"</span><br><span class="line">    3) "key2447"</span><br><span class="line">    4) "key2471"</span><br><span class="line">    5) "key2470"</span><br><span class="line">    6) "key2464"</span><br><span class="line">    7) "key2412"</span><br><span class="line">    8) "key2419"</span><br><span class="line">    9) "key2499"</span><br><span class="line">   10) "key2496"</span><br><span class="line">127.0.0.1:6379&gt; scan 16383 match key24* count 1000</span><br><span class="line">1) "0"</span><br><span class="line">2) (empty list or set)</span><br></pre></td></tr></table></figure><p>可以看到虽然我们设置的count为1000，但Redis每次返回的数值只有10个左右。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;消息队列的作用&quot;&gt;&lt;a href=&quot;#消息队列的作用&quot; class=&quot;headerlink&quot; title=&quot;消息队列的作用&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/categories/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/tags/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="面试" scheme="https://isjinhao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>类加载和自定义类加载器</title>
    <link href="https://isjinhao.github.io/2019/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%92%8C%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/"/>
    <id>https://isjinhao.github.io/2019/类加载和自定义类加载器/</id>
    <published>2019-08-14T08:50:27.000Z</published>
    <updated>2019-08-15T09:29:44.798Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Java是一个纯面向对象的语言，Java的体系结构是由一个一个的类构成的。类加载是将.class文件定义为JVM中一个类的过程，也是使用一个类的前提条件。每一个类由：<code>它的全限定名+它的类加载器</code>唯一确定。</p><p>类加载器是一个抽象类：abstract ClassLoader。JDK给我们实现了三个类加载器，BootStrapClassLoader、ExtClassLoader、AppClassLoader。</p><h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就加载后返回，否则交给子类加载器完成。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>安全，可避免用户自己编写的类动态替换Java的核心类，如java.lang.String</li><li>避免全限定命名的类重复加载，使用了findLoadClass()判断当前类是否已加载</li></ul><h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><h4 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 如果没有被记载</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 有爹就找他爹去加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 没爹就找BootStrap加载器去加载</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 父亲不能加载的情况下自己加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 一个满足双亲委派原则的自定义类加载器需要覆盖此方法</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h4><p>这个方法是上面第29行被调用的方法。如果想保持双亲委派机制，在自定义类加载器的时候不去覆盖loadClass，去覆盖findClass就可以了。</p><h2 id="自定义类加载器的例子"><a href="#自定义类加载器的例子" class="headerlink" title="自定义类加载器的例子"></a>自定义类加载器的例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.zzj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.zzj;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(Class.forName(<span class="string">"org.zzj.User"</span>).getClassLoader());</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.zzj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassForNameTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 当前调用者的加载器是 sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line">        System.out.println(Class.forName(<span class="string">"org.zzj.User"</span>).getClassLoader());</span><br><span class="line"></span><br><span class="line">        MyClassLoader classLoader = <span class="keyword">new</span> MyClassLoader();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// clazz是 org.zzj.MyClassLoader@5b2133b1 加载的</span></span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"org.zzj.UserService"</span>);</span><br><span class="line">        System.out.println(<span class="string">"aaa   -&gt;    "</span> + clazz.getClassLoader());</span><br><span class="line"></span><br><span class="line">        Method method = clazz.getMethod(<span class="string">"add"</span>);</span><br><span class="line"></span><br><span class="line">        method.invoke(clazz.newInstance());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">        InputStream in = getClass().getResourceAsStream(fileName);</span><br><span class="line">        <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">byte</span>[] b = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            b = <span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">            in.read(b);</span><br><span class="line">            in.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将 字节数组 转为 类</span></span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Class-forName和ClassLoader-loadClass的区别"><a href="#Class-forName和ClassLoader-loadClass的区别" class="headerlink" title="Class.forName和ClassLoader.loadClass的区别"></a>Class.forName和ClassLoader.loadClass的区别</h2><p>Class.forName加载的类会进行初始化，而ClassLoader.loadClass加载的类不会进行初始化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是这个使用这个方法加载得到的类默认是调用者的类加载器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><img width="80%" src="//isjinhao.github.io/2019/类加载和自定义类加载器/2019-08-15_141131.jpg"></div><h2 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h2><p>Java 提供了很多服务提供者接口（Service Provider Interface，SPI），允许第三方为这些接口提供实现。常见的 SPI 有 JDBC、JCE、JNDI、JAXP 和 JBI 等。</p><p>这些 SPI 的接口由 Java 核心库来提供，而这些 SPI 的实现代码则是作为 Java 应用所依赖的 jar 包被包含进类路径（CLASSPATH）里。SPI接口中的代码经常需要加载具体的实现类。那么问题来了，SPI的接口是Java核心库的一部分，是由启动类加载器(Bootstrap Classloader)来加载的；SPI的实现类是由系统类加载器(System ClassLoader)来加载的。引导类加载器是无法找到 SPI 的实现类的，因为依照双亲委派模型，BootstrapClassloader无法委派AppClassLoader来加载类。</p><p>而线程上下文类加载器破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链模式，使程序可以逆向使用类加载器。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Java是
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Maven排除依赖</title>
    <link href="https://isjinhao.github.io/2019/Maven%E6%8E%92%E9%99%A4%E4%BE%9D%E8%B5%96/"/>
    <id>https://isjinhao.github.io/2019/Maven排除依赖/</id>
    <published>2019-08-11T07:56:48.000Z</published>
    <updated>2019-08-11T13:58:14.817Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --><p>依赖重复时在启动项目的时候会报错，但大多数不影响使用。不过如果把Maven项目按普通方式打包时就会出现问题。所以依赖最好排除一下。</p><div align="center"><img width="100%" src="//isjinhao.github.io/2019/Maven排除依赖/2019-08-11_200910.jpg"></div><h2 id="排除依赖的写法"><a href="#排除依赖的写法" class="headerlink" title="排除依赖的写法"></a>排除依赖的写法</h2><p>在坐标里面（dependency）加入exclusions结点，exclusions里的exclusion是要排除的内容。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-log4j12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br></pre></td></tr></table></figure><div align="center"><img width="100%" src="//isjinhao.github.io/2019/Maven排除依赖/2019-08-11_201458.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;依赖重复时在启动项目的时候会报错，但大多数不影响使用。不过如果把Maven项目按普通方式打包时就会出现问题。所以依赖最好排除一下。&lt;/p&gt;&lt;di
      
    
    </summary>
    
      <category term="Maven" scheme="https://isjinhao.github.io/categories/Maven/"/>
    
    
      <category term="Maven" scheme="https://isjinhao.github.io/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>IDEA的打包</title>
    <link href="https://isjinhao.github.io/2019/IDEA%E7%9A%84%E6%89%93%E5%8C%85/"/>
    <id>https://isjinhao.github.io/2019/IDEA的打包/</id>
    <published>2019-08-11T07:55:53.000Z</published>
    <updated>2019-08-11T13:58:14.817Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --><h2 id="基本打包方式"><a href="#基本打包方式" class="headerlink" title="基本打包方式"></a>基本打包方式</h2><div align="center"><img width="100%" src="//isjinhao.github.io/2019/IDEA的打包/2019-08-11_195445.jpg"></div><div align="center"><img width="100%" src="//isjinhao.github.io/2019/IDEA的打包/2019-08-11_195555.jpg"></div><div align="center"><img width="100%" src="//isjinhao.github.io/2019/IDEA的打包/2019-08-11_195714.jpg"></div><div align="center"><img width="100%" src="//isjinhao.github.io/2019/IDEA的打包/2019-08-11_195905.jpg"></div><p>然后选择build。</p><p>这样过后，我们能在classes文件夹下找到一个文件夹，文件夹里我们写的的包和第三方包。</p><h2 id="Maven打包Springboot项目"><a href="#Maven打包Springboot项目" class="headerlink" title="Maven打包Springboot项目"></a>Maven打包Springboot项目</h2><p>pom.xml中加入插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">includeSystemScope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">includeSystemScope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure><div align="center"><img width="100%" src="//isjinhao.github.io/2019/IDEA的打包/2019-08-11_200608.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;基本打包方式&quot;&gt;&lt;a href=&quot;#基本打包方式&quot; class=&quot;headerlink&quot; title=&quot;基本打包方式&quot;&gt;&lt;/a&gt;基本打
      
    
    </summary>
    
      <category term="IDE" scheme="https://isjinhao.github.io/categories/IDE/"/>
    
    
      <category term="IDEA" scheme="https://isjinhao.github.io/tags/IDEA/"/>
    
      <category term="IDE" scheme="https://isjinhao.github.io/tags/IDE/"/>
    
  </entry>
  
  <entry>
    <title>Jar包的动态加载及卸载</title>
    <link href="https://isjinhao.github.io/2019/Jar%E5%8C%85%E7%9A%84%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD%E5%8F%8A%E5%8D%B8%E8%BD%BD/"/>
    <id>https://isjinhao.github.io/2019/Jar包的动态加载及卸载/</id>
    <published>2019-08-11T07:55:36.000Z</published>
    <updated>2019-08-15T09:21:00.730Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --><p>用springboot封装了一下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"controller"</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Controller</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 公司的一个调用dubbo服务的jar</span></span><br><span class="line">    File innerServiceBus = <span class="keyword">new</span> File(<span class="keyword">new</span> File(<span class="string">""</span>).getCanonicalPath() + File.separator + <span class="string">"InnerServiceBus_4.3.0"</span> + <span class="string">".jar"</span>);</span><br><span class="line"></span><br><span class="line">    URLClassLoader loader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;innerServiceBus.toURI().toURL()&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Controller</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"invoke1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke1</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @RequestParam(<span class="string">"service"</span>)</span> String service,</span></span><br><span class="line"><span class="function">            @<span class="title">RequestParam</span><span class="params">(<span class="string">"method"</span>)</span> String method,</span></span><br><span class="line"><span class="function">            @<span class="title">RequestParam</span><span class="params">(<span class="string">"jarName"</span>)</span> String jarName) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载传入的jar包</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="keyword">new</span> File(<span class="string">""</span>).getCanonicalPath() + File.separator + jarName + <span class="string">".jar"</span>);</span><br><span class="line">        URL url = file.toURI().toURL();</span><br><span class="line">        Class aClass1 = loader.getClass();</span><br><span class="line"></span><br><span class="line">        Method add = URLClassLoader.class.getDeclaredMethod(<span class="string">"addURL"</span>, URL.class);</span><br><span class="line">        add.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        add.invoke(loader, url);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程上下文类加载器</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载 ServiceBus 类</span></span><br><span class="line">        Class&lt;?&gt; serviceBusClazz = loader.loadClass(<span class="string">"dcloud.common.InnerServiceBus.ServiceBus"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造serviceBus对象</span></span><br><span class="line">        Object serviceBus = serviceBusClazz.newInstance();</span><br><span class="line">        Method init = serviceBusClazz.getMethod(<span class="string">"init"</span>);</span><br><span class="line">        init.invoke(serviceBus);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取dubbo传来的对象</span></span><br><span class="line">        Method locateService = serviceBusClazz.getMethod(<span class="string">"locateService"</span>, String.class);</span><br><span class="line">        Object serviceObject = locateService.invoke(serviceBus, service);</span><br><span class="line"></span><br><span class="line">        Class clazz = serviceObject.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印所有的方法</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m : methods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行一个无参测试方法</span></span><br><span class="line">        <span class="comment">// 如果是有参需要注意：</span></span><br><span class="line">        <span class="comment">//如使用自己定义的类，必须使用同一类加载器进行加载。</span></span><br><span class="line">        <span class="comment">//      比如有个cn.isjinhao.User类，在getDeclaredMethod的时候需要</span></span><br><span class="line">        <span class="comment">//传入：loader.loadClass("cn.isjinhao,User").</span></span><br><span class="line">        Method methoda = clazz.getDeclaredMethod(method);</span><br><span class="line">        Object invoke = methoda.invoke(serviceObject);</span><br><span class="line">        System.out.println(invoke);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        loader.close();</span><br><span class="line">        ClassLoaderUtil.releaseLoader(loader);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"invoke2"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke2</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            @RequestParam(<span class="string">"service"</span>)</span> String service,</span></span><br><span class="line"><span class="function">            @<span class="title">RequestParam</span><span class="params">(<span class="string">"method"</span>)</span> String method,</span></span><br><span class="line"><span class="function">            @<span class="title">RequestParam</span><span class="params">(<span class="string">"jarName"</span>)</span> String jarName) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新创建一个 类加载器</span></span><br><span class="line">        loader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//加载 两个jar包</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="keyword">new</span> File(<span class="string">""</span>).getCanonicalPath() + File.separator + jarName + <span class="string">".jar"</span>);</span><br><span class="line">        URL url = file.toURI().toURL();</span><br><span class="line"></span><br><span class="line">        Method add = URLClassLoader.class.getDeclaredMethod(<span class="string">"addURL"</span>, URL.class);</span><br><span class="line">        add.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        add.invoke(loader, url);</span><br><span class="line">        add.invoke(loader, innerServiceBus.toURI().toURL());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置线程上下文类加载器</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(loader);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 加载 ServiceBus 类</span></span><br><span class="line">        Class&lt;?&gt; serviceBusClazz = loader.loadClass(<span class="string">"dcloud.common.InnerServiceBus.ServiceBus"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 构造serviceBus对象</span></span><br><span class="line">        Object serviceBus = serviceBusClazz.newInstance();</span><br><span class="line">        Method init = serviceBusClazz.getMethod(<span class="string">"init"</span>);</span><br><span class="line">        init.invoke(serviceBus);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取dubbo传来的对象</span></span><br><span class="line">        Method locateService = serviceBusClazz.getMethod(<span class="string">"locateService"</span>, String.class);</span><br><span class="line">        Object serviceObject = locateService.invoke(serviceBus, service);</span><br><span class="line"></span><br><span class="line">        Class clazz = serviceObject.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印所有的方法</span></span><br><span class="line">        Method[] methods = clazz.getMethods();</span><br><span class="line">        <span class="keyword">for</span>(Method m : methods)&#123;</span><br><span class="line">            System.out.println(m);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 执行一个无参测试方法</span></span><br><span class="line">        Method methoda = clazz.getDeclaredMethod(method);</span><br><span class="line">        Object invoke = methoda.invoke(serviceObject);</span><br><span class="line">        System.out.println(invoke);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;用springboot封装了一下。&lt;/p&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>kettle的基本使用</title>
    <link href="https://isjinhao.github.io/2019/kettle%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <id>https://isjinhao.github.io/2019/kettle的基本使用/</id>
    <published>2019-08-06T07:25:22.000Z</published>
    <updated>2019-08-06T08:52:54.378Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --><p>最近实习被公司安排用kettle处理数据，所以写一篇记录一下kettle的基本使用方法。</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">K.EQUIP_ID <span class="keyword">AS</span> STATIONIDX, </span><br><span class="line">K.NAME <span class="keyword">AS</span> STATIONNAME, </span><br><span class="line">STA_DAY, </span><br><span class="line"><span class="keyword">ISNULL</span>( STANUM, <span class="number">0</span> ), </span><br><span class="line"><span class="keyword">ISNULL</span>( SPACENUM, <span class="number">0</span> ), </span><br><span class="line"><span class="keyword">ISNULL</span>( SIGNALNUM, <span class="number">0</span> ), </span><br><span class="line">FNUM </span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">A.STATIONIDX,</span><br><span class="line">B.STATIONNAME,</span><br><span class="line">&#123;<span class="number">3</span>&#125; <span class="keyword">AS</span> STA_DAY,</span><br><span class="line"><span class="keyword">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> RESTRAIN_FLAG = <span class="number">0</span> <span class="keyword">OR</span> </span><br><span class="line">                RESTRAIN_FLAG <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> ) <span class="keyword">AS</span> NNUM,</span><br><span class="line"><span class="keyword">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> RESTRAIN_FLAG = <span class="number">0</span> <span class="keyword">OR</span> </span><br><span class="line">                RESTRAIN_FLAG <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">THEN</span> <span class="number">0</span> <span class="keyword">ELSE</span> <span class="number">1</span> <span class="keyword">END</span> ) <span class="keyword">AS</span> FNUM </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">MONITORSIGNAL.TBSIGNALBASIS_SX_&#123;&#123;<span class="number">2</span>&#125;&#125; A<span class="comment">/* 变量参数  +  循环*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">JOIN</span> </span><br><span class="line">MONITORSIGNAL.TBSTATION_SX B </span><br><span class="line"><span class="keyword">ON</span> </span><br><span class="line">        A.STATIONIDX = B.STATIONIDX </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">SIGNAL_TIME &gt;= &#123; <span class="number">3</span> &#125; <span class="comment">/* 占位参数 */</span></span><br><span class="line"><span class="keyword">AND</span> SIGNAL_TIME &lt; &#123; <span class="number">4</span> &#125; </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">A.STATIONIDX,</span><br><span class="line">B.STATIONNAME </span><br><span class="line">) M</span><br><span class="line"></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st_id,</span><br><span class="line"><span class="keyword">count</span>( * ) <span class="keyword">AS</span> SPACENUM </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">ESDC_ODS.D5000_HISDB_OP_DEV_SX A</span><br><span class="line"><span class="keyword">JOIN</span> </span><br><span class="line">MONITORSIGNAL.TBSTATION_SX B </span><br><span class="line"><span class="keyword">ON</span> </span><br><span class="line">A.st_id = B.STATIONIDX </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">OCCUR_TIME &gt;= &#123; <span class="number">3</span> &#125; </span><br><span class="line"><span class="keyword">AND</span> OCCUR_TIME &lt; &#123; <span class="number">4</span> &#125; </span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">STATUS</span> = <span class="number">1</span> </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">st_id </span><br><span class="line">) N </span><br><span class="line"><span class="keyword">ON</span> </span><br><span class="line">M.stationidx = N.st_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">st_id,</span><br><span class="line"><span class="keyword">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">STATUS</span> = <span class="number">19</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> ) <span class="keyword">AS</span> STANUM,</span><br><span class="line"><span class="keyword">SUM</span>( <span class="keyword">CASE</span> <span class="keyword">WHEN</span> <span class="keyword">STATUS</span> = <span class="number">7</span> <span class="keyword">THEN</span> <span class="number">1</span> <span class="keyword">ELSE</span> <span class="number">0</span> <span class="keyword">END</span> ) <span class="keyword">AS</span> SIGNALNUM </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">ESDC_ODS.D5000_HISDB_OP_YX_SX </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">OCCUR_TIME &gt;= &#123; <span class="number">3</span> &#125; </span><br><span class="line"><span class="keyword">AND</span> OCCUR_TIME &lt; &#123; <span class="number">4</span> &#125; </span><br><span class="line"><span class="keyword">AND</span> (<span class="keyword">STATUS</span> = <span class="number">7</span> <span class="keyword">OR</span> <span class="keyword">STATUS</span> = <span class="number">19</span>)</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">st_id </span><br><span class="line">) O </span><br><span class="line"><span class="keyword">ON</span> </span><br><span class="line">M.STATIONIDX = O.st_id</span><br><span class="line"></span><br><span class="line"><span class="keyword">JOIN</span> </span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span></span><br><span class="line">EMS_EQUIP_ID,</span><br><span class="line">EQUIP_ID,</span><br><span class="line"><span class="keyword">NAME</span> </span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">SG_THEME.D5000_EMS_EQUIP_MAPPING I</span><br><span class="line"><span class="keyword">JOIN</span> SG_THEME.SG_CON_SUBSTATION_B D <span class="keyword">ON</span> I.EQUIP_ID = D.ID </span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">I.LX = <span class="string">'SG_CON_SUBSTATION_B'</span> </span><br><span class="line">) K </span><br><span class="line"><span class="keyword">ON</span> </span><br><span class="line">K.EMS_EQUIP_ID = M.STATIONIDX</span><br></pre></td></tr></table></figure><p>这个sql是真实业务场景下的一句SQL，emmm，比较长，但是很有代表性。下面就以这个sql解释知识点。</p><h2 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h2><ul><li><p>union、连接、分组的字段必须在连接之时是按照升序排序的。</p></li><li><p>按字符串处理之前必须是String类型，如果不是可以使用字段选择进行转换类型。</p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/kettle的基本使用/2019-08-06_153552.jpg"></div></li><li><p>记录集连接是两个表之间的连接，如果需要多个表做一个条件的连接使用multiway merge join。</p></li><li>数字类型和字符串类型做连接时可能会出错，需要将转换数据类型后再做连接。</li></ul><h2 id="JS脚本"><a href="#JS脚本" class="headerlink" title="JS脚本"></a>JS脚本</h2><p>有些需要使用到处理的语句需要使用JS进行处理，比如上面的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CASE WHEN RESTRAIN_FLAG = 0 OR RESTRAIN_FLAG IS NULL THEN 1 ELSE 0 END ) AS NNUM</span><br></pre></td></tr></table></figure><div align="center"><img width="80%" src="//isjinhao.github.io/2019/kettle的基本使用/2019-08-06_154702.jpg"></div><p>从上一步获得的输入可以在JS中直接使用，但是一定要注意数据类型对不对，虽然JS是弱类型，但是最好还是在使用时处理一下，比如使用<code>&#39;&#39;+XXX</code>进行转字符串，在做其他操作。</p><p>在脚本中用var定义的变量可以在下方的字段中被获取，获取之后就能作为输出字段输出。</p><p>记住：JS脚本的执行过程是将上一步输入的每一行都使用执行一遍JS，然后将每次执行后的结果合并。</p><h2 id="占位参数"><a href="#占位参数" class="headerlink" title="占位参数"></a>占位参数</h2><p>如果某个表（设为A）输入的SQL语句需要使用使用其他表的数据，我们可以在其之前加上一个表（设为B），将B表的数据输入到A表中。此时需要使用到占位参数。</p><div align="center"><img width="40%" src="//isjinhao.github.io/2019/kettle的基本使用/2019-08-06_155808.jpg"></div><p>B表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *,? <span class="keyword">as</span> d3,? <span class="keyword">as</span> d4 <span class="keyword">FROM</span> MONITORSIGNAL.TBSIGNALBASIS_SX_2019_01 A </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">SIGNAL_TIME &gt;= ?</span><br><span class="line"><span class="keyword">AND</span> SIGNAL_TIME &lt; ? <span class="keyword">ORDER</span> <span class="keyword">BY</span> STATIONIDX;</span><br></pre></td></tr></table></figure><p>A表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">lastexectime <span class="keyword">as</span> STA_DAY,</span><br><span class="line">lastexectime + numtodsinterval(intervalvalue, <span class="string">'minute'</span>) <span class="keyword">as</span> D41,</span><br><span class="line">lastexectime <span class="keyword">as</span> D32, </span><br><span class="line">lastexectime + numtodsinterval(intervalvalue, <span class="string">'minute'</span>) <span class="keyword">as</span> D42 </span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">monitorsignal.tbdataetlconfig</span><br></pre></td></tr></table></figure><p>占位参数是按顺序匹配。</p><p>两者的执行关系是：B表拿出每一行带入A表，A表依次执行，得到的所有数据在做合并拼接。</p><h2 id="变量参数"><a href="#变量参数" class="headerlink" title="变量参数"></a>变量参数</h2><p>占位参数的弊端是使用完就没了，上面所示的A表获得的四个字段在B表使用之后丢失，B表再传出的是其处理后的数据。所以如果我们需要跨几个操作使用就需要用到变量参数。</p><p>变量的设置方式：</p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/kettle的基本使用/2019-08-06_160633.jpg"></div><p>上图所示实在自定义常量数据中定义了一个数据，JS处理之后设置为变量，实际上不使用JS处理也可以直接设置为变量。</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>我们有时候需要做循环，比如再使用子表的时候，我们会对每个月的子表的分别就进行操作。这样就需要做一个循环，循环中只改变子表名。</p><p>设置一个转换来获取变量，比如从表中查一列。并且放在结果中，这个结果个人理解就是一个缓冲区，别的转换能从这个结果中拿数据。</p><div align="center"><img width="70%" src="//isjinhao.github.io/2019/kettle的基本使用/2019-08-06_163112.jpg"></div><p>在处理的时候再一行一行的拿数据。</p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/kettle的基本使用/2019-08-06_164741.jpg"></div><p>转换中需要设置一个阻塞，保证再使用到变量的时候此变量已被初始化。</p><div align="center"><img width="100%" src="//isjinhao.github.io/2019/kettle的基本使用/2019-08-06_164938.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;最近实习被公司安排用kettle处理数据，所以写一篇记录一下kettle的基本使用方法。&lt;/p&gt;&lt;h2 id=&quot;SQL&quot;&gt;&lt;a href=&quot;#S
      
    
    </summary>
    
      <category term="kettle" scheme="https://isjinhao.github.io/categories/kettle/"/>
    
    
      <category term="kettle" scheme="https://isjinhao.github.io/tags/kettle/"/>
    
      <category term="etl" scheme="https://isjinhao.github.io/tags/etl/"/>
    
  </entry>
  
  <entry>
    <title>11-面试题</title>
    <link href="https://isjinhao.github.io/2019/11-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://isjinhao.github.io/2019/11-面试题/</id>
    <published>2019-07-28T13:48:12.000Z</published>
    <updated>2019-08-23T08:07:24.933Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --><h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="控制某个方法允许并发访问线程的个数"><a href="#控制某个方法允许并发访问线程的个数" class="headerlink" title="控制某个方法允许并发访问线程的个数"></a>控制某个方法允许并发访问线程的个数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>, <span class="keyword">true</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    test();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            semaphore.acquire();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"进来了"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">"走了"</span>);</span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三个线程a、b、c并发运行，c、b需要a线程的数据怎么实现"><a href="#三个线程a、b、c并发运行，c、b需要a线程的数据怎么实现" class="headerlink" title="三个线程a、b、c并发运行，c、b需要a线程的数据怎么实现"></a>三个线程a、b、c并发运行，c、b需要a线程的数据怎么实现</h3><p>考虑到多线程的不确定性，因此我们不能确保 ThreadA 就一定先于 ThreadB 和 ThreadC 前执行，就算 ThreadA先执行了，我们也无法保证 ThreadA 什么时候才能将变量 num 给初始化完成。因此我们必须让 ThreadB 和 ThreadC去等待 ThreadA 完成任何后发出的消息。现在需要解决两个问题，一是让 ThreadB 和 ThreadC 等待ThreadA 先执行完，二是 ThreadA 执行完之后给ThreadB 和 ThreadC 发送消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCommunication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> num;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//模拟耗时操作之后初始化变量 num</span></span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    num = <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//初始化完参数后释放两个 permit</span></span><br><span class="line">                    semaphore.release(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取 permit，如果 semaphore 没有可用的 permit 则等待，如果有则消耗一个</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"获取到 num 的值为："</span> + num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Thread threadC = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//获取 permit，如果 semaphore 没有可用的 permit 则等待，如果有则消耗一个</span></span><br><span class="line">                    semaphore.acquire();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"获取到 num 的值为："</span> + num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//同时开启 3 个线程</span></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line">        threadC.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同一个类中的2个方法都加了同步锁，多个线程能同时访问同一个类中的这两个方法吗？"><a href="#同一个类中的2个方法都加了同步锁，多个线程能同时访问同一个类中的这两个方法吗？" class="headerlink" title="同一个类中的2个方法都加了同步锁，多个线程能同时访问同一个类中的这两个方法吗？"></a>同一个类中的2个方法都加了同步锁，多个线程能同时访问同一个类中的这两个方法吗？</h3><p>多个线程不可访问同一个类中的 2 个加了锁的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();<span class="comment">//设置 lock 锁</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Runnable run1 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock(); <span class="comment">//加锁</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//打印是否执行该方法</span></span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" run1: "</span> + count++);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//方法 2</span></span><br><span class="line">    <span class="keyword">public</span> Runnable run2 = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">1000</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() +</span><br><span class="line">                            <span class="string">" run2: "</span> + count++);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        TestA t = <span class="keyword">new</span> TestA(); <span class="comment">//创建一个对象</span></span><br><span class="line">        <span class="keyword">new</span> Thread(t.run1).start();<span class="comment">//获取该对象的方法 1</span></span><br><span class="line">        <span class="keyword">new</span> Thread(t.run2).start();<span class="comment">//获取该对象的方法 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h3><ul><li>互斥条件：线程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个线程所占有。此时若有其他线程请求该资源，则请求线程只能等待。</li><li>不剥夺条件：线程所获得的资源在未使用完毕之前，不能被其他线程强行夺走，即只能由获得该资源的线程自己来释放（只能是主动释放)。</li><li>请求和保持条件：线程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li><li>循环等待条件：存在一种线程资源的循环等待链，链中每一个线程已获得的资源同时被链中下一个线程所请求。即存在一个处于等待状态的线程集合{Pl, P2, …, pn}，其中 Pi 等待的资源被 P(i+1)占有（i=0, 1, …, n-1)，Pn 等待的资源被 P0 占有。</li></ul><h4 id="产生死锁的例子"><a href="#产生死锁的例子" class="headerlink" title="产生死锁的例子"></a>产生死锁的例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeadLock</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> flag = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object o1 = <span class="keyword">new</span> Object(), o2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"flag = "</span> + flag);</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"1"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (flag == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (o2) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">synchronized</span> (o1) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"0"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DeadLock td1 = <span class="keyword">new</span> DeadLock();</span><br><span class="line">        DeadLock td2 = <span class="keyword">new</span> DeadLock();</span><br><span class="line">        td1.flag = <span class="number">1</span>;</span><br><span class="line">        td2.flag = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//td1,td2 都处于可执行状态，但 JVM 线程调度先执行哪个线程是不确定的。</span></span><br><span class="line">        <span class="comment">//td2 的 run()可能在 td1 的 run()之前运行</span></span><br><span class="line">        <span class="keyword">new</span> Thread(td1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(td2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h3><h4 id="你看过HashMap源码嘛，知道原理嘛"><a href="#你看过HashMap源码嘛，知道原理嘛" class="headerlink" title="你看过HashMap源码嘛，知道原理嘛"></a>你看过HashMap源码嘛，知道原理嘛</h4><p>针对这个问题，嗯，当然是必须看过HashMap源码。至于原理：数组+链表+红黑树。</p><p>HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。</p><h4 id="为什么用数组-链表"><a href="#为什么用数组-链表" class="headerlink" title="为什么用数组+链表"></a>为什么用数组+链表</h4><ul><li><p>数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到。</p></li><li><p>链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。</p></li></ul><h4 id="hash冲突你还知道哪些解决办法"><a href="#hash冲突你还知道哪些解决办法" class="headerlink" title="hash冲突你还知道哪些解决办法"></a>hash冲突你还知道哪些解决办法</h4><p>比较出名的有四种：开放定址法、链地址法、再哈希法、公共溢出区域法</p><h4 id="我用LinkedList代替数组结构可以么"><a href="#我用LinkedList代替数组结构可以么" class="headerlink" title="我用LinkedList代替数组结构可以么"></a>我用LinkedList代替数组结构可以么</h4><p>这里我稍微说明一下，此题的意思是，源码中是这样的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry[] table = <span class="keyword">new</span> Entry[capacity];</span><br></pre></td></tr></table></figure><p>那我用下面这样表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Entry&gt; table = <span class="keyword">new</span> LinkedList&lt;Entry&gt;();</span><br></pre></td></tr></table></figure><ol><li>是否可行？答案很明显，必须是可以的。</li><li>既然是可以的，为什么HashMap不用LinkedList，而选用数组？因为用数组效率最高！</li><li>在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。</li><li>那ArrayList，底层也是数组，查找也快啊，为啥不用ArrayList？因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。而ArrayList的扩容机制是1.5倍扩容，那ArrayList为什么是1.5倍扩容这就不在本文说明了。</li></ol><h3 id="HashMap在什么条件下扩容"><a href="#HashMap在什么条件下扩容" class="headerlink" title="HashMap在什么条件下扩容"></a>HashMap在什么条件下扩容</h3><h4 id="HashMap在什么条件下扩容-1"><a href="#HashMap在什么条件下扩容-1" class="headerlink" title="HashMap在什么条件下扩容"></a>HashMap在什么条件下扩容</h4><p>如果bucket满了（超过load factor*current capacity），就要resize。默认load factor为0.75，为了最大程度避免哈希冲突。（current capacity为当前数组大小。</p><h4 id="为什么扩容是2的次幂"><a href="#为什么扩容是2的次幂" class="headerlink" title="为什么扩容是2的次幂"></a>为什么扩容是2的次幂</h4><h5 id="减少碰撞"><a href="#减少碰撞" class="headerlink" title="减少碰撞"></a>减少碰撞</h5><p>HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；这个算法实际就是取模，<code>hash%length</code>。但是，大家都知道这种运算不如位移运算快。因此，源码中做了优化hash &amp; (length-1)。也就是说hash%length==hash&amp;(length-1)。那为什么是2的n次方呢？因为2的n次方实际就是1后面n个0，2的n次方-1，实际就是n个1。如果length不为2的幂，比如15。那么length-1的2进制就会变成1110。在h为随机数的情况下，和1110做&amp;操作。尾数永远为0。那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用。这样会造成浪费，不随机等问题。 length-1 二进制中为1的位数越多，那么分布就平均。</p><h5 id="扩容时减少消耗"><a href="#扩容时减少消耗" class="headerlink" title="扩容时减少消耗"></a>扩容时减少消耗</h5><p>以下图为例，其中图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，n代表length。</p><div align="center"><img width="100%" src="//isjinhao.github.io/2019/11-面试题/599ef1bbd35bdf0551446727e6d7ea8922f.jpg"></div><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><div align="center"><img width="100%" src="//isjinhao.github.io/2019/11-面试题/1928fa5426bc9024bf3b445616fa0f5eb80.jpg"></div><p>resize过程中不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap“。</p><h4 id="hash方法为什么为什么要先高16位异或低16位再取模运算"><a href="#hash方法为什么为什么要先高16位异或低16位再取模运算" class="headerlink" title="hash方法为什么为什么要先高16位异或低16位再取模运算"></a>hash方法为什么为什么要先高16位异或低16位再取模运算</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hashmap这么做，只是为了降低hash冲突的几率。打个比方，当我们的length为16的时候，哈希码(字符串“abcabcabcabcabc”的key对应的哈希码)对(16-1)与操作，对于多个key生成的hashCode，只要哈希码的后4位为0，不论不论高位怎么变化，最终的结果均为0。</p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/11-面试题/2019-08-23_092053.jpg"></div><p>而加上高16位异或低16位的“扰动函数”后，结果如下：</p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/11-面试题/2019-08-23_092149.jpg"></div><p>可以看到: 扰动函数优化前：1954974080 % 16 = 1954974080 &amp; (16 - 1) = 0 扰动函数优化后：1955003654 % 16 = 1955003654 &amp; (16 - 1) = 6 很显然，减少了碰撞的几率。</p><h3 id="讲讲hashmap的get-put的过程"><a href="#讲讲hashmap的get-put的过程" class="headerlink" title="讲讲hashmap的get/put的过程"></a>讲讲hashmap的get/put的过程</h3><h4 id="知道hashmap中put元素的过程是什么样么"><a href="#知道hashmap中put元素的过程是什么样么" class="headerlink" title="知道hashmap中put元素的过程是什么样么"></a>知道hashmap中put元素的过程是什么样么</h4><ul><li>对key的hashCode()做hash运算，计算index</li><li>如果没碰撞直接放到bucket里；</li><li>如果碰撞了，以链表的形式存在buckets后；</li><li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树</li><li>如果节点已经存在就替换old value(保证key的唯一性)</li><li>如果bucket满了(超过load factor*current capacity)，就要resize。</li></ul><h4 id="知道hashmap中get元素的过程是什么样么"><a href="#知道hashmap中get元素的过程是什么样么" class="headerlink" title="知道hashmap中get元素的过程是什么样么"></a>知道hashmap中get元素的过程是什么样么</h4><ul><li>对key的hashCode()做hash运算，计算index;</li><li>如果在bucket里的第一个节点里直接命中，则直接返回；</li><li>如果有冲突，则通过key.equals(k)去查找对应的Entry;<ul><li>若为树，则在树中通过key.equals(k)查找，O(logn)；</li><li>若为链表，则在链表中通过key.equals(k)查找，O(n)。</li></ul></li></ul><h4 id="你还知道哪些hash算法"><a href="#你还知道哪些hash算法" class="headerlink" title="你还知道哪些hash算法"></a>你还知道哪些hash算法</h4><p>先说一下hash算法干嘛的，Hash函数是指把一个大范围映射到一个小范围。把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。比较出名的有MurmurHash、MD4、MD5等等。</p><h4 id="说说String中hashcode的实现"><a href="#说说String中hashcode的实现" class="headerlink" title="说说String中hashcode的实现"></a>说说String中hashcode的实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是以31为权，每一位为字符的ASCII值进行运算。哈希计算公式可以计为<code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code>那为什么以31为质数呢？主要是因为31是一个奇质数，所以<code>31*i=32*i-i=(i&lt;&lt;5)-i</code>，这种位移与减法结合的计算相比一般的运算快很多。</p><h3 id="为什么hashmap的在链表元素数量超过8时改为红黑树"><a href="#为什么hashmap的在链表元素数量超过8时改为红黑树" class="headerlink" title="为什么hashmap的在链表元素数量超过8时改为红黑树"></a>为什么hashmap的在链表元素数量超过8时改为红黑树</h3><h4 id="知道jdk1-8中hashmap改了啥么"><a href="#知道jdk1-8中hashmap改了啥么" class="headerlink" title="知道jdk1.8中hashmap改了啥么"></a>知道jdk1.8中hashmap改了啥么</h4><ul><li>由<strong>数组+链表</strong>的结构改为<strong>数组+链表+红黑树</strong>。</li><li>优化了高位运算的hash算法：h ^ (h&gt;&gt;&gt;16)</li><li>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。</li></ul><h4 id="为什么在解决hash冲突的时候，不直接用红黑树-而选择先用链表，再转红黑树"><a href="#为什么在解决hash冲突的时候，不直接用红黑树-而选择先用链表，再转红黑树" class="headerlink" title="为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树"></a>为什么在解决hash冲突的时候，不直接用红黑树?而选择先用链表，再转红黑树</h4><p>因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。当元素小于8个当时候，此时做查询操作，链表结构已经能保证查询性能。当元素大于8个的时候，此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。因此，如果一开始就用红黑树结构，元素太少，新增效率又比较慢，无疑这是浪费性能的。</p><h4 id="我不用红黑树，用二叉查找树可以么"><a href="#我不用红黑树，用二叉查找树可以么" class="headerlink" title="我不用红黑树，用二叉查找树可以么"></a>我不用红黑树，用二叉查找树可以么</h4><p>可以。但是二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。</p><h4 id="当链表转为红黑树后，什么时候退化为链表"><a href="#当链表转为红黑树后，什么时候退化为链表" class="headerlink" title="当链表转为红黑树后，什么时候退化为链表"></a>当链表转为红黑树后，什么时候退化为链表</h4><p>为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p><h3 id="你一般用什么作为HashMap的key"><a href="#你一般用什么作为HashMap的key" class="headerlink" title="你一般用什么作为HashMap的key"></a>你一般用什么作为HashMap的key</h3><h4 id="健可以为Null值么"><a href="#健可以为Null值么" class="headerlink" title="健可以为Null值么"></a>健可以为Null值么</h4><p>必须可以，key为null的时候，hash算法最后的值以0来计算，也就是放在数组的第一个位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="你一般用什么作为HashMap的key-1"><a href="#你一般用什么作为HashMap的key-1" class="headerlink" title="你一般用什么作为HashMap的key"></a>你一般用什么作为HashMap的key</h4><p>一般用Integer、String这种不可变类当HashMap当key，而且String最为常用。</p><ul><li>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</li><li>因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的覆写了hashCode()以及equals()方法。</li></ul><h4 id="我用可变类当HashMap的key有什么问题"><a href="#我用可变类当HashMap的key有什么问题" class="headerlink" title="我用可变类当HashMap的key有什么问题"></a>我用可变类当HashMap的key有什么问题</h4><p>hashcode可能发生改变，导致put进去的值，无法get出，如下所示：</p><h4 id="如果让你实现一个自定义的class作为HashMap的key该如何实现"><a href="#如果让你实现一个自定义的class作为HashMap的key该如何实现" class="headerlink" title="如果让你实现一个自定义的class作为HashMap的key该如何实现"></a>如果让你实现一个自定义的class作为HashMap的key该如何实现</h4><h5 id="针对问题一，记住下面四个原则即可"><a href="#针对问题一，记住下面四个原则即可" class="headerlink" title="针对问题一，记住下面四个原则即可"></a><strong>针对问题一，记住下面四个原则即可</strong></h5><ul><li>两个对象相等，hashcode一定相等</li><li>两个对象不等，hashcode不一定不等</li><li>hashcode相等，两个对象不一定相等</li><li>hashcode不等，两个对象一定不等</li></ul><h5 id="针对问题二，记住如何写一个不可变类"><a href="#针对问题二，记住如何写一个不可变类" class="headerlink" title="针对问题二，记住如何写一个不可变类"></a>针对问题二，记住如何写一个不可变类</h5><ul><li><p>类添加final修饰符，保证类不被继承。如果类可以被继承会破坏类的不可变性机制，只要继承类覆盖父类的方法并且继承类可以改变成员变量值，那么一旦子类以父类的形式出现时，不能保证当前类是否可变。</p></li><li><p>保证所有成员变量必须私有，并且加上final修饰。通过这种方式保证成员变量不可改变。但只做到这一步还不够，因为如果是对象成员变量有可能再外部改变其值。所以第4点弥补这个不足。</p></li><li><p>不提供改变成员变量的方法，包括setter避免通过其他接口改变成员变量的值，破坏不可变特性。</p></li><li><p>通过构造器初始化所有成员，进行深拷贝(deep copy)，如果构造器传入的对象直接赋值给成员变量，还是可以通过对传入对象的修改进而导致改变内部变量的值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableDemo</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] myArray;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImmutableDemo</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.myArray = array; <span class="comment">// wrong  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式不能保证不可变性，myArray和array指向同一块内存地址，用户可以在ImmutableDemo之外通过修改array对象的值来改变myArray内部的值。为了保证内部的值不被修改，可以采用深度copy来创建一个新内存保存传入的值。正确做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImmutableDemo</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] myArray;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyImmutableDemo</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.myArray = array.clone();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝，这种做法也是防止对象外泄，防止通过getter获得内部可变成员对象后对成员变量直接操作，导致成员变量发生改变。</p></li></ul><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</p><p>系统加载 Class 类型的文件主要三步:<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步:<strong>验证-&gt;准备-&gt;解析</strong>。</p><div align="center"><img width="60%" src="//isjinhao.github.io/2019/11-面试题/2019-08-23_115356.jpg"></div><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>类加载过程的第一步，主要完成下面3件事情：</p><ol><li>通过全类名获取定义此类的二进制字节流</li><li>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</li><li>在内存中生成一个代表该类的 Class 对象，作为方法区这些数据的访问入口</li></ol><p>虚拟机规范多上面这3点并不具体，因此是非常灵活的。比如：”通过全类名获取定义此类的二进制字节流” 并没有指明具体从哪里获取、怎样获取。比如：比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等。</p><p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的 loadClass() 方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><div align="center"><img width="60%" src="//isjinhao.github.io/2019/11-面试题/2019-08-23_115615.jpg"></div><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段</strong>，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：</p><ol><li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。</li><li>这里所设置的初始值”通常情况”下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了<code>public static int value = 111</code> ，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关键字<code>public static final int value = 111</code> ，那么准备阶段 value 的值就被复制为 111。</li></ol><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。</p><p>符号引用就是一组符号来描述目标，可以是任何字面量。<strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。在程序实际运行时，只有符号引用是不够的，举个例子：在程序执行方法时，系统需要明确知道这个方法所在的位置。Java 虚拟机为每个类都准备了一张方法表来存放类中所有的方法。当需要调用一个类的方法的时候，只要知道这个方法在方发表中的偏移量就可以直接调用该方法了。通过解析操作符号引用就可以直接转变为目标方法在类中方法表的位置，从而使得方法可以被调用。</p><p>综上，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，也就是得到类或者字段、方法在内存中的指针或者偏移量。</p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><strong>初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <code>&lt;clinit&gt; ()</code>方法的过程。</strong>（是类构造器，不是对象构造器）</p><p>对于<code>&lt;clinit&gt;()</code> 方法的调用，虚拟机会自己确保其在多线程环境中的安全性。因为 <code>&lt;clinit&gt;()</code> 方法是带锁线程安全，所以在多线程环境下进行类初始化的话可能会引起死锁，并且这种死锁很难被发现。</p><p>对于初始化阶段，虚拟机严格规范了有且只有5中情况下，必须对类进行初始化：</p><ol><li>当遇到 new 、 getstatic、putstatic或invokestatic 这4条直接码指令时，比如 new 一个类，读取一个静态字段(未被 final 修饰)、或调用一个类的静态方法时。</li><li>使用 <code>java.lang.reflect</code> 包的方法对类进行反射调用时 ，如果类没初始化，需要触发其初始化。</li><li>初始化一个类，如果其父类还未初始化，则先触发该父类的初始化。</li><li>当虚拟机启动时，用户需要定义一个要执行的主类 (包含 main 方法的那个类)，虚拟机会先初始化这个类。</li><li>当使用 JDK1.7 的动态语言时，如果一个 MethodHandle 实例的最后解析结构为 REF_getStatic、REF_putStatic、REF_invokeStatic、的方法句柄，并且这个句柄没有初始化，则需要先触发器初始化。</li></ol><h2 id="Java的引用"><a href="#Java的引用" class="headerlink" title="Java的引用"></a>Java的引用</h2><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><h3 id="引用分类"><a href="#引用分类" class="headerlink" title="引用分类"></a>引用分类</h3><p><strong>强引用</strong></p><p>Java中默认声明的就是强引用，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">//只要obj还指向Object对象，Object对象就不会被回收</span></span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">//手动置null</span></span><br></pre></td></tr></table></figure><p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了。</p><p><strong>软引用</strong></p><p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。下面以一个例子来进一步说明强引用和软引用的区别：<br>在运行下面的Java代码之前，需要先配置参数 -Xms2M -Xmx3M，将 JVM 的初始内存设为2M，最大可用内存为 3M。</p><p>首先先来测试一下强引用，在限制了 JVM 内存的前提下，下面的代码运行正常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         testStrongReference();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStrongReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当 new byte为 1M 时，程序运行正常</span></span><br><span class="line">        <span class="comment">// 当 new byte为 1M 时，程序报异常 OutOfMemoryError</span></span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着来看一下软引用会有什么不一样，在下面的示例中连续创建了 10 个大小为 1M 的字节数组，并赋值给了软引用，然后循环遍历将这些对象打印出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testSoftReference();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSoftReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; sr = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line">            list.add(sr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        System.gc(); <span class="comment">//主动通知垃圾回收</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">            Object obj = ((SoftReference) list.get(i)).get();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    [B@12a3a380</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们发现无论循环创建多少个软引用对象，打印结果总是只有最后一个对象被保留，其他的obj全都被置空回收了。这里就说明了在内存不足的情况下，软引用将会被自动回收。</p><p><strong>弱引用</strong></p><p>弱引用的引用强度比软引用要更弱一些，<strong>无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">        WeakReference&lt;<span class="keyword">byte</span>[]&gt; sr = <span class="keyword">new</span> WeakReference&lt;&gt;(buff);</span><br><span class="line">        list.add(sr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.gc(); <span class="comment">//主动通知垃圾回收</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; list.size(); i++)&#123;</span><br><span class="line">        Object obj = ((WeakReference) list.get(i)).get();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以发现所有被弱引用关联的对象都被垃圾回收了。</p><p><strong>虚引用</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。<strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h3 id="判断一个常量是废弃常量"><a href="#判断一个常量是废弃常量" class="headerlink" title="判断一个常量是废弃常量"></a>判断一个常量是废弃常量</h3><p>运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？</p><p>假如在常量池中存在字符串 “abc”，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池。</p><h3 id="判断一个类是无用的类"><a href="#判断一个类是无用的类" class="headerlink" title="判断一个类是无用的类"></a>判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="什么是垃圾回收"><a href="#什么是垃圾回收" class="headerlink" title="什么是垃圾回收"></a><strong>什么是垃圾回收</strong></h3><p>垃圾回收（Garbage Collection，GC），顾名思义就是释放垃圾占用的空间，防止内存泄露。有效的使用可以使用的内存，对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收。</p><p>Java 语言出来之前，大家都在拼命的写 C 或者 C++ 的程序，而此时存在一个很大的矛盾，C++ 等语言创建对象要不断的去开辟空间，不用的时候又需要不断的去释放控件，既要写构造函数，又要写析构函数，很多时候都在重复的 allocated，然后不停的析构。于是，有人就提出，能不能写一段程序实现这块功能，每次创建，释放控件的时候复用这段代码，而无需重复的书写呢？</p><p>1960年，基于 MIT 的 Lisp 首先提出了垃圾回收的概念，而这时 Java 还没有出世呢！所以实际上 GC 并不是Java的专利，GC 的历史远远大于 Java 的历史！</p><h3 id="怎么定义垃圾"><a href="#怎么定义垃圾" class="headerlink" title="怎么定义垃圾"></a><strong>怎么定义垃圾</strong></h3><p>既然我们要做垃圾回收，首先我们得搞清楚垃圾的定义是什么，哪些内存是需要回收的。</p><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a><strong>引用计数算法</strong></h4><p>引用计数算法（Reachability Counting）是通过在对象头中分配一个空间来保存该对象被引用的次数（Reference Count）。如果该对象被其它对象引用，则它的引用计数加1，如果删除对该对象的引用，那么它的引用计数就减1，当该对象的引用计数为0时，那么该对象就会被回收。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String m = new String(&quot;jack&quot;);</span><br></pre></td></tr></table></figure><p>先创建一个字符串，这时候”jack”有一个引用，就是 m。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/qdzZBE73hWsbhfAng9ibqfcbjrqgyRWqA0IN3crKpcmibhyypDpUSyq1G8awia1X1pAsB6VQVOAocEBUwOfRiaWoWQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>然后将 m 设置为 null，这时候”jack”的引用次数就等于0了，在引用计数算法中，意味着这块内容就需要被回收了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m = null;</span><br></pre></td></tr></table></figure><p><img src="https://mmbiz.qpic.cn/mmbiz_png/qdzZBE73hWsbhfAng9ibqfcbjrqgyRWqAp4xu2PFfmIzm1vPU7nqowJicHSwDdUZWiaPHSdT5EKUdhIsbTBRyZJKw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>引用计数算法是将垃圾回收分摊到整个应用程序的运行当中了，而不是在进行垃圾收集时，要挂起整个应用的运行，直到对堆中所有对象的处理都结束。因此，采用引用计数的垃圾收集不属于严格意义上的”Stop-The-World”的垃圾收集机制。</p><p>看似很美好，但我们知道JVM的垃圾回收就是”Stop-The-World”的，那是什么原因导致我们最终放弃了引用计数算法呢？看下面的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Object instance;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ReferenceCountingGC</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    ReferenceCountingGC a = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">"objA"</span>);</span><br><span class="line">    ReferenceCountingGC b = <span class="keyword">new</span> ReferenceCountingGC(<span class="string">"objB"</span>);</span><br><span class="line"></span><br><span class="line">    a.instance = b;</span><br><span class="line">    b.instance = a;</span><br><span class="line"></span><br><span class="line">    a = <span class="keyword">null</span>;</span><br><span class="line">    b = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>定义2个对象</p></li><li><p>相互引用</p></li><li>置空各自的声明引用</li></ol><p><img src="https://mmbiz.qpic.cn/mmbiz_png/qdzZBE73hWsbhfAng9ibqfcbjrqgyRWqAxp8rh0Z7icLP0dkyZwoYxHRqQqX8bjHqfASaV8oPMpxv2qUvPqyHfFQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="image.png"></p><p>我们可以看到，最后这2个对象已经不可能再被访问了，但由于他们相互引用着对方，导致它们的引用计数永远都不会为0，通过引用计数算法，也就永远无法通知GC收集器回收它们。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a><strong>可达性分析算法</strong></h4><p>可达性分析算法（Reachability Analysis）的基本思路是，通过一些被称为引用链（GC Roots）的对象作为起点，从这些节点开始向下搜索，搜索走过的路径被称为（Reference Chain)，当一个对象到 GC Roots 没有任何引用链相连时（即从 GC Roots 节点到该节点不可达），则证明该对象是不可用的。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/qdzZBE73hWsbhfAng9ibqfcbjrqgyRWqAAQhD9PcPnUPX2KbibTuazA8ONDE4NZ94xzA3MVibZ3KfQyrH0JvTH5OA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>通过可达性算法，成功解决了引用计数所无法解决的问题“循环依赖”，只要你无法与 GC Root 建立直接或间接的连接，系统就会判定你为可回收对象。那这样就引申出了另一个问题，哪些属于 GC Root。</p><h5 id="Java-内存区域"><a href="#Java-内存区域" class="headerlink" title="Java 内存区域"></a>Java 内存区域</h5><p>在 Java 语言中，可作为 GC Root 的对象包括以下4种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中 JNI（即一般说的 Native 方法）引用的对象</li></ul><div align="center"><img width="100%" src="//isjinhao.github.io/2019/11-面试题/2019-08-23_095538.jpg"></div><h5 id="虚拟机栈（栈帧中的本地变量表）中的引用"><a href="#虚拟机栈（栈帧中的本地变量表）中的引用" class="headerlink" title="虚拟机栈（栈帧中的本地变量表）中的引用"></a>虚拟机栈（栈帧中的本地变量表）中的引用</h5><p>此时的 s，即为 GC Root，当s置空时，localParameter 对象也断掉了与 GC Root 的引用链，将被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StackLocalParameter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StackLocalParameter</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    StackLocalParameter s = <span class="keyword">new</span> StackLocalParameter(<span class="string">"localParameter"</span>);</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法区中类静态属性的引用"><a href="#方法区中类静态属性的引用" class="headerlink" title="方法区中类静态属性的引用"></a>方法区中类静态属性的引用</h5><p>s 为 GC Root，s 置为 null，经过 GC 后，s 所指向的 properties 对象由于无法与 GC Root 建立关系被回收。而 m 作为类的静态属性，也属于 GC Root，parameter 对象依然与 GC root 建立着连接，所以此时 parameter 对象并不会被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaStaicProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> MethodAreaStaicProperties m;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAreaStaicProperties</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MethodAreaStaicProperties s = <span class="keyword">new</span> MethodAreaStaicProperties(<span class="string">"properties"</span>);</span><br><span class="line">    s.m = <span class="keyword">new</span> MethodAreaStaicProperties(<span class="string">"parameter"</span>);</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="方法区中常量的引用"><a href="#方法区中常量的引用" class="headerlink" title="方法区中常量的引用"></a>方法区中常量的引用</h5><p>m 即为方法区中的常量引用，也为 GC Root，s 置为 null 后，final 对象也不会因没有与 GC Root 建立联系而被回收。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodAreaStaicProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MethodAreaStaicProperties m = MethodAreaStaicProperties(<span class="string">"final"</span>);</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MethodAreaStaicProperties</span><span class="params">(String name)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MethodAreaStaicProperties s = <span class="keyword">new</span> MethodAreaStaicProperties(<span class="string">"staticProperties"</span>);</span><br><span class="line">    s = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="本地方法栈中的引用"><a href="#本地方法栈中的引用" class="headerlink" title="本地方法栈中的引用"></a>本地方法栈中的引用</h5><p>任何 Native 接口都会使用某种本地方法栈，实现的本地方法接口是使用 C 连接模型的话，那么它的本地方法栈就是 C 栈。当线程调用 Java 方法时，虚拟机会创建一个新的栈帧并压入 Java 栈。然而当它调用的是本地方法时，虚拟机会保持 Java 栈不变，不再在线程的 Java 栈中压入新的帧，虚拟机只是简单地动态连接并直接调用指定的本地方法。</p><div align="center"><img width="50%" src="//isjinhao.github.io/2019/11-面试题/2019-08-23_100427.jpg"></div><h3 id="怎么回收垃圾"><a href="#怎么回收垃圾" class="headerlink" title="怎么回收垃圾"></a><strong>怎么回收垃圾</strong></h3><p>在确定了哪些垃圾可以被回收后，垃圾收集器要做的事情就是开始进行垃圾回收，但是这里面涉及到一个问题是：如何高效地进行垃圾回收。由于Java虚拟机规范并没有对如何实现垃圾收集器做出明确的规定，因此各个厂商的虚拟机可以采用不同的方式来实现垃圾收集器，这里我们讨论几种常见的垃圾收集算法的核心思想。</p><h4 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a><strong>标记清除算法</strong></h4><div align="center"><img width="80%" src="//isjinhao.github.io/2019/11-面试题/2019-08-23_100613.jpg"></div><p>标记清除算法（Mark-Sweep）是最基础的一种垃圾回收算法，它分为2部分，先把内存区域中的这些对象进行标记，哪些属于可回收标记出来，然后把这些垃圾拎出来清理掉。就像上图一样，清理掉的垃圾就变成未使用的内存区域，等待被再次使用。</p><p>这逻辑再清晰不过了，并且也很好操作，但它存在一个很大的问题，那就是内存碎片。</p><p>上图中等方块的假设是 2M，小一些的是 1M，大一些的是 4M。等我们回收完，内存就会切成了很多段。我们知道开辟内存空间时，需要的是连续的内存区域，这时候我们需要一个 2M的内存区域，其中有2个 1M 是没法用的。这样就导致，其实我们本身还有这么多的内存的，但却用不了。</p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a><strong>复制算法</strong></h4><div align="center"><img width="80%" src="//isjinhao.github.io/2019/11-面试题/2019-08-23_100715.jpg"></div><p>复制算法（Copying）是在标记清除算法上演化而来，解决标记清除算法的内存碎片问题。它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。保证了内存的连续可用，内存分配时也就不用考虑内存碎片等复杂情况，逻辑清晰，运行高效。</p><p>上面的图很清楚，也很明显的暴露了另一个问题，合着我这140平的大三房，只能当70平米的小两房来使？代价实在太高。</p><h4 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a><strong>标记整理算法</strong></h4><div align="center"><img width="80%" src="//isjinhao.github.io/2019/11-面试题/2019-08-23_100756.jpg"></div><p>标记整理算法（Mark-Compact）标记过程仍然与标记清除算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，再清理掉端边界以外的内存区域。</p><p>标记整理算法一方面在标记-清除算法上做了升级，解决了内存碎片的问题，也规避了复制算法只能利用一半内存区域的弊端。看起来很美好，但从上图可以看到，它对内存变动更频繁，需要整理所有存活对象的引用地址，在效率上比复制算法要差很多。</p><h4 id="分代收集算法分代收集算法（Generational-Collection）"><a href="#分代收集算法分代收集算法（Generational-Collection）" class="headerlink" title="分代收集算法分代收集算法（Generational Collection）"></a>分代收集算法分代收集算法（Generational Collection）</h4><p>严格来说并不是一种思想或理论，而是融合上述3种基础的算法思想，而产生的针对不同情况所采用不同算法的一套组合拳。对象存活周期的不同将内存划分为几块。一般是把 Java 堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用标记-清理或者标记整理算法来进行回收。so，另一个问题来了，那内存区域到底被分为哪几块，每一块又有什么特别适合什么算法呢？</p><p><strong>内存模型与回收策略</strong></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/11-面试题/2019-08-23_101002.jpg"></div><p>Java 堆（Java Heap）是JVM所管理的内存中最大的一块，堆又是垃圾收集器管理的主要区域，这里我们主要分析一下 Java 堆的结构。</p><p>Java 堆主要分为2个区域：年轻代与老年代，其中年轻代又分 Eden 区和 Survivor 区，其中 Survivor 区又分 From 和 To 2个区。可能这时候大家会有疑问，为什么需要 Survivor 区，为什么Survivor 还要分2个区。不着急，我们从头到尾，看看对象到底是怎么来的，而它又是怎么没的。</p><h5 id="Eden-区"><a href="#Eden-区" class="headerlink" title="Eden 区"></a><strong>Eden 区</strong></h5><p>IBM 公司的专业研究表明，有将近98%的对象是朝生夕死，所以针对这一现状，大多数情况下，对象会在新生代 Eden 区中进行分配，当 Eden 区没有足够空间进行分配时，虚拟机会发起一次 Minor GC，Minor GC 相比 Major GC 更频繁，回收速度也更快。</p><p>通过 Minor GC 之后，Eden 会被清空，Eden 区中绝大部分对象会被回收，而那些无需回收的存活对象，将会进到 Survivor 的 From 区（若 From 区不够，则直接进入 Old 区）。</p><h5 id="Survivor-区"><a href="#Survivor-区" class="headerlink" title="Survivor 区"></a><strong>Survivor 区</strong></h5><p>Survivor 区相当于是 Eden 区和 Old 区的一个缓冲，类似于我们交通灯中的黄灯。Survivor 又分为2个区，一个是 From 区，一个是 To 区。每次执行 Minor GC，会将 Eden 区和 From 存活的对象放到 Survivor 的 To 区（如果 To 区不够，则直接进入 Old 区）。</p><p>为啥需要？</p><p>不就是新生代到老年代么，直接 Eden 到 Old 不好了吗，为啥要这么复杂。想想如果没有 Survivor 区，Eden 区每进行一次 Minor GC，存活的对象就会被送到老年代，老年代很快就会被填满。而有很多对象虽然一次 Minor GC 没有消灭，但其实也并不会蹦跶多久，或许第二次，第三次就需要被清除。这时候移入老年区，很明显不是一个明智的决定。</p><p>所以，Survivor 的存在意义就是减少被送到老年代的对象，进而减少 Major GC 的发生。Survivor 的预筛选保证，只有经历16次 Minor GC 还能在新生代中存活的对象，才会被送到老年代。</p><p>为啥需要俩？</p><p>设置两个 Survivor 区最大的好处就是解决内存碎片化。</p><p>我们先假设一下，Survivor 如果只有一个区域会怎样。Minor GC 执行后，Eden 区被清空了，存活的对象放到了 Survivor 区，而之前 Survivor 区中的对象，可能也有一些是需要被清除的。问题来了，这时候我们怎么清除它们？在这种场景下，我们只能标记清除，而我们知道标记清除最大的问题就是内存碎片，在新生代这种经常会消亡的区域，采用标记清除必然会让内存产生严重的碎片化。因为 Survivor 有2个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，From 与 To 职责兑换，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。</p><p>这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。那么，Survivor 为什么不分更多块呢？比方说分成三个、四个、五个?显然，如果 Survivor 区再细分下去，每一块的空间就会比较小，容易导致 Survivor 区满，两块 Survivor 区可能是经过权衡之后的最佳方案。</p><h5 id="Old-区"><a href="#Old-区" class="headerlink" title="Old 区"></a><strong>Old 区</strong></h5><p>老年代占据着2/3的堆内存空间，只有在 Major GC 的时候才会进行清理，每次 GC 都会触发“Stop-The-World”。内存越大，STW 的时间也越长，所以内存也不仅仅是越大就越好。由于复制算法在对象存活率较高的老年代会进行很多次的复制操作，效率很低，所以老年代这里采用的是标记——整理算法。</p><p>除了上述所说，在内存担保机制下，无法安置的对象会直接进到老年代，以下几种情况也会进入老年代。</p><ul><li>大对象：大对象指需要大量连续内存空间的对象，这部分对象不管是不是“朝生夕死”，都会直接进到老年代。这样做主要是为了避免在 Eden 区及2个 Survivor 区之间发生大量的内存复制。当你的系统有非常多“朝生夕死”的大对象时，得注意了。</li><li>长期存活对象：虚拟机给每个对象定义了一个对象年龄（Age）计数器。正常情况下对象会不断的在 Survivor 的 From 区与 To 区之间移动，对象在 Survivor 区中每经历一次 Minor GC，年龄就增加1岁。当年龄增加到15岁时，这时候就会被转移到老年代。当然，这里的15，JVM 也支持进行特殊设置。</li><li>动态对象年龄：虚拟机并不重视要求对象年龄必须到15岁，才会放入老年区，如果 Survivor 空间中相同年龄所有对象大小的总合大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进去老年区，无需等你“成年”。这其实有点类似于负载均衡，轮询是负载均衡的一种，保证每台机器都分得同样的请求。看似很均衡，但每台机的硬件不通，健康状况不同，我们还可以基于每台机接受的请求数，或每台机的响应时间等，来调整我们的负载均衡算法。</li></ul><p><strong>空间分配担保</strong></p><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进程一次Minor GC（尽管此次GC是有风险的），如果小于或者不允许冒险，需要进行一次Full GC。</p><h3 id="GC分类"><a href="#GC分类" class="headerlink" title="GC分类"></a>GC分类</h3><p>老年代：major gc。新生代：minor gc。全清理：full gc。major gc+minor gc = full gc，如果是新生代不够了，会触发minor gc，如果minor gc将一部分移到老年代，老年代不够会触发major gc，所以一般major gc会伴随minor gc，进而形成full gc。但是像大对象直接进入major gc不会伴随minor gc。</p><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>JVM则是JRE中的核心组成部分，承担分析和执行Java字节码的工作。在Java历史上有很多发行的Java虚拟机，但目前一般都是<code>HotSpot</code>。查看本机JVM：<code>java -version</code></p><div align="center"><img src="//isjinhao.github.io/2019/11-面试题/查看JVM.jpg" style="width:80%"></div><h4 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h4><p>Java虚拟机在执行Java程序的时候会把它所管理的内存区域划分为若干个不同的数据区域。根据JVM规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。</p><h3 id="运行时数据区划分"><a href="#运行时数据区划分" class="headerlink" title="运行时数据区划分"></a>运行时数据区划分</h3><div align="center"><img src="//isjinhao.github.io/2019/11-面试题/1.8内存模型.jpg" style="width:60%"></div><h4 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h4><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</p><p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>从上面的介绍中我们知道程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h5 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h5><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</p><p>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息）</p><p>局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向一条字节码指令的地址）。</p><p>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</p><ul><li><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li><li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li></ul><p>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><p><strong>扩展：那么方法/函数如何调用？</strong></p><p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>Java方法有两种返回方式：</p><ul><li>return 语句。</li><li>抛出异常。</li></ul><p>不管哪种返回方式都会导致栈帧被弹出。</p><h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p><h4 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h4><h5 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h5><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代。再细致一点有：<code>Eden空间</code>、<code>From Survivor</code>、<code>To Survivor</code>空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TwVibBF785ic5RU2iafKlnVEsC7XwTj6XECpS7ibPzdgmc3pqrvwf99HymgMU9xJnAMfsicDsuY1XxVlug/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>上图所示的eden区、s0区、s1区都属于新生代，tentired区属于老年代。大部分情况，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0或者s1，并且对象的年龄还会加 1（<code>Eden区-&gt;Survivor</code> 区后对象的初始年龄变为1），当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h6 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h6><p>运行时常量池在JDK8及以后存放在堆中。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p><ul><li>字面量就是指这个量本身，比如字面量3。也就是指3。再比如 string类型的字面量”ABC”, 这个”ABC” 通过字来描述。 可以理解成一眼就能知道的量。</li></ul><p>既然运行时常量池时方法区的一部分，自然受到堆内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。方法区存放在元空间中。</p><p>元空间使用的是直接内存。我们可以使用参数： <code>-XX:MetaspaceSize</code> 来指定元数据区的大小。如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。</p><p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h3 id="类的各个部分分别在哪个位置"><a href="#类的各个部分分别在哪个位置" class="headerlink" title="类的各个部分分别在哪个位置"></a>类的各个部分分别在哪个位置</h3><ul><li>字节码：方法区</li><li>方法：方法区</li><li>字节码对象：堆</li><li>普通对象：大部分存在于堆。更多参考：<a href="https://blog.csdn.net/rickiyeat/article/details/76802085" target="_blank" rel="noopener">https://blog.csdn.net/rickiyeat/article/details/76802085</a></li><li>对象的属性：大部分存在于堆</li><li>static属性：方法区</li><li>方法中的局部变量：Java虚拟机栈</li><li>String对象：堆或常量池</li></ul><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><div align="center"><img src="//isjinhao.github.io/2019/11-面试题/对象的创建.jpg" style="width:80%"></div><ul><li><strong>类加载检查：</strong> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</li><li><strong>分配内存：</strong> 在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</li></ul><h3 id="内存分配的两种方式"><a href="#内存分配的两种方式" class="headerlink" title="内存分配的两种方式"></a>内存分配的两种方式</h3><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。</p><ul><li>指针碰撞：假设JAVA堆中的内存时绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式成为“指针碰撞”。</li><li>空闲链表：如果JAVA堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式成为“空闲列表”。</li><li><strong>初始化零值：</strong> 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>设置对象头：</strong> 初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li><li><strong>执行 init 方法：</strong> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li></ul><h3 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a><strong>内存分配并发问题</strong></h3><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，否则比如当虚拟机正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存就会引发严重的问题。通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在Eden区分配一块儿内存，称为本地线程分配缓存（Thread Local Allocation Buffer，TLAB），JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。</li></ul><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为3块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的自身运行时数据</strong>（哈希码、GC分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种：</p><ul><li><strong>句柄：</strong> 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li></ul><div align="center"><img src="//isjinhao.github.io/2019/11-面试题/句柄.jpg" style="width:80%"></div><ul><li><strong>直接指针</strong>：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/11-面试题/指针.jpg" style="width:80%"></div><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><h2 id="初始化问题解析"><a href="#初始化问题解析" class="headerlink" title="初始化问题解析"></a>初始化问题解析</h2><p>规则：</p><ul><li>静态先于普通</li><li>父类先于子类</li><li>创建对象必须先初始化类（初始化属性）</li><li>获得子类对象必须先获得一份父类对象</li><li>默认的加载方式和Class.forName执行：<code>加载、链接、初始化</code>。classloader.load仅执行<code>加载</code>。</li><li>static在初始化的时候被执行（初始化的时候执行类构造器，即运行字节码）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Test"</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"person static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"MyClass"</span>);</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  test static</span></span><br><span class="line"><span class="comment">  myclass static</span></span><br><span class="line"><span class="comment">  person static</span></span><br><span class="line"><span class="comment">  person Test</span></span><br><span class="line"><span class="comment">  test constructor</span></span><br><span class="line"><span class="comment">  person MyClass</span></span><br><span class="line"><span class="comment">  myclass constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><ol><li>加载MyClass，发现Test没被加载，先去加载Test，因此会执行Test类中的static块</li><li>加载完Test，加载MyClass，因此执行MyClass中的static块</li><li>初始化MyClass，先去初始化Test</li><li>初始化Test，需要先加载Person类，因此执行Person的static块</li><li>构造Person对象时执行构造方法</li><li>构造Test对象时执行构造方法</li><li>构造MyClass对象时初始化一个Person对象</li><li>执行MyClass构造方法</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;并发&quot;&gt;&lt;a href=&quot;#并发&quot; class=&quot;headerlink&quot; title=&quot;并发&quot;&gt;&lt;/a&gt;并发&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/categories/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/tags/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="面试" scheme="https://isjinhao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>10-项目准备</title>
    <link href="https://isjinhao.github.io/2019/10-%E9%A1%B9%E7%9B%AE%E5%87%86%E5%A4%87/"/>
    <id>https://isjinhao.github.io/2019/10-项目准备/</id>
    <published>2019-07-28T13:48:06.000Z</published>
    <updated>2019-08-06T06:31:07.685Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>09-数据结构和编程能力</title>
    <link href="https://isjinhao.github.io/2019/09-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%BC%96%E7%A8%8B%E8%83%BD%E5%8A%9B/"/>
    <id>https://isjinhao.github.io/2019/09-数据结构和编程能力/</id>
    <published>2019-07-28T13:48:00.000Z</published>
    <updated>2019-08-27T11:19:22.672Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>由于红黑树本质上就是一棵二叉查找树，所以在了解红黑树之前，咱们先来看下二叉查找树。</p><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p><ul><li>若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>任意结点的左、右子树也分别为二叉查找树。</li><li>没有键值相等的结点（no duplicate nodes）。</li></ul><p>因为，一棵由n个结点，随机构造的二叉查找树的高度为lgn，一般操作的执行时间为O（lgn）。但二叉树若退化成了一棵具有n个结点的线性链后，则此些操作最坏情况运行时间为O（n）。</p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>红黑树是一颗平衡二叉树，平衡二叉树的概念：每课树的左右子树高度差都不超过1。</p><ul><li>每个结点都有颜色，红色或者黑色</li><li>根结点是黑色的</li><li>每个叶结点是黑色的（设叶结点是NIL，但它不是一个空节点，是一个哨兵）</li><li>如果一个结点是红色的，则它的两个子结点都是黑色的</li><li>对每个结点，从该结点到其所有后代结点的简单路径上，均包含相同数目的黑色结点</li></ul><div align="center"><img width="80%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/2019-07-12_181943.jpg"></div><br>图中的NIL其实可以用一个哨兵（T.nil）替代，但在画图时往往其实不画NIL结点。<br><br><br><br>### 旋转<br><br>对红黑树的增加和删除会破坏红黑树原本的性质，旋转是用来使其恢复到红黑树的手段。<br><br>#### 左旋<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/2.jpg"></div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LEFT-ROTATE(T, x)    设x是图中的pivot</span></span><br><span class="line">y = x.right</span><br><span class="line">x.right = y.left</span><br><span class="line"><span class="keyword">if</span> y.left != T.nil</span><br><span class="line">y.left.p = x</span><br><span class="line">y.p = x.p</span><br><span class="line"><span class="keyword">if</span> x.p == T.nil</span><br><span class="line">T.root = y</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> x == x.p.left<span class="comment">// 判断应该放在P的左子树还是右子树上</span></span><br><span class="line">x.p.left = y</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    x.p.right = y</span><br><span class="line">y.left = x</span><br><span class="line">x.p = y</span><br></pre></td></tr></table></figure><br><br>#### 右旋<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/3.jpg"></div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RIGHT-ROTATE(T, x)    设x是图中的pivot</span></span><br><span class="line">y = x.left</span><br><span class="line">x.left = y.right</span><br><span class="line"><span class="keyword">if</span> y.right != T.nil</span><br><span class="line">y.right.p = x</span><br><span class="line">y.p = x.p</span><br><span class="line"><span class="keyword">if</span> x.p == T.nil</span><br><span class="line">T.root = y</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> x == x.p.right<span class="comment">// 判断应该放在P的左子树还是右子树上</span></span><br><span class="line">x.p.right = y</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    x.p.lrft = y</span><br><span class="line">y.right = x</span><br><span class="line">x.p = y</span><br></pre></td></tr></table></figure><br><br>### 二叉查找树的插入<br><br>如果要在二叉查找树中插入一个结点，首先要查找到结点插入的位置，然后进行插入，假设插入的结点为z的话，插入的伪代码如下：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TREE-INSERT(T, z)</span></span><br><span class="line">y = T.nil</span><br><span class="line">x = T.root</span><br><span class="line"><span class="keyword">while</span> x != NIL</span><br><span class="line">y = x</span><br><span class="line"><span class="keyword">if</span> z.key &lt; x.key</span><br><span class="line">x = x.left</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        x = x.right</span><br><span class="line">z.p = y</span><br><span class="line"><span class="keyword">if</span> y == NIL</span><br><span class="line">T.root = z              <span class="comment">// Tree T was empty</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z.key &lt; y.key</span><br><span class="line">y.left = z</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y.right = z</span><br></pre></td></tr></table></figure><br><br>### 红黑树的插入<br><br>如果我们插入的是黑色节点，会违反了性质五，需要进行大规模调整，如果我们插入的是红色节点，那就只有在要插入节点的父节点也是红色的时候违反性质四或者是当插入的节点是根节点时，违反性质二，所以，我们把要插入的节点的颜色变成红色。仍然设被插入结点是z：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RB-INSERT(T, z)</span></span><br><span class="line">y = T.nil</span><br><span class="line">x = T.root</span><br><span class="line"><span class="keyword">while</span> x != T.nil</span><br><span class="line">y = x</span><br><span class="line"><span class="keyword">if</span> z.key &lt; x.key</span><br><span class="line">x = x.left</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x = x.right</span><br><span class="line">z.p = y</span><br><span class="line"><span class="keyword">if</span> y == T.nil</span><br><span class="line">T.root = z</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z.key &lt; y.key</span><br><span class="line">y.left = z</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    y.right = z</span><br><span class="line">z.left = T.nil</span><br><span class="line">z.right = T.nil</span><br><span class="line">z.color = RED</span><br><span class="line">RB-INSERT-FIXUP(T, z)</span><br></pre></td></tr></table></figure><br><br>我们把上面这段红黑树的插入代码，跟我们之前看到的二叉查找树的插入代码，可以看出，RB-INSERT(T, z)前面的16行代码基本就是二叉查找树的插入代码，然后第17-18行代码把z的左孩子、右孩子都赋为叶结点nil，第19行再把z结点着为红色，最后为保证红黑性质在插入操作后依然保持，调用一个辅助程序RB-INSERT-FIXUP来对结点进行重新着色，并旋转。 <strong>换言之</strong>：<br><br>- 如果插入的是根结点，因为原树是空树，此情况只会违反性质2，所以直接把此结点涂为黑色。<br>- 如果插入的结点的父结点是黑色，由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时也是什么也不做。<br><br>但当遇到下述3种情况时需要修复：<br><br>- 插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色<br>- 插入修复情况2：当前结点的父结点是红色，叔叔结点是黑色，当前结点是其父结点的右子<br>- 插入修复情况3：当前结点的父结点是红色，叔叔结点是黑色，当前结点是其父结点的左子<br><br><br><br>#### 修复<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T, z)</span><br><span class="line"><span class="keyword">while</span> z.p.color == RED</span><br><span class="line"><span class="keyword">if</span> z.p == z.p.p.left</span><br><span class="line">y = z.p.p.right<span class="comment">// 指向叔叔结点</span></span><br><span class="line"><span class="keyword">if</span> y.color == RED</span><br><span class="line">z.p.color = BLACK</span><br><span class="line">y.color = BLACK</span><br><span class="line">z.p.p.color = RED</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z == z.p.right</span><br><span class="line">z = z.p</span><br><span class="line">LEFT-ROTATE(T, z)</span><br><span class="line">        z.p.color = BLACK</span><br><span class="line">        z.p.p.color = RED</span><br><span class="line">        RIGHT-ROTATE(T, z.p.p)</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 与 if 对称，等下只分析if，不分析else</span></span><br><span class="line">y = z.p.p.left</span><br><span class="line"><span class="keyword">if</span> y.color == RED</span><br><span class="line">z.p.color = BLACK</span><br><span class="line">z.p.p.color = RED</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z == z.p.left</span><br><span class="line">z = z.p</span><br><span class="line">RIGHT-ROTATE(T, z)</span><br><span class="line">        z.p.color = BLACK</span><br><span class="line">        z.p.p.color = RED</span><br><span class="line">        LEFT-ROTATE(T, z.p.p)</span><br><span class="line">T.root.color = BLACK</span><br></pre></td></tr></table></figure><br><br>下面，咱们来分别处理上述3种插入修复情况。<br><br><strong>插入修复情况1：当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色。</strong><br><br>上诉代码中第5行至第8行是处理这种情况：将父结点和叔叔结点涂黑，将爷爷结点涂红。<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/4.png"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/5.png"></div><br><strong>插入修复情况2：当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的右子</strong><br><br>上诉代码中第9行至第11行是处理这种情况：当前结点的父结点做为新的当前结点，以新当前结点为支点左旋。<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/6.png"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/7.png"></div><br><strong>插入修复情况3：当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的左子</strong><br><br>上述代码中的12-14行处理此种情况：父结点变为黑色，祖父结点变为红色，在祖父结点为支点右旋。<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/8.png"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/9.png"></div><br>### 二叉查找树的后继<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TREE-SUCCESSOR(x)</span></span><br><span class="line"><span class="keyword">if</span> x.right != T.nil</span><br><span class="line"><span class="keyword">return</span> TREE-MINIMUM(x.right)</span><br><span class="line">y = x.p</span><br><span class="line"><span class="keyword">while</span> y != T.nil and x == y.right</span><br><span class="line">x = y</span><br><span class="line">y = y.p</span><br><span class="line"><span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><br><br>$x$是待查找结点，右子树不为空，右子树的最小值所在的节点是后继。解释第<code>4-8</code>行代码需要证明一个定理：<br><br>&gt; 对于一棵二叉搜索树T，其关键字各不相同，如果T中一个节点$x$的右子树为空，且$x$有一个后继$y$，那么$y$一定是$x$的最底层祖先，并且其左孩子也是$x$的祖先。（每个结点都是其自身的祖先）<br><br>#### 证明<br><br>对于给定结点$x$，若其后继$y$存在，则$y &gt; x$。<br><br>1. 考虑结点$x$，对于$x$的左子树，显然其中任意结点值都小于$x$，所以$y$必定不在其左子树中。<br>2. $x$的右子树，其中任意结点值都大于$x$,但是根据题设，其右子树为空。<br><br>所以，$y$必定为$x$的祖先或其祖先的右子树。<br><br>又因为$y$是其中大于$x$且最小的一个，则$y$不可能是其祖先的右子树，那么我们可以将范围缩小至$y$必定为$x$的某一祖先，又根据$y&gt;x$，则$x$必定在$y$的左子树中，即$y$的左孩子也是$x$的祖先（$x$也是$x$的祖先）<br><br>对于所有满足条件的，假设有$p_0,p_1 \dots p_n$共$n+1$个，且$p_0 &lt; p_1 &lt; p_2 &lt; \dots &lt; p_n$。显然，$x$的前驱结点$y$必定是其中的最小一个，即$y=p_0$。又因为$y$是$x$的祖先，则$y$必然是$x$的最底层祖先。<br><br>#### 结论<br><br>这个定理实际的意义是，对于二叉搜索树中的一个节点（$x$），如果其不存在右子树且还有后继（$y$），则$y$是$x$祖先节点中有左子树的最底层祖先。如下图中13的后继是15。<br><br><div align="center"><img width="70%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/后继图示.jpg"></div><br>### 二叉查找树的前驱<br><br>前驱的代码和后继对应。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-PREDECESSOR(x)</span><br><span class="line"><span class="keyword">if</span> x.left != <span class="keyword">null</span></span><br><span class="line"><span class="keyword">return</span> TREE-MAXNUM(x.left);</span><br><span class="line">y = x.p</span><br><span class="line"><span class="keyword">while</span> y != <span class="keyword">null</span> and x == y.left</span><br><span class="line">x = y</span><br><span class="line">y = y.p</span><br><span class="line"><span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><br><br><code>3-7</code>行代码的意思是，对于二叉搜索树中的一个节点（$x$），如果其不存在左子树且还有前驱（$y$），则$y$是$x$祖先节点中有右子树的最底层祖先。如图中17的前驱是15。<br><br><br><br>### 二叉查找树的删除<br><br>讨论删除之前需要证明一个定理：<br><br>&gt; 如果一个二叉搜索树中的一个节点有两个孩子，那么它的后继没有左孩子，它的前驱没有右孩子。<br><br>#### 证明<br><br>如果一棵二叉搜索树中的一个结点有两个孩子，那么它的后继为它的右子树中的最小值，所以它的后继没有左孩子，它的前驱为它的左子树中的最大值，所以它的前驱没有右孩子。<br><br><br><br>删除时有三种情况：<br><br>1. 如果被删除节点（$z$）没有孩子节点，直接删除，修改父节点相应指针指向空。<br>2. 如果$z$只有一个孩子，把孩子提到树中$z$所在的位置，并修改$z$的父节点，用$z$的孩子来替换。<br>3. 如果$z$有两个孩子，那么找$z$的后继$y$（一定在$z$的右子树中）。<br>1. 如果$y$是$z$的右孩子，用$y$替换$z$，同时留下$y$的右孩子。<br>2. 如果$y$不是$z$的右孩子，有之上定理可知，$y$是没有左孩子的，此时用$y$的右孩子替换$y$，用$y$替换$z$，不留下$y$的右孩子。<br><br>#### TRANSPLANT<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TRANSPLANT(T, u, v)</span></span><br><span class="line"><span class="keyword">if</span> u.p == T.nil</span><br><span class="line">T.root = v</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> u == u.p.left</span><br><span class="line">u.p.left = v</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">u.p.right = v</span><br><span class="line"><span class="keyword">if</span> v != T.nil</span><br><span class="line">v.p = u.p</span><br></pre></td></tr></table></figure><br><br><code>TRANSPLANT</code>的功能是在树$T$中用一棵以$v$为根的子树来替换一棵以$u$为根的子树。<br><br>- <code>2-3</code>行：当$u$是树根的时候，直接让$T$的根指向$v$。<br>- <code>4-5</code>行：当$u$是一个左孩子的时候，将$v$放在$u$的左孩子的位置。<br>- <code>6</code>行：当$u$是一个右孩子的时候，将$v$放在$u$的右孩子的位置。<br>- <code>7-8</code>行：更新$v$的父节点。<br><br>#### TREE-DELETE<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TREE-DELETE(T, z)</span><br><span class="line"><span class="keyword">if</span> z.left == T.nil</span><br><span class="line">TRANSPLANT(T, z, z.right)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z.right == T.nil</span><br><span class="line">TRANSPLANT(T, z, z.left)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    y = TREE-MINIMUM(z.right)</span><br><span class="line"><span class="keyword">if</span> y.p != z</span><br><span class="line">TRANSPLANT(T, y, y.right)</span><br><span class="line">        y.right = z.right</span><br><span class="line">        y.right.p = y</span><br><span class="line">    TRANSPLANT(T, z, y)</span><br><span class="line">    y.left = z.left</span><br><span class="line">    y.left.p = y</span><br></pre></td></tr></table></figure><br><br>1. <code>2-5</code>行：如果$z$没有左孩子，那么用其右孩子替换$z$。如果$z$没有右孩子，那么用其左孩子替换$z$。<br>2. <code>12-14</code>行：如果$y$是$z$的右孩子，用$y$替换$z$，同时留下$z$的左孩子。<br>3. <code>7-11</code>行：如果如果$z$有两个孩子，且$y$不是$z$的右孩子，用$y$的右孩子替换$y$，用$y$替换$z$。<br><br><div align="center"><img width="100%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/删除图示.jpg"></div><br>### 红黑树的删除<br><br>红黑树的删除和二叉查找树的删除有类似的结构。<br><br>#### RB-TRANSPLANT<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RB-TRANSPLANT(T, u, v)</span></span><br><span class="line"><span class="keyword">if</span> u.p == T.nil</span><br><span class="line">T.root = v</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> u == u.p.left</span><br><span class="line">u.p.left = v</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">u.p.right = v</span><br><span class="line">v.p = u.p</span><br></pre></td></tr></table></figure><br><br>过程RB-TRANSPLANT与TRANSPLANT有一点不同，即第8行无条件赋值，因为红黑树中的哨兵不是空。<br><br>#### RB-DELETE<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RB-DELETE(T, z)</span></span><br><span class="line">y = z</span><br><span class="line">y-original-color = y.color<span class="comment">// 删除的结点的颜色</span></span><br><span class="line"><span class="keyword">if</span> z.left == T.nil<span class="comment">// 左子树为空，右子树直接上去</span></span><br><span class="line">x = z.right<span class="comment">// x指向被删除结点的右孩子</span></span><br><span class="line">RB-TRANSPLANT(T, z, z.right)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z.right == T.nil<span class="comment">// 右子树为空，右子树直接上去</span></span><br><span class="line">x = z.left</span><br><span class="line">RB-TRANSPLANT(T, z, z.left)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">y = TREE-MINIMUM(z.right)<span class="comment">// 右子树中最小的</span></span><br><span class="line">y-original-color = y.color<span class="comment">// 删除的节点的颜色</span></span><br><span class="line">x = y.right</span><br><span class="line"><span class="keyword">if</span> y.p == z</span><br><span class="line">x.p = y</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">RB-TRANSPLANT(T, y, y.right)<span class="comment">// 和二叉搜索树删除时第2、3点一致</span></span><br><span class="line">y.right = z.right</span><br><span class="line">y.right.p = y</span><br><span class="line">RB-TRANSPLANT(T, z, y)</span><br><span class="line">y.left = z.left</span><br><span class="line">y.left.p = y</span><br><span class="line">y.color = z.color</span><br><span class="line"><span class="keyword">if</span> y-original-color == BLACK<span class="comment">//当删除的是黑色时需要调整，红色不需要</span></span><br><span class="line">RB-DELETE-FIXUP(T, x)</span><br></pre></td></tr></table></figure><br><br>我们从被删结点后来顶替它的那个结点开始调整，并认为它有额外的一重黑色。这里额外一重黑色是什么意思呢，我们不是把红黑树的结点加上除红与黑的另一种颜色，这里只是一种假设，我们认为我们当前指向它，因此空有额外一种黑色，可以认为它的黑色是从它的父结点被删除后继承给它的，它现在可以容纳两种颜色，如果它原来是红色，那么现在是红+黑，如果原来是黑色，那么它现在的颜色是黑+黑。有了这重额外的黑色，原红黑树性质5就能保持不变。现在只要恢复其它性质就可以了，做法还是尽量向根移动和穷举所有可能性。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RB-DELETE-FIXUP(T, x)</span></span><br><span class="line"><span class="keyword">while</span> x != T.root and x.color == BLACK</span><br><span class="line"><span class="keyword">if</span> x == x.p.left</span><br><span class="line">w = x.p.right  <span class="comment">// 兄弟结点</span></span><br><span class="line"><span class="keyword">if</span> w.color == RED</span><br><span class="line">w.color = BLACK</span><br><span class="line">x.p.color = RED</span><br><span class="line">LEFT-ROTATE(T, x.p)</span><br><span class="line">            w = x.p.right</span><br><span class="line">        <span class="keyword">if</span> w.left.color == BLACK and w.right.color == BLACK</span><br><span class="line">        w.color = RED</span><br><span class="line">        x = x.p</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> w.right.color == BLACK</span><br><span class="line">        w.left.color = BLACK</span><br><span class="line">        w.color= RED</span><br><span class="line">        RIGHT-RATATE(T, w)</span><br><span class="line">            w = x.p.right</span><br><span class="line">        w.color = x.p.color</span><br><span class="line">        x.p.color = BLACK</span><br><span class="line">        w.right.color = BLACK</span><br><span class="line">        LEFT-ROTATE(T, x.p)</span><br><span class="line">        x = T.root</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">same as then clause with <span class="string">"right"</span> and <span class="string">"left"</span> exchanged</span><br><span class="line">x.color = BLACK</span><br></pre></td></tr></table></figure><br><br>（y是被删除的结点，x是怼上去的结点，即x占据了y的位置）<br><br>如果y的颜色是RED，则y不可能为红黑树的根，所以不管x的颜色是什么，都不会影响到红黑树的性质。所以只考虑y的颜色为BLACK的情况。<br><br>在y的颜色是BLACK的情况下，如果x的颜色为RED的话，删除y之后，结点y所在的分支的黑高就会减1，所以，只需要将x的颜色变为BLACK，则该分支的黑高会加1，则会保持住红黑树的颜色性质。<br><br><strong>所以最终要考虑的情况就是：</strong>y颜色为BLACK，x的颜色为BLACK的情况。因把y删除后，x顶替y的位置，y所在分支的黑高减1，所以，假设x节点的颜色为BLACK-BLACK，简称BB，也就是原来y的BLACK增加到x上了，这样就保证了该分支的黑高不变，接下来要做的就是调整x所在的分支，使红黑树的性质保持不变，又分为下面的几种情况（只考虑x为左孩子的情况，右孩子的情况是对称的）<br><br><strong>删除修复情况1：当前结点是黑+黑且兄弟结点为红色(此时父结点和兄弟结点的子结点为黑)。</strong><br><br>解法：把父结点染成红色，把兄弟结点染成黑色，左旋，之后重新进入算法。此变换后原红黑树性质5不变，而把问题转化为兄弟结点为黑色的情况(注：变化前，原本就未违反性质5，只是为了<strong>把问题转化为兄弟结点为黑色的情况</strong>)。 即第5行至第9行。<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/10.jpg"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/11.jpg"></div><br><strong>删除修复情况2：当前结点是黑加黑且兄弟是黑色且兄弟结点的两个子结点全为黑色。</strong><br><br>解法：把当前结点和兄弟结点中抽取一重黑色追加到父结点上，把父结点当成新的当前结点，重新进入算法。（此变换后性质5不变），即第10-12行代码操作。<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/12.jpg"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/13.jpg"></div><br><strong>删除修复情况3：当前结点颜色是黑+黑，兄弟结点是黑色，兄弟的左子是红色，右子是黑色。</strong><br><br>解法：把兄弟结点染红，兄弟左子结点染黑，之后再以兄弟结点为支点解右旋，之后重新进入算法。此是把当前的情况转化为情况4，而性质5得以保持，即第13-17行代码：<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/14.jpg"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/15.jpg"></div><br><strong>删除修复情况4：当前结点颜色是黑-黑色，它的兄弟结点是黑色，但是兄弟结点的右子是红色，兄弟结点左子的颜色任意。</strong><br><br>解法：把兄弟结点染成当前结点父结点的颜色，把当前结点父结点染成黑色，兄弟结点右子染成黑色，之后以当前结点的父结点为支点进行左旋，此时算法结束，红黑树所有性质调整正确，即第18-22行代码，如下所示：<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/16.jpg"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/09-数据结构和编程能力/17.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;红黑树&quot;&gt;&lt;a href=&quot;#红黑树&quot; class=&quot;headerlink&quot; title=&quot;红黑树&quot;&gt;&lt;/a&gt;红黑树&lt;/h2&gt;&lt;h3 
      
    
    </summary>
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/categories/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/tags/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="面试" scheme="https://isjinhao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>08-并发</title>
    <link href="https://isjinhao.github.io/2019/08-%E5%B9%B6%E5%8F%91/"/>
    <id>https://isjinhao.github.io/2019/08-并发/</id>
    <published>2019-07-28T13:47:55.000Z</published>
    <updated>2019-08-22T06:35:48.862Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --><h2 id="线程的中断"><a href="#线程的中断" class="headerlink" title="线程的中断"></a>线程的中断</h2><h3 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h3><p>interrupt()是一个线程中断的方法，本人只在Java网络编程这门课的实验里用过一次。其可以使得处于阻塞状态的线程抛出一个异常，也就说，它可以用来中断一个正处于阻塞状态的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        MyThread thread = test.new MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">// 睡2秒，保证thread线程得到执行</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"进入睡眠状态"</span>);</span><br><span class="line">                Thread.currentThread().sleep(<span class="number">10000</span>);</span><br><span class="line">                System.out.println(<span class="string">"睡眠完毕"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                System.out.println(<span class="string">"得到中断异常"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"run方法执行完毕"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="isInterrupted"><a href="#isInterrupted" class="headerlink" title="isInterrupted()"></a>isInterrupted()</h3><p>interrupt()配合isInterrupted()能够中断正在运行的线程，因为调用interrupt方法相当于将中断标志位置为true，那么可以通过调用isInterrupted()判断中断标志是否被置位来中断线程的执行。比如下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        MyThread thread = test.new MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.currentThread().sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(!isInterrupted() &amp;&amp; i &lt; Integer.MAX_VALUE)&#123;</span><br><span class="line">                System.out.println(i+<span class="string">" while循环"</span>);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是以上的暂停程序运行的方法可以被替换为如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> isStop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!isStop)&#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStop</span><span class="params">(<span class="keyword">boolean</span> stop)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isStop = stop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>volatile的目的是禁止指令重排。参见：<a href="https://isjinhao.github.io/2019/volatile/#more">https://isjinhao.github.io/2019/volatile/#more</a></p><h3 id="interrupted"><a href="#interrupted" class="headerlink" title="interrupted()"></a>interrupted()</h3><blockquote><p>Tests whether the current thread has been interrupted. The <em>interrupted status</em> of the thread is cleared by this method. In other words, if this method were to be called twice in succession, the second call would return false (unless the current thread were interrupted again, after the first call had cleared its interrupted status and before the second call had examined it).</p><p>A thread interruption ignored because a thread was not alive at the time of the interrupt will be reflected by this method returning false.</p></blockquote><p>每个线程都有一个中断状态位：</p><ul><li><code>private native boolean isInterrupted(boolean ClearInterrupted);</code>：传入true重置状态位，传入false不重置状态位。返回此方法执行完成前线程中断状态位的状态。</li><li><code>public void interrupt()</code>：将中断状态位设置为true。</li><li><code>public boolean isInterrupted()</code>：查看当前状态位但是不影响状态位，内部实现原理isInterrupted(false)。</li><li><code>public static boolean interrupted()</code>：重置当前线程状态位（即如果状态位是true，则设置为false），内部实现原理isInterrupted(true)。</li></ul><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>按照时间发展呢的顺序，Java中是先出现了synchronized（since 1.0），再出现了Lock（since 5.0）。</p><p>在Java中，每一个对象都拥有一个锁标记（monitor），也称为监视器，我们可以使用synchronized关键字来标记一个方法或者代码块，当某个线程调用该对象的synchronized方法或者访问synchronized代码块时，这个线程便获得了该对象的锁，其他线程暂时无法访问这个方法，只有等待这个方法执行完毕或者代码块执行完毕，这个线程才会释放该对象的锁，其他线程才能执行这个方法或者代码块。</p><ul><li>synchronized方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通方法获得当前对象的锁，即this的锁。静态方法获得类的字节码对象的锁。</p><ul><li>synchronized代码块</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(synObject) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于synchronized方法或者synchronized代码块，当出现异常时，JVM会自动释放当前线程占用的锁，因此不会由于异常导致出现死锁现象。</p><h3 id="条件对象"><a href="#条件对象" class="headerlink" title="条件对象"></a>条件对象</h3><p>当一个线程进入临界区后却发现某一条件被满足之后它才能执行，比如在银行转账时，A向B账户转账，但是当A账户获得锁后，发现账户中没有钱，需要等待C账户给其转账之后其才能给B账户转账，这时它就需要释放锁，进入等待状态，并且当其的账户余额能保证向B转完账后不为负数这个条件时才能转账，同时当此条件被满足时其他线程需要通知等待的线程让其进入运行状态。方法如下：</p><ul><li>synchronized方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(条件x不满足)</span><br><span class="line">wait();</span><br><span class="line"><span class="keyword">if</span>(条件x被满足)</span><br><span class="line">notify() <span class="function">or <span class="title">notifyAll</span><span class="params">()</span>  <span class="comment">//唤醒等待在条件x上的线程</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><ul><li>synchronized代码块</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(synObject) &#123;</span><br><span class="line"><span class="keyword">if</span>(条件x不满足)</span><br><span class="line">wait();</span><br><span class="line"><span class="keyword">if</span>(条件x被满足)</span><br><span class="line">notify() <span class="function">or <span class="title">notifyAll</span><span class="params">()</span>  <span class="comment">//唤醒等待在条件x上的线程</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>但是如果还有一个条件可以迫使线程进入等待状态，在编程时只能将其也等待在条件x上，这就是其不足之一。</p><p>需要注意：对于synchronized方法或者synchronized代码块，当出现异常时，JVM会自动释放当前线程占用的锁，因此不会由于异常导致出现死锁现象。</p><h2 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h2><p>Lock接口定义的方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>tryLock()</code>方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，也就说这个方法无论如何都会立即返回。在拿不到锁时不会一直在那等待。</li><li><code>tryLock(long time, TimeUnit unit)</code>方法和<code>tryLock()</code>方法是类似的，只不过区别在于这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</li></ul><p>Lock接口的典型使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Lock lock = ...;</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//处理任务</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception ex)&#123;</span><br><span class="line">     </span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">    lock.unlock();   <span class="comment">//释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>翻译为是“可重入锁”，意思是如果锁具备可重入性，则称作为可重入锁。像synchronized和ReentrantLock都是可重入锁，可重入性在我看来实际上表明了锁的分配机制：基于线程的分配，而不是基于方法调用的分配。举个简单的例子，当一个线程执行到某个synchronized方法时，比如说method1，而在method1中会调用另外一个synchronized方法method2，此时线程不必重新去申请锁，而是可以直接执行方法method2。</p><p>按不同的分类，还有一类锁是中断锁，顾名思义，就是可以相应中断的锁。在Java中，synchronized就不是可中断锁，而Lock是可中断锁。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者在别的线程中中断它，这种就是可中断锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        MyThread thread0 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        MyThread thread1 = <span class="keyword">new</span> MyThread(test);</span><br><span class="line">        thread0.start();</span><br><span class="line">        thread1.start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        thread1.interrupt();</span><br><span class="line">    &#125;  </span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Thread thread)</span> <span class="keyword">throws</span> InterruptedException</span>&#123;</span><br><span class="line">        lock.lockInterruptibly();   </span><br><span class="line">        <span class="comment">//注意，如果需要正确中断等待锁的线程，必须将获取锁放在外面，然后将InterruptedException抛出</span></span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"得到了锁"</span>);</span><br><span class="line">            <span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">                <span class="keyword">if</span>(System.currentTimeMillis() - startTime &gt;= Integer.MAX_VALUE)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 *插入数据</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"执行finally"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(thread.getName()+<span class="string">"释放了锁"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Test test = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyThread</span><span class="params">(Test test)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.test = test;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test.insert(Thread.currentThread());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName()+<span class="string">"被中断"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，如果线程1首先获得锁，其会一直运行下去，此时线程0得不到锁就会永远等待下去。但是如果线程0首先获得锁，其会一直运行下去，所以此时线程1得不到锁，但是在主线程中线程1启用了interrupt()方法，而lockInterruptibly()可以响应中断。</p><h2 id="thread的状态"><a href="#thread的状态" class="headerlink" title="thread的状态"></a>thread的状态</h2><div align="center"><img src="//isjinhao.github.io/2019/08-并发/线程的状态.png"></div><br>### yield()<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JDK原型</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">yield</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><br><br>&gt; A hint to the scheduler that the current thread is willing to yield its current use of a processor. The scheduler is free to ignore this hint.<br><br>当yield()成功的时候会自动放弃时间片，转入就绪状态，然后和其它线程进行CPU的争夺。<br><br><br><br>### join()<br><br>join方法有三个重载版本：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">join()</span><br><span class="line">join(long millis)     //参数为毫秒</span><br><span class="line">join(long millis,int nanoseconds)    //第一参数为毫秒，第二个参数为纳秒</span><br></pre></td></tr></table></figure><br><br>假如在main线程中，调用thread.join方法，则main方法会等待thread线程执行完毕或者等待一定的时间。<br><br>- 如果调用的是无参join方法，则等待thread执行完毕。<br>- 如果调用的是指定了时间参数的join方法，则等待一定的时间。<br><br>#### join的实现<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span></span></span><br><span class="line"><span class="function"> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            wait(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">            <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            wait(delay);</span><br><span class="line">            now = System.currentTimeMillis() - base;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>join是使用wait来实现的，如果线程仍然活着，则等待对应的时间。当调用线程（设为A）执行到其他线程（设为B）的join()方法时，A阻塞在线程B的this对象（线程B本身），如第12行或第20行所示。从代码上我们看不出来什么时候notify线程A，但是JDK注释上描述：<br><br>&gt; As a thread terminates the this.notifyAll method is invoked.<br><br>笔者也是在此知道，当一个线程结束时会通知所有在其上等待的线程。<br><br><br><br>## ThreadLocal<br><br>### ThreadLocal使用<br><br>ThreadLocal是一个线程局部变量，我们都知道全局变量和局部变量的区别，拿Java举例就是定义在类中的是全局的变量，各个方法中都能访问得到（静态方法不能获得实例属性），而局部变量定义在方法中，只能在方法内访问。那线程局部变量（ThreadLocal）就是每个线程都会有一个局部变量，独立于变量的初始化副本，而各个副本是通过线程唯一标识相关联的。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> UniqueThreadIdGenerator t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TaskThread</span><span class="params">(String threadName, UniqueThreadIdGenerator t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.setName(threadName);</span><br><span class="line"><span class="keyword">this</span>.t = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> value = t.getUniqueId();</span><br><span class="line">System.out.println(<span class="string">"thread[ "</span> + Thread.currentThread().getName() + </span><br><span class="line">                <span class="string">" ] --&gt; uniqueId[ "</span> + value + <span class="string">" ]"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">UniqueThreadIdGenerator uniqueThreadId = <span class="keyword">new</span> UniqueThreadIdGenerator();</span><br><span class="line"><span class="comment">// 为每个线程生成一个唯一的局部标识</span></span><br><span class="line">TaskThread t1 = <span class="keyword">new</span> TaskThread(<span class="string">"custom-thread-1"</span>, uniqueThreadId);</span><br><span class="line">TaskThread t2 = <span class="keyword">new</span> TaskThread(<span class="string">"custom-thread-2"</span>, uniqueThreadId);</span><br><span class="line">TaskThread t3 = <span class="keyword">new</span> TaskThread(<span class="string">"custom-thread-3"</span>, uniqueThreadId);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniqueThreadIdGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程局部整型变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; uniqueNum = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUniqueId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">uniqueNum.set(uniqueNum.get() + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> uniqueNum.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread[ custom-thread-2 ] --&gt; uniqueId[ 1 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-1 ] --&gt; uniqueId[ 1 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-3 ] --&gt; uniqueId[ 1 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-1 ] --&gt; uniqueId[ 2 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-2 ] --&gt; uniqueId[ 2 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-1 ] --&gt; uniqueId[ 3 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-3 ] --&gt; uniqueId[ 2 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-1 ] --&gt; uniqueId[ 4 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-2 ] --&gt; uniqueId[ 3 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-3 ] --&gt; uniqueId[ 3 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-2 ] --&gt; uniqueId[ 4 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-3 ] --&gt; uniqueId[ 4 ]</span></span><br><span class="line"><span class="comment">// 每个线程之间的uniqueId是互不干扰的</span></span><br></pre></td></tr></table></figure><br><br>### ThreadLocal源码分析<br><br>每个线程内部有一个ThreadLocalMap，<code>get()</code>的时候就是获得当前线程的<code>ThreadLocalMap</code>，并且将当前<code>ThreadLocal</code>对象传入<code>map.getEntry(this);</code><br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/08-并发/2019-07-13_160318.jpg"></div><br>#### get()<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 拿到每个线程内部的ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// this指的是这个ThreadLocal对象，每个ThreadLocalMap可以有多个ThreadLocal对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认初始化为null</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocalMap.java</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### set()<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### remove()<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从当前线程的ThreadLocalMap中删除当前的ThreadLocal</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### ThreadLocalMap<br><br>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/08-并发/2019-07-13_160809.jpg"></div><br>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象，这点被Entry的构造方法已经限定死了。<br><br>Entry继承自WeakReference（弱引用，生命周期只能存活到下次GC前），但只有Key是弱引用类型的，Value并非弱引用。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entry.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### Hash冲突怎么解决<br><br>和HashMap的最大的不同在于，ThreadLocalMap结构非常简单，没有next引用，也就是说ThreadLocalMap中解决Hash冲突的方式并非链表的方式，而是采用线性探测的方式，所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。<br><br>ThreadLocalMap解决Hash冲突的方式就是简单的步长加1或减1，寻找下一个相邻的位置。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increment i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decrement i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>显然ThreadLocalMap采用线性探测的方式解决Hash冲突的效率很低，如果有大量不同的ThreadLocal对象放入map中时发送冲突，或者发生二次冲突，则效率很低。<strong>所以这里引出的良好建议是：每个线程只存一个变量，需要多个变量 这个时候需要把这些对象封装成变量对象</strong>。<br><br><br><br>### 内存泄漏<br><br>ThreadLocal在ThreadLocalMap中是以一个弱引用身份被Entry中的Key引用的，因此如果ThreadLocal没有外部强引用来引用它，那么ThreadLocal会在下次JVM垃圾收集时被回收。这个时候就会出现Entry中Key已经被回收，出现一个null Key的情况，外部读取ThreadLocalMap中的元素是无法通过null Key来找到Value的。因此如果当前线程的生命周期很长，一直存在，那么其内部的ThreadLocalMap对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：Thread –&gt; ThreadLocalMap–&gt;Entry–&gt;Value，这条强引用链会导致Entry不会回收，Value也不会回收，但Entry中的Key却已经被回收的情况，造成内存泄漏。<br><br>但是JVM团队已经考虑到这样的情况，并做了一些措施来保证ThreadLocal尽量不会内存泄漏：在ThreadLocal的get()、set()、remove()方法调用的时候会清除掉线程ThreadLocalMap中所有Entry中Key为null的Value，并将整个Entry设置为null，利于下次内存回收。<br><br>ThreadLocal的get()方法在调用map.getEntry(this)时，内部会判断key是否为null<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);<span class="comment">// 清除空结点的方法</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot（意思是，删除value，设置为null便于下次回收）</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    <span class="comment">// 将当前Entry删除后，会继续循环往下检查是否有key为null的节点，如果有则一并删除，防止内存泄漏。</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>但这样也并不能保证ThreadLocal不会发生内存泄漏，例如：<br><br>- 使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏。<br>- 分配使用了ThreadLocal又不再调用get()、set()、remove()方法，那么就会导致内存泄漏<br><br>#### 为什么使用弱引用？<br><br>从表面上看，发生内存泄漏，是因为Key使用了弱引用类型。但其实是因为整个Entry的key为null后，没有主动清除value导致。为什么使用弱引用而不是强引用？<br><br>官方文档的说法：<br><br>&gt; To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>&gt; 为了处理非常大和生命周期非常长的线程，哈希表使用弱引用作为 key。<br><br>下面我们分两种情况讨论：<br><br>- key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。<br>- key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set，get，remove的时候会被清除。<br><br>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set，get，remove的时候会被清除。<br><br>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key的value就会导致内存泄漏，而不是因为弱引用。<br><br>所以：<strong>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</strong>尤其是在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。<br><br><br><br>## Callable和Future和FutureTask<br><br>### Callable<br><br>Callable位于java.util.concurrent包下，它也是一个接口，在它里面也只声明了一个方法，只不过这个方法叫做call()：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span>` `<span class="class"><span class="keyword">interface</span>` `<span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;``    ``<span class="comment">/**``     ``* Computes a result, or throws an exception if unable to do so.``     ``*``     ``* <span class="doctag">@return</span> computed result``     ``* <span class="doctag">@throws</span> Exception if unable to compute a result``     ``*/</span>``    ``<span class="function">V <span class="title">call</span><span class="params">()</span> ``<span class="keyword">throws</span>` `Exception</span>;``&#125;`</span><br></pre></td></tr></table></figure><br><br>可以看到，这是一个泛型接口，call()函数返回的类型就是传递进来的V类型。<br><br>那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;``&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;``Future&lt;?&gt; submit(Runnable task);`</span><br></pre></td></tr></table></figure><br><br>第一个submit方法里面的参数类型就是Callable。<br><br>暂时只需要知道Callable一般是和ExecutorService配合来使用的，具体的使用方法讲在后面讲述。<br><br><br><br>### Future<br><br>Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。<br><br>Future类位于java.util.concurrent包下，它是一个接口：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span>` `<span class="class"><span class="keyword">interface</span>` `<span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;``    ``<span class="keyword">boolean</span>` `cancel(``<span class="keyword">boolean</span>` `mayInterruptIfRunning);``    ``<span class="keyword">boolean</span>` `isCancelled();``    ``<span class="keyword">boolean</span>` `isDone();``    ``<span class="function">V <span class="title">get</span><span class="params">()</span> ``<span class="keyword">throws</span>` `InterruptedException, ExecutionException</span>;``    ``<span class="function">V <span class="title">get</span><span class="params">(``<span class="keyword">long</span>` `timeout, TimeUnit unit)</span>``        ``<span class="keyword">throws</span>` `InterruptedException, ExecutionException, TimeoutException</span>;``&#125;`</span><br></pre></td></tr></table></figure><br><br>在Future接口中声明了5个方法，下面依次解释每个方法的作用：<br><br>- cancel方法用来取消任务，如果取消任务成功则返回true，如果取消任务失败则返回false。参数mayInterruptIfRunning表示是否允许取消正在执行却没有执行完毕的任务，如果设置true，则表示可以取消正在执行过程中的任务。如果任务已经完成，则无论mayInterruptIfRunning为true还是false，此方法肯定返回false，即如果取消已经完成的任务会返回false；如果任务正在执行，若mayInterruptIfRunning设置为true，则返回true，若mayInterruptIfRunning设置为false，则返回false；如果任务还没有执行，则无论mayInterruptIfRunning为true还是false，肯定返回true。<br>- isCancelled方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。<br>- isDone方法表示任务是否已经完成，若任务完成，则返回true；<br>- get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；<br>- get(long timeout, TimeUnit unit)用来获取执行结果，如果在指定时间内，还没获取到结果，就直接抛出TimeoutException。<br><br>也就是说Future提供了三种功能：<br><br>- 判断任务是否完成；<br>- 能够中断任务；<br>- 能够获取任务执行结果。<br><br>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。<br><br><br><br>### FutureTask<br><br>我们先来看一下FutureTask的实现：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span>` `<span class="class"><span class="keyword">class</span>` `<span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; ``<span class="keyword">implements</span>` `<span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;`</span></span><br></pre></td></tr></table></figure><br><br>FutureTask类实现了RunnableFuture接口，我们看一下RunnableFuture接口的实现：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span>` `<span class="class"><span class="keyword">interface</span>` `<span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; ``<span class="keyword">extends</span>` `<span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;``    ``<span class="keyword">void</span>` `run();``&#125;`</span><br></pre></td></tr></table></figure><br><br>可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。<br><br>FutureTask提供了2个构造器：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`<span class="keyword">public</span>` `FutureTask(Callable&lt;V&gt; callable) &#123;``&#125;``<span class="keyword">public</span>` `FutureTask(Runnable runnable, V result) &#123;``&#125;`</span><br></pre></td></tr></table></figure><br><br>### 使用示例<br><br>#### 使用Callable+Future获取执行结果<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"task运行结果"</span>+result.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### 使用Callable+FutureTask获取执行结果<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式</span></span><br><span class="line">        ExecutorService executor = Executors.newCachedThreadPool();</span><br><span class="line">        Task task = <span class="keyword">new</span> Task();</span><br><span class="line">        FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</span><br><span class="line">        executor.submit(futureTask);</span><br><span class="line">        executor.shutdown();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//第二种方式，注意这种方式和第一种方式效果是类似的，只不过一个使用的是ExecutorService，一个使用的是Thread</span></span><br><span class="line">        <span class="comment">/*Task task = new Task();</span></span><br><span class="line"><span class="comment">        FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task);</span></span><br><span class="line"><span class="comment">        Thread thread = new Thread(futureTask);</span></span><br><span class="line"><span class="comment">        thread.start();*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"主线程在执行任务"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"task运行结果"</span>+futureTask.get());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"所有任务执行完毕"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子线程在进行计算"</span>);</span><br><span class="line">        Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">            sum += i;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>## 线程池<br><br>### 线程池的分类<br><br>并发库中，线程池创建线程大致可以分为下面三种：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建固定大小的线程池</span></span><br><span class="line">ExecutorService fPool = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line"><span class="comment">//创建缓存大小的线程池</span></span><br><span class="line">ExecutorService cPool = Executors.newCachedThreadPool();</span><br><span class="line"><span class="comment">//创建单一的线程池</span></span><br><span class="line">ExecutorService sPool = Executors.newSingleThreadExecutor();</span><br></pre></td></tr></table></figure><br><br>#### 固定大小连接池<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个可重用固定线程数的线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建实现了 Runnable 接口对象，Thread 对象当然也实现了 Runnable 接口</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将线程放入池中进行执行</span></span><br><span class="line">        pool.execute(t1);</span><br><span class="line">        pool.execute(t2);</span><br><span class="line">        pool.execute(t3);</span><br><span class="line">        pool.execute(t4);</span><br><span class="line">        pool.execute(t5);</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 正在执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">    pool-1-thread-2 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-1 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-1 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-2 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-1 正在执行...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><br>#### 单任务连接池<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个可重用固定线程数的线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newSingleThreadExecutor();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建实现了 Runnable 接口对象，Thread 对象当然也实现了 Runnable 接口</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将线程放入池中进行执行</span></span><br><span class="line">        pool.execute(t1);</span><br><span class="line">        pool.execute(t2);</span><br><span class="line">        pool.execute(t3);</span><br><span class="line">        pool.execute(t4);</span><br><span class="line">        pool.execute(t5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 可以重启一个执行结束的线程</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        pool.execute(t1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 正在执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">    pool-1-thread-1 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-1 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-1 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-1 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-1 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-1 正在执行...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><br>#### 可变连接池<br><br>可变任务线程池在执行 execute 方法来执行 Thread 类中的 run 方法。这里 execute 执行多次，线程池就会创建出多个线程来处理 Thread 类中 run 方法。所有我们看到连接池会根据执行的情况，在程序运行时创建多个线程来处理。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个可重用固定线程数的线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newCachedThreadPool();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建实现了 Runnable 接口对象，Thread 对象当然也实现了 Runnable 接口</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//将线程放入池中进行执行</span></span><br><span class="line">        pool.execute(t1);</span><br><span class="line">        pool.execute(t2);</span><br><span class="line">        pool.execute(t3);</span><br><span class="line">        pool.execute(t4);</span><br><span class="line">        pool.execute(t5);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 正在执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">    pool-1-thread-2 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-3 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-5 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-4 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-1 正在执行...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><br>#### 延迟连接池<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</span></span><br><span class="line">        <span class="comment">//ScheduledExecutorService 是 ExecutorService 的子接口</span></span><br><span class="line">        ScheduledExecutorService pool = Executors.newScheduledThreadPool(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建实现了 Runnable 接口对象，Thread 对象当然也实现了 Runnable 接口</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t3 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t4 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        Thread t5 = <span class="keyword">new</span> MyThread();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将线程放入池中进行执行</span></span><br><span class="line">        pool.execute(t1);</span><br><span class="line">        pool.execute(t2);</span><br><span class="line">        pool.execute(t3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用定时执行风格的方法</span></span><br><span class="line">        pool.schedule(t4, <span class="number">10</span>, TimeUnit.SECONDS); <span class="comment">//t4 和 t5 在 10 秒后执行</span></span><br><span class="line">        pool.schedule(t5, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 正在执行..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">运行结果：</span></span><br><span class="line"><span class="comment">    pool-1-thread-2 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-1 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-2 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-2 正在执行...</span></span><br><span class="line"><span class="comment">    pool-1-thread-1 正在执行...</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><br>### ExecutorService<br><br>java.util.concurrent.ExecutorService 接口表示一个异步执行机制，使我们能够在后台执行任务。ExecutorService 执行的线程不影响其本身的执行：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个可重用固定线程数的线程池</span></span><br><span class="line">        ExecutorService pool = Executors.newSingleThreadExecutor();</span><br><span class="line">        <span class="comment">//创建实现了 Runnable 接口对象，Thread 对象当然也实现了 Runnable 接口</span></span><br><span class="line">        Thread t1 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">// 正常启动线程</span></span><br><span class="line">        t1.start();</span><br><span class="line">        <span class="comment">//将线程放入池中进行执行</span></span><br><span class="line">        pool.execute(t1);</span><br><span class="line">        <span class="comment">//关闭线程池</span></span><br><span class="line">        pool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" 正在执行..."</span> + (++i));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Thread-0 正在执行...11</span></span><br><span class="line"><span class="comment">pool-1-thread-1 正在执行...12</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><br>#### 基本使用<br><br>##### ExecutorService 实现<br><br>既然 ExecutorService 是个接口，如果你想用它的话就得去使用它的实现类之一。java.util.concurrent 包提供了 ExecutorService 接口的以下实现类：<br><br>- ThreadPoolExecutor<br>- ScheduledThreadPoolExecutor<br><br>##### ExecutorService 创建<br><br>ExecutorService 的创建依赖于你使用的具体实现。但是你也可以使用 Executors 工厂类来创建ExecutorService 实例。代码示例：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService1 = Executors.newSingleThreadExecutor(); </span><br><span class="line">ExecutorService executorService2 = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">ExecutorService executorService3 = Executors.newScheduledThreadPool(<span class="number">10</span>);</span><br></pre></td></tr></table></figure><br><br>##### ExecutorService 使用<br><br>有几种不同的方式来将任务委托给 ExecutorService 去执行：<br><br>- execute(Runnable)<br><br>- submit(Runnable)<br><br>submit(Runnable) 方法也要求一个 Runnable 实现类，但它返回一个 Future 对象。这个 Future 对象可<br>以用来检查 Runnable 是否已经执行完毕。他无法得到返回值，因为Runnable接口没有返回值。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        Future future = executorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Asynchronous task"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        future.get(); <span class="comment">//获得执行完 run 方法后的返回值，这里使用的 Runnable，所以这里没有返回值，返回的是 null。</span></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>- submit(Callable)<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">        Future future = executorService.submit(<span class="keyword">new</span> Callable()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Asynchronous Callable"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"Callable Result"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"future.get() = "</span> + future.get());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>- invokeAny(…)<br><br>invokeAny() 方法要求一系列的 Callable 或者其子接口的实例对象。调用这个方法并不会返回一个 Future，但它返回其中一个 Callable 对象的结果。无法保证返回的是哪个 Callable 的结果 – 只能表明其中一个已执行结束。如果其中一个任务执行结束(或者抛了一个异常)，其他 Callable 将被取消。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> times = <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">while</span>(times -- &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            ExecutorService executorService = Executors.newSingleThreadExecutor();</span><br><span class="line">            Set&lt;Callable&lt;String&gt;&gt; callables = <span class="keyword">new</span> HashSet&lt;Callable&lt;String&gt;&gt;();</span><br><span class="line">            callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Task 1"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Task 2"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            callables.add(<span class="keyword">new</span> Callable&lt;String&gt;() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Task 3"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            String result = executorService.invokeAny(callables);</span><br><span class="line">            System.out.println(<span class="string">"result = "</span> + result);</span><br><span class="line">            executorService.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>- invokeAll(…)<br><br>invokeAll() 方法将调用你在集合中传给 ExecutorService 的所有 Callable 对象。invokeAll() 返回一系列的 Future 对象，通过它们你可以获取每个 Callable 的执行结果。记住，一个任务可能会由于一个异常而结束，因此它可能没有 “成功”。无法通过一个 Future 对象来告知我们是两种结束中的哪一种。<br><br>##### Executors 关闭<br><br>使用 shutdown 和 shutdownNow 可以关闭线程池。两者的区别：<br><br>- shutdown 只是将空闲的线程 interrupt() 了，shutdown() 之前提交的任务可以继续执行直到结束。<br><br>- shutdownNow 是 interrupt 所有线程， 因此大部分线程将立刻被中断。之所以是大部分，而不是全部 ，<br>是因为 interrupt()方法能力有限。<br><br>#### ThreadPoolExecutor 线程池执行者<br><br>java.util.concurrent.ThreadPoolExecutor 是 ExecutorService 接口的一个实现。ThreadPoolExecutor 使用其内部池中的线程执行给定任务(Callable 或者 Runnable)。ThreadPoolExecutor 包含的线程池能够包含不同数量的线程。池中线程的数量由以下变量决定：<br><br>- corePoolSize<br>- maximumPoolSize<br><br>当一个任务委托给线程池时，如果池中线程数量低于 corePoolSize，一个新的线程将被创建，即使池中可能尚有空闲线程。如果内部任务队列已满，而且有 corePoolSize 个线程正在运行，但是运行线程的数量低于maximumPoolSize，一个新的线程将被创建去执行该任务。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span>;</span><br></pre></td></tr></table></figure><br><br>- corePoolSize：线程池核心线程数（平时保留的线程数）<br>- maximumPoolSize：线程池最大线程数（当workQueue都放不下时，启动新线程，最大线程数）<br>- keepAliveTime：超出corePoolSize数量的线程的保留时间。<br>- unit：keepAliveTime单位<br>- workQueue：阻塞队列，存放来不及执行的线程<br>- ArrayBlockingQueue：构造函数一定要传大小<br>- LinkedBlockingQueue：构造函数不传大小会默认为（Integer.MAX_VALUE ），<strong>当大量请求任务时，容易造成 内存耗尽。</strong><br>- SynchronousQueue：同步队列，一个没有存储空间的阻塞队列 ，将任务同步交付给工作线程。<br>- PriorityBlockingQueue : 优先队列<br>- threadFactory：线程工厂<br>- handler：饱和策略<br>- AbortPolicy（默认）：直接抛弃<br>- CallerRunsPolicy：用调用者的线程执行任务<br>- DiscardOldestPolicy：抛弃队列中最久的任务<br>- DiscardPolicy：抛弃当前任务<br><br>##### 阿里巴巴开发手册<br><br>线程池不使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样 的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br><br>说明： Executors 返回的线程池对象的弊端如下：<br><br>1. FixedThreadPool 和 SingleThreadPool : 允许的请求队列长度为 Integer.MAX_VALUE ，可能会堆积大量的请求，从而导致 OOM 。<br>2. CachedThreadPool 和 ScheduledThreadPool : 允许的创建线程数量为 Integer.MAX_VALUE ，可能会创建大量的线程，从而导致 OOM 。<br><br><br><br>### ScheduledExecutorService<br><br>java.util.concurrent.ScheduledExecutorService 是一个 ExecutorService， 它能够将任务延后执行，或者间隔固定时间多次执行。 任务由一个工作者线程异步执行，而不是由提交任务给 ScheduledExecutorService 的那个线程执行。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService =</span><br><span class="line">                Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        ScheduledFuture scheduledFuture =</span><br><span class="line">                scheduledExecutorService.schedule(</span><br><span class="line">                        <span class="keyword">new</span> Callable() &#123;</span><br><span class="line">                              <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                  System.out.println(<span class="string">"Executed!"</span>);</span><br><span class="line">                                  <span class="keyword">return</span> <span class="string">"Called!"</span>;</span><br><span class="line">                              &#125;</span><br><span class="line">                         &#125;,</span><br><span class="line">                        <span class="number">5</span>,</span><br><span class="line">                        TimeUnit.SECONDS);<span class="comment">//5 秒后执行</span></span><br><span class="line">        scheduledExecutorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### ScheduledExecutorService 的实现<br><br>ScheduledExecutorService 是一个接口，你要用它的话就得使用 java.util.concurrent 包里对它的某个实现类。<br>ScheduledExecutorService 具有以下实现类：ScheduledThreadPoolExecutor<br><br>#### 创建一个 ScheduledExecutorService<br><br>如何创建一个 ScheduledExecutorService 取决于你采用的它的实现类。但是你也可以使用 Executors 工厂类<br>来创建一个 ScheduledExecutorService 实例。比如：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br></pre></td></tr></table></figure><br><br>#### ScheduledExecutorService 的使用<br><br>一旦你创建了一个 ScheduledExecutorService，你可以通过调用它的以下方法：<br><br>- schedule (Callable task, long delay, TimeUnit timeunit)<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestExecutor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">        ScheduledFuture scheduledFuture = scheduledExecutorService.schedule(</span><br><span class="line">            <span class="keyword">new</span> Callable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"Executed!"</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">"Called!"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="number">5</span>,</span><br><span class="line">            TimeUnit.SECONDS);</span><br><span class="line">        System.out.println(<span class="string">"result = "</span> + scheduledFuture.get());</span><br><span class="line">        scheduledExecutorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>- schedule (Runnable task, long delay, TimeUnit timeunit)<br>- scheduleAtFixedRate (Runnable, long initialDelay, long period, TimeUnit timeunit)<br><br>这一方法规划一个任务将被定期执行。该任务将会在首个 initialDelay 之后得到执行，然后每个 period 时间之<br>后重复执行。如果给定任务的执行抛出了异常，该任务将不再执行。如果没有任何异常的话，这个任务将会持续循环执行到ScheduledExecutorService 被关闭。如果一个任务占用了比计划的时间间隔更长的时候，下一次执行将在当前执行结束执行才开始。计划任务在同一时间不会有多个线程同时执行。<br><br>- scheduleWithFixedDelay (Runnable, long initialDelay, long period, TimeUnit timeunit)<br><br>除了 period 有不同的解释之外这个方法和 scheduleAtFixedRate() 非常像。scheduleAtFixedRate() 方法中，period 被解释为前一个执行的开始和下一个执行的开始之间的间隔时间。而在本方法中，period 则被解释为前一个执行的结束和下一个执行的结束之间的间隔。因此这个延迟是执行结束之间的间隔，而不是执行开始之间的间隔。<br><br><br><br>## Lock.lockInterruptibly<br><br>API文档的说法：<br><br>- lock.lock()：尝试获取锁。当该函数返回时，处于已经获取锁的状态。如果当前有别的线程获取了锁，则睡眠。<br>- lockInterruptibly()：尝试获取锁。如果当前有别的线程获取了锁，则睡眠。当该函数返回时，有两种可能：<br>- 已经获取了锁。<br>- 获取锁不成功，但是别的线程打断了它。则该线程会抛出 InterruptedException 异常而返回，<strong>同时该线程的中断标志会被清除</strong>。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Run</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" trying to get lock"</span>);</span><br><span class="line">            lock.lock();</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" finished"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            System.out.println(<span class="string">"now lock is avalibale"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread i0 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Run());</span><br><span class="line">        Thread i1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Run());</span><br><span class="line"></span><br><span class="line">        i0.start();</span><br><span class="line">        Thread.sleep(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        i1.start();</span><br><span class="line">        i1.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Thread-0 trying to get lock</span></span><br><span class="line"><span class="comment">    Thread-1 trying to get lock</span></span><br><span class="line"><span class="comment">    Thread-0 finished</span></span><br><span class="line"><span class="comment">    now lock is avalibale</span></span><br><span class="line"><span class="comment">    Thread-1 interrupted</span></span><br><span class="line"><span class="comment">    now lock is avalibale</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><br>在线程0获取了锁后，线程1去lock.lock().然后主线程里面去中断线程1，线程1并没有立马中断，而是要等到Thread0运行完后，释放了锁，Thread1在成功获取锁之后，才会被中断，抛出异常。<br><br>如果我们使用的是lock.lockInterruptibly()，信息如下：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Thread-0 trying to get lock</span><br><span class="line">Thread-1 trying to get lock</span><br><span class="line">Thread-1 interrupted</span><br><span class="line">Exception in thread &quot;Thread-1&quot; java.lang.IllegalMonitorStateException</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)</span><br><span class="line">at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)</span><br><span class="line">at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)</span><br><span class="line">at Run.run(Test.java:19)</span><br><span class="line">at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">Thread-0 finished</span><br><span class="line">now lock is avalibale</span><br></pre></td></tr></table></figure><br><br>在线程0获取了锁后，线程1去lock.lock().然后主线程里面去中断线程1。因为在中断时，线程1是没有拿到锁的（线程0获取了锁，在处于sleep状态），所以lock.lockInterruptibly()里面抛出了中断，此时并没有拿到锁！！而finally块就算是发生了中断也会执行lock.unlock()，这里就抛出异常了，因为你没有获取到锁啊，unlock啥！！<br><br>同时如下的代码不能解决此问题：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">       <span class="comment">//如果不是以中断方式返回，则应该是获取了锁，则释放锁！！</span></span><br><span class="line">           <span class="keyword">if</span>(!Thread.currentThread().isInterrupted())</span><br><span class="line">           &#123;</span><br><span class="line">               lock.unlock();</span><br><span class="line">               System.out.println(<span class="string">"now lock is avalibale"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><br><br>因为lock.lockInterruptibly()在抛出了异常后，是会清除中断标志位的，所以，finally 中的 if 永远会执行，又回到了之前的状态。比较好的方法是这样的：既然Thread自己的标志位会被清除，那自己设一个呗！<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;  </span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" running"</span>);  </span><br><span class="line">        Thread.sleep(<span class="number">1900</span>);  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" finished"</span>);  </span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e)&#123;  </span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">" interrupted"</span>);  </span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">        lock.unlock();  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>## 阻塞队列<br><br>阻塞队列 （BlockingQueue）是 Java util.concurrent 包下重要的数据结构，BlockingQueue 提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于 BlockingQueue 实现的。<br><br><div align="center"><img width="100%" src="//isjinhao.github.io/2019/08-并发/2019-08-19_200623.jpg"></div><br>### ArrayBlockingQueue<br><br>一个有界的阻塞队列，其内部实现是将对象放到一个数组里。有界也就意味着，它不能够存储无限多数量的元素。它有一个同一时间能够存储元素数量的上限。你可以在对其初始化的时候设定这个上限，但之后就无法对这个上限进行修改了。<br><br>#### 构造函数<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">    lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">    notEmpty = lock.newCondition();</span><br><span class="line">    notFull = lock.newCondition();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">公平锁：就是在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程线程是等 待队列的第一个，就占有锁，否则就会加入到等待队列中，以后会按照 FIFO 的规则从队列中取到自己。</span></span><br><span class="line"><span class="comment">非公平锁：比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><br>#### offer<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    <span class="keyword">if</span> (++putIndex == items.length)</span><br><span class="line">        putIndex = <span class="number">0</span>;</span><br><span class="line">    count++;</span><br><span class="line">    notEmpty.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### put<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)</span><br><span class="line">            notFull.await();</span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>这里需要思考一个问题为啥调用 lockInterruptibly 方法而不是 Lock 方法。我的理解是因为调用了条件变量的 await()方法，而 await()方法会在中断标志设置后抛出 InterruptedException 异常后退出，所以还不如在加锁时候先看中断标志是不是被设置了，如果设置了直接抛出 InterruptedException 异常，就不用再去获取锁了。然后看了其他并发类里面凡是调用了 await 的方法获取锁时候都是使用的 lockInterruptibly 方法而不是 Lock 也验证了这个想法。<br><br>#### poll<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length)</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>)</span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### take<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)</span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> dequeue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### peek<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> itemAt(takeIndex); <span class="comment">// null when queue is empty</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### size<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### 面试题<br><br>在多线程操作下，一个数组中最多只能存入 3 个元素。多放入不可以存入数组，或等待某线程对数组中某个元素取走才能放入，要求使用 java 的多线程来实现。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> BlockingQueue queue = <span class="keyword">new</span> ArrayBlockingQueue(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 生产者</span></span><br><span class="line">            <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">1000</span>));</span><br><span class="line">                            queue.put(<span class="number">1</span>);</span><br><span class="line">                            System.out.println(Thread.currentThread().getName() + <span class="string">" 放了数据，"</span> +</span><br><span class="line">                                    <span class="string">"队列目前有"</span> + queue.size() + <span class="string">"个数据"</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 消费者</span></span><br><span class="line">        <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                        System.err.println(queue.take());</span><br><span class="line">                        System.out.println(Thread.currentThread().getName() + <span class="string">" 取走数据，"</span> +</span><br><span class="line">                                <span class="string">"队列目前有"</span> + queue.size() + <span class="string">"个数据"</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### LinkedBlockingQueue<br><br>内部以一个链式结构(链接节点)对其元素进行存储。如果需要的话，这一链式结构可以选择一个上限。如果没有定义上限，将使用 Integer.MAX_VALUE 作为上限。<br><br>LinkedBlockingQueue 中也有两个 Node 分别用来存放首尾节点，并且里面有个初始值为 0 的原子变量 count用来记录队列元素个数，另外里面有两个 ReentrantLock 的独占锁，分别用来控制元素入队和出队加锁，其中 takeLock用来控制同时只有一个线程可以从队列获取元素，其他线程必须等待，putLock 控制同时只能有一个线程可以获取锁去添加元素，其他线程必须等待。另外 notEmpty 和 notFull 用来实现入队和出队的同步。 另外由于出入队是两个非公平独占锁，所以可以同时又一个线程入队和一个线程出队，其实这个是个生产者-消费者模型。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();</span><br></pre></td></tr></table></figure><br><br>#### 带时间的 Offer 操作-生产者<br><br>在 ArrayBlockingQueue 中已经简单介绍了 Offer()方法，LinkedBlocking 的 Offer 方法类似，在此就不过多去介绍。这次我们从介绍下带时间的 Offer 方法。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(<span class="keyword">new</span> Node&lt;E&gt;(e));</span><br><span class="line">        c = count.getAndIncrement();</span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)</span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### 带时间的 poll 操作-消费者<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();</span><br><span class="line">        c = count.getAndDecrement();</span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### size 操作<br><br>当前队列元素个数，如代码直接使用原子变量 count 获取。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> count.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### remove<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    fullyLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">             p != <span class="keyword">null</span>;</span><br><span class="line">             trail = p, p = p.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123;</span><br><span class="line">                unlink(p, trail);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### PriorityBlockingQueue<br><br>一 个 无 界 的 并 发 队 列 。 它 使 用 了 和 类java.util.PriorityQueue 一 样 的 排 序 规 则 。 你 无 法 向 这 个 队 列 中 插 入 null 值 。 所 有 插 入 到PriorityBlockingQueue 的元素必须实现 java.lang.Comparable 接口。因此该队列中元素的排序就取决于你自己的 Comparable 实现。每次出队都返回优先级最高的元素，是二叉树最小堆的实现，直接遍历队列元素是无序的。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BlockingQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PriorityBlockingQueue&lt;User&gt; queue = </span><br><span class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;User&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        queue.add(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"wu"</span>));</span><br><span class="line">        queue.add(<span class="keyword">new</span> User(<span class="number">5</span>, <span class="string">"wu5"</span>));</span><br><span class="line">        queue.add(<span class="keyword">new</span> User(<span class="number">23</span>, <span class="string">"wu23"</span>));</span><br><span class="line">        queue.add(<span class="keyword">new</span> User(<span class="number">55</span>, <span class="string">"wu55"</span>));</span><br><span class="line">        queue.add(<span class="keyword">new</span> User(<span class="number">9</span>, <span class="string">"wu9"</span>));</span><br><span class="line">        queue.add(<span class="keyword">new</span> User(<span class="number">3</span>, <span class="string">"wu3"</span>));</span><br><span class="line">        <span class="keyword">for</span> (User user : queue) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(queue.take().name);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//静态内部类</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(User o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.age &gt; o.age ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 其他<br><br>- SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。<br>- DelayQueue：DelayQueue 对元素进行持有直到一个特定的延迟到期。注入其中的元素必须实现<br>java.util.concurrent.Delayed 接口<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Auther</span> sty</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@createTime</span> 2018/9/18 下午2:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DelayQueue delayQueue  = <span class="keyword">new</span> DelayQueue();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                delayQueue.offer(<span class="keyword">new</span> MyDelayedTask(<span class="string">"task1"</span>,<span class="number">10000</span>));</span><br><span class="line">                delayQueue.offer(<span class="keyword">new</span> MyDelayedTask(<span class="string">"task2"</span>,<span class="number">3900</span>));</span><br><span class="line">                delayQueue.offer(<span class="keyword">new</span> MyDelayedTask(<span class="string">"task3"</span>,<span class="number">1900</span>));</span><br><span class="line">                delayQueue.offer(<span class="keyword">new</span> MyDelayedTask(<span class="string">"task4"</span>,<span class="number">5900</span>));</span><br><span class="line">                delayQueue.offer(<span class="keyword">new</span> MyDelayedTask(<span class="string">"task5"</span>,<span class="number">6900</span>));</span><br><span class="line">                delayQueue.offer(<span class="keyword">new</span> MyDelayedTask(<span class="string">"task6"</span>,<span class="number">7900</span>));</span><br><span class="line">                delayQueue.offer(<span class="keyword">new</span> MyDelayedTask(<span class="string">"task7"</span>,<span class="number">4900</span>));</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">// 输出的时候有一定时间的延迟</span></span><br><span class="line">            Delayed take = delayQueue.take();</span><br><span class="line">            System.out.println(take);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  compareTo 方法必须提供与 getDelay 方法一致的排序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyDelayedTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name ;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time ;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyDelayedTask</span><span class="params">(String name,<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.time = time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 需要实现的接口，获得延迟时间   用过期时间-当前时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unit.convert((start+time) - System.currentTimeMillis(),TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于延迟队列内部比较排序   当前时间的延迟时间 - 比较对象的延迟时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed o)</span> </span>&#123;</span><br><span class="line">        MyDelayedTask o1 = (MyDelayedTask) o;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) (<span class="keyword">this</span>.getDelay(TimeUnit.MILLISECONDS) - o.getDelay(TimeUnit.MILLISECONDS));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"MyDelayedTask&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", time="</span> + time +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>- LinkedTransferQueue：由链表结构组成的无界阻塞TransferQueue队列。相对于其他阻塞队列，多了tryTransfer和transfer方法<br>- transfer方法，如果当前有消费者正在等待接收元素（take或者待时间限制的poll方法），transfer可以把生产者传入的元素立刻传给消费者。如果没有消费者等待接收元素，则将元素放在队列的tail节点，并等到该元素被消费者消费了才返回。<br>- tryTransfer方法，用来试探生产者传入的元素能否直接传给消费者。，如果没有消费者在等待，则返回false。和上述方法的区别是该方法无论消费者是否接收，方法立即返回。而transfer方法是必须等到消费者消费了才返回。<br><br>- LinkedBlockingDeque：链表结构的双向阻塞队列，优势在于多线程入队时，减少一半的竞争。<br><br><br><br>## <strong>volatile</strong><br><br>### 提升计算机工作能力<br><br>在许多情况下，让计算机同时去做几件事情，不仅是因为计算机的运算能力强大了，还有一个很重要的原因是计算机的运算速度与它的存储和通信子系统速度的差距太大， 大量的时间都花费在磁盘I/O、网络通信或者数据库访问上。 如果不希望处理器在大部分时间里都处于等待其他资源的状态，就必须使用一些手段去把处理器的运算能力” 压榨” 出来， 否则就会造成很大的浪费，而计算机同时处理几项任务则是最容易想到、也被证明是非常有效的 “压榨” 手段。<br><br>除了充分利用计算机处理器的能力外，一个服务端同时对多个客户端提供服务则是另一个更具体的并发应用场景。衡量一个服务性能的高低好坏，每秒事务处理数（Transactions Per Second，TPS）是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序的并发能力。<br><br>服务端是Java语言最擅长的领域之一，这个领域的应用占了Java应用中最大的一块份额，不过如何写好并发应用程序却又是服务端程序开发的难点之一，处理好并发方面的问题通常需要更多的编码经验来支持。幸好Java语言和虚拟机提供了许多工具，把并发编程的门槛降低了不少。并且各种中间件服务器、各类框架都努力地替程序员处理尽可能多的线程并发细节，使得程序员在编码时能更关注业务逻辑，而不是花费大部分时间去关注此服务会同时被多少人调用、如何协调硬件资源。无论语言、中间件和框架如何先进，开发人员都不能期望它们能独立完成所有并发处理的事情，了解并发的内幕也是成为一个高级程序员不可缺少的课程。<br><br><br><br>### 真机的内存结构<br><br>在正式讲解 Java 虚拟机并发相关的知识之前，我们先花费一点时间去了解一下物理计算机中的并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。<br><br>“让计算机并发执行若干个运算任务” 与 “更充分地利用计算机处理器的效能” 之间的因果关系，看起来顺理成章，实际上它们之间的关系并没有想象中的那么简单，其中一个重要的复杂性来源是绝大多数的运算任务都不可能只靠处理器 “计算” 就能完成，处理器至少要与内存交互，如读取运算数据、存储运算结果等，这个 I/O 操作是很难消除的（无法仅靠寄存器来完成所有运算任务）。由于计算机的存储设备与处理器的运算速度有几个数量级的差距，所以现代计算机系统都不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：将运算需要使用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。<br><br>基于高速缓存的存储交互很好地理解了处理器与内存的速度矛盾，但是也为计算机系统带来了更高的复杂度，因为它引入了一个新的问题：缓存一致性（Cache Coherence）。在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），如图所示。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？为了解决一致性的问题，需要各个处理器访问缓存时都遵循一些协议，在读写时要根据协议来进行操作，这类协议有 MSI、MESI（Illinois Protocol）、MOSI、Synapse、Firefly 及 Dragon Protocol 等。其中最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：<strong>当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取</strong>。在本章中将会多次提到的 “内存模型” 一词，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象。不同架构的物理机器可以拥有不一样的内存模型，而 Java 虚拟机也有自己的内存模型，并且这里介绍的内存访问操作与硬件的缓存访问操作具有很高的可比性。<br><br><div align="center"><img src="//isjinhao.github.io/2019/08-并发/真机内存模型.jpg"></div><br>除了增加高速缓存之外，为了使得处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行（Out-Of-Order Execution）优化，处理器会在计算之后将乱序执行的结果充足，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类型，Java 虚拟机的即时编译器中有有类似的指令重排序（Instruction Reorder）优化。<br><br><br><br>### JVM的内存结构<br><br>Java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。<br><br>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的变量（Variables）与 Java 编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。为了获得较好的执行效能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存和主内存进行交互，也没有限制即时编译器进行调整代码执行顺序这类优化措施。<br><br>Java 内存模型规定了所有的变量都存储在主内存（Main Memory）中（此处的主内存与介绍物理硬件时的主内存名字一样，两者也可以互相类比，但此处仅是虚拟机内存的一部分）。每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成，线程、主内存、工作内存三者的交互关系如图所示。<br><br><div align="center"><img src="//isjinhao.github.io/2019/08-并发/Java内存模型.jpg"></div><br>### volatile<br><br>关键字 volatile 可以说是 Java 虚拟机提供的最轻量级的同步机制。当一个变量定义为 volatile 之后，它将具备两种特性：<br><br>#### 保证此变量对所有线程的可见性<br><br>这里的 “可见性” 是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程 A 修改一个普通变量的值，然后向主内存进行回写，另外一条线程 B 在线程 A 回写完成了之后再从主内存进行读取操作，新变量值才会对线程 B 可见。关于 volatile 变量的可见性，经常会被开发人员误解，认为以下描述成立：“volatile 变量对所有线程是立即可见的，对 volatile 变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile 变量在各个线程中是一致的，所以基于 volatile 变量的运算在并发下是安全的”。这句话的论据部分并没有错，但是其论据并不能得出 “基于 volatile 变量的运算在并发下是安全的” 这个结论。比如以下代码：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>运行它会发现每次运行结果都不一致，都是一个小于10000的数字。这便是由于volatile 不能保证原子性。同时自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：<br><br>- 假如某个时刻变量inc的值为10。<br>- 线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；<br>- 然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。<br>- 然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。<br>- 那么两个线程分别进行了一次自增操作后，inc只增加了1。<br><br><br><br>#### 禁止指令重排序优化<br><br>普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是 Java 内存模型中描述的所谓的 “线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。<br><br>volatile关键字禁止指令重排序有两层意思：<br><br>- 当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；<br>- 在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。<br><br>可能上面说的比较绕，举个简单的例子：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//x、y为非volatile变量</span><br><span class="line">//flag为volatile变量</span><br><span class="line">x = 2;   //语句1</span><br><span class="line">y = 0;   //语句2</span><br><span class="line">flag = true;  //语句3</span><br><span class="line">x = 4;  //语句4</span><br><span class="line">y = -1;     //语句5`</span><br></pre></td></tr></table></figure><br><br>由于 flag 变量为 volatile 变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。<br><br>并且 volatile 关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。<br><br>那么我们看一个例子：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//线程1:</span><br><span class="line">context = loadContext();   //语句1</span><br><span class="line">inited = true;             //语句2</span><br><span class="line"> </span><br><span class="line">//线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep();</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><br><br>前在这个例子中，有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。<br><br>这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。<br><br><br><br>### 并发编程的三个概念<br><br>并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。<br><br>#### 原子性（Atomicity）<br><br>在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子，请分析以下哪些操作是原子性操作：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = 10;         //语句1</span><br><span class="line">y = x;         //语句2</span><br><span class="line">x++;           //语句3</span><br><span class="line">x = x + 1;  //语句4</span><br></pre></td></tr></table></figure><br><br>乍一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。<br><br>语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。所以上面4个语句只有语句1的操作具备原子性。<br><br>也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。<br><br>#### 可见性（Visibility）<br><br>当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。<br><br>而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br><br>另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。<br><br>#### 有序性（Ordering）<br><br>在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。<br><br>在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。<br><br>另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 先行发生原则（happens-before原则）。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。<br><br>##### 先行发生原则<br><br>1. 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作<br>2. 锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作<br>3. volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作<br>4. 传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C<br>5. 线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作<br>6. 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生<br>7. 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行<br>8. 对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始<br><br>这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。下面我们来解释一下前4条规则：<br><br>1. 对于程序次序规则：一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。<br>2. 锁定规则：也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。<br>3. volatile变量规则：如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。<br>4. 传递规则：实际上就是体现happens-before原则具备传递性。<br><br><br><br>### volatile关键字的场景<br><br>所以总结来说，volatile 变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile 变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在不一致性问题），但是 Java 里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的。由于 volatile 变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍然需要通过加锁（使用 synchronized 或 java.util.concurrent 中的原子类）来保证原子性。通常来说，使用volatile必须具备以下2个条件：<br><br>- 对变量的写操作不依赖于当前值<br>- 该变量没有包含在具有其他变量的不变式中<br><br>实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。下面列举几个Java中使用volatile的几个场景。<br><br>#### 状态标记量<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> inited = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();  </span><br><span class="line">inited = <span class="keyword">true</span>;            </span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited)&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure><br><br>#### double check<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="comment">// 如果不加volatile可能拿到半个实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 此层判断的目的是在instance初始化完成之后，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 可能会有多个线程到达此步，对字节码加锁的目的是使保证只能被构造一次</span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="comment">// 进入第10行的线程在正常情况下一定会进入到此步，再判断一次，如果被构造了则不再构造</span></span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>## CAS<br><br>CAS指令需要有3个操作数，分别是内存位置（在Java中可以简单理解为变量的内存地址，用V表示）、 旧的预期值（用A表示）和新值（用B表示）。 CAS指令执行时，当且仅当V符合旧预期值A时，处理器用新值B更新V的值，否则它就不执行更新，但是无论是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作。在JDK 1.5之后，Java程序中才可以使用CAS操作，该操作由sun.misc.Unsafe类里面的compareAndSwapInt()和compareAndSwapLong()等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器CAS指令，没有方法调用的过程。<br><br><br><br>### ABA问题<br><br>尽管CAS看起来很美，但显然这种操作无法涵盖互斥同步的所有使用场景，并且CAS从语义上来说并不是完美的，存在这样的一个逻辑漏洞：如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那我们就能说它的值没有被其他线程改变过了吗？如果在这段期间它的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA”问题。 J.U.C包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。 不过目前来说这个类比较“鸡肋”，大部分情况下ABA问题不会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。<br><br>以<code>AtomicInteger</code>为例：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerDefectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        defectOfABA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">defectOfABA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AtomicInteger atomicInteger = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        Thread coreThread = <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> currentValue = atomicInteger.get();</span><br><span class="line">                    System.out.println(Thread.currentThread().getName() + <span class="string">" ------ currentValue="</span> + currentValue);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 这段目的：模拟处理其他业务花费的时间</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">300</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">boolean</span> casResult = atomicInteger.compareAndSet(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">" ------ currentValue="</span> + currentValue</span><br><span class="line">                            + <span class="string">", finalValue="</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">", compareAndSet Result="</span> + casResult);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        coreThread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 这段目的：为了让 coreThread 线程先跑起来</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Thread amateurThread = <span class="keyword">new</span> Thread(</span><br><span class="line">                () -&gt; &#123;</span><br><span class="line">                    <span class="keyword">int</span> currentValue = atomicInteger.get();</span><br><span class="line">                    <span class="keyword">boolean</span> casResult = atomicInteger.compareAndSet(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">" ------ currentValue="</span> + currentValue</span><br><span class="line">                            + <span class="string">", finalValue="</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">", compareAndSet Result="</span> + casResult);</span><br><span class="line"></span><br><span class="line">                    currentValue = atomicInteger.get();</span><br><span class="line">                    casResult = atomicInteger.compareAndSet(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">                    System.out.println(Thread.currentThread().getName()</span><br><span class="line">                            + <span class="string">" ------ currentValue="</span> + currentValue</span><br><span class="line">                            + <span class="string">", finalValue="</span> + atomicInteger.get()</span><br><span class="line">                            + <span class="string">", compareAndSet Result="</span> + casResult);</span><br><span class="line">                &#125;</span><br><span class="line">        );</span><br><span class="line">        amateurThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>## 原子类<br><br>并发包 <code>java.util.concurrent</code> 的原子类都存放在<code>java.util.concurrent.atomic</code>。根据操作的数据类型，可以将JUC包中的原子类分为4类。<br><br><br><br>### <strong>基本类型</strong><br><br>使用原子的方式更新基本类型<br><br>- AtomicInteger：整型原子类<br>- AtomicLong：长整型原子类<br>- AtomicBoolean ：布尔型原子类<br><br>上面三个类提供的方法几乎相同，所以我们这里以 AtomicInteger 为例子来介绍。<br><br>#### <strong>AtomicInteger 类常用方法</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> <span class="comment">//获取当前的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//获取当前的值，并设置新的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span><span class="comment">//获取当前的值，并自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">()</span> <span class="comment">//获取当前的值，并自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取当前的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> newValue)</span><span class="comment">//最终设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure><br><br>#### AtomicInteger 常见方法使用<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> temvalue = <span class="number">0</span>;</span><br><span class="line">AtomicInteger i = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">temvalue = i.getAndSet(<span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"temvalue:"</span> + temvalue + <span class="string">";  i:"</span> + i);<span class="comment">//temvalue:0;  i:3</span></span><br><span class="line">temvalue = i.getAndIncrement();</span><br><span class="line">System.out.println(<span class="string">"temvalue:"</span> + temvalue + <span class="string">";  i:"</span> + i);<span class="comment">//temvalue:3;  i:4</span></span><br><span class="line">temvalue = i.getAndAdd(<span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"temvalue:"</span> + temvalue + <span class="string">";  i:"</span> + i);<span class="comment">//temvalue:4;  i:9</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### AtomicInteger 线程安全原理简单分析<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        valueOffset = unsafe.objectFieldOffset</span><br><span class="line">            (AtomicInteger.class.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br></pre></td></tr></table></figure><br><br>AtomicInteger 类主要利用 CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。<br><br>CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址。另外 value 是一个volatile变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。<br><br><br><br>### <strong>数组类型</strong><br><br>使用原子的方式更新数组里的某个元素<br><br>- AtomicIntegerArray：整型数组原子类<br>- AtomicLongArray：长整型数组原子类<br>- AtomicReferenceArray ：引用类型数组原子类<br><br>#### AtomicIntegerArray 类常用方法<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndSet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span><span class="comment">//返回 index=i 位置的当前的值，并将其设置为新值：newValue</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">(<span class="keyword">int</span> i)</span><span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自增</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndDecrement</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="comment">//获取 index=i 位置元素的值，并让该位置的元素自减</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> <span class="comment">//获取 index=i 位置元素的值，并加上预期的值</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> <span class="comment">//如果输入的数值等于预期值，则以原子方式将 index=i 位置的元素值设置为输入值（update）</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lazySet</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> newValue)</span><span class="comment">//最终 将index=i 位置的元素设置为newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</span></span></span><br></pre></td></tr></table></figure><br><br>#### AtomicIntegerArray 常见方法使用<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerArrayTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">int</span> temvalue = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">AtomicIntegerArray i = <span class="keyword">new</span> AtomicIntegerArray(nums);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">System.out.println(i.get(j));</span><br><span class="line">&#125;</span><br><span class="line">temvalue = i.getAndSet(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(<span class="string">"temvalue:"</span> + temvalue + <span class="string">";  i:"</span> + i);</span><br><span class="line">temvalue = i.getAndIncrement(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">"temvalue:"</span> + temvalue + <span class="string">";  i:"</span> + i);</span><br><span class="line">temvalue = i.getAndAdd(<span class="number">0</span>, <span class="number">5</span>);</span><br><span class="line">System.out.println(<span class="string">"temvalue:"</span> + temvalue + <span class="string">";  i:"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### <strong>引用类型</strong><br><br>- AtomicReference：引用类型原子类<br>- AtomicStampedReference：原子更新引用类型里的字段原子类<br>- AtomicMarkableReference ：原子更新带有标记位的引用类型<br><br>基本类型原子类只能更新一个变量，如果需要原子更新多个变量，需要使用引用类型原子类。<br><br>#### AtomicReference 类使用示例<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicReferenceTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AtomicReference&lt;Person&gt; ar = <span class="keyword">new</span> AtomicReference&lt;Person&gt;();</span><br><span class="line">Person person = <span class="keyword">new</span> Person(<span class="string">"SnailClimb"</span>, <span class="number">22</span>);</span><br><span class="line">ar.set(person);</span><br><span class="line">Person updatePerson = <span class="keyword">new</span> Person(<span class="string">"Daisy"</span>, <span class="number">20</span>);</span><br><span class="line">ar.compareAndSet(person, updatePerson);</span><br><span class="line">System.out.println(ar.get().getName());</span><br><span class="line">System.out.println(ar.get().getAge());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>上述代码首先创建了一个 Person 对象，然后把 Person 对象设置进 AtomicReference 对象中，然后调用 compareAndSet 方法，该方法就是通过通过 CAS 操作设置 ar。如果 ar 的值为 person 的话，则将其设置为 updatePerson。CAS操作中比较的是地址。<br><br>#### AtomicStampedReference 类使用示例<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicStampedReferenceDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实例化、取当前值和 stamp 值</span></span><br><span class="line">        <span class="keyword">final</span> Integer initialRef = <span class="number">0</span>, initialStamp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> AtomicStampedReference&lt;Integer&gt; asr = <span class="keyword">new</span> AtomicStampedReference&lt;&gt;(initialRef, initialStamp);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + asr.getReference() + <span class="string">", currentStamp="</span> + asr.getStamp());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// compare and set</span></span><br><span class="line">        <span class="keyword">final</span> Integer newReference = <span class="number">666</span>, newStamp = <span class="number">999</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> casResult = asr.compareAndSet(initialRef, newReference, initialStamp, newStamp);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + asr.getReference()</span><br><span class="line">                + <span class="string">", currentStamp="</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">", casResult="</span> + casResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前的值和当前的 stamp 值</span></span><br><span class="line">        <span class="keyword">int</span>[] arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">final</span> Integer currentValue = asr.get(arr);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> currentStamp = arr[<span class="number">0</span>];</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + currentValue + <span class="string">", currentStamp="</span> + currentStamp);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 单独设置 stamp 值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> attemptStampResult = asr.attemptStamp(newReference, <span class="number">88</span>);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + asr.getReference()</span><br><span class="line">                + <span class="string">", currentStamp="</span> + asr.getStamp()</span><br><span class="line">                + <span class="string">", attemptStampResult="</span> + attemptStampResult);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 重新设置当前值和 stamp 值</span></span><br><span class="line">        asr.set(initialRef, initialStamp);</span><br><span class="line">        System.out.println(<span class="string">"currentValue="</span> + asr.getReference() + <span class="string">", currentStamp="</span> + asr.getStamp());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">currentValue=0, currentStamp=0</span></span><br><span class="line"><span class="comment">    currentValue=666, currentStamp=999, casResult=true</span></span><br><span class="line"><span class="comment">    currentValue=666, currentStamp=999</span></span><br><span class="line"><span class="comment">    currentValue=666, currentStamp=88, attemptStampResult=true</span></span><br><span class="line"><span class="comment">    currentValue=0, currentStamp=0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><br>### <strong>对象的属性修改类型</strong><br><br>- AtomicIntegerFieldUpdater:原子更新整型字段的更新器<br>- AtomicLongFieldUpdater：原子更新长整型字段的更新器<br>- AtomicStampedReference ：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。<br>- AtomicMarkableReference：原子更新带有标记的引用类型。该类将 boolean 标记与引用关联起来，也可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。<br><br>要想原子地更新对象的属性需要两步。第一步，因为对象的属性修改类型原子类都是抽象类，所以每次使用都必须使用静态方法 newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新的对象属性必须使用 public volatile 修饰符。<br><br>上面三个类提供的方法几乎相同，所以我们这里以 <code>AtomicIntegerFieldUpdater</code>为例子来介绍。<br><br>#### 5.2 AtomicIntegerFieldUpdater 类使用示例<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicIntegerFieldUpdaterTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">AtomicIntegerFieldUpdater&lt;User&gt; a = AtomicIntegerFieldUpdater.newUpdater(User.class, <span class="string">"age"</span>);</span><br><span class="line"></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="string">"Java"</span>, <span class="number">22</span>);</span><br><span class="line">System.out.println(a.getAndIncrement(user));<span class="comment">// 22</span></span><br><span class="line">System.out.println(a.get(user));<span class="comment">// 23</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>();</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>## AQS<br><br>Java并发包（JUC）中提供了很多并发工具，这其中，很多我们耳熟能详的并发工具，譬如ReentrangLock、Semaphore，它们的实现都用到了一个共同的基类–<strong>AbstractQueuedSynchronizer</strong>，简称AQS。AQS是一个用来构建锁和同步器的框架，使用AQS能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的ReentrantLock，Semaphore，其他的诸如ReentrantReadWriteLock，SynchronousQueue，FutureTask等等皆是基于AQS的。当然，我们自己也能利用AQS非常轻松容易地构造出符合我们自己需求的同步器。<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/08-并发/AQS.png"></div><h3 id="AQS-原理概览"><a href="#AQS-原理概览" class="headerlink" title="AQS 原理概览"></a>AQS 原理概览</h3><p><strong>AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><blockquote><p>CLH(Craig,Landin,and Hagersten)队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS是将每条请求共享资源的线程封装成一个CLH锁队列的一个结点（Node）来实现锁的分配。</p></blockquote><p>看个AQS(AbstractQueuedSynchronizer)原理图：</p><p><img src="//isjinhao.github.io/2019/08-并发/721070-20170504110246211-10684485.png" alt="enter image description here"></p><p>AQS使用一个int成员变量来表示同步状态，通过内置的FIFO队列来完成获取资源线程的排队工作。AQS使用CAS对该同步状态进行原子操作实现对其值的修改。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;<span class="comment">//共享变量，使用volatile修饰保证线程可见性</span></span><br></pre></td></tr></table></figure><p>状态信息通过protected类型的getState，setState，compareAndSetState进行操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回同步状态的当前值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">// 设置同步状态的值</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123; </span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//原子地（CAS操作）将同步状态值设置为给定值update如果当前同步状态的值等于expect（期望值）</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AQS-对资源的共享方式"><a href="#AQS-对资源的共享方式" class="headerlink" title="AQS 对资源的共享方式"></a>AQS 对资源的共享方式</h3><ul><li><strong>Exclusive</strong>（独占）：只有一个线程能执行，如ReentrantLock。又可分为公平锁和非公平锁：<ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><strong>Share</strong>（共享）：多个线程可同时执行，如Semaphore/CountDownLatch。Semaphore、CountDownLatCh、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</li></ul><p>ReentrantReadWriteLock 可以看成是组合式，因为ReentrantReadWriteLock也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在上层已经帮我们实现好了。</p><h3 id="AQS底层使用了模板方法模式"><a href="#AQS底层使用了模板方法模式" class="headerlink" title="AQS底层使用了模板方法模式"></a>AQS底层使用了模板方法模式</h3><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>使用者继承AbstractQueuedSynchronizer并重写指定的方法。（这些重写方法很简单，无非是对于共享资源state的获取和释放）</li><li>将AQS组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用，下面简单的给大家介绍一下模板方法模式，模板方法模式是一个很容易理解的设计模式之一。</p><blockquote><p>模板方法模式是基于”继承“的，主要是为了在不改变模板结构的前提下在子类中重新定义模板中的内容以实现复用代码。举个很简单的例子假如我们要去一个地方的步骤是：购票<code>buyTicket()</code>-&gt;安检<code>securityCheck()</code>-&gt;乘坐某某工具回家<code>ride()</code>-&gt;到达目的地<code>arrive()</code>。我们可能乘坐不同的交通工具回家比如飞机或者火车，所以除了<code>ride()</code>方法，其他方法的实现几乎相同。我们可以定义一个包含了这些方法的抽象类，然后用户根据自己的需要继承该抽象类然后修改 <code>ride()</code>方法。</p></blockquote><p><strong>AQS使用了模板方法模式，自定义同步器时需要重写下面几个AQS提供的模板方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isHeldExclusively()<span class="comment">//该线程是否正在独占资源。只有用到condition才需要去实现它。</span></span><br><span class="line">tryAcquire(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试获取资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryRelease(<span class="keyword">int</span>)<span class="comment">//独占方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br><span class="line">tryAcquireShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数</span></span><br><span class="line">    <span class="comment">//表示成功，且有剩余资源。</span></span><br><span class="line">tryReleaseShared(<span class="keyword">int</span>)<span class="comment">//共享方式。尝试释放资源，成功则返回true，失败则返回false。</span></span><br></pre></td></tr></table></figure><p>默认情况下，每个方法都抛出 <code>UnsupportedOperationException</code>。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS类中的其他方法都是final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p><p>以ReentrantLock为例，state初始化为0，表示未锁定状态。A线程lock()时，会调用tryAcquire()独占该锁并将state+1。此后，其他线程再tryAcquire()时就会失败，直到A线程unlock()到state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A线程自己是可以重复获取此锁的（state会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证state是能回到零态的。</p><p>再以CountDownLatch以例，任务分为N个子线程去执行，state也初始化为N（注意N要与线程个数一致）。这N个子线程是并行执行的，每个子线程执行完后countDown()一次，state会CAS(Compare and Swap)减1。等到所有子线程都执行完后(即state=0)，会unpark()主调用线程，然后主调用线程就会从await()函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现<code>tryAcquire-tryRelease</code>、<code>tryAcquireShared-tryReleaseShared</code>中的一种即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，如<code>ReentrantReadWriteLock</code>。</p><h3 id="acquire-release"><a href="#acquire-release" class="headerlink" title="acquire-release"></a>acquire-release</h3><h4 id="acquire-int"><a href="#acquire-int" class="headerlink" title="acquire(int)"></a>acquire(int)</h4><p>此方法是独占模式下线程获取共享资源的顶层入口。如果获取到资源，线程直接返回，否则进入等待队列，直到获取到资源为止，且整个过程忽略中断的影响。这也正是lock()的语义，当然不仅仅只限于lock()。获取到资源后，线程就可以去执行其临界区代码了。下面是acquire()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数流程如下：</p><ol><li>tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中获取资源，一直获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><h5 id="tryAcquire-int"><a href="#tryAcquire-int" class="headerlink" title="tryAcquire(int)"></a>tryAcquire(int)</h5><p>此方法尝试去获取独占资源。如果获取成功，则直接返回true，否则直接返回false。这也正是tryLock()的语义，还是那句话，当然不仅仅只限于tryLock()。如下是tryAcquire()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>什么？直接throw异常？说好的功能呢？好吧，<strong>还记得概述里讲的AQS只是一个框架，具体资源的获取/释放方式交由自定义同步器去实现吗？</strong>就是这里了！！！AQS这里只定义了一个接口，具体资源的获取交由自定义同步器去实现了（通过state的get/set/CAS）！！！至于能不能重入，能不能加塞，那就看具体的自定义同步器怎么去设计了！！！当然，自定义同步器在进行资源访问时要考虑线程安全的影响。</p><p>这里之所以没有定义成abstract，是因为独占模式下只用实现tryAcquire-tryRelease，而共享模式下只用实现tryAcquireShared-tryReleaseShared。如果都定义成abstract，那么每个模式也要去实现另一模式下的接口。说到底，Doug Lea还是站在咱们开发者的角度，尽量减少不必要的工作量。</p><h5 id="addWaiter-Node"><a href="#addWaiter-Node" class="headerlink" title="addWaiter(Node)"></a>addWaiter(Node)</h5><p>此方法用于将当前线程加入到等待队列的队尾，并返回当前线程所在的结点。还是上源码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//以给定模式构造结点。mode有两种：EXCLUSIVE（独占）和SHARED（共享）</span></span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//尝试快速方式直接放到队尾。</span></span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//上一步失败则通过enq入队。</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node结点是对每一个访问同步代码的线程的封装，其包含了需要同步的线程本身以及线程的状态，如是否被阻塞，是否等待唤醒，是否已经被取消等。变量waitStatus则表示当前被封装成Node结点的等待状态，共有4种取值CANCELLED、SIGNAL、CONDITION、PROPAGATE。</p><ul><li>CANCELLED：值为1，在同步队列中等待的线程等待超时或被中断，需要从同步队列中取消该Node的结点，其结点的waitStatus为CANCELLED，即结束状态，进入该状态后的结点将不会再变化。</li><li>SIGNAL：值为-1，被标识为该等待唤醒状态的后继结点，当其前继结点的线程释放了同步锁或被取消，将会通知该后继结点的线程执行。说白了，就是处于唤醒状态，只要前继结点释放锁，就会通知标识为SIGNAL状态的后继结点的线程执行。</li><li>CONDITION：值为-2，与Condition相关，该标识的结点处于<strong>等待队列</strong>中，结点的线程等待在Condition上，当其他线程调用了Condition的signal()方法后，CONDITION状态的结点将<strong>从等待队列转移到同步队列中</strong>，等待获取同步锁。</li><li>PROPAGATE：值为-3，与共享模式相关，在共享模式中，该状态标识结点的线程处于可运行状态。</li><li>0状态：值为0，代表初始化状态。</li></ul><p>AQS在判断状态时，通过用waitStatus&gt;0表示取消状态，而waitStatus&lt;0表示有效状态。</p><h5 id="enq-Node"><a href="#enq-Node" class="headerlink" title="enq(Node)"></a>enq(Node)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// CAS"自旋"，直到成功加入队尾</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// 队列为空，创建一个空的标志结点作为head结点，并将tail也指向它。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//正常流程，放入队尾</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="acquireQueued-Node-int"><a href="#acquireQueued-Node-int" class="headerlink" title="acquireQueued(Node, int)"></a>acquireQueued(Node, int)</h5><p>OK，通过tryAcquire()和addWaiter()，该线程获取资源失败，已经被放入等待队列尾部了。聪明的你立刻应该能想到该线程下一部该干什么了吧：<strong>进入等待状态休息，直到其他线程彻底释放资源后唤醒自己，自己再拿到资源，然后就可以去干自己想干的事了</strong>。没错，就是这样！是不是跟医院排队拿号有点相似~~acquireQueued()就是干这件事：<strong>在等待队列中排队拿号（中间没其它事干可以休息），直到拿到号后再返回</strong>。这个函数非常关键，还是上源码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//标记是否成功拿到资源</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//标记等待过程中是否被中断过</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//又是一个“自旋”！</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//拿到前驱</span></span><br><span class="line">            <span class="comment">//如果前驱是head，即该结点已成老二，那么便有资格去尝试获取资源（可能是老大释放完资源唤醒自己的，当然也可能被interrupt了）。</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);<span class="comment">//拿到资源后，将head指向该结点。所以head所指的标杆结点，就是当前获取到资源的那个结点或null。</span></span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// setHead中node.prev已置为null，此处再将head.next置为null，就是为了方便GC回收以前的head结点。也就意味着之前拿完资源的结点出队了！</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;<span class="comment">//返回等待过程中是否被中断过</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果自己可以休息了，就进入waiting状态，直到被unpark()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;<span class="comment">//如果等待过程中被中断过，哪怕只有那么一次，就将interrupted标记为true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="shouldParkAfterFailedAcquire-Node-Node"><a href="#shouldParkAfterFailedAcquire-Node-Node" class="headerlink" title="shouldParkAfterFailedAcquire(Node, Node)"></a>shouldParkAfterFailedAcquire(Node, Node)</h5><p>此方法主要用于检查状态，看看自己是否真的可以去休息了，万一队列前边的线程都放弃了只是瞎站着，那也说不定，对吧！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//拿到前驱的状态</span></span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">//如果已经告诉前驱拿完号后通知自己一下，那就可以安心休息了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 如果前驱放弃了，那就一直往前找，直到找到最近一个正常等待的状态，并排在它的后边。</span></span><br><span class="line"><span class="comment">         * 注意：那些放弃的结点，由于被自己“加塞”到它们前边，它们相当于形成一个无引用链，稍后就会被保安大叔赶走了(GC回收)！</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">//如果前驱正常，那就把前驱的状态设置成SIGNAL，告诉它拿完号后通知自己一下。有可能失败，人家说不定刚刚释放完呢！</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="parkAndCheckInterrupt"><a href="#parkAndCheckInterrupt" class="headerlink" title="parkAndCheckInterrupt()"></a>parkAndCheckInterrupt()</h5><p>如果线程找好安全休息点后，那就可以安心去休息了。此方法就是让线程去休息，真正进入等待状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LockSupport.park(<span class="keyword">this</span>);<span class="comment">//调用park()使线程进入waiting状态</span></span><br><span class="line"><span class="keyword">return</span> Thread.interrupted();<span class="comment">//如果被唤醒，查看自己是不是被中断的。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>park()会让当前线程进入waiting状态。在此状态下，有两种途径可以唤醒该线程：</p><ul><li>被unpark()；</li><li>被interrupt()。需要注意的是，Thread.interrupted()会清除当前线程的中断标记位。</li></ul><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>acquireQueued()分析完之后，我们接下来再回到acquire()！再贴上它的源码吧：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来总结下它的流程吧：</p><ol><li>调用自定义同步器的tryAcquire()尝试直接去获取资源，如果成功则直接返回；</li><li>没成功，则addWaiter()将该线程加入等待队列的尾部，并标记为独占模式；</li><li>acquireQueued()使线程在等待队列中休息，有机会时（轮到自己，会被unpark()）会去尝试获取资源。获取到资源后才返回。如果在整个等待过程中被中断过，则返回true，否则返回false。</li><li>如果线程在等待过程中被中断过，它是不响应的。只是获取资源后才再进行自我中断selfInterrupt()，将中断补上。</li></ol><h4 id="release-int"><a href="#release-int" class="headerlink" title="release(int)"></a>release(int)</h4><p>此方法是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。这也正是unlock()的语义，当然不仅仅只限于unlock()。下面是release()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        Node h = head;<span class="comment">//找到头结点</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            unparkSuccessor(h);<span class="comment">//唤醒等待队列里的下一个线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逻辑并不复杂。它调用tryRelease()来释放资源。有一点需要注意的是，<strong>它是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！所以自定义同步器在设计tryRelease()的时候要明确这一点！！</strong></p><h5 id="tryRelease-int"><a href="#tryRelease-int" class="headerlink" title="tryRelease(int)"></a>tryRelease(int)</h5><p>此方法尝试去释放指定量的资源。下面是tryRelease()的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟tryAcquire()一样，这个方法是需要独占模式的自定义同步器去实现的。正常来说，tryRelease()都会成功的，因为这是独占模式，该线程来释放资源，那么它肯定已经拿到独占资源了，直接减掉相应量的资源即可，也不需要考虑线程安全的问题。但要注意它的返回值，上面已经提到了，<strong>release()是根据tryRelease()的返回值来判断该线程是否已经完成释放掉资源了！</strong>所以自义定同步器在实现时，如果已经彻底释放资源(state=0)，要返回true，否则返回false。</p><h5 id="unparkSuccessor-Node"><a href="#unparkSuccessor-Node" class="headerlink" title="unparkSuccessor(Node)"></a>unparkSuccessor(Node)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里，node一般为当前线程所在的结点。</span></span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)<span class="comment">//置零当前线程所在的结点状态，允许失败。</span></span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;<span class="comment">//找到下一个需要唤醒的结点s</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;<span class="comment">//如果为空或已取消</span></span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)<span class="comment">//从这里可以看出，&lt;=0的结点，都是还有效的结点。</span></span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);<span class="comment">//唤醒</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数并不复杂。一句话概括：<strong>用unpark()唤醒等待队列中最前边的那个未放弃线程</strong>，这里我们也用s来表示吧。此时，再和acquireQueued()联系起来，s被唤醒后，进入if (p == head &amp;&amp; tryAcquire(arg))的判断（即使p!=head也没关系，它会再进入shouldParkAfterFailedAcquire()寻找一个安全点。这里既然s已经是等待队列中最前边的那个未放弃线程了，那么通过shouldParkAfterFailedAcquire()的调整，s也必然会跑到head的next结点，下一次自旋p==head就成立啦），然后s把自己设置成head标杆结点，表示自己已经获取到资源了，acquire()也返回了！！And then, DO what you WANT!</p><h5 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h5><p>release()是独占模式下线程释放共享资源的顶层入口。它会释放指定量的资源，如果彻底释放了（即state=0）,它会唤醒等待队列里的其他线程来获取资源。</p><h3 id="acquireShared-releaseShared"><a href="#acquireShared-releaseShared" class="headerlink" title="acquireShared-releaseShared"></a>acquireShared-releaseShared</h3><h4 id="acquireShared-int"><a href="#acquireShared-int" class="headerlink" title="acquireShared(int)"></a>acquireShared(int)</h4><p>此方法是共享模式下线程获取共享资源的顶层入口。它会获取指定量的资源，获取成功则直接返回，获取失败则进入等待队列，直到获取到资源为止，整个过程忽略中断。下面是acquireShared()的源码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">doAcquireShared(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里tryAcquireShared()依然需要自定义同步器去实现。但是AQS已经把其返回值的语义定义好了：负值代表获取失败；0代表获取成功，但没有剩余资源；正数表示获取成功，还有剩余资源，其他线程还可以去获取。所以这里acquireShared()的流程就是：</p><ol><li>tryAcquireShared()尝试获取资源，成功则直接返回；</li><li>失败则通过doAcquireShared()进入等待队列，直到获取到资源为止才返回。</li></ol><h5 id="doAcquireShared-int"><a href="#doAcquireShared-int" class="headerlink" title="doAcquireShared(int)"></a>doAcquireShared(int)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);<span class="comment">//加入队列尾部</span></span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;<span class="comment">//是否成功标志</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;<span class="comment">//等待过程中是否被中断过的标志</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();<span class="comment">//前驱</span></span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;<span class="comment">//如果到head的下一个，因为head是拿到资源的线程，此时node被唤醒，很可能是head用完资源来唤醒自己的</span></span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);<span class="comment">//尝试获取资源</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;<span class="comment">//成功</span></span><br><span class="line">                    setHeadAndPropagate(node, r);<span class="comment">//将head指向自己，还有剩余资源可以再唤醒之后的线程</span></span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)<span class="comment">//如果等待过程中被打断过，此时将中断补上。</span></span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断状态，寻找安全点，进入waiting状态，等着被unpark()或interrupt()</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跟独占模式比，有一点需要注意的是，这里只有线程是head.next时（“老二”），才会去尝试获取资源，有剩余的话还会唤醒之后的队友。那么问题就来了，假如老大用完后释放了5个资源，而老二需要6个，老三需要1个，老四需要2个。老大先唤醒老二，老二一看资源不够，他是把资源让给老三呢，还是不让？答案是否定的！老二会继续park()等待其他线程释放资源，也更不会去唤醒老三和老四了。独占模式，同一时刻只有一个线程去执行，这样做未尝不可；但共享模式下，多个线程是可以同时执行的，现在因为老二的资源需求量大，而把后面量小的老三和老四也都卡住了。当然，这并不是问题，只是AQS保证严格按照入队顺序唤醒罢了（保证公平，但降低了并发）。</p><h5 id="setHeadAndPropagate"><a href="#setHeadAndPropagate" class="headerlink" title="setHeadAndPropagate"></a>setHeadAndPropagate</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    Node h = head; </span><br><span class="line">    setHead(node);<span class="comment">//head指向自己</span></span><br><span class="line">     <span class="comment">//如果还有剩余量，继续唤醒下一个邻居线程</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法在setHead()的基础上多了一步，就是自己苏醒的同时，如果条件符合（比如还有剩余资源），还会去唤醒后继结点，毕竟是共享模式！doReleaseShared()我们留着下一小节的releaseShared()里来讲。</p><h5 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h5><p>至此，acquireShared()也要告一段落了。让我们再梳理一下它的流程：</p><ul><li>tryAcquireShared()尝试获取资源，成功则直接返回；</li><li>失败则通过doAcquireShared()进入等待队列park()，直到被unpark()/interrupt()并成功获取到资源才返回。整个等待过程也是忽略中断的。</li></ul><p>其实跟acquire()的流程大同小异，只不过多了个<strong>自己拿到资源后，还会去唤醒后继队友的操作（这才是共享嘛）</strong>。</p><h4 id="releaseShared"><a href="#releaseShared" class="headerlink" title="releaseShared"></a>releaseShared</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;<span class="comment">//尝试释放资源</span></span><br><span class="line">        doReleaseShared();<span class="comment">//唤醒后继结点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此方法的流程也比较简单，一句话：释放掉资源后，唤醒后继。跟独占模式下的release()相似，但有一点稍微需要注意：独占模式下的tryRelease()在完全释放掉资源（state=0）后，才会返回true去唤醒其他线程，这主要是基于独占下可重入的考量；而共享模式下的releaseShared()则没有这种要求，共享模式实质就是控制一定量的线程并发执行，那么拥有资源的线程在释放掉部分资源时就可以唤醒后继等待结点。例如，资源总量是13，A（5）和B（7）分别获取到资源并发运行，C（4）来时只剩1个资源就需要等待。A在运行过程中释放掉2个资源量，然后tryReleaseShared(2)返回true唤醒C，C一看只有3个仍不够继续等待；随后B又释放2个，tryReleaseShared(2)返回true唤醒C，C一看有5个够自己用了，然后C就可以跟A和B一起运行。而ReentrantReadWriteLock读锁的tryReleaseShared()只有在完全释放掉资源（state=0）才返回true，所以自定义同步器可以根据需要决定tryReleaseShared()的返回值。</p><h5 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared()"></a>doReleaseShared()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);<span class="comment">//唤醒后继</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (h == head)<span class="comment">// head发生变化</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="unparkSuccessor"><a href="#unparkSuccessor" class="headerlink" title="unparkSuccessor"></a>unparkSuccessor</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><p>Mutex是一个不可重入的互斥锁实现。锁资源（AQS里的state）只有两种状态：0表示未锁定，1表示锁定。下边是Mutex的核心源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> <span class="keyword">implements</span> <span class="title">Lock</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 自定义同步器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断是否锁定状态</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试获取资源，立即返回。成功则返回true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> acquires == <span class="number">1</span>; <span class="comment">// 这里限定只能为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;<span class="comment">//state为0才设置为1，不可重入！</span></span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());<span class="comment">//设置为当前线程独占资源</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 尝试释放资源，立即返回。成功则为true，否则false。</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> releases == <span class="number">1</span>; <span class="comment">// 限定为1个量</span></span><br><span class="line">            <span class="keyword">if</span> (getState() == <span class="number">0</span>)<span class="comment">//既然来释放，那肯定就是已占有状态了。只是为了保险，多层判断！</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);<span class="comment">//释放资源，放弃占有状态</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 真正同步类的实现都依赖继承于AQS的自定义同步器！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync = <span class="keyword">new</span> Sync();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//lock&lt;--&gt;acquire。两者语义一样：获取资源，即便等待，直到成功才返回。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//tryLock&lt;--&gt;tryAcquire。两者语义一样：尝试获取资源，要求立即返回。成功则为true，失败则为false。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.tryAcquire(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unlock&lt;--&gt;release。两者语文一样：释放资源。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//锁是否占有状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sync.isHeldExclusively();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同步类在实现时一般都将自定义同步器（sync）定义为内部类，供自己使用；而同步类自己（Mutex）则实现某个接口，对外服务。当然，接口的实现要直接依赖sync，它们在语义上也存在某种对应关系！！而sync只用实现资源state的获取-释放方式tryAcquire-tryRelelase，至于线程的排队、等待、唤醒等，上层的AQS都已经实现好了，我们不用关心。</p><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreExample1</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="comment">// 一次只能允许执行的线程数量。</span></span><br><span class="line">    <span class="keyword">final</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          semaphore.acquire();<span class="comment">// 获取一个许可，所以可运行线程数量为20/1=20</span></span><br><span class="line">          test(threadnum);</span><br><span class="line">          semaphore.release();<span class="comment">// 释放一个许可</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">"finish"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">"threadnum:"</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Semaphore 有两种模式，公平模式和非公平模式。</p><ul><li><strong>公平模式：</strong> 调用acquire的顺序就是获取许可证的顺序，遵循FIFO；</li><li><strong>非公平模式：</strong> 抢占式的。</li></ul><p><strong>Semaphore 对应的两个构造方法如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p>Semaphore有两种模式，公平模式和非公平模式。公平模式就是调用acquire的顺序就是获取许可证的顺序，遵循FIFO；而非公平模式是抢占式的，也就是有可能一个新的获取线程恰好在一个许可证释放时得到了这个许可证，而前面还有等待的线程。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到两个构造方法，都必须提供许可的数量，第二个构造方法可以指定是公平模式还是非公平模式，默认非公平模式。Semaphore内部基于AQS的共享模式，所以实现都委托给了Sync类。这里就看一下NonfairSync的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line"><span class="keyword">super</span>(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到直接调用了父类的构造方法，Sync的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">setState(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到调用了setState方法，也就是说AQS中的资源就是许可证的数量。</p><h4 id="获取许可"><a href="#获取许可" class="headerlink" title="获取许可"></a>获取许可</h4><p>先从获取一个许可看起，并且先看非公平模式下的实现。首先看acquire方法，acquire方法有几个重载，但主要是下面这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.acquireSharedInterruptibly(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，调用了Sync的acquireSharedInterruptibly方法，该方法在父类AQS中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//如果线程被中断了，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//获取许可失败，将线程加入到等待队列中</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS子类如果要使用共享模式的话，需要实现tryAcquireShared方法，下面看NonfairSync的该方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取剩余许可数量</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="comment">//计算给完这次许可数量后的个数</span></span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="comment">//如果许可不够或者可以将许可数量重置的话，返回</span></span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，只有在许可不够时返回值才会小于0，其余返回的都是剩余许可数量，这也就解释了，一旦许可不够，后面的线程将会阻塞。看完了非公平的获取，再看下公平的获取，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//如果前面有线程再等待，直接返回-1</span></span><br><span class="line">        <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//后面与非公平一样</span></span><br><span class="line">        <span class="keyword">int</span> available = getState();</span><br><span class="line">        <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">        <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">            compareAndSetState(available, remaining))</span><br><span class="line">            <span class="keyword">return</span> remaining;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，FairSync与NonFairSync的区别就在于会首先判断当前队列中有没有线程在等待，如果有，就老老实实进入到等待队列；而不像NonfairSync一样首先试一把，说不定就恰好获得了一个许可，这样就可以插队了。看完了获取许可后，再看一下释放许可。</p><h4 id="释放许可"><a href="#释放许可" class="headerlink" title="释放许可"></a>释放许可</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    sync.releaseShared(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>releaseShared方法在AQS中，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果改变许可数量成功</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AQS子类实现共享模式的类需要实现tryReleaseShared类来判断是否释放成功，实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取当前许可数量</span></span><br><span class="line">        <span class="keyword">int</span> current = getState();</span><br><span class="line">        <span class="comment">//计算回收后的数量</span></span><br><span class="line">        <span class="keyword">int</span> next = current + releases;</span><br><span class="line">        <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">        <span class="comment">//CAS改变许可数量成功，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面可以看到，一旦CAS改变许可数量成功，那么就会调用doReleaseShared()方法释放阻塞的线程。</p><h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。</p><h3 id="CountDownLatch-的三种典型用法"><a href="#CountDownLatch-的三种典型用法" class="headerlink" title="CountDownLatch 的三种典型用法"></a>CountDownLatch 的三种典型用法</h3><ul><li>某一线程在开始运行前等待n个线程执行完毕。将 CountDownLatch 的计数器初始化为n ：<code>new CountDownLatch(n)</code>，每当一个任务线程执行完毕，就将计数器减1 <code>countdownlatch.countDown()</code>，当计数器的值变为0时，在<code>CountDownLatch上 await()</code> 的线程就会被唤醒。一个典型应用场景就是启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行。</li><li>实现多个线程开始执行任务的最大并行性。注意是并行性，不是并发，强调的是多个线程在某一时刻同时开始执行。类似于赛跑，将多个线程放到起点，等待发令枪响，然后同时开跑。做法是初始化一个共享的 <code>CountDownLatch</code> 对象，将其计数器初始化为 1 ：<code>new CountDownLatch(1)</code>，多个线程在开始执行任务前首先 <code>coundownlatch.await()</code>，当主线程调用 countDown() 时，计数器变为0，多个线程同时被唤醒。</li><li>死锁检测：一个非常方便的使用场景是，你可以使用n个线程访问共享资源，在每次测试阶段的线程数目是不同的，并尝试产生死锁。</li></ul><h3 id="CountDownLatch-的使用示例"><a href="#CountDownLatch-的使用示例" class="headerlink" title="CountDownLatch 的使用示例"></a>CountDownLatch 的使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchExample1</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 请求的数量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个具有固定线程数量的线程池对象（如果这里线程池的线程数量给太少的话你会发现执行的很慢）</span></span><br><span class="line">    ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">300</span>);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">      <span class="keyword">final</span> <span class="keyword">int</span> threadnum = i;</span><br><span class="line">      threadPool.execute(() -&gt; &#123;<span class="comment">// Lambda 表达式的运用</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          test(threadnum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          countDownLatch.countDown();<span class="comment">// 表示一个请求已经被完成</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    countDownLatch.await();</span><br><span class="line">    threadPool.shutdown();</span><br><span class="line">    System.out.println(<span class="string">"finish"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">    System.out.println(<span class="string">"threadnum:"</span> + threadnum);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);<span class="comment">// 模拟请求的耗时操作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，我们定义了请求的数量为550，当这550个请求被处理完成之后，才会执行<code>System.out.println(&quot;finish&quot;);</code>。</p><p>与CountDownLatch的第一次交互是主线程等待其他线程。主线程必须在启动其他线程后立即调用CountDownLatch.await()方法。这样主线程的操作就会在这个方法上阻塞，直到其他线程完成各自的任务。</p><p>其他N个线程必须引用闭锁对象，因为他们需要通知CountDownLatch对象，他们已经完成了各自的任务。这种通知机制是通过 CountDownLatch.countDown()方法来完成的；每调用一次这个方法，在构造函数中初始化的count值就减1。所以当N个线程都调 用了这个方法，count的值等于0，然后主线程就能通过await()方法，恢复执行自己的任务。</p><h3 id="CountDownLatch-的不足"><a href="#CountDownLatch-的不足" class="headerlink" title="CountDownLatch 的不足"></a>CountDownLatch 的不足</h3><p>CountDownLatch是一次性的，计数器的值只能在构造方法中初始化一次，之后没有任何机制再次对其设置值，当CountDownLatch使用完毕后，它不能再次被使用。</p><h2 id="CyclicBarrier-循环栅栏"><a href="#CyclicBarrier-循环栅栏" class="headerlink" title="CyclicBarrier(循环栅栏)"></a>CyclicBarrier(循环栅栏)</h2><p>CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。</p><p>CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier默认的构造方法是 <code>CyclicBarrier(int parties)</code>，其参数表示屏障拦截的线程数量，每个线程调用<code>await</code>方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</p><h3 id="CyclicBarrier-的应用场景"><a href="#CyclicBarrier-的应用场景" class="headerlink" title="CyclicBarrier 的应用场景"></a>CyclicBarrier 的应用场景</h3><p>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。比如我们用一个Excel保存了用户所有银行流水，每个Sheet保存一个帐户近一年的每笔银行流水，现在需要统计用户的日均银行流水，先用多线程处理每个sheet里的银行流水，都执行完之后，得到每个sheet的日均银行流水，最后，再用barrierAction用这些线程的计算结果，计算出整个Excel的日均银行流水。</p><h3 id="CyclicBarrier-的使用示例"><a href="#CyclicBarrier-的使用示例" class="headerlink" title="CyclicBarrier 的使用示例"></a>CyclicBarrier 的使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample2</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line">    <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"threadnum:"</span> + threadnum + <span class="string">"is ready"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**等待60秒，保证子线程完全执行结束*/</span></span><br><span class="line">            cyclicBarrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"-----CyclicBarrierException------"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"threadnum:"</span> + threadnum + <span class="string">"is finish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    threadnum:0is ready</span></span><br><span class="line"><span class="comment">    threadnum:1is ready</span></span><br><span class="line"><span class="comment">    threadnum:2is ready</span></span><br><span class="line"><span class="comment">    threadnum:3is ready</span></span><br><span class="line"><span class="comment">    threadnum:4is ready</span></span><br><span class="line"><span class="comment">    threadnum:4is finish</span></span><br><span class="line"><span class="comment">    threadnum:0is finish</span></span><br><span class="line"><span class="comment">    threadnum:1is finish</span></span><br><span class="line"><span class="comment">    threadnum:2is finish</span></span><br><span class="line"><span class="comment">    threadnum:3is finish</span></span><br><span class="line"><span class="comment">    threadnum:5is ready</span></span><br><span class="line"><span class="comment">    threadnum:6is ready</span></span><br><span class="line"><span class="comment">    threadnum:7is ready</span></span><br><span class="line"><span class="comment">    threadnum:8is ready</span></span><br><span class="line"><span class="comment">    threadnum:9is ready</span></span><br><span class="line"><span class="comment">    threadnum:9is finish</span></span><br><span class="line"><span class="comment">    threadnum:5is finish</span></span><br><span class="line"><span class="comment">    threadnum:8is finish</span></span><br><span class="line"><span class="comment">    threadnum:7is finish</span></span><br><span class="line"><span class="comment">    threadnum:6is finish</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>可以看到当线程数量也就是请求数量达到我们定义的 5 个的时候， <code>await</code>方法之后的方法才被执行。</p><p>另外，CyclicBarrier还提供一个更高级的构造函数<code>CyclicBarrier(int parties, Runnable barrierAction)</code>，用于在线程到达屏障时，优先执行<code>barrierAction</code>，方便处理更复杂的业务场景。示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierExample3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 请求的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> threadCount = <span class="number">550</span>;</span><br><span class="line">    <span class="comment">// 需要同步的线程数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, () -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">"------当线程数达到之后，优先执行------"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 创建线程池</span></span><br><span class="line">        ExecutorService threadPool = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> threadNum = i;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            threadPool.execute(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    test(threadNum);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> threadnum)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"threadnum:"</span> + threadnum + <span class="string">"is ready"</span>);</span><br><span class="line">        cyclicBarrier.await();</span><br><span class="line">        System.out.println(<span class="string">"threadnum:"</span> + threadnum + <span class="string">"is finish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">threadnum:0is ready</span></span><br><span class="line"><span class="comment">    threadnum:1is ready</span></span><br><span class="line"><span class="comment">    threadnum:2is ready</span></span><br><span class="line"><span class="comment">    threadnum:3is ready</span></span><br><span class="line"><span class="comment">    threadnum:4is ready</span></span><br><span class="line"><span class="comment">    ------当线程数达到之后，优先执行------</span></span><br><span class="line"><span class="comment">    threadnum:4is finish</span></span><br><span class="line"><span class="comment">    threadnum:0is finish</span></span><br><span class="line"><span class="comment">    threadnum:2is finish</span></span><br><span class="line"><span class="comment">    threadnum:1is finish</span></span><br><span class="line"><span class="comment">    threadnum:3is finish</span></span><br><span class="line"><span class="comment">    threadnum:5is ready</span></span><br><span class="line"><span class="comment">    threadnum:6is ready</span></span><br><span class="line"><span class="comment">    threadnum:7is ready</span></span><br><span class="line"><span class="comment">    threadnum:8is ready</span></span><br><span class="line"><span class="comment">    threadnum:9is ready</span></span><br><span class="line"><span class="comment">    ------当线程数达到之后，优先执行------</span></span><br><span class="line"><span class="comment">    threadnum:9is finish</span></span><br><span class="line"><span class="comment">    threadnum:5is finish</span></span><br><span class="line"><span class="comment">    threadnum:6is finish</span></span><br><span class="line"><span class="comment">    threadnum:8is finish</span></span><br><span class="line"><span class="comment">    threadnum:7is finish</span></span><br><span class="line"><span class="comment">    ......</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h3><p>CountDownLatch是计数器，只能使用一次，而CyclicBarrier的计数器提供reset功能，可以多次使用。但是我不那么认为它们之间的区别仅仅就是这么简单的一点。我们来从jdk作者设计的目的来看，javadoc是这么描述它们的：</p><blockquote><p>CountDownLatch: A synchronization aid that allows one or more threads to wait until a set of operations being performed in other threads completes.(CountDownLatch: 一个或者多个线程，等待其他多个线程完成某件事情之后才能执行；)<br>CyclicBarrier : A synchronization aid that allows a set of threads to all wait for each other to reach a common barrier point.(CyclicBarrier : 多个线程互相等待，直到到达同一个同步点，再继续一起执行。)</p></blockquote><p>对于CountDownLatch来说，重点是“一个线程（多个线程）等待”，而其他的N个线程在完成“某件事情”之后，可以终止，也可以等待。而对于CyclicBarrier，重点是多个线程，在任意一个线程没有完成，所有的线程都必须等待。</p><p>CountDownLatch是计数器，线程完成一个记录一个，只不过计数不是递增而是递减，而CyclicBarrier更像是一个阀门，需要所有线程都到达，阀门才能打开，然后继续执行。</p><div align="center"><img width="100%" src="//isjinhao.github.io/2019/08-并发/AQS333.png"></div><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>在很多应用场景中，读操作可能会远远大于写操作。由于读操作根本不会修改原有的数据，因此对于每次读取都进行加锁其实是一种资源浪费。我们应该允许多个线程同时访问List的内部数据，毕竟读取操作是安全的。</p><p><code>CopyOnWriteArrayList</code> 类的所有可变操作（add，set等等）都是通过创建底层数组的新副本来实现的。当 List 需要被修改的时候，我并不修改原有内容，而是对原有数据进行一次复制，将修改的内容写入副本。写完之后，再将修改完的副本替换原来的数据，这样就可以保证写操作不会影响读操作了。</p><p>从 <code>CopyOnWriteArrayList</code> 的名字就能看出<code>CopyOnWriteArrayList</code> 是满足<code>CopyOnWrite</code> 的ArrayList，所谓<code>CopyOnWrite</code> 也就是说：在计算机，如果你想要对一块内存进行修改时，我们不在原有内存块中进行写操作，而是将内存拷贝一份，在新的内存中进行写操作，写完之后呢，就将指向原来内存指针指向新的内存，原来的内存就可以被回收掉了。</p><p>读取操作没有任何同步控制和锁操作，理由就是内部数组 array 不会发生修改，只会被另外一个 array 替换，因此可以保证数据安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Object[] array;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>CopyOnWriteArrayList 写入操作 add() 方法在添加集合的时候加了锁，保证了同步，避免了多线程写的时候会 copy 出多个副本出来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();<span class="comment">//加锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//拷贝新数组</span></span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();<span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h2><p>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。</p><p>ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。</p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/08-并发/20180625103613871.png"></div><p>我们前面介绍了，ConcurrentLinkedQueue的节点都是Node类型的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> E item;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">    Node(E item) &#123;</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = Node.class;</span><br><span class="line">            itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"item"</span>));</span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Node类也比较简单，不再解释，ConcurrentLinkedQueue类有下面两个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造方法，head节点存储的元素为空，tail节点等于head节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据其他集合来创建队列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = <span class="keyword">null</span>, t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 遍历节点</span></span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        <span class="comment">// 若节点为null，则直接抛出NullPointerException异常</span></span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>)</span><br><span class="line">            h = t = newNode;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            t.lazySetNext(newNode);</span><br><span class="line">            t = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>)</span><br><span class="line">        h = t = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    head = h;</span><br><span class="line">    tail = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下head节点存储的元素为空，tail节点等于head节点。</p><h3 id="入队操作"><a href="#入队操作" class="headerlink" title="入队操作"></a>入队操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果e为null，则直接抛出NullPointerException异常</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">// 创建入队节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 循环CAS直到入队成功</span></span><br><span class="line">    <span class="comment">// 1、根据tail节点定位出尾节点（last node）；2、将新节点置为尾节点的下一个节点；3、casTail更新尾节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">        <span class="comment">// p用来表示队列的尾节点，初始情况下等于tail节点</span></span><br><span class="line">        <span class="comment">// q是p的next节点</span></span><br><span class="line">        Node&lt;E&gt; q = p.next;</span><br><span class="line">        <span class="comment">// 判断p是不是尾节点，tail节点不一定是尾节点，判断是不是尾节点的依据是该节点的next是不是null</span></span><br><span class="line">        <span class="comment">// 如果p是尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// p is last node</span></span><br><span class="line">            <span class="comment">// 设置p节点的下一个节点为新节点，设置成功则casNext返回true；否则返回false，说明有其他线程更新过尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">                <span class="comment">// 如果p != t，则将入队节点设置成tail节点，更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点</span></span><br><span class="line">                <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                    casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 多线程操作时候，由于poll时候会把旧的head变为自引用，然后将head的next设置为新的head</span></span><br><span class="line">        <span class="comment">// 所以这里需要重新找新的head，因为新的head后面的节点才是激活的节点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">            <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">            <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">            <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">            <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">            p = (t != (t = tail)) ? t : head;</span><br><span class="line">        <span class="comment">// 寻找尾节点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">            p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码角度来看整个入队过程主要做两件事情：</p><ul><li>第一是定位出尾节点。tail节点并不总是尾节点，所以每次入队都必须先通过tail节点来找到尾节点，尾节点可能就是tail节点，也可能是tail节点的next节点。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于q节点的情况，出现这种情况的原因我们后续再来介绍。</li><li>第二是使用CAS算法能将入队节点设置成尾节点的next节点，如不成功则重试。p.casNext(null, newNode)方法用于将入队节点设置为当前队列尾节点的next节点，q如果是null表示p是当前队列的尾节点，如果不为null表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</li></ul><h4 id="tail节点不一定为尾节点的设计意图"><a href="#tail节点不一定为尾节点的设计意图" class="headerlink" title="tail节点不一定为尾节点的设计意图"></a>tail节点不一定为尾节点的设计意图</h4><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;线程的中断&quot;&gt;&lt;a href=&quot;#线程的中断&quot; class=&quot;headerlink&quot; title=&quot;线程的中断&quot;&gt;&lt;/a&gt;线程的中断&lt;
      
    
    </summary>
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/categories/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/tags/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="面试" scheme="https://isjinhao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>06-SpringCloud和SpringBoot</title>
    <link href="https://isjinhao.github.io/2019/06-SpringCloud%E5%92%8CSpringBoot/"/>
    <id>https://isjinhao.github.io/2019/06-SpringCloud和SpringBoot/</id>
    <published>2019-07-28T13:47:40.000Z</published>
    <updated>2019-08-06T06:31:07.679Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>05-JavaWeb和SSM</title>
    <link href="https://isjinhao.github.io/2019/05-JavaWeb%E5%92%8CSSM/"/>
    <id>https://isjinhao.github.io/2019/05-JavaWeb和SSM/</id>
    <published>2019-07-28T13:47:33.000Z</published>
    <updated>2019-08-22T01:38:34.912Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --><h2 id="Tomcat的结构"><a href="#Tomcat的结构" class="headerlink" title="Tomcat的结构"></a>Tomcat的结构</h2><div align="center"><img width="100%" src="//isjinhao.github.io/2019/05-JavaWeb和SSM/tomcat结构.png"></div><br>## HTTP请求<br><br>HTTP请求共有DELETE、HEAD、GET、OPTIONS、POST、PUT、TRACE和CONNECT八种请求方式。<br><br><div align="center"><img width="100%" src="05-JavaWeb和SSM/http请求.png"></div><br>## HTTP响应<br><br><div align="center"><img width="100%" src="05-JavaWeb和SSM/http响应.png"></div><br>## Servlet<br><br>Servlet是指任何实现了Servlet接口的类。一般情况下Servlet用来扩展基于HTTP协议的Web服务器，它可以接受和响应通过HTTP协议从客户端发过来的信息。<br><br>Servlet是一个类，但Servlet类的对象是由Web服务器创建的，不是由开发者创建的。并且多个客户端访问同一个Servlet时只会创建一个Servlet对象。<br><br><br><br>### Servlet的方法<br><br>Servlet有5个方法：<br><br>1. void init(ServletConfig config)：在服务器创建 Servlet对象时执行。<br>2. void destroy() ：在服务器关闭时调用。<br>3. ServletConfig getServletConfig() ：返回一个ServletConfig对象。<br>4. String getServletInfo() ：得到Servlet的信息。如作者、版本等。<br>5. void service(ServletRequest req, ServletResponse res) ：被服务器调用去获得和响应从服务器发来的请求。<br><br><br><br>### Servlet对象的生命周期<br><br>1. Servlet何时创建：默认第一次访问Servlet时创建该对象。<br>2. Servlet何时销毁：服务器关闭Servlet就销毁了。<br>3. 每次访问必然执行的方法：<code>service(ServletRequest req, ServletResponse res)</code>方法<br><br><br><br>### Servlet访问过程<br><br>浏览器中输入的URL会被浏览器封装成HTTP请求发送给服务器。Tomcat收到从客户端发来的时候解析HTTP请求中的资源地址，然后创建代表请求的requset和代表响应的response对象，再把这两个对象作为参数去调用service()方法。<br><br><br><br>## ServletConfig<br><br>代表当前Servlet在web.xml中的配置信息。当Servlet配置了初始化参数后，web容器在创建Servlet实例对象时，会自动将这些初始化参数封装到ServletConfig对象中，并在调用Servlet的init方法时，将ServletConfig对象传递给Servlet。进而，程序员通过ServletConfig对象就可以得到当前Servlet的初始化参数信息。这样做的好处是：如果将数据库信息、编码方式等配置信息放在web.xml中，如果以后数据库的用户名、密码改变了，则直接很方便地修改web.xml就行了，避免了直接修改源代码的麻烦。<strong>最大的用处是获得ServletContext对象。</strong><br><br><br><br>## HttpServlet开发<br><br>在开发的时候一般不直接实现Servlet来获取和响应从客户端发来的信息，而是继承Servlet接口的实现类HttpServlet。因为从客户端发来的请求和响应都是基于HTTP协议的，HttpServlet就是用于HTTP协议请求和响应的实现类，继承httpServlet后再覆盖某些方法进行开发即可。<br><br><br><br>### 继承HttpServlet进行开发<br><br>服务器会调用Servlet接口的service()方法，由于多态原则，真正被调用的方法是HttpServlet类的service()方法。HttpServlet类为每种请求方式都设置单独的处理方法，但我们使用的一般使用的是GET和POST请求方式，所以我们只需要覆盖doGet()和doPost()方法即可。这是因为HttpServlet()的service()方法中可以调用每种请求方式的方法，我们覆盖doGet()和doPost()就可以达到功能性需求。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/TestServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">       </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TestServlet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">doGet(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### web.xml配置<br><br><strong>必须配置的参数</strong><br><br>有Servlet还不行，Web服务器不能直接通过类名访问Servlet，必须通过一个虚拟路径来访问这个Servlet，所以要对Servlet进行配置。配置在web.xml文件中进行。举例说明：<br><br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Begin<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.servlet.begin.Begin<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>Begin<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/begin<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><br><br>当浏览器中地址输入为：<code>…/begin</code>，然后Tomcat去找此项目下虚拟路径为<code>/begin</code>对应的<code>servlet-name</code>，找到<code>servlet-name</code>后映射到servlet配置中找到它所对应的类<code>com.servlet.begin.Begin</code>。mapping在集合里指的是映射，在此指的也是映射。servlet-mapping里的Begin相当于Key。servlet里的servlet-class相当于Value。<br><br>总结来说，<code>servlet</code>和<code>servlet-mapping</code>里的<code>servlet-name</code>必须一致，<code>url-pattern</code>是浏览器输入的地址，<code>servlet-class</code>是对访问做出处理的类。<br><br><strong>可选配置的参数</strong><br><br>1. <code>load-on-startup</code>：<code>&lt;load-on-startup&gt;x&lt;/load-on-startup&gt;</code>，x大于等于1的时候表示在服务器启动的时候就创建Servlet对象。<br>2. 缺省Servlet：可以将url-pattern配置为’/’，代表该servlet是缺省的servlet，也就是当访问资源地址与所有的Servlet都不匹配时，有缺省的servlet负责处理，就是传说中的404界面。<br><br><br><br>### url-pattern的三种匹配<br><br>1. 完全匹配：访问的资源与配置的资源完全相同才能访问到。<br>2. 目录匹配：格式：<code>/虚拟的目录../*</code>。如：<code>…/abc/*</code>表示当输入路径<code>…/abc/xxx</code>的xxx为任意的时候都可以访问的到。<br>3. 拓展名匹配：格式：<code>*.扩展名</code>。如：<code>*.abcd</code>表示输入路径为<code>…/xxx.abcd</code>的xxx为任意的时候都能访问。在某路径下进行拓展名匹配是错误的，如：<code>/aaa/bbb/*.abcd</code>（错误的）<br><br><br><br>## HttpServletResponse<br><br>HttpServletResponse是一个接口，封装了向客户端输出信息的方法，部分方法如下：<br><br>1. void setStatus(int sc)：设置响应状态码；<br><br>2. void setHeader(String name, String data)：设置响应头；<br><br>3. ServletOutputStream getOutputStream()：返回一个输出流对象；<br><br>4. PrintWriter getWriter()：返回一个打印流对象。<br><br><br><br>### HttpServletResponse的执行过程<br><br>HttpServletResponse是向客户端输出信息的接口，但它的对象（设为response）不是直接把信息输出给浏览器，也不是直接输出给服务器。response会把要输出的信息输出到response的缓冲区，然后服务器拿到缓冲区的数据后再添加一些数据组成HTTP响应发送给客户端。<br><br><br><br>### 重定向<br><br>重定向的过程需要两次访问Servlet。当浏览器访问到重定向的Servlet时此Servlet会返回一个302的状态码和重定向的地址。代码会有两句：<br><br>1. <code>response.setStatus(int sc);</code><br>2. <code>response.setHeader(“location”, “要跳转的地址”);</code><br><br>但Java把这两步进行了封装，<code>response.sendRedirect(“要跳转的地址”);</code>。<br><br><br><br>### 定时刷新<br><br>使用setHeader()。response.setHeader(“refresh”, “3”);表示这个页面3秒后会被刷新。<br><br>还可以指定URL跳转到其他页面（URL可以带数据，所以是GET方式跳转）：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(“refresh”, “3;url=https:www.baidu.com”)</span><br></pre></td></tr></table></figure><br><br>### 输出乱码的解决<br><br>1. 设置response缓冲区：response缓冲区的默认编码是iso8859-1，设置为UTF-8编码需要使用：<code>response.setCharacterEncoding(String charset);</code><br>2. 设置浏览器编码：浏览器默认使用GBK编码，但缓冲区设置的是UTF-8编码，仍然有乱码问题存在：<code>response.setContentType(&quot;text/html;charset=UTF-8&quot;);</code><br>3. 一键解决缓冲区和浏览器问题：仍然是<code>response.setContentType(&quot;text/html;charset=UTF-8&quot;);</code>此方法默认包含了<code>response.setCharacterEncoding(String charset);</code>。<br><br><br><br>## ServletContext域对象<br><br>ServletContext类的对象（后续servletContext特指ServletContext类对象）是域对象，就是说这个对象可以进行数据的存取操作，它的作用范围是所有的Servlet。方法如下：<br><br>1. void setAttribute(String name, Object o)<br><br>2. String getAttribute(String name)<br><br>3. void removeAttribute(String name)<br><br><br><br><br>## HttpServletRequest<br><br>HttpServletRequest是一个接口，封装了获取浏览器发来的信息的方法。部分方法如下：<br><br>1. String getMethod()：获得请求方式；<br><br>2. String getHeader(String name)：获取某请求头的Value；<br><br>3. String getParameter(String name)：获得提交时的某参数的Value；<br><br>4. String getRemoteAddr()：获得客户端的IP地址；<br><br>5. String getContextPath()：获得web应用的名称；<br><br><br><br>### 提交乱码解决<br><br>1. POST方式：<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code><br><br>2. GET方式：<br><br>- 假设接收到的参数为param，在使用之前加上：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param = new String(param.getBytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;);</span><br></pre></td></tr></table></figure><br><br>- 修改server.xml文件：补上此句<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/05-JavaWeb和SSM/20180816152344395.png"></div><h3 id="HttpServletRequest域对象"><a href="#HttpServletRequest域对象" class="headerlink" title="HttpServletRequest域对象"></a>HttpServletRequest域对象</h3><p>HttpServletRequest接口的对象引用（request特指HttpServletRequest接口的对象引用）同时也是域对象，就是说这个对象可以进行数据的存取操作，它的作用范围是一次http请求，当此次请求结束（返回一个response时）。方法如下：</p><ol><li><code>void setAttribute(String name, Object o)</code></li><li><code>String getAttribute(String name)</code></li><li><code>void removeAttribute(String name)</code></li></ol><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><p>当客户端请求某个Servlet的时候，此Servlet交给别的Servlet解决叫做请求转发。请求转发分为两步：</p><ol><li>获得转发器：<code>RequestDispatcher rd = request.getRequestDispatcher(String path)</code></li><li>转发的时候携带请求和响应：<code>rd.forward(ServletRequest request, ServletResponse response)</code></li></ol><h3 id="辨析重定向和请求转发"><a href="#辨析重定向和请求转发" class="headerlink" title="辨析重定向和请求转发"></a>辨析重定向和请求转发</h3><p>重定向是两次请求服务器，请求转发只有一次请求服务器。重定向可以访问外部资源，转发只能访问内部资源。图解：</p><p><img src="file:///C:/Users/ISJINHAO/AppData/Local/Temp/msohtmlclip1/02/clip_image009.jpg" alt="img"></p><ol><li>转发的路径：项目中的<code>url-pattern</code></li><li>重定向的路径：项目名+项目中的<code>url-pattern</code></li></ol><h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><p>客户端访问服务器的时候，服务器并不知道客户端是谁，因为HTTP协议是无状态的。也就是说A把商品a加入购物车后关闭浏览器之后再来访问服务器时服务器分不出来是不是A访问了服务器。而会话技术就是帮助服务器区分客户端的。用户打开浏览器，访问Web服务器上多个资源，然后关闭浏览器，整个过程称之为一次会话。会话技术分为：Cookie和Session。</p><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie技术是将用户状态的数据存储到客户端的技术。主要方法如下：</p><ul><li>创建Cookie（不能保存中文信息）：<code>Cookie c = new Cookie(String name, String value);</code></li><li><p>设置Cookie在客户端的持久化时间，无持久化时间Cookie在关闭浏览器时信息会销毁： <code>c.setMaxAge(int seconds);</code>，时间秒。</p></li><li><p>设置Cookie的携带路径，如果不设置携带路径，那么该Cookie信息会在访问产生该Cookie的 web资源所在的路径都携带Cookie信息，如：</p><ul><li><code>cookie.setPath(&quot;/WEB&quot;);</code> 代表访问WEB应用中的任何资源都携带该Cookie</li><li><code>cookie.setPath(&quot;/WEB/cookieServlet&quot;);</code> 代表访问WEB中的cookieServlet时才携带Cookie信息</li></ul></li><li><p>向客户端发送Cookie：<code>response.addCookie(Cookie cookie);</code></p></li><li><p>删除客户端的Cookie：使用<strong>同名同路径且持久化时间为0</strong>的Cookie覆盖。</p></li><li><p>服务器获得客户端携带的Cookie：满足条件的Cookie会被自动以请求头的方式发送到服务器端。获得某一Cookie的内容需要两步：</p><ul><li><p>通过request获得所有的Cookie：<code>Cookie[] cookies = request.getCookies();</code></p></li><li><p>遍历Cookie数组，通过Cookie的名称获得我们想要的Cookie：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(Cookie cookie : cookies)&#123;</span><br><span class="line"><span class="keyword">if</span>(cookie.getName().equal(cookieName))&#123;</span><br><span class="line">String cookieValue = cookie.getValue();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><p>Session技术是将用户状态的数据存储到服务器端的技术。服务器会为每个客户端都创建一块内存空间 存储客户的数据，但客户端需要每次都携带一个标识ID（通过Cookie储存在客户端，在Tomcat中叫做JSESSIONID）去服务器中寻找属于自己的内 存空间。同时由于Session具有存储数据的功能，也是一个域对象。主要方法如下：</p><ol><li>获得Session对象：<code>HttpSession session = request.getSession();</code>。此方法会获得专属于当前会话的Session对象，如果服务器端没有该会话的Session对象会创建一个新的Session返回，如果已经有了属于该会话的Session直接将已有的Session返回（实质就是根据JSESSIONID判断该客户端是否在服务器上已经存在session了）</li><li>向Session中存储数据：<code>session.setAttribute(String name, Object obj);</code></li><li>从Session中获得数据：<code>session.getAttribute(String name);</code></li><li>移除Session中某名称的值：<code>session.removeAttribute(String name);</code></li></ol><h3 id="Session域的声明周期"><a href="#Session域的声明周期" class="headerlink" title="Session域的声明周期"></a>Session域的声明周期</h3><ul><li><p>创建：第一次执行request.getSession()时创建。</p></li><li><p>销毁：默认情况下在客户端不再操作服务器端资源时30分钟后session过期。</p><ol><li><p>手动销毁session： <code>session.invalidate();</code></p></li><li><p>也可以在工程的web.xml中进行配置来修改默认过期时间：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="name">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>作用范围：一次会话中任何资源公用一个session对象。</p></li></ul><h2 id="获得各种路径"><a href="#获得各种路径" class="headerlink" title="获得各种路径"></a>获得各种路径</h2><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/05-JavaWeb和SSM/路径.png"></div><p></p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(urlPatterns = <span class="string">"/api/*"</span>, filterName = <span class="string">"loginFilter"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器加载的时候调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"init loginFilter"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 请求被拦截的时候进行调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, </span></span></span><br><span class="line"><span class="function"><span class="params">         ServletResponse servletResponse, FilterChain filterChain)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"doFilter loginFilter"</span>);</span><br><span class="line"></span><br><span class="line">HttpServletRequest req = (HttpServletRequest) servletRequest;</span><br><span class="line">HttpServletResponse resp = (HttpServletResponse) servletResponse;</span><br><span class="line">String username = req.getParameter(<span class="string">"username"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="string">"xdclass"</span>.equals(username)) &#123;</span><br><span class="line">filterChain.doFilter(servletRequest, servletResponse);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">resp.sendRedirect(<span class="string">"/index.html"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 容器被销毁的时候被调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"destroy loginFilter"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个过滤器的执行顺序是按照filterName按字典排序执行。</p><table><thead><tr><th><strong>属性名</strong></th><th><strong>类型</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>filterName</td><td>String</td><td>指定过滤器的 name 属性，等价于<code>&lt;filter-name&gt;</code></td></tr><tr><td>value</td><td>String[]</td><td>该属性等价于 urlPatterns 属性。但是两者不应该同时使用。</td></tr><tr><td>urlPatterns</td><td>String[]</td><td>指定一组过滤器的 URL 匹配模式。等价于<code>&lt;url-pattern&gt;</code>标签。</td></tr><tr><td>servletNames</td><td>String[]</td><td>指定过滤器将应用于哪些 Servlet。取值是 @WebServlet 中的 name 属性的取值，或者是 web.xml 中<code>&lt;servlet-name&gt;</code>的取值。</td></tr><tr><td>dispatcherTypes</td><td>DispatcherType</td><td>指定过滤器的转发模式。具体取值包括： ASYNC、ERROR、FORWARD、INCLUDE、REQUEST。</td></tr><tr><td>initParams</td><td>WebInitParam[]</td><td>指定一组过滤器初始化参数，等价于<code>&lt;init-param&gt;</code>标签。</td></tr><tr><td>asyncSupported</td><td>boolean</td><td>声明过滤器是否支持异步操作模式，等价于<code>&lt;async-supported&gt;</code> 标签。</td></tr><tr><td>description</td><td>String</td><td>该过滤器的描述信息，等价于<code>&lt;description&gt;</code>标签。</td></tr><tr><td>displayName</td><td>String</td><td>该过滤器的显示名，通常配合工具使用，等价于<code>&lt;display-name&gt;</code>标签。</td></tr></tbody></table><h2 id="监听器"><a href="#监听器" class="headerlink" title="监听器"></a>监听器</h2><p>常用的监听器 servletContextListener、httpSessionListener、servletRequestListener。都是接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebListener</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestListener</span> <span class="keyword">implements</span> <span class="title">ServletRequestListener</span> </span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestDestroyed</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"======requestDestroyed========"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestInitialized</span><span class="params">(ServletRequestEvent sre)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"======requestInitialized========"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><p>Java Database Connectivity，Java数据库连接。是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序，所以说，JDBC对Java程序员而言是API，对实现与数据库连接的服务提供商而言是接口模型。作为API，JDBC为程序开发提供标准的接口，并为数据库厂商及第三方中间件厂商实现与数据库的连接提供了标准方法。</p><p>数据库并不是Java提供的，所以在Java中如果想连接数据库，肯定需要使用第三方jar包，这些jar包是数据库厂商根据JDBC接口模型开发的自己数据库的连接包。文章里使用的数据库是mysql，所以使用mysql-connector。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>使用JDBC需要六步：注册驱动、建立连接、创建Statement、执行查询、获得结果集、处理结果集、释放资源。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Connection con = <span class="keyword">null</span>;</span><br><span class="line">        Statement statement = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet query = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 1、注册驱动：在使用JDBC连接连接数据库的时候，Java程序并不知道自己是否连接上了相应的</span></span><br><span class="line"><span class="comment">             *            数据库，所以在第一步需要注册驱动，如果连接正常则可以进行接下来的操作。也</span></span><br><span class="line"><span class="comment">             *            就是说注册驱动这一步是通过我们导入的jar包测试能否正常连接数据库。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            DriverManager.registerDriver(<span class="keyword">new</span> com.mysql.jdbc.Driver());</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2、获得连接：数据库服务器中可能存在多个数据库，我们需要连接上我们即将使用的数据库。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            con = DriverManager.getConnection</span><br><span class="line">                (<span class="string">"jdbc:mysql://localhost/jdbc-study"</span>, <span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 3、创建Statement：如果想和数据库进行交互，一定需要使用这个类。JDK对他的解释是：</span></span><br><span class="line"><span class="comment">             *    The object used for executing a static SQL statement and </span></span><br><span class="line"><span class="comment">             *    returning the results it produces. </span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            statement = con.createStatement();</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 4、执行查询，获得结果集：想数据库中注入SQL语句，是我们能够进行操作</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String sql = <span class="string">"select * from students"</span>;</span><br><span class="line">    </span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 5、处理结果集：query是数据库中的元组集合，可以通过循环获得每个元组</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            query = statement.executeQuery(sql);</span><br><span class="line">            <span class="keyword">while</span>(query.next())&#123;</span><br><span class="line">                String id = query.getString(<span class="string">"id"</span>);</span><br><span class="line">                String name = query.getString(<span class="string">"name"</span>);</span><br><span class="line">                String clazz = query.getString(<span class="string">"clazz"</span>);</span><br><span class="line">                System.out.println(id + <span class="string">"  "</span> + name + <span class="string">"  "</span> + clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 6、释放资源：操作结束后进行操作</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span>(query != <span class="keyword">null</span>)</span><br><span class="line">                query.close();</span><br><span class="line">            <span class="keyword">if</span>(statement != <span class="keyword">null</span>)</span><br><span class="line">                statement.close();</span><br><span class="line">            <span class="keyword">if</span>(con != <span class="keyword">null</span>)</span><br><span class="line">                con.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="封装工具类"><a href="#封装工具类" class="headerlink" title="封装工具类"></a>封装工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> String driverClass = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> String url = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> String name = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span> String password= <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//1. 创建一个属性配置对象</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">InputStream is = <span class="keyword">new</span> FileInputStream(<span class="string">"jdbc.properties"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类加载器，去读取src底下的资源文件。 后面在servlet</span></span><br><span class="line"><span class="comment">// InputStream is = JDBCUtil.class.getClassLoader().</span></span><br><span class="line">            <span class="comment">//getResourceAsStream("jdbc.properties");</span></span><br><span class="line"><span class="comment">//导入输入流。</span></span><br><span class="line">properties.load(is);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取属性</span></span><br><span class="line">driverClass = properties.getProperty(<span class="string">"driverClass"</span>);</span><br><span class="line">url = properties.getProperty(<span class="string">"url"</span>);</span><br><span class="line">name = properties.getProperty(<span class="string">"name"</span>);</span><br><span class="line">password = properties.getProperty(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Connection&gt; </span><br><span class="line">        connectionHolder = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    conn = DriverManager.getConnection(url, name, password);</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取连接对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConn</span><span class="params">()</span></span>&#123;</span><br><span class="line">Connection conn = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(driverClass);</span><br><span class="line">conn = connectionHolder.get();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> conn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection conn , Statement st , ResultSet rs)</span></span>&#123;</span><br><span class="line">closeRs(rs);</span><br><span class="line">closeSt(st);</span><br><span class="line">closeConn(conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Connection conn =  connectionHolder.get();</span><br><span class="line">conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回滚事务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Connection conn =  connectionHolder.get();</span><br><span class="line"><span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">conn.rollback();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">Connection conn =  connectionHolder.get();</span><br><span class="line"><span class="keyword">if</span>(conn!=<span class="keyword">null</span>)&#123;</span><br><span class="line">conn.commit();</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeRs</span><span class="params">(ResultSet rs)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">rs.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">rs = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeSt</span><span class="params">(Statement st)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(st != <span class="keyword">null</span>)&#123;</span><br><span class="line">st.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">st = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">closeConn</span><span class="params">(Connection conn)</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">conn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">conn = <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">driverClass=com.mysql.jdbc.Driver</span><br><span class="line">url=jdbc:mysql://localhost/jdbc-study</span><br><span class="line">name=root</span><br><span class="line">password=root</span><br></pre></td></tr></table></figure><h3 id="CURD"><a href="#CURD" class="headerlink" title="CURD"></a>CURD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CRUD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Connection con;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        con = JDBCUtil.getConn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Statement statement = con.createStatement();</span><br><span class="line">        String sql = <span class="string">"select * from students"</span>;</span><br><span class="line">        ResultSet query = statement.executeQuery(sql);</span><br><span class="line">        <span class="keyword">while</span>(query.next())&#123;</span><br><span class="line">            String id = query.getString(<span class="string">"id"</span>);</span><br><span class="line">            String name = query.getString(<span class="string">"name"</span>);</span><br><span class="line">            String clazz = query.getString(<span class="string">"clazz"</span>);</span><br><span class="line">            System.out.println(id + <span class="string">"  "</span> + name + <span class="string">"  "</span> + clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Statement statement = con.createStatement();</span><br><span class="line">        String sql = <span class="string">"insert into students(id, name, clazz) values ('160341238', '赵承阳', '160341B')"</span>;</span><br><span class="line">        <span class="keyword">int</span> row = statement.executeUpdate(sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Statement statement = con.createStatement();</span><br><span class="line">        String sql = <span class="string">"update students set id = 'helloworld' where id = '160341237'"</span>;</span><br><span class="line">        <span class="keyword">int</span> row = statement.executeUpdate(sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Statement statement = con.createStatement();</span><br><span class="line">        String sql = <span class="string">"delete from students where id = '160341238'"</span>;</span><br><span class="line">        <span class="comment">//返回处理的行数</span></span><br><span class="line">        <span class="keyword">int</span> row = statement.executeUpdate(sql); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PrepareStatement"><a href="#PrepareStatement" class="headerlink" title="PrepareStatement"></a>PrepareStatement</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    Statement statement = con.createStatement();</span><br><span class="line">    String qid = <span class="string">"160341238 or 1 = 1"</span>;</span><br><span class="line">    String sql = <span class="string">"select * from students where id = "</span> + qid;</span><br><span class="line">    ResultSet query = statement.executeQuery(sql);</span><br><span class="line">    <span class="keyword">while</span>(query.next())&#123;</span><br><span class="line">    String id = query.getString(<span class="string">"id"</span>);</span><br><span class="line">    String name = query.getString(<span class="string">"name"</span>);</span><br><span class="line">    String clazz = query.getString(<span class="string">"clazz"</span>);</span><br><span class="line">    System.out.println(id + <span class="string">"  "</span> + name + <span class="string">"  "</span> + clazz);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/**Console:</span></span><br><span class="line"><span class="comment">    *      160341238  赵承阳  160341B</span></span><br><span class="line"><span class="comment">       aaa  詹金浩  160341B            */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面这段代码中，查询的qid后面添加上了or 1 = 1就可以把表中所有信息都查询出来，因为or 1 = 1这句话是一定为真，而我们刚才使用的Statement又使用的是拼接字符串的方式，在字符串中or会被认为是关键字，所以sql语句的条件永远为真。可以采用PrepareStatement类来解决这个问题。</p><h3 id="PrepareStatement-1"><a href="#PrepareStatement-1" class="headerlink" title="PrepareStatement"></a>PrepareStatement</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String sql = <span class="string">"select * from students where id=?"</span>;</span><br><span class="line">    PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 从1开始，把字符串填到匹配的?里。关键字也被认为是是字符串</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ps.setString(<span class="number">1</span>, <span class="string">"160341238 or 1 = 1"</span>);</span><br><span class="line">    ResultSet query = ps.executeQuery();</span><br><span class="line">    <span class="keyword">while</span>(query.next())&#123;</span><br><span class="line">    String id = query.getString(<span class="string">"id"</span>);</span><br><span class="line">    String name = query.getString(<span class="string">"name"</span>);</span><br><span class="line">    String clazz = query.getString(<span class="string">"clazz"</span>);</span><br><span class="line">    System.out.println(id + <span class="string">"  "</span> + name + <span class="string">"  "</span> + clazz);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无结果</span></span><br></pre></td></tr></table></figure><h3 id="改进的CURD"><a href="#改进的CURD" class="headerlink" title="改进的CURD"></a>改进的CURD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedCURD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Connection con;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        con = JDBCUtil.getConn();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from students where id=?"</span>;</span><br><span class="line">        PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">        ps.setString(<span class="number">1</span>, <span class="string">"160341238"</span>);</span><br><span class="line">        ResultSet query = ps.executeQuery();</span><br><span class="line">        <span class="keyword">while</span>(query.next())&#123;</span><br><span class="line">            String id = query.getString(<span class="string">"id"</span>);</span><br><span class="line">            String name = query.getString(<span class="string">"name"</span>);</span><br><span class="line">            String clazz = query.getString(<span class="string">"clazz"</span>);</span><br><span class="line">            System.out.println(id + <span class="string">"  "</span> + name + <span class="string">"  "</span> + clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sql = <span class="string">"insert into students(id, name, clazz) values (?, ?, ?)"</span>;</span><br><span class="line">        PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">        ps.setString(<span class="number">1</span>, <span class="string">"160341244"</span>);</span><br><span class="line">        ps.setString(<span class="number">2</span>, <span class="string">"qwe"</span>);</span><br><span class="line">        ps.setString(<span class="number">3</span>, <span class="string">"160341B"</span>);</span><br><span class="line">        <span class="keyword">int</span> row = ps.executeUpdate();</span><br><span class="line">        System.out.println(row);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sql = <span class="string">"update students set id = ? where id = ?"</span>;</span><br><span class="line">        PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">        ps.setString(<span class="number">1</span>, <span class="string">"helloworld"</span>);</span><br><span class="line">        ps.setString(<span class="number">2</span>, <span class="string">"160341243"</span>);</span><br><span class="line">        <span class="keyword">int</span> row = ps.executeUpdate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sql = <span class="string">"delete from students where id = ?"</span>;</span><br><span class="line">        PreparedStatement ps = con.prepareStatement(sql);</span><br><span class="line">        ps.setString(<span class="number">1</span>, <span class="string">"160341238"</span>);</span><br><span class="line">        <span class="keyword">int</span> row = ps.executeUpdate();</span><br><span class="line">        <span class="comment">//返回处理的行数</span></span><br><span class="line">        System.out.println(row);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><h3 id="自定义数据库连接池"><a href="#自定义数据库连接池" class="headerlink" title="自定义数据库连接池"></a>自定义数据库连接池</h3><p>数据库连接池的概念本来就是sun公司提出来的额，所以sun公司针对数据库连接池也提供了一套规范，一个简单的数据库连接池如下，只有获取连接和归还连接的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List &lt;Connection&gt; list = <span class="keyword">new</span> ArrayList&lt;Connection&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="title">MyDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Connection conn = JDBCUtil.getConn();</span><br><span class="line">            list.add(conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  该连接池对外公布的获取连接的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//来拿连接的时候，先看看，池子里面还有没有。</span></span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                Connection conn = JDBCUtil.getConn();</span><br><span class="line">                list.add(conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//remove(0) ---&gt; 移除第一个。 移除的是集合中的第一个。  移除的是开始的那个元素</span></span><br><span class="line">        Connection conn = list.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用完之后，记得归还。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBack</span><span class="params">(Connection conn)</span></span>&#123;</span><br><span class="line">        list.add(conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------</span></span><br><span class="line"><span class="comment">// other method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ol><li>AddBack()：这个方法不是接口中的方法，不能使用面向接口的编程。</li><li>连接池不是单例：在一个程序中，连接池应该只存在一个，每new一个都会产生一个连接池和n个连接。</li><li>扩容：当连接数大于我们设置的数量时需要对连接池中的连接扩容，否则就会产生问题。</li></ol><h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><ol><li>使用装饰者模式装饰Connection；</li><li>把连接池设为单例；</li><li>连接池空时自动增加机制。</li></ol><h3 id="改进的数据库连接池"><a href="#改进的数据库连接池" class="headerlink" title="改进的数据库连接池"></a>改进的数据库连接池</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">MyDataSource</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> MyDataSource mds = <span class="keyword">new</span> MyDataSource();</span><br><span class="line">    <span class="keyword">static</span> List &lt;Connection&gt; list = <span class="keyword">new</span> ArrayList&lt;Connection&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Connection conn = JDBCUtil.getConn();</span><br><span class="line">            list.add(conn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MyDataSource <span class="title">getMyDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  该连接池对外公布的获取连接的方法，扩容</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="comment">//来拿连接的时候，先看看，池子里面还有没有。</span></span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span> )&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                Connection conn = JDBCUtil.getConn();</span><br><span class="line">                list.add(conn);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Connection conn = list.remove(<span class="number">0</span>);</span><br><span class="line">        Connection connection = <span class="keyword">new</span> ConnectionWrap(conn, list);</span><br><span class="line">        <span class="keyword">return</span> connection;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用完之后，记得归还。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBack</span><span class="params">(Connection conn)</span></span>&#123;</span><br><span class="line">        list.add(conn);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//----------------------------</span></span><br><span class="line"><span class="comment">// other method</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionWrap</span> <span class="keyword">implements</span> <span class="title">Connection</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Connection connection = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> List &lt;Connection&gt; list ;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionWrap</span><span class="params">(Connection connection, List &lt;Connection&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.connection = connection;</span><br><span class="line">        <span class="keyword">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        list.add(connection);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">prepareStatement</span><span class="params">(String sql)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> connection.prepareStatement(sql);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//====================================================================</span></span><br><span class="line">    <span class="comment">//之后的方法没有被装饰，需要使用时再装饰</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">MyDataSource myDataSource = MyDataSource.getMyDataSource();</span><br><span class="line"></span><br><span class="line">Connection connection = <span class="keyword">new</span> ConnectionWrap(myDataSource.getConnection(), myDataSource.list);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="C3P0"><a href="#C3P0" class="headerlink" title="C3P0"></a>C3P0</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- default-config 默认的配置，  --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql://localhost/jdbc-study<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdleTime"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span>&gt;</span>200<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">&lt;!-- This app is massive! --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">named-config</span> <span class="attr">name</span>=<span class="string">"oracle"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>100<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>1000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- intergalactoApp adopts a different approach to configuring statement caching --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span>&gt;</span>0<span class="tag">&lt;/<span class="name">property</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatementsPerConnection"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- he's important, but there's only one of him --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">user-overrides</span> <span class="attr">user</span>=<span class="string">"master-of-the-universe"</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"acquireIncrement"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>5<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatementsPerConnection"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">user-overrides</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">named-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Connection connection = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//1、构建数据源</span></span><br><span class="line">            ComboPooledDataSource cpds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2、得到连接对象</span></span><br><span class="line">            connection = cpds.getConnection();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//3、执行sql语句</span></span><br><span class="line">            String sql = <span class="string">"select * from students"</span>;</span><br><span class="line">            ps = connection.prepareStatement(sql);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//4、获得结果、处理结果</span></span><br><span class="line">            ResultSet query = ps.executeQuery();</span><br><span class="line">            <span class="keyword">while</span>(query.next()) &#123;</span><br><span class="line">                String id = query.getString(<span class="string">"id"</span>);</span><br><span class="line">                String name = query.getString(<span class="string">"name"</span>);</span><br><span class="line">                String clazz = query.getString(<span class="string">"clazz"</span>);</span><br><span class="line">                System.out.println(id + <span class="string">" "</span> + name + <span class="string">" "</span> + clazz);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ps.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                connection.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Dbutils"><a href="#Dbutils" class="headerlink" title="Dbutils"></a>Dbutils</h2><h3 id="增删改"><a href="#增删改" class="headerlink" title="增删改"></a>增删改</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1、指定数据库连接池</span></span><br><span class="line">        ComboPooledDataSource dataSource = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2、增删改都使用update方法</span></span><br><span class="line">        QueryRunner qr = <span class="keyword">new</span> QueryRunner(dataSource);</span><br><span class="line">        String insert = <span class="string">"insert into students(id, name, clazz) values(?, ?, ?)"</span>;</span><br><span class="line">        qr.update(insert, <span class="string">"123"</span>, <span class="string">"123"</span>, <span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">        String update = <span class="string">"update students set name = ? where id = ?"</span>;</span><br><span class="line">        qr.update(update, <span class="string">"789"</span>, <span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line">        String delete = <span class="string">"delete from students where id = ?"</span>;</span><br><span class="line">        qr.update(delete, <span class="string">"123"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><h4 id="自定义封装-返回值类型是单个对象"><a href="#自定义封装-返回值类型是单个对象" class="headerlink" title="自定义封装-返回值类型是单个对象"></a>自定义封装-返回值类型是单个对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">String query = <span class="string">"select * from students where id = ?"</span>;</span><br><span class="line"></span><br><span class="line">Student student = qr.query(query, <span class="keyword">new</span> ResultSetHandler&lt;Student&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            String id = rs.getString(<span class="string">"id"</span>);</span><br><span class="line">            String name = rs.getString(<span class="string">"name"</span>);</span><br><span class="line">            String clazz = rs.getString(<span class="string">"clazz"</span>);</span><br><span class="line">            s.setId(id);</span><br><span class="line">            s.setName(name);</span><br><span class="line">            s.setClazz(clazz);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">"helloworld"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(student);</span><br></pre></td></tr></table></figure><h4 id="自定义封装-返回值类型是集合"><a href="#自定义封装-返回值类型是集合" class="headerlink" title="自定义封装-返回值类型是集合"></a>自定义封装-返回值类型是集合</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String query = <span class="string">"select * from students"</span>;</span><br><span class="line">List&lt;Student&gt; list = qr.query(query, <span class="keyword">new</span> ResultSetHandler&lt;List&lt;Student&gt;&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">handle</span><span class="params">(ResultSet rs)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        List&lt;Student&gt; l = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="keyword">while</span>(rs.next()) &#123;</span><br><span class="line">            s.setId(rs.getString(<span class="string">"id"</span>));</span><br><span class="line">            s.setName(rs.getString(<span class="string">"name"</span>));</span><br><span class="line">            s.setClazz(rs.getString(<span class="string">"clazz"</span>));</span><br><span class="line">            l.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure><h4 id="快速封装-返回值类型是单个对象"><a href="#快速封装-返回值类型是单个对象" class="headerlink" title="快速封装-返回值类型是单个对象"></a>快速封装-返回值类型是单个对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String query = <span class="string">"select * from students where id = ?"</span>;</span><br><span class="line">Student q = qr.query(query, <span class="keyword">new</span> BeanHandler&lt;&gt;(Student.class), <span class="string">"helloworld"</span>);</span><br><span class="line">System.out.println(q);</span><br><span class="line"><span class="comment">/**Console:</span></span><br><span class="line"><span class="comment">*   Student [id=helloworld, name=qwe, clazz=160341B]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="快速封装-返回值类型是多个对象"><a href="#快速封装-返回值类型是多个对象" class="headerlink" title="快速封装-返回值类型是多个对象"></a>快速封装-返回值类型是多个对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String query = <span class="string">"select * from students"</span>;</span><br><span class="line">List&lt;Student&gt; l = qr.query(query, <span class="keyword">new</span> BeanListHandler&lt;&gt;(Student.class));</span><br><span class="line">System.out.println(l);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * [Student [id=160341240, name=qwe, clazz=160341B], </span></span><br><span class="line"><span class="comment"> *      Student [id=160341244, name=qwe, clazz=160341B], </span></span><br><span class="line"><span class="comment"> *          Student [id=aaa, name=詹金浩, clazz=160341B], </span></span><br><span class="line"><span class="comment"> *              Student [id=helloworld, name=qwe, clazz=160341B]]</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h2 id="跨域问题和CORS"><a href="#跨域问题和CORS" class="headerlink" title="跨域问题和CORS"></a>跨域问题和CORS</h2><h3 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h3><p>如果两个页面的<strong>协议</strong>，<strong>端口（如果有指定）</strong>和<strong>主机</strong>都相同，则两个页面具有相同的<strong>源</strong>。下表给出了同源检测的示例，相对：<code>http://store.company.com/dir/page.html</code>:</p><table><thead><tr><th style="text-align:left">URL</th><th style="text-align:left">结果</th><th style="text-align:center">原因</th></tr></thead><tbody><tr><td style="text-align:left"><code>http://store.company.com/dir2/other.html</code></td><td style="text-align:left">成功</td><td style="text-align:center">只有路径不同</td></tr><tr><td style="text-align:left"><code>http://store.company.com/dir/inner/another.html</code></td><td style="text-align:left">成功</td><td style="text-align:center">只有路径不同</td></tr><tr><td style="text-align:left"><code>https://store.company.com/secure.html</code></td><td style="text-align:left">失败</td><td style="text-align:center">不同协议 ( https和http )</td></tr><tr><td style="text-align:left"><code>http://store.company.com:81/dir/etc.html</code></td><td style="text-align:left">失败</td><td style="text-align:center">不同端口 ( http:// 80是默认的)</td></tr><tr><td style="text-align:left"><code>http://news.company.com/dir/other.html</code></td><td style="text-align:left">失败</td><td style="text-align:center">不同域名 ( news和store )</td></tr></tbody></table><h3 id="没有同源策略限制的两个危险场景"><a href="#没有同源策略限制的两个危险场景" class="headerlink" title="没有同源策略限制的两个危险场景"></a>没有同源策略限制的两个危险场景</h3><h4 id="没有同源策略限制的接口请求"><a href="#没有同源策略限制的接口请求" class="headerlink" title="没有同源策略限制的接口请求"></a>没有同源策略限制的接口请求</h4><p>有一个小小的东西叫cookie大家应该知道，一般用来处理登录等场景，目的是让服务端知道谁发出的这次请求。如果你请求了接口进行登录，服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中，服务端就能知道这个用户已经登录过了。知道这个之后，我们来看场景：</p><ul><li>你准备去清空你的购物车，于是打开了买买买网站<code>www.maimaimai.com</code>，然后登录成功，一看，购物车东西这么少，不行，还得买多点。</li><li>你在看有什么东西买的过程中，你的好基友发给你一个链接<code>www.nidongde.com</code>，一脸yin笑地跟你说：“你懂的”，你毫不犹豫打开了。</li><li>你饶有兴致地浏览着<code>www.nidongde.com</code>，谁知这个网站暗地里做了些不可描述的事情！由于没有同源策略的限制，它向<code>www.maimaimai.com</code>发起了请求！聪明的你一定想到一句话“服务端验证通过后会在响应头加入Set-Cookie字段，然后下次再发请求的时候，浏览器会自动将cookie附加在HTTP请求的头字段Cookie中”，这样一来，这个不法网站就相当于登录了你的账号，可以为所欲为了！当然，这只是对cookie的一方面限制，想完整的保证cookie的安全性还必须信息安全同学的头发。</li></ul><h4 id="没有同源策略限制的Dom查询"><a href="#没有同源策略限制的Dom查询" class="headerlink" title="没有同源策略限制的Dom查询"></a>没有同源策略限制的Dom查询</h4><ul><li>有一天你刚睡醒，收到一封邮件，说是你的银行账号有风险，赶紧点进<code>www.yinghang.com</code>改密码。你吓尿了，赶紧点进去，还是熟悉的银行登录界面，你果断输入你的账号密码，登录进去看看钱有没有少了。</li><li>睡眼朦胧的你没看清楚，平时访问的银行网站是<code>www.yinhang.com</code>，而现在访问的是<code>www.yinghang.com</code>，这个钓鱼网站做了什么呢？</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HTML</span></span><br><span class="line">&lt;iframe name=<span class="string">"yinhang"</span> src=<span class="string">"www.yinhang.com"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span></span><br><span class="line"><span class="comment">// JS</span></span><br><span class="line"><span class="comment">// 由于没有同源策略的限制，钓鱼网站可以直接拿到别的网站的Dom</span></span><br><span class="line"><span class="keyword">const</span> iframe = <span class="built_in">window</span>.frames[<span class="string">'yinhang'</span>]</span><br><span class="line"><span class="keyword">const</span> node = iframe.document.getElementById(<span class="string">'你输入账号密码的Input'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`拿到了这个<span class="subst">$&#123;node&#125;</span>，我还拿不到你刚刚输入的账号密码吗`</span>)</span><br></pre></td></tr></table></figure><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/05-JavaWeb和SSM/2019-07-11_154252.jpg"></div><br>但是对于如下的请求，会被同源策略放行：<p></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"//static.store.com/jquery.js &gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>这样的话可以保证一些插件能从指定的地址下载放到我们自己的页面中。其实这种“嵌入式”的跨域加载资源的方式还有<code>&lt;img&gt;</code>、<code>&lt;link&gt;</code>等，相当于我们浏览器发起了一次GET请求，取到相关资源，然后放到本地而已。</p><h3 id="CORS解决跨域问题"><a href="#CORS解决跨域问题" class="headerlink" title="CORS解决跨域问题"></a>CORS解决跨域问题</h3><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。看名字就知道这是处理跨域问题的标准做法。CORS有两种请求，简单请求和非简单请求。</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><p>只要同时满足以下两大条件，就属于简单请求。</p><ol><li>请求方法是以下三种方法之一：<ol><li>HEAD</li><li>GET</li><li>POST</li></ol></li><li>HTTP的头信息不超出以下几种字段：<ol><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ol></li></ol><p>当浏览器发现发起的ajax请求是简单请求时，会在请求头中携带一个字段：<code>Origin</code>。</p><p></p><div align="center"><img width="100%" src="//isjinhao.github.io/2019/05-JavaWeb和SSM/1530460311064.png"></div><br>Origin中会指出当前请求属于哪个域（协议+域名+端口）。服务会根据这个值决定是否允许其跨域。如果服务器允许跨域，需要在返回的响应头中携带下面信息：<p></p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://manage.leyou.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><ul><li>Access-Control-Allow-Origin：可接受的域，是一个具体域名或者*（代表任意域名）</li><li>Access-Control-Allow-Credentials：是否允许携带cookie，默认情况下，cors不会携带cookie，除非这个值是true。</li></ul><p>服务器想要操作当前页面的cookie，需要满足3个条件：</p><ul><li>服务的响应头中需要携带Access-Control-Allow-Credentials并且为true。</li><li>浏览器发起ajax请求需要指定字段withCredentials 为true</li><li>响应头中的Access-Control-Allow-Origin一定不能为*，必须是指定的域名</li></ul><h4 id="特殊请求"><a href="#特殊请求" class="headerlink" title="特殊请求"></a>特殊请求</h4><p>特殊请求会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。</p><p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIONS</span> <span class="string">/cors</span> HTTP/1.1</span><br><span class="line"><span class="attribute">Origin</span>: http://manage.leyou.com</span><br><span class="line"><span class="attribute">Access-Control-Request-Method</span>: PUT</span><br><span class="line"><span class="attribute">Access-Control-Request-Headers</span>: X-Custom-Header</span><br><span class="line"><span class="attribute">Host</span>: api.leyou.com</span><br><span class="line"><span class="attribute">Accept-Language</span>: en-US</span><br><span class="line"><span class="attribute">Connection</span>: keep-alive</span><br><span class="line"><span class="attribute">User-Agent</span>: Mozilla/5.0...</span><br></pre></td></tr></table></figure><p>与简单请求相比，除了Origin以外，多了两个头：</p><ul><li>Access-Control-Request-Method：接下来会用到的请求方式，比如PUT</li><li>Access-Control-Request-Headers：会额外用到的头信息</li></ul><p>服务的收到预检请求，如果许可跨域，会发出响应：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 <span class="number">200</span> OK</span><br><span class="line"><span class="attribute">Date</span>: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line"><span class="attribute">Server</span>: Apache/2.0.61 (Unix)</span><br><span class="line"><span class="attribute">Access-Control-Allow-Origin</span>: http://manage.leyou.com</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span>: true</span><br><span class="line"><span class="attribute">Access-Control-Allow-Methods</span>: GET, POST, PUT</span><br><span class="line"><span class="attribute">Access-Control-Allow-Headers</span>: X-Custom-Header</span><br><span class="line"><span class="attribute">Access-Control-Max-Age</span>: 1728000</span><br><span class="line"><span class="attribute">Content-Type</span>: text/html; charset=utf-8</span><br><span class="line"><span class="attribute">Content-Encoding</span>: gzip</span><br><span class="line"><span class="attribute">Content-Length</span>: 0</span><br><span class="line"><span class="attribute">Keep-Alive</span>: timeout=2, max=100</span><br><span class="line"><span class="attribute">Connection</span>: Keep-Alive</span><br><span class="line"><span class="attribute">Content-Type</span>: text/plain</span><br></pre></td></tr></table></figure><p>除了<code>Access-Control-Allow-Origin</code>和<code>Access-Control-Allow-Credentials</code>以外，这里又额外多出3个头：</p><ul><li>Access-Control-Allow-Methods：允许访问的方式</li><li>Access-Control-Allow-Headers：允许携带的头</li><li>Access-Control-Max-Age：本次许可的有效时长，单位是秒，**过期之前的ajax请求就无需再次进行预检了</li></ul><h3 id="SpringMVC实现"><a href="#SpringMVC实现" class="headerlink" title="SpringMVC实现"></a>SpringMVC实现</h3><p>实现比较简单：</p><ul><li>浏览器端都有浏览器自动完成，我们无需操心</li><li>服务端可以通过拦截器统一实现，不必每次都去进行跨域判定的编写。</li></ul><p>事实上，SpringMVC已经帮我们写好了CORS的跨域过滤器：CorsFilter，内部已经实现了刚才所讲的判定逻辑，我们直接用就好了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.CorsConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CorsFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1.添加CORS配置信息</span></span><br><span class="line">        CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">        <span class="comment">//1) 允许的域,不要写*，否则cookie就无法使用了</span></span><br><span class="line">        config.addAllowedOrigin(<span class="string">"http://manage.leyou.com"</span>);</span><br><span class="line">        <span class="comment">//2) 是否发送Cookie信息</span></span><br><span class="line">        config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">//3) 允许的请求方式</span></span><br><span class="line">        config.addAllowedMethod(<span class="string">"OPTIONS"</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">"HEAD"</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">"GET"</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">"PUT"</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">"POST"</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">"DELETE"</span>);</span><br><span class="line">        config.addAllowedMethod(<span class="string">"PATCH"</span>);</span><br><span class="line">        <span class="comment">// 4）允许的头信息</span></span><br><span class="line">        config.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.添加映射路径，我们拦截一切请求</span></span><br><span class="line">        UrlBasedCorsConfigurationSource configSource = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">        configSource.registerCorsConfiguration(<span class="string">"/**"</span>, config);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//3.返回新的CorsFilter</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CorsFilter(configSource);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Tomcat的结构&quot;&gt;&lt;a href=&quot;#Tomcat的结构&quot; class=&quot;headerlink&quot; title=&quot;Tomcat的结构
      
    
    </summary>
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/categories/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/tags/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="面试" scheme="https://isjinhao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>04-操作系统和Linux</title>
    <link href="https://isjinhao.github.io/2019/04-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%92%8CLinux/"/>
    <id>https://isjinhao.github.io/2019/04-操作系统和Linux/</id>
    <published>2019-07-28T13:47:27.000Z</published>
    <updated>2019-08-16T03:37:01.063Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:51 GMT+0800 (GMT+08:00) --><h2 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h2><p>操作系统（Operating System，简称OS）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是管理硬件设备来提高利用率和吞吐量，同时为用户和应用系统提供易于使用的接口。</p><ul><li>提高利用率：使系统中各设备的空闲时间尽可能短。</li><li>提高吞吐量：使单位时间内完成的业务更多。</li><li>提供易于使用的接口：即是方便使用计算机资源。例如没有操作系统，操纵计算机可能需要用户输入二进制代码，有了操作系统，用户可以点击图标，操作系统就会将其转换成二进制代码。</li></ul><h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><ul><li>方便性：即对用户和应用程序提供易于使用的接口。</li><li>有效性：提高利用率和吞吐量。</li><li>可扩充性：计算机硬件和体系结构等都在不断发展中，OS需要有好的可扩充性来满足不断发展的需求。</li><li>开放性：为了使计算机的应用环境从单机转换成网络，OS需要满足相应的软硬件标准来实现设备的互联。</li></ul><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ul><li>提供易于使用的接口，如Shell、图形界面等。</li><li>管理计算机所有的资源，负责计算机系统全部资源的分配、控制、调度和回收。</li><li>隐蔽硬件特性，如计算2*3，某些机器的实现是使用加法器做2+2+2，而有的机器是乘法器实现2*3。操作系统屏蔽这些细节，用户只需要输入2*3就能完成。</li></ul><h2 id="未配置操作系统的计算机系统"><a href="#未配置操作系统的计算机系统" class="headerlink" title="未配置操作系统的计算机系统"></a>未配置操作系统的计算机系统</h2><ul><li>人工操作：程序员把程序和数据通过穿孔的方式记录在纸带上，再启动机器读入纸带，运行完成并取走计算结果后，才允许下一个用户上机。缺点：<ul><li>用户独占整机：计算机上的资源为上机用户独占。</li><li>设备空闲率高：用户装卡，卸卡等人工操作时，设备资源是空闲的。</li></ul></li><li>脱机输入/输出（Off-Line I/O）：为了解决人机矛盾及CPU、I/O等设备之间速度的不匹配。它是先把纸带通过输入设备在外围机（与主机相比处于次要地位的计算机）的控制下输入到磁带上，当CPU需要这些信息时再从磁带上高速地调取。类似的，在输出时把信息输出到磁盘中，在外围机的控制下通过输出设备输出。也就是说主机直接对磁盘进行操作，输入输出和程序运行脱离。<ul><li>減少了CPU的空闲时间：主机不必依赖输入输出，可以从磁盘中读取数据。</li><li>提升了I/O速度：主机读取信息不再是从卡片中读取，从磁盘读取速度较快。</li></ul></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/脱机输入输出.jpg"></div><h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><p>为了提升计算机资源的利用率和提升计算机的吞吐量研发出了批操作系统。</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>作业：程序+数据+作业说明书（系统根据说明书来对程序的运行进行控制）。</li><li>周转时间：从作业进入系统到作业完成退出系统所用的时间。</li><li>平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NT_i]$</li><li>带权周转时间：作业的周转时间（$T$）和系统为它提供服务的时间（$T_S$）。$W=\frac{T}{T_s}$</li><li>平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NW_i]$</li></ul><h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><p>设计一个常驻内存的程序（监督程序），操作员有选择地把若干作业合成一批，安装输入设备上，并启动监督程序，然后由监督程序自动控制这批作业运行，从而减少部分人工干预，有效地缩短了作业运行前的准备时间，相对的提高CPU的利用率。同一时刻只有一个硬件在运行。特点：自动性、顺序性、单道性。缺点：</p><ul><li>I/O的慢速与CPU 的高速不匹配，且输入时需要CPU等待。</li><li>用户交互性差。作业安装输入后，就不能再交互。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/单道批处理系统.jpg"></div><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><p>把一个以上的作业存放在主存中，并且同时处于运行状态，使这些作业共享处理机和外部设备等其它系统资源。对于一个单处理机系统来说，作业同时处于运行状态只是宏观的概念，其含义是指每个作业都已开始运行，但尚未完成。就微观而言，在任意特定时刻，处理机上运行的作业只有一个。特点：多道性、无序性、调度性。优缺点：</p><ul><li>优点：资源利用率高、系统吞吐量大。</li><li>缺点：作业仍然要排队处理，所以平均周转时间长、无交互能力。<br>此时如何调度程序已经不是再用一张简单的流程图能说明了，<a href="02-进程&amp;线程.md">第二章</a>会有介绍。下图只是说明处理器利用率高。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/多道批处理.jpg"></div><h3 id="举例证明资源利用率高和系统吞吐量大"><a href="#举例证明资源利用率高和系统吞吐量大" class="headerlink" title="举例证明资源利用率高和系统吞吐量大"></a>举例证明资源利用率高和系统吞吐量大</h3><p>设内存中有三道程序 A、B、C，它们的计算和I/O操作的时间如下表所示：</p><table><thead><tr><th style="text-align:center">程序操作</th><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th></tr></thead><tbody><tr><td style="text-align:center">计算</td><td style="text-align:center">30</td><td style="text-align:center">60</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">I/O</td><td style="text-align:center">40</td><td style="text-align:center">30</td><td style="text-align:center">40</td></tr><tr><td style="text-align:center">计算</td><td style="text-align:center">10</td><td style="text-align:center">10</td><td style="text-align:center">20</td></tr></tbody></table><ul><li>单道</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/单道举例.jpg" width="100%"></div><br>- 多道<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/多道举例.jpg" width="100%"></div><h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><p>批处理系统中，作业一旦提交就不能进行更改，所以人机交互性很差。为了满足人机交互的需求诞生分时系统。每一个用户通过一台终端与计算机相连，以交互式的命令使用系统，采用分享CPU的方法，由于CPU的速度比人在终端输入指令的时间快得多，所以用户感到自己独占了整个计算机系统。系统规定一个称之为“时间片”的时间单位，所有终端用户轮流享用一个时间片的CPU。需要解决的问题：</p><ul><li>及时接受：所有终端用户输入的信息都要能够被及时的送到处理器上。所以主机会以很快的速度循环扫描各个终端。每个终端也要拥有缓存区来保存输入的信息。</li><li>及时处理：用户需要能对自己的作业及其允许及时地实施控制。所以所有的作业必须驻留在内存中，因此批作业系统不能被使用。它采用的方式是：作业直接进入内存。但每个用户只连续使用一个“时间片”的时间，对所有用户进行循环。这样每个用户都能及时地与自己的作业进行交互。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/分时系统.jpg"></div><h3 id="分时系统与多道批处理系统的不同特性"><a href="#分时系统与多道批处理系统的不同特性" class="headerlink" title="分时系统与多道批处理系统的不同特性"></a>分时系统与多道批处理系统的不同特性</h3><ul><li>多路性：允许多个用户共享一台计算机，提高资源利用率。</li><li>独立性：每个用户之间互不干扰，感觉就是一个人在独占一台计算机。</li><li>及时性：用户的请求能在很短的时间内得到回应。</li><li>交互性：用户可以通过终端和计算机进行及时交互。</li></ul><h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2><p>指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。实时系统强调程序运行的时间，它需对接收到的某些信号做出及时地反应。大多数的实时系统是专用系统，如：工业（武器）控制系统、信息查询系统、多媒体系统、嵌入式系统等。最大的特点就是可靠性：系统必须高度可靠，因为任何可能的差错都可能带来灾难性后果，所以系统一般都有多级容错措施。</p><ul><li>按是否周期执行分类：<ul><li>周期性实时任务：如外部设备周期性地发出状态信号给计算机使其状态能被实时感知。</li><li>非周期性实时任务：提交给系统时需要指定开始截止时间和完成截止时间。</li></ul></li><li>硬实时任务&amp;软实时任务：<ul><li>硬实时任务（Hard Real-time Task）：截止时间到达时任务必须完成，比如武器控制系统。</li><li>软实时任务（Soft Real-time Task）：截止时间到达时任务没有完成没有太大影响，比如多媒体系统。</li></ul></li></ul><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ul><li>进程：在系统中能独立运行并作为资源分配的基本单位。</li><li>线程：独立运行的基本单位，比进程更小，基本上不拥有系统资源。通常在一个进程中包含了若干个线程。</li></ul><h2 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a>操作系统的基本特性</h2><ul><li>并发：宏观上是多个进程同时运行，微观上是每一时刻只有一道进程在执行。</li><li>共享：系统中的资源可供内存中多个并发执行的进程（线程）共同使用。有两种共享方式：<ul><li>互斥共享方式，如打印机；</li><li>同时访问方式，如共享文件夹、网络资源。</li></ul></li><li>虚拟：通过某种技术把一个物理实体变为若干个逻辑上的对应物。这样可以避免一个进程单独占用某个物理设备，一个物理设备被分配给多个进程便可以提升物理设备的使用率。</li><li>不确定性（异步性）：进程以人们不可预知的速度向前推进，即为进程的不确定性。这样的话很可能是先进入内存的作业后完成；而后进入内存的作业先完成。尽管如此，但只要有合理的进程同步方式且运行环境相同，作业经多次运行，都会获得完全相同的结果。因此，异步运行方式是允许的。</li></ul><h2 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h2><h3 id="传统操作系统结构"><a href="#传统操作系统结构" class="headerlink" title="传统操作系统结构"></a>传统操作系统结构</h3><ul><li>无结构OS：<ul><li>关注功能的实现和获得高的效率操作系统是为数众多的一组过程的集合，各过程之间可以相互调用，在操作系统内部不存在任何结构。</li><li>程序设计的技巧，只是如何编制紧凑的程序，以便于有效地利用内存。</li><li>操作系统既庞大又杂乱，缺乏清晰的程序结构。</li><li>程序错误很多，给调试工作带来很多困难；另一方面也使程序难以阅读和理解，增加了维护人员的负担。</li></ul></li><li>模块化结构OS<ul><li>模块化程序设计技术，是最早（20世纪60年代）出现的一种程序设计技术。该技术是基于“分解”和“模块”原则来控制大型软件的复杂度的。</li><li>将OS按其功能划分为若干个具有一定独立性和大小的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口， 使各模块之间能通过该接口实现交互，然后再进一步将各模块细分为若干个具有一定管理功能的子模块。（会导致模块之间的依赖关系很重，OS结构不清晰）</li><li>若子模块较大时，再进一步将它细分。</li></ul></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/模块式os结构.jpg"></div><br>- 分层式结构OS：<br>- 改进设计方式，使每一步设计都是建立在可靠的基础上一层一层地自底向上增添软件层，每一层都实现若干功能，最后总能构成一个能满足需要的OS。<br>- 每一层都仅使用其底层所提供的功能和服务，这样可使系统的调试和验证都变得容易。<br>- 一旦发现错误后，通常该错误只会局限于某一层，因为它与所有其高层的软件无关，而此层以下的各层软件，又都经过仔细的调试，bug修复较为容易。<br><br>### 客户/服务器结构<br><br>- 为了提高OS的灵活性和可扩充性而将OS划分为两部分。<br>- 一部分是用于提供各种服务的一组服务器（进程），所有这些服务器（进程）都运行在用户态。当有一用户进程（现在称为客户进程）要求读文件的一个盘块时，该进程便向文件服务器（进程）发出一个请求；当服务器完成了该客户的请求后，便给该客户回送一个响应。<br>- 另一部分是内核，用来处理客户和服务器之间的通信， 即由内核来接收客户的请求，再将该请求送至相应的服务器；同时它也接收服务器的应答， 并将此应答回送给请求客户。<br>- 此外，在内核中还应具有其它一些机构，用于实现与硬件紧密相关的和一些较基本的功能。<br><br>### 面向对象结构（20世纪80年代）<br><br>- 该技术是基于“抽象”和“隐蔽”原则来控制大型软件的复杂度的。所谓对象，是指在现实世界中具有相同属性、服从相同规则的一系列事物的抽象，而把其中的具体事物称为对象的实例。<br>- OS中的各类实体如进程、线程、消息、存储器等，都使用了对象这一概念，相应地，便有进程对象、线程对象、 存储器对象等。<br>- 由于隐蔽了表示实体的数据和操作，因而可以改变对象的表示而不会影响其它部分， 从而可以方便地改变老的对象和增加新的对象。<br>- 继承性。继承性是面向对象技术所具有的重要特性。继承性是指子对象可以继承父对象的属性，这样，在创建一个新的对象时， 便可减少大量的时空开销。<br>- 正确性和可靠性。由于对象是构成操作系统的基本单元，可以独立地对它进行测试，这样，比较易于保证其正确性和可靠性，从而比较容易保证整个系统的正确性和可靠性。<br><br>### 微服务结构（20世纪90年代）<br><br>- 能有效支持多处理机，适用于分布式系统环境。<br>- 以微内核为操作系统核心，以客户/服务器为基础，采用了面向对象的程序设计方法。<br>- 所谓微内核技术，是指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS(程序)不同， 它更小更精炼，它不仅运行在核心态，而且开机后常驻内存， 它不会因内存紧张而被换出内存。<br>- 微内核并非是一个完整的OS， 而只是为构建通用OS提供一个重要基础。<br>- 在微内核OS结构中，通常都采用了客户/服务器模式，因此OS的大部分功能和服务，都是由若干服务器来提供的， 如文件服务器、作业服务器和网络服务器等。<br><br><br><br>## 进程概念<br><br>### 前趋图<br><br>数据结构中的有向无环图。箭头表示进程之间执行的先后关系。结点表示一个程序或一个进程，甚至一条语句。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/前趋图.jpg"></div><h3 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h3><p>不存在前趋关系的程序之间才有可能并发执行。特征：</p><ul><li>间断性：程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系，进而导致并发程序具有“执行-暂停-执行”这种间断性的活动规律。</li><li>失去封闭性：由于资源共享，所以当某程序的运行影响资源的状态时，其他程序的运行环境就会被破坏。</li><li>不可再现性：计算结果与并发程序各自执行速度有关。即同一程序，使用相同输入、在相同环境下运行，却可能获得完全不同的结果。</li></ul><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><p>在多道程序环境下，程序的执行属于并发执行，此时他们将失去其封闭性，并具有间断性，以及运行结果的不可再现性。由此，决定了通常的程序是不能参与并发执行的。为了能使程序并发执行，引入了进程。</p><ul><li>进程实体：程序+数据+进程控制块（Process Control Block，PCB）。</li><li>进程：运行态的进程实体是就是进程，是系统进行资源分配和调度的一个独立单位。<ul><li>PCB是为了使程序能并发执行而诞生的一种数据结构，它用来控制和管理进程。由于数据和程序本来就存在，所以创建/撤销进程也就是创建/撤销PCB。至于如何并发执行，见下面的进程同步。</li><li>区别于作业：进程是程序在数据集上的一次作执行，作业是用户提交给系统的一个任务，包含一个或多个进程。</li></ul></li></ul><h3 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h3><ul><li>动态性：由创建而产生，由调度而执行，由撤销而消亡。</li><li>并发性：进程的重要特征，操作系统的重要特征。</li><li>独立性：独立运行、独立分配资源、独立接受调度。</li><li>异步性：按各自独立、不可预知的速度向前推进。</li></ul><h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><h3 id="PCB中保存的信息"><a href="#PCB中保存的信息" class="headerlink" title="PCB中保存的信息"></a>PCB中保存的信息</h3><ul><li>进程标识符。用于唯一的标识某个进程。<ul><li>外部标识符：不仅可以标识进程，还指明其父进程、子进程以及拥有该进程的用户。</li><li>内部标识符：方便系统使用进程，仅能标识进程。</li></ul></li><li>处理机状态。用于在进程切换时保存处理机中各个寄存器的内容。以便在该进程重新调度时能再从断点执行。</li><li>进程调度信息。<ul><li>进程状态：指明进程的状态，方便进程调度和对换时的依据。</li><li>进程优先级：进程优先级高的更容易获得处理机。</li><li>进程调度所需信息：保存的内容和进程调度算法有关，如进程等待了多久CPU，使用了多长CPU。</li><li>事件：进程因何由执行状态转变为阻塞状态，即阻塞原因。</li></ul></li><li>进程控制信息。<ul><li>程序和数据的地址。</li><li>进程同步的通信机制。</li><li>资源清单。进程已分配到的除处理机之外的资源。</li><li>链接指针。用于指向下一个PCB的首地址。用于进程调度。</li></ul></li></ul><h3 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h3><ul><li>线性方式：所有的PCB都保存在一张表中，每次寻找PCB都在表中查找。效率低。</li><li>链接方式：把具有相同状态的PCB链接起来。</li><li>索引方式：把具有相同状态的PCB保存在相应的表中。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/pcb的组织方式.jpg"></div><h2 id="OS内核"><a href="#OS内核" class="headerlink" title="OS内核"></a>OS内核</h2><h3 id="系统态-amp-用户态"><a href="#系统态-amp-用户态" class="headerlink" title="系统态 &amp; 用户态"></a>系统态 &amp; 用户态</h3><p>对于处理机来说，根据其执行的指令不同，可以将其分成系统态（管态、内核态）和用户态。处理机处于系统态时可以执行任意的指令，访问所有的寄存器和存储区，而处于用户态的时候会受到相应的限制。所以计算机中的程序可以分成系统程序和用户程序，用户程序运行在用户态，这样就可以防止用户程序对操作系统进行破坏。</p><h3 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h3><p>操作系统把CPU指令分成两类：</p><ul><li>特权指令：在系统态执行的指令。执行几乎不受限制，如启动外部设备、设置系统时钟等。</li><li>非特权指令：在用户态执行的指令。限制较多，比如不能操作硬件等。</li></ul><h3 id="内核概念"><a href="#内核概念" class="headerlink" title="内核概念"></a>内核概念</h3><p>现代操作系统采用分层设计模式，不同权重的程序分别设置在不同的层次中。通常与<strong>硬件紧密相关的程序</strong>、<strong>设备驱动程序</strong>和<strong>运行频率高的程序</strong>等放置在高级别层次中，操作系统会将它们常驻内存，这些程序便被称为OS内核。OS内核运行在系统态中。</p><h3 id="内核的功能"><a href="#内核的功能" class="headerlink" title="内核的功能"></a>内核的功能</h3><p>不同操作系统的内核在功能上有一定的差异，但是一般都包含两类功能：</p><ul><li>支撑功能<ul><li>中断处理：是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，且处理完毕后又返回原被暂停的程序继续运行。人机交互、设备驱动和进程调度等都需要依赖中断处理。</li><li>时钟管理：系统中很多活动都需要用到时钟，如定时任务、时间片轮转调度算法等。</li><li>原语操作：原语是若干条机器指令构成的，用以完成特定功能的一段程序。而原语操作便是原语的执行，其在执行期间是不可分割的。</li></ul></li><li>资源管理功能<ul><li>进程管理：进程的创建、撤销、调度等操作。</li><li>存储器管理：空间的分配、撤销、逻辑地址转换为物理地址等。</li><li>设备管理：进行设备分配、缓和CPU和I/O速度不匹配矛盾的缓冲管理等。</li></ul></li></ul><h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><ol><li>为新进程申请内部标识符，同时从PCB集合中索取一个空白的PCB。</li><li>为新进程分配其运行所需的资源。这些资源直接来自操作系统或者父进程。</li><li>初始化PCB。如处理机状态信息、标识符和进程优先级等。</li><li>若就绪队列还能接受进程，则插入就绪队列。不能接受则执行相应处理机制。</li></ol><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><ol><li>从PCB集合中获得某进程的PCB，并读出该进程的状态。<ul><li>若进程正处于执行状态，应立即终止该进程的执行。</li><li>若此进程有子进程则一并终止，防止其成为不可控进程。</li></ul></li><li>将进程拥有的所有资源归还给其父进程或操作系统。</li><li>将被终止的进程从所在队列或链表（指PCB的组织方式）中移出，等待其他程序收集信息，释放空间等。</li></ol><h3 id="三种基本状态"><a href="#三种基本状态" class="headerlink" title="三种基本状态"></a>三种基本状态</h3><ul><li>就绪状态：分配到出处理机之外的其他所有必要资源。此时可运行，但其他进程正在占用CPU。</li><li>执行状态：就绪状态的进程获得CPU，正在执行的状态。</li><li>阻塞状态：进程发出的请求没有及时得到满足而无法继续执行的状态，此时会引起进程调度，OS把处理机分配给其他就绪进程，原进程暂停。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/五种进程状态.jpg"></div><h3 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h3><p>进程暂停执行或不接受调度的状态。原因有如下几点：</p><ul><li>用户的需要：用户想暂停正在的进程，观察其状态或修改程序等。</li><li>父进程请求：父进程为了完成某项任务，协调其各子进程间的活动。</li><li>负荷调节的需要：系统压力过大或实时操作系统不能很好的满足可靠性时会挂起一些进程。</li><li>操作系统的需要：操作系统挂起某些进程来更方便的检查系统资源。<br>挂起和阻塞不同在于阻塞是客观条件不能得到满足，即资源不足引起暂停。挂起是主观需要引起暂停。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/引入挂起的进程状态图.jpg"></div><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>进程同步的主要任务是使并发执行的诸进程之间能有效的共享资源和相互合作，从而使程序的执行具有可再现性。</p><h3 id="同步-amp-互斥"><a href="#同步-amp-互斥" class="headerlink" title="同步 &amp; 互斥"></a>同步 &amp; 互斥</h3><p>并发执行的诸进程之间既有独立性又有制约性。</p><ul><li>独立性：各进程都可独立地向前推进；</li><li>制约性：由于资源共享和进程合作引起的进程之间的相互依赖和相互制约的关系。可归结为互斥和同步。<ul><li>同步：两个或多个事件的发生有着某种时序上的关系。按照这种时序关系进行能保证各任务安全的完成。</li><li>互斥：资源的使用要排它使用，防止冲突（不同时使用，但无先后次序。一种特殊同步）。</li></ul></li></ul><h3 id="临界资源-amp-临界区"><a href="#临界资源-amp-临界区" class="headerlink" title="临界资源 &amp; 临界区"></a>临界资源 &amp; 临界区</h3><ul><li>临界资源：需要被各进程互斥访问的资源。</li><li>临界区：各进程中访问临界资源的代码。<br>若能保证各进程互斥地进入自己的临界区，便可以保证互斥地访问临界资源，进而保证进程同步。常用的方式有硬件同步机制和信号量机制。</li></ul><h3 id="同步准则"><a href="#同步准则" class="headerlink" title="同步准则"></a>同步准则</h3><ul><li>空闲让进：当无进程处于临界区时，应当允许一个进程进入自己的临界区。</li><li>忙则等待：当有进程处于临界区时其他请求就如临界区的进程必须等待。</li><li>有限等待：对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区。</li><li>让权等待：当进程不能进入临界区时，应立即释放处理机避免进程陷入“忙等”的状态。</li></ul><h2 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h2><h3 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h3><p>当进程在临界区执行期间，计算机系统不响应中断，因此不会引发调度，临界资源只会被一个进程占据，这样就不会发生进程同步问题。</p><h3 id="利用Test-and-Set指令实现互斥"><a href="#利用Test-and-Set指令实现互斥" class="headerlink" title="利用Test-and-Set指令实现互斥"></a>利用Test-and-Set指令实现互斥</h3><p>指令的描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TS</span><span class="params">(boolean *lock)</span></span>&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为临界资源设置一个布尔变量<code>lock = false</code>。在进程进入临界区之前利用TS指令测试，如果得到的值为<code>false</code>表示资源未被使用，如果得到的值为<code>true</code>，则一直测试到结果为<code>false</code>。使用TS指令实现互斥描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">while</span> (TS(&amp;lock));</span><br><span class="line">...</span><br><span class="line">lock = <span class="literal">false</span>;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="利用Swap指令实现互斥"><a href="#利用Swap指令实现互斥" class="headerlink" title="利用Swap指令实现互斥"></a>利用Swap指令实现互斥</h3><p>指令描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(boolean *a, boolean *b)</span></span>&#123;</span><br><span class="line">    boolean temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为每个临界资源设置一个全局变量<code>lock=false</code>。每个进程设置一个局部变量<code>key</code>。实现互斥的描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">...</span><br><span class="line">    key = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        swap(&amp;lock, &amp;key);</span><br><span class="line">    &#125;<span class="keyword">while</span>(key != <span class="literal">false</span>)</span><br><span class="line">    critical section;</span><br><span class="line">    lock = <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>关中断：效率低下且不适用于多处理机系统。且其他进行会”忙等“，不符合让权等待。</li><li>TS指令 &amp; Swap指令：其他进行会”忙等“，不符合让权等待。</li></ul><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p>整型信号量是一个用于描述资源数目的整型量（S）。但除了初始化以外，仅能通过两个原子操作来访问。</p><ul><li><p>wait(S)：P操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wait(S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>);</span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>signal(S)：V操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S)&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P操作用于分配资源，V操作用于释放资源。</p></li></ul><h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>整型信号量未遵循让权等待原则。只要<code>S &lt;= 0</code>就会不断的循环。此时需要增加一个进程链表指针链接等待进程。</p><ul><li><p>数据结构的描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;<span class="comment">//资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process_control_block</span> *<span class="title">list</span>;</span><span class="comment">//阻塞队列</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure></li><li><p>wait(S)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    if(S-&gt;value &lt; 0)</span><br><span class="line">    block(S-&gt;list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>signal(S)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">signal(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">    wakeup(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当进程被阻塞时会被加入阻塞对列，资源被满足时唤醒阻塞对列中的某个资源。</p></li></ul><h3 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h3><p>记录型信号量只能解决共享一个临界资源的情况，若有多个临界资源则需要使用多个记录型信号量。但是信号量越多，系统死锁的概率越大，且大量的同步操作会给系统的管理带来麻烦。AND型信号量的思想是一次性分配进程所需的全部资源，如果有一个没有分配成功，则其他所有可能为之分配的资源亦不分配。</p><ul><li><p>Swait(S)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1, S2, ..., Sn)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Si &gt;= <span class="number">1</span> &amp;&amp; ... &amp;&amp; Sn &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            Si--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            把进程阻塞在请求未能得到满足的资源Si所对应的阻塞队列里，同时把进程的程序计数器（放  置CPU下一条要执行的指令地址）放置在本操作的开始处（下一次再调度到此进程，需要再次</span><br><span class="line">            检查所有的资源）。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Ssignal(S)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ssignal(S1, S2, ..., Sn)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            Si++;</span><br><span class="line">            唤醒等待Si资源的阻塞队列。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h3><p>之前的信号量都是一次申请或释放某资源一份，若申请或释放N份资源需要进行N次操作，效率比较低下。此外，当资源数量低于某一下限值时，为了系统安全，就不能再予以分配。所以产生信号量集解决以上问题。描述如下：</p><ul><li><code>Swait(S1, t1, d1, ..., Sn, tn, dn)</code>：当<code>Si &gt;= ti</code>时<code>Si = Si - di</code>。（<code>di &gt;= ti</code>）</li><li><code>Ssignal(S1, d1, ..., Sn, dn)</code>：<code>Si = Si + di</code>。<br>特殊的信号量集：</li><li><code>Swait(S1, d, d)</code>：每次申请d份资源，资源少于d时不分配。</li><li><code>Swait(S, 1, 1)</code>：退化成一般的记录型信号量。</li><li><code>Swait(S, 1, 0)</code>：<code>S &gt;= 1</code>时运行多个进行进入特定区。<code>S &lt;= 0</code>时禁止进程进入特定区。</li></ul><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>直接使用信号量机制会把大量的同步操作分散在各个进程中，这会增加系统死锁的概率并且不方便系统的管理。而管程就是把代表共享资源的数据结构和对共享数据结构的操作（包括同步机制）封装起来以更好的为进程使用。这时所有请求访问共享资源的进程都只能通过管程间接访问，同时管程每次只允许一个进程进入管程。<br>此时的管程可以使用面相对象的操作来完成整型信号量的功能。但是此时无法解决“让权等待”的问题，所以再按照面相对象的思想将<code>block</code>和<code>wakeup</code>操作封装起来来解决这个问题，即构成条件变量。条件变量的操作如下：</p><ul><li><code>condition.wait()</code>：使进程在因某条件不能满足时阻塞在其所对应的条件变量上。</li><li><code>condition.signal()</code>：唤醒因某条件不能满足而阻塞的进程。<br>可以很容易看出来，设置不同的条件变量能使由不同原因等待的进程阻塞在不同的队列中。<br>使用时把<code>signal()</code>操作放在函数/过程的最后，这样保证在唤醒其他进程后本进程能直接退出而不再产生冲突。<br><strong>管程的描述如下：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1、局部数据和条件变量组成管程内的数据结构。</span></span><br><span class="line"><span class="comment">2、过程/函数1~过程/函数k组成管程内的一组过程对管程内的数据结构进行操作。</span></span><br><span class="line"><span class="comment">3、初始化代码：对管程内的数据结构进行初始化。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Monitor monitor_name&#123;</span><br><span class="line">    share variable declartions; <span class="comment">//共享变量说明</span></span><br><span class="line">    condition declarations;<span class="comment">//条件变量说明</span></span><br><span class="line">    &#123;<span class="comment">//管程主体</span></span><br><span class="line">        initialization code;    <span class="comment">//初始化代码</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:<span class="comment">//能被进程调用的过程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Pn</span><span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量的应用"><a href="#信号量的应用" class="headerlink" title="信号量的应用"></a>信号量的应用</h2><h3 id="互斥访问资源"><a href="#互斥访问资源" class="headerlink" title="互斥访问资源"></a>互斥访问资源</h3><p>设某共享资源的信号量是<code>mutex</code>，PA和PB进程并发时需互斥访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">PA()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    ...</span><br><span class="line">        wait(mutex);</span><br><span class="line">        ...</span><br><span class="line">        signal(mutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">PB()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        wait(mutex);</span><br><span class="line">        ...</span><br><span class="line">        signal(mutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用信号量实现前趋关系"><a href="#利用信号量实现前趋关系" class="headerlink" title="利用信号量实现前趋关系"></a>利用信号量实现前趋关系</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/前趋图例题.jpg"></div><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">P1（）&#123;...V(f1);V(f1);V(f1);&#125;</span><br><span class="line">P2（）&#123;P(f1)；... V(f2);&#125;</span><br><span class="line">P3（）&#123;P(f1)；... V(f3);&#125;</span><br><span class="line">P4（）&#123;P(f1)；... V(f4);&#125;</span><br><span class="line">P5（）&#123;P(f2)；... V(f5);&#125;</span><br><span class="line">P6（）&#123;P(f3);P(f4);P(f5);...;&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    semaphore f1=f2=f3=f4=f5=<span class="number">0</span>；</span><br><span class="line">    Cobegin</span><br><span class="line">    P1(); P2();P3(); P4();P5(); P6();</span><br><span class="line">    Coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>在并发时，如果<code>P1</code>的功能代码未执行完，<code>f1</code>为0，每次对<code>f1</code>进行V操作能使<code>P2</code>、<code>P3</code>、<code>P4</code>运行一个。其他亦然。<br><br><br><br>### 生产者—消费者问题<br><br>- 问题描述：多个生产者进程生产产品以供多个消费者消费。通过由n个环形缓冲区构成的缓冲池（循环队列），把多个生产者和多个消费者联系起来。不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未取走的缓冲区中投放产品。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/生产者消费者.jpg"></div><br>- 分析：<br><br>- 任何时刻，只能有一个进程在缓冲区中操作。<br>- 对于“生产者”而言，缓冲区满则应等待。<br>- 对于“消费者”而言，缓冲区空则应等待。<br><br>- 利用记录型信号量解决问题<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;<span class="comment">//in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。</span></span><br><span class="line">item buffer[n];<span class="comment">//缓存区大小为n，地址为[0, n-1]。</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;<span class="comment">//mutex用于互斥访问缓存区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        produce an item nextproducer;</span><br><span class="line">        ...</span><br><span class="line">        wait(empty);<span class="comment">//消耗一个empty，当empty&lt;=0时等待</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        buffer[in] = nextproducer;</span><br><span class="line">        in = (in+<span class="number">1</span>) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(full);<span class="comment">//增加一个full</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(full);<span class="comment">//消耗一个full，当full&lt;=0时等待</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        nextconsumer = buffer[out];</span><br><span class="line">        out = (out+<span class="number">1</span>) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);<span class="comment">//增加一个empty</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        produce();consumer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>- 互斥信号量 &amp; 资源信号量<br>互斥使用的资源设置一个互斥信号量，资源数为1。资源信号量的资源数和资源的意义有关。资源信号量的资源为1时退化成互斥信号量。<br>在使用时互斥信号量的P操作需要紧邻其对应共享资源的临界区使用，否则可能造成同步问题。比如互换上面代码的第8行和第9行之后，若生产者进程和消费者进程都只有一个，且生产者通过了<code>P(mutex)</code>，阻塞在<code>P(empty)</code>，消费者通过了<code>P(full)</code>，阻塞在<code>P(mutex)</code>，此时生产者等待消费者的<code>V(empty)</code>，消费者等待生产者的<code>V(mutex)</code>，发生死锁。而V操作不需要注意顺序。<br><br>- 利用AND型信号量解决问题<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;<span class="comment">//in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。</span></span><br><span class="line">item buffer[n];<span class="comment">//缓存区大小为n，地址为[0, n-1]。</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;<span class="comment">//mutex用于互斥访问缓存区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        produce an item nextproducer;</span><br><span class="line">        ...</span><br><span class="line">        Swait(empty, mutex);<span class="comment">//消耗一个empty，当empty&lt;=0时等待</span></span><br><span class="line">        buffer[in] = nextproducer;</span><br><span class="line">        in = (in+<span class="number">1</span>) % n;</span><br><span class="line">        signal(empty, mutex);<span class="comment">//增加一个full</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(full, mutex);<span class="comment">//消耗一个full，当full&lt;=0时等待</span></span><br><span class="line">        nextconsumer = buffer[out];</span><br><span class="line">        out = (out+<span class="number">1</span>) % n;</span><br><span class="line">        signal(full, mutex);<span class="comment">//增加一个empty</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        produce();consumer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>- 利用管程解决问题<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Monitor monitor&#123;</span><br><span class="line">    item buffer[n];</span><br><span class="line">    <span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    condition notfull, notempty;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="keyword">static</span> <span class="title">put</span><span class="params">(item x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= n)</span><br><span class="line">            cwait(notfull);<span class="comment">//阻塞在队列满的条件下</span></span><br><span class="line">            buffer[in] = x;</span><br><span class="line">            in = (in+<span class="number">1</span>) % n;</span><br><span class="line">            count++;</span><br><span class="line">            csignal(notempty);</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="keyword">static</span> <span class="title">get</span><span class="params">(item &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(count &lt;= <span class="number">0</span>)</span><br><span class="line">                cwait(notempty);<span class="comment">//阻塞在队列空的条件下</span></span><br><span class="line">            x = buffer[out];</span><br><span class="line">            out = (out+<span class="number">1</span>) % n;</span><br><span class="line">            count--;</span><br><span class="line">            csignal(notfull);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    item x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        produce an item in nextproducer;</span><br><span class="line">        monitor.put(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    item x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        monitor.get(x);</span><br><span class="line">        consume the item in nextconsumer;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        produce();consumer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><br>### 哲学家进餐问题<br><br>- 问题描述：五个哲学家坐在圆桌前，每人一份饭，每个哲学家两侧各有一支筷子,只有拿到左右两只筷子才能进餐，哲学家处于吃饭和思考两种状态。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/哲学家进餐.jpg"></div><ul><li><p>分析</p><ul><li>同一时刻一只筷子只能有一个哲学家拿起。</li><li>只有获得两个筷子后才能进餐。</li><li>如果每个哲学家都拿起一只筷子，都饿死。</li><li>并行程度：五只筷子允许两人同时进餐。</li></ul></li><li><p>利用AND型信号量解决问题<br>每次必须拿到两只筷子才能拿起，否则不拿起筷子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Swait(chopstick[i], chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    ...</span><br><span class="line">    Ssignal(chopstick[i], chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><ul><li><p>问题描述：</p><ul><li>写者向共享数据区放数据，读者从共享数据区读数据。</li><li>多个读者可同时读取数据，多个写者不能同时写数据。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/读者-写者.jpg"></div></li><li><p>分析：</p><ul><li>读者进入共享数据区，写者必须等待。</li><li>读者进入共享数据区，读者可以进入。</li><li>写者进入共享数据区，读者必须等待。</li></ul></li><li><p>利用记录型信号量解决问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore readmutex = <span class="number">1</span>, writemutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(readmutex);</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            wait(writemutex);</span><br><span class="line">        readcount++;</span><br><span class="line">        signal(readmutex);</span><br><span class="line">        ...<span class="comment">//read opreation</span></span><br><span class="line">        wait(readmutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            signal(writemutex);</span><br><span class="line">        signal(readmutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(writemutex);<span class="comment">//当写者进入共享数据区，reader会阻塞在</span></span><br><span class="line">        ... <span class="comment">//write operation</span></span><br><span class="line">        signal(writemutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        reader();writer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码分析：<br>最开始并发的时候：</p><ul><li>假如读者先抢到资源，<code>readcount == 0</code>，<code>P(writemutex)</code>，<code>writer()</code>会阻塞在第20行，但其他<code>reader()</code>仍可以运行，只是不会再<code>P(writemutex)</code>。同时每个<code>reader()</code>都<code>readcount++</code>，直到<code>readcount == 0</code>时<code>V(writemutex)</code>，然后<code>writer()</code>才有可能能进入。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。</li><li>假如写者先抢到资源，<code>P(writemutex)</code>，此时<code>readcount == 0</code>，所有<code>reader()</code>阻塞在第7行。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。<br>综上，完成了要求。</li></ul></li></ul><h3 id="读者-写者问题拓展"><a href="#读者-写者问题拓展" class="headerlink" title="读者-写者问题拓展"></a>读者-写者问题拓展</h3><ul><li><p>问题描述：拓展就是又增加一个条件，最多只允许RN个读者同时读。</p></li><li><p>利用信号量集解决问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">semaphore L = RN, mx = <span class="number">1</span>;<span class="comment">//L用来控制访问数，mx控制写者访问时所有读者阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        Swait(L, <span class="number">1</span>, <span class="number">1</span>);<span class="comment">//第RN+1个读者进入时会阻塞</span></span><br><span class="line">        Swait(mx, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//mx &gt;= 1时才可以进入</span></span><br><span class="line">        ...<span class="comment">//read operation</span></span><br><span class="line">        Ssignal(L, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        Swait(mx, <span class="number">1</span>, <span class="number">1</span>; L, RN, <span class="number">0</span>);<span class="comment">//mx &gt;= 1 &amp;&amp; L &gt;= RN时进入</span></span><br><span class="line">        ...<span class="comment">//write operation</span></span><br><span class="line">        Ssignal(mx, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        reader();writer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码分析：<br>最开始并发的时候：</p><ul><li>假如读者先抢到资源，<code>L = L - 1</code>，写者阻塞在第12行，但其他<code>reader()</code>仍可以运行，直至没有读者进程在访问共享数据区。当所有的读者进程都退出时，共享数据区中停留的个进程数都为0，即重新开始。</li><li>假如写者先抢到资源，<code>mx = mx - 1</code>，所有读者进程和其他写者进程都要被阻塞，写者进程退出时，共享数据区中停留的个进程数都为0，即重新开始。</li></ul></li></ul><h3 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h3><ul><li><p>问题描述：一把理发椅，N把等待座位。理发师为理发椅上的顾客理发，没有顾客就在理发椅上睡觉，有一个顾客时需要叫醒理发师，多个顾客时需要在等待座位上等候。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/理发师问题.jpg"></div></li><li><p>分析：</p><ul><li>理发椅上只能有一位顾客。</li><li>等待座位是有限缓冲区。</li><li>只要存在顾客，理发师就不能睡觉。</li></ul></li><li><p>利用记录型信号量解决问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semaphore customer = <span class="number">0</span>, barber = <span class="number">0</span>, mutex = <span class="number">1</span>; <span class="comment">//barber使理发师只能为一个顾客服务</span></span><br><span class="line"><span class="keyword">int</span> waiting = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">barber</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(customer);<span class="comment">//没有顾客的时候理发师睡觉</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        waiting –= <span class="number">1</span>;<span class="comment">//等待的人少一个</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(barber);</span><br><span class="line">        ...<span class="comment">//获得被激活进程的信息并给相应的顾客剪发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    wait(mutex);</span><br><span class="line">    <span class="keyword">if</span>(waiting &lt; CHAIRS)&#123;<span class="comment">//顾客到来的时候，还有座位就进去等待</span></span><br><span class="line">        waiting += <span class="number">1</span>;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(customer);</span><br><span class="line">        wait(barber);</span><br><span class="line">        ...  <span class="comment">//将被激活进程的信息发送给barber()</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        signal(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码分析<br>在最开始并发的时候<code>barber()</code>会等待到有顾客时才醒来。顾客一来就需要访问<code>waiting</code>，所以获得<code>mutex</code>。</p><ul><li>如果位置不够就立即释放<code>mutex</code>。</li><li>如果位置够，就让等待的人加1，再释放<code>mutex</code>。然后顾客人数<code>customer += 1</code>来激活理发师进程。理发师进程激活后会<code>V(barber)</code>，然后等待着的<code>customer()</code>进程争夺资源，争夺到<code>P(barber)</code>的进程将被激活进程的信息发送给<code>barber()</code>，<code>barber()</code>获得被激活进程的信息并给相应的顾客剪发。</li></ul></li></ul><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程之间合作完成工作不仅仅需要有时序关系，还需要进程信息交互，比如刚才的理发师问题中就设计到了信息交互。从概念上说进程通信是指进程之间的信息交换，所以信号量机制本身就涉及到了信息交换，不过我们把这种信息交换叫做低级进程通信，因为其效率低且需要用户大量的干预。真正的进程通信需要满足使用方便且能高效传输大量数据的需求。</p><h3 id="共享存储器系统"><a href="#共享存储器系统" class="headerlink" title="共享存储器系统"></a>共享存储器系统</h3><ul><li>基于共享数据结构的通信方式：诸进程公用某些数据结构来实现进行通信 ，如生产者—消费者问题中的有界缓冲区，属于低级通信方式。</li><li>基于共享存储区的通信方式：在存储器中划出一块共享存储区，诸进程通过对共享存储区中数据的读或写实现通信，此时数据的形式、位置和访问控制仍是进程实现。适用于传输大量数据，属于高级通信。</li></ul><h3 id="管道通信系统"><a href="#管道通信系统" class="headerlink" title="管道通信系统"></a>管道通信系统</h3><p>所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件。向管道提供输入的发送进程（即写进程）以字符流形式将大量的数据送入管道，而接收进程（即读进程），可从管道中接收数据。管道通信系统必须满足以下三个要求：</p><ul><li>互斥：管道的使用必须互斥。因为存数据和取数据可归于写文件的添加和删除。</li><li>同步：写进程把一定数量的数据写入管道后去睡眠，读进程读完后将其唤醒。读进程读空的管道时需要睡眠。</li><li>确定对方存在：如果写进程不存在，读进程就会一直等待。如果读进程不存在，写进程写完数据后也会一直等待，所以通信双方必须同时存在。</li></ul><h3 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a>消息传递系统</h3><p>指进程可以利用一组通信命令（原语）把数据封装在消息中传送，不需要显示的指定共享存储区或数据结构等。它隐藏了通信的细节，也是目前使用最广泛的进程间通信机制。通常有两种实现方式：</p><ul><li>直接通信方式：OS提供原语给进程使用。</li><li>间接通信方式：借助共享中间实体（称为邮箱）完成进程间的通信。<ul><li>和共享存储器系统的区别是进程不再需要指定数据的形式、位置和访问控制等，信箱内部自有实现。</li></ul></li></ul><h3 id="客户机-服务器系统"><a href="#客户机-服务器系统" class="headerlink" title="客户机-服务器系统"></a>客户机-服务器系统</h3><p>前三种都是单机下的通信机制，这种是网络环境中的通信机制。主要有套接字和RPC两种方式。</p><ul><li>套接字：一个套接字是一个通信标识类型的数据结构，包含了通信目的地址、通信端口号、通信的网络协议、进程自身的地址以及对外提供的系统调用等。使用套接字可以在不同主机上的进程建立连接进而进行通信。</li><li>RPC：Remote Procedure Call，它是一个通信协议，可以使本地进程调用其他主机的进程对程序员表现为常规方法调用。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/rpc.jpg"></div><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的由来"><a href="#线程的由来" class="headerlink" title="线程的由来"></a>线程的由来</h3><p>进程解决了程序不能并发执行的问题，但是由于进程是拥有资源的基本单位，所以在创建、撤销和切换时所需的时空开销很大，因为处理机势必要付出更大的代价来保存现场。所以把拥有资源和独立运行两项功能分开，让线程作为独立运行的基本单位，进程作为拥有资源的基本单位。不过线程也拥有一些能保证其独立运行的资源，如TCB。</p><h3 id="TCB（Thread-Control-Block）"><a href="#TCB（Thread-Control-Block）" class="headerlink" title="TCB（Thread Control Block）"></a>TCB（Thread Control Block）</h3><p>所有用于控制和管理线程的信息都会被记录在线程控制块中，通常包含：</p><ul><li>线程标识符：每个线程都有唯一的线程标识符。</li><li>处理机信息：包括程序计数器、状态寄存器、通用寄存器的内容。</li><li>线程运行状态：线程和进程一样也有多种运行状态，就绪、阻塞、运行等。详见<code>103-网络编程</code>。</li><li>优先级：和调度算法有关，优先级越高，得到处理机的机会越大。</li><li>线程专有存储区：用于在线程切换时保存现场状态和保存线程的统计信息。</li><li>信号屏蔽：屏蔽某些发送给线程的信号。</li><li>堆栈指针：线程调用别的过程时需要保存局部变量和返回地址等来供返回时能继续执行。</li></ul><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>线程是为了解决进程调度时过于笨重的问题，所以在不同的环境中实现线程的方式不同。根据内核能否感知到线程的存在可分为内核支持线程（Kernel Supported Threads，KST）和用户级线程（User Level Threads，ULT）。它俩的区别是能否直接调用系统服务，前者可以而后者需要借助中间系统。</p><h3 id="内核支持线程"><a href="#内核支持线程" class="headerlink" title="内核支持线程"></a>内核支持线程</h3><p>若线程是由内核直接调度，线程资源也是保存在内核空间，就可以说此类线程为内核支持线程。此类线程的创建、撤销和切换等操作都是在内核空间完成的，此时线程可以直接调用系统服务。一种可能的实现方式是在创建进程时分配一个任务数据区（Per Task Data Area，PTDA），各个线程的TCB保存在其中即可。不过仅实现内核支持线程的系统对用户进程创建的线程很不友好，每次线程调度处理机都要从用户态转换到核心态。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/内核级线程.jpg"></div><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>用户级线程是指线程虽客观存在但对内核来说是透明的，此时不能再直接调用系统服务，间接调用系统服务需要有中间系统的支持，通常的中间系统有运行时系统和内核控制线程。</p><ul><li><p>运行时系统：把创建线程、撤销线程和线程同步等只能由OS内核完成的操作封装起来作为运行时系统，而运行时系统停留在用户空间供其他进程调用来实现线程调度。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/运行时系统.jpg"></div></li><li><p>内核控制线程：这种线程又被称作轻量进程（Light Weight Process，LWP），它既可以共享进程的资源，又可以使用内核提供的服务。虽然下图中LWP和用户线程是1对1关系，但实际上多个用户级线程可以复用一个LWP，但每个轻型线程都要连接到一个内核线程中。所以此种方式系统需要同时实现内核支持线程。</p></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/内核控制线程.png" width="80%"></div><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>处理机调度是指通过对处理机资源进程的合理分配来提升系统资源的利用率、降低作业周转时间等。但是由于不同操作系统的目标不同，所以处理机调度的策略和目标也不相同。</p><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ul><li><p>高级调度：又称作业调度或长程调度。它的主要功能是根据某种算法决定把外存上处于后备队列中的哪些作业调入内存，并为他们创建进程、分配资源等，然后放入就绪进程队列。主要用于批处理系统，分时系统的实时系统中不设置高级调度。</p></li><li><p>低级调度：又称进程调度或断层调度。它的主要功能是根据某种算法决定让哪些就绪队列获得处理机，并由分配程序将处理机分配给被选中的进程。在批处理系统、实时系统和分时系统中都设置低级调度。</p></li><li><p>中级调度：又称内存调度。它的主要功能是根据某种算法决定将哪些暂时不能运行的进程调至外存等待，当它们具备运行条件且内存又有空闲时再调入内存。这实际上是存储器管理中的对换功能，在下一章再展开介绍，</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/处理机调度层次.jpg"></div></li></ul><h3 id="处理机调度的目标"><a href="#处理机调度的目标" class="headerlink" title="处理机调度的目标"></a>处理机调度的目标</h3><ul><li>共同目标：<ul><li>提升资源利用率：$CPU的利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$。</li><li>公平：每个进程都应获得合理的CPU时间，不发生进程饥饿现象。</li><li>平衡：进程可以分成多个类型，如计算型、I/O型等等。平衡是指系统中不同的设备都能处于忙碌状态。</li><li>策略强制执行：指某些强制型任务，比如安全策略等，即使会造成其他工作的延迟。</li></ul></li><li>批处理系统的目标：<ul><li>平均周转时间短：<ul><li>周转时间：从作业进入系统到作业完成退出系统所用的时间。</li><li>平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NT_i]$</li><li>带权周转时间：作业的周转时间（$T$）和系统为它提供服务的时间（$T_S$）。$W=\frac{T}{T_s}$</li><li>平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NW_i]$</li></ul></li><li>系统吞吐量高：单位时间内系统完成的作业数尽量多。</li><li>处理机利用率高。</li></ul></li><li>分时系统的目标：<ul><li>响应时间快：指终端提交一个请求到主机返回结果至终端的时间短。</li><li>均衡：不同请求的复杂度不同，所以响应时间必定不同，均衡是指响应时间应和请求复杂度相适应。</li></ul></li><li>实时系统的目标：<ul><li>截止时间的保证：对于HRT任务截止时间必须满足要求，SRT也要尽可能满足。</li><li>可预测性：如在观看电影时一般都会连续播放帧，所以请求是可预测的，假如采用双缓冲实现第<code>i</code>帧和第<code>i+1</code>帧并行处理就能提高实时性。</li></ul></li></ul><h2 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h2><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ul><li>作业：比程序更为广泛的概念，不仅包含了通常的程序和数据，还有一份作业说明书。在批处理系统中，是以作业为基本单位从外存调入内存的。</li><li>作业步：在作业运行期间，每个作业都必须经过若干个相对独立。又相互关联的顺序加工步骤才能得到结果。期中每一个加工步骤成为一个作业步。</li></ul><h3 id="作业控制块"><a href="#作业控制块" class="headerlink" title="作业控制块"></a>作业控制块</h3><p>Job Control Block，JCB。是作业在系统中存在的标志。保存了系统对作业进行管理和调度所需的全部信息。如：作业标识、用户名称、用户账号、作业类型（CPU繁忙型、I/O繁忙型、批量型、终端型等）、作业状态、调度信息（优先级、作业运行时间）、资源需求（预计运行时间、要求内存大小等）、已申请到资源的使用情况。</p><h3 id="作业运行的三个阶段"><a href="#作业运行的三个阶段" class="headerlink" title="作业运行的三个阶段"></a>作业运行的三个阶段</h3><ul><li><p>收容阶段：每一个作业进入系统时（即输入到硬盘），便由“作业注册”程序为该作业建立一个作业控制块JCB并把它放入作业后备队列中。</p></li><li><p>运行阶段：后备队列中的作业被选中后，系统会为其分配必要的资源和建立进程，然后将其放入就绪队列。一个作业从第一次进入就绪状态开始到它运行结束前都是处于运行阶段。</p></li><li><p>完成阶段：当作业完成或发生异常而终止时，作业便处于完成阶段，此时系统会撤销进程和资源，并将运行结果通过某种方式输入，如输出到文件中。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/批处理系统调度.jpg"></div></li></ul><h3 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h3><p>First-Come First-served，FCFS。每次调度都是选择一个或多个最先进入队列的作业或进程，为它们分配资源，创建进程和分配CPU，使之投入运行。它是最简单的调度算法，同时也可用于进程调度。效率不高，所以一般不作为主调度算法。</p><p>适用于CPU繁忙型而不适用于I/O繁忙型。因为CPU繁忙型长时间占用CPU很少有I/O操作，一旦获得CPU，就会运行很长时间，就是会长时间占用CPU，而I/O繁忙型由于要频繁访问IO端口，每次访问都要放弃CPU，等I/O访问完后要重新等待下一次调度（此时排到了就绪队列的队尾），所以要等待很久才能重新被调度。因此先来先服务有利于CPU繁忙型而不利于I/O繁忙型。</p><h3 id="短作业优先算法"><a href="#短作业优先算法" class="headerlink" title="短作业优先算法"></a>短作业优先算法</h3><p>Short Job First，SJF。指对短作业优先调度的算法，它从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。</p><p>此种算法对长作业非常不利而且实际使用上很难预估每个作业的运行时间。</p><h3 id="静态优先级调度算法"><a href="#静态优先级调度算法" class="headerlink" title="静态优先级调度算法"></a>静态优先级调度算法</h3><p>为照顾紧迫性作业，使之进入系统后获得优先处理，引入优先级调度算法。按照进程的优先级大小来调度，使高优先级进程得到优先处理的策略称为优先权调度算法。</p><p>静态优先级调度算法是指在输入前作业为其赋予优先级且一直保持不变。虽然可以照顾紧迫性作业，但是没有考虑到作业本身的运行时间和作业的等待时间等，所以产生了更好的动态优先级算法。</p><h3 id="高响应比算法"><a href="#高响应比算法" class="headerlink" title="高响应比算法"></a>高响应比算法</h3><p>高响应比算法是动态优先级算法的一种，其中$优先级 = \frac{响应时间}{要求服务时间} = \frac{等待时间+要求服务时间}{要求服务时间}$。这样可以得到：</p><ul><li>对于短作业：其要求服务时间短，优先级相对较高。</li><li>对于长作业：在等待一段时间之后，其优先级会增长，直至够高而能获得服务。</li><li>对于先来作业：假如在某一时刻其仍未获得服务，和后来的作业相比其优先级相对较高。</li></ul><p>相应时间与周转时间的对比，假如作业运行完了，两者相等，假如没有则 $响应时间&lt;周转时间$</p><ul><li>周转时间：从作业进入系统到作业完成退出系统所用的时间。</li><li>响应时间：等待时间+要求服务时间。</li></ul><h2 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h2><h3 id="进程调度的任务和机制"><a href="#进程调度的任务和机制" class="headerlink" title="进程调度的任务和机制"></a>进程调度的任务和机制</h3><ul><li>保存处理机的现场信息：比如程序计数器、通用寄存器里的内容。</li><li>按某种算法选取进程。</li><li>把处理机分配给进程：把选中进程的PCB中的有关处理机调度的信息装入处理器的寄存器中，把处理器的控制权交给进程使其能从上次的断点处恢复运行。</li></ul><h3 id="进程调度机制"><a href="#进程调度机制" class="headerlink" title="进程调度机制"></a>进程调度机制</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/进程调度机制.jpg"></div><br>- 排队器：每当有进程转入就绪状态时，排队器会将它插入到相应的就绪队列。<br>- 分派器：分派器依据进程调度程序（更直接的说，进程调度算法）所选定的进程，将其从就绪队列中取出。<br>- 上下文切换器：会产生两次上下文切换：<br>- 旧进程和分配程序之间的切换；<br>- 分配程序和新进程之间的切换。<br><br>排队器、分派器、上下文切换器本身也是程序，但是它们是处于系统态的程序，而被调度的进程一般是用户态的程序，从系统态到用户态进行上下文切换需要很大的耗费，所以一般采用两组（或多组）寄存器，一组用于处理机在系统态时使用，一组用于系统在用户态时使用，这样在系统态和用户态之间切换时就可以只改变指针（用于从寄存器中存取数据和指令）使其指向指定寄存器就行。<br><br><br><br>### 进程调度方式<br><br>### 非抢占方式<br><br>一旦某进程获得处理机，就会一直运行下去，直至该进程完成或者因发生某种事件而被阻塞其他进程才能获得处理机。此时引起进程调度的因素：<br><br>- 正在执行的进程运行完毕。<br>- 外部环境的改变使其不能再继续运行，如程序运行发生异常。<br>- 进程通信或进程同步时执行了某种原语，如<code>Block</code>。<br>- 正在执行的进程发出I/O请求。<br><br><br><br>### 抢占方式<br><br>允许调度程序根据某种原则去暂停某个正在执行的进程，将处理机分配给其他进程。这些原则一般有三种：<br><br>- 高优先级原则；<br>- 短进程优先原则；<br>- 时间片原则。<br><br>我们后面所提到的进程调度算法其实都是抢占方式下的策略。<br><br><br><br>## 轮转调度算法<br><br>将CPU的处理时间分成固定大小的时间片q， q的大小从几ms到几百ms。系统将所有就绪进程按先来先服务的原则排成队列。每次调度时，把CPU分配给队首进程，令其执行一个时间片，时间片用完后若进程未结束，则送回就需队列尾部重新调度，在一给定的时间内，就绪进程均能获得一时间片的执行时间。<br><br>此时时间片大小是关键问题，一般来说时间片q正比于响应时间，反比于就绪进程数目。计算机的处理能力。速度快，q可小些。通常q值是这样决定的：<br><br>- 批处理系统:80%的CPU周期在一个时间片内完成<br>- 分时系统：$q=T/N_{max}$，（$T-响应时间上限，N_{max}-最大进程数$）<br><br><br><br>## 优先级调度算法<br><br>### 非抢占式优先级调度算法<br><br>即一旦某个高优先级的进程占有了处理机，就一直运行下去，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件）才让另一高优先级进程运行。主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。<br><br><br><br>### 抢占式优先级调度算法<br><br>任何时刻都严格按照高优先级进程在处理机上运行的原则进行进程的调度。常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。<br><br><br><br>#### 静态优先权<br><br>静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，这些整数被称为优先数。确定优先权大小的依据：<br><br>- 进程类型；<br>- 进程对资源的需求；<br>- 用户要求。<br><br><br><br>#### 动态优先权<br><br>动态优先权是指，在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得<br>更好的调度性能。例如，我们可以规定，在就绪队列中的进程，随其等待时间的增长，其优先权以速率<code>a</code>提高。若所有的进程都具有相同的优先权初值，则显然是最先进入就绪队列的进程，将因其动态优先权变得最高而优先获得处理机，此即<code>FCFS算法</code>。若所有的就绪进程具有各不相同的优先权初值，那么，对于优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机。当采用抢占式优先权调度算法时，如果再规定当前进程的优先权以速率b下降，则可防止一个长作业长期地垄断处理机。<br><br><br><br>## 多队列调度算法<br><br>之前介绍的调度算法都是用一个算法来解决所有的进程调度，这样无法满足系统中不同用户对进程调度策略的不同要求。而多队列调度算法就是将就绪队列从一个分成多个，将不同性质或类型的进程放在不同的就绪队列，这样不同的队列之间设置优先级，和队列内部也可以设置优先级，能更好的满足用户的需求。<br><br>同时在多处理机系统中，可以方便的给每个处理机设置单独的就绪队列。<br><br><br><br>## 多级反馈队列调度算法<br><br>1. 设置多个就绪队列，每个队列赋予不同的优先级，一个队列的优先级最高，第二个队列次之，其余各队列的优先级逐个降低，各队列内部使用FCFS原则排列。<br>2. 优先级越高的进程时间片越短。<br>3. 当一个进程进入内存后，首先放在第一队列的尾部，按FCFS的原则调度，如果该时间片内未结束，进程调度时将此进程转入第二队列队尾，直至第N个对列，若进程仍未结束，在第N个对列上采用时间片轮转算法。<br>4. 仅当第<code>i</code>队列空闲时才调度第<code>i+1</code>队列，如果有新进程进入优先级较高的队列，剥夺CPU执行新进程，旧进程放入原队列尾部。<br><br>此算法不必事先知道各进程执行的所需时间，可满足各种进程需要，是目前公认较好的进程调度算法。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/多级队列反馈调度算法.jpg"></div><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>第<code>i</code>个对列的时间片为$2^{i-1}$。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/多级反馈队列.jpg"></div><h2 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h2><h3 id="保证调度算法"><a href="#保证调度算法" class="headerlink" title="保证调度算法"></a>保证调度算法</h3><p>保证每个进程都获得相同的处理机时间：</p><ol><li>跟踪计算每个进程自创建以来已经执行的时间。</li><li>计算每个进程应该获得的处理机时间，即自创建以来的时间除以n。</li><li>比较各进程获得处理机时间的比率，即实际执行时间除以应获得的处理机时间。</li><li>比较各进程获得处理机时间的比率，如A：0.5；B：0.9；C：1.2。</li><li>调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率，然后把处理机让给此时比率最小的进程。</li></ol><h3 id="公平调度算法"><a href="#公平调度算法" class="headerlink" title="公平调度算法"></a>公平调度算法</h3><p>在上个算法中，如果用户A有4个进程，用户B有1各进程，那用户A获得处理机的时间是用户B的四倍。而公平调度算法的目标是保证每个用户都获得相同的处理机时间。</p><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><p>实时调度必须能满足实时任务对截止时间的要求。所以实时任务的算法和优先级算法有些区别。</p><h3 id="实时算法的分类"><a href="#实时算法的分类" class="headerlink" title="实时算法的分类"></a>实时算法的分类</h3><h4 id="非抢占式调度算法"><a href="#非抢占式调度算法" class="headerlink" title="非抢占式调度算法"></a>非抢占式调度算法</h4><ul><li>非抢占式轮转调度算法；</li><li>非抢占式优先调度算法。</li></ul><h4 id="抢占式调度算法"><a href="#抢占式调度算法" class="headerlink" title="抢占式调度算法"></a>抢占式调度算法</h4><ul><li>基于<a href="https://isjinhao.github.io/2019/%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD/#more">时钟中断</a>的抢占式优先级调度算法：在某实时任务到达后，如果它的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断发生时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先级任务。</li><li>立即抢占式优先级调度算法：一旦出现外部中断，只要当前任务未处于临界区，便立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/实时调度.jpg"></div><br>### 最早截止时间优先算法<br><br>Earliest Deadline First，EDF。可用于非抢占式算法，也可用于抢占式算法。<br><br>#### 非抢占式<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/非抢占式EDF.jpg"></div><br>#### 抢占式<br><br>有两个周期任务，A、B的周期分别是20ms，50ms。A、B的执行时间分别是10ms和25ms。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/抢占式EDF.jpg"></div><br>### 最低松弛度优先即算法<br><br>Least Laxity First，LLF。$松弛度=截止时间-当前时间-任务执行时间$。主要用于抢占式调度。<br><br><br><br>#### 例<br><br>有两个周期任务，A、B的周期分别是20ms，50ms。A、B的执行时间分别是10ms和25ms。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/LLF.jpg"></div><h2 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h2><p>即高优先级进程（或线程）被低优先级（或线程）延迟或阻塞。例，假如有三个完全独立的进程P1、P2和P3，优先级P1&gt;P2&gt;P3。P1和P3通过共享一个临界资源进行交互。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P1：...P(mutex); CS<span class="number">-1</span>; V(mutex);... </span><br><span class="line">P2: ...Program2...;</span><br><span class="line">P3：...P(mutex); CS<span class="number">-3</span>; V(mutex);...</span><br></pre></td></tr></table></figure><p>假如P3最先执行，在执行了P(mutex)操作后，进入临界区CS-3。在时刻a，P2就绪，因为它比P3的优先级高，P2抢占了P3的处理机而运行，在时刻b，P1就绪，因为它比P2的优先级高，抢占处理机执行，但P1执行P(mutex)之后被阻塞，处理机被P2获得，P2执行结束后，P1仍不能进入临界区，处理机被P3获得，等P3退出临界区，P1才能获得处理机。所以本应该高优先级的P1优先执行，但是由于存在临界资源而导致优先级倒置。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/优先级倒置.jpg"></div><h3 id="优先级倒置的解决"><a href="#优先级倒置的解决" class="headerlink" title="优先级倒置的解决"></a>优先级倒置的解决</h3><p>遵循动态优先级继承原则：当高优先级进程P1要进入临界区去使用临界资源，如果已经有一个低优先级进程P3正在使用该资源，此时一方面P1被阻塞，一方面P3继承P1的优先级并一直保持到P3退出临界区。这样做就能保证不会有比P3优先级高但比P1优先级低的进程插进来。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/优先级倒置.jpg"></div><h2 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h2><h3 id="可重用资源和消耗性资源"><a href="#可重用资源和消耗性资源" class="headerlink" title="可重用资源和消耗性资源"></a>可重用资源和消耗性资源</h3><ul><li>可重用性资源：可供用户重复使用多次的资源。特点：<ul><li>互斥访问</li><li>系统中此资源数目相对固定</li><li>系统中大多数资源属于此类</li></ul></li><li>可消耗性资源：临时性资源<ul><li>由进程动态创建和消耗，数目是可以不断变化的，比如信号量、进程通信的信息等。</li></ul></li></ul><h3 id="可抢占性资源和不可抢占性资源"><a href="#可抢占性资源和不可抢占性资源" class="headerlink" title="可抢占性资源和不可抢占性资源"></a>可抢占性资源和不可抢占性资源</h3><ul><li>可抢占性资源：CPU和主存，不会引起死锁。</li><li>不可抢占性资源：只能进程自行释放。如打印机，因为如果打印到一半，打印机被抢占，造成的结果只能是此次打印作废，所以它是不可抢占资源。</li></ul><h2 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h2><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/死锁举例.jpg"></div><h2 id="死锁的起因"><a href="#死锁的起因" class="headerlink" title="死锁的起因"></a>死锁的起因</h2><h3 id="竞争不可抢占性资源引起死锁"><a href="#竞争不可抢占性资源引起死锁" class="headerlink" title="竞争不可抢占性资源引起死锁"></a>竞争不可抢占性资源引起死锁</h3><p>一个资源只能同时被一个进程使用，但是下图P1在获得R1后还去申请R2，同时P2获得R2后还去申请R1，陷入僵局，引发死锁。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/竞争不可抢占资源.jpg"></div><h3 id="竞争可消耗性资源引起死锁"><a href="#竞争可消耗性资源引起死锁" class="headerlink" title="竞争可消耗性资源引起死锁"></a>竞争可消耗性资源引起死锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P1：receive(p3,m3)； send(p2,m1)；</span><br><span class="line">P2：receive(p1,m1)； send(p3,m2)；</span><br><span class="line">P3：receive(p2,m2)； send(p1,m3)；</span><br></pre></td></tr></table></figure><p>如上代码，P1在等待P3给P1发消息，P2在等待P1给它P2发消息，P3在等待P2给P3发消息。造成一个死循环。</p><h3 id="进程推进顺序非法"><a href="#进程推进顺序非法" class="headerlink" title="进程推进顺序非法"></a>进程推进顺序非法</h3><p>在下图中，X轴表示进程P1推进图，Y轴表示进程P2推进图。如果按照4号路线推进，可以看出P1在经过b、d段的执行之后，获得R1，P2在进过a、c、e段的执行之后获得R2。此时如果不加以处理，系统一定会进入死锁状态，因为接下来P1在拥有R1后又去申请R2，P2在拥有R2后又去申请R1。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/进程推进顺序非法.jpg"></div><h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><ul><li>互斥条件：某段时间内，某资源只能由一个进程使用；</li><li>请求和保持条件：进程因请求资源而阻塞时，对已分配给它的资源保持不放；</li><li>不可抢占条件 ：资源在未使用完前，不能被剥夺，由使用进程释放；</li><li>循环等待条件 ：发生死锁时，有向图必构成一环路。</li></ul><h2 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h2><p>共有三类做法：</p><ul><li><p>第一类是预防死锁，也就是破坏死锁产生的条件（破坏其中一个就可以），这样系统就永远不会产生死锁。</p></li><li><p>第二类是死锁避免，死锁产生的根本原因是系统资源分配出现问题，如果能进行合理的资源分配就能避免死锁的发生。</p></li><li><p>第三类是死锁发生后的检测和解除。</p></li></ul><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p>预防死锁是给系统施加一个条件使其永远不可能满足死锁产生的必要条件，但是互斥条件是不能被破坏的条件，所以预防死锁有三类做法：</p><h3 id="破坏“请求和保持”条件"><a href="#破坏“请求和保持”条件" class="headerlink" title="破坏“请求和保持”条件"></a>破坏“请求和保持”条件</h3><p>即进程在请求资源时，它不能持有不可抢占资源。有两种做法：</p><ol><li>所有进程在开始运行之前，一次性的申请其在整个运行过程中的全部资源，如果申请成功，进程便陷入等待。这样进程在运行的时候就不会再发出请求。</li><li>进程在只获得运行初期所需的资源后便开始运行，但是进程在运行过程中需要逐步释放以分配给自己的资源，等初期获得所有资源都被释放后才能请求其他资源。</li></ol><h3 id="破坏“不可抢占”条件"><a href="#破坏“不可抢占”条件" class="headerlink" title="破坏“不可抢占”条件"></a>破坏“不可抢占”条件</h3><p>当进程保持了某些不可被抢占资源，且提出的新需求又不能被满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这种预防策略的代价非常昂贵，比如进程请求的打印机被强制剥夺后，之前的工作等于作废。</p><h3 id="破坏“循环等待”条件"><a href="#破坏“循环等待”条件" class="headerlink" title="破坏“循环等待”条件"></a>破坏“循环等待”条件</h3><p>常见的方法是“资源有序分配”。其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号升序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程，在拥有大编号资源再申请小编号资源时需要释放和小资源编号相等及以上的编号。</p><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>避免死锁讲道理是属于死锁的预防，但是它和预防死锁不同，预防死锁是破坏死锁产生的条件，避免死锁是防止系统进入不安全状态。所以我们就要明白什么是安全状态，它和死锁产生的必要条件有什么区别。</p><h3 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h3><p>安全状态指的是系统能按某种进程推进顺序<code>(P1, P2, …, Pn)</code>为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。此时，序列<code>(P1, P2, …, Pn)</code>为安全序列。如果系统无法找到这样一个序列，则称系统处于不安全状态。</p><p>为什么能找到这样的序列系统就是安全的呢？其实它是一个递推的关系，假如系统在时刻<code>i</code>发起申请资源请求，其此时状态为<code>a</code>，系统会判断它申请成功后是否还能寻找到一个安全序列，如果能找到便可以分配，否则便是系统不安全状态。假如系统申请到了资源，还想发出申请请求，便会再次判断请求成功之后能否找到安全序列，由此递推下去可保证整个系统能避免死锁。</p><h3 id="安全状态和死锁必要条件的区别"><a href="#安全状态和死锁必要条件的区别" class="headerlink" title="安全状态和死锁必要条件的区别"></a>安全状态和死锁必要条件的区别</h3><p>仍以此图为例。假如我们采用的是预防死锁策略中的破坏“请求和保持”条件里的第一个做法，那么推进顺序就不可能为4，因为进程P1在执行的时候需要获取全部资源才能执行。但对于避免死锁来说，系统可以按照4号推进顺序推进到e段和阴影区的交界处，然后进程P2在申请资源R2的时候会去判断分配R2给P2之后系统能否找到安全序列，事实上是找不到的，所以R2便不会分配给P2，这样系统就进入不了阴影区，从而可以避免死锁。</p><p>所以预防死锁和避免死锁的区别是：</p><ul><li>预防死锁是每个进程在执行之前确保其自身不陷入死锁状态，如果每个进程都能不陷入死锁状态，系统便能永远安全。即从单个进程角度静态解决问题。</li><li>但避免死锁是在每一次进行资源分配时判断分配之后是否系统处于安全状态，如果处于安全状态便可分配，否则便不能分配。即从系统整体角度动态解决问题。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/进程推进顺序非法.jpg"></div><br>### 银行家算法<br><br>#### 数据结构<br><br>1. 可利用资源向量$Available$：是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果$Available[j]=K$，则表示系统中现有$R_j$类资源K个。<br>2. 最大需求矩阵$Max$：这是一个$n×m$的矩阵，它定义了系统中$n$个进程中的每一个进程对$m$类资源的最大需求。如果$Max[i, j]=K$，则表示进程$i$需要$R_j$类资源的最大数目为K。<br>3. 分配矩阵$Allocation$：这也是一个$n×m$的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果$Allocation[i,j]=K$，则表示进程i当前已分得$R_j$类资源的 数目为K。<br>4. 需求矩阵$Need$：这也是一个$n×m$的矩阵，用以表示每一个进程尚需的各类资源数。如果$Need[i,j]=K$，则表示进程$i$还需要$R_j$类资源K个，方能完成其任务。<br><br>可得：$Need[i,j]=Max[i,j]-Allocation[i,j]$<br><br><br><br>#### 算法<br><br>设进程$cusneed$提出请求$REQUEST[i]$，则银行家算法按如下规则进行判断。<br><br>1. 如果$REQUEST[cusneed] [i]&lt;= Need[cusneed][i]$，则转2；否则，出错。<br>2. 如果$REQUEST [cusneed] [i]&lt;= Available[i]$，则转3；否则，等待。<br>3. 系统试探分配资源，修改相关数据：<br>1. $Available[i]-=REQUEST[cusneed][i]$;<br>2. $Allocation[cusneed][i]+=REQUEST[cusneed][i]$;<br>3. $Need[cusneed][i]-=REQUEST[cusneed][i]$;<br>4. 系统执行安全性检查算法，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。<br><br>#### 安全性算法<br><br>1. 设置两个工作向量$Work=Available$、$Finish=false$。<br>2. 从进程集合中找到一个满足下述条件的进程$i$，$Finish[i]==false;$$Need[i, j]&lt;=Work[j];$，如找到，执行3；否则，执行4。<br>3. 设进程获得资源，可顺利执行，直至完成，从而释放资源。$Work[i]=Work[i]+Allocation[i,j];$，$Finish[i]=true;$，循环2。<br>4. 如所有的进程$Finish= true$，则表示安全；否则系统不安全。<br><br>#### 举例<br><br>- 假定系统中有五个进程$\lbrace P0, P1, P2, P3, P4\rbrace$和三类资源$\lbrace A,B, C\rbrace$，各种资源的数量分别为10、5、7，在$T0$时刻的资源分配情况如图所示。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/T0.jpg"></div><br>- $T0$时刻的安全性<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/T1.jpg"></div><br>- $P1$请求资源：$P1$发出请求向量$Request1(1,0,2)$，系统按银行家算法进行检查。<br>- $Request_1(1, 0, 2)≤Need_1(1, 2, 2)$<br>- $Request_1(1, 0, 2)≤Available_1(3, 3, 2)$<br>- 系统先假定可为$P1$分配资源，并修改$Available,Allocation_1和Need_1$向量。由此得到的资源变换情况如上上图括号所示。<br>- 再利用安全性算法检查此时系统是否安全。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/T2.jpg"></div><br>- $P4$请求资源：$P4$发出请求向量$Request_4(3,3,0)$，系统按银行家算法进行检查。<br><br>- $Request_4(3, 3, 0)≤Need_4(4, 3, 1);$。<br>- $Request_4(3, 3, 0)&gt;Available(2, 3, 0)$，让$P4$等待。<br><br>- $P0$请求资源：$P0$发出请求向量$Requst_0(0,2,0)$，系统按银行家算法进行检查。<br><br>- $Request_0(0, 2, 0)≤Need_0(7, 4, 3);$<br>- $Request_0(0, 2, 0)≤Available(2, 3, 0);$<br>- 系统暂时先假定可为$P0$分配资源，并修改有关数据，如下图所示。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/T3.jpg"></div><ul><li>进行安全性检查：此时可用资源$Available(2,1,0)$已经不能满足任何进程的需要，进入不安全状态，因此系统不分配资源。</li></ul><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p>在图中找一既非阻塞又非独立的进程节点$P_i$，如顺利，$P_i$可获得所有资源直至运行完毕。消去$P_i$所有的请求边和分配边，即释放占有的所有资源，同理再选下一进程节点$P_{i+1}, …, $若能消去所有的边，那么该图是可完全简化的，否则该图是不可完全简化的。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/死锁的检测.jpg"></div><br>具体做法如下：<br><br>1. 可利用资源向量$Available[]$，它表示了m类资源中每一类资源的可用数目。<br>2. 把不占用资源的进程（向量$Allocation[i]∶= 0$）记入L表中，即$L_i \bigcup L$。<br>3. 从进程集合中找到一个$Request_i≤Work$的进程，做如下处理：<br>1. 将其资源分配图简化，释放出资源，增加工作向量$Work∶ =Work+Allocation_i$。<br>2. 将它记入L表中。<br>4. 若不能把所有进程都记入L表中， 便表明系统状态S的资源分配图是不可完全简化的。 因此，该系统状态将发生死锁。<br><br><br><br>#### 死锁的解除<br><br>死锁解除有多种做法，如下是按代价递减排序的几种。<br><br>1. 撤销所有死锁的进程。<br>2. 将每个进程回退到先前定义的某个检查点，再重新启动所有进程。<br>3. 逐个撤销死锁进程，直至死锁不存在。撤销进程的顺序应是基于某种最小代价原则，每次撤销后，死锁检测算法应该重新检测死锁是否依然存在。<br>4. 剥夺进程P的资源交给进程Q，P同时会退到获得此资源的节点上。<br><br>对于3和4，选择的标准可以如下：<br><br>- 以占用处理器的时间最小；<br>- 以产生的输出少；<br>- 所估计的剩余运行时间最长；<br>- 所占用的资源最少；<br>- 优先权最低。<br><br><br><br>## 存储器的层次<br><br>我们都知道存储器的容量和速度是限制计算机发展的一大原因，人们对存储器的要求需要既快又大，但是这样带来的结果就是存储器的造价非常昂贵，所以不可能在计算机中全部配置既快又大的存储器。所以现代的计算机系统中都配置了多层结构的存储器系统来平衡速度差异问题。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/存储器分级.jpg"></div><br>存储器一般被分成六层，不过在只有前四层属于内存，所以此篇只介绍前四层：<br><br><br><br>### 主存储器<br><br>- 用于保存进程运行时的程序和数据。<br>- 对于微机系统和大中型机，容量为数十MB到数GB；对于嵌入式系统，容量为数十KB到数MB。<br>- CPU从主存读取指令和数据。<br>- CPU与外设交换信息要依托主存。<br>- 为缓解CPU执行指令速度和主存访问速度的矛盾，引入寄存器和高速缓冲。<br><br><br><br>### 寄存器<br><br>- 访问速度做快，完全与CPU协调工作，价格十分昂贵，容量不可能很大。<br>- 长度一般以字为单位。<br>- 对于微机系统和大中型机，可能有几十个甚至上百个；对于嵌入式系统，仅有几个到几十个。<br><br><br><br>### 高速缓冲<br><br>- 容量大于或远大于寄存器，比内存小两到三个数量级左右，从几十KB到几MB。<br>- 访问速度快于主存。<br>- 将主存中经常访问的信息存放在高速缓冲，减少访问主存次数。<br><br><br><br>### 磁盘缓冲<br><br>- 将一部分频繁使用的磁盘数据和信息，暂时存放在磁盘缓冲中，减少访问磁盘次数。<br>- 不是实际存在的存储介质，利用主存的存储空间，暂存从磁盘读出或写入的信息。<br><br><br><br>总结一下：磁盘缓冲是为了解决内存和外存的速度差异而在内存中开辟的一块用于暂存磁盘数据的存储介质。主存储器是保存进程运行时的程序和数据的。寄存器是和CPU速度匹配的存储器，直接给CPU提供数据。虽然CPU是直接从寄存器去取指令和数据，但是寄存器的数据来源最终还是主存储器，所以为了减少访问CPU的次数，产生了高速缓冲来缓和寄存器和主存储器的矛盾。至于为什么能缓和呢？这是由于<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/15572003" target="_blank" rel="noopener">程序局部性原理</a>。<br><br><br><br>## 程序的装入和链接<br><br>用户程序要在系统中运行，必须将它装入内存，其中有三个过程。<br><br>- 编译：由编译程序（Complier）将用户源代码编译成若干个目标模块（Object Module）；<br>- 链接：由链接程序（Linker）将编译后形成的目标模块以及它们所需要的库函数，链接在一起，形成一个装入模块（Load Module）；<br>- 装入：由装入程序(Loader)将装入模块装入内存。<br><br><br><br>### 链接<br><br>链接程序的功能是将经过编译或汇编后得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块。<br><br>#### 静态链接方式<br><br>生成可执行文件时进行链接。主要有两步。<br><br>1. 修改相对地址。<br>2. 变换外部调用符号。<br><br>#### 装入时动态链接<br><br>目标模块是在装入内存时，边装入边链接的。装入时动态链接方式有以下优点：<br><br>- 便于修改和更新。<br>- 便于实现对目标模块的共享。<br><br>#### 运行时动态链接<br><br>将对某些模块的链接推迟到执行时才执行，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存， 把它链接到调用者模块上。<br><br>凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。<br><br><br><br>### 装入<br><br>装入是将一个具有执行资格的模块加载进内存。<br><br>#### 绝对装入方式<br><br>在可执行文件中指定内存地址，装入时直接定位在上述（即文件中记录的地址）内存地址。逻辑地址和物理地址完全相同。<br><br>#### 可重定位装入方式<br><br>编译程序所生成的目标模块中采用逻辑地址，根据当前内存情况，将装入模块装入到适当位置。地址映射是在装入模块装入内存时一次性进行的，即是静态重定位。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/静态重定位.jpg"></div><br>#### 动态运行时装入方式<br><br>静态重定位时程序装入内存后不能移动，而且通常需要占用连续的内存空间。所以与其对应的动态重定位是将地址映射工作推迟到程序真正执行时才进行。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/动态重定位.jpg"></div><h3 id="现代计算机运行过程"><a href="#现代计算机运行过程" class="headerlink" title="现代计算机运行过程"></a>现代计算机运行过程</h3><ul><li><p>预处理</p><ul><li>把存储在不同文件中的源程序聚合在一起。</li><li>把被称为宏的缩写语句转换为原始语句。</li></ul></li><li><p>编译：将高级语言翻译成汇编语言或机器语言。</p></li><li><p>链接</p><ul><li>将多个可重定位的机器代码文件（包括库文件）连接到一起。</li><li>解决外部内存地址（一个文件中的代码会引用其他文件中的数据对象或过程，这些数据对象或过程的地址对于此文件来说就是外部地址）问题。</li></ul></li><li><p>装入</p><p>确定程序在内中的绝对地址（即修改程序起始地址），将修改后的指令和数据放到内存中适当的位置。</p></li></ul><h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>连续分配是指为一个用户程序分配空间的时候，将所有程序装入到一段连续的物理内存中。在早期（20世纪60-80<br>年代）的操作系统中，这种分配内存的方式曾经被广泛的使用。</p><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>这是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。内存分为以下两个分区：系统区和用户区。操作系统使用系统区；应用程序装入到用户区，可使用用户区全部空间。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/单一连续分配.jpg"></div><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>固定分区式分配，是最早使用的一种可运行多道程序的存储管理方式。它将内存空间划分为若干个固定大小的区域，每个分区大小可相同，也可不同。OS占一区，其余每个分区中可以装入一道作业。</p><p>为了便于内存分配，系统需建立一张分区使用表。当有一用户程序要装入时，从表中找出一个能满足要求的、尚未分配的分区分配给该程序，然后修改分区使用表。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/固定分区分配.jpg"></div><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>空闲分区表<ul><li>每个空闲分区占用一个表项。</li><li>分区表的表项中包含分区号、分区始址及分区大小等表目。</li><li>表长不易确定。</li><li>占用额外内存。</li></ul></li><li>空闲分区链表<ul><li>利用各空闲分区自身的单元组成双向链表。</li><li>操作速度较慢。</li></ul></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/动态分区数据结构.jpg"></div><br>#### 分区分配<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/分区分配.jpg"></div><br>#### 分区回收<br><br>- 如果回收区的前后有空闲区，可分为图示三种情况。回收时将空闲区和回收区合并。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/分区回收.jpg"></div><br>- 如果回收区的前后无空闲区，新建一个表项，填写信息插入。<br><br><br><br>#### 分区检索算法<br><br>##### 顺序检索算法<br><br>- 首次适应算法：按各空闲分区首址的升序的方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从头查找，找到符合要求的第一个分区。<br>- 循环首次适应算法：分配空闲空间时，不是从链首（或表头）开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找。<br>- 最佳适应算法：按空闲区大小的升序方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从<br>头查找，找到符合要求的第一个分区。就说明它是最适合的（即最佳的）。<br>- 最坏适应算法：按空闲区大小的降序方法组织，分配时总是取空闲分区表（或空闲分区链）中的第一项，<br>若大小不能满足申请者的要求，则表示系统中无满足要求的空闲区，分配失败；否则分配。<br><br><br><br>##### 索引检索算法<br><br>- 快速适应算法：将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应一种空闲分区类型，并记录其表头指针。空闲分区的分类是根据进程常用的空间大小进行划分，对于其他大小的分区，可以放在一个特殊的空闲区链表中。<br>- 伙伴系统：分区大小均为2的K次幂。假设系统可利用空间容量为$2^m$个字，系统运行过程中，不断划分，将空闲分区根据大小分类。为长度为n的进程分配分区时，首先计算$i$值使得$2^{i-1}≦n≦2^i$。先找大小为$2^i$的分区分配，否则找大小为$2^{i+1}$的分区分配，把$2^{i+1}$分区分成两个$2^i$分区（互称伙伴），一个分配，另一个加入$2^i$的空闲分区链表。分配可能经过多次分割，回收可能进行多次合并。<br>- 哈希算法：根据空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最近分配策略。<br><br>#### 紧凑<br><br>可变式分区也有零头问题。在系统不断地分配和回收中，必定会出现一些不连续的小的空闲区，称为外零头。虽然可能所有零头的总和超过某一个作业的要求，但是由于不连续而无法分配。解决零头的方法是拼接（或称紧凑），即向一个方向（例如向低地址端）移动已分配的作业，使那些零散的小空闲区在另一方向连成一片。分区的拼接技术，一方面是要求能够对作业进行重定位，另一方面系统在拼接时要耗费较多的时间。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/紧凑.jpg"></div><h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>页面：将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。</p></li><li><p>物理块：把内存空间分成与页面相同大小的若干个存储块，称为（物理）块或页框（frame）。</p></li><li><p>页面碎片：由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。</p></li><li><p>页面大小：每一页可进行编址的地址数目。页面大小应该<a href="https://isjinhao.github.io/2019/为什么分页存储管理页面大小是2的n次幂/#more">满足2的n此幂</a>。</p></li><li><p>逻辑地址：</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/分页逻辑地址.jpg"></div></li><li><p>页表：系统为每个进程建一张页表，其在内存的起始地址和长度记录在该进程的PCB中。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/页表.jpg"></div></li><li><p>页表项：页表的每一行。</p></li><li><p>页表项长度：每个页表项占用的编址个数。从逻辑地址那里我们可以看到页号占用了20位，对应的块号也要占用20位，当然块号本身可能不止$2^{20}$个。又由于为了控制对物理块的读写等操作，会在页表项中加上控制字段。如果内存按字节编址，即每个编址可以存储8个二进制位，那么页表项占用的二进制位总数大于内存的字长度。我们需要把一个页表项拆开存放在多个编址后的空间中。</p></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/页表项.jpg" style="width:80%"></div><br>### 地址变换<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/页表基本地址变换.jpg"></div><br>$物理地址=块号+块内地址=F(逻辑地址的页号*页表项长度+页表始址)+业内地址$。<br><br>每次进行地址变换需要访问两次内存，内存速度较慢，所以影响计算机整体性能。<br><br><br><br>### 具有快表的地址变换<br><br>根据程序局部性原理，把最近使用的页表项存放在快表中，下次再进行地址变换时先去快表中查找对应项，如果没找到再去内存中查找，然后把新找到的页表项存放在快表中，如果快表已满，采用某种算法淘汰一份。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/具有快表的页表地址变换.jpg"></div><h3 id="有效访问时间"><a href="#有效访问时间" class="headerlink" title="有效访问时间"></a>有效访问时间</h3><p>设t是访问内存的时间，a是快表命中率，λ是查找快表所需的时间。</p><ul><li>普通地址变换时间：<code>t+t</code></li><li>具有快表的地址变换时间：$ a \ast \lambda + (1-a) \ast (t+\lambda)$。</li></ul><h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><p>对于两级页表，是将页表再进行分页，页面的大小与内存物理块的大小相同。逻辑地址结构可描述如下：</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/两级页表.jpg"></div><h3 id="两级页表地址变换"><a href="#两级页表地址变换" class="headerlink" title="两级页表地址变换"></a>两级页表地址变换</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/两级页表地址变换.jpg"></div><br>可推广至N级页表。<br><br><br><br>### 反置页表<br><br>页表是按每个进程的页号排序，指示出物理块号的位置，反置页表是按物理块号排序，指示出每个页隶属的进程和页号。<br><br>此方法需要为每个进程创建一个外部页表，即将页表建立在外存中。进程进行地址变换时先从反置页表里查找，如果查找不到则去外村中查找，再将查找到的页表项调入内存。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/反置页表.jpg"></div><h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><p>之前的分区管理都是为了更好的利用内存。为了满足程序员在编程上的要求引入了分段管理方式。</p><ul><li><p>方便编程：通常，用户把自己的作业按照逻辑关系划分为若干个段，每个段都是从0开始编址，并有自己的名字和长度。因此，希望要访问的逻辑地址是由段名（段号）和段内偏移量（段内地址）决定的。例如，下述的两条指令便是使用段名和段内地址：其中，前一条指令的含义是将分段A中D单元内的值读入寄存器1；后一条指令的含义是将寄存器1的内容存入B分段的C单元中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD 1，[A] |〈D〉；</span><br><span class="line">STORE 1，[B] |〈C〉；</span><br></pre></td></tr></table></figure></li><li><p>信息共享：在实现对程序和数据的共享时，是以信息的逻辑单位为基础的。比如，共享某个例程和函数。分页系统中的“页”只是存放信息的物理单位（块），并无完整的意义，不便于实现共享；然而段却是信息的逻辑单位。由此可知，为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适应。</p></li><li><p>信息保护：信息保护同样是对信息的逻辑单位进行保护，因此，分段管理方式能更有效和方便地实现信息保护功能。</p></li><li><p>动态增长：在实际应用中，往往有些段，特别是数据段，在使用过程中会不断地增长，而事先又无法确切地知道数据段会增长到多大。前述的其它几种存储管理方式，都难以应付这种动态增长的情况，而分段存储管理方式却能较好地解决这一问题。</p></li><li><p>动态链接：动态链接是指在作业运行之前，并不把几个目标程序段链接起来。要运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段（目标程序）调入内存并进行链接。可见，动态链接也要求以段作为管理的单位。</p></li></ul><h3 id="分段地址"><a href="#分段地址" class="headerlink" title="分段地址"></a>分段地址</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/分段地址.jpg"></div><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/段表.jpg"></div><h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/分段地址映射.jpg"></div><h3 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/分段地址变换.jpg"></div><h3 id="分页和分段的主要区别"><a href="#分页和分段的主要区别" class="headerlink" title="分页和分段的主要区别"></a>分页和分段的主要区别</h3><ul><li>页是信息的物理单位，段则是信息的逻辑单位；</li><li>页的的大小固定且由系统决定，而段的长度不固定，由用户所编写的程序决定；</li><li>分页的地址空间是一维的，而分段的地址空间是二维的。</li><li>分页是系统管理的需要；分段是为了更好满足用户的需要。</li></ul><h2 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h2><p>分段结构具有逻辑上清晰的优点，但它的一个致命弱点是每个段必须占据主存储器的连续区域，于是，要装入一个分段时可能要移动已在主存储器中的信息，为了克服这个缺点，可兼用分段和分页的方法，构成段页式存储管理。每个作业仍按逻辑分段，但对每一段不是按单一的连续整体存放到存储器中，而是把每个段再分成若干个页面，每一段不必占据连续的主存空间，可把它按页存放在不连续的主存块中。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>逻辑地址空间分段，段内分页，内存分块（页框），存储管理的分配单位是：物理块（页框）</li><li>地址结构：段号，页号，页内偏移地址。</li><li>每个作业一张段表，每段一张页表。地址变换：先查段表，再查该段的页表。</li></ul><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/段表地址映射.jpg"></div><h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/段表地址变换.jpg"></div><h2 id="传统存储器的问题"><a href="#传统存储器的问题" class="headerlink" title="传统存储器的问题"></a>传统存储器的问题</h2><p>传统的内存管理方式要求将一个作业全部装入内存才可以运行，由此造成了以下两种情况：</p><ul><li>大作业对内存的要求超出物理内存总容量，致使其无法运行。</li><li>内存由于容量的限制，只能装入少量的作业使其运行，而其它大量作业留在外存。</li></ul><h3 id="解决原理"><a href="#解决原理" class="headerlink" title="解决原理"></a>解决原理</h3><h4 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h4><ol><li>程序执行时， 除了少部分的转移和过程调用指令外，在大多数情况下仍是顺序执行的。</li><li>过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域， 但经研究看出，过程调用的深度在大多数情况下都不超过5。</li><li>程序中存在许多循环结构， 这些虽然只由少数指令构成， 但是它们将多次执行。</li><li>程序中还包括许多对数据结构的处理， 如对数组进行操作， 它们往往都局限于很小的范围内。</li></ol><h4 id="表现两个方面"><a href="#表现两个方面" class="headerlink" title="表现两个方面"></a>表现两个方面</h4><ol><li>时间局限性。如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环。</li><li>空间局限性。一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</li></ol><h4 id="基于局部性原理"><a href="#基于局部性原理" class="headerlink" title="基于局部性原理"></a>基于局部性原理</h4><p>在程序装入时，不必将其全部读入到内存，而只需将当前需要执行的部分页或段读入到内存，就可让程序开始执行。在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统，将相应的页或段调入到内存，然后继续执行程序。</p><h3 id="虚拟存储器定义"><a href="#虚拟存储器定义" class="headerlink" title="虚拟存储器定义"></a>虚拟存储器定义</h3><p>所谓虚拟存储器， 是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、 中、 小型机器和微型机中。</p><h3 id="实现虚拟存储器的条件"><a href="#实现虚拟存储器的条件" class="headerlink" title="实现虚拟存储器的条件"></a>实现虚拟存储器的条件</h3><p>由于一个作业被分成多次地调入内存运行，所以在内存分配时必须采用离散分配方式。同时需要解决以下问题：</p><ul><li>页表（段表）的设计（软件支持）</li><li>程序不在内存时去外存调度需要中断（硬件支持）</li><li>逻辑地址转换为物理地址（软件硬件支持）</li><li>如何给每个进程分配物理块</li><li>一个页（段）进入内存时，淘汰哪个页（段）</li></ul><h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>用于将用户逻辑地址空间变换为内存的物理地址空间。在页表中增加若干项，以便于标志程序或数据的状态。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/页表设计.jpg"></div><br>- 状态位（存在位）P：表示该页是否调入内存。<br>- 访问字段A：用于记录该页在某段时间内被访问的次数。<br>- 修改位M：表示该页在调入内存后是否被修改过。未修改过不必写回外存，修改要写回外存。<br>- 外存地址：该页在外存上的地址，通常是物理块号。<br><br><br><br>### 缺页中断机构<br><br>- 在地址映射过程中，在页表中发现所要访问的页不在内存，则产生缺页中断。操作系统接到此中断信号后，就调出缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使进程继续运行下去。<br>- 如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应页表项目的状态位及相应的内存块号。<br>- 若此时内存中没有空闲块，则要淘汰某页，若该页在内存期间被修改过，则要将其写回外存。<br>- 缺页中断发生在指令执行期间，而通常情况下，CPU是在一条指令执行完后，才检查是否有中断请求到达；一条指令在执行期间，可能产生多次缺页中断。所以硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处，继续执行。<br><br><br><br>### 地址转换机构<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/请求分页地址转换机构.jpg"></div><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="最小物理块数的确定"><a href="#最小物理块数的确定" class="headerlink" title="最小物理块数的确定"></a>最小物理块数的确定</h4><p>最小物理块数：保证进程正常运行所需的最小物理块数。与计算机的硬件机构有关，取决于指令的格式、功能和寻址方式。</p><h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p>在请求分页中，可采取两种分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置<br>换和局部置换（置换范围不同）。于是组合出三种适用的策略：</p><ul><li>固定分配局部置换：分配固定数目的内存空间，在整个运行期间都不改变。如果缺页，则先从该进程在内存的页面中选中一页，进行换出操作，然后再调入一页。</li><li>可变分配全局置换：每个进程预先分配一定数目的物理块，同时OS也保持一个空闲物理块队列。当缺页时，首先将对OS所占有的空闲块进行分配，从而增加了各进程的物理块数。当OS的空闲块全部用完，将引起换出操作。</li><li>可变分配局部置换：系统根据缺页率动态调整各进程占有的物理块数目，使其保持在一个比较低的缺页率状态下。</li></ul><h4 id="物理块分配算法"><a href="#物理块分配算法" class="headerlink" title="物理块分配算法"></a>物理块分配算法</h4><ul><li>平均分配算法：将系统中所有可供分配的物理块，平均分配给各个进程。</li><li>按比例分配算法：按照进程的大小比例分配物理块。</li><li>考虑优先权的分配算法：为了对于紧迫的作业，能够尽快完成。可以将内存的物理块分成两部分，一部分按照比例分配给各进程，另一部分根据进程优先级，适当增加其相应的份额，分配给各进程。</li></ul><h3 id="页面调入"><a href="#页面调入" class="headerlink" title="页面调入"></a>页面调入</h3><h4 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h4><ul><li>提前取页：预先装入主存一页或几页（提前页）。</li><li>请求取页：当用到某页而不在主存时即缺页时取页。</li></ul><h4 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h4><p>外存有两个部分：文件区和对换区。对换区I/O操作速度比文件区相对快一些，因此一般应当尽量使用对换区来调入页面。对于不同情况，采用不同的策略：</p><ul><li>系统有足够的对换空间：全部从对换区调入。</li><li>系统对换空间不足：未修改的从文件区调入，修改的从对换区调入。</li><li>UNIX的调入方式：未运行过的从文件区调入，运行过的放在对换区，允许页面共享。</li></ul><h4 id="页面调入过程"><a href="#页面调入过程" class="headerlink" title="页面调入过程"></a>页面调入过程</h4><ol><li>进程需要的页面不在内存，引起缺页中断</li><li>中断处理程序保留现场环境，转入缺页中断处理程序</li><li>中断处理程序查找页表，得到对应的外存物理块号。如果内存有空闲，则启动磁盘操作，将所缺的页面读入，并修改页表。否则，到4。</li><li>执行置换算法，选出要换出的页面，如果该页修改过，应将其写入磁盘，然后将所缺页调入内存，修改相应表项，将其存在位置为<code>1</code>，并放入快表。</li><li>利用修改后的页表，形成物理地址，访问内存数据。</li></ol><h4 id="缺页率"><a href="#缺页率" class="headerlink" title="缺页率"></a>缺页率</h4><ul><li>假设进程逻辑空间为n页，系统为其分配物理块数为<code>m</code>。</li><li>如果进程运行过程中，访问页面成功次数为S，访问页面失败次数为F，总页面访问次数<code>A=S+F</code>，则进程运行过程中 缺页率<code>f=F/A</code>。</li></ul><p>影响缺页率的主要因素：</p><ul><li>页面大小：页面越大，缺页率越小</li><li>进程所分配物理块数：物理块越多，缺页率越小</li><li>页面置换算法：合理的置换算法能更少将页面调入调出</li><li>程序固有特性：比如做循环操作时，缺页率较低，因为执行的命令都是一系列大致相同的指令。</li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h4><p>所选择的被淘汰页面，将是以后永不使用的， 或许是在最长（未来）时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。这是一种理想情况，是实际执行中无法预知的，因而不能实现。可用作性能评价的依据。</p><p>例：假定系统为某进程分配了三个物理块， 并考虑有以下的页面号引用串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure><p>进程运行时， 先将7，0，1三个页面装入内存。 以后， 当进程要访问页面2时， 将会产生缺页中断。此时OS根据最佳置换算法， 将选择页面7予以淘汰。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/最佳置换算法.jpg"></div><br>#### 先进先出页面置换算法<br><br>选择装入最早的页面被置换。可以通过链表来表示各页的建立时间先后。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/先进先出算法.jpg"></div><br>#### 最近最久未使用置换算法<br><br>选择内存中最久未使用的页面被置换。这是局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/LRU.jpg"></div><br>##### 硬件支持<br><br>- 寄存器：每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，于是寄存器数<br>值最小的是最久未使用页面。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/寄存器LRU.jpg"></div><ul><li><p>栈：一个特殊的栈，每当进程访问某页面时，便把被访问的页面移到栈顶，于是栈底的是最久未使用页面。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/栈LRU.jpg"></div></li></ul><h4 id="最少使用置换算法"><a href="#最少使用置换算法" class="headerlink" title="最少使用置换算法"></a>最少使用置换算法</h4><p>选择到当前时间为止被访问次数最少的页面被置换。</p><ul><li>实现方法1：每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，这样，在最近一段时间内时用最少的页面将是$\sum_{R_i}$最小的页。</li><li>实现方法2：每页设置访问计数器，每当页面被访问时，该页面的访问计数器加1；发生缺页中断时，淘汰计数值最小的页面，并将所有计数清零。</li></ul><h4 id="Clock置换算法"><a href="#Clock置换算法" class="headerlink" title="Clock置换算法"></a>Clock置换算法</h4><p>也称最近未使用算法（NRU, Not Recently Used），它是LRU（最近最久未使用算法）和FIFO的折衷。</p><p>内存中所有页面通过链接指针形成一个循环队列，每页有一个使用访问位，若该页被访问则置1。置换时采用一个指针，从当前指针位置开始按地址先后检查各页，寻找访问位为0的页面作为被置换页。指针经过的访问位为1的页都修改0，最后指针停留在被置换页的下一个页。</p><h4 id="改进Clock置换算法"><a href="#改进Clock置换算法" class="headerlink" title="改进Clock置换算法"></a>改进Clock置换算法</h4><p>由于Clock算法不考虑换出页面时，页面是否修改过的问题。这样在换出的页面如果被修改过的话，则必须做拷回磁盘处理，开销比较大。于是，改进型的Clock算法为每个页又增加了一个修改位。选择页面时，尽量选择既未使用又没有修改的页面。</p><p>访问位A，修改位M有四种不同情形：</p><ul><li>1类(A=0，M=0）既未访问，又没有修改，最佳淘汰页</li><li>2类(A=0，M=1）未访问，但是有修改，效率低的淘汰页</li><li>3类(A=1，M=0）被访问，但没有修改</li><li>4类(A=1，M=1）既被访问，又有修改</li></ul><p>算法：</p><ol><li>指针从当前位置开始，开始第一轮扫描循环队列，寻找A=0且M=0的页面，找到则可换出。</li><li>如果找不到，则开始第二轮扫描，寻找A=0且M=1的页面，并且每经过一个页面时，将其访问位A设置为0。如果找到一个第2类页面，则可换出。</li><li>如果仍旧未找到合适的换出页面，则此时指针回到初始位置，且所有页面其访问位A为0。再转回1继续工作。</li></ol><h4 id="页面缓冲算法"><a href="#页面缓冲算法" class="headerlink" title="页面缓冲算法"></a>页面缓冲算法</h4><p>在请求分页系统中，进程在运行的时候经常会发生页面换进换出的情况。而影响换进换出效率的原因如下：</p><ul><li>页面置换算法：好的页面置换算法能使进程运行中具有较低的缺页率，从而可以减少换进换出的开销。</li><li>写会磁盘的频率。</li><li>读入内存的频率。</li></ul><p>而页面缓存算法就是降低读写磁盘的频率来降低开销。做法如下：</p><ul><li>空闲页面链表：当有一个未被修改的页要换出时，实际上并不将其换出到外存，而是把它们所在的物理块挂在空闲链表的末尾。如果以后某进程请求此页时，便将其从空闲页面链表上取下。</li><li>修改页面链表：和空闲页面链表的功能一样，只是说此链表是存放已修改页面的。</li></ul><p>当链表上挂有足够多的页面时，将它们一齐写入磁盘，这样可以降低读写磁盘的频率。</p><h3 id="访问内存的有效时间"><a href="#访问内存的有效时间" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3><ul><li>被访问页在主存，且相应页表项在快表：$EAT= \lambda +t$<ul><li>查找快表+访问实际物理地址</li></ul></li><li>被访问页在主存，但相应页表项不在快表：$ EAT= \lambda +t + t + \lambda$<ul><li>查找快表+读取页表+读取数据+更新快表</li></ul></li><li>被访问页不在主存：$EAT= \lambda + t + \varepsilon + t + \lambda$<ul><li>查找快表+读取页表+缺页中断处理+读取数据+等新快表</li></ul></li><li>内存的有效访问时间为：$EAT= \lambda + t + (1 - a ) \ast [f \ast ( \varepsilon + \lambda + t)+(1-f) \ast(\lambda+t)]$<ul><li><code>a</code>为命中率，<code>f</code>为缺页率。</li><li>查找快表+访问内存一次+未命中不需要请求缺页访问快表+未命中时不需要请求缺页访问内存+未命中需要请求缺页访问快表+未命中时需要请求缺页访问内存+未命中时需要请求缺页开销。</li></ul></li></ul><h2 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h2><h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>由于只装入一个进程的部分程序和数据便可开始运行，故希望运行更多进程，增加多道程序度。但在多道程序环境下，并不是多道程序的度越高，系统吞吐量越大。当CPU的利用率达到某一峰值后，若继续增加多道程度，将产生“抖动”。</p><p>抖动是指同时运行进程太多，分配给每个进程物理块太少，进程在运行时频繁缺页，必须请求调页，等待页面调进调出的进程增多，磁盘访问时间急剧增加，进程大部分时间用于页面换进换出，处理机利用率急剧下降并趋于0。</p><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>基于程序运行的局部性原理，程序运行时，对页面的访问并不均匀，一段时间仅局限于较少的页面；另一段时间，有可能局限于另一些较少的页面，如果能预知这些页面，并提前调入，将大大减少缺页率工作集，是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。</p><ul><li>方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。</li></ul><p>定义：是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。</p><ul><li>方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。</li></ul><p>工作集$ \omega (t, \Delta) $是二元函数。某进程在时间<code>t</code>的工作集记为$ \omega (t, \Delta) $，其中，$\Delta$为工作集的窗口尺寸。</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><ul><li>窗口大小$\Delta$选择得过小，频繁产生缺页中断。</li><li>窗口大小$\Delta$选择得很大，失去了虚拟存储器的意义</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/工作集.jpg"></div><h3 id="抖动的预防方法"><a href="#抖动的预防方法" class="headerlink" title="抖动的预防方法"></a>抖动的预防方法</h3><ul><li>采取局部置换策略：仅允许进程在自身范围内进行置换，不影响其他进程</li><li>在CPU调度程序中引入工作集算法：调入新作业时，应该检查每个进程在内存中的驻留集是否足够大</li><li><code>L=S</code>准则：<code>产生缺页的平均时间L=系统处理进程缺页的平均时间S</code></li><li>选择暂停的进程：使某些低优先级的进程进程挂起，从而腾出内存空间</li></ul><h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><ul><li>请求分页系统建立的虚拟存储器，是以页面为单位进行换入、换出操作的。</li><li>在请求分段系统中实现的虚拟存储器，以分段为单位进行换入和换出。</li><li>程序在运行之前，只需要装入必要的若干个分段即可运行。当访问的分段不在内存时，可由OS将所缺少的段调入内存。</li></ul><p>使用请求分段存储管理方式可以对动态链接有很好的支持。</p><h3 id="请求段表机制"><a href="#请求段表机制" class="headerlink" title="请求段表机制"></a>请求段表机制</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/段表.jpg"></div><br>- 存取方式：标记本段存取属性。如读R，写W，执行X<br>- 访问字段A：记录本段使用的频繁程度<br>- 修改位：是否在调入内存后做过修改<br>- 存在位：本段是否装入内存<br>- 增补位：该段是否动态增长过<br><br><br><br>### 缺段中断机构<br><br>要有专门的缺段中断处理程序。特点：<br><br>- 指令和操作数必定不会跨越在段边界上。<br>- 由于段的长度是不固定的，处理比缺页系统复杂。<br>- 调入一个段可能要淘汰几个内存中的段。<br><br><br><br>### 请求中断处理<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/请求中断处理.jpg"></div><h3 id="地址中断机构"><a href="#地址中断机构" class="headerlink" title="地址中断机构"></a>地址中断机构</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/地址变换机构.jpg"></div><h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3><h4 id="共享段表"><a href="#共享段表" class="headerlink" title="共享段表"></a>共享段表</h4><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/共享段表.jpg"></div><br>- 共享进程计数：多少进程在使用此段。<br>- 存取控制手段：每个共享段，应为不同进程赋予不同的存取权限。<br>- 断号：同一个共享段在不同进程那有不同的断号。<br><br><br><br>#### 分配<br><br>第一个请求的进程，由系统分配一物理块，调入共享段，设置相关表项信息，并置<code>count=1</code>； 以后的进程，在自己的段表中增加一项，填入共享段的信息，在共享段表项中做<code>count=count+1</code>，填写进程相关信息。<br><br>#### 回收<br><br>1. 做count=count-1；<br>2. 若count=0 ，则该共享段被回收。<br><br>#### 分段保护<br><br>- 越界检查：在进行存储访问时，要将逻辑地址的段号与段表长度进行比较，如果超出则发生越界中断信号；其次，将段内地址与段表中该段的长度进行比较，如果有效才进行转换，否则产生越界中断信号。<br>- 存取控制检查：用于规定对该段的访问权限。通常的访问方式有：<br>- 读：允许用户对该段/页内任何信息或其副本进行读操作。<br>- 写：允许用户修改该段/页内任何信息直至撤消整个段/页。<br>- 执行：用户可以执行该段/页程序，数据段/页除外。<br>- 增加：用户可在段/页的末尾添加信息，但不允许修改已存在于段/页中的信息。<br>- 环保护检查：是一种功能较完善的保护机制。<br>- 思想：将所有的程序分成不同的级别，分别放置在不同的环上。内环（编号小，在内侧）的程序具有高优先权，外环的程序优先权低。<br>- 操作系统核心安排在0环内；重要程序和操作系统服务安排在中间环；一般应用程序安排在外环。<br>- 一个程序可以直接访问在相同环或低优先级环（比自身相对靠外的环）上的数据。<br>- 一个程序访问高优先级（比自己靠内的环）时，通过系统调用方式实现。<br><br><br><br>## IO系统的基本功能<br><br>输入输出系统和OS中的其他部分有很大区别，因为其他部分都是在说计算机接受任务后该怎么运行能又快又可靠的完成任务并把结果输出。而输入输出系统是怎么快速稳定的将任务的需求输入和任务的结果输出。<br><br>又由于输入输出设备种类繁多，比如输入设备中的键盘、鼠标、网卡、摄像头，输出设备中的打印机、音频等。所以输入输出系统被划分很多层次来尽可能屏蔽物理细节。<br><br>- 隐藏物理设备的细节：只需要使用简单的命令就能操作各种具有不同实现的硬件完成相应需求。<br>- 与设备的无关性：用户不需要指定哪些设备完成功能，只需要描述需求，OS会选择一个设备完成功能。<br>- 提高处理机和IO设备的利用率：IO设备之间一般是相互独立的，因此设备之间能够并行操作，所以OS应让处理机和设备之间能并行操作。<br>- 对IO设备进行控制：<br>- 轮询的可编程IO方式。<br>- 采用中断你的可编程IO方式。<br>- 直接存储器访问方式。<br>- IO通道方式。<br>- 确保对设备的正确共享。<br>- 错误处理。<br><br><br><br>## IO软件的层次结构<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/IO软件层次.jpg"></div><br>- 用户层软件：提供设备与用户交互的接口，用户可以使用该层提供的功能直接控制设备。<br>- 设备独立性软件：设备分配，设备保护，设备分配，设备回收，数据缓存等。<br>- 设备驱动软件：发出控制设备的命令。<br>- 中断处理程序：保存被中断的进程的CPU环境，转入相应的中断处理程序仅需处理，处理完毕后再恢复被中断进程的现场，返回到被中断的进程。<br><br><br><br>## IO系统各模块层次视图<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/IO各模块层次视图.jpg"></div><br>- 块设备：输入输出以数据块为单位的设备。如磁盘。<br>- 流设备：字符设备的输入输出，如键盘。<br>- 网络通信接口：网卡。<br><br><br><br>## IO设备和设备控制器<br><br>直接和IO设备对接的是设备控制器。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/IO设备和设备控制器.jpg"></div><br>### 作用<br><br>1. 接收和识别命令（控制寄存器、命令译码器）：设备控制器将CPU送来的命令写入控制器寄存器中，并进行译码。<br>2. 数据交换（数据寄存器）。<br>3. 设备状态的了解和报告（状态寄存器）。<br>4. 地址识别（地址译码器）：系统中的每个设备都有自己的地址段，设备接口电路中有多个寄存器，一个寄存器有唯一的一个地址，每个地址为I/O端口，该地址称为I/O端口地址。设备控制器必须能识别每个设备的地址。<br>5. 数据缓冲：缓冲器。<br>6. 差错控制：差错检测码。<br><br><br><br>### 组成<br><br>- 设备控制器和处理机的接口：用于实现CPU与设备控制器之间的通信。<br>- 设备控制器和设备的接口。<br>- IO逻辑：在一个设备控制器上，可以连一个或多个设备。相应的，在控制器中就有一个或多个设备接口，一个接口连一台设备，控制器中的I/O逻辑根据处理机发来的地址信号，去选择一个设备接口。控制器中的I/O逻辑用来实现对设备的控制。通过接收CPU 发来的命令和地址信息，对所选设备进行控制<br><br><br><br>### CPU如何控制设备控制器<br><br>CPU控制内存时需要指定指令地址、数据地址等。控制设备控制器亦如此，一般有两种控制方式：<br><br>- 利用特定IO指令：利用特殊的IO指令控制设备控制器。<br>- 内存映像IO：不再区分内存和控制器中的寄存器地址。假如有一个地址K，当0&lt;=K&lt;N时被认为是内存地址，K&gt;=N时被认为是寄存器地址。<br><br><br><br>### IO通道<br><br>有了设备控制器之后，CPU便可以操作控制器完成对IO设备的控制，但是此时数据交换仍然需要CPU的全程参与，所以引入IO通道来使数据传送、IO设备的组织管理等都独立于CPU。<br><br>通道是独立于CPU的专门负责数据输入/输出传输工作的处理机，对外部设备实现统一管理，代替CPU对输入/输出操作进行控制，从而使输入，输出操作可与CPU并行操作。通道执行通道程序来控制IO操作。与CPU的区别：<br><br>- 通道程序指令类型单一<br>- 通道没有自己的内存，通道程序在主机的内存中，即通道与CPU共享内存。<br><br><br><br>#### 字节多路通道<br><br>主要连接以字节为单位的低速IO设备。如打印机，终端。<br><br>- 按字节交叉方式工作的通道。通常含有许多非分配型子通道，其数量从几十个到数百个，每一个子通道连接一台I/O设备。这些子通道按时间片轮转方式共享主通道。<br>- 字节多路通道以字节为单位传输信息，它可以分时地执行多个通道程序。当一个通道程序控制某台设备传送一个字节后，通道硬件就控制转去执行另一个通道程序，控制另一台设备传送信息。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/字节多路通道.jpg"></div><br>#### 数组选择通道<br><br>主要连接磁盘，磁带等高速I/O设备<br><br>选择通道是按数组方式进行数据传送，每次传送一批数据，故传送速度很高。<br><br>选择通道在一段时间内只能执行一个通道程序，只允许一台设备进行数据传输。当这台设备数据传输完成后，再选择与通道连接的另一台设备，执行它的相应的通道程序。这种独占性又使得通道利用率很低。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/数组选择通道.jpg"></div><br>#### 数组多路通道<br><br>主要连接高速设备。<br><br>- 结合了数组选择通道传送速度高和字节多路通道能进行分时并行操作的优点。它先为一台设备执行一条通道指令，然后自动转接，为另一台设备执行一条通道指令。它含有多个非分配型的子通道，既有很高的数据传输率，又能获得令人满意的通道利用率<br>- 对通道程序采用多道程序设计的硬件实现<br>- 可以连接多台高速设备，数据传输按数组方式，一段时间内可以执行多道通道程序<br><br>#### 解决瓶颈<br><br>通道执行通道程序，向控制器发出命令，并具有向CPU发中断信号的功能。一旦CPU发出指令，启动通道，则通道独立于CPU工作。但是，由于通道价格贵，通道数量少，往往使之成为IO的“瓶颈”。解决办法是在不增加通道的前提下，增加设备到主机间的通路，一个通道可连接多个控制器，一个控制器可连接多个设备，形成树形交叉连接。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/解决瓶颈.jpg"></div><br>## 中断机构和中断处理程序<br><br>### 中断的理解<br><br>说到中断还不得不从现代操作系统的特性说起，无论是桌面PC操作系统还是嵌入式都是多任务的操作系统，而很遗憾，处理器往往是单个的，即使在硬件成本逐渐下降，但处理器的数量依然不可能做到每个任务一个CPU，所以CPU必须作为一种全局的资源让所有任务共享。即什么时候给任务A用，什么时候给任务B用……这就是进程调度，具体的安排就由调度算法决定了。<br><br>进程如何去调度？现代操作系统一般都是采用基于时间片的优先级调度算法，把CPU的时间划分为很细粒度的时间片，一个任务每次只能时间这么多的时间，时间到了就必须交出使用权，即换其他的任务使用。这种要看操作系统的定时器机制了。那么时间片到之后，系统做了什么呢？这就要用到我们的中断了，时间片到了由定时器触发一个软中断，然后进入相应的处理历程。当然这一点不足以表明中断的重要，计算机操作系统自然离不开外部设备：鼠标、键盘、网卡、磁盘等等。就拿网卡来讲，我计算机并不知道时候数据包会来到，我能保证的就是数据来了我能正常接收就行了。但是我又不可能一直等着接收数据包，要是这样其他任务就死完了。所以合理的办法是，你数据包来到之后，通知我，然后我再对你处理，怎么通知呢？？答：中断！键盘、鼠标亦是如此！<br><br><br><br>### 中断的定义<br><br>指处理机处理程序运行中出现的紧急事件的整个过程.程序运行过程中，系统外部、系统内部或者现行程序本身若出现紧急事件，处理机立即中止现行程序的运行，自动转入相应的处理程序（中断服务程序），待处理完后，再返回原来的程序运行，这整个过程称为程序中断。可分为两类：<br><br><br><br>#### 硬中断（Hardware Interrupt）<br><br>- 外部中断：一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断是可屏蔽的。<br>- 内部中断是指因硬件出错（如突然掉电、奇偶校验错等）,或运算出错（除数为零、运算溢出、单步中断等）所引起的中断，内部中断是不可屏蔽的。<br><br>#### 软中断（Software Interrupt）<br><br>软中断是利用硬中断的概念，用软件方式进行模拟，实现宏观上的异步执行效果。很多情况下，软中断和”信号”有些类似，同时，软中断又是和硬中断相对应的，硬中断是外部设备对CPU的中断，软中断通常是硬中断服务程序（模拟硬件发出中断的程序）对内核的中断，信号则是由内核（或其他进程）对某个进程的中断。<br><br><br><br>### 时钟中断<br><br>在Linux的0号中断是一个定时器中断。在固定的时间间隔都发生一次中断，也是说每秒发生该中断的频率都是固定的。该频率是常量HZ，该值一般是在100 ~ 1000之间。该中断的作用是为了定时更新系统日期和时间，使系统时间不断地得到跳转。另外该中断的中断处理函数除了更新系统时间外，还需要更新本地CPU统计数。若进程的时间片递减到0，进程则被调度出去而放弃CPU使用权。<br><br>Linux的OS时钟的物理产生原因是可编程定时/计数器产生的输出脉冲，这个脉冲送入CPU，就可以引发一个中断请求信号，我们就把它叫做<code>时钟中断</code>。<br><br><code>时钟中断</code>是特别重要的一个中断，因为整个操作系统的活动都受到它的激励。系统利用时钟中断维持系统时间、促使环境的切换，以保证所有进程共享CPU；利用时钟中断进行记帐、监督系统工作以及确定未来的调度优先级等工作。可以说，<code>时钟中断</code>是整个操作系统的脉搏。<br><br><br><br>## 设备驱动程序<br><br>### 功能<br><br>1. 接受设备独立性软件发来的命令和参数，将接收到的抽象要求转换为具体要求<br>2. 检查用户IO请求的合法性，了解IO设备的状态，传递有关参数，设置设备的工作方式<br>3. 发出IO命令，如果设备空闲，启动IO设备完成指定的IO操作；如果设备忙碌，则将请求挂在设备队列上等待<br>4. 及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。<br>5. 对于设置有通道的计算机系统，驱动程序还应能够根据用户的IO请求，自动地构成通道程序。<br><br><br><br>### 特点<br><br>1. 驱动程序主要是在设备无关性软件和设备控制器之间的一个通信程序<br>2. 驱动程序与IO设备特性密切相关：通常由硬件厂商提供<br>3. 驱动程序与I/O控制方式密切相关:中断驱动和DMA方式<br>4. 驱动程序与硬件相关,部分代码需用汇编语言编写<br>5. 驱动程序应允许可重入<br><br><br><br>### 处理过程<br><br>1. 将抽象要求转换为具体要求<br>1. 通常设备控制器中都有若干个寄存器，分别用于暂存命令、数据和参数等；<br>2. 用户及上层软件对设备控制器的具体情况毫无了解，因而只能向它们发出抽象的要求(命令)，但不能直接传送给设备控制器。需要将抽象要求转换为具体要求(命令码，数据，参数)。例如，将抽象要求中的盘块号转换为磁盘的盘面、磁道号及扇区。这一转换工作只能由驱动程序来完成；<br>3. 在OS中只有驱动程序才同时了解抽象要求和设备控制器中的寄存器情况；也只有它才知道命令、数据和参数应分别送往哪个寄存器。<br>2. 检查IO请求的合法性<br>3. 读出和检查设备的状态<br>4. 传送必要的参数，设置工作方式<br>5. 启动I/O设备<br>1. 在完成上述准备工作后，驱动程序可以向控制器中的命令寄存器传送相应的控制命令<br>2. 对于字符设备，若发出的是写命令，驱动程序将把一个数据传送给控制器；若发出的是读命令，则驱动程序等待接收数据，并通过从控制器中的状态寄存器读入状态字的方法，来确定数据是否到达。<br>3. 驱动程序发出IO命令后，基本的IO是在设备控制器的控制下进行的，通常IO操作所要完成的工作较多，需要一定的时间，如读/写一个盘块中的数据，此时，驱动程序进程把自己阻塞起来，直至中断到来时才将它唤醒。<br><br><br><br>### 对IO设备的控制方式<br><br>#### 使用轮询的可编程I/O方式<br><br>CPU发出启动外设的I/O指令，同时将忙/闲标志置为1。如果外设的工作没有完成，则标志一直为1，CPU不断循环检测该标志，直到标志为不忙为止。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/轮询可编程.jpg"></div><br>#### 使用中断的可编程I/O方式<br><br>CPU设定I/O设备的初始值，然后不再忙等待，运行其他进程，当前进程阻塞；I/O设备完成对当前数据的处理后，向CPU发出中断，I/O中断处理程序将负责传送剩余数据。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/中断可编程.jpg"></div><br>#### 直接存储器访问(DMA)方式<br><br>采用中断驱动IO方式时的CPU，是以字为单位进行干预的。如果将这种方式用于块设备的I／O，是极其低效的。如：为了从磁盘中读出1KB的数据块；需要中断1K次CPU。而DMA方式使用独立的DMA控制器代替CPU的工作，I/O设备与DMA通信，DMA在传输完成一个数据缓冲区之后再向CPU发中断。<br><br>- 数据传输的基本单位是数据块，即CPU与IO设备之间，每次传送至少是一个数据块，主要用在块设备的IO操作中。<br>- 在DMA方式中，利用总线直接连接外设和内存，由DMA控制机构窃取总线占有权，完成外设与内存间的成批数据交换。所传送的数据是从设备直接送入内存的，或者相反。<br>- 仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的，不再需要CPU进行干预。<br><br>#### I/O通道控制方式<br><br>使用DMA方式，CPU每发出一条I/O指令，只能读写一个连续的数据块。如果需要一次去读多个离散的数据块且将它们分别送到不同的内存区域，则需要CPU分别发出多条I/O指令及进行多次中断处理，才能完成。<br><br>而IO通道可实现CPU、通道和I/O设备三者的并行操作，进一步提高CPU与外设之间的并行工作能力，使I/O操作形成独立于CPU的体系，减少CPU的负担，使外设与内存的数据交换更加灵活，从而更有效地提高整个系统的资源利用率。<br><br><br><br>## 与设备无关的I/O软件<br><br>为了便于对外设进行管理，系统对每台进入计算机系统中的设备都给定一个对应的编号，作为调用时识别和区分设备用。这种编号无任何重复，一般被称为设备的绝对号（或物理设备名）。早期操作系统，应用程序直接使用物理设备名称，非常不灵活。所以引入逻辑设备名，规定用户申请外设时，只需要向系统说明所需用的某类设备真正在实际中使用哪台设备，由系统根据这类设备的应用情况作出分配。<br><br><br><br>### 设备分配<br><br>在多道程序环境下，设备不允许用户自行使用，而必须由系统分配。对于进程的IO请求，只要是安全（无死锁），设备分配程序便按照一定的策略进行设备分配。数据结构：<br><br>- 系统设备表SDT：System Device Table。<br><br>- 整个系统中只有一张，全面反映了系统中的外设资源的类型、数量、占用情况等。<br>- 在SDT表中，每个接入系统中的外围设备都占有一个表目项。登录了该设备的名称、标识、设备控制表DCT的入口地址、设备驱动程序的入口地址及占用设备的进程名称等相关信息。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/SDT.jpg"></div><ul><li><p>设备控制表DCT ：Device Control Table。每台设备都有一张设备控制表DCT，用于记录本设备的情况。</p><ul><li>Type：设备类型</li><li>Deviceid:设备标识符</li><li>设备队列队首指针</li><li>设备状态：标识设备忙或者空闲；</li><li>与设备连接的控制器表指针。</li><li>重复执行次数</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/DCT.jpg"></div></li><li><p>控制器控制表COCT：Controller Control Table。每个控制器都有一张，用于记录某控制器的使用分配情况及与该控制器相连的通道的情况。</p><ul><li>控制器号：控制器的内部标识符。</li><li>控制器状态：控制器忙/闲，好/坏的状态标志。</li><li>通道指针：指向与该控制器相联的通道控制表CHCT，当控制器与若干通道连接时该项内含多个指针。</li><li>等待队列指针：指向等待该控制器的I/O进程队列</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/COCT.jpg"></div></li><li><p>通道控制表CHCT：Channel Control Table。反映了通道的情况，系统中的每个通道一张CHCT。</p><ul><li>通道号：通道内部标识符</li><li>通道状态：通道的各种状态（好/坏，已分/未分等）的反映</li><li>等待队列指针：等待该通道的I/O进程队列的首位置</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/CHCT.jpg"></div></li></ul><h3 id="设备分配算法"><a href="#设备分配算法" class="headerlink" title="设备分配算法"></a>设备分配算法</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/设备分配算法.jpg"></div><h2 id="用户层的I-O软件"><a href="#用户层的I-O软件" class="headerlink" title="用户层的I/O软件"></a>用户层的I/O软件</h2><h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>用户层软件必须使用一组系统调用来取得操作系统服务，在高级语言中都提供了相应的库函数来完成此功能。</p><h3 id="SPOOLing程序"><a href="#SPOOLing程序" class="headerlink" title="SPOOLing程序"></a>SPOOLing程序</h3><p>多道程序技术将一台CPU虚拟为多台CPU，从而可以提高CPU的利用率。而SPOOLing系统是模拟脱机输入输出系统来实现多个用户共享一台物理IO设备。</p><ul><li>脱机输入输出系统的IO处理机 对应 SPOOLing程序。</li><li>脱机输入输出系统的高速缓冲 对应 内存。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/SPOOLing.jpg"></div><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><h3 id="单缓冲区"><a href="#单缓冲区" class="headerlink" title="单缓冲区"></a>单缓冲区</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/单缓冲区.jpg"></div><h3 id="双缓冲区"><a href="#双缓冲区" class="headerlink" title="双缓冲区"></a>双缓冲区</h3><p>为输入或输出分配两个缓冲区，让两个缓冲区交替工作，形成并行操作的方式。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/双缓冲.jpg"></div><h3 id="环形缓冲区"><a href="#环形缓冲区" class="headerlink" title="环形缓冲区"></a>环形缓冲区</h3><ul><li>空缓冲区R：用于存放数据（指针：Nexti）</li><li>已装满数据的缓冲区G：其中的数据提供给进程使用。（指针：Nextg）</li><li>现行工作缓冲区C：当前进程使用的缓冲区。（指针：Current）</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/环形缓冲.jpg"></div><h2 id="磁盘存储器的性能和调度"><a href="#磁盘存储器的性能和调度" class="headerlink" title="磁盘存储器的性能和调度"></a>磁盘存储器的性能和调度</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/磁盘.jpg"></div><br>当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头（又叫磁头）下通过，就可以进行数据的读/写了。<br><br>一般磁盘分为固定头盘（磁头固定）和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。<br><br>活动头盘 （如上图）的磁头是可移动的。每一个盘面上只有一个磁头（磁头是双向的，因此正反盘面都能读写）。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的（行动整齐划一）。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。<br><br><br><br>### 磁盘访问时间<br><br>1. 寻道时间$T_s$：$T_s = s$<br>2. 旋转延迟时间$T_τ$：$T_t = \frac{1}{2r}$<br>3. 磁盘访问时间 ：$T_t=\frac{b}{rN}$<br><br>$s$是指磁头从当前位置定位到开始点的时间，$b$是传输的字节数，$r$是每秒的转数，$N$是一条磁道上的字节数。$总时间 = T_s + \frac{1}{2r} + \frac{b}{rN}$<br><br><br><br>### 磁盘调度算法<br><br>假设磁盘访问序列：98，183，37，122，14，124，65，67，读写头起始位置：53。<br><br>#### 先来先服务<br><br>按访问请求到达的先后次序服务。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/先来先服务.jpg"></div><br>#### 最短寻道时间优先<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/最短寻道.jpg"></div><br>#### 扫描算法<br><br>当设备无访问请求时，磁头不动；当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/扫描算法.jpg"></div><br>#### 循环扫描算法<br><br>CSCAN算法规定磁头单向移动，例如由里向外移动，当磁头移到最外的磁道并访问后磁头立即返回到最里的欲访<br>问磁道，即最小磁道号紧接最大磁道号构成循环，进行循环扫描。<br><br><br><br><br><br>## 文件管理概述<br><br>计算机中有很多的程序和数据都是保存在外存中，在需要使用的时候才调入内存中。而如何保存这些信息是很重要的问题，因为不同类型的文件存储的数据格式不同，但这些格式却必须“迎合”硬件只能存储二进制数据的硬性条件。所以操作系统提供了文件管理的功能，让使用者能在不了解文件特性和外存特性的情况下完成文件的存储和查找等功能。同时还提供了文件共享和安全管理等功能。<br><br><br><br>### 文件系统 &amp; 文件<br><br>操作系统中负责管理和存储文件信息的软件称为文件管理系统，简称文件系统。包含：文件系统的接口，对对象操纵和管理的软件集合，对象及属性三部分。它负责对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。包含创建文件、删除文件等功能。<br><br>文件是指具有文件名的若干相关元素的集合，可以分成有结构文件和无结构文件，无结构文件可以看成一个字符流。有结构文件是由一组记录的集合，记录又是一组数据项的集合。<br><br>- 数据项：用来描述一个对象的某种属性的字符集。例如学生的学号、姓名等。<br>- 记录：一组数据项的集合，用来描述一个对象在某方面的属性，例如学生的成绩。能唯一标识一个记录的一个或多个数据项叫做关键字。<br><br><br><br>### 文件类型<br><br>不同的文件类型由于本身存储的信息具有不同的结构，在管理的时候也是不同。所以文件会被分成很多类型，下面是常用的文件分类方法：<br><br>- 按用途分类：系统文件、库文件、用户文件。<br>- 按文件中数据的形式分类：源文件、目标文件、可执行文件。<br>- 按存储控制属性分类：可读、可写、可执行文件。<br>- 按组织形式和处理方法分类：普通文件、目录文件、特殊文件。<br><br><br><br>### 剖析文件和目录<br><br>我们刚才在定义中说道，文件是指具有文件名的若干相关元素的集合，在有结构文件中这些元素是数据项集合的集合，在无结构文件指的是字符流。所以文件的概念中本身是：<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/文件.png"></div><h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p>文件系统从底层到高层可分成三部分：对象及其属性、对对象操纵和管理的软件集合、文件系统接口：</p><ul><li>对象及其属性：文件管理系统管理的文件如下：<ul><li>文件：在文件管理系统中有着各种不同类型的文件，它们都作为文件管理的直接对象。</li><li>目录：用于对文件的存储和检索，目录的每个目录项包含了一个文件或目录的信息。</li><li>磁盘存储空间：文件和目录必定占用存储空间，对这部分空间的有效管理不仅能提高外存的利用率，而且能提高对文件的存取速度。</li></ul></li><li>对对象操纵和管理的软件集合：该层是文件管理系统的核心部分。文件系统的功能大多是在这一层实现的。如：文件存储的管理、文件目录的管理、将文件的逻辑地址转换为物理地址的机制、文件读写控制的管理、文件的共享和保护等功能。这些功能被可分为四层：<ul><li>I/O控制层：文件系统的最底层、主要由磁盘驱动程序等组成。</li><li>基本文件系统层：主要用于处理内存和磁盘之间数据块的交换。</li><li>基本I/O管理程序：完成与磁盘I/O有关的事务，如将文件的逻辑块号转换为物理块号、管理磁盘中的空闲盘块、I/O缓冲的指定等。</li><li>逻辑文件系统：管控对文件的操作，如控制用户或应用程序对文件的读写等。</li></ul></li><li>文件系统的接口：操作系统提供给用户或应用程序用来使用文件系统的接口：<ul><li>命令接口：用户与文件系统直接交互的接口，如Shell命令。</li><li>程序接口：应用程序可以通过一系列命令调用文件系统的服务。</li></ul></li></ul><h2 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h2><p>当用户要求对一个文件实施多次读/写操作时，如果每次都检索目录效率较低，所以为了避免多次重复的检索目录，OS提供了“打开（Open）”操作，当此操作被执行时，OS会把被打开文件的信息存为“打开文件表”的一个条目，然后把这个条目编号返回用户，这样用户就可以通过这个编号和文件之间建立一个连接，也就可以进行文件的读写等操作。当用户再次向系统发出请求时，把这个编号提交给OS，OS通过这个编号在打开文件表中查找文件信息就可以减少检索时间。而关闭就是OS从“打开文件表”上删除此条目，这样断开了用户和文件之间的连接。</p><h2 id="文件的逻辑结构和物理结构"><a href="#文件的逻辑结构和物理结构" class="headerlink" title="文件的逻辑结构和物理结构"></a>文件的逻辑结构和物理结构</h2><ul><li>逻辑结构：从用户的角度来看，文件是能被存取的基本单位。</li><li>物理结构：文件在磁盘上存储时的组织形式。</li></ul><h3 id="逻辑文件按结构分类"><a href="#逻辑文件按结构分类" class="headerlink" title="逻辑文件按结构分类"></a>逻辑文件按结构分类</h3><ul><li>有结构文件：每个文件用于描述实体集中的一个实体。每个记录的长度对OS来说都是可知的。但记录之间可以分为定长和变长两种。<ul><li>定长记录：所有记录的长度都是相同的、所有记录中的各数据项都处在记录中相同的位置具有相同的顺序和长度。</li><li>变长记录：各记录的长度不相同。比如论文的摘要可能长度差距很大，不能在存储之前估计出所需要的空间。</li></ul></li><li>无结构文件：系统中运行的大量的源程序、可执行文件、文本文件等都是无结构文件，即流式文件。其文件长度是以字节为单位的。</li></ul><h3 id="逻辑文件按组织方式分类"><a href="#逻辑文件按组织方式分类" class="headerlink" title="逻辑文件按组织方式分类"></a>逻辑文件按组织方式分类</h3><p>组织方式指的是文件中记录的组织方式。只对有结构文件有效。可以分成：顺序文件、索引文件、索引顺序文件。</p><h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><p>指由一系列记录按某种顺序排列所形成的的文件。</p><ul><li>串结构：按存入时间的先后顺序排列。所以检索时必须从头挨个查找，效率低。</li><li>顺序结构：用户指定一个字段作为关键字，他可以是任意类型的变量。如sql文件。</li></ul><h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>为变长记录文件创建一张索引表，索引表是定长记录文件，检索时，先查找索引表，再根据指针所指的地址读取记录。可以解决变长文件记录较难直接存取的问题。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/索引文件.jpg"></div><br>### 索引顺序文件<br><br>将顺序文件的所有记录分成若干组，为顺序文件建立一张索引表，索引表中为每组的第一个记录建立一个索引项。检索时，先检索索引表，找到记录所在记录组的第一个记录的表项，再顺序查找主文件，得到要求的记录。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/索引顺序文件.jpg"></div><br>## 文件目录<br><br>### 文件控制块<br><br>包含三类信息：<br><br>- 基本信息类：文件名、文件物理位置、文件逻辑结构、文件物理结构<br>- 控制信息类：各类用户的读、写、可执行文件等。<br>- 使用信息类：文件的建立时间，当前的使用信息，上一次修改的时间，是否被进程锁住等。<br><br><br><br>### 索引节点<br><br>为了唯一确定外存中的一个文件，必须要把文件的FCB加载进内存，而每次加载的数据大小是一定的，所以为了一次能多加载进内存一个文件标识。将FCB分成两部分：<br><br>#### 磁盘索引节点<br><br>- 文件主标识符<br>- 文件类型<br>- 文件存取权限<br>- 文件物理地址<br>- 文件长度<br>- 文件连接计数：本人理解为硬链接计数<br>- 文件存取时间<br><br><br><br>#### 内存索引节点。<br><br>- 索引节点编号<br>- 状态<br>- 访问计数<br>- 文件所属文件系统的逻辑设备号：不明白<br>- 链接指针：不明白<br><br><br><br>### 树形结构目录<br><br>在树形结构目录中，目录应该保存文件的信息。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/文件目录.jpg"></div><br>同时目录的目录项要能既作为目录文件的FCB，又作为数据文件的FCB。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/树形文件目录.jpg"></div><br>## 文件共享<br><br>### 基于有向无循环图实现文件共享<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/有向无环图.jpg" style="width:80%"></div><br>此种方法存在问题：<br><br>比如对于文件<code>F8</code>，<code>D5:p</code>、<code>D6:e</code>、<code>D3:p</code>都保存了<code>F8</code>的物理地址，即从某个盘块开始，总长度多少等。此时如果<code>D6:e</code>对<code>F8</code>进行了删除操作，<code>D5:p</code>和<code>D3:P</code>都无法察觉，仍然会认为在它们存储的位置上有文件，即一个目录项对文件的操作对其他目录项来说是不可见的。<br><br><br><br>### 利用索引节点<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/利用索引节点.jpg" style="width:60%"></div><br>引入索引结点，将文件的物理地址和其他的属性放在索引结点中，只在目录项中存放文件名和指向索引结点的指针。由任何用户对文件进行Append操作或修改，引起相应索引结点内容的改变。此种方法即Linux中的硬链接。<br><br><br><br>### 利用符号链接实现文件共享<br><br>建立符号链接文件，它是一种特殊类型的文件，其内容是被链接文件的路径名。建立符号链接文件，并不影响原文件，实际上它们各是一个文件。可以建立任意的别名关系，甚至原文件是在其他计算机上。只有文件主才有指向索引结点的指针，而其他共享用户只有该文件的路径名。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/利用符号链接.jpg"></div><br>## 文件保护<br><br>### 访问权&amp;保护域<br><br>- 访问权：一个进程能对某对象执行操作的权利，用&lt;对象名，权集&gt;表示，如<code>&lt;F1, {R/W}&gt;</code>表示进程对F1有读和写的权利。<br>- 保护域：进程对一组对象访问权的集合，进程只能在域内进行操作。<br><br><br><br>### 进程和域的联系方式<br><br>进程和域之间是一对多的关系，即一个进程可以联系多个域。此时进程的运行分为多个阶段，每个阶段联系一个域，这样就可以根据运行的实际需要规定进程每个阶段所能访问的对象。<br><br><br><br>### 访问矩阵<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/访问矩阵.jpg"></div><br>- R：在域内运行的进程对文件具有读权限<br>- W：在域内运行的进程对文件具有写权限<br>- $R^\ast$：在域内运行的进程能把其对文件的读权限扩展到其他域中，但在其他域中是R权限，不再是$R^\ast$。<br>- $W^\ast$：在域内运行的进程能把其对文件的写权限扩展到其他域中，但在其他域中是W权限，不再是$W^\ast$。<br>- S：在域Di中运行的进程能转移到域Dj中运行，如图中在域D3运行的进程能转移到域D2中运行。<br>- O：在域中运行的进程能增加或删除对某文件的访问权。<br>- Control：在域Di中运行的进程能删除在域Dj中运行进程对各对象的访问权。如图中在D2中运行的进程能删除在D3中运行进程的访问权。<br><br><br><br>### 访问矩阵的实现<br><br>#### 访问控制表<br><br>将访问对象按列划分，为每一列建立一张访问控制表，在该表中把属于对象的所有空项都删除。此时表中的每一项都是一个有序对<code>&lt;域，权集&gt;</code>构成。<br><br><br><br>#### 访问权限表<br><br>将访问矩阵按行划分，每一行是一个访问权限表，表中的每一项表示该域对某对象的访问权限。<br><br><br><br><br><br>文件管理的目标是管理文件的组织方式，管理文件的访问权等。而磁盘存储器的管理是管理存储器的使用，如何高效利用存储器。他俩是棋与棋盘的关系。<br><br><br><br>## 连续组织方式<br><br>文件的信息存放在若干连续的物理块中。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/连续组织方式.jpg" style="width:70%"></div><br>- 优点<br>- 简单<br>- 支持顺序存取和随机存取<br>- 顺序存取速度快，所需的磁盘寻道次数和寻道时间最少<br>- 缺点<br>- 文件不能动态增长（预留空间：浪费、重新分配和移动）<br>- 不利于文件插入和删除<br>- 外部碎片问题<br><br><br><br>## 链接组织方式<br><br>### 隐式链接<br><br>在文件的目录中记录该文件的第一和最后一个盘块的指针，每一个盘块的指针指向文件的下一物理块号。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/隐式链接.jpg"></div><br>- 优点<br>- 文件可动态增长<br>- 有利于文件的插入和删除<br>- 提高了磁盘空间利用率,不存在外部碎片问题<br>- 缺点<br>- 存取速度慢，不适于随机存取<br>- 可靠性问题，如指针出错<br>- 更多的寻道次数和寻道时间<br>- 链接指针占用一定的空间<br><br><br><br>### 显示链接<br><br>将链接文件各物理块的指针显示地放在内存的一张链接表（文件分配表，File Allocation Table）中。在FCB的物理地址中填写其首指针所对应的盘块号。由于文件分配表示存储在内存中的，可以大大减少访问磁盘的次数。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/显示链接.jpg" style="width:70%"></div><h3 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h3><p>微软公司早、中期推出的操作系统一直都是采用的FAT技术，即利用文件分配表FAT来记录每个文件中所有盘块之间的链接。FAT中引入了“卷”的概念，支持将一个物理磁盘分成四个逻辑磁盘，每个逻辑磁盘就是一个卷（也称为分区），每个卷都可以被单独格式化和使用。把盘块作为基本分配单位，同时每个分区中都配有两张相同的文件分配表FAT1和FAT2。</p><p>FAT技术的发展有三个阶段：FAT12、FAT16和FAT32</p><h4 id="FAT12"><a href="#FAT12" class="headerlink" title="FAT12"></a>FAT12</h4><p>FAT表的每个表项占用12个bit。所以最多有$2^{12}$个表项，每个盘块的大小是512B，则每个磁盘分区的容量是2MB，能处理的磁盘最大容量是8MB。</p><p>为了增大FAT能管理的最大容量，引入了“簇”的概念，每个簇是一组相邻的扇区，这样如果分配时以簇为单位进行分配就能管理更大的磁盘容量，但是相应的簇内零头也会更大，降低磁盘的利用率。</p><h4 id="FAT16"><a href="#FAT16" class="headerlink" title="FAT16"></a>FAT16</h4><p>FAT表的每个表项占用16个bit。最多有$2^{16}$个表项。</p><h4 id="FAT32"><a href="#FAT32" class="headerlink" title="FAT32"></a>FAT32</h4><p>FAT表的每个表项占用16个bit。最多有$2^{32}$个表项。同时每个簇固定为4KB。所以最大可管理$4 \ast 2^{10} \ast 2^{32} = 2TB$大小的空间。</p><h3 id="NTFS"><a href="#NTFS" class="headerlink" title="NTFS"></a>NTFS</h3><h2 id="索引组织方式"><a href="#索引组织方式" class="headerlink" title="索引组织方式"></a>索引组织方式</h2><h3 id="单级索引组织方式"><a href="#单级索引组织方式" class="headerlink" title="单级索引组织方式"></a>单级索引组织方式</h3><p>一个文件的信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构索引表，并将这些块的块号存放在一个索引表中。一个索引表就是磁盘块地址数组，其中第i个条目指向文件的第i块。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/索引组织方式.jpg" style="width:60%"></div>·<br>### 多级索引组织方式<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/多级索引组织方式.jpg"></div><br>### 增量式索引组织方式<br><br>可以更好的满足大、中、小文件的组织。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/增量组织方式.jpg"></div><br>## 文件存储空间的管理<br><br>文件存储空间的管理包括空闲块的组织分配和回收。<br><br>### 空闲表法<br><br>把一个连续未分配区域称为“空闲文件”，系统为所有空闲文件单独建立一个目录。表目内容：序号，第一个空白块号，空白块个数。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/空闲链表.jpg"></div><br>- 分配算法：内存管理中的首次适应算法、循环首次适应算法。<br>- 合并：空闲区邻接合并<br><br><br><br>### 空闲链表法<br><br>空闲盘块链：所有空闲盘块拉成一条链，分配时从头分配，回收时链接在尾部。<br><br>空闲盘区链：每个连续的盘块组成一个盘区，每个盘区包含本盘区的大小和下一个盘区的地址。<br><br><br><br>### 位示图法<br><br>用一串二进制位反映磁盘空间中分配使用情况，每个物理块对应一位，分配物理块为1，否则为0。申请物理块时，可以在位示图中查找为0的位，返回对应物理块号；归还时；将对应位转置0。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/位示图法.jpg"></div><br>### 成组链接法（重点）<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/成组链接法.jpg"></div><br>- 把所有的空闲盘块按每n个一组分成m个组。<br>- 最后一个组放在内存的空闲盘块号栈中，其他组存在外存上。空闲盘块号栈是一个临界资源，只允许一个进程同时访问。<br>- 数据结构，一个size为n+1的栈。图上是一个倒着的的栈（栈底在上方，栈顶在下方）<br>- 一个n+1的栈实际可用盘块只有n（图上只有99个可用盘块），因为栈底是一个计数器，指示当前有多少个可用盘块，但是可用盘块中有一个是指向下一个组，即stack[1]指向下一个组。如果stack[1]==0表示此时是最后一组。<br>- 分配时从栈顶开始向下分配，直至分配出n-1个盘块，此时如果再想分配一个块就需要把下一个组调入空闲盘块号栈。调入后新组覆盖旧组。<strong>然后把新组在外存中占用的盘块分配出去。</strong><br>- 回收时从栈底向上回收，如果计数器==100时还有空闲盘块（设这个盘块编号为p）要回收，就把空闲盘块号栈内的组取出来存在p中，在空闲盘块号栈内新开辟一个组，新组的stack[1]指向p。<br><br><br><br>### 例<br><br>此题题目及来源：<a href="https://blog.csdn.net/ajay666/article/details/73569654" target="_blank" rel="noopener">https://blog.csdn.net/ajay666/article/details/73569654</a><br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/成组链接例.jpg"></div><br>分配3个盘块后，回收它所占的5个盘块，回收的盘块号依次为700、711、703、788、701，画出分配回收过程。<br><br>#### 第一次分配<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/成组链接例1.jpg"></div><br>#### 第二次分配<br><br>注意：300号盘块中存储的组信息调入空闲盘块号栈之后其自己也可以被分配。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/成组链接例2.jpg"></div><br>#### 第三次分配<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/成组链接例3.jpg"></div><br>#### 第一次回收<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/第一次回收.jpg"></div><br>#### 第二次回收<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/第二次回收.jpg"></div><br>#### 第三次&amp;第四次&amp;第五次回收<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/第三四五次回收.jpg"></div><h2 id="Linux介绍"><a href="#Linux介绍" class="headerlink" title="Linux介绍"></a>Linux介绍</h2><p>Linux是一套免费使用和自由传播的操作系统。严格来讲，Linux这个词本身只表示Linux内核，但一般来说使用Linux内核的操作系统都被称为Linux。而不同的厂家使用相同的Linux内核所构建的操作系统叫做Linux发行版。常见的Linux发行版有Ubuntu、Centos、Debian等。这些发行版的使用方法大同小异。</p><p>但Linux不仅限于使用在PC机上，移动端（安卓系统是由Linux改写而来）、路由器（只保留少许功能的Linux系统）等终端都在使用Linux。</p><h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><ul><li><p>虚拟机安装：<a href="https://blog.csdn.net/qq_38206090/article/details/82559358" target="_blank" rel="noopener">blog.csdn.net/qq_38206090/article/details/82559358</a></p></li><li><p>双系统：笔者没有安装过，因为怕系统出问题导致文件损失。</p></li><li><p>云服务器：云服务器系统配置Linux版本我认为是最简单的方式，所以以下实例均采用阿里云服务器。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/阿里云服务器.png"></div></li></ul><h2 id="连接服务器工具"><a href="#连接服务器工具" class="headerlink" title="连接服务器工具"></a>连接服务器工具</h2><ul><li>SecureCRT：去 <a href="http://59.110.143.226/Sharing-Your-Story/" target="_blank" rel="noopener">http://59.110.143.226/Sharing-Your-Story/</a> 搜索。</li><li>Termius：<a href="https://www.microsoft.com/store/productId/9NK1GDVPX09V" target="_blank" rel="noopener">https://www.microsoft.com/store/productId/9NK1GDVPX09V</a></li></ul><p>推荐使用Termius，好看也好用。SecureCRT是破解版，Termius是免费使用。</p><h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p>Linux的目录结构是一个树形结构，树根是一个/。直接子目录包括root、home等。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/根目录.png"></div><p>如我的阿里云服务器根目录：</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/根目录格式.jpg"></div><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>Shell是指“为使用者提供操作界面”的软件（命令解析器）。Shell翻译过来叫做“壳”，用来区别于“核”，也就是说它把底层的东西封装成命令，使用者键入命令就能得到相应的结果。比如上面的这张图中，我在根目录下输入<code>ll</code>命令，就在终端上给我显示根目录下的文件信息。也就是说Shell解析了我输入的<code>ll</code>命令，返回我想要的信息（根目录文件信息）。</p><h2 id="Bash命令"><a href="#Bash命令" class="headerlink" title="Bash命令"></a>Bash命令</h2><p>Shell是命令解释器，自然会有不同的分类，就类比于同是循环结构，Java和Python却有不同的语法。但是Bash（Bourne-Again SHell）是Linux默认的Shell交互类型，也就是说在Linux中打开一个终端，就启动一个Bash进程。</p><h2 id="Bash命令格式"><a href="#Bash命令格式" class="headerlink" title="Bash命令格式"></a>Bash命令格式</h2><p>格式：命令名 [选项] [参数1] [参数2] … 有如下特点：</p><ul><li>命令名必须是小写英文字母。</li><li>一般格式中，方括号括起来的部分是可选选项。</li><li>选项是对命令的特别定义，以“-”开始。一个命令<strong>可以使用多个选项</strong>且多个选项连接起来同样有效（部分发行版不支持）。如：<code>ls -al</code>和<code>ls -a -l</code>效果相同。</li><li>命令正常执行后返回一个0表示执行成功，返回非0值表示执行过程出错。在终端上很难体现出来，但在shell脚本（后续会介绍）中可作为控制逻辑流程的一部分（用$?查看）。</li></ul><h2 id="Bash举例"><a href="#Bash举例" class="headerlink" title="Bash举例"></a>Bash举例</h2><p>查看内核版本号：<code>uname -a</code>:</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/查看内核版本号.jpg"></div><p><code>uname</code>是命令名，<code>-a</code>是选项，这个命令没有参数。</p><h2 id="uname解释"><a href="#uname解释" class="headerlink" title="uname解释"></a>uname解释</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/uname.png"></div><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>终端窗口中的命令以Enter键结束，且Shell命令区分大小写。如果命令太长，一行放不下时，在行尾输入<code>\</code>并按Enter键。这时Shell会返回一个大于号（&gt;）作为提示符，表示该命令行尚未结束，允许继续输入有关信息。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/输入.png"></div><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>echo命令把命令行中的参数全部显示到标准输出（终端）中。如果参数用引号引起来，会按原样输出。否则会把各个单词按字符串输出，字符串之间用空格隔开。单引号/双引号的区别请看Shell那一部分。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/echo.png"></div><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>Linux的标准输出是屏幕，把结果输出到指定的文件叫做输出重定向。</p><ul><li><code>&gt;</code>：目标文件不存在，系统将建立该文件；文件存在，重定向将会删除该文件，并重新建立一个新文件存放结果。</li><li><code>&gt;&gt;</code>：目标文件不存在，系统将建立该文件；如果目标文件存在，新的输出结果将会追加到文件末尾。</li></ul><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>显示出当前所在目录的路径。</p><h2 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h2><p><code>history</code>命令可以看到用户所有曾经输入过的命令。</p><ul><li><code>!!</code>：执行上一个命令；</li><li>`!n：执行第n个命令；</li><li><code>!-n</code>：执行倒数第n个命令；</li><li><code>!xxx</code>：执行以xxx开头的命令，如之前使用过clear，<code>!cle</code>会执行clear。</li></ul><p><code>~/.bash_history</code>文件中会存储你近期使用过的命令。查看此文件：<code>cat ~/.bash_history</code></p><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><ul><li><p><code>date</code>命令在屏幕上显示或设置系统的日期和时间：</p><ul><li><code>date [+格式控制字符串]格式控制字符串常用单引号引起来。年:Y 月:m 日:d 小时:H 分:M 秒:S</code></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/date1.png"></div></li><li><p>有且只有超级用户能设置或修改系统时钟，语法如下：</p><ul><li><code>date -s “year-month-day hour:minute:second”</code></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/date2.png"></div></li></ul><p>系统在启动的时候是从CMOS（用来存储计算机某些参数的芯片）中加载时钟，为了保持系统时间与CMOS时间的一致性，Linux每隔一段时间会将系统时间写入CMOS。由于该同步是每隔一段时间进行的，在我们执行<code>date -s</code>后，如果马上重起机器，修改时间就有可能没有被写入CMOS，而<code>hwclock –w</code>强制把系统时间写入CMOS。</p><h2 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h2><p>列出日历信息。</p><ul><li>单独一个cal：列出当前月的日历信息。</li><li>cal xxxx：列出xxxx年的日历信息。</li><li>cal yy xxxx：列出xxxx年yy月的日历信息。</li><li>cal dd yy xxxx：列出xxxx年yy月xx日所在月的日历信息。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/cal1.png"></div><h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>clear命令清除屏幕上的信息，清屏后，提示符移到屏幕左上角。</p><h2 id="关机-amp-重启"><a href="#关机-amp-重启" class="headerlink" title="关机 &amp; 重启"></a>关机 &amp; 重启</h2><ul><li><code>shutdown -h now</code>：立刻关机</li><li><code>shutdown -h 15:30</code>：15:30 关机</li><li><code>shutdown -h +30</code>：30 分钟后关机</li><li><code>reboot</code>：重启</li><li><code>shutdown -k +2 &quot;一会要关机，抓紧保存&quot;</code>：向所有用户输出关机通知，但不做真正操作。<code>+2</code>表示通知的关机时间是现在之后的两分钟。</li></ul><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>如果我们忘记某些命令或其参数如何使用，需要使用帮助命令。</p><ul><li><code>whatis &lt;命令&gt;</code>：显示命令的简短描述。</li><li><code>&lt;命令&gt; -help</code>：显示使用方法概述和参数列表。</li><li><code>man &lt;命令&gt;</code>：为命令提供相关帮助文档，页面分成章节。</li><li><code>info &lt;命令&gt;</code>：类似man命令，但是通常比它更详细。</li></ul><h2 id="切换路径命令"><a href="#切换路径命令" class="headerlink" title="切换路径命令"></a>切换路径命令</h2><ul><li><code>cd &lt;位置&gt;</code>：切换到指定位置；</li><li><code>cd ~</code>：切换到用户家目录；</li><li><code>cd -</code>：切换到上一个所在目录；</li></ul><h2 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h2><p>修改密码。</p><ul><li><code>单独的passwd</code>：修改使用该命令的用户的密码。</li><li><code>passwd 用户名</code>：root用户可以使用该命令修改其他用户的密码。</li></ul><h2 id="Linux用户"><a href="#Linux用户" class="headerlink" title="Linux用户"></a>Linux用户</h2><p>登录Linux系统时，必须通过指定的用户名和密码进行登录。不过所有的用户在Linux眼中都是一个数字，用userid（一个32位的二进制整数）来表示。可以通过id命令，查看自己的userid。userid为0的表示根用户。同时，在系统运行的每个进程、所创建的每个文件都有一个userid，这个userid代表运行这个程序的用户，或者文件的所有者。Linux系统中，用户被保存在<code>/etc/passwd</code>文件中。用户又分成三类：一般用户（userid&gt;=500）、超级用户（userid=0）和系统用户（userid&lt;500）。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/linux用户.png"></div><h2 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h2><p>Linux是一个多用户系统，即很多个用户同时操作一个设备中的资源，但不同的用户有不同的权限。这些用户中有一个是超级用户（root），它是权限最高的用户。root用户在终端中的输入命令以#开头，其他的用户以$开头。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/root.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/user.png"></div><ul><li><p><code>who</code>：列出正在使用系统的<strong>所有</strong>用户、所用的终端名和注册到系统的时间。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/who.png"></div></li><li><p><code>who am i</code>：列出<strong>使用该命令</strong>的用户、所用的终端名和注册到系统的时间。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/whoi.png"></div></li></ul><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><p>由于不同的用户有不同的权限。为了给不同的用户赋予相同的权限更加方便，诞生了用户组的概念。即同一个用户组里的人员可以有相同的某些权限。<strong>Linux中的用户或文件至少属于一个用户组</strong>。</p><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p><code>useradd</code>或者<code>adduser</code>。执行后的具体操作（不同发行版有区别）：</p><ul><li><p>分配一个新的userid，数值等于之前所有userid中数值最大的加一。</p></li><li><p>在/etc/passwd中添加一行。</p></li><li><p>为用户在/home下建立一个新的目录（用户的家目录），目录名和用户名相同。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/adduser.png"></div></li><li><p>在/etc/group中为用户建立一个新的个人组。</p></li><li><p>在/var/spool/mail中创建用户的邮件文件。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/addmail.png"></div></li></ul><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><p><code>userdel &lt;用户&gt;</code>。删除用户及部分相关信息，家目录和邮件文件还会存在。</p><ul><li><code>-r</code>：包括家目录和邮件池等在内的所有用户信息都会被删除。</li></ul><h2 id="添加-删除组"><a href="#添加-删除组" class="headerlink" title="添加/删除组"></a>添加/删除组</h2><ul><li><code>groupadd &lt;组名&gt;</code>。所有的组都保存在/etc/group文件中。</li><li><code>groupdel &lt;组名&gt;</code>。删除组。</li></ul><h2 id="etc-passwd-amp-etc-shadow"><a href="#etc-passwd-amp-etc-shadow" class="headerlink" title="/etc/passwd &amp; /etc/shadow"></a>/etc/passwd &amp; /etc/shadow</h2><ul><li><p><code>/etc/passwd</code>有7列：用户名、密码、用户id、主要组id、备注信息、主目录、登录shell。</p><ul><li>各列之间使用<code>:</code>分割。同时密码一般都是x（被加密了），加密后的密码在/etc/shadow中。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/passwd.png"></div></li><li><p><code>/etc/shadow</code>有9列：用户名、加密密码、最近更改密码的日期、密码不可更改的天数、密码需要重新更改的天使、密码更改期限前的警告期限、密码过期的宽限时间、帐号失效日期、保留字段。但这里显示的密码是加密的。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/shadow.png"></div></li></ul><h2 id="查看用户所属的组"><a href="#查看用户所属的组" class="headerlink" title="查看用户所属的组"></a>查看用户所属的组</h2><ul><li><code>groups</code>：查看使用此命令的用户所属组；</li><li><code>groups &lt;用户&gt;</code>：查看指定用户所属组。用户可多选，使用空格隔开。</li></ul><h2 id="etc-group-amp-etc-gshadow"><a href="#etc-group-amp-etc-gshadow" class="headerlink" title="/etc/group &amp; /etc/gshadow"></a>/etc/group &amp; /etc/gshadow</h2><ul><li><code>/etc/group</code>：组名、组密码、组id、组中附加用户。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/group.png"></div><ul><li><code>/etc/gshadow</code>：组名、密码、组管理者、组中附加用户。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/gshadow.png"></div><h2 id="为用户添加备注"><a href="#为用户添加备注" class="headerlink" title="为用户添加备注"></a>为用户添加备注</h2><ul><li>在创建的时候添加：<code>useradd -c &lt;备注&gt; 用户名</code>。</li><li>创建后修改：<code>usermod -c &lt;备注&gt; 用户名</code>。（会清除之前的备注信息）。</li></ul><h2 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h2><p>改变用户某些属性的命令。</p><ul><li><p><code>-l</code>：改变用户的名称；</p></li><li><p><code>-G</code>：改变用户支持的用户组，会退出原来的附属组，配合<code>-a</code>不会删除之前组；</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/usermodag.png"></div></li><li><p><code>-L</code>：不让该用户登录；</p></li><li><p><code>-e</code>：设定用户失效日期。日期格式：“YYYY-MM-DD”。</p></li><li><p><code>-s</code>：改变Shell。新创建的用户默认使用bash，此选项修改登录Shell。</p><ul><li>如：<code>usermod -aG 组名 用户</code></li></ul></li></ul><h2 id="gpasswd"><a href="#gpasswd" class="headerlink" title="gpasswd"></a>gpasswd</h2><p><code>gpasswd -d userName groupNam</code>e：从组中删除用户</p><h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><ul><li>超级用户输入<code>su 用户名</code>可以不用输入密码切换到其他用户。</li><li>普通用户切换到其他所有用户（<code>su 用户名</code>）需要输入密码。</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。</p><ul><li><p>文件：文件系统中存储数据的一个命名的对象。即使是空文件（不包含用户数据）也会为操作系统提供其他信息。</p></li><li><p>目录：包含文件项目的一类特殊文件。Linux中在应用层上来看目录和文件是被区分开来的。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/filesys.png"></div></li></ul><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><p><code>find &lt;路径&gt; -name &#39;正则表达式&#39;</code>：如<code>find . -name &#39;*.so&#39;</code>，查找当前目录下以<code>.so</code>结尾的文件。</p><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><ul><li><code>cat &lt;文件&gt;</code>：显示文件的内容。文件可以多选，之间用空格隔开。</li><li><code>cat f1 &gt; f2</code>：把f1文件的内容合并到f2文件中。</li></ul><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><ul><li><p>文件不存在：则创建一个空的新文件；</p></li><li><p>文件存在：把文件的时间标签更新为系统当前时间。</p></li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>命令的意思：global search regular expression and print out the line。</p><h3 id="部分选项如下："><a href="#部分选项如下：" class="headerlink" title="部分选项如下："></a>部分选项如下：</h3><ul><li><code>-a</code>：将 binary 文件以 text 文件的方式搜寻数据</li><li><code>-c</code>：计算找到 ‘搜寻字符串’ 的次数</li><li><code>-i</code>：忽略大小写的不同，所以大小写视为相同</li><li><code>-n</code>：顺便输出行号</li><li><code>-v</code>：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！</li><li><code>--color=auto</code>：可以将找到的关键词部分加上颜色的显示喔！</li></ul><h3 id="举例如下："><a href="#举例如下：" class="headerlink" title="举例如下："></a>举例如下：</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/grep.jpg"></div><h2 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h2><p>管道命令是用来过滤信息的，比如我们之前<code>grep -n root /etc/passwd</code>之后显示带有root的行，如果想在结果中再按其他条件过滤就要使用管道命令：“|”。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/管道.png"></div><h2 id="统计文件信息"><a href="#统计文件信息" class="headerlink" title="统计文件信息"></a>统计文件信息</h2><p><code>wc</code>：统计指定文件的字节数（<code>-c</code>）、字数（<code>-w</code>）、行数（<code>-l</code>）</p><ul><li>例子：统计文件a中以b开头的行数：<code>cat a | grep ^b | wc -l</code></li></ul><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p><code>mkdir &lt;文件名&gt;</code>。</p><ul><li><code>-p</code>：父目录不存在时也可以创建。</li></ul><h2 id="删除文件-目录"><a href="#删除文件-目录" class="headerlink" title="删除文件/目录"></a>删除文件/目录</h2><p><code>rm -rf &lt;文件名&gt;</code>。<code>-r</code>表示递归删除；<code>-f</code>表示强制删除，不询问。</p><h2 id="列出文件"><a href="#列出文件" class="headerlink" title="列出文件"></a>列出文件</h2><p><code>ls</code>命令列出指定目录的内容。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ls.png"></div><ul><li><p><code>-l</code>：文件的详细信息。输出的信息分成多列，它们依次是：文件类型与权限、链接数、文件主、文件组、文件大小、建立或最近修改的时间、文件名。total的计算：<a href="https://yq.aliyun.com/ziliao/264744" target="_blank" rel="noopener">https://yq.aliyun.com/ziliao/264744</a>。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ll.png"></div></li><li><p><code>-a</code>：显示所有文件。之前显示的没有隐藏文件（以<code>.</code>开头）。</p></li><li><p><code>-h</code>：文件大小以人类可读的方式显示。需要配合<code>-l</code>使用。</p></li></ul><h2 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h2><p><code>cp &lt;文件&gt; &lt;目录&gt;</code>。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/cp.png"></div><h2 id="剪切文件"><a href="#剪切文件" class="headerlink" title="剪切文件"></a>剪切文件</h2><p><code>mv &lt;文件&gt; &lt;目录&gt;</code>。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/mv.png"></div><h2 id="修改文件名"><a href="#修改文件名" class="headerlink" title="修改文件名"></a>修改文件名</h2><p><code>mv &lt;文件&gt; &lt;新文件名&gt;</code>。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/mvname.png"></div><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>Linux中所有的文件都由两部分构成。</p><ul><li><p>索引结点：包含此文件的信息，如文件权限、文件主、文件大小等。</p></li><li><p>数据：文件的实际内容，有没有数据都可以。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/文件结构.png"></div></li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接就是把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。</p><ul><li><p>硬链接：硬链接是多一个文件名和inode结点关联。由于它依赖于inode，所以不能在不同的文件系统之间做硬链接。硬链接不能用于目录。用法：<code>ln &lt;被链接的文件&gt; &lt;新的文件名&gt;</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/hardlink.png"></div></li><li><p>软连接：软连接是再拓展出一份inode，这个inode指向的区域保存如何找到真正数据的信息。用法：<code>ln -s &lt;被链接的文件&gt; &lt;新的文件名&gt;</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/software.png"></div></li></ul><h2 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a>用户和权限</h2><ul><li><p>文件主：文件所有者，并赋予唯一的注册名。只有文件主或root才有权利用<code>chown</code>命令改变文件的所有关系（UID）。</p></li><li><p>用户组：通常，组中包含了有相同需求的用户。文件主或超级用户（root）可以利用<code>chgrp</code>命令改变文件的GID。</p></li><li><p>用户存取权限：Linux系统中规定了4种不同类型的用户：文件主、同组用户、其他用户、超级用户。</p></li><li><p>3种访问文件或目录的方式：r（读）、w（写）、 x（可执行或查找）。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/用户与权限.png"></div></li></ul><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><ul><li><p>只有文件主或超级用户root才有权用<code>chmod</code>命令改变文件或目录的存取权限。</p></li><li><p>使用格式：<code>chmod [选项] MODE 文件</code>。MODE可多选，之间用<code>,</code>隔开。</p><ul><li>MODE：<code>&lt;who&gt;&lt;操作符号&gt;&lt;权限&gt;</code>。<ul><li>who：u——user、g——group、o——others、a——all（可叠加）。</li><li>操作符号：<code>+ 添加</code>、<code>- 取消</code>、<code>= 赋予</code>；</li><li>权限：r 读、w 写、x 执行。（可叠加）</li></ul></li></ul></li><li><p>举例</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/chmod.png"></div></li><li><p>以绝对方式改变权限</p><ul><li><p>置为1表示有相应权限，置为0表示没有相应权限。例如：</p><p><code>r w x r - x r - -</code></p><p><code>1 1 1 1 0 1 1 0 0</code></p></li><li><p>转换成十进制是754。<code>chmod 754 aa</code>和<code>chmod u=rwx,g=rx,o=r aa</code>一致。</p></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/chmod绝对.png"></div></li></ul><h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><p>官方的解释是掩码，其实就是用户创建文件或目录后它们的默认权限。不过和<code>chomd</code>有区别的是它把有权限设置为0，没权限设置为1，而且<code>umask</code>命令显示的是八进制数字。我的<code>umask</code>显示的是0022，转换成二进制就是000 010 010，转换成权限就是<code>rwx r-x r-x</code>。所以创建的目录的默认权限就是这个。但是Linux不允许新创建的文件有可执行权限，所以创建的文件的默认权限是<code>rw- r-- r--</code>。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/umask.png"></div><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p>改变某个文件或目录的所有者。<code>chown &lt;用户&gt; &lt;文件&gt;/&lt;目录&gt;</code></p><h2 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h2><p>改变文件或目录所属的用户组。<code>chgrp &lt;用户组&gt; &lt;文件&gt;/&lt;目录&gt;</code></p><h2 id="文件权限的理解"><a href="#文件权限的理解" class="headerlink" title="文件权限的理解"></a>文件权限的理解</h2><ul><li>可读（r）：浏览文件中的内容；</li><li>可写（w）：修改文件中的内容；</li><li>可执行（x）：将文件作为命令使用。</li></ul><h2 id="目录权限的理解"><a href="#目录权限的理解" class="headerlink" title="目录权限的理解"></a>目录权限的理解</h2><ul><li><p>可读：只能查看到目录下的子目录名和文件名；</p></li><li><p>可执行：可以访问目录中的文件，包括子目录；</p></li><li><p>可写：要在目录下添加删除目录和文件，必须有可执行的权利。</p></li></ul><h2 id="压缩-amp-打包-amp-解压缩"><a href="#压缩-amp-打包-amp-解压缩" class="headerlink" title="压缩 &amp; 打包 &amp; 解压缩"></a>压缩 &amp; 打包 &amp; 解压缩</h2><ul><li><code>tar -zcvf</code>：打包压缩后的文件名 要打包压缩的文件（多个之间用space分开）<ul><li><code>z</code>：调用gzip压缩命令进行压缩</li><li><code>c</code>：create，打包文件</li><li><code>v</code>：显示运行过程</li><li><code>f</code>：指定文件名</li></ul></li><li><code>tar -xvf xxx.tar.gz -C 位置</code><ul><li><code>x</code>：extract，解包</li><li><code>v</code>：显示允许过程</li><li><code>f</code>：指定文件名</li></ul></li></ul><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>我们可以使用ll代替<code>ls -l</code>。但是对于<code>ls -a</code>，系统并没有提供<code>la</code>命令，不过我们可以使用<code>alias</code>定义<code>la</code>。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/别名.png"></div><p>取消别名使用<code>unalias 别名</code></p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p><code>cron</code>工具允许用户配置要定期运行的任务，通过配置<code>crontab</code>的文件可以指定要运行哪些作业以及何时运行。配置<code>crontab</code>文件使用命令<code>crontab</code>。命令由6个用空白分隔的字段组成：</p><table><thead><tr><th>字段</th><th>minute</th><th>hour</th><th>day of month</th><th>month</th><th>day of week</th><th>command to run</th></tr></thead><tbody><tr><td>举例</td><td>45</td><td>16</td><td>*</td><td>*</td><td>*</td><td>date&gt;/tmp/date.txt</td></tr><tr><td>范围</td><td>0-59</td><td>0-23</td><td>1-31</td><td>1-12</td><td>0-7</td><td>*</td></tr></tbody></table><p>corntab命令的参数：</p><ul><li><code>-e</code>：编辑<code>crontab</code>的内容（会打开一个文件）；</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/crone.png"></div><ul><li>设置定期任务（16:45时把当前时间写入<code>/tmp/date.txt</code>文件中）：</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/设置定期任务.png"></div><ul><li><p>过一段时间之后查看<code>/tmp</code>文件夹：</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/查看定时任务.png"></div></li><li><p><code>-u</code>：只有root才能执行这个选项，帮助其他用户建立/删除<code>crontab</code>；</p></li><li><p><code>-l</code>：查看crontab的工作内容:</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/cronl.png"></div></li><li><p><code>-r</code>：删除crontab的工作内容；</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/cronr.png"></div></li></ul><h2 id="成组命令"><a href="#成组命令" class="headerlink" title="成组命令"></a>成组命令</h2><p>被成组命令约束的命令被认为是一条命令。</p><ul><li><code>{ 命令; }</code>：需要有空格和命令隔开，且命令后面需要“<code>;</code>”。不创建子进程。</li><li><code>(命令)</code>：不强制需要有空格和命令隔开，不强制需要“<code>;</code>”。创建子进程完成功能。</li></ul><p>例如下例把两条ls命令的值全部由管道输入给grep。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/成组命令.png"></div><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>sort lines of text files，将文本文件内容加以排序，以行为单位来排序，但不改变文件原始内容。</p><ul><li><p>默认排序规则：从第每行一个字符开始，依次按照ASCII码值进行比较。</p></li><li><p><code>-n</code>：按数字的大小排序，默认情况下把数字看成字符。</p></li><li><p><code>-r</code>：反转排序效果。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/testsort.jpg"></div></li></ul><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p>文件输出时，删除重复行或列。但如果重复的行不连续则不起作用。</p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><ul><li>-：普通文件</li><li>l：符号链接文件</li><li>d：目录</li><li>s：套接字文件（socket）</li><li>b：块设备文件</li><li>p：命名管道文件（pipe）</li><li>c：字符设备文件</li></ul><h2 id="ex1：用户管理"><a href="#ex1：用户管理" class="headerlink" title="ex1：用户管理"></a>ex1：用户管理</h2><h3 id="在系统中添加三个用户：Blondie、Prince和Madonna"><a href="#在系统中添加三个用户：Blondie、Prince和Madonna" class="headerlink" title="在系统中添加三个用户：Blondie、Prince和Madonna"></a>在系统中添加三个用户：Blondie、Prince和Madonna</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex11.png"></div><h3 id="他们都希望属于次要组music"><a href="#他们都希望属于次要组music" class="headerlink" title="他们都希望属于次要组music"></a>他们都希望属于次要组music</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex12.png"></div><h3 id="Blondie要求在他的条目中添加特殊备注“heart-of-glass”"><a href="#Blondie要求在他的条目中添加特殊备注“heart-of-glass”" class="headerlink" title="Blondie要求在他的条目中添加特殊备注“heart of glass”"></a>Blondie要求在他的条目中添加特殊备注“heart of glass”</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex13.png"></div><h3 id="Prince要求使用-bin-csh作为登录shell"><a href="#Prince要求使用-bin-csh作为登录shell" class="headerlink" title="Prince要求使用/bin/csh作为登录shell"></a>Prince要求使用/bin/csh作为登录shell</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex14.png"></div><h3 id="Madonna的使用期限为2020-12-1。"><a href="#Madonna的使用期限为2020-12-1。" class="headerlink" title="Madonna的使用期限为2020-12-1。"></a>Madonna的使用期限为2020-12-1。</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex15.png"></div><h3 id="Blondie决定加入摔跤俱乐部wrestle组。"><a href="#Blondie决定加入摔跤俱乐部wrestle组。" class="headerlink" title="Blondie决定加入摔跤俱乐部wrestle组。"></a>Blondie决定加入摔跤俱乐部wrestle组。</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex161.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex162.png"></div><h3 id="Prince要将他的用户名改为tafkap。"><a href="#Prince要将他的用户名改为tafkap。" class="headerlink" title="Prince要将他的用户名改为tafkap。"></a>Prince要将他的用户名改为tafkap。</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex17.png"></div><h3 id="Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。"><a href="#Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。" class="headerlink" title="Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。"></a>Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。</h3><ul><li><code>groupadd fengshui</code></li><li><code>usermod -a –G fengshui Madonna</code></li><li><code>usermod –u 888 Madonna</code></li></ul><h3 id="Prince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。"><a href="#Prince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。" class="headerlink" title="Prince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。"></a>Prince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。</h3><ul><li><code>usermod –L Prince</code></li></ul><h3 id="Blondie最近表现不好，我们决定将他踢出去。"><a href="#Blondie最近表现不好，我们决定将他踢出去。" class="headerlink" title="Blondie最近表现不好，我们决定将他踢出去。"></a>Blondie最近表现不好，我们决定将他踢出去。</h3><ul><li><code>userdel –r Blondie</code>（想把该用户所有信息都一起删除可以使用-r）</li></ul><h2 id="ex2：文件目录管理"><a href="#ex2：文件目录管理" class="headerlink" title="ex2：文件目录管理"></a>ex2：文件目录管理</h2><h3 id="Ventura同时属于次要组governor和wrestle。"><a href="#Ventura同时属于次要组governor和wrestle。" class="headerlink" title="Ventura同时属于次要组governor和wrestle。"></a>Ventura同时属于次要组governor和wrestle。</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex21.png"></div><h3 id="Ventura撰写了自己的摔跤计划plans-txt，并将它放到目录-tmp下。"><a href="#Ventura撰写了自己的摔跤计划plans-txt，并将它放到目录-tmp下。" class="headerlink" title="Ventura撰写了自己的摔跤计划plans.txt，并将它放到目录/tmp下。"></a>Ventura撰写了自己的摔跤计划plans.txt，并将它放到目录/tmp下。</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex22.png"></div><h3 id="Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。"><a href="#Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。" class="headerlink" title="Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。"></a>Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex22.png"></div><h3 id="用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？"><a href="#用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？" class="headerlink" title="用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？"></a>用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex24.png"></div><h3 id="用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？"><a href="#用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？" class="headerlink" title="用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？"></a>用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？</h3><p>不可以，只有root和文件主能修改文件访问权。</p><h2 id="vi-amp-vim"><a href="#vi-amp-vim" class="headerlink" title="vi &amp; vim"></a>vi &amp; vim</h2><p>这俩都是文本编辑器。vi是Linux默认的编辑器，类似于windows的记事本。vim是vi的拓展，比vi更强大。可以用于在Linux中编辑文件内容。笔记中使用vim。它有两种模式，命令模式和编辑模式，在命令模式中可以做一些检索、筛选等操作。在编辑模式中可以对文档进行修改。</p><h2 id="进入-amp-退出"><a href="#进入-amp-退出" class="headerlink" title="进入 &amp; 退出"></a>进入 &amp; 退出</h2><h3 id="进入命令模式"><a href="#进入命令模式" class="headerlink" title="进入命令模式"></a>进入命令模式</h3><p>方法：<code>vim &lt;文件名&gt;</code>。此时进入命令模式，不能对文件内容进行操作。对文档的检索是在这种模式下进行的。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/vima.png"></div><h3 id="进入编辑模式："><a href="#进入编辑模式：" class="headerlink" title="进入编辑模式："></a>进入编辑模式：</h3><h4 id="i：编辑位置在当前光标位置之前"><a href="#i：编辑位置在当前光标位置之前" class="headerlink" title="i：编辑位置在当前光标位置之前"></a><code>i</code>：编辑位置在当前光标位置之前</h4><p>按下<code>i</code>再按<code>_</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/i1.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/i2.png"></div><h4 id="I：在光标所在行的行首插入新增文本"><a href="#I：在光标所在行的行首插入新增文本" class="headerlink" title="I：在光标所在行的行首插入新增文本"></a>I：在光标所在行的行首插入新增文本</h4><p>按下<code>I</code>再按<code>_</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/I11.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/I22.png"></div><h4 id="a：在该命令之后输入的字符都插到光标之后"><a href="#a：在该命令之后输入的字符都插到光标之后" class="headerlink" title="a：在该命令之后输入的字符都插到光标之后"></a><code>a</code>：在该命令之后输入的字符都插到光标之后</h4><p>按下<code>a</code>再按<code>_</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/a1.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/a1.png"></div><h4 id="A：在光标所在行的行尾添加文本"><a href="#A：在光标所在行的行尾添加文本" class="headerlink" title="A：在光标所在行的行尾添加文本"></a>A：在光标所在行的行尾添加文本</h4><p>按下<code>A</code>再按<code>_</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/A11.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/a22.png"></div><h4 id="o：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行"><a href="#o：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行" class="headerlink" title="o：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行"></a><code>o</code>：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行</h4><p>按下<code>o</code>再按<code>_</code></p><div align="center"><img src="/03-vim/o1.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/o2.png"></div><h4 id="O：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上"><a href="#O：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上" class="headerlink" title="O：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上"></a><code>O</code>：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上</h4><p>按下<code>O</code>再按<code>_</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/o11.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/o2.png"></div><h4 id="r：替换光标所在的哪一个字符"><a href="#r：替换光标所在的哪一个字符" class="headerlink" title="r：替换光标所在的哪一个字符"></a><code>r</code>：替换光标所在的哪一个字符</h4><p>按下<code>r</code>再按<code>_</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/r1.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/r2.png"></div><h4 id="R：一直替换光标所在的文字，直到按下ESC为止"><a href="#R：一直替换光标所在的文字，直到按下ESC为止" class="headerlink" title="R：一直替换光标所在的文字，直到按下ESC为止"></a><code>R</code>：一直替换光标所在的文字，直到按下ESC为止</h4><p>按下<code>R</code>再按三次<code>_</code>再按<code>Esc</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/r11.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/r22.png"></div><h3 id="退出编辑模式"><a href="#退出编辑模式" class="headerlink" title="退出编辑模式"></a>退出编辑模式</h3><p>在编辑模式下按 Esc 键。</p><h3 id="退出命令模式"><a href="#退出命令模式" class="headerlink" title="退出命令模式"></a>退出命令模式</h3><p>需要使用转义字符<code>:</code></p><ul><li><code>:q</code>：若未修改文件，此命令可以退出编辑器。</li><li><code>:wq</code>：把编辑缓冲区的内容写入文件中，退出编辑器，回到Shell下。</li><li><code>:ZZ</code>或<code>:x</code>：仅当作过修改时才将缓冲区内容写到文件上。</li><li><code>:q!</code>： 强行退出vi。告诉vi，无条件退出，丢弃缓冲区内容。</li></ul><h2 id="vim流程图"><a href="#vim流程图" class="headerlink" title="vim流程图"></a>vim流程图</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/vim流程图.png"></div><h2 id="命令模式下的光标跳转"><a href="#命令模式下的光标跳转" class="headerlink" title="命令模式下的光标跳转"></a>命令模式下的光标跳转</h2><ol><li>方向键和Backspace键的使用和正常情况下相同。</li><li>移动到上一行，列不变：<code>k</code></li><li>移动到上一行行头：<code>-</code></li><li>移动到下一行，列不变：<code>j</code></li><li>移动到下一行行头：<code>+</code></li><li>如果在相应命令的前面加上一个数字<code>n</code>，相应命令执行<code>n</code>次。如<code>2k</code>表示向上移动两行，列不变。</li><li>移至行首：<code>^</code>或<code>0</code></li><li>移至行尾：<code>$</code></li><li>移至指定行：行号<code>G</code>。如<code>2G</code>，移动到第二行行首。</li><li>移至指定列：列号<code>|</code>。如<code>2|</code>，移动到本行第2列。</li></ol><h2 id="文本删除"><a href="#文本删除" class="headerlink" title="文本删除"></a>文本删除</h2><ol><li>命令<code>x</code>（小写字母）删除光标所在的字符。</li><li>命令<code>X</code>（大写字母）删除光标前面的那个字符</li><li>命令<code>dd</code>删除光标所在的整行</li><li>命令<code>D</code>从光标位置开始删除到行尾</li><li><code>d&lt;光标移动命令&gt;</code>删除从光标位置开始至光标移动命令之间的所有字符。如：<ol><li><code>d0</code>：从光标位置（不包括光标位）删至行首。</li><li><code>d3l</code>：从光标位置（包括光标位）向右删3个字符。</li><li><code>d$</code>：从光标位置（包括光标位）删至行尾。与D相同。</li><li><code>d5G</code>：将光标所在行至第5行都删除。</li></ol></li></ol><h2 id="复原命令"><a href="#复原命令" class="headerlink" title="复原命令"></a>复原命令</h2><ol><li><code>u</code>：取消前面刚执行的插入或删除命令的效果，恢复到此前的情况。</li><li><code>U</code>：总是把当前行恢复成它被编辑之前的状态。</li></ol><h2 id="重复命令"><a href="#重复命令" class="headerlink" title="重复命令"></a>重复命令</h2><p><code>.</code>：在命令模式下，重复执行前一次插入命令或删除命令</p><h2 id="补充文本编辑"><a href="#补充文本编辑" class="headerlink" title="补充文本编辑"></a>补充文本编辑</h2><h3 id="命令方式下"><a href="#命令方式下" class="headerlink" title="命令方式下"></a>命令方式下</h3><ol><li><code>d0</code>：删至行首</li><li><code>d$</code>：删至行尾</li><li><code>ndd</code>：删除当前行及其后的n-1行</li><li><code>yy</code>：复制当前行的文本</li><li><code>10yy</code>：复制包括当前行及其后面9行文本</li><li><code>p</code>：在当前行后面插入一个空行，把缓冲区的内容粘贴过来</li><li><code>P</code>：在当前行前面插入一个空行，把缓冲区的内容粘贴过来</li></ol><h3 id="ex转移方式下"><a href="#ex转移方式下" class="headerlink" title="ex转移方式下"></a>ex转移方式下</h3><ol><li><code>:n1,n2 d</code>：将n1行到n2行的内容删除</li><li><code>:n1,n2 co n3</code>：将n1行到n2行的内容复制到n3行下</li><li><code>:n1,n2 m n3</code>：将n1行到n2行的内容移到n3行下</li></ol><h2 id="字符串检索"><a href="#字符串检索" class="headerlink" title="字符串检索"></a>字符串检索</h2><ul><li>向下检索：/模式〈Enter〉。例如：/int</li><li>向上检索：?模式〈Enter〉。例如：?flout</li></ul><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><ol><li><code>:n1,n2s/word1/word2/g</code>：<code>n1</code>和<code>n2</code>为数字。在<code>n1</code>与<code>n2</code>行之间寻找<code>word1</code>这个字符串，并将该字符串替换为<code>word2</code>。例如<code>:100,200s/a/A</code>在100行到200行之间搜索a并替换成A。</li><li><code>:1,$s/word1/word2/gc</code>：全局搜索word1，替换成word2。<code>g</code>改成<code>gc</code>表示要用户确认。</li><li><code>:%s/$/s2/g</code>：在整个行的末尾添加s2。</li><li>全局替换命令g：<code>:g/模式/命令表</code>。</li><li><code>:g/s1/p</code>：打印文本中有s1的行。p命令表示打印。</li></ol><h2 id="块选择"><a href="#块选择" class="headerlink" title="块选择"></a>块选择</h2><p><code>ctrl+v</code>，然后使用方向键选择块。</p><ol><li><code>y</code>：复制反白的地方</li><li><code>d</code>：将反白的地方删除掉</li><li><code>p</code>：插入复制的内容</li></ol><p>参考：<a href="https://jingyan.baidu.com/article/84b4f565c6b9e560f6da3291.html。" target="_blank" rel="noopener">https://jingyan.baidu.com/article/84b4f565c6b9e560f6da3291.html。</a></p><h2 id="Linux的进程状态"><a href="#Linux的进程状态" class="headerlink" title="Linux的进程状态"></a>Linux的进程状态</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/Linux进程管理.png"></div><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p><code>Process Status</code>。查看进程状态的最常用的命令，它可以提供关于进程的许多信息。</p><ul><li><p>直接用ps命令可以列出每个与你的当前Shell有关的进程的基本信息。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ps.png"></div></li><li><p><code>ps -ef</code>：显示系统中所有进程的全面信息。</p><ul><li><p><code>-e</code>：显示所有进程</p></li><li><p><code>-f</code>：全格式</p></li><li><p>用户ID、进程ID、父进程ID、CPU占用率、开始时间、开始此进程的终端设备、此进程运行的总时间、命令名。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/psef.png"></div></li></ul></li><li><p><code>ps aux</code>显示所有终端上所有用户的有关进程的所有信息。</p></li></ul><h2 id="终结进程"><a href="#终结进程" class="headerlink" title="终结进程"></a>终结进程</h2><ul><li>通常来说，终结一个前台进程可以使用<code>Ctrl+C</code>。</li><li>终结一个后台进程得使用<code>kill</code>命令。<code>kill &lt;进程号&gt;</code>。如果想强制杀掉一个进程需要使用-9：<code>kill -9 &lt;进程号&gt;</code></li></ul><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>使进程暂停由时间值所指定的秒数。此命令大多用于shell程序设计中，使两条命令执行之间停顿指定的时间。如：<code>sleep 100; who | grep &#39;root&#39;</code>。</p><h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p><code>wait</code>是用来阻塞当前进程的执行，直至指定的子进程执行结束后，才继续执行。</p><ul><li><code>wait [进程号 或 作业号]</code>：eg：wait 23 or wait %1</li><li>如果<code>wait</code>后面不带任何的进程号或作业号，那么<code>wait</code>会阻塞当前进程的执行，直至当前进程的所有子进程都执行结束后，才继续执行。</li></ul><h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p>fork()函数会创建一个和原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事。但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。fork()调用一次，<strong>分别向父子进程返回</strong>，它可能有三种不同的返回值：</p><ul><li>在父进程中，fork()返回新创建子进程的进程ID；</li><li>在子进程中，fork()返回0；</li><li>如果出现错误，fork()返回一个负值；</li></ul><p>所以我们可以通过fork返回的值来判断当前进程是子进程还是父进程。同时每个进程都有一个互不相同的进程标识符（process ID），可以通过getpid()函数获得，还有一个记录父进程pid的变量，可以通过getppid()函数获得变量的值。</p><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t1代码.png"></div><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t1结果.png"></div><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>程序运行到第7行，创建一个新的进程，克隆一份当前进程。向父进程返回子进程的pid，向子进程返回0。所以执行后父进程进入第3个分支，子进程进入第2个分支。</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><h3 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t2代码.png"></div><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t2结果.png"></div><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t2分析.png"></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><h3 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t3代码.png"></div><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t3结果.png"></div><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t3分析.png"></div><h2 id="题4"><a href="#题4" class="headerlink" title="题4"></a>题4</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t4.jpg"></div><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>执行第5行之后，向父进程返回真，向子进程返回假，但是没有任何影响，此时创建了一个进程，之后父子进程创建的进程个数相同，所以只分析一个再乘以2即可。第一个子进程分析结果如下图。注意，对于<code>A &amp;&amp; B || C</code>：</p><ul><li>表达式A为假，B不执行，C执行；</li><li>表达式A为真，B执行：<ul><li>B为真：C不执行；</li><li>B为假：C执行。</li></ul></li></ul><p>所以答案是<code>1+9*2=19</code>个。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t4图.png"></div><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Shell是一个命令解释器，用户输入命令来获得自己想要的结果，但是终端中输入的命令很难进行高级语言的选择、循环等操作。不过Shell程序可以存放在文件上，称为Shell脚本（虽然Linux文件不以后缀名区分文件类型，但是一般编写Shell脚本时文件名会命名为以<code>.sh</code>结尾）。在脚本中可以较方便的进行类似高级语言的操作。</p><h2 id="最简单的Shell脚本"><a href="#最简单的Shell脚本" class="headerlink" title="最简单的Shell脚本"></a>最简单的Shell脚本</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/最简单shell脚本.jpg"></div><p>我们都知道，直接在终端输入<code>echo</code>命令是回显参数，把<code>echo</code>命令放在shell脚本中有相同的效果。</p><h2 id="设置成可执行文件"><a href="#设置成可执行文件" class="headerlink" title="设置成可执行文件"></a>设置成可执行文件</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/设置为可执行文件.png"></div><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Shell脚本中的变量直接使用<code>=</code>便可创建，使用<code>$</code>解析变量名。<code>{}</code>是分组命令，表示<code>H</code>是一个变量，这里不加也可以。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/变量.jpg"></div><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><ul><li><code>$#</code>：除脚本名外，命令行上参数的个数。</li><li><code>$*</code>：表示在命令行上实际给出的所有实参。<ul><li>如：<code>exam3.sh A B C D E F G H I J K</code>。<code>$#</code>是11。<code>$*</code>是： A B C D E F G H I J K</li></ul></li><li><code>$n</code>：表示命令行上第n个参数<ul><li><code>$0</code>表示文件名 <code>$1</code>表示第一个参数 …</li></ul></li><li><code>$@</code>：表示在命令行上实际给出的所有实参。<ul><li>如：<code>exam3.sh A B C D E F G H I J K</code>。<code>$@</code>就是： “A” “B” “C” “D” “E” “F” “G” “H” “I” “J” “K”</li></ul></li><li><code>$$</code>：当前进程的进程号</li><li><code>$!</code>：上一个后台命令对应的进程号。</li><li><code>$?</code>：上一条前台命令执行后的返回值。</li></ul><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><p>执行算术运算需要使用let，如<code>let c=$a+$b</code>。可以使用<code>c=$(($a+$b))</code>代替。其中算术运算符及优先级等同于C语言。同时多了个<code>**</code>表示幂运算。（运算符前后不要有空格）</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/算术运算符.jpg"></div><h2 id="从命令行读入参数"><a href="#从命令行读入参数" class="headerlink" title="从命令行读入参数"></a>从命令行读入参数</h2><p>直接使用read，命令行中的参数会读到read后面跟的参数（相当于变量）里。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/read.jpg"></div><p>读入时输出提示信息：</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/readp.jpg"></div><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><ul><li><p>双引号：由双引号引起来的字符（除<code>$</code>、<code>`和`\`）都被当做普通字符对待。</code></p><ul><li><code>$</code>表示变量替换；</li><li><code></code> `表示命令替换；</li><li><code>\</code>之后的字符只有是<code>$</code>、<code></code> <code>、</code>双引号<code>、</code>`或<code>换行符</code>之一时会成为转义字符。其他情况都是<code>\</code>本身。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/引号.jpg"></div></li><li><p>单引号：单引号引起来的字符都是普通字符。特殊字符也失效。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/单引号.jpg"></div></li><li><p>倒引号：被到引号引起来的字符被解释为命令。如上上图中所示。</p></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>变量之间使用空格隔开各个元素。如果元素中有空格，使用双引号引起来。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/数组.jpg"></div><h2 id="测试条件"><a href="#测试条件" class="headerlink" title="测试条件"></a>测试条件</h2><p>任何命令都可以作为条件，shell会执行这个命令并检查返回值，如果命令成功（返回值为0），表示真。</p><ul><li><code>test &lt;条件&gt;</code>：如<code>test n1 -eq n2</code></li><li><code>[ 条件 ]</code>：如<code>[ n1 -eq n2 ]</code></li></ul><h3 id="有关文件方面的测试"><a href="#有关文件方面的测试" class="headerlink" title="有关文件方面的测试"></a>有关文件方面的测试</h3><ul><li><code>-r 文件名</code>：真 &lt;==&gt; 文件存在并且是用户可读</li><li><code>-w 文件名</code>：真 &lt;==&gt; 文件存在并且是用户可写</li><li><code>-x 文件名</code>：真 &lt;==&gt; 文件存在并且用户可执行</li><li><code>-f 文件名</code>：真 &lt;==&gt; 文件存在且是普通文件</li><li><code>-d 文件名</code>：真 &lt;==&gt; 文件存在且是目录文件</li><li><code>-s 文件名</code>：真 &lt;==&gt; 文件存在且长度大于0</li></ul><h3 id="有关字符串方面的测试"><a href="#有关字符串方面的测试" class="headerlink" title="有关字符串方面的测试"></a>有关字符串方面的测试</h3><ul><li><code>-z s1</code>：真 &lt;==&gt; 字符串长度为0</li><li><code>-n s1</code>：真 &lt;==&gt; 字符串长度大于0</li><li><code>s1</code>：真 &lt;==&gt; 字符串不是空字符串</li><li><code>s1 = s2</code>（在“=”前后应有空格）：真 &lt;==&gt; 字符串相等</li><li><code>s1 != s2</code>：真 &lt;==&gt; 字符串不等</li><li><code>s1 &lt; s2</code>：真 &lt;==&gt; 按字典顺序s1在s2之后</li><li><code>s1 &gt; s2</code>：真 &lt;==&gt; 按字典顺序s1在s2之前</li></ul><h3 id="数值方面的测试"><a href="#数值方面的测试" class="headerlink" title="数值方面的测试"></a>数值方面的测试</h3><ul><li><code>n1 -eq n2</code>：真 &lt;==&gt; 数值相等</li><li><code>n1 -ne n2</code>：真 &lt;==&gt; 数值不等</li><li><code>n1 -lt n2</code>：真 &lt;==&gt; n1小于n2</li><li><code>n1 -le n2</code>：真 &lt;==&gt; n1小于或等于n2</li><li><code>n1 -gt n2</code>：真 &lt;==&gt; n1大于n2</li><li><code>n1 -ge n2</code>：真 &lt;==&gt; n1大于或等于n2</li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><code>!</code>：逻辑非</li><li><code>-a</code>：逻辑与</li><li><code>-o</code>：逻辑或</li><li><code>(表达式)</code>：圆括号括起来表示为一条语句</li></ul><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/选择结构.jpg"></div><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/循环结构.png"></div><h2 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h2><p>和C语言一致。</p><h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><p>参数跳转命令：不跟数组默认跳转1位，跟了跳转n位。</p><table><thead><tr><th style="text-align:center">命令行</th><th style="text-align:center">ex.sh</th><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">F</th></tr></thead><tbody><tr><td style="text-align:center">原位置参数</td><td style="text-align:center">$0</td><td style="text-align:center">$1</td><td style="text-align:center">$2</td><td style="text-align:center">$3</td><td style="text-align:center">$4</td><td style="text-align:center">$5</td><td style="text-align:center">$6</td></tr><tr><td style="text-align:center">移位后参数</td><td style="text-align:center">$0</td><td style="text-align:center"></td><td style="text-align:center">$1</td><td style="text-align:center">$2</td><td style="text-align:center">$3</td><td style="text-align:center">$4</td><td style="text-align:center">$5</td></tr></tbody></table><p>还可以用于循环结构的done上面，表示每次选择指定参数。</p><h2 id="参数置换变量"><a href="#参数置换变量" class="headerlink" title="参数置换变量"></a>参数置换变量</h2><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">var1为空</th><th style="text-align:center">var1不空</th></tr></thead><tbody><tr><td style="text-align:center"><code>var2=${var1:-str}</code></td><td style="text-align:center">var2=str。var1不变</td><td style="text-align:center">var2=$var1。var1不变</td></tr><tr><td style="text-align:center"><code>var2=${var1:=str}</code></td><td style="text-align:center">var2=var1=str</td><td style="text-align:center">var2=$var1。var1不变</td></tr><tr><td style="text-align:center"><code>var2=${var1:+str}</code></td><td style="text-align:center">var2为空。var1不变</td><td style="text-align:center">var2=str。var1不变</td></tr><tr><td style="text-align:center"><code>var2=${var1:?str}</code></td><td style="text-align:center">输出：“shell 脚本名:var1:str”并退出shell。var2不变</td><td style="text-align:center">var2=$var1。var1不变</td></tr></tbody></table><h2 id="ex1"><a href="#ex1" class="headerlink" title="ex1"></a>ex1</h2><p>编写ex1.sh，参数为一个大于 20 的正整数。先检查参数是否符合要求。如果不符合要求，请给出提示；如果符合要求，输出这个参数的平方。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex1.jpg"></div><h2 id="ex2"><a href="#ex2" class="headerlink" title="ex2"></a>ex2</h2><p>编写ex2.sh，首先显示当天日期，然后查找给定的用户是否在系统中工作（who 命令）。如果在系统中，就输出一条欢迎语句（例如 hello，xxxx！）；如果不在系统中，就输出一条语句（waiting for xxx！）</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex2.jpg"></div><h2 id="ex3"><a href="#ex3" class="headerlink" title="ex3"></a>ex3</h2><p>编写 ex3.sh，该脚本接受一个参数。若改参数不是目录，则给出提示信息；否则使用<code>ll</code>命令列出该目录下的内容，并输出有多少个子目录（<code>d</code>开头），多少个普通文件（<code>-</code>开头）。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex3.jpg"></div><h2 id="ex4"><a href="#ex4" class="headerlink" title="ex4"></a>ex4</h2><p>编写 ex4.sh，将第一个参数指定的内容 copy 到第二个参数指定地点。</p><ul><li>若第一个参数是目录，自动添加<code>-r</code>选项（即把目录下的所有内容都 copy 过去）；</li><li>若第一个参数是普通文件，则将其 copy 到指定地点；</li><li>若第一个参数指定的文件或目录不存在，则报错；</li><li>若第二个参数指定的文件或目录已经存在，则提示是否替换，若选择 yes，则先删除原来的文件或目录，然后再执行 copy 操作，否则放弃。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex41.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex42.png"></div><h2 id="ex5"><a href="#ex5" class="headerlink" title="ex5"></a>ex5</h2><p>编写 ex5.sh。检查命令行的第一个参数是否是<code>-b</code>或者<code>-s</code>。</p><ul><li>如果是<code>-b</code>，则计算由第二个参数指定的文件中以 b 开头的行数。</li><li>如果是<code>-s</code>，则计算由第二个参数指定的文件中以 s 开头的行数。否则显示选择有错的信息。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex5.jpg"></div><h2 id="ex6"><a href="#ex6" class="headerlink" title="ex6"></a>ex6</h2><p>编写 ex6.sh。该脚本需要输入两个文件的名称，然后由用户选择相应的操作（若两个参数中任何一个不是普通文件，则报错）。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex61.png"></div><h3 id="cat：输出两个文件的内容"><a href="#cat：输出两个文件的内容" class="headerlink" title="cat：输出两个文件的内容"></a>cat：输出两个文件的内容</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex62.png"></div><h3 id="statistic：统计两个文件分别有多少行"><a href="#statistic：统计两个文件分别有多少行" class="headerlink" title="statistic：统计两个文件分别有多少行"></a>statistic：统计两个文件分别有多少行</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex63.png"></div><h3 id="merge：将第-1-个文件的内容合并到第-2-个文件后面"><a href="#merge：将第-1-个文件的内容合并到第-2-个文件后面" class="headerlink" title="merge：将第 1 个文件的内容合并到第 2 个文件后面"></a>merge：将第 1 个文件的内容合并到第 2 个文件后面</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex64.png"></div><h3 id="copy：将第-1-个文件的内容-copy-到第-2-个文件（覆盖原文件）"><a href="#copy：将第-1-个文件的内容-copy-到第-2-个文件（覆盖原文件）" class="headerlink" title="copy：将第 1 个文件的内容 copy 到第 2 个文件（覆盖原文件）"></a>copy：将第 1 个文件的内容 copy 到第 2 个文件（覆盖原文件）</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex65.png"></div><h3 id="bye：退出"><a href="#bye：退出" class="headerlink" title="bye：退出"></a>bye：退出</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex66.png"></div><h2 id="1ex"><a href="#1ex" class="headerlink" title="1ex"></a>1ex</h2><p>编写 1ex.sh，利用 for 循环将当前目录下的.c 文件移动到指定的目录下，完成后显示指定目录下的文件内容，并按文件从小到大排序。(ll -r -S）</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/1ex.jpg"></div><h2 id="2ex"><a href="#2ex" class="headerlink" title="2ex"></a>2ex</h2><p>编写 2ex.sh，显示 Fibonacci 数列的前 10 项及其总和。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/2ex.jpg"></div><h2 id="3ex"><a href="#3ex" class="headerlink" title="3ex"></a>3ex</h2><p>编写 ex3.sh，判断给定的参数是否是素数。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/3ex.jpg"></div><h2 id="4ex"><a href="#4ex" class="headerlink" title="4ex"></a>4ex</h2><p>编写 ex4.sh，将给定的参数转换成二进制表示。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/4ex.jpg"></div><h2 id="5ex"><a href="#5ex" class="headerlink" title="5ex"></a>5ex</h2><p>ex5.sh假设存在一个<code>/homework</code>的文件夹，其中包含一个 studentlist.csv的文件，当中存放了若干学生的学号，每个一行。例如：150341101、150341102、150341105、150341106，编写 ex11.sh。查看/homework 文件夹下学生是否提交了作业，假设作业名的格式为：学号_homework.txt。最后输出没提交作业的学号名单。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/5ex.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:51 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;操作系统的定义&quot;&gt;&lt;a href=&quot;#操作系统的定义&quot; class=&quot;headerlink&quot; title=&quot;操作系统的定义&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/categories/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/tags/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="面试" scheme="https://isjinhao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>03-IO流和网络</title>
    <link href="https://isjinhao.github.io/2019/03-IO%E6%B5%81%E5%92%8C%E7%BD%91%E7%BB%9C/"/>
    <id>https://isjinhao.github.io/2019/03-IO流和网络/</id>
    <published>2019-07-28T13:47:20.000Z</published>
    <updated>2019-08-22T15:06:09.792Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p></p><div align="center"><img width="90%" src="//isjinhao.github.io/2019/03-IO流和网络/2019-07-15_000310.jpg"></div><p></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayInputStream(<span class="keyword">byte</span>[] buf) </span><br><span class="line"><span class="comment">// 创建一个 ByteArrayInputStream，使用 buf 作为其缓冲区数组。 </span></span><br><span class="line">    </span><br><span class="line">ByteArrayInputStream(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length) </span><br><span class="line"><span class="comment">// 创建 ByteArrayInputStream，使用 buf 作为其缓冲区数组。 </span></span><br><span class="line"></span><br><span class="line">FileInputStream(File file) </span><br><span class="line"><span class="comment">// 通过打开一个到实际文件的连接来创建一个 FileInputStream，</span></span><br><span class="line"><span class="comment">// 该文件通过文件系统中的 File 对象 file 指定。 </span></span><br><span class="line"></span><br><span class="line">FileInputStream(String name) </span><br><span class="line"><span class="comment">// 通过打开一个到实际文件的连接来创建一个 FileInputStream，</span></span><br><span class="line"><span class="comment">// 该文件通过文件系统中的路径名 name 指定。 </span></span><br><span class="line"></span><br><span class="line">ObjectInputStream(InputStream in) </span><br><span class="line"><span class="comment">// 创建从指定 InputStream 读取的 ObjectInputStream。</span></span><br><span class="line">    </span><br><span class="line">BufferedInputStream(InputStream in) </span><br><span class="line"><span class="comment">// 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 </span></span><br><span class="line">    </span><br><span class="line">BufferedInputStream(InputStream in, <span class="keyword">int</span> size) </span><br><span class="line"><span class="comment">// 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 </span></span><br><span class="line"></span><br><span class="line">BufferedReader(Reader in) </span><br><span class="line"><span class="comment">// 创建一个使用默认大小输入缓冲区的缓冲字符输入流。 </span></span><br><span class="line"></span><br><span class="line">BufferedReader(Reader in, <span class="keyword">int</span> sz)</span><br><span class="line"><span class="comment">// 创建一个使用指定大小输入缓冲区的缓冲字符输入流。 </span></span><br><span class="line"></span><br><span class="line">CharArrayReader(<span class="keyword">char</span>[] buf) </span><br><span class="line"><span class="comment">// 根据指定的 char 数组创建一个 CharArrayReader。 </span></span><br><span class="line"></span><br><span class="line">CharArrayReader(<span class="keyword">char</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length) </span><br><span class="line"><span class="comment">// 根据指定的 char 数组创建一个 CharArrayReader。 </span></span><br><span class="line"></span><br><span class="line">StringReader(String s) </span><br><span class="line"><span class="comment">// 创建一个新字符串 reader。</span></span><br><span class="line"></span><br><span class="line">FileReader(File file) </span><br><span class="line"><span class="comment">// 在给定从中读取数据的 File 的情况下创建一个新 FileReader。 </span></span><br><span class="line"></span><br><span class="line">FileReader(String fileName) </span><br><span class="line"><span class="comment">// 在给定从中读取数据的文件名的情况下创建一个新 FileReader。 </span></span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream() </span><br><span class="line"><span class="comment">// 创建一个新的 byte 数组输出流。 </span></span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream(<span class="keyword">int</span> size) </span><br><span class="line"><span class="comment">// 创建一个新的 byte 数组输出流，它具有指定大小的缓冲区容量（以字节为单位）。 </span></span><br><span class="line"></span><br><span class="line">FileOutputStream(File file)</span><br><span class="line"><span class="comment">// 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 </span></span><br><span class="line"></span><br><span class="line">FileOutputStream(File file, <span class="keyword">boolean</span> append) </span><br><span class="line"><span class="comment">// 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 </span></span><br><span class="line"></span><br><span class="line">FileOutputStream(String name) </span><br><span class="line"><span class="comment">// 创建一个向具有指定名称的文件中写入数据的输出文件流。 </span></span><br><span class="line"></span><br><span class="line">FileOutputStream(String name, <span class="keyword">boolean</span> append) </span><br><span class="line"><span class="comment">// 创建一个向具有指定 name 的文件中写入数据的输出文件流。 </span></span><br><span class="line"></span><br><span class="line">ObjectOutputStream(OutputStream out) </span><br><span class="line"><span class="comment">// 创建写入指定 OutputStream 的 ObjectOutputStream。</span></span><br><span class="line"></span><br><span class="line">BufferedOutputStream(OutputStream out) </span><br><span class="line"><span class="comment">// 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 </span></span><br><span class="line"></span><br><span class="line">BufferedOutputStream(OutputStream out, <span class="keyword">int</span> size) </span><br><span class="line"><span class="comment">// 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 </span></span><br><span class="line"></span><br><span class="line">PrintStream(File file) </span><br><span class="line"><span class="comment">// 创建具有指定文件且不带自动行刷新的新打印流。 </span></span><br><span class="line"></span><br><span class="line">PrintStream(File file, String csn) </span><br><span class="line"><span class="comment">// 创建具有指定文件名称和字符集且不带自动行刷新的新打印流。 </span></span><br><span class="line"></span><br><span class="line">PrintStream(OutputStream out) </span><br><span class="line"><span class="comment">// 创建新的打印流。 </span></span><br><span class="line"></span><br><span class="line">PrintStream(OutputStream out, <span class="keyword">boolean</span> autoFlush) </span><br><span class="line"><span class="comment">// 创建新的打印流。 </span></span><br><span class="line"></span><br><span class="line">PrintStream(OutputStream out, <span class="keyword">boolean</span> autoFlush, String encoding) </span><br><span class="line"><span class="comment">// 创建新的打印流。 </span></span><br><span class="line"></span><br><span class="line">PrintStream(String fileName) </span><br><span class="line"><span class="comment">// 创建具有指定文件名称且不带自动行刷新的新打印流。 </span></span><br><span class="line"></span><br><span class="line">PrintStream(String fileName, String csn) </span><br><span class="line"><span class="comment">// 创建具有指定文件名称和字符集且不带自动行刷新的新打印流。 </span></span><br><span class="line"></span><br><span class="line">BufferedWriter(Writer out) </span><br><span class="line"><span class="comment">// 创建一个使用默认大小输出缓冲区的缓冲字符输出流。 </span></span><br><span class="line"></span><br><span class="line">BufferedWriter(Writer out, <span class="keyword">int</span> sz) </span><br><span class="line"><span class="comment">// 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。 </span></span><br><span class="line"></span><br><span class="line">CharArrayWriter() </span><br><span class="line"><span class="comment">// 创建一个新的 CharArrayWriter。 </span></span><br><span class="line"></span><br><span class="line">CharArrayWriter(<span class="keyword">int</span> initialSize) </span><br><span class="line"><span class="comment">// 创建一个具有指定初始大小的新 CharArrayWriter。 </span></span><br><span class="line"></span><br><span class="line">StringWriter() </span><br><span class="line"><span class="comment">// 使用默认初始字符串缓冲区大小创建一个新字符串 writer。 </span></span><br><span class="line"></span><br><span class="line">StringWriter(<span class="keyword">int</span> initialSize) </span><br><span class="line"><span class="comment">// 使用指定初始字符串缓冲区大小创建一个新字符串 writer。 </span></span><br><span class="line"></span><br><span class="line">FileWriter(File file) </span><br><span class="line"><span class="comment">// 根据给定的 File 对象构造一个 FileWriter 对象。 </span></span><br><span class="line"></span><br><span class="line">FileWriter(File file, <span class="keyword">boolean</span> append) </span><br><span class="line"><span class="comment">// 根据给定的 File 对象构造一个 FileWriter 对象。 </span></span><br><span class="line"></span><br><span class="line">FileWriter(String fileName) </span><br><span class="line"><span class="comment">// 根据给定的文件名构造一个 FileWriter 对象。 </span></span><br><span class="line"></span><br><span class="line">FileWriter(String fileName, <span class="keyword">boolean</span> append) </span><br><span class="line"><span class="comment">// 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(File file) </span><br><span class="line"><span class="comment">// 使用指定文件创建不具有自动行刷新的新 PrintWriter。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(File file, String csn) </span><br><span class="line"><span class="comment">// 创建具有指定文件和字符集且不带自动刷行新的新 PrintWriter。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(OutputStream out) </span><br><span class="line"><span class="comment">// 根据现有的 OutputStream 创建不带自动行刷新的新 PrintWriter。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(OutputStream out, <span class="keyword">boolean</span> autoFlush) </span><br><span class="line"><span class="comment">// 通过现有的 OutputStream 创建新的 PrintWriter。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(String fileName) </span><br><span class="line"><span class="comment">// 创建具有指定文件名称且不带自动行刷新的新 PrintWriter。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(String fileName, String csn) </span><br><span class="line"><span class="comment">// 创建具有指定文件名称和字符集且不带自动行刷新的新 PrintWriter。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(Writer out) </span><br><span class="line"><span class="comment">// 创建不带自动行刷新的新 PrintWriter。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(Writer out, <span class="keyword">boolean</span> autoFlush) </span><br><span class="line"><span class="comment">// 创建新 PrintWriter。</span></span><br></pre></td></tr></table></figure><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>计算机网络就是互联的、自治的计算机集合。自治指的是所有的计算机直接没有主从关系；互联指的是互联互通，能进行数据交换。</p><p>计算机网络的本质是一种通信网络，只不过信源和信宿都是主机。它是计算机技术和通信技术的结合。</p><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>信道是数据交换的载体。狭义上说人和人之间交流所承载信息的空气就是信道。广义上说它还可以包括有关的变换装置，这样的话信道往往被分成信道编码器、信道本身和信道译码器。</p><p>简易通信系统模型如下：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/信道.png"></div><p></p><h3 id="主机（host）"><a href="#主机（host）" class="headerlink" title="主机（host）"></a>主机（host）</h3><p>诸如手机、电脑、服务器等端系统（end systems）。</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>如果想实现多个计算机之间的互联，按照之前的想法是每两台计算机进行连接，但这样太麻烦，一个好的做法是把这个计算机连接在某一中心上，这个中心把所有连接上来的计算机进行互联，在链路层这个中心叫做交换机。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/交换机.png" style="width:25%"></div><p></p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>分组是带有地址信息的信息小片，可以理解成是计算机把一个文件切片后打成的包裹，由两部分构成：地址信息和真正传输的东西。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/分组.jpg"></div><p></p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>是计算机网络的一种专用计算机，它只有一个功能，就是转发分组。可以简单的理解为路由器是电子化的邮局，全国所有的邮局之间互联，是包裹能够传递，路由器之间互联，是分组能够正确转发。</p><p>路由器和交换机的区别是：交换机将计算机连在一起，构成局域网；路由器将局域网连在一起，形成互联网。</p><h2 id="计算机网络基本原理"><a href="#计算机网络基本原理" class="headerlink" title="计算机网络基本原理"></a>计算机网络基本原理</h2><p><strong>分组交换技术</strong>，也就是拆分分组、传输分组、合并分组的技术。</p><p>这个技术的优点就是便宜，因为把数据打包成分组和分组拆分都在计算机中进行，网络上只进行分组的转发，就使得网络的结构很简单，路由器设计也很简单。这一中原则被叫做“端到端的原则”，即能在端系统做的事情不在网络上实现。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/计算机网络基本原则.jpg" style="width:60%"></div><p></p><h3 id="分组交换技术"><a href="#分组交换技术" class="headerlink" title="分组交换技术"></a>分组交换技术</h3><ol><li>一个主机至少连接一个路由器：数据最终是通过路由器进行转发的，所以一个主机至少得连接一个路由器。</li><li>分组存储转发：分组完全进入路由器后，路由器按照地址信息检索转发表。注意不是第一个bit或Byte进入时就开始转发，是<strong>全部进入</strong>才转发。</li><li>分组独立选择路径：一个文件被分成多个分组，但这些分组之间是独立的，路由器给他们看成相互独立的数据。分组的组装是通过接收方进行的，和网络无关。</li></ol><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><h3 id="组成细节角度"><a href="#组成细节角度" class="headerlink" title="组成细节角度"></a>组成细节角度</h3><p>ISP网络互联形成的网络之网络。由运行各种网路应用的计算设备，光纤、铜缆、无线电等通信链路、路由器和交换机等组成的分组交换设备组成。</p><h3 id="服务角度"><a href="#服务角度" class="headerlink" title="服务角度"></a>服务角度</h3><p>是为网络应用提供通信服务的通信基础设施和为网络应用提供的应用编程接口。</p><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>ISP，全称为Internet Service Provider，因特网服务提供商，即指提供互联网服务的公司。能提供拨号上网服务、网上浏览、下载文件、收发电子邮件等服务。</p><h3 id="IXP"><a href="#IXP" class="headerlink" title="IXP"></a>IXP</h3><p>Internet eXchange Point，互联网交换点IXP的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</p><h2 id="网络的结构"><a href="#网络的结构" class="headerlink" title="网络的结构"></a>网络的结构</h2><ul><li><p>网络边缘：位于“网络边缘”运行网络应用程序的端系统。</p></li><li><p>接入网络、物理介质：有线或无线的通信链路。</p></li><li><p>网络核心：互联的路由器（或分组转发设备）。构成“网络之网络”的关键。</p></li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/计算机网络结构.png" style="width:30%"></div><p></p><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><p>客户/服务器应用模型：依赖于专用服务器，如Web应用。</p><p>对等应用模型：不依赖专用服务器，通信在对等实体之间进行，如P2P应用。</p><h2 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h2><p>接入网络是一种用户网络，它连接用户到特定的服务提供商并通过承载网络到达其他网络。两个被用户关心的特征：带宽（数据传输速率，bps）、独占/共享（独占是带宽为某用户独用，共享是多个用户分用同一带宽）。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/接入网络.jpg" style="width:50%"></div><p></p><h3 id="数字用户线路：DSL"><a href="#数字用户线路：DSL" class="headerlink" title="数字用户线路：DSL"></a>数字用户线路：DSL</h3><p>是以电话线为传输介质的传输技术组合。DSL技术在传递公用电话网络的用户环路上支持对称和非对称传输ADSL：上行速度较慢，下行速度较快）模式。</p><p>用DSL接入Internet时用户一方会有DSL调制解调器，被接入方会有DSL接入多路复用器与多个用户进行接入。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/DSL.png" style="width:60%"></div><p></p><h3 id="电缆网络"><a href="#电缆网络" class="headerlink" title="电缆网络"></a>电缆网络</h3><p>又被称为混合光纤同轴电缆网络。也是一种非对称式的接入网络。但它是共享网络，多个用户共同接入一个解调器。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/电缆网络.png" style="width:80%"></div><p></p><h3 id="常见网络接入"><a href="#常见网络接入" class="headerlink" title="常见网络接入"></a>常见网络接入</h3><h4 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h4><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/家庭接入.png" style="width:75%"></div><p></p><h4 id="机构（企业）接入"><a href="#机构（企业）接入" class="headerlink" title="机构（企业）接入"></a>机构（企业）接入</h4><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/企业接入.png" style="width:70%"></div><p></p><h4 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h4><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/无线局域网.png"></div><p></p><h4 id="广域局域网"><a href="#广域局域网" class="headerlink" title="广域局域网"></a>广域局域网</h4><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/广域局域网.png" style="width:40%"></div><p></p><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心的功能是：路由（routing）：确定分组从源到目的传输路径；转发（forwarding）：将分组从路由器的输入端口交换至正确的输出端口。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网络核心.png" style="width:70%"></div><p></p><h2 id="Internet结构"><a href="#Internet结构" class="headerlink" title="Internet结构"></a>Internet结构</h2><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/Internet结构.png" style="width:70%"></div><p></p><ul><li><code>一级ISP包含</code>：网通、电信等商业ISP，还包含谷歌、微软等内容提供商网络。</li><li><code>IXP</code>：全称：Internet eXchange Point，即互联网交换中心。互联网Internet是由众多的网络互相连接而形成的全球性网络，互联网交换中心负责这些不同的网络之间互相通信的交换点，是互联网的关键基础设施。</li></ul><h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>包含三个阶段：建立连接、通信、释放连接。最显著的特点是独占电路资源。最典型的是电话网络。（下图的中继线上可以存在多组用户通信，详见复用技术）</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/电路交换.png" style="width:80%"></div><p></p><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>报文交换是指把信息整个打包，然后经过存储转发送到目的地。</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>分组交换是把信息拆分成不同的分组，然后把所有的分组相继发送给路由器，路由器通过路由&amp;转发把数据传输到目的地。</p><ul><li><p>和报文交换的区别是：报文交换不拆分信息。</p></li><li><p>和电路交换的区别是：如果把每个分组看成原子单位，区别就是各分组走不同的路径，不需要独占资源。</p></li></ul><h3 id="图解三种交换"><a href="#图解三种交换" class="headerlink" title="图解三种交换"></a>图解三种交换</h3><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/图解三种交换.png" style="width:80%"></div><p></p><h3 id="分组交换的优势"><a href="#分组交换的优势" class="headerlink" title="分组交换的优势"></a>分组交换的优势</h3><ul><li><p>和报文交换相比：速度快，因为在报文交换时，同一时间只有一个路由器在工作，其他路由器在等待。路由器的存储空间小，最低存储空间和分组大小差不多。</p></li><li><p>和电路交换相比：分组交换允许更多用户同时使用网络，让网络资源充分共享。</p></li></ul><h3 id="分组交换的劣势"><a href="#分组交换的劣势" class="headerlink" title="分组交换的劣势"></a>分组交换的劣势</h3><p>可能产生拥塞（congestion）：分组延迟和丢失。需要协议处理可靠数据传输和拥塞控制。</p><h2 id="RFC文档"><a href="#RFC文档" class="headerlink" title="RFC文档"></a>RFC文档</h2><p>Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。目前RFC文件是由Internet Society（ISOC）赞助发行。基本的互联网通信协议都有在RFC文件内详细说明。RFC文件还额外加入许多的论题在标准内，例如对于互联网新开发的协议及发展中所有的记录。因此几乎所有的互联网标准都有收录在RFC文件之中。</p><h2 id="IETF"><a href="#IETF" class="headerlink" title="IETF"></a>IETF</h2><p>全称：The Internet Engineering Task Force，国际互联网工程任务组。全球互联网最具权威的技术标准化组织，主要任务是负责互联网相关技术规范的研发和制定，是一个由为互联网技术工程及发展做出贡献的专家自发参与和管理的国际民间机构。主要任务是负责互联网相关技术标准的研发和制定，是国际互联网业界具有一定权威的网络相关技术研究团体。绝大多数国际互联网技术标准出自IETF。</p><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>network protocol。为进行网络中的数据交换而建立的规则、标准或约定。其中规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到的消息或发生的事件而产生的动作。也可以说网络协议规定了网络中所有信息的发送和接受过程。</p><h3 id="协议三要素"><a href="#协议三要素" class="headerlink" title="协议三要素"></a>协议三要素</h3><ul><li><p>语义：语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。</p></li><li><p>语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。</p></li><li><p>时序：时序是对事件发生顺序的详细说明。（也可称为“同步”）。</p></li></ul><p>总结：语义表示要做什么，语法表示要怎么做，时序表示做的顺序。</p><h2 id="速率-amp-带宽"><a href="#速率-amp-带宽" class="headerlink" title="速率 &amp; 带宽"></a>速率 &amp; 带宽</h2><ul><li>速率：又称数据率，数据传输速率或比特率。单位bps、kbps、Mbps、Gbps。</li><li>带宽：数字信道所能传输的最大数据率。单位bps等。</li></ul><h2 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h2><p>如果路由器的缓存满了，再到达的分组会被路由器丢弃，即造成丢包现象。丢包率 = 丢包数 / 已发分组数。</p><h2 id="分组延迟"><a href="#分组延迟" class="headerlink" title="分组延迟"></a>分组延迟</h2><ul><li><p>结点处理延迟：差错检测、确定输出链路；</p></li><li><p>排队延迟：等待输出链路可用、取决于路由器拥塞程度；</p></li><li><p>传输延迟：分组长度/链路带宽；</p></li><li><p>传播延迟：物理链路长度/信号传输速度。</p></li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/分组延迟.jpg" style="width:60%"></div><p></p><h2 id="流量强度"><a href="#流量强度" class="headerlink" title="流量强度"></a>流量强度</h2><p>设链路带宽为R(bps)，分组长度为L(bits)，平均每组到达速率为v。则：</p><ul><li><p>$L \ast v / R \longrightarrow 0 $时：平均排队延迟很小；</p></li><li><p>$L \ast v / R \longrightarrow 1$时：平均排队延迟很大；</p></li><li><p>$L \ast v / R &gt; 1$时：超出服务能力，延迟 趋向于 无限大。</p></li></ul><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>$时延带宽积 = 传播时延 \ast 带宽$，单位：bit。实际意义是：从我们向某一信道上发送第一个bit，到这个bit被接收方接受这个时间里，发送方总共向信道上发送了多少bit。也可以称为以比特为单位的链路长度，比如某段链路长度为n比特。</p><h2 id="吞吐率-量（Throughput）"><a href="#吞吐率-量（Throughput）" class="headerlink" title="吞吐率/量（Throughput）"></a>吞吐率/量（Throughput）</h2><p>发送端与接收端之间的传送数据率（b/s）。端到端的吞吐量取决于瓶颈链路。</p><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><p>指通信系统的整体设计，它为网络硬件、软件、协议、存取控制和拓扑提供标准。</p><p>计算机网络是一个非常复杂的系统，需要解决的问题很多并且性质各不相同。所以，在设计时，就使用了“分层”的思想，即将庞大而复杂的问题分为若干较小的易于处理的局部问题。各层之间是按照功能进行分层的，同时每层遵循相应的网络协议完成本层功能。</p><h2 id="OSI参考模型的通信过程"><a href="#OSI参考模型的通信过程" class="headerlink" title="OSI参考模型的通信过程"></a>OSI参考模型的通信过程</h2><p>七层结构：物理层、数据链路层、网络层、传输层、对话层、表示层和应用层。</p><ul><li><p>端系统需要完成七层的功能，中间系统完成三层功能。</p></li><li><p>协议之间是对等的，比如应用层的协议对发送方来说是如何把信息传输到表示层，而对接收方来说，是如何把从表示层传来的信息还原到应用层。</p></li><li>对于后四层，从逻辑上说不需要经过中间系统，所以被称为“端-端层”。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/osi.png" style="width:70%"></div><p></p><h3 id="OSI参考模型的数据封装"><a href="#OSI参考模型的数据封装" class="headerlink" title="OSI参考模型的数据封装"></a>OSI参考模型的数据封装</h3><ul><li>后六层每层在把数据向下一层传输时都会加上控制信息。而物理层不再封装，因为到达它的数据已经时二进制数据，直接传输就行。</li><li>数据链路层传送给物理层时一般加头加尾，其他层只加头。头是首部，尾是循环冗余校验。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/osi数据.png" style="width:80%"></div><p></p><h3 id="PDU"><a href="#PDU" class="headerlink" title="PDU"></a>PDU</h3><p>协议数据单元。可能包括地址：标识发送端/接收端等；差错检测编码：用于差错检测或纠正；协议控制：一些如优先级、服务质量、安全控制等信息。</p><h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p>四层结构：应用层、运输层、网际层和网络接口层。</p><p>所有的应用都架构在IP上，在网络接口层只要能构建IP，能进行分组就可以算是网络的一部分，这是互联网发展迅速的一大原因。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/TCPIP模型.png" style="width:70%"></div><p></p><h2 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h2><p>五层结构：物理层、链路层、网络层、传输层和应用层。此模型结合了OSI概念清晰，分工明确的优点和TCP/IP简单实用的优点。</p><h3 id="五层传输模型的数据封装"><a href="#五层传输模型的数据封装" class="headerlink" title="五层传输模型的数据封装"></a>五层传输模型的数据封装</h3><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/五层模型.png" style="width:70%"></div><p></p><h3 id="三种模型对应"><a href="#三种模型对应" class="headerlink" title="三种模型对应"></a>三种模型对应</h3><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/三种模型对应.png" style="width:70%"></div><p></p><h3 id="物理层实现的功能概述"><a href="#物理层实现的功能概述" class="headerlink" title="物理层实现的功能概述"></a>物理层实现的功能概述</h3><p>核心功能：<strong>透明地传送比特流</strong>。解决的问题一般如下：</p><ul><li>接口特性：<ul><li>机械特性：接口的几何形状，位置等等；</li><li>电气特性：使用电压的高低等等；</li><li>功能特性：各个引脚的作用等等；</li><li>规程特性：工作的过程是什么样的，如哪个引脚先发送数据，哪个后发送等。</li></ul></li><li>比特编码：用信号的什么特征表示信息，如什么时候用0，什么时候用1。</li><li>数据率：在物理层上传输数据的速率。</li><li>比特同步：解决时钟同步问题，发送端何时发送数据，接收端何时接受数据。</li><li>传输模式：<ul><li>单工通信：一个为确定的发送端、一个为确定的接收端，不能互换。</li><li>半双工：发送端和接收端可以互换，但是随时间交替的。</li><li>双工：两端可以同时发送和接受数据。</li></ul></li></ul><h3 id="数据链路层功能概述"><a href="#数据链路层功能概述" class="headerlink" title="数据链路层功能概述"></a>数据链路层功能概述</h3><p>核心功能：<strong>在两个相邻结点之间的链路上“透明”地传送数据</strong>。解决的问题如下：</p><ul><li>组帧：来自网络层的数据被加头加尾后形成的数据叫做帧。组帧问题包含：头和尾里包含什么信息等。</li><li>物理寻址：物理层只进行比特流的传输，其他的都不做。物理寻址是在数据链路层做的，也就是数据链路层传输层给物理层的数据包含处理好的地址。</li><li>流量控制：使数据的发送和数据的接收尽可能平衡，防止数据太多造成丢失等。</li><li>差错处理：检测并重传损坏或丢失帧，并避免重复帧。</li><li>访问（接入）控制：在任一时刻觉得哪个设备拥有链路使用权。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/链路层.png" style="width:80%"></div><p></p><h3 id="网络层功能概述"><a href="#网络层功能概述" class="headerlink" title="网络层功能概述"></a>网络层功能概述</h3><p>核心功能：</p><ol><li>负责为分组交换网上的不同主机提供通信服务。</li><li>选择合适的路由，是源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</li></ol><p>解决的问题：</p><ul><li>逻辑寻址：全局唯一逻辑地址，确保数据分组被送达的主机，如IP地址。</li><li><p>路由和分组转发：确保在网络中数据能从源主机到目的主机</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网络层.png" style="width:70%"></div><p></p><h3 id="传输层功能"><a href="#传输层功能" class="headerlink" title="传输层功能"></a>传输层功能</h3></li></ul><p>核心功能：负责向两个主机中进程之间的通信提供服务。</p><p>解决的问题：</p><ul><li>分段与重组：网络层传输的分组大小是有限制的。应用层的</li><li>SAP寻址：确保将完整报文提交给正确进程，如端口号<ul><li>SAP：Service Access Point，在同一系统中相邻两层的实体进行交互的地方。</li></ul></li><li>连接控制：有两种协议，面向连接的TCP和无连接的UDP。</li><li>流量控制：匹配发送方和接收方的速度。</li><li>差错控制：如发送的报文接收方没有接受到或者接收方缓冲区由于满把报文丢弃该怎么处理。</li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>核心功能：直接为用户的应用进程提供服务。</p><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><h3 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h3><p>数字通信中对数字信号的计量单位。在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>假如基带信号是<code>101011000110111010...</code>，如果直接发送，则每个码元携带一个比特的信息（每个码元只有2种状态），但是如果将信号中的三个比特编为一组，即101，011，000，110，111，010…，三个比特共有8种不同的排列，我们可以用不同的调制方法来表示这种信，如8种不同的振幅，频率，相位等，如果采用相位调制，相位$\phi_0$表示000，$\phi_1$表示001，以此类推，那么接收端如果收到相位是$\phi_0$的信号就知道表示的是000，以此类推，这样一个码元就不知不觉的传输了三个比特位的信号，此时每个码元有8种状态。一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难。</p><h3 id="编码级别"><a href="#编码级别" class="headerlink" title="编码级别"></a>编码级别</h3><p>如果把n个比特编码成一个码元，则此时编码状态$M=2^n$，其表示当前传输时有多少不同的状态，如8级编码，会有：<code>000、001、010 …</code></p><h2 id="奈斯准则"><a href="#奈斯准则" class="headerlink" title="奈斯准则"></a>奈斯准则</h2><h3 id="码间串扰"><a href="#码间串扰" class="headerlink" title="码间串扰"></a>码间串扰</h3><p>码元的传输速率是有限制的，超过某上限就会出现码间串扰问题。这是由于在真正传输中，信号在传输时都不是理想化的，如下图就是理想化的高低电平和真实传输时的高低电平。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络真实和理想.jpg" style="width:50%"></div><br>假如此时速度太快，就可能把低电平和高电平弄混。而最高的码元传输速率被奈斯准则限制。<p></p><h3 id="奈斯准则内容"><a href="#奈斯准则内容" class="headerlink" title="奈斯准则内容"></a>奈斯准则内容</h3><ul><li>理想低通信道（能通过信号频率在某值之下）的最高码元传输速率为：$2W Baud$。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络低通信道.png" style="width:80%"></div><p></p><ul><li>理想带通信道（能通过信号频率在某范围之内）的最高码元传输速率为：$1W Baud$。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络带通信道.png" style="width:80%"></div><br>W是理想低通信道的带宽，单位为赫(Hz)。Baud 是波特，是码元传输速率的单位，1 波特为每秒传送 1 个码元。<p></p><h3 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h3><p>单位时间内数据通信系统所传输的码元个数（信号个数），单位是波特（Baud）。</p><h3 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h3><p>表示单位时间内数据通信系统传输的比特数，单位是比特/秒（b/s或bps）。$比特率 = 波特率 * log_2M$</p><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><h3 id="编码级数限制"><a href="#编码级数限制" class="headerlink" title="编码级数限制"></a>编码级数限制</h3><p>虽然码元传输速率有限制，但是如果我们能尽可能提高编码级数不就能提升信息传输速率了吗？但事实上信号传输速率不受限于调制技术，而是受限于信噪比。举个例子，如果我们是在天气晴朗的一天出门，我们穿任意颜色衣服都能被分辨出来，但是如果我们在沙尘暴天气出门，穿<code>橘黄</code>和<code>橙黄</code>两种颜色的衣服别人自然就认不出来了。在这个比喻中衣服的颜色代表码元，确定衣服的颜色代表信息，沙尘暴就是噪声。</p><h3 id="香农公式内容"><a href="#香农公式内容" class="headerlink" title="香农公式内容"></a>香农公式内容</h3><p>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率$C=W \ast log_2(1+PS/PN)（b/s）$。</p><ul><li>其中$W$是信道的带宽。$PS$是信号的能量。$PN$是噪声的能量。</li><li>信噪比：$S/N=10lg{PS/PN}$。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>设带宽是<code>1MHz</code>，信噪比是<code>24dB</code>，则信道的最高信息传输速率为：$C=1M \ast log_2{(1+(10^{2.4}))}=7.98Mbps$。</p><h2 id="奈氏准则vs香农公式"><a href="#奈氏准则vs香农公式" class="headerlink" title="奈氏准则vs香农公式"></a>奈氏准则vs香农公式</h2><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络香农公式和奈斯准则.png" style="width:80%"></div><p></p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>电路交换中独占电路资源，并不是指用户线和中继线都被此次交换所独占，而是说在两个用户建立连接之后，除非连接中断，否则他们当前所拥有的资源不会被释放，即使他们之间不传输信息。而如何在中继线上实现多组用户通信就是多路复用技术。</p><p>产生多路复用的物理基础是：传输媒体的带宽或容量往往会大于传输单一信号的需求，使用多路复用，为了有效地利用通信线路，希望一个信道同时传输多路信号。</p><p>这种技术会将链路/网络资源（如带宽）划分为“资源片”，将资源片分配给各路“呼叫”（calls），每路呼叫独占分配到的资源片进行通信，资源片可能“闲置”</p><p>常见的复用技术有：频分多路复用、时分多路复用、波分多路复用、码分多路复用。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络多路复用.png" style="width:80%"></div><p></p><h3 id="频分多路复用"><a href="#频分多路复用" class="headerlink" title="频分多路复用"></a>频分多路复用</h3><p>FMD：Frequency-division multiplexing，是指载波带宽被划分为多种不同频带的子信道，每个子信道可以并行传送一路信号的一种多路复用技术。也就是说信道的可用频带被分成若干个互不交叠的频段，每路信号用其中一个频段传输，因而可以用滤波器将它们分别滤出来，然后分别解调接收。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络频分多路复用.png" style="width:40%"></div><p></p><h3 id="时分多路复用"><a href="#时分多路复用" class="headerlink" title="时分多路复用"></a>时分多路复用</h3><p>TDM：time division multiplexing，它使不同的信号在不同的时间内传送，将整个传输时间分为许多时间间隔（Time Slot，TS，又称为时隙），每个时间片被一路信号占用。TDM就是通过在时间上交叉发送每一路信号的一部分来实现一条电路传送多路信号的。电路上的每一短暂时刻只有一路信号存在。因数字信号是有限个离散值，所以TDM多应用于数字通信系统。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络时分多路复用.png" style="width:70%"></div><p></p><h3 id="波分多路复用"><a href="#波分多路复用" class="headerlink" title="波分多路复用"></a>波分多路复用</h3><p>将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器（亦称合波器，Multiplexer）汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；在接收端，经解复用器（亦称分波器或称去复用器，Demultiplexer）将各种波长的光载波分离，然后由光接收机作进一步处理以恢复原信号。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络波分多路复用.png" style="width:70%"></div><p></p><h3 id="码分多路复用"><a href="#码分多路复用" class="headerlink" title="码分多路复用"></a>码分多路复用</h3><p>为每个用户分配一个唯一的mbit的码片序列（chipping sequence），二进制下的0用-1表示，二进制下的1用+1表示。在信道上传输的信号 = 原始数据 <em>码片序列，比如码片序列是：(-1, 1, 1)，需要传一个0，应该是 -1 </em>(-1, 1, 1)，所以传输的就是(1, -1, -1)。</p><p>同时为了保证数据之间不相互影响，被共享的用户所占有的码片应该相互正交的。即：$\frac{1}{m}S_i \cdot S_j = 0 (i \neq j)$。而信道上真正传输的数据是各用户发送数据的叠加值。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络码分多路复用.png" style="width:80%"></div><p></p><h3 id="数字信号在模拟信道传输"><a href="#数字信号在模拟信道传输" class="headerlink" title="数字信号在模拟信道传输"></a>数字信号在模拟信道传输</h3><p>数字信号需要编码后才能传输。常见的三种编码：</p><ol><li>NRZ编码：进制数字0、1分别用两种电平来表示。常用-5V表示1，+5V表示0。</li><li>曼切斯特编码：用电压的变化表示0和1：高→低 &lt;=&gt; 0，低→高 &lt;=&gt; 1。</li><li>差分曼切斯特编码：在码元开始处有无跳变来表示0和1：有 &lt;=&gt; 0，无 &lt;=&gt; 1。</li></ol><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络数字信号编码.png" style="width:80%"></div><p></p><h2 id="相邻"><a href="#相邻" class="headerlink" title="相邻"></a>相邻</h2><p>计算机网络中链路层的功能是“相邻节点间的数据传输”。这句话什么意思呢？我们先讨论“相邻”一词，再讨论“数据传输”。两台主机，用一根网线相连是相邻。多台主机，用一根网线相连，仍然是相邻。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网线相邻.png"></div><br>这根线缆退化成一个节点，这样的设备称为集线器。通过集线器相连的多台主机也是相邻。集线器没有任何智能，等同于线缆。在集线器上增加简单的智能控制功能，就是交换机。通过交换机相连的多台主机也是相邻。交换机将计算机互联在一起，构成局域网。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/集线器和交换机.png"></div><br>所以“相邻节点间的数据传输”换一种说法就是“构建局域网”，再换一种说法就是“局域网内的主机都是邻居关系”。链路层的功能就是构建局域网。相邻这一概念很重要，主机间的数据传输可以分为两种情况，一种是两个主机在同<br>一个局域网内，两主机是相邻关系，简称内网通信，另一种是两个主机在两个不同的网络里，可称外网通信，两种数据传输原理完全不同。本篇博文只关注内网通信。<p></p><h2 id="链路层解决的问题"><a href="#链路层解决的问题" class="headerlink" title="链路层解决的问题"></a>链路层解决的问题</h2><p>数据传输就是将一台主机内的数据传输到另一台主机，物理层解决了比特转换为电磁信号传输的问题，但这不是数据传输的全部问题，还有一些问题，例如：</p><ul><li>物理层传输中的数据有可能出错，如何处理？</li><li>发送方与接收方的速度可能不匹配，如何调节？</li><li>数据如何封装成数据帧，然后传输，如何传输封装？</li><li>发生碰撞该怎么办？</li></ul><p>针对这些问题制定的解决方案称为数据链路层的通信协议。物理链路+通信协议构成了我们要研究的数据链路。</p><h2 id="循环冗余码"><a href="#循环冗余码" class="headerlink" title="循环冗余码"></a>循环冗余码</h2><p>循环冗余码（CRC）在很多地方都被用来校验传输的数据是否出错，至于其如何证明，博主也未曾探究，下文介绍冗余码的思想和计算方法。</p><p>如果发送方只传输 87，接收方收到 82，接收方是无法判断 82 是不是发送方发送的数据，就是说无法判断 82 是对还是错。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/CRC例子8782.png"></div><br>怎么办？发送方与接收方事先商量好一个数，例如 15，发送时先计算 87 除 15 的余数，为 12，将这个余数与 87 一起发送，即 8712，接收时先计算 82 除 15 的余数，为 7，不等于 12，就认为传输的数据出错，这样检错的概率并非百分之百，例如87 错成 72 就检测不出来，但总体来说，检错概率已经非常高了。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/CRC例子87821.png"></div><p></p><h3 id="CRC-计算方法"><a href="#CRC-计算方法" class="headerlink" title="CRC 计算方法"></a>CRC 计算方法</h3><ul><li>第一，CRC 有一个生成多项式 P(x)，其作用等同于除数 15，将其写成比特串，转化规则如图：</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/生成多项式.png"></div><p></p><ul><li>第二，如果 P(x) 的比特串是 n 位，在发送数据后补 n-1 个 0。例如 P(x)为 1101，就要补 000。</li><li>第三，做模2除法。<strong>注意模二除法不是二进制除法。</strong></li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/CRC举例.png"></div><p></p><ul><li>第四，用<strong>余数</strong>替换补的 0，形成发送数据，101001001。</li><li>第五，接收方用接收数据 101001001 除以 P(x)1101，如果能整除，就表示没有错（等同与原理中的余数相同），如果不能整除，就表示出错了（等同与原理中的余数不相等）。</li></ul><h2 id="停止等待协议（Stop-and-Wait-protocol）"><a href="#停止等待协议（Stop-and-Wait-protocol）" class="headerlink" title="停止等待协议（Stop-and-Wait protocol）"></a>停止等待协议（Stop-and-Wait protocol）</h2><p>如果两个主机间数据传输时，接收方的速度永远不会低于发送方的速度；传输的数据帧不会出错，也不会丢失，完全理想化的数据传输，那就没有什么问题，当然也不需要解决问题的办法，也就不需要协议。现在假设，没有差错，但是接收方的速度低于发送方的速度，怎么办？显然控制的思路只能是快的一方牵就慢的一方，就是由慢的一方指挥快的一方。具体来说，就是发送方每发送一帧就停下来，等待；收到 ACK 发送下一帧，接收方则是等待，收到数据帧，发送 ACK（确认 Acknowledgment ），等待下一帧。停下来，等待就是停止等待协议的由来。</p><p>停止等待协议当然不仅仅需要这一个问题，其需要解决的问题如下：</p><ul><li>接收方的速度低于发送方的速度；</li><li>传输的数据帧可能出错；</li><li>数据帧可能丢失，确认帧 ACK 也可能丢失；</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/停止等待协议解决的问题.png"></div><p></p><h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p>接收方收到一个数据帧，并校验正确，给发送方一个确认 ACKn，ACKn 表示“第 n-1 号帧已经收到，现在期望接收第 n 号帧”。确认号是接收方预期接收的下一帧的序号。</p><h3 id="差错"><a href="#差错" class="headerlink" title="差错"></a>差错</h3><p>数据帧出错时，接收方收到一个数据帧，校验时发现数据帧出错，接收方丢弃此数据帧，此外不做任何事，即不发送 ACK。发送方发送完数据帧后在停止等待 ACK，然而此时不会有 ACK，发送方就等死在这里了。</p><h3 id="重传定时器"><a href="#重传定时器" class="headerlink" title="重传定时器"></a>重传定时器</h3><p>发送方设计一个重传定时器的机制，发送方每发送一个数据帧，就启动一个倒计时的重传定时器，如果在超时 timeout 之前收到确认，就关闭定时器并发送下一帧。如果超时，就重传之前的帧。</p><h3 id="丢失"><a href="#丢失" class="headerlink" title="丢失"></a>丢失</h3><p>接收方收到一个数据帧，校验正确发送 ACK，等待接收下一帧，如果确认帧丢失，发送方收不到确认，超时后重传旧帧，而接收方在等待新帧，此刻发送方与接收方的状态不同步，如何区分新帧与重传的帧？</p><h3 id="帧编号"><a href="#帧编号" class="headerlink" title="帧编号"></a>帧编号</h3><p>停等协议使用序号和确认号，以区分重传的数据帧。发送方发送帧时使用序号，接收方使用确认号。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/停止等待协议举例.png"></div><p></p><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>停止等待协议的优点是简单，但缺点是信道利用率太低。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/停止等待协议信道利用率.png"></div><br>信道利用率公式：$U=\frac{T_D}{T_D+RTT+T_A}$，其中：<p></p><ul><li>$T_D$：数据帧传输时延</li><li>$RTT$：数据帧+确认帧传播时延</li><li>$T_A$：确认帧传输时延</li></ul><p>举例：假设主机甲与主机乙使用停等协议传输数据，若甲乙之间的单向传播延迟是 15ms，数据帧长为 1000 字节，信道宽带为 100Mbps，乙每收到一个数据帧立即利用一个短帧（忽略其发送时延）进行确认，则信道利用率为：发送一个数据帧到 100Mbps 链路所需时间为：$T_D = \frac{1000 \ast 8bits}{100 \ast 10^6bit/s }= 80\mu s$。发送方在 t=0 时刻发送，15ms 后第 1 个比特到达主机乙，15.08ms 时主机乙收到最后一比特，开始发送确认帧，由于确认帧很短，我们忽略其发送时延，在30.08ms 时，确认帧到达主机甲，总时间周期为T𝐷 + RTT + T𝐴(忽略) = 30.08ms，信道利用率为0.0027。信道利用率为 0.27%，就是说发送方只有百分之0.27的时间是忙的。停止等待协议信道利用率太低了。</p><h2 id="GBN-协议"><a href="#GBN-协议" class="headerlink" title="GBN 协议"></a>GBN 协议</h2><p>我们讨论一个可以获得较高信道利用率的协议：连续 ARQ 协议(Go-back-NProtocol)，或称 GBN 协议，也称为滑动窗口协议（Sliding Window Protocol）。发送方在接收到确认之前，发送一组数据帧，而不是发送一个数据帧就停止等待确认。</p><h3 id="确认号-1"><a href="#确认号-1" class="headerlink" title="确认号"></a>确认号</h3><p>在 GBN 协议中，采用累积确认的方式，确认号是希望接收的下一个分组序号。举例，ACK7 表示序号 6 以内的所有帧都已正确收到了，等待接收 7 号帧。</p><h3 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h3><p>在 GBN 协议中，发送一组帧，然后停止等待确认。发送窗口定义了最多可以发送多少个数据帧。举例如下图：一个大小为 7 的窗口，窗口左侧是已确认，已丢弃的帧，窗口内有色的是已发送的，尚未收到确认的帧，0，1，2，3 号帧，发送方需要等待，可称为未完成帧，窗口内无色的是可发送还未发送的帧，是 4，5，6 号帧，窗口右侧是不能发送的帧。描述发送窗口需 3 个变量：</p><ul><li>$S_f$：发送窗口，第一个未完成分组。完成指的是发送方接收到确认方的确认帧。</li><li>$S_n$：发送窗口，下一个待发送分组。</li><li>$S_{size}$：发送窗口，大小。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/GBN1.png"></div><br>当 ackNo 大于等于 $S_f$ 且小于 $S_n$ 的无错 ACK 到达时，发送窗口可以滑动一个或多个槽。举例，当发送方收到 $ACK_6$，表示 4，5 号帧已正确接收，窗口滑动，状态如下图。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/GBN2.png"></div><p></p><h3 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h3><p>在 GBN 协议中，接收窗口大小总是 1。只有序号在接收窗口内的数据帧才接收。任何失序的分组都会被丢弃，需要重发。描述接收窗口控制只需 1 个变量 $R_n$，表示其期待下一次接收的帧，</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/GBN3.png"></div><p></p><h3 id="重传定时器-1"><a href="#重传定时器-1" class="headerlink" title="重传定时器"></a>重传定时器</h3><p>在 GBN 协议中，只使用一个计时器。接收窗口大小总是 1。当定时器超时，发送方重发所有未完成分组。例如，假设发送方已经发送了分组 6（$S_n=7$），但是唯一的计时器终止。如果 $S_f=3$，这意味着分组 3、4、5 和 6 没有被确认；发送方回退并重发分组 3、4、5 和 6。</p><h4 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h4><ul><li>发送分组。发送方会开启唯一的计时器。$S_n$ 的值增长，（$S_n=S_n+1$）如果达到窗口值进入阻塞状态。</li><li>如果 ACK 到达，其 ackNo 与一个未完成分组有关，那么发送方滑动窗口（令 $S_f=ackNo$），并且如果所有未完成分组都被确认（$ackNo=S_n$），那么关闭计时器。如果并不是所有未完成分组都被确认，那么重新开启计时器。</li><li>如果超时发生，发送方重发所有未完成分组并重新开启计时器。</li></ul><h4 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h4><ul><li>如果 $seqNo=R_n$ 的无错分组到达，之后窗口滑动，$R_n=（R_n+1）$。$ackNo=R_n$的 ACK 被发送。</li><li>如果 seqNo 在窗口之外的无错分组到来，分组被丢弃，但是 $ackNo=R_n$的 ACK 被发送。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/GBN4.png"></div><p></p><h3 id="发送窗口的最大值"><a href="#发送窗口的最大值" class="headerlink" title="发送窗口的最大值"></a>发送窗口的最大值</h3><p>当用 n 个比特进行帧编号时，接收窗口的大小为 1，则只有在发送窗口的大小$W_T ≤ 2^n − 1$时，连续 ARQ 协议才能正确运行。例如，当采用 2bit 编码时，发送窗口的最大值是 3 而不是 4。下图比较 4 与 3 两种情况。如果窗口的大小是 4 并且所有确认都丢失，发送方将会重传旧的所有 4 个帧。但是接收方等待接收的是新的 0 号帧，由于窗口匹配，接收 0 号帧，接收方认为接收的是新的 0 号帧，这是一个错误。如果窗口大小为 3 并且所有三个确认都丢失，那么超时并且重发所有 3 个分组，接收方现在期待 3 号帧，而不是 0 号帧，因此重传分组被正确丢弃。不会产生错误。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/GBN5.png"></div><br>为能正确区分重传的帧，应保证在$W_T+W_R$的窗口内不出现重复序号，即$W_T + W_R ≤ 2^n$，我们将 WT 和 WR 拼接在一起，在$W_T + W_R$窗口内如果出现重复序号，就会发生上述的错误，如果不出现重复的序号，就不会发生上述的错误。GBN 协议的接收窗口为 1，所以发送窗口最大为$2^n − 1$<p></p><h2 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h2><p>共享信道有一个基本问题，碰撞 （Collision）。若某时刻两帧同时发出，会相互重叠，结果使信号无法辨认，称为碰撞。如下图便是碰撞：</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/碰撞.png"></div><br>碰撞的结果是两个帧都变得无用。解决碰撞的思路大致有两类：<p></p><ul><li>一类思路是将工作做在前面，预防碰撞，即受控接入：各主机不能任意发送数据，必须服从一定的控制。如令牌环网，拥有令牌的主机可发送数据，没有令牌的主机只能接收数据，令牌如击鼓传花般依次传递。</li><li>另一类思路是将工作做在后面，撞就撞吧，做好事故的处理，即随机接入：所有主机都可以根据自己的意愿随机地发送数据。</li></ul><p>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）载波监听多点接入/碰撞检测。载波监听（Carrier Sense）指监测信道上有无数据信号传输，监测方法是判断基带上是否有脉冲二进制 0 或 1。多点接入（Multiple Access）同时有多个站点连接在信道上。显然，使用随机接入的方式是无法避免碰撞的。在随机接入的情况下，需要完成几项工作：</p><ul><li>尽量减少碰撞</li><li>是否碰撞有明确结论</li><li><p>碰撞之后的事故处理</p><p>CSMA/CD 协议完成这些工作的原理，简缩为三句口诀。</p></li><li><p>先听后发</p></li><li>边发边听</li><li>冲突重发</li></ul><h3 id="先听后发"><a href="#先听后发" class="headerlink" title="先听后发"></a>先听后发</h3><p>我们当然希望尽量减少碰撞，想个什么办法呢？就是在发送数据帧之前，先监听信道。“载波监听”就是“发送前先监听”，如果信道上有数据帧，当然就先不发送数据帧，否则一发送数据帧就产生碰撞，碰撞了就毫无意义。当监听信道时，如果信道忙有数据帧，站点回去睡一段随机时间，然后再回来监听信道，这种策略称非坚持型 CSMA。当监听信道时，如果信道忙有数据帧。站点不是回去睡一会，而是蹲守在这儿，继续监听直到信道空闲，这种策略称坚持型 CSMA。当监听到信道空闲下来时，站点立即就发送数据，称 1-坚持型 CSMA。当监听到信道空闲下来时，站点并不立即发送数据，先抛一次硬币，如果是字就发，如果是花就不发，就是说以概率 p 发送数据，称 p-坚持型 CSMA。</p><h3 id="边发边听"><a href="#边发边听" class="headerlink" title="边发边听"></a>边发边听</h3><p>站点发出数据帧后，是否碰撞需要有明确的结论。就需要“碰撞检测”（Collision Detection）。如何检测呢？站点检测信道上的信号电压大小，当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，“碰撞检测”也称为“冲突检测”。</p><p>假设 A 站点与 B 站点是网络最远的两端，从 A 站点发出一数据帧，到达 B站点的所花费的时间为$\tau$，A 站点发出一数据帧，就在即将到达 B 站的时刻，B站发出一数据帧，立即发生碰撞，碰撞信号继续到达 A 站，A 站在经过时间 $2\tau$（两倍的端到端传播时延）发现碰撞。所以，$发送站点监听时间&gt;2\tau$，就可以得到是否碰撞的明确结论。$2\tau$ 也即称为争用期，或碰撞窗口。所以为得到是否碰撞的明确结论，只需要$监听时间&gt;2\tau$就可以了。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/碰撞窗口.png"></div><p></p><h3 id="冲突重发"><a href="#冲突重发" class="headerlink" title="冲突重发"></a>冲突重发</h3><p>发生碰撞，两个数据帧都损坏，当然需要重发。但是如果两个站点都立即重发数据帧，又会再次碰撞，两个站点发送时刻最好能够错开一些。CSMA/CD 协议使用<strong>截断二进制指数退避算法</strong>，发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。</p><ul><li>重传次数 k，$k=Min[重传次数,10]$</li><li>从整数集合$[0,1,…,(2^k-1)]$中随机地取出一个数，记为 r。</li><li>重传所需的时延就是 r 倍的基本退避时间。基本退避时间一般是取为争用期。</li></ul><p>当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。使用 CSMA/CD 协议后不能进行全双工通信而只能进行双向交替通信（半双工通信）。每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</p><h2 id="10BASE-T-以太网"><a href="#10BASE-T-以太网" class="headerlink" title="10BASE-T 以太网"></a>10BASE-T 以太网</h2><p>10Base-T以太网使用的是1-坚持型CSMA / CD。</p><p>10BASE-T 以太网不用同轴电缆而用无屏蔽双绞线，降低了成本，还增加了一种可靠性非常高的设备，叫做集线器（hub）。正是这两个原因，使得 10BASE-T以太网拥有很低的成本和很高的可靠性，迅速在局域网中占据了统治地位。10BASE-T 以太网定义：</p><ul><li>争用期的长度为 51.2 us，而$监听时间 &gt; 2 \tau$ 便等价于$发送数据帧的时间 &gt; 2\tau$。可得：$\frac{帧长L}{10Mbps}&gt;51.2 \mu s$，即$L &gt; 512bit$。最短帧长 64 字节。</li><li>帧间最小间隔为 9.6us，因为要给双方留下缓冲时间。</li><li>站点到集线器的距离不超过 100m，为了保证双绞线上的信号不会出错。</li><li>如果数据帧太长就会出现有的主机长时间不能发送数据，而且有的发送数据可能超出接收端的缓冲区大小，造成缓冲溢出。为避免单一主机占用信道时间过长，规定了以太网帧的数据部分最大长度为1500。</li></ul><h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>在主机内部，需要 10BASE-T 的网络接口板又称为通信适配器（adapter）或网络接口卡 NIC(Network Interface Card)，或“网卡”。网络适配器的重要功能：</p><ul><li>对数据进行串行/并行传输的转换</li><li>编码与译码即曼彻斯特编码与译码。</li><li>链路管理主要是 CSMA/CD 协议的实现。</li><li>数据的封装与解封封装以太网帧。</li></ul><p>网卡的第一，第二项功能属于物理层的功能。第三项 CSMA/CD 协议的原理上文也介绍了，在此主要介绍一下以太网帧，也称 MAC 帧。网络适配器工作在数据链路层和物理层。生产网卡时，在网卡的 ROM 固化了 6 字节的 MAC 地址，因此 MAC 地址也叫做硬件地址(hardware address)或物理地址。MAC 地址唯一标识了一块网卡。MAC 地址字段是 6 字节（48 位），前三个字节（即高位 24 位），是生产厂家标识，称为组织唯一标识符，后三个字节（即低位 24 位）由厂家自行指派的产品串号，称为扩展唯一标识符，必须保证串号没有重复。网卡将上一层交下来的数据加上首部和尾部，成为以太网的帧。接收时将以太网的帧剥去首部和尾部，然后送交上一层。常用的以太网 MAC 帧格式有两种标准：DIXEthernetV2 标准和 IEEE 的 802.3 标准，最常用的 MAC 帧是以太网 V2 的格式。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/以太网V2格式.png"></div><p></p><h3 id="网卡工作要点"><a href="#网卡工作要点" class="headerlink" title="网卡工作要点"></a>网卡工作要点</h3><ul><li>适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中，准备发送。</li><li>若适配器检测到信道空闲，就发送这个帧。若检测到信道忙，则继续检测并等待信道转为空闲（加上 96 比特时间），然后发送这个帧。</li><li>在发送过程中继续检测信道，若一直未检测到碰撞，就顺利把这个帧成功发送完毕。若检测到碰撞，则中止数据的发送，并发送人为干扰信号。</li><li>在中止发送后，适配器就执行指数退避算法，等待 r 倍 512 比特时间后，返回到步骤 2。</li></ul><p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。早期以太网采用无源的总线结构。现在采用以太网交换机的星形结构成为以太网的首选拓扑。总线以太网使用 CSMA/CD 协议，以半双工方式工作。以太网<br>交换机以全双工方式工作，不使用共享总线，没有碰撞问题，因此不使用CSMA/CD 协议。但仍然采用以太网的帧结构。</p><h2 id="网桥与交换机"><a href="#网桥与交换机" class="headerlink" title="网桥与交换机"></a>网桥与交换机</h2><p>我们看下面一个拓扑，某学院有三个系，各自有一个以太网，三个以太网是三个独立的碰撞域，如果用集线器连成一个更大的以太网，同时也形成一个更大的碰撞域。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/碰撞扩大.png"></div><p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/碰撞扩大2.png"></div><br>连接的范围扩大了，但碰撞也多了，能不能只扩大范围，不扩大碰撞呢？<p></p><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>有一种网络设备，称为网桥（bridge），能只扩大范围，不扩大碰撞。网桥工作在数据链路层，其内部维护一张转发表，根据 MAC 地址转发数据帧。当网桥收到一个帧时，根据此帧的目的 MAC 地址，检索转发表，然后再转发帧到接口。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网桥.png"></div><br>我们看下面的一个拓扑图，先不考虑网桥的转发表是怎么来的，先看一下网桥 B1 和网桥 B2 的转发表的最终形态，可以看出，转发表的本质就是拓扑图的描述，推想一下，这是必然的，网桥若要正确转发数据帧，就需要知道各主机与其的位置关系。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网桥表.png"></div><br>那么，这张转发表又是怎么来的呢？网桥 B1 和网桥 B2 刚上电时，其内部转发表都是空表，这时，主机 A 给主<br>机 B 发送一数据帧，网桥 B1 的接口 1 收到这帧，网桥 B1 能判断出主机 A 在它的接口 1 侧，但判断不出主机 B 在哪侧，首先转发，把帧向网桥除接口 1 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“A 接口 1”填入转发表，网桥 B1 就学到 1 个条目。网桥 B2 收到网桥 B1 的转发帧，网桥 B2 也能判断出主机 A 在它的接口 1 侧，但判断不出主机 B 在哪侧，首先转发，把帧向网桥除接口 1 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“A 接口 1”填入转发表，网桥 B2 也学到 1 个条目。<p></p><p>接下来，第二个数据帧是主机 F 给主机 C 发送的，网桥 B2 的接口 2 收到这帧，网桥 B2 能判断出主机 F 在它的接口 2 侧，但判断不出主机 C 在哪侧，首先转发，把帧向网桥除接口 2 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“F 接口 2”填入转发表，网桥 B2 就学到 2 个条目。网桥 B1 收到网桥 B2 的转发帧，网桥 B1 也能判断出主机 F 在它的接口 2 侧，但判断不出主机 C 在哪侧，首先转发，把帧向网桥除接口 2 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“F 接口 2”填入转发表，网桥 B1 也学到 2 个条目。</p><p>第三个数据帧是主机 B 给主机 A 发送的，网桥 B1 的接口 1 收到这帧，网桥B1 能判断出主机 B 在它的接口 1 侧，由于已经学到 2 个条目，网桥 B1 由前 2个条目，知道主机 A 在接口 1 侧的，所以不转发。第二，将“B 接口 1”填入转发表，网桥 B2 就学到 3 个条目。因为网桥 1 没转发，网桥 B2 没收到任何数据帧，网桥 B2 仍维持着 2 个条目。</p><p>经过一段时间，各主机发送了很多数据帧，网桥 B1 和网桥 B2 就学习到了完整的转发表。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网桥表2.png"></div><br>但是需要注意，在下图中三个碰撞域内是可以进行通信，但是跨碰撞域之后还是会产生碰撞。如A给D发消息时，B和C不能进行通信。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网桥.png"></div><p></p><h3 id="交换机-1"><a href="#交换机-1" class="headerlink" title="交换机"></a>交换机</h3><p>网桥只有 2 个接口，可是谁规定网桥只能有 2 个接口呢，网桥也可以有更多接口，这就是以太网交换机，以太网交换机（switch）实质上就是一个多接口的网桥。通常都有十几个或更多的接口。每个接口都直接与一个单台主机或另一个以太网交换机相连，工作在全双工方式。以太网交换机工作原理也是按转发表转发数据帧，工作在数据链路层，是第二层交换机，其内部的帧交换表（又称为地址表）是通过自学习算法自动地逐渐建立起来的。</p><p>我们看下面的一个拓扑图，先不考虑交换机的转发表是怎么来的，先看一下交换机的转发表的最终形态，可以看出，转发表的本质就是拓扑图的描述，推想一下，这是必然的，交换机若要正确转发数据帧，就需要知道哪个接口与哪个主机相连。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/交换机表1.png"></div><br>那么，这张转发表又是怎么来的呢？交换机启动时，其内部转发表是空表。A 先向 B 发送一帧，交换机收到帧后，先执行转发功能。查找交换表，如果没有查到，洪泛，交换机向除接口 1 以外的所有的接口广播这个帧。再执学习发功能，把这个帧的源地址 A 和接口 1 写入交换表中。当所有主机都发送过数据帧后，交换机就将交换表学完整了。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/交换机表2.png"></div><br>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就自动被删除。以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。交换机工作原理是按转发表（MAC 表）转发数据帧，转发表的本质就是拓扑图的描述。要把交换机转发表的本质牢固的记住：<strong>交换机就是要知道哪个接口与哪个主机相连。</strong><p></p><h3 id="MAC-表抖动与广播风暴"><a href="#MAC-表抖动与广播风暴" class="headerlink" title="MAC 表抖动与广播风暴"></a>MAC 表抖动与广播风暴</h3><p>网桥和交换机的使用可能会发生一下问题，我们以网桥举例：</p><ul><li>会发生 MAC 表抖动（flapping）的问题：就是说同一个MAC地址在一台交换机上的两个及以上接口都学习到，导致MAC地址表中关于此MAC地址与交换机的端口对应不断改变。</li><li>数据帧会循环兜圈子，形成广播风暴。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网桥网络风暴.png"></div><br>在拓扑图上，我们可以看到 帧F 到 网桥1 的时候将 F 转发出去，设为 F1，此时 网桥1 学习 到MACA（主机A的MAC地址）在下方接口。F1 到 F2 是 网桥2 学习到 MACA 在 上方接口，但是 帧F 到达 网桥2 的时候网桥2学习到MACA在下方接口，这便是MAC表抖动。同样的 F2 到 网桥1 的时候 网桥1 学习到 MACA 在上方接口，也会发生抖动。（注意：F、F1、F2的MAC地址一致）<p></p><p>如果数据帧按照我们上面所述的方式运行，他们会在网桥1和网桥2之间不停的转圈。</p><p>至于交换机自然也会出现上述的问题。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/交换机网络风暴.png"></div><br>解决的办法，就是在逻辑上将环打断，环打断就是棵树。一句话，就是将环打断生成树，简称为“生成树”。在网桥或交换机上运行生成树协议 STP（Spanning Tree Protocol）。生成树协议的要点是：不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。<p></p><h2 id="无线局域网与-CSMA-CA"><a href="#无线局域网与-CSMA-CA" class="headerlink" title="无线局域网与 CSMA/CA"></a>无线局域网与 CSMA/CA</h2><p>IEEE802.11是一个有固定基础设施的无线局域网WLAN（Wireless Local Area Network）的国际标准。简单地说，802.11 就是无线以太网的标准：使用星形拓扑，其中心叫做接入点 AP(Access Point)，在 MAC 层使用 CSMA/CA 协议，802.11 无线局域网又称为 Wi-Fi（Wireless-Fidelity，意思是“无线保真度”）。以下讨论都是这种无线局域网。</p><p>无线局域网最小构件是基本服务集 BSS（Basic Service Set），基本服务集里面的基站叫做接入点 AP（AccessPoint，AP 的逻辑功能等同与以太网的集线器），一个基本服务集通过接入点 AP 连接到一个主干分配系统 DS（Distribution System），然后再接入到另一个基本服务集，构成了一个扩展的服务集 ESS。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/ESS.png"></div><p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/AP和集线器对等.png"></div><p></p><h3 id="无线局域网没有碰撞检测"><a href="#无线局域网没有碰撞检测" class="headerlink" title="无线局域网没有碰撞检测"></a>无线局域网没有碰撞检测</h3><p>无线局域网逻辑上也是共享信道，采用的也是随机接入的思路。但是，无线局域网与有线局域网有一个重要的差异，无线局域网没有碰撞检测（Collision Detection）。</p><ul><li>“碰撞检测”要求一个站点在发送本站数据的同时，还必须不间断地检测信道，但接收到的信号强度往往会远远小于发送信号的强度，在无线局域网的设备中要实现这种功能就花费过大。</li><li>隐蔽站问题，如下图，有 ABCD 四个站，但 A 只知道有 B，不知道有 CD。A 和 C 互相检测不到对方的无线信号时，都以为 B 是空闲的，都向 B 发送数据，结果发生碰撞。隐蔽站问题使“碰撞检测”失去意义。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/隐蔽站问题.png"></div><br>由于以上两个原因，无线局域网没有碰撞检测。为什么没有碰撞检测就成为问题了呢？因为没有碰撞检测引发了两个问题：<p></p><ul><li>怎么确定发出的数据帧是否发生碰撞，是否碰撞要有明确的结论，这个结论怎么下？</li><li>在碰撞发生时，就没有感觉，撞了发送方也不会停止发送数据，仍发送数据，直到发送完才停止。不是“撞-停”的情况，而是“撞撞撞撞撞撞···”的情况，碰撞的损失过大。</li></ul><p>这两个问题都需要解决。先说第一个问题，是否碰撞的结论怎么下？无线网使用了停止等待协议，由接收方发送 ACK 帧来表示正确收到数据帧，否则引发超时重传。再说第二个问题，对于这个问题的解决办法，当然就是“尽量不碰撞”。无线网为了“尽量不碰撞”，设计了一个复杂的协议 CSMA/CA。注意，CSMA/CA协议只能做到“尽量少碰撞”，做不到“完全不碰撞”。第一个问题仍需解决，无线网的 CSMA/CA 替代不了无线网的停等协议。</p><h3 id="CSMA-CA-协议"><a href="#CSMA-CA-协议" class="headerlink" title="CSMA/CA 协议"></a>CSMA/CA 协议</h3><p>无线局域网没有碰撞检测，所以有线的 CSMA/CD 就被阉割为 CSMA，可不甘心，还想进一步的减少碰撞，就又加了一个 CA（Collision Avoidance 碰撞避免）功能。802.11 就使用 CSMA/CA 协议。而在使用 CSMA/CA 的同时，还增加使用停止等待协议。</p><h4 id="帧间间隔-IFS"><a href="#帧间间隔-IFS" class="headerlink" title="帧间间隔 IFS"></a>帧间间隔 IFS</h4><p>所有的站在完成发送后，必须再等待一段很短的时间（继续监听）才能发送下一帧。这段时间的通称是帧间间隔 IFS（Inter Frame Space）。SIFS，即短（Short）帧间间隔，长度为 28us，使用 SIFS 的帧类型有：ACK 帧、CTS 帧。DIFS，即分布协调功能帧间间隔，长度为 128us。DIFS 用来发送数据帧和管理帧。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/IFS.png"></div><p></p><h3 id="争用窗口（二进制指数退避）"><a href="#争用窗口（二进制指数退避）" class="headerlink" title="争用窗口（二进制指数退避）"></a>争用窗口（二进制指数退避）</h3><p>信道从忙态变为空闲时，任何一个站要发送数据帧时，不仅都必须等待一个DIFS 的间隔，而且还要进入争用窗口，各站就要执行退避算法。802.11 使用二进制指数退避算法。这样做就减少了发生碰撞的概率。但其避退算法和CSMA/CD的有区别。第i次退避就在$2^{2+i}$个时隙中随机地选择一个。这就是说，第1次退避是在8个时隙（而不是2个）中随机选择一个，而第2次退避是在16个时隙（而不是4个）中随机选择一个。 这样做的目的是减少碰撞。</p><p>发送算法如下：</p><ol><li>如果某站点检测到信道空闲，会等待一个DIFS发送该帧。</li><li>否则该站点选取一个随机值进行避退，并且在检测到信道忙的时候递减该值。当检测不忙的时候计数值保持不变。</li><li>当计数值减为0的时候（此时信道一定为空闲），该站点发送整个数据帧并等待确认。</li><li>如果发送方收到确认，发送站点知道他的帧被目的站正确接收了，如果该站点要发送另一帧它需要从第二步开始进行。如果未收到，执行回退算法，此次会在一个更大的范围里选取。</li></ol><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/争用窗口.png"></div><br>需要注意，上图中的退避区间内退避算法得到的计数值不一定在减少。冻结指的就是再次检测到信道忙的时候不再减少计数值。<p></p><h3 id="信道预约"><a href="#信道预约" class="headerlink" title="信道预约"></a>信道预约</h3><p>为了更好地解决隐蔽站带来的碰撞问题，802.11 允许要发送数据的站对信道进行预约。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/信道预约.png"></div><p></p><h3 id="有线与无线的对比"><a href="#有线与无线的对比" class="headerlink" title="有线与无线的对比"></a>有线与无线的对比</h3><p>无线局域网与有线局域网都是使用随机接入的方式，都是无法绝对避免碰撞的。在这种情况下，都需要考虑以下问题：尽量减少碰撞、是否碰撞要有明确结论、碰撞之后的事故处理。简单做一对比：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/有线无线对比.png"></div><br>无线网中碰撞造成的损失更大，就需要在减少碰撞的方面做更多的工作，精心设计了 CSMA/CA 协议，包含帧间间隔，争用窗口（二进制指数退避），信道预约三种机制，但仍无法完全避免碰撞。由于没有碰撞检测，是否碰撞的明确结论，由接收方发送 ACK 确认帧机制。碰撞事故处理是空，是因为将重发中的二进制指数退避已经融合到 CSMA/CA 协议中。<p></p><h3 id="802-11-局域网的-MAC-帧"><a href="#802-11-局域网的-MAC-帧" class="headerlink" title="802.11 局域网的 MAC 帧"></a>802.11 局域网的 MAC 帧</h3><p>802.11 帧共有三种类型：控制帧、数据帧和管理帧。只简单讨论数据帧。数据帧的三大部分，MAC 首部，共 30 字节。帧的复杂性都在帧的首部。帧主体，数据部分不超过 2312 字节，通常都是小于 1500 字节。帧检验序列 FCS 是尾部，共 4 字节。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/无线网帧.png"></div><br>802.11 数据帧最特殊的地方就是有四个地址字段。地址 4 用于自组网络（博主暂未接触）。我们在这里只讨论前三种地址。地址 1 总是帧将访问的下一个设备的地址，地址 2 总是帧离开的前一个设备的地址，如果地址 1 没有定义最后的目的地址，地址 3 就是最后的目的站点的地址，如果地址 2 没有定义原始源地址，地址 3 就是原始源站点地址。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/局域网帧.png"></div><p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/无线网帧举例.png"></div><br>站点 A 向 B 发送数据帧，但这个数据帧必须经过 AP 转发。首先站点 A 发送数据帧到 AP1，然后 AP1 把数据帧发送给 B。举例：A-&gt;AP1 时：<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/111.png"></div><p></p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>ARP（Address Resolution Protocol），根据 IP 地址查询MAC 地址。ARP 协议的工作原理如下图，有 ARP 请求（Request）和 ARP 回答（Reply）两个报文。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/arp工作图解.png"></div><br>ARP 报文封装成 Mac 帧，是 Mac 帧的负载，mac 帧类型值 0806 指示 mac 帧的数据部分是 ARP 报文。ARP 请求（Request）是广播，ARP 回答（Reply）是单播，见下图：ARP 请求报文所封装的 Mac 帧，目的 Mac 地址是 FF-FF-FF-FF-FF-FF，这 个地址是广播地址，交换机就会广播这个帧。ARP 请求报文和校园广播的大喇叭是不是很像呢？如果目的主机也在你的网络里，你用大喇叭喊它，要来它的mac 地址，就可以封装 mac 帧了。注意，ARP 直接封装为 MAC 帧，不是封装为 IP 报。从这点看，我个人更赞同将 ARP 理解为链路层协议。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/arp报文举例.png"></div><br>报文格式：<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/arp格式.png"></div><p></p><h2 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h2><p>ARP 是设备通过自己知道的IP地址来获得自己不知道的物理地址的协议。假如一个设备不知道它自己的IP地址，但是知道自己的物理地址，应该怎么办呢？RARP（逆地址解析协议）正是针对这种情况的一种协议。</p><p>RARP以与ARP相反的方式工作。RARP发出要反向解析的物理地址并希望返回其对应的IP地址，应答包括由能够提供所需信息的RARP服务器发出的IP地址。虽然发送方发出的是广播信息，RARP规定只有RARP服务器能产生应答。许多网络指定多个RARP服务器，这样做既是为了平衡负载也是为了作为出现问题时的备份。</p><h2 id="网络通信分类"><a href="#网络通信分类" class="headerlink" title="网络通信分类"></a>网络通信分类</h2><p>不同主机间的数据通信可以分为三种：两个主机属于同一个网、两个主机属于相邻的两个网中、两个主机属于不相邻的两个网络中。其中第一类是链路层所解决的问题，而后两类都是网络需要解决的问题，图示如下。为了叙述方便，博主将第二类情况简称“两个网”，第三类情况简称“三个网”，但实际上“三个网”的理论可以推广到“n个网”中。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网络通信分类.png"></div><p></p><h2 id="传统的IP地址划分"><a href="#传统的IP地址划分" class="headerlink" title="传统的IP地址划分"></a>传统的IP地址划分</h2><p>传统的IP地址划分规则中，地址由两个部分组成：网络号 + 主机号。具有相同网络号的IP地址属于同一个网络。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网络号举例.png"></div><br>同时网络被划分为5类：<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/地址分类.png"></div><br>但是并不是所有的主机号都能被用来标识主机，主机号全为0的IP地址被称为网络地址，标识一个网络。主机号全为1的地址被称为广播地址，用于向某个网络的所有主机广播。例：主机 212.111.44.136 所在网络的广播地址为212.111.44.255。而对于任意一个主机若想向其所在的网络中广播都可以使用255.255.255.255。按照这个划分我们可以得到各类地址的特性：<p></p><h3 id="各类地址特性"><a href="#各类地址特性" class="headerlink" title="各类地址特性"></a>各类地址特性</h3><h4 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h4><ul><li><p>前1字节标识网络地址，后3字节标识主机地址</p></li><li><p>每个网络最多可容纳（$2^{24} －2$）台主机</p></li><li><p>从高位起，前1位为“0”，第1字节用十进制表示的取值范围为“0～127”</p></li><li><p>具有A类地址特征的网络总数为126个</p></li></ul><h4 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h4><ul><li>前2字节标识网络地址，后2字节标识主机地址</li><li>每个网络最多可容纳（$2^{16} －2$）台主机</li><li>从高位起，前2位为“10”，第1字节用十进制表示的取值范围为“128～191”</li><li>具有B类地址特征的网络总数为 $2^{14} －1$ 个</li></ul><h4 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h4><ul><li>前3字节标识网络地址，后1字节标识主机地址</li><li>每个网络最多可容纳254台主机</li><li>从高位起，前3位为“110”，第1字节用十进制表示的取值范围为“192～223”</li><li>具有C类地址特征的网络总数为 $2^{21} －1$个</li></ul><h4 id="D类地址"><a href="#D类地址" class="headerlink" title="D类地址"></a>D类地址</h4><ul><li>多播通信地址（multicast address）</li><li>从高位起，前4位为“1110”，第1字节用十进制表示的取值范围为“224－239”，用于标识multicast通信地址</li><li>后28位用于区分不同的multicast组</li></ul><h4 id="E类地址"><a href="#E类地址" class="headerlink" title="E类地址"></a>E类地址</h4><ul><li>从高位起，前4位为“1111”，第1字节用十进制表示的取值范围为“240－255”，用于标识E类地址</li><li>后28位留作它用</li></ul><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>早期的 IP 地址的设计确实不够合理。会存在如下问题：</p><ul><li>IP 地址空间的利用率有时很低。</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li><li>两级的 IP 地址不够灵活。</li><li>网络很快就被分配完了。</li></ul><p>所以从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址。但划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。其实现思路就是从主机号借用若干个比特作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个比特。</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/划分子网.png"></div><p></p><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><p>划分子网后仍然没有解决IP V4的问题，1992年互联网的三大危机：</p><ul><li>B类地址耗尽</li><li>路由表爆炸</li><li>IP地址整体耗尽</li></ul><p>无分类域间路由选择，Classless Inter-Domain Routing，是为解决上述危机而开发的一种方案。</p><p>在CIDR技术中，IP 地址由两部分组成，网络前缀 + 主机号。CIDR 还使用“斜线记法”(slash notation)，它又称为CIDR记法，即在IP地址后面加上一个斜线“/”，然后写上网络前缀所占的比特数（这个数值对应于三级编址中子网掩码中比特 1 的个数）。CIDR 将网络前缀都相同的连续的 IP 地址组成“CIDR地址块”。</p><ul><li>128.14.32.0/20 表示的地址块共有 212 个地址（因为斜线后面的 20 是网络前缀的比特数，所以主机号的比特数是 12）。</li><li>这个地址块的起始地址是 128.14.32.0。</li><li>在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”。</li><li>128.14.32.0/20 地址块的最小地址：128.14.32.0。128.14.32.0/20 地址块的最大地址：128.14.47.255</li><li>全 0 和全 1 的主机号地址一般不使用。</li></ul><h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3><p>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由，减少了路由器之间的路由信息交换。路由聚合也称为构成超网。（super netting）。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/CIDR划分IP地址.png"></div><br>这个 ISP 共有 6 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每一个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，只需用路由聚合后的 1 个项目 206.0.64.0/18 就能找到该 ISP。 需要注意的是若是因特网中某路由器想标识该ISP，只需要记录206.0.64.0/18，但是对于ISP内的路由器还是会将各子地址块的网络地址记录。<p></p><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><ul><li>使用 CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果。</li><li>应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配（longest-prefix matching）。</li><li>网络前缀越长，其地址块就越小，因而路由就越具体。</li><li>最长前缀匹配又称为最长匹配或最佳匹配。</li></ul><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>如果把计算机网络与快递网络做类比，假设东北大学是一个网络，西南大学是一个网络，东北大学想向西南大学寄点东西那么它需要通过自己学校的驿站寄到西南大学的驿站。网络之间进行通信的时候也需要有一个这种“驿站”。这便是网关。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/两个网.png"></div><br>默认网关就是为主机转发分组的路由器网络接口，就是主机的第一跳路由器，网关就是你邮信时需要找到的校园邮筒的地址，即默认网关是在网关中选一个。主机 H1 的默认网关是路由器的 E0 接口。“两个网”时，需要正确配置网关。网关是主机的第一跳路由器。举例：假设主机 H2 的 E0 接口 IP 地址 100.16.0.1，掩码 255.255.0.0，E1 接口 IP 地址 100.17.0.1，掩码 255.255.0.0：主机 H1 本地连接 IP 地址 100.16.0.2，掩码 255.255.0.0，默认网关 100.16.0.1。主机 H3 的默认网关是什么呢？100.16.0.1。主机 H5 的默认网关又是什么？是100.17.0.1。<p></p><p>在“多个网”时，多个网络如何互联？我们看下面的网络拓扑图，这是 3 个路由器连接了 4 个网络。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/多个网.png"></div><br>假设网 1 内部有一个主机 H1，网 1 内部只有一个路由器 R1，因此默认网关只能设为 R1 的 15.0.0.4，再配置好 IP 地址，就可以与外网通信了。假设网 2 内部有一个主机 H3，在网 2 内有两个路由器 R1 和 R2，可以任选一个做默认网关，假设选 R2，默认网关设为 20.0.0.9，再配置好 IP 地址，就可以与外网通信了。<p></p><p>再讨论如何配置路由器。路由器不傻，只要配置好路由器接口的 IP 地址，路由器会从接口的 IP 地址计算出网络地址，也就是说路由器能看清自己身边的网络。至于路由器是怎么看到的，在网络层-网络构建中会解释。</p><h2 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h2><p>之前说了这么多都是在做铺垫，其实主要想介绍的一点是路由器是如何转发不同网络中的数据包。算法如下：</p><ol><li>从收到的分组的首部提取目的 IP 地址 D。</li><li>先用各网络的子网掩码和 D 逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行3。</li><li>若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行4。</li><li>对路由表中的每一行的子网掩码和 D 逐位相“与”，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行5。</li><li>若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行6。</li><li>报告转发分组出错。</li></ol><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/转发举例.png"></div><br>R1的路由表：<p></p><table><thead><tr><th style="text-align:center">目的网络地址</th><th style="text-align:center">子网掩码</th><th style="text-align:center">下一跳</th></tr></thead><tbody><tr><td style="text-align:center">128.30.33.0</td><td style="text-align:center">255.255.255.128</td><td style="text-align:center">接口0</td></tr><tr><td style="text-align:center">128.30.33.128</td><td style="text-align:center">255.255.255.128</td><td style="text-align:center">接口1</td></tr><tr><td style="text-align:center">128.30.36.0</td><td style="text-align:center">255.255.255.0</td><td style="text-align:center">R2</td></tr></tbody></table><p>R2的路由表：</p><table><thead><tr><th style="text-align:center">目的网络地址</th><th style="text-align:center">子网掩码</th><th style="text-align:center">下一跳</th></tr></thead><tbody><tr><td style="text-align:center">128.30.33.0</td><td style="text-align:center">255.255.255.128</td><td style="text-align:center">R1</td></tr><tr><td style="text-align:center">128.30.33.128</td><td style="text-align:center">255.255.255.128</td><td style="text-align:center">接口0</td></tr><tr><td style="text-align:center">128.30.36.0</td><td style="text-align:center">255.255.255.0</td><td style="text-align:center">接口1</td></tr></tbody></table><p>在上图中，若H1（128.30.33.13）想给H3（128.30.36.12）发送数据，我们来分析一下具体的过程：</p><ol><li>主机 H1 首先将本子网的子网掩码 255.255.255.128与分组的 IP 地址 128.30.36.12 逐位相“与”（AND 操作）。即255.255.255.128 AND 128.30.36.12 得到 128.30.36.0，发现不等于128.30.33.0，所以他要将数据报发送到它的默认网关（128.30.33.1）上。</li><li>R1收到这个地址后，会遍历所有的子网掩码，进行按位与后再和对应的网络地址做比对。可以得到转发给R2计算过程如下：<ol><li>255.255.255.128 AND 128.30.36.12 = 128.30.36.0 不等于 128.30.33.0</li><li>255.255.255.128 AND 128.30.36.12 = 128.30.36.0 不等于 128.30.33.128、</li><li>255.255.255.0 AND 128.30.36.12 等于 128.30.36.0</li></ol></li><li>R1收到这个地址后，会遍历所有的子网掩码，进行按位与后再和对应的网络地址做比对。可以得到转发给接口1。</li><li>然后便是链路层需要解决的问题。</li></ol><h3 id="ARP深入"><a href="#ARP深入" class="headerlink" title="ARP深入"></a>ARP深入</h3><p>只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。可以分为四种情况：</p><ul><li>发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li><li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li></ul><h2 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h2><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/IP数据报的格式.png"></div><p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/IP首部.png"></div><p></p><ul><li>版本：占 4 位，指 IP 协议的版本目前的 IP 协议版本号为 4 （即 IPv4）。</li><li>首部长度：占 4 位，可表示的最大数值是 15 个单位（一个单位为 4 字节）因此 IP 的首部长度的最大值是 60 字节。</li><li>区分服务：占 8 位，用来获得更好的服务在旧标准中叫做服务类型，但实际上一直未被使用过。1998 年这个字段改名为区分服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段。</li><li>总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。</li><li>标识（identification）：占 16 位，它是一个计数器，用来产生数据报的标识。</li><li>标志（flag）：占 3 位，目前只有前两位有意义。标志字段的最低位是 MF（More Fragment）。MF = 1 表示后面“还有分片”。MF = 0 表示最后一个分片。标志字段中间的一位是 DF（Don’t Fragment）。只有当 DF=0 时才允许分片。</li><li>片偏移(13 位)指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/分片举例.png"></div><p></p><ul><li><p>生存时间（8 位）记为 TTL（Time To Live）：数据报在网络中可通过的路由器数的最大值。</p></li><li><p>协议（8 位）：指出此数据报携带的数据使用何种协议，即运输层协议。</p></li><li>首部检验和（16 位）字段只检验数据报的首部不检验数据部分。</li><li>源地址和目的地址都各占 4 字节。</li></ul><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><h3 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h3><p>在现在的网络中，IP地址分为公网IP地址和私有IP地址。公网IP是在Internet使用的IP地址，而私有IP地址则是在局域网中使用的IP地址。私有IP地址是一段保留的IP地址。只使用在局域网中，无法在Internet上使用。</p><ul><li>A类私有地址：10.0.0.0～10.255.255.255</li><li>B类私有地址：172.16.0.0～172.31.255.255</li><li>C类私有地址：192.168.0.0～192.168.255.255</li></ul><p>这些地址可以在任何组织或企业内部使用，和其他Internet地址的区别就是，仅能在内部使用，不能作为全球路由地址。这就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到Internet，就可以使用这些地址而不用向 IANA（The Internet Assigned Numbers Authority，互联网数字分配机构，是负责协调一些使Internet正常运作的机构） 提出申请，而在内部的路由管理和报文传递方式与其他网络没有差异。</p><p>对于有Internet访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署NAT网关，在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有IP地址了。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/NAT.jpg"></div><p></p><h2 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h2><p>Autonomous System，AS。每个AS由一组通常处在相同管理控制下的路由器组成。一个ISP中的路由器以及连接他们的线路可以构成一个AS，一个ISP也可以将他们的网络划分成多个AS。每个AS由一个唯一的ASN来标识。所以在构建网络的时候，我们需要对 AS 内的网络和 AS 之外的网络进行区分。这两个统称为路由协议。</p><h3 id="内部网关协议"><a href="#内部网关协议" class="headerlink" title="内部网关协议"></a>内部网关协议</h3><p>Interior Gateway Protocol （IGP），用于自治系统（AS）内部的路由交换也叫做域内路由选择（intradomain routing），如 RIP 和 OSPF 协议</p><h3 id="外部网关协议"><a href="#外部网关协议" class="headerlink" title="外部网关协议"></a>外部网关协议</h3><p>Exterior Gateway Protocol （EGP），用于不同自治系统（AS）之间的路由交换，也叫做域间路由选择（interdomain routing），目前使用最多的是 BGP-4。</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/路由选择协议.png"></div><p></p><h3 id="路由选择算法分类"><a href="#路由选择算法分类" class="headerlink" title="路由选择算法分类"></a>路由选择算法分类</h3><p>常用的分类是：每个路由器知道的是全局的信息还是分散的信息？</p><ul><li>全局的<ul><li>所有的路由器具有完整的拓扑和链路费用信息</li><li>“链路状态(L-S)”算法</li><li>应用于RIP协议</li></ul></li><li>分散的<ul><li>路由器只知道物理连接的邻居和到邻居的链路费用</li><li>迭代的计算过程，与邻居交换信息</li><li>“距离向量(D-V)”算法</li><li>应用于OSPF协议</li></ul></li></ul><h2 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h2><p>基于距离向量的分布式路由选择协议，规定：</p><ul><li>“距离”为到目的网络所经过的路由器数。</li><li>从一路由器到直接连接的网络的距离定义为 1。</li><li>RIP允许一个通路最多包含15个路由器，多于15个路由器时不可达。</li><li>RIP不能在两个网络之间同时使用多条路由，它选择一个具有最少路由器的路由，具有相同路径长度的路规定先入为主。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>仅和相邻路由器交换信息。</li><li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。</li><li>按固定的时间间隔交换路由信息，例如，每隔 30 秒。</li></ul><h3 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h3><p>收到相邻路由器（其地址为 X）的一个 RIP 报文：</p><ol><li>先修改此 RIP 报文中的所有项目：将“下一跳”字段中的地址都改为 X，并将所有的“距离”字段的值加 1。</li><li>对修改后的 RIP 报文中的每一个项目，重复以下步骤：<ul><li>若项目中的目的网络不在路由表中，则将该项目加到路由表中。</li><li>否则<ul><li>若下一跳字段给出的路由器地址是同样的，则将收到的项目替换原路由表中的项目</li><li>否则<ul><li>若收到项目中的距离小于路由表中的距离，则进行更新</li><li>否则，什么也不做。</li></ul></li></ul></li></ul></li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则将此相邻路由器记为不可达的路由器，即将距离置为16（距离为16表示不可达）。</li><li>返回。</li></ol><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>一开始，各路由表只有到相邻路由器的信息：</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/rip1.png"></div><br>路由器 B 收到相邻路由器 A 和 C 的路由表：<p></p><p>修改 A 的路由表，将 RIP 报文中的所有项目下一跳的字段都改成 A ，距离增加 1。</p><table><thead><tr><th style="text-align:center">目的网络</th><th style="text-align:center">距离</th><th style="text-align:center">下一跳</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">A</td></tr></tbody></table><p>修改 C 的路由表，将 RIP 报文中的所有项目下一跳的字段都改成 C ，距离增加 1。</p><table><thead><tr><th style="text-align:center">目的网络</th><th style="text-align:center">距离</th><th style="text-align:center">下一跳</th></tr></thead><tbody><tr><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">2</td><td style="text-align:center">C</td></tr></tbody></table><p>将 B 原来不可达的项目加入到B的路由表中，加入后B的路由表：</p><table><thead><tr><th style="text-align:center">目的网络</th><th style="text-align:center">距离</th><th style="text-align:center">下一跳</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">2</td><td style="text-align:center">C</td></tr></tbody></table><p>修改 收到的目的网络原本在B路由器中且下一跳的字段和原B路由表项目中的字段一致 的项目，发现不用修改。</p><p>修改 B 可达，A和C也可达的项目，发现收到项目中的距离小于路由表中的距离，则进行更新，否则不更新。则修改后B的路由表是：</p><table><thead><tr><th style="text-align:center">目的网络</th><th style="text-align:center">距离</th><th style="text-align:center">下一跳</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">2</td><td style="text-align:center">C</td></tr></tbody></table><h3 id="RIP-协议的优缺点"><a href="#RIP-协议的优缺点" class="headerlink" title="RIP 协议的优缺点"></a>RIP 协议的优缺点</h3><ul><li>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。即好消息传播得快，而坏消息传播得慢。</li><li>RIP 协议最大的优点就是实现简单，开销较小。</li><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li></ul><h3 id="好消息传播得快，坏消息传播得慢"><a href="#好消息传播得快，坏消息传播得慢" class="headerlink" title="好消息传播得快，坏消息传播得慢"></a>好消息传播得快，坏消息传播得慢</h3><p>在正常情况下，R1中项目表示到网1距离为1，R2中项目表示到网1距离为2。R2收到 R1 的项目后修改R2的项目为：1 2 R1，R2发现到网1的下一跳为R1，和原路由表一致，修改原路由表该项目为：1 2 R1。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/好消息传播得快坏消息传播得慢1.png"></div><br>R1 说：“我到网 1 的距离是 16 （表示无法到达），是直接交付”。但 R2 在收到 R1 的更新报文之前，还发送原来的报文，因为这时 R2 并不知道 R1 出了故障。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/好消息传播得快坏消息传播得慢2.png"></div><br>我们列出一个网1出现故障后的交换表：<p></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">R1</th><th style="text-align:center">R2</th></tr></thead><tbody><tr><td style="text-align:center">正常</td><td style="text-align:center">1 1 -</td><td style="text-align:center">1 2 R1</td></tr><tr><td style="text-align:center">故障</td><td style="text-align:center">1 16 -</td><td style="text-align:center">1 2 R1</td></tr><tr><td style="text-align:center">第1次</td><td style="text-align:center">1 3 R2</td><td style="text-align:center">1 16 R1</td></tr><tr><td style="text-align:center">第2次</td><td style="text-align:center">1 16 R2</td><td style="text-align:center">1 4 R1</td></tr><tr><td style="text-align:center">第3次</td><td style="text-align:center">1 5 R2</td><td style="text-align:center">1 16 R1</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>这样不断更新下去，直到 R1 和 R2 到网 1 的距离都增大到 16 时，R1 和 R2 才知道网1是不可达的。</p><h3 id="RIP协议的位置"><a href="#RIP协议的位置" class="headerlink" title="RIP协议的位置"></a>RIP协议的位置</h3><ul><li>RIP 协议使用运输层的用户数据报 UDP进行传送（使用 UDP 的端口 520）。</li><li>因此 RIP 协议的位置应当在应用层。但转发 IP 数据报的过程是在网络层完成的。</li></ul><p>这时有一个困惑，RIP是网络层协议，可是为什么用UDP封装？因为路由器虽然是网络层设备，但并不代表他只具备物理层、链路层、网络层功能，他还具备一些应用层的功能，当遇到RIP报文这类应用层的协议，他也能够解封。然后读取RIP报文中的下一跳路由。</p><h3 id="RIP2-协议的报文格式"><a href="#RIP2-协议的报文格式" class="headerlink" title="RIP2 协议的报文格式"></a>RIP2 协议的报文格式</h3><p>RIP2由RIP而来，属于RIP协议的补充协议，提升装载的信息量，增加安全性。</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/rip报文格式.png"></div><p></p><h2 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h2><p>开放最短路径优先协议OSPF （Open Shortest Path First）。</p><h3 id="RIP-协议的问题"><a href="#RIP-协议的问题" class="headerlink" title="RIP 协议的问题"></a>RIP 协议的问题</h3><ul><li>以跳数评估的路由并非最优路径</li><li>最大跳数16导致网络尺度小</li><li>收敛速度慢</li><li>更新发送全部路由表浪费网络资源</li></ul><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li>向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。<ul><li>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”（metric）。</li></ul></li><li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</li></ul><h3 id="链路状态数据库"><a href="#链路状态数据库" class="headerlink" title="链路状态数据库"></a>链路状态数据库</h3><p>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得快是其重要优点。</p><h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/Dijkstra.png"></div><br>| | 1 | 2 | 3 | 4 | 5 | 6 |<br>| :—–: | :–: | :—: | :–: | :—: | :—: | :—: |<br>| 初始化1 | 0 | 2 | 6 | <strong>1</strong> | +无穷 | +无穷 |<br>| 第1步 | 0 | 2 | 4 | 1 | <strong>2</strong> | +无穷 |<br>| 第2步 | 0 | <strong>2</strong> | 3 | 1 | 2 | 4 |<br>| 第3步 | 0 | <strong>2</strong> | 3 | 1 | 2 | 6 |<p></p><p>路径：1 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 3 -&gt; 6</p><h3 id="OSPF-的区域-area"><a href="#OSPF-的区域-area" class="headerlink" title="OSPF 的区域(area)"></a>OSPF 的区域(area)</h3><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。每一个区域都有一个 32 bit 的区域标识符（用点分十进制表示）。区域也不能太大，在一个区域内的路由器最好不超过 200 个。 同时 OSPF 划分为两种不同的区域：</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/划分区域.png"></div><br>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。OSPF 使用层次结构的区域划分。在上层的区域叫作主干区域(backbone area)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。 图中的R3、R4、R6、R7是主干路由器。<p></p><h3 id="OSPF-载体"><a href="#OSPF-载体" class="headerlink" title="OSPF 载体"></a>OSPF 载体</h3><ul><li>OSPF 不用 UDP 而是直接用 IP 数据报传送。</li><li>OSPF 构成的数据报很短。这样做可减少路由信息的通信量。</li><li>数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</li></ul><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/OSPF格式.png"></div><p></p><h3 id="OSPF-的五种分组类型"><a href="#OSPF-的五种分组类型" class="headerlink" title="OSPF 的五种分组类型"></a>OSPF 的五种分组类型</h3><ul><li>类型1，问候（Hello）分组。</li><li>类型2，数据库描述（Database Description）分组。</li><li>类型3，链路状态请求（Link State Request）分组。</li><li>类型4，链路状态更新（Link State Update）分组，用洪泛法对全网更新链路状态。</li><li>类型5，链路状态确认（Link State Acknowledgment）分组。</li></ul><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/OSPF操作.png"></div><p></p><h2 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h2><p>BGP 是不同自治系统的路由器之间交换路由信息的协议。 BGP 较新版本是 2006 年 1 月发表的 BGP-4，可以将 BGP-4 简写为 BGP。</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/BGP协议.png"></div><br>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP 发言人” 。一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。<p></p><p>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话（session），利用 BGP 会话交换路由信息。使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站或对等站。</p><h3 id="BGP报文"><a href="#BGP报文" class="headerlink" title="BGP报文"></a>BGP报文</h3><ul><li>打开（Open）报文，用来与相邻的另一个BGP发言人建立关系。</li><li>更新（Update）报文，用来发送某一路由的信息，以及列出要撤消的多条路由。</li><li>保活（Keepalive）报文，用来确认打开报文和周期性地证实邻站关系。</li><li>通知（Notificaton）报文，用来发送检测到的差错。</li></ul><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/BGP格式.png"></div><p></p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><ul><li>IP协议<ul><li>只有一种报文格式：IP报文</li><li>功能：传递上层数据</li><li>缺乏：应付可能出现差错的能力</li></ul></li><li>网际控制报文协议 ICMP (Internet Control Message Protocol)<ul><li>IP的辅助协议</li><li>为IP提供差错报告机制</li><li>同时为其它层（TCP/UDP、应用）提供辅助功能</li></ul></li></ul><p>ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/ICMP格式.png" width="80%"></div><p></p><h3 id="差错报告报文"><a href="#差错报告报文" class="headerlink" title="差错报告报文"></a>差错报告报文</h3><ul><li>终点不可达</li><li>源点抑制(Source quench)</li><li>时间超过</li><li>参数问题</li><li>改变路由（重定向）(Redirect)</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/ICMP差错.png" width="80%"></div><p></p><h3 id="询问报文"><a href="#询问报文" class="headerlink" title="询问报文"></a>询问报文</h3><ul><li><p>回送请求和回答报文</p></li><li><p>时间戳请求和回答报文</p></li></ul><h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h3><p>Ping发送一个ICMP 报文；回声请求消息给目的地并报告是否收到所希望的ICMPecho （ICMP回声应答）。它是用来检查网络是否通畅或者网络连接速度的命令。</p><p>网络层完成了“主机到主机”的通信，但主机间的通信并不是最后的结果，产生和消耗数据的并不是主机，而是某项网络应用，真正通信的是两个应用“进程”。“进程”就是“正在进行的程序”。而“进程到进程的通信”正是传输层的功能。但这不是全部，更重要的，传输层的任务是为从源主机到目的主机提供可靠的，低价格的数据传输。可靠性，低价格是两个关键词，或者为了更明显一些，可以有第三个关键词，拥塞控制。其实可靠性与拥塞控制本质上是一个词。可靠性、低价格、拥塞控制使传输层成为整个协议体系的核心与灵魂。如果没有传输层，就没有可靠的数据传输，网络层也将失去意义。</p><h2 id="传输服务"><a href="#传输服务" class="headerlink" title="传输服务"></a>传输服务</h2><p>传输层的服务与网络层服务很相似，为何要分为两个层呢？答案就是“可靠性”。网络层并不提供可靠性，路由器可以丢失分组，用户无法控制中间的网络设备，用户不能选择性能更好的路由器或质量更好的数据链路，那么如何保证数据可以正常传输呢？添加一个传输层，传输层应该检测到各种问题，并采取补救措施，从而提供可靠的数据传输。传输层就是要弥补网络层技术、设计的各种缺陷。用个不恰当的比方，传输层就是“填坑的”，将网络层与应用层之间的坑、沟填平。传输层服务前，是遍布坑、沟的公路，传输层服务后，是平坦的公路。</p><p>再谈谈“低价格”这个关键词。如果在设计网络时，由网络层提供可靠性，会如何呢？如果由网络层提供可靠性，就要在中间网络的千万个路由器上添加可靠性的功能，系统的复杂性会提高数据传输的成本，那就与电话通信网的成本差别不大。可靠性由通信网提供还是由端计算机提供，二者的价格差别可太大了。可靠性由端计算机提供，才有了低成本的数据传输，低价格才是计算机网络将其他通信技术淘汰的本质。要低价格，可靠性就要放置在端计算机内部。显然放置在操作系统内部更加合理，直接由操作系统对应用程序提供可靠的数据传输服务，是非常自然的选择。传输层封装在端计算机的操作系统内，用个不恰当的比方，如同封装在房间内的电线，在装修时已经埋好了，只是提供了许多插座，这个插座接洗衣机，那个插座接冰箱，那个插座接电视，等等。</p><p>对计算机网络来说，“可靠性”的关键是什么？或者反过来，造成数据传输不可靠的最主要的原因是什么？是网络拥塞，当网络拥塞时，路由器就会丢弃数据包。传输层需要具有“调控网络”的功能。我们说，传输层在端主机内，而端主机是无法控制中间的网络设备的，“调控网络”从何谈起呢？后面会说到网络拥塞如同现实生活的堵车，根本的解决办法是不让车上路，所有的车都不上路，路就不堵了。“调控网络”是说所有端计算机内的传输层要能感知到网络的状态，能感知到当前通信网的态势，网络拥塞，就少发数据，网络通畅，就多发数据。尤其是网络拥塞时，要少发数据，让中间网络尽快恢复传输能力。</p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>最常用的进程到进程的通信方式是客户机与服务器模式。我们这里说的客户机与服务器都是指一个应用进程，而不是机器。客户机，请求服务，主动发起呼叫的进程。服务器，提供服务，被动等待的进程。总是客户机呼叫服务器，绝不可能是服务器呼叫客户机。在生活中，总是你给消防队打电话，绝不可能是消防队给你打电话。某一项服务，就是一项网络应用。端主机完全可以同时有多项网络应用，如同时打开浏览器浏览网页，打开 QQ 聊天。标识不同的网络应用进程的标识符称为协议端口号 (protocol port number)，简称为端口 (port)。端口是一个 16 位的标识符。客户机用一个临时端口号定义自己。客户机可以随机选择一个端口号使用。服务器也需要用一个端口号来定义自己，但是服务器不能随机选用一个端口号。为什么呢？假设消防队随机使用一个电话号码，当发生火灾时，人们向哪打电话呢？服务器必须使用一个预先定义的，众所周知的端口号，就如同消防队使用119，急救中心使用 120 一样。</p><h3 id="端口范围划分"><a href="#端口范围划分" class="headerlink" title="端口范围划分"></a>端口范围划分</h3><ul><li><p>熟知端口，端口号范围是 0~1023。由 ICANN 分配和控制。</p></li><li><p>注册端口，端口号范围是 1024~49151，ICANN 不分配也不控制，但必须在 ICANN 登记以防止重复。通常为没有熟知端口号的应用程序使用的。</p></li><li><p>动态端口，端口号范围是 49152~65535，这范围的端口号即不用指派，也不需注册，可以由任何进程使用。最初的建议是客户机使用的临时端口号应该在这个范围，但许多程序员可没有遵守这个建议。</p></li></ul><p>注意：端口号只具有本地意义，只是为了标志本计算机应用层中的各进程。</p><h3 id="复用与分用"><a href="#复用与分用" class="headerlink" title="复用与分用"></a>复用与分用</h3><p>某台主机中可能有多个应用进程同时分别和网络上的许多其他主机中的某个或多个应用进程通信。这表明运输层有一个很重要的功能：复用（multiplexing）和分用（demultiplexing）。</p><p>当一个实体接受来自多个源的输入时，就称为复用（multiplexing） （多到一）。</p><p>而当一个实体将数据交到多个源时，就称为分用（demultiplexing）（一到多）。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/复用与分用.png"></div><p></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>用户数据报协议 UDP（User Datagram Protocol）是无连接不可靠的传输层协议。它只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和校验和的功能。校验和功能是可选的，如果不选择校验功能，就全填入 0。UDP 缺点是不可靠，优点是开销小。发送数据之前不需要建立连接。这对某些实时应用是很重要的。网络出现拥塞时，不调整，不降低发送速率。UDP 用户数据报首部如下图：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/udp首部.png"></div><br>源端口和目的端口号，各占 16 位，标志应用进程，总长度为 UDP 的总长度，UDP 首部加 UDP 数据的长度，校验和计算下面介绍。<p></p><h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><p>UDP 的校验和功能是可选的，如果不选择校验和功能，就全填入 0，否则，计算校验和。计算时包含三个部分，伪首部，首部，数据部分，注意计算校验和是包含了数据部分的。如下图：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/UDP校验和.png" width="80%"></div><p></p><h4 id="计算-UDP-检验和的例子"><a href="#计算-UDP-检验和的例子" class="headerlink" title="计算 UDP 检验和的例子"></a>计算 UDP 检验和的例子</h4><p>二进制反码计算规则：0 + 0 = 10；0 + 1 = 1； 1 + 1 = 0</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/校验和计算.png" width="80%"></div><p></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP格式"><a href="#TCP格式" class="headerlink" title="TCP格式"></a>TCP格式</h3><p>一个 TCP 报文段分为首部和数据两部分，首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。而 TCP 的全部功能都体现在它首部中各字段的作用：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/TCP格式.png"></div><p></p><ul><li>源端口和目的端口字段：各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。</li><li>序号字段：占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</li><li>确认号字段：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li><li>窗口字段：占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</li><li>数据偏移（即首部长度）：占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。</li><li>保留：占 6 位，保留为今后使用。</li><li>控制：占 6 位，定义了 6 种不同的控制位或标志。在同一时间可设置位或多位标志位。分别是 URG、ACK、PSH、RST、SYN、FIN。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/TCP格式控制.png"></div><p></p><ul><li><p>检验和：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p></li><li><p>紧急指针字段：占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。</p></li><li><p>选项字段：长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”</p></li></ul><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>TCP 是可靠的传输层协议。就是说 TCP 向应用层交付的是按顺序的，没有差错的，没有丢失的数据。TCP 通过 3 种机制进行差错控制：检验和，确认与超时。</p><h4 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h4><p>TCP 规定每个报文段都必须使用 16 位的检验和。TCP 检验计算时包含三个部分，伪首部，首部，数据部分，注意计算校验和是包含了数据部分的。计算方 法同 UDP 一样。</p><h4 id="确认和超时"><a href="#确认和超时" class="headerlink" title="确认和超时"></a>确认和超时</h4><p>TCP 采用确认的方式来证实收到报文。接收方可以在合适的时候单独发送确 认报文，也可以在自己有数据要发送时把确认信息捎带上。TCP 使用肯定的累积确认。先解释“肯定”，ACK 就是“肯定”的意思。就是只在正确的情况下才发送确认。当发生丢弃，丢失，重复这些错误时，就什么也不做。“报喜不报忧”，注意，当发生错误时，不发送确认。这样，对方收不到确认，重传定时器就会超时，触发重传。 再解释“累积”，就是表示的累积效果，确认号字段值表示的是希望接收的下一个字节的序号。例如确认号为 301，是表示 301 号字节之前的数据都正确接收了，希望接收的下一个字节是 301 号字节。</p><h4 id="重传定时器-2"><a href="#重传定时器-2" class="headerlink" title="重传定时器"></a>重传定时器</h4><p>差错控制的核心就是重传机制。TCP 使用确认-超时重传机制。具体说，TCP 每发送一个报文段，就设置一个重传定时器，当重传时间到，但还没有收到确认，就要重传这一报文段。重传定时器的值怎么设是 TCP 最复杂的事情之一。后面我们会解释原因，现在我们只要知道，重传定时器的值的估算要尽可能的准确，定时器的值不像加班费，越大越好，也不是越小越好，是越准确越好。</p><p>首先，很自然的想法，重传定时器的值应该是“一个往返时延再多一点”。“一个往返时延”如何确定？举例，8 点测了一次往返时延，8:05 又测一次，间隔 5 分钟，测了 10 次，往返时延应该用哪次测量的值呢？显然，用哪一次的<br>也不合适，应该是某种“平均值”。下面介绍的这个算法的目标是使估计值更加“平滑”，我们将往返时延估计值记作 RTTs。这个算法中，历史的累积效应权重更大一些，占比 7/8，新测量值的权重小，占比1/8。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/RTTS.png"></div><br>下图是 RTT 样本与 RTT 估计值示意图，蓝色的是各次的测量值，红色的是RTT 的估计值。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/RTTS图.png"></div><br>说完“一个往返时延”，再说“多一点”。这一点Δ怎么算呢？取样本值到平滑线的距离为Δ，|RTTs-新样本|，显然，每个样本点到平滑线都有一个Δ，就是Δ1，Δ2，Δ3，Δ4，···，取哪个Δ合适呢？显然，用哪一个Δ也不合适，还应<br>该是某种“平均值”。算法也是给出一种“平滑平均值”，记作 RTTD。这个算法中，历史的累积效应权重更大一些，占比 3/4，新测量值的权重小，占比 1/4。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/RTTD.png"></div><br>总的RTO计算公式：$RTO=RTTs + 4 \ast RTTD$<p></p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 是全双工通信，TCP 为每个方向的数据传输使用两个窗口，发送窗口和接收窗口。双向通信就有四个窗口，为简化讨论，只讨论单向数据传输。</p><h4 id="发送窗口-1"><a href="#发送窗口-1" class="headerlink" title="发送窗口"></a>发送窗口</h4><p>下图是一发送窗口例子，TCP 中的窗口以字节为单位。TCP 的传输实际是一个一个的报文段，但控制窗口的变量是以字节为单位。TCP 中只使用一个重传计时器。为方便说明，字节编号取得很小。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/发送窗口1.png"></div><br>发送窗口的后沿（left wall）只能向前移动（关闭 closes），前沿可向前移动（opens），也可收缩（shrinks），但 TCP 标准不赞成收缩。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/发送窗口2.png"></div><p></p><h4 id="接收窗口-1"><a href="#接收窗口-1" class="headerlink" title="接收窗口"></a>接收窗口</h4><p>下图是一接收窗口例子。实际上，接收窗口永远不会收缩。通常，接收方 TCP 等待应用进程来取数据。就是说，分配给接收方的缓存可能包含已接收且确认的数据字节，它们在正等待应用进程将它们拉走。接收窗口总是小于缓冲区的大小。接收窗口通常称为 rwnd，rwnd = 缓冲区大小 – 正在等待被拉走的字节数，如下图：rwnd = 40 。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/接收窗口.png"></div><p></p><h4 id="窗口如何滑动"><a href="#窗口如何滑动" class="headerlink" title="窗口如何滑动"></a>窗口如何滑动</h4><p>TCP 通过滑动窗口机制实现流量控制。我们先忽略差错、拥塞等其他因素，且只简化讨论一个方向的数据传输。下图描述了一个例子，总是客户端发送数据，服务器确认。客户端是发送方，发送窗口，使用序号字段，服务器是接收方，接收窗口，使用确认号和窗口两个字段，窗口字段值是 rwnd 的值。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/窗口滑动.png" width="80%"></div><br>假设发送方的缓冲区与接收方的缓冲区大小都是 800 字节。<p></p><ol><li>第 1 个报文段，客户端发给服务器，SYN 报文段，seq=100。三次握手建立连接的第一个报文，请求连接，并通告初始序号是 seq=100。</li><li>第 2 个报文段，服务器发给客户端，SYN+ACK 报文段，ack=101，rwnd=800。三次握手建立连接的第二个报文，窗口值通告 rwnd=800。</li><li><p>第3个报文段，客户端发给服务器，ACK报文段。客户端通告rwnd=2000，表示客户端的接收缓冲区的大小，我们忽略这个值，只讨论单向传输。</p></li><li><p>第 4 个报文段，客户端发给服务器，数据报文段，seq=101。客户端发送一数据报文段，携带 200 字节数据，数据字节编号 101~300，序号字段填写第 1个数据字节的编号 seq=101。发送窗口前沿在 901，后沿在 101，显示已发送 200字节数据，正等待确认。</p></li><li>第 5 个报文段，服务器发给客户端，ACK 报文段，ack=301，rwnd=600。服务器收到 101~300 号字节，共 200 字节数据，接收窗口调整，后沿向前滑动 200 字节，表示已收好 200 字节。向客户端发送 ACK 确认，确认字段值 ack=301，表示 301 号之前数据收好，下一个希望接收的字节是 301 号字节。注意，此刻 200 字节数据仍在接收缓冲区内，服务器的应用进程还没将它们拉走，接收窗口的大小 rwnd= 800 – 200 = 600。报文段中通告的窗口值为 600。</li><li>第 6 个报文段，客户端发给服务器，数据报文段，seq=301。客户端收到确认 ack=301，rwnd=600。客户端知道服务器已经收好 101~300 号字节，就可以删除这些数据，发送窗口调整，后沿向前滑动 200 字节，至01 处。但前沿不能向前滑动，因为现在接收方通告的 rwnd=600，前沿=301+600=901。客户端发送数据报文段，携带 300 字节数据，数据字节编号 301~600，序号字段eq=301。</li><li>第 7 个报文段，服务器发给客户端，ACK 报文段，ack=601，rwnd=400。服务器收到第二次的 301~600 号字节数据，共 300 字节数据。接收窗口调整，后沿向前滑动 300 字节，至 601 处。因 TCP 使用累积确认，向客户端发送的确认为 ack=601，表示 601 号之前所有数据收好，下一个希望接收的字节是 601 号字节。注意，此刻 200+300=500 字节数据仍在接收缓冲区内。这时，服务器的应用进程拉走 100 字节数据，接收缓冲区的 101~200 号字节空间被释放，但 201~601的 400 字节数据滞留在接收缓冲区内。接收窗口的大小 wnd= 800 – 400 = 400。通告窗口值为 rwnd=400。客户端收到确认 ack=601，rwnd=400。客户端知道服务器已经收好 601 号之前的数据，就可以删除这些数据，发送窗口调整，后沿向前滑动至 601 处。因为现在接收方通告的 rwnd=400，前沿=601+400=1001。前沿向前滑动至 1001 处。</li><li>第 8 个报文段，服务器发给客户端，ACK 报文段，ack=601，rwnd=600。服务器的应用进程又拉走 200 字节数据，接收缓冲区的 201~400 号字节空间被释放，但 401~601 的 200 字节数据仍滞留在接收缓冲区内。接收窗口的大小 rwnd= 800 – 200 = 600。通告窗口值为 400。对于确认来说，服务器现在收好的是 601 号字节之前的数据，确认为 ack=601，表示希望接收的下一个字节是 601 号字节。客户端收到确认 ack=601，wnd=600。客户端知道服务器已经收好 601 号之前的数据，发送窗口的后沿就在 601 处，不需滑动。因为现在接收方通告的rwnd=600，前沿=601+600=1201。前沿向前滑动至 1201 处。</li></ol><h3 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h3><p>假如 TCP 发送的报文段只含有 1 个字节的数据，那么意味着为发送 1 字节的数据，而发送了 41 个字节的报文段，20 个字节的 TCP 首部和 20 个字节的 IP首部。此时的效率是 1/41。这一现象称为糊涂窗口综合症（Silly Window Syndrome）。糊涂窗口综合症是怎样产生的呢?</p><h4 id="由发送方产生的糊涂窗口综合症（Syndrome-Created-by-the-Sender）"><a href="#由发送方产生的糊涂窗口综合症（Syndrome-Created-by-the-Sender）" class="headerlink" title="由发送方产生的糊涂窗口综合症（Syndrome Created by the Sender）"></a>由发送方产生的糊涂窗口综合症（Syndrome Created by the Sender）</h4><p>如果发送方 TCP 正在为一个产生数据很缓慢的应用程序服务，例如一次产生 1 字节数据，就有可能产生糊涂窗口综合症。解决方法是使用 Nagle 算法。</p><h5 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h5><ol><li>发送方 TCP 把它从应用进程收到的第一块数据发送出去，即使只有 1 字节。</li><li>在发送一个报文段后，发送方 TCP 就在输出缓存中累积数据并等待，直至收到接收方发来的确认，或者已积累了足够的数据已达到报文段的最大长度时，就立即发送一个报文段。</li><li>重复步骤 2。</li></ol><p>Nagle 算法之巧妙，在于其巧妙地平衡了应用程序产生数据速度和网络传输速度。如果应用程序比网络速度快，报文段就大（最大报文段长度），如果应用程序比网络速度慢，报文段就小。</p><h4 id="由接收方产生的糊涂窗口综合症（Syndrome-Created-by-the-Receiver）"><a href="#由接收方产生的糊涂窗口综合症（Syndrome-Created-by-the-Receiver）" class="headerlink" title="由接收方产生的糊涂窗口综合症（Syndrome Created by the Receiver）"></a>由接收方产生的糊涂窗口综合症（Syndrome Created by the Receiver）</h4><p>如果接收方 TCP 正在为一个消耗数据很缓慢的应用程序服务，例如一次消耗 1 字节数据，接收方每次发送 rwnd=1 的通告，就有可能产生糊涂窗口综合症。解决方法的是推迟确认。</p><p>报文到达时，不立即发送确认，接收方等待一段时间，直到输入缓存有足够的空间（或者接收缓存已有一个最长报文段的空间，或者接收缓存已有一半空闲的空间），就发送确认报文。但推迟确认不能超过 500ms。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制是 TCP 协议中最重要的一部分。理解 TCP 的拥塞控制，关键在于真正理解网络拥塞这一现象，理解了拥塞，以后的内容都会顺理成章的很好理解。</p><h4 id="拥塞概述"><a href="#拥塞概述" class="headerlink" title="拥塞概述"></a>拥塞概述</h4><p>两个主机，通过中间的一个传输网，连接在一起。正是因为中间有网络，就有了网络拥塞问题。谈网络拥塞之前，先回忆一下路由器的原理。网络层的路由器是一种“尽力而为”的机制。当超过路由器的能力时，路由器就将会丢弃数据报。假设路由器每秒能转发 1000 个数据报，此刻来了 1200 个数据报，路由器就将后 200 个数据报丢弃。注意：当没有超过路由器的负载能力时，路由器是不会丢弃数据报的。换一句话说，就是某个路由节点拥塞了，才会丢弃数据报。</p><p>怎么解决拥堵呢？很明显有两种方案，用公路网来打比方就是增加路的数量和减少驶入公路网的车。从协议的角度考虑，自然是做不到增加路的数量，所以我们就要控制发送到网络中的数据量。</p><h4 id="传输网络"><a href="#传输网络" class="headerlink" title="传输网络"></a>传输网络</h4><p>当网络拥塞时，如同城市交通堵塞，南城的人去不了北城，北城的人一样也去不了南城，路都堵死了，谁也走不了。也就是说，拥塞时，网络外围的所有主机，发送的数据包都会被丢掉，所以一定不会有返回的 ACK 确认，超时定时器一定会闹响。也就是说，网络拥塞时，所有主机都会超时。这样问题就解决了，简单归纳为一句话，超时就表示网络拥塞。</p><blockquote><p>超时就表示网络全拥塞。</p></blockquote><p>因为 TCP 协议中以超时做为网络拥塞的判断依据，重传定时器的值需要估算合适，这很重要。值估算小了，实际网络不拥塞，确产生了超时重传，误判为拥塞，就不能充分使用网络的传输能力。值估算大了，实际网络已经拥塞，确没有产生超时重传，误判为通畅，就会使拥塞更加恶化，最终通信崩溃。在日常的生活中，城市的交通堵塞一定是渐渐堵死的，绝无可能在前一分钟，全城都是通畅的，后一分钟，全城所有的道路都堵死。总是开始时某些路段堵死，然后慢慢扩大，最后全部堵死。如果在某些路段堵死的时候，就开始疏导，有可能不会演变为全堵死。同理在计算机网络中，也很难相信，在前一分钟，所有的路由器都负载很轻，后一分钟，所有的路由器都超负载。应该是，某些路由器超负载了，其他路由器正常，这时后续的数据包就会自动绕路。假设某主机，连续发送了 2，3，4，5号数据包，2 号数据包碰到超负荷的路由器，被路由器丢弃，3，4，5 号数据包绕路到达目的主机，目的主机发送了 3 个 ACK 确认，请求 2 号数据包。当发送方收到 3 个重复 ACK 时，就会判断，网络是部分拥塞的，前面的数据包堵死在路上，后面的数据包绕路走了，已经到达目的地。简单归纳为一句话，3 个重复ACK 就表示网络部分拥塞，我称为半拥塞。</p><blockquote><p>3 个重复 ACK 就表示网络半拥塞。</p></blockquote><p>至此，外围的主机有了推测中间传输网络状态的办法，这两个事件就标志着网络的两种状态。用两个事件标志两种网络状态的方法，需要认真领会。TCP 的拥塞控制不能算闭环，没有一个具体的设备发出一个网络拥塞的信号，因为拥塞是全网的状态，不是某一个路由器的状态。一个路由器超载，可以绕其他路由器。TCP 的拥塞控制也不能算开环，“超时”与“3ACK”这两个事件确实反馈了中间传输网络的状态，为决策提供了依据。了解了网络现在的状态，就好办了。全拥塞有全拥塞的处理办法，半拥塞有半拥塞的处理办法。</p><h4 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h4><p>在上文中，讨论过 TCP 的流量控制，发送方窗口大小是由接收方的可用缓存空间（rwnd）决定的，就是由接收方指示发送方应当使用多大的窗口，这当然可以保证接收方不会溢出。但是，这个方法没考虑网络的存在，上文说过，要调控网络拥塞，就要根据当前网络的状态，调整发送到网络中的数据量。也就是说，TCP 需要一个控制变量，即TCP 发送方使用拥塞窗口 cwnd （Congestion Window）作为控制变量，根据当前网络的拥塞程度，拥塞窗口的大小动态地变化，调整发送的数据量。这样一来发送窗口大小不仅取决于接收方通告的接收窗口 rwnd，还取决于网络的拥塞状况 cwnd，进而 实际的发送窗口 = min（ rwnd , cwnd ）</p><h4 id="拥塞检测"><a href="#拥塞检测" class="headerlink" title="拥塞检测"></a>拥塞检测</h4><p>TCP 的发送方使用两个事件作为判断网络全拥塞和半拥塞的依据。超时表示网络全拥塞。3 次重复 ACK 表示网络半拥塞。</p><h5 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h5><p>上文已经解释过拥塞的现象，我们现在简单理解为：发送方的超时事件就表示中间网络全部堵死了。</p><p>发送方 TCP 在整个连接期间，只维护一个 RTO 计时器。发送方发送段 1 和 段 2，计时器启动，接收方发回 ACK，发送方收到 ACK 后，计时器清零。在启动计时器，发送段 3，段 4，段 3 丢失，段 4 到达，接收方将段 4 存储下来，因为段 3 丢失，接收方留出一个间隙，表明数据是不连续的，接收方只能再发送对段 2 的确认 ACK。发送方收到确认，但因为不是对段 3，段 4 的确认，计时器不能清零，计时器超时，就会重传段 3，并重启计时器，这次段 3 正常到达，接收方发送 ACK，发送方收到，将计时器清零。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/超时.png"></div><p></p><h5 id="三次重复-ACK（3dupACKs）"><a href="#三次重复-ACK（3dupACKs）" class="headerlink" title="三次重复 ACK（3dupACKs）"></a>三次重复 ACK（3dupACKs）</h5><p>三次重复 ACK，也称做“快重传”（Fast retransmission）。如下图：发送方发送 2 个段后，正常收到 ACK，这个 ACK 是原始的 ACK，超时计时器清零。发送方再发送 4 个段，并再次启动超时计时器，段 3 丢失，段 4，5，6 到达。当接收方收到失序的数据段时，立即发送 ACK。接收方会发出 3 个重复的 ACK。发送方收到三个重复的 ACK，就立即重传丢失的报文段，而不等待计时器超时，并重启计时器。这一规则称为“快重传”，目前的 TCP 都遵守这规则。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/3次ACK.png"></div><br>三次重复 ACK，显然是某个报文段丢失了，后面的报文段正常到达。这就表示网络有堵死的地方，造成丢失，其他部分通畅，后面的报文段绕行了通畅的路径。我们现在简单理解为：发送方收到三次重复 ACK，就表示中间网络半堵死。<p></p><h4 id="拥塞控制策略"><a href="#拥塞控制策略" class="headerlink" title="拥塞控制策略"></a>拥塞控制策略</h4><p>TCP 拥塞策略基于两个阶段，慢启动（slow-start，SS）阶段和拥塞避免（congestion avoidance，CA）阶段。在慢启动阶段，发送方从非常慢的速率开始，很快达到一个门限值。当到达门限值，进入拥塞避免阶段。</p><h5 id="慢启动（SS-Slow-start）"><a href="#慢启动（SS-Slow-start）" class="headerlink" title="慢启动（SS, Slow start）"></a>慢启动（SS, Slow start）</h5><p>指数增大，拥塞窗口 cwnd 从 1 个最大报文段 MSS 开始。每收到一个 ACK 确认，拥塞窗口增加一个 MSS。慢启动算法开始很慢，但它是以指数增大的。</p><p>按 ACK 计算， cwnd = cwnd + 1。</p><p>如图，从 cwnd=1 开始，第 1 个 ACK 到达后，cwnd 加 1，就是 2。这时，就可发送 2 个段，相应的回来 2 个 ACK，对于每个 ACK，cwnd 加 1，就是 4 了。是按指数增大的。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/慢开始.png"></div><br>慢启动不能无限制的指数增大，有一个门限值来终止慢启动。发送方有一个慢开始门限 ssthresh（slow-start threshold）的变量，当拥塞窗口大小达到阈值时，慢启动停止，开始拥塞避免阶段。<p></p><h5 id="拥塞避免（CA，Congestion-avoidance）"><a href="#拥塞避免（CA，Congestion-avoidance）" class="headerlink" title="拥塞避免（CA，Congestion avoidance）"></a>拥塞避免（CA，Congestion avoidance）</h5><p>加法增大，在慢启动阶段，当拥塞窗口达到慢开始门限 ssthresh 的值时，慢启动停止，进入拥塞避免阶段。此时，拥塞窗口按加法增大。每次整个“窗口”的所有段都被确认后，拥塞窗口增加 1。</p><p>举例，发送方以 cwnd=4 开始，此刻发送方只能发 4 个段，在 4 个 ACK 到达后，拥塞窗口才加 1。如果按往返时延 RTT 观察，拥塞窗口是每一轮次加 1。</p><p>按 ACK 计算， cwnd = cwnd + ( 1 / cwnd )<br>按 RTT 计算， cwnd = cwnd + 1</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/拥塞避免.png"></div><p></p><h5 id="拥塞控制策略的转换"><a href="#拥塞控制策略的转换" class="headerlink" title="拥塞控制策略的转换"></a>拥塞控制策略的转换</h5><p>在拥塞避免阶段，拥塞窗口加法增大。拥塞避免阶段会一直持续下去吗？继续下去，会是什么情况？显然，拥塞避免阶段继续下去，网络只会有处于通畅，半拥塞，全拥塞三种状态中的一种。就如同城市交通一样，只会是不堵车，部分堵死，全部堵死这三种情况之一。</p><ul><li>通畅：标志是无事件发生。拥塞避免阶段继续，拥塞窗口继续按加法增大。</li><li>半拥塞：<ul><li>标志事件是：发送方收到三次重复 ACK（3dupACKs）。</li><li>处理办法是：<ul><li>ssthresh 门限值设为此刻 cwnd 的一半 ssthresh = cwnd / 2</li><li>将拥塞窗口设为门限值。 cwnd = ssthresh</li><li>进入拥塞避免阶段。</li></ul></li></ul></li><li>全拥塞<ul><li>标志事件是：发送方超时。</li><li>处理办法是：<ul><li>ssthresh 门限值设为此刻 cwnd 的一半 ssthresh = cwnd / 2</li><li>将拥塞窗口重新设置设为 1。 cwnd = 1</li><li>进入慢启动阶段</li></ul></li></ul></li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/转化图.png"></div><br>拥塞举例：<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/拥塞举例.png"></div><p></p><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>TCP 是一种面向连接的协议。TCP 以全双工方式传送数据。在 TCP 中，面向连接的传输需要经过三个阶段：连接建立，数据传输，连接断开。TCP 连接采用客户服务器方式。主动发起连接建立的应用进程叫做客户(client)，被动等待连接建立的应用进程叫做服务器(server)。</p><h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h4><p>TCP 建立连接的过程叫做三次握手（three-way handshaking）。服务器首先打开一个端口，端口处于监听态，称为被动打开。客户端发起连接请求，连接到服务器的打开的端口上，连接就建立了。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/三次握手.png"></div><p></p><ol><li>客户端发送第 1 个报文段，SYN 标志置 1，SYN 是请求同步的意思，SYN 报文段是控制报文，只在每个方向的第 1 个报文里出现。客户随机选择一个数字作为初始序号，假设为 x。<strong>TCP协议规定：SYN 报文段不能携带数据，但要消耗掉一个序号。</strong></li><li>服务器发送第 2 个报文段，SYN，ACK 置 1。SYN 标志表示服务器方的请求同步，并且服务器设置自己的初始序号，假设为 y。ACK 置 1 表示包含确认，这个确认是对客户端 SYN 报文的确认，所以确认号=x+1，表示序号 x+1 之前的报文都收好了，希望收到序号为 x+1 的报文段。</li><li>客户端发送第 3 个报文段，ACK 标志置 1。这个报文段仅仅是一个 ACK 段，通常不携带数据。这个段是客户端发出的，序号就是 x+1。ACK 置 1 表示包含确认，这是对服务器 SYN 报文的确认，确认号=y+1，表示服务器发送的序号 y+1 之前的报文都收好了，希望收到服务器发送的序号为 y+1 的报文段。要特别注意教材中的这句话，并需要真正理解。<strong>TCP 的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号。</strong></li></ol><p>举例：客户端发送的第 1 个 SYN 报文段，序号为 8000，服务器发送的第 2 个 SYN+ACK 报文段，序号为 15000，此后，客户端发送了第 3 个报文段，未携带数据，第 4 个报文段，携带 100 字节数据，问客户端发送的第 3，4 个报文段的序号是什么？</p><p>解析：第 3 个报文段，序号为 8001，因为序号 8000 已经被 SYN 报用掉了。 第 4 个报文段，序号仍然是 8001，注意不是 8002，因为第 3 个报文段是一个 ACK 报文段，并且没携带数据，所以不消耗序号，就是说第 3 个报文的序号 8001 没有被用掉，在第 4 个报文中继续使用。</p><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h5 id="为什么TCP客户端最后还要发送一次确认呢"><a href="#为什么TCP客户端最后还要发送一次确认呢" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢"></a>为什么TCP客户端最后还要发送一次确认呢</h5><p>一句话<strong>，主要防止已经失效的连接请求报文突然又传送到了服务器</strong>，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>连接建立后，可进行双向的数据传输。客户端和服务器都可以发送数据和确认。TCP 连接使用了序号和确认号的机制。</p><h5 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h5><p>TCP 把要发送的数据都按字节编上号。两个方向的编号是相互独立的。编号并不是从 0 开始，而是使用一个随机数作为初始编号，初始编号在建立连接的第一个 SYN 报文段里通告给对方。每个 TCP 报文段都有序号字段，序号字段值是这个报文段中第一个数据字节的编号。</p><blockquote><p>TCP 报文的序号字段值是这个报文段中第一个数据字节的编号。</p></blockquote><h5 id="确认号-2"><a href="#确认号-2" class="headerlink" title="确认号"></a>确认号</h5><p>TCP 使用确认机制。当报文段中 ACK 标志置 1，报文的确认号字段有效，TCP 的确认是累计确认，确认号字段值是完全接收好的数据的最后一个字节的编号+1，表示此值前的数据已收好，期望接收的下一字节是此值。举例，确认号是5644，表示从开始到 5643 号字节的数据都已收好，希望接收 5644 号字节。</p><p>TCP 是累积确认。确认号字段值是期望接收的下一个字节的编号。</p><p>举例：客户端发送一报文段，序号 8001，确认号 15001，携带 1000 字节数据。服务器发送的下一个报文段，序号，确认号是多少？服务器的回复携带 2000 字节数据，则客户端发送的再下一个报文，序号，确认号是多少？</p><p>解析：因第 1 个报文的确认号 15001，是期望接收的下一个报文段的序号，所以，服务器发送的下一个报文段的序号是 15001。因第 1 个报文的序号 8001，携带 1000 字节数据，服务器收到了 8001-9000 编号的 1000 字节数据，确认号是9001，表示 9001 号字节之前的数据已经收好，希望接收的下一个字节是 9001号字节。同理，第 3 个报文，序号为 9001，确认号是 17001。</p><h4 id="连接断开"><a href="#连接断开" class="headerlink" title="连接断开"></a>连接断开</h4><p>数据传输结束后，客户端和服务器任一方都可以发起断开连接。一般来说客户端发起断开连接。TCP 连接释放过程是四次握手。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/20170606084851272.png"></div><p></p><ol><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ol><h5 id="为什么客户端最后还要等待2MSL"><a href="#为什么客户端最后还要等待2MSL" class="headerlink" title="为什么客户端最后还要等待2MSL"></a>为什么客户端最后还要等待2MSL</h5><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p><p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h5 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢</h5><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</p><p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p><h5 id="如果已经建立了连接，但是客户端突然出现故障了怎么办"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办</h5><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h4 id="TCP-连接管理的三规则"><a href="#TCP-连接管理的三规则" class="headerlink" title="TCP 连接管理的三规则"></a>TCP 连接管理的三规则</h4><ul><li>规则 1：TCP 规定，SYN 报文段不能携带数据，但要消耗掉一个序号</li><li>规则 2：TCP 的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号。</li><li>规则 3：TCP 规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。</li></ul><h2 id="打开网页的过程"><a href="#打开网页的过程" class="headerlink" title="打开网页的过程"></a>打开网页的过程</h2><p>总体来说分为以下几个过程:</p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/各种协议与HTTP协议之间的关系.png"></div><p></p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h3><blockquote><p>This class represents an Internet Protocol (IP) address.</p></blockquote><h4 id="获得本机IP地址"><a href="#获得本机IP地址" class="headerlink" title="获得本机IP地址"></a>获得本机IP地址</h4><ul><li>获得本地IP地址</li></ul><p><code>InetAddress iaddress = InetAddress.getLocalHost();</code></p><p>但是这个函数有问题，因为这个函数的原理是通过获取本机的<code>hostname</code>，然后对此<code>hostname</code>做解析，从而获取<code>IP</code>地址的。那么问题来了，如果在本机的<code>/etc/hosts</code>文件里对这个主机名指向了一个错误的<code>IP</code>地址，那么<code>InetAddress.getLocalHost</code>就会返回这个错误的<code>IP</code>地址。当然如果你的<code>hostname</code>是到<code>DNS</code>去解析的，碰巧<code>DNS</code>上的信息也是错的，也同样是悲惨结局。</p><p><code>InetAddress</code>是由两部分组成的，一部分是getHostName()，一部分是getHostAddress()。</p><ul><li>获得本机所有的IP地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取机器所有网卡的IP（ipv4）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getLocalIP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">List&lt;String&gt; ipList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">InetAddress ip = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Enumeration&lt;NetworkInterface&gt; netInterfaces = (Enumeration&lt;NetworkInterface&gt;) NetworkInterface.getNetworkInterfaces();</span><br><span class="line"><span class="keyword">while</span> (netInterfaces.hasMoreElements()) &#123;</span><br><span class="line">NetworkInterface ni = (NetworkInterface) netInterfaces.nextElement();</span><br><span class="line"><span class="comment">// 遍历所有ip</span></span><br><span class="line">Enumeration&lt;InetAddress&gt; ips = ni.getInetAddresses();</span><br><span class="line"><span class="keyword">while</span> (ips.hasMoreElements()) &#123;</span><br><span class="line">ip = (InetAddress) ips.nextElement();</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">null</span> == ip || <span class="string">""</span>.equals(ip)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">String sIP = ip.getHostAddress();</span><br><span class="line"><span class="keyword">if</span>(sIP == <span class="keyword">null</span> || sIP.indexOf(<span class="string">":"</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">ipList.add(sIP);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ipList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取其他主机的IP地址对象</li></ul><p><code>InetAddress otherInetAddress = InetAddress.getByName(&quot;www.baidu.com&quot;);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line"><span class="comment">//1.获取本地主机</span></span><br><span class="line">InetAddress iaddress = InetAddress.getLocalHost();</span><br><span class="line">System.out.println(iaddress); <span class="comment">//打印 InetAddress对象 默认格式: 用户名/IP地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取主机名</span></span><br><span class="line">String hostName = iaddress.getHostName();</span><br><span class="line"><span class="comment">//3.获取主机IP地址</span></span><br><span class="line">String ip = iaddress.getHostAddress();</span><br><span class="line">System.out.println(hostName);</span><br><span class="line">System.out.println(ip);</span><br><span class="line"><span class="comment">//3.获取其他主机的IP地址对象</span></span><br><span class="line">InetAddress otherInetAddress = InetAddress.getByName(<span class="string">"www.baidu.com"</span>);</span><br><span class="line">System.out.println(otherInetAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h3><p>UDP通信需要两个类的支持：</p><ul><li>数据的发送接收器：DatagramSocket</li><li>数据包类：DatagramPacket</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//1.创建DatagramSocket对象,</span></span><br><span class="line"><span class="comment">//强调:接收端必须指定一个端口号</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">12345</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//2.直接创建一个DatagramPacket对象</span></span><br><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bs, bs.length);</span><br><span class="line"><span class="comment">//3.接收</span></span><br><span class="line">System.out.println(<span class="string">"等待发送端发送数据...."</span>);</span><br><span class="line">ds.receive(dp);<span class="comment">//这个方法具有等待功能,等待发送端发送过来的数据</span></span><br><span class="line">System.out.println(<span class="string">"接收数据成功!!"</span>);</span><br><span class="line"><span class="comment">//获取发送端的地址</span></span><br><span class="line">InetAddress sendAddress = dp.getAddress();</span><br><span class="line">System.out.println(<span class="string">"发送端是:"</span>+sendAddress.getHostAddress());</span><br><span class="line"><span class="comment">//获取真正的数据</span></span><br><span class="line"><span class="keyword">byte</span>[] data = dp.getData();</span><br><span class="line"><span class="comment">//获取发送端 发来了多少字节</span></span><br><span class="line"><span class="keyword">int</span> len = dp.getLength();</span><br><span class="line"><span class="comment">//打印数据</span></span><br><span class="line">String receiveMsg = <span class="keyword">new</span> String(data, <span class="number">0</span>, len);</span><br><span class="line">System.out.println(<span class="string">"发送端说:"</span>+receiveMsg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.关闭资源（程序运行结束之后是需要关闭资源的，但是我们的程序是一个死循环，此句永不会执行，所以不能加关闭）</span></span><br><span class="line"><span class="comment">//ds.close();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSender</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"><span class="comment">//1.创建DatagramSocket对象</span></span><br><span class="line">DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//2.创建DatagramPacket对象</span></span><br><span class="line"><span class="comment">//存储 发送的数据,对方的IP,端口号</span></span><br><span class="line">System.out.println(<span class="string">"请输入您要发送的数据:"</span>);</span><br><span class="line">String sendMsg = sc.nextLine();</span><br><span class="line"><span class="keyword">byte</span>[] bs = sendMsg.getBytes();</span><br><span class="line"><span class="comment">//IP地址:127.0.0.1  代表本机,本地回环地址</span></span><br><span class="line">DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bs,bs.length,InetAddress.getByName(<span class="string">"127.0.0.1"</span>),<span class="number">12345</span>);</span><br><span class="line"><span class="comment">//3.发送</span></span><br><span class="line">ds.send(dp);</span><br><span class="line">System.out.println(<span class="string">"发送数据成功!!!"</span>);<span class="comment">//192.168.146.72</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.关闭资源（程序运行结束之后是需要关闭资源的，但是我们的程序是一个死循环，此句永不会执行，所以不能加关闭）</span></span><br><span class="line"><span class="comment">//ds.close();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP服务器:(ServerSocket) 步骤:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.创建一个ServerSocket对象,必须绑定一个端口,这个端口必须和客户端连接的端口一致</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.调用server的accept()方法,获取到底哪一个客户端连接的服务器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.通过刚刚获取到的客户端对象 调用getInputStream()方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4.通过输入流调用read方法,读取客户端写过来的数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 5.关闭资源</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 1.创建一个ServerSocket对象,必须绑定一个端口,这个端口必须和客户端连接的端口一致</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">12345</span>);</span><br><span class="line"><span class="comment">// 2.获取到 哪一个 客户端连接的我</span></span><br><span class="line">System.out.println(<span class="string">"等待客户端连接..."</span>);</span><br><span class="line">Socket client = server.accept();<span class="comment">// 此方法也具有等待功能,等待某一个客户端连接</span></span><br><span class="line"><span class="comment">// 打印一些和客户端有关信息</span></span><br><span class="line">String ip = client.getInetAddress().getHostAddress();</span><br><span class="line">System.out.println(<span class="string">"小样,抓到你了:"</span> + ip);</span><br><span class="line"><span class="comment">// 3.获取输入流,实际上是客户端写数据时的输出流</span></span><br><span class="line">InputStream in = client.getInputStream();</span><br><span class="line"><span class="comment">// 4.读取数据</span></span><br><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = in.read(bs);</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line">System.out.println(<span class="string">"客户端说:"</span> + <span class="keyword">new</span> String(bs, <span class="number">0</span>, len));</span><br><span class="line"><span class="comment">// 5.要向客户端 回写数据,告诉客户端您的信息我已经收到了</span></span><br><span class="line">OutputStream out = client.getOutputStream();</span><br><span class="line">out.write(<span class="string">"您的消息已经收到..."</span>.getBytes());</span><br><span class="line">System.out.println(<span class="string">"给客户端反馈的信息发送成功!!!"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">server.close();</span><br><span class="line">client.close();</span><br><span class="line">in.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用TCP协议的客户端(Socket类) 步骤: 1.创建一个客户端对象(注意:指定这个Socket要连接的服务器的IP和端口)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.从客户端对象中获取 输出流:getOutputStream()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.调用输出流的Write方法写数据到服务器即可</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4.关闭资源</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// 1.创建一个客户端对象(注意:指定这个Socket要连接的服务器的IP和端口)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 这个构造方法干了很多事情: a.自动去连接服务器 b.自动进行三次握手,建立连接 c.自动为连接中创建两个流</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.从客户端对象中获取 输出流:getOutputStream()</span></span><br><span class="line"><span class="comment">// OutputStream out = client.getOutputStream();</span></span><br><span class="line"><span class="comment">// 3.调用输出流的Write方法写数据到服务器即可</span></span><br><span class="line"><span class="comment">// out.write("How are you".getBytes());</span></span><br><span class="line">client.getOutputStream().write(<span class="string">"How are you"</span>.getBytes());</span><br><span class="line">System.out.println(<span class="string">"给服务器发送数据成功!!"</span>);</span><br><span class="line"><span class="comment">// 4.读取服务器 发送过来的反馈信息</span></span><br><span class="line">InputStream in = client.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = in.read(bs);</span><br><span class="line">System.out.println(<span class="string">"服务器响应:"</span> + <span class="keyword">new</span> String(bs, <span class="number">0</span>, len));</span><br><span class="line"><span class="comment">// 关闭资源</span></span><br><span class="line">client.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件传输案例"><a href="#文件传输案例" class="headerlink" title="文件传输案例"></a>文件传输案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="comment">//1.创建ServerSocket对象,绑定一个端口</span></span><br><span class="line">ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">12345</span>);</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="comment">//2.获取哪一个客户端连接的服务器</span></span><br><span class="line">System.out.println(<span class="string">"等待客户端连接..."</span>);</span><br><span class="line"><span class="keyword">final</span> Socket client = server.accept();</span><br><span class="line"><span class="comment">//开启一个线程,和clinet进行交互</span></span><br><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">System.out.println(<span class="string">"小样:"</span>+client.getInetAddress().getHostAddress());</span><br><span class="line"><span class="comment">//3.获取输入流,读取客户端发来数据</span></span><br><span class="line">InputStream in = client.getInputStream();</span><br><span class="line"><span class="comment">//4.创建文件的输出流,把数据写到文件中</span></span><br><span class="line">String picName = <span class="string">"D:\\"</span>+System.currentTimeMillis()+<span class="string">".png"</span>;</span><br><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(picName);</span><br><span class="line"><span class="comment">//5.循环 从输入流读取客户端数据, 写入到文件中</span></span><br><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=in.read(bs))!=-<span class="number">1</span>)&#123;</span><br><span class="line">fos.write(bs, <span class="number">0</span>, len);</span><br><span class="line">&#125;<span class="comment">//1小时</span></span><br><span class="line">System.out.println(<span class="string">"客户端的文件已经保存完毕,可以查看了"</span>+picName);</span><br><span class="line"><span class="comment">//6.告知客户端,文件真的真的真的上传成功</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">OutputStream out = client.getOutputStream();</span><br><span class="line">out.write(<span class="string">"您的文件真的真的真的上传成功"</span>.getBytes());</span><br><span class="line">client.close();</span><br><span class="line">in.close();</span><br><span class="line">out.close();</span><br><span class="line">fos.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6.关闭</span></span><br><span class="line"><span class="comment">//server.close();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadClient</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line"><span class="comment">//1.创建Socket对象,连接服务器</span></span><br><span class="line">Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">12345</span>);</span><br><span class="line">System.out.println(<span class="string">"连接服务器成功.."</span>);</span><br><span class="line"><span class="comment">//2.获取输出流,把数据写向服务器</span></span><br><span class="line">OutputStream out = client.getOutputStream();</span><br><span class="line"><span class="comment">//3.创建文件的输入流,读取本地的文件数据</span></span><br><span class="line">FileInputStream fis = </span><br><span class="line">            <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\我.jpg"</span>);</span><br><span class="line"><span class="comment">//4.循环,读取本地文件,写到服务器</span></span><br><span class="line"><span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>((len=fis.read(bs))!=-<span class="number">1</span>)&#123;</span><br><span class="line">out.write(bs, <span class="number">0</span>, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//关闭输出流</span></span><br><span class="line">client.shutdownOutput();</span><br><span class="line"><span class="comment">//5.获取服务器反馈的信息</span></span><br><span class="line">InputStream in = client.getInputStream();</span><br><span class="line"><span class="keyword">byte</span>[] bs1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> len1 = in.read(bs1);</span><br><span class="line">System.out.println(<span class="string">"服务器说:"</span>+<span class="keyword">new</span> String(bs1,<span class="number">0</span>,len1));</span><br><span class="line"><span class="comment">//6关闭</span></span><br><span class="line">client.close();</span><br><span class="line">out.close();</span><br><span class="line">fis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Socket属性"><a href="#Socket属性" class="headerlink" title="Socket属性"></a>Socket属性</h3><ul><li>TCP_NODELAY：是否采用nagle算法。</li><li>SO_REUSEADDR：表示是否允许重用Socket所绑定的本地地址。</li><li>SO_TIMEOUT：表示接收数据时的等待超时时间。</li><li>SO_SNFBUF：表示发送数据的缓冲区的大小。</li><li>SO_RCVBUF：表示接收数据的缓冲区的大小。</li><li>SO_KEEPALIVE：表示对于长时间处于空闲状态的Socket，是否要自动把它关闭。</li><li>SO_LINGER：表示当执行Socket的close()方法时，是否立即关闭底层的Socket。默认第一种。</li></ul><table><thead><tr><th>on</th><th style="text-align:center">linger</th><th style="text-align:center">closesocket行为</th><th style="text-align:center">发送队列</th><th style="text-align:center">底层行为</th></tr></thead><tbody><tr><td>true</td><td style="text-align:center">忽略</td><td style="text-align:center">立即返回。</td><td style="text-align:center">保持直至发送完成。</td><td style="text-align:center">系统接管套接字并保证将数据发送至对端。</td></tr><tr><td>false</td><td style="text-align:center">零</td><td style="text-align:center">立即返回。</td><td style="text-align:center">立即放弃。</td><td style="text-align:center">直接发送RST包，自身立即复位，不用经过2MSL状态。对端收到复位错误号。</td></tr><tr><td>false</td><td style="text-align:center">非零</td><td style="text-align:center">阻塞直到linger时间超时或数据发送完成。(套接字必须设置为阻塞状态)</td><td style="text-align:center">在超时时间段内保持尝试发送，若超时则立即放弃。</td><td style="text-align:center">超时则同第二种情况，若发送完成则皆大欢喜。</td></tr></tbody></table><ul><li><p>OOBINLINE：Enable/disable SO_OOBINLINE(receipt of TCP urgent data)By default, this option is disabled and TCP urgent data received on a socket is silently discarded. If the user wishes to receive urgent data, then this option must be enabled. When enabled, urgent data is received inline with normal data.</p><p>Note, only limited support is provided for handling incoming urgent data. In particular, no notification of incoming urgent data is provided and there is no capability to distinguish between normal data and urgentdata unless provided by a higher level protocol.</p></li><li><p>PerformancePreferences：设置连接时间、低延迟、高带宽之间的权重。</p></li></ul><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Java NIO的通道类似流，但又有些不同：</p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li></ul><p>java.nio.channels.Channel接口只声明了两个方法：</p><ul><li>close()：关闭通道。</li><li>isOpen()：判断通道是否打开。</li></ul><p>通道在创建时被打开，一旦关闭通道，就不能重新打开它。</p><h3 id="Channel的实现"><a href="#Channel的实现" class="headerlink" title="Channel的实现"></a>Channel的实现</h3><p>这些是Java NIO中最重要的通道的实现：</p><ul><li>FileChannel：从文件中读写数据。</li><li>DatagramChannel：能通过UDP读写网络中的数据。</li><li>SocketChannel：能通过TCP读写网络中的数据。</li><li>ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</li></ul><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Java NIO中的Buffer用于和NIO通道进行交互。如你所知，数据是从通道读入缓冲区，从缓冲区写入到通道中的。缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/Buffer和Channel.png"></div><br>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。为了理解Buffer的工作原理，需要熟悉它的三个属性：<p></p><ul><li>capacity：作为一个内存块，Buffer有一个固定的大小值，叫“capacity”。你只能往对应的Buffer里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</li><li>position：<ul><li>当你写数据到Buffer中时，position表示当前的位置。初始的position值为0，当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1。</li><li>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</li></ul></li><li>limit：<ul><li>写模式下，Buffer的limit表示你最多能往Buffer里写多少数据，此时limit等于Buffer的capacity。</li><li>当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</li></ul></li></ul><h3 id="Buffer的实现"><a href="#Buffer的实现" class="headerlink" title="Buffer的实现"></a>Buffer的实现</h3><p>Java NIO 有以下Buffer类型</p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><h2 id="Buffer详解"><a href="#Buffer详解" class="headerlink" title="Buffer详解"></a>Buffer详解</h2><p>在我们刚才的说明中提到了写模式和读模式，但是实际上这只是被强行赋予的，即JDK中并没有说法，这么说只是为了更方便的理解，所以下面我们来解读一下Buffer的API及怎么在两种模式之间进行切换。</p><p>需要指出：写模式指的是想Buffer写入，读模式是从Buffer里读出。</p><h3 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h3><ul><li><p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。<code>ByteBuffer buf = ByteBuffer.allocate(48);</code></p></li><li><p>这是分配一个可存储1024个字符的CharBuffer：<code>CharBuffer buf = CharBuffer.allocate(1024);</code></p></li></ul><p><strong>刚获得的Buffer默认是写模式。</strong></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/分配之后.png"></div><p></p><h3 id="向Buffer中写数据"><a href="#向Buffer中写数据" class="headerlink" title="向Buffer中写数据"></a>向Buffer中写数据</h3><p>写数据到Buffer有两种方式：</p><ul><li>从Channel写到Buffer：<code>int bytesRead = inChannel.read(buf); //read into buffer</code><ul><li>bytesRead指读出的数据大小。当bytesRead为-1时表示缓存区中不再有数据。</li></ul></li><li>通过Buffer的put()方法写到Buffer里：<code>buf.put(127);</code><ul><li>put()：相对写。向缓冲区的当前位置写入一个单元的数据，写完后把位置加1。</li><li>put(int index)：绝对写。向参数index指定的位置写入一个单元的数据。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * test_in是有数据的文件，用于被读入至Java程序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RandomAccessFile fileIn = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_in"</span>, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line">FileChannel inChannel = fileIn.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line"><span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Read "</span> + bytesRead);</span><br><span class="line">buf.flip();<span class="comment">//写模式切换为读模式</span></span><br><span class="line">System.out.println(charset.decode(buf).toString());</span><br><span class="line">buf.clear();</span><br><span class="line">bytesRead = inChannel.read(buf);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">fileIn.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>inChannel.read(buf);</code>之后，<code>buf.flip();</code>之前Buffer的状态：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/写模式.png"></div><p></p><h3 id="向Channel中写数据"><a href="#向Channel中写数据" class="headerlink" title="向Channel中写数据"></a>向Channel中写数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * test_in是有数据的文件，用于被读入至Java程序</span></span><br><span class="line"><span class="comment"> * test_out中没有数据，用于Java程序的写出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RandomAccessFile fileIn = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_in"</span>, <span class="string">"rw"</span>);</span><br><span class="line">RandomAccessFile fileOut = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_out"</span>, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line">FileChannel inChannel = fileIn.getChannel();</span><br><span class="line">FileChannel outChannel = fileOut.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">bytesRead = inChannel.read(buf);</span><br><span class="line">System.out.println(<span class="string">"Read "</span> + bytesRead);</span><br><span class="line">buf.flip();<span class="comment">//写模式切换为读模式</span></span><br><span class="line">outChannel.write(buf);</span><br><span class="line">buf.clear();</span><br><span class="line">&#125;<span class="keyword">while</span>(bytesRead != -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">fileIn.close();</span><br><span class="line">fileOut.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>buf.flip();</code>之后，<code>outChannel.write(buf);</code>之前Buffer的状态。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/flip之后.png"></div><p></p><h3 id="测试limit"><a href="#测试limit" class="headerlink" title="测试limit"></a>测试limit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * test_in是有数据的文件，用于被读入至Java程序</span></span><br><span class="line"><span class="comment"> * test_out中没有数据，用于Java程序的写出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">RandomAccessFile fileIn = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_in"</span>, <span class="string">"rw"</span>);</span><br><span class="line">RandomAccessFile fileOut = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_out"</span>, <span class="string">"rw"</span>);</span><br><span class="line"></span><br><span class="line">FileChannel inChannel = fileIn.getChannel();</span><br><span class="line">FileChannel outChannel = fileOut.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line"><span class="keyword">int</span> bytesRead = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">bytesRead = inChannel.read(buf);</span><br><span class="line">System.out.println(<span class="string">"写模式下： "</span> + buf.limit());</span><br><span class="line">buf.flip();<span class="comment">//写模式切换为读模式</span></span><br><span class="line">System.out.println(<span class="string">"读模式下： "</span> + buf.limit());</span><br><span class="line">outChannel.write(buf);</span><br><span class="line">buf.clear();</span><br><span class="line">&#125;<span class="keyword">while</span>(bytesRead != -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">fileIn.close();</span><br><span class="line">fileOut.close();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h3><p>Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。</p><h3 id="clear-与compact-方法"><a href="#clear-与compact-方法" class="headerlink" title="clear()与compact()方法"></a>clear()与compact()方法</h3><p>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。</p><p>如果调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer被清空了。Buffer中的数据并未清除。如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</p><p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p><h3 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h3><p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定位置。之后可以通过调用Buffer.reset()方法将position置于这个位置。</p><h3 id="equals-与compareTo-方法"><a href="#equals-与compareTo-方法" class="headerlink" title="equals()与compareTo()方法"></a>equals()与compareTo()方法</h3><h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>当满足下列条件时，表示两个Buffer相等：</p><ol><li>有相同的类型（byte、char、int等）。</li><li>Buffer中剩余的byte、char等的个数相等。</li><li>Buffer中所有剩余的byte、char等都相同。</li></ol><p>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。</p><h4 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo()方法"></a>compareTo()方法</h4><p>compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：</p><ol><li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li><li>所有元素都相等，但第一个Buffer比另一个先耗尽（第一个Buffer的元素个数比另一个少）。</li></ol><h2 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h2><ul><li>scatter：分散，从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。</li></ul><p>Scattering Reads是指数据从一个channel读取到多个buffer中。如下图描述：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/scatter.png"></div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_in"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel channel = file.getChannel();</span><br><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">6</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"><span class="keyword">long</span> read = channel.read(bufferArray);</span><br><span class="line">System.out.println(read);</span><br><span class="line">header.flip();</span><br><span class="line">body.flip();</span><br><span class="line">System.out.println(charset.decode(header).toString());</span><br><span class="line">System.out.println(charset.decode(body).toString());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。</p><p>Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息（消息大小不固定）。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads才能正常工作。</p><ul><li>gather：聚集，写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。</li></ul><p>Gathering Writes是指数据从多个buffer写入到同一个channel。如下图描述：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/gather.png"></div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">RandomAccessFile fileOut = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_out"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel channelOut = fileOut.getChannel();</span><br><span class="line"></span><br><span class="line">ByteBuffer header = ByteBuffer.allocate(<span class="number">6</span>);</span><br><span class="line">ByteBuffer body   = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">header.put(<span class="string">"陈"</span>.getBytes());</span><br><span class="line">body.put(<span class="string">"钰琪是个大可爱"</span>.getBytes());</span><br><span class="line">ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line"></span><br><span class="line">header.flip();</span><br><span class="line">body.flip();</span><br><span class="line"></span><br><span class="line">channelOut.write(bufferArray);</span><br><span class="line">fileOut.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="通道之间的数据传输"><a href="#通道之间的数据传输" class="headerlink" title="通道之间的数据传输"></a>通道之间的数据传输</h2><p>在Java NIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel传输到另外一个channel。</p><h3 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h3><p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中（这个方法在JDK文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中）。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_in"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_out"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">toChannel.transferFrom(fromChannel, position, count);</span><br><span class="line"></span><br><span class="line">fromFile.close();</span><br><span class="line">toFile.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h3><p>将数据从FileChannel传输到其他的channe中。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_in"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_out"</span>, <span class="string">"rw"</span>);</span><br><span class="line">FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">fromChannel.transferTo(position, count, toChannel);</span><br><span class="line"></span><br><span class="line">fromFile.close();</span><br><span class="line">toFile.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>服务器程序只需要一个线程就能同时负责接收客户的连接、接收各个客户发送的数据，以及向各个客户发送响应数据。服务器程序的处理流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(一直等待，直到有接收连接就绪事件、读就绪事件或写就绪事件发生)&#123; <span class="comment">//阻塞</span></span><br><span class="line"><span class="keyword">if</span>(有客户连接)</span><br><span class="line">接收客户的连接; <span class="comment">//非阻塞</span></span><br><span class="line"><span class="keyword">if</span>(某个Socket的输入流中有可读数据)</span><br><span class="line">从输入流中读数据; <span class="comment">//非阻塞</span></span><br><span class="line"><span class="keyword">if</span>(某个Socket的输出流可以写数据)</span><br><span class="line">向输出流写数据; <span class="comment">//非阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上处理流程采用了轮询的工作方式，当某一种操作就绪，就执行该操作，否则就察看是否还有其他就绪的操作可以执行。线程不会因为某一个操作还没有就绪，就进入阻塞状态，一直傻傻的在那里等待这个操作就绪。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/非阻塞技术模型.png"></div><p></p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。</p><h3 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h3><p>通过调用Selector.open()方法创建一个Selector，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><h3 id="向Selector注册通道"><a href="#向Selector注册通道" class="headerlink" title="向Selector注册通道"></a>向Selector注册通道</h3><p>为了将Channel和Selector配合使用，必须将channel注册到selector上。通过SelectableChannel.register()方法来实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p><p>注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p><ul><li>SelectionKey.OP_ACCEPT：接收连接就绪事件，表示服务器监听到了客户连接，服务器可以接收这个连接了。常量值为16</li><li>SelectionKey.OP_CONNECT：连接就绪事件，表示客户与服务器的连接已经建立成功。常量值为8。</li><li>SelectionKey.OP_READ：读就绪事件，表示通道中已经有了可读数据，可以执行读操作了。常量值为1。</li><li>SelectionKey.OP_WRITE：写就绪事件，表示已经可以向通道写数据了。常量值为4。</li></ul><p>以上常量分别占居不同的二进制位，因此可以通过二进制的或运算“|”，来将它们进行任意组合。</p><p>总结来说：通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个serverSocketChannel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。</p><h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>在上一小节中，当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：</p><ul><li>interest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li><li>附加的对象（可选）</li></ul><h4 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h4><p>就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = </span><br><span class="line">(interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="comment">//  其他的也类似...</span></span><br></pre></td></tr></table></figure><h4 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h4><p>ready 集合是通道已经准备就绪的操作的集合。在一次选择（Selection）之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：<code>intreadySet = selectionKey.readyOps();</code></p><p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure><h4 id="Channel-Selector"><a href="#Channel-Selector" class="headerlink" title="Channel + Selector"></a>Channel + Selector</h4><p>从SelectionKey访问Channel和Selector很简单。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure><h4 id="附加的对象"><a href="#附加的对象" class="headerlink" title="附加的对象"></a>附加的对象</h4><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure><h3 id="通过Selector选择通道"><a href="#通过Selector选择通道" class="headerlink" title="通过Selector选择通道"></a>通过Selector选择通道</h3><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p><p>下面是select()方法：</p><ul><li>int select()：阻塞到至少有一个通道在你注册的事件上就绪了。</li><li>int select(long timeout)：和select()一样，除了最长会阻塞timeout毫秒(参数)。</li><li>int selectNow()：不会阻塞，不管什么通道就绪都立刻返回（<em>此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。</em>）。</li></ul><p>select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p><h4 id="selectedKeys"><a href="#selectedKeys" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h4><p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure><p>当像Selector注册Channel时，Channel.register()方法会返回一个SelectionKey 对象。这个对象代表了注册到该Selector的通道。可以通过SelectionKey的selectedKeySet()方法访问这些对象。</p><p>可以遍历这个已选择的键集合来访问就绪的通道。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p><p>SelectionKey.channel()方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。</p><h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><h3 id="打开-SocketChannel"><a href="#打开-SocketChannel" class="headerlink" title="打开 SocketChannel"></a>打开 SocketChannel</h3><p>下面是SocketChannel的打开方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">20000</span>));</span><br></pre></td></tr></table></figure><h3 id="关闭-SocketChannel"><a href="#关闭-SocketChannel" class="headerlink" title="关闭 SocketChannel"></a>关闭 SocketChannel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure><h2 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h2><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。ServerSocketChannel类在 java.nio.channels包中。</p><h3 id="打开-ServerSocketChannel"><a href="#打开-ServerSocketChannel" class="headerlink" title="打开 ServerSocketChannel"></a>打开 ServerSocketChannel</h3><p>通过调用 ServerSocketChannel.open() 方法来打开ServerSocketChannel，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br></pre></td></tr></table></figure><h3 id="关闭-ServerSocketChannel"><a href="#关闭-ServerSocketChannel" class="headerlink" title="关闭 ServerSocketChannel"></a>关闭 ServerSocketChannel</h3><p>通过调用ServerSocketChannel.close() 方法来关闭ServerSocketChannel，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.close();</span><br></pre></td></tr></table></figure><h3 id="监听新进来的连接"><a href="#监听新进来的连接" class="headerlink" title="监听新进来的连接"></a>监听新进来的连接</h3><p>通过 ServerSocketChannel.accept() 方法监听新进来的连接。当 accept()方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, accept()方法会一直阻塞到有新连接到达。</p><p>通常不会仅仅只监听一个连接,在while循环中调用 accept()方法，如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel =</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//do something with socketChannel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以在while循环中使用除了true以外的其它退出准则。</p><h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel =</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(socketChannel != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//do something with socketChannel...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务器使用NIO向客户端Echo数据的例子"><a href="#服务器使用NIO向客户端Echo数据的例子" class="headerlink" title="服务器使用NIO向客户端Echo数据的例子"></a>服务器使用NIO向客户端Echo数据的例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ClosedChannelException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoSeverZJH</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> Selector selector;</span><br><span class="line"><span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">8000</span>;</span><br><span class="line"><span class="keyword">private</span> Charset charset = Charset.forName(<span class="string">"utf-8"</span>);</span><br><span class="line"><span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EchoSeverZJH</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">selector = Selector.open();</span><br><span class="line">serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">serverSocketChannel.socket().setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"服务器开启成功... : "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">list.add(<span class="string">"一共有18018条航班数据"</span>);</span><br><span class="line"><span class="keyword">try</span> (Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"copy"</span>)))) &#123;</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">while</span>(cin.hasNext()) &#123;</span><br><span class="line">line = cin.nextLine();</span><br><span class="line">list.add(line);</span><br><span class="line">&#125;</span><br><span class="line">list.add(<span class="string">"no data"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">num = list.size();</span><br><span class="line">System.out.println(<span class="string">"数据已准备好... : "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line"><span class="comment">//没有连接就会阻塞</span></span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">n = selector.select();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">Set&lt;SelectionKey&gt; readkeys = selector.selectedKeys();</span><br><span class="line">Iterator&lt;SelectionKey&gt; iterator = readkeys.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">SelectionKey key = iterator.next();</span><br><span class="line"><span class="keyword">if</span>(!key.isValid()) &#123;</span><br><span class="line">iterator.remove();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">accept(key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">send(key);</span><br><span class="line">&#125;</span><br><span class="line">iterator.remove();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理接收连接就绪事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line">SocketChannel socketChannel;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">socketChannel = serverSocketChannel.accept();</span><br><span class="line">System.out.println(<span class="string">"收到了客户端连接，来自 ： "</span> + socketChannel.getRemoteAddress());</span><br><span class="line">socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//注册到selector</span></span><br><span class="line">socketChannel.register(selector, SelectionKey.OP_WRITE, <span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理写就绪事件</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line"><span class="keyword">int</span> index = (<span class="keyword">int</span>)key.attachment();</span><br><span class="line">key.attach((index + <span class="number">1</span>) % num);</span><br><span class="line">String line = list.get(index);</span><br><span class="line">ByteBuffer outputBuffer = charset.encode(line + <span class="string">"\r\n"</span>);</span><br><span class="line"><span class="keyword">while</span> (outputBuffer.hasRemaining()) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">socketChannel.write(outputBuffer);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">key.cancel();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(socketChannel.getRemoteAddress() + <span class="string">"   断开连接----"</span>);</span><br><span class="line">socketChannel.socket().close();</span><br><span class="line">socketChannel.close();</span><br><span class="line">outputBuffer.clear();</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">e1.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"><span class="keyword">new</span> EchoSeverZJH().service();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadFromSocket</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Socket socket = <span class="keyword">null</span>;</span><br><span class="line">Scanner sc = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">8000</span>);</span><br><span class="line">String line = <span class="keyword">null</span>;</span><br><span class="line">sc = <span class="keyword">new</span> Scanner(socket.getInputStream());</span><br><span class="line">line = sc.nextLine();</span><br><span class="line">System.out.println(line);</span><br><span class="line"><span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">line = sc.nextLine();</span><br><span class="line">System.out.println(line);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">socket.close();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">sc.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Selector维护的集合"><a href="#Selector维护的集合" class="headerlink" title="Selector维护的集合"></a>Selector维护的集合</h2><p>对上面的代码有一个很大的疑问，即服务器端为什么要进行<code>iterator.remove();</code>。解答这个问题之前我们先来理一下思路：</p><ol><li>服务器端有一个<code>ServerSocketChannel</code>，它绑定了端口号，且设置为非阻塞模式，它先向<code>Selector</code>中注册：<code>serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</code>。ServerSocketChannel在注册的时候指定的事件是：<code>OP_ACCEPT</code>，表示接收连接就绪事件，即服务器在监听客户连接。</li><li>每一个注册到<code>selector</code>上的<code>channel</code>都会被加入一个集合（key set），这个集合可以通过<code>selector.keys()</code>方法返回。</li><li>然后判断已经准备好的连接<code>n = selector.select();</code>有几个，如果等于0则表示没有准备好的连接，此时需要<code>continue</code>。其中，已经准备好的连接可以按如下获得：<code>Set&lt;SelectionKey&gt; readkeys = selector.selectedKeys();</code>。即所有已经准备好channel都在一个集合（selected-key）中。</li><li>但是selected-key本身并不是线程安全的，所以在处理的时候需要判断其是不是已经合法的，比如如果客户端中断了访问，则不能在传输数据，即其实不合法的。</li></ol><p>同时，每个都撤销的channel都在<code>cancelled-key set</code>中，但是所关联<code>channel</code>还没有被撤销登记。其不能够被直接返回，但也一定是key set的子集。</p><p>所以我们移出的其实只是已准备好的channel的key。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;IO流&quot;&gt;&lt;a href=&quot;#IO流&quot; class=&quot;headerlink&quot; title=&quot;IO流&quot;&gt;&lt;/a&gt;IO流&lt;/h2&gt;&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/categories/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/tags/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="面试" scheme="https://isjinhao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>02-MySQL</title>
    <link href="https://isjinhao.github.io/2019/02-MySQL/"/>
    <id>https://isjinhao.github.io/2019/02-MySQL/</id>
    <published>2019-07-28T13:47:14.000Z</published>
    <updated>2019-08-16T09:33:24.831Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><h3 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h3><h4 id="磁盘构造"><a href="#磁盘构造" class="headerlink" title="磁盘构造"></a>磁盘构造</h4><div align="center"><img width="30%" src="//isjinhao.github.io/2019/02-MySQL/磁盘.jpg"></div><br>当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头（又叫磁头）下通过，就可以进行数据的读/写了。<br><br>一般磁盘分为固定头盘（磁头固定）和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。<br><br>活动头盘 （如上图）的磁头是可移动的。每一个盘面上只有一个磁头（磁头是双向的，因此正反盘面都能读写）。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的（行动整齐划一）。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。<br><br>#### 访问时间<br><br>典型的磁盘访问时间包括以下三个部分：寻道时间、旋转延迟时间、磁盘访问时间。这其中，时间开销最大的是$s$，台式机的旋转速度一般是7200转/分钟（RPM），即旋转一周需要8.33ms，所以式子中的$s$平均为4.165ms，而且磁臂的移动也需要时间，而硅存储的常见存取时间是50ns，即$s$约为一次存取时间100000倍。通常一页的长度为$2^{11}-2^{14}$，即使磁盘一般是一次读取连续的几个页面，定位到信息的时间也比存取信息的时间多（通常磁盘的平均存储时间是$8-11ms$）。所以当大量数据存储在外存磁盘中时，需要一种合理高效的数据结构来降低访问外存的时间：B树。需要说一下，B树的英文名是<code>B-tree</code>，所以有时候有人会把<code>B树</code>叫做<code>B-树</code>，这两个名词是同一个意思。<br><br>B树的典型执行过程中，B树算法的运行时间取决于<code>DISK-READ</code>和<code>DISK-WRITE</code>。<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = a pointer to some object</span><br><span class="line">DISK-READ(x)</span><br><span class="line">operations of x</span><br><span class="line">DISK-WRITE(x)</span><br></pre></td></tr></table></figure><br><br>通常一个B树的结点和磁盘的一页一样大，这样一次读写操作能获取更多的信息。而每页能存储多少个数据和关键字大小有关。下图中的B树每个结点有1000个数据（B树中结点的度数为结点数据个数+1，见后面的定义），高度为2。所以它可以存储超过十亿个关键字，查找某个关键字至多进行两次磁盘访问。<br><br><br><br>### B树的定义<br><br>#### B树的定义<br><br>- 每个结点有如下属性：<br>1. $x.n$：表示当前存储在结点$x$中的关键字个数。<br>2. 每个结点中的关键字以非降序方式存放：$x.key_1 \leq x.key_2 \leq \cdots \leq x.key_n$。<br>3. $x.leaf$：一个布尔值，如果$x$是叶结点，则为$true$，否则为$false$。<br>- 每个内部结点还包含包含$x.n+1$个指向其孩子的指针：$x.c_1, x.c_2, \cdots , x.c_n $，叶结点的$c_i$属性没有定义。<br>- 关键字$x.key_i$对存储在各子树中的关键字范围加以分割：如果$k_i$为任意一个存储在以$x.c_i$为根的子树中的关键字，满足：$k_i \leq x.key_1 \leq k_2 \leq x.key_2 \leq \cdots \leq x.key_{x.n} \leq k_{x.n+1}$。<br>- 每个叶结点具有相同的深度，即树的高度h。<br>- 每个结点关键字所包含的关键字个数有上界和下界。用一个被称为B树的最小度数的固定整数$t$来表示这些界，$t \geq 2$。<br>1. 除了根结点外的每个结点都至少有$t-1$个关键字，因此，除了根结点以外的每个内部结点至少有$t$个孩子。如果树非空，根结点至少有一个关键字。<br>2. 每个结点至多可包含$2t-1$个关键字，因此一个内部结点至多可有$2t$个孩子，当一个结点恰好有$2t-1$个关键字时，该结点是满的。<br>3. $t=2$的树是最简单的，每个内部结点有2个、3个或4个孩子。<br><br>那么为什么最小度数不能取1呢？因为最小度数取1之后，内部结点（设指向其的指针为p）可以包含0个关键字，此时包含0个关键字的结点只有一个孩子（设为c），这个结点就被浪费了，我们其实可以直接让p指向c。<br><br><br><br>### B树的高度<br><br>对任意一棵包含n（$n \geq 1$）个关键字、最小度数为t的B树来说，有：$h \leq log_t{\frac{n+1}{2}}$。证明：<br><br>假设根所在的层高度为0，则高度为h的B树在高度为1的层至少包含2个结点，在高度为2的层至少包含$2t$个结点，在高度为3的层至少包含$2t^2$个结点…直到高度为h的层至少包含$2t^{h-1}$个结点。可得关键字个数n满足不等式：$n \geq 1+(t-1)\sum_{i=1}^h2t^{i-1} = 1+2(t-1)(\frac{t^h-1}{t-1})=2t^h-1$<br><br>$\Longrightarrow t^h \leq (n+1)/2$<br><br>$\Longrightarrow h \leq log_t{\frac{n+1}{2}}$<br><br>（t-1）指的是每个结点至少包含t-1个关键字。<br><br><br><br>### B树的阶<br><br>我们经常会遇到一个B数的术语：阶，假如树中的结点最多含有m个孩子，此B树的阶为m。当阶为偶数的时候，我们可以把定义中的$t$替换成$m/2$，但是当阶为奇数的时候就要考虑一个问题了，除根结点外的每个内部结点至少含有<code>ceil(m/2)</code>个结点还是<code>floor(m/2)</code>个结点？应该是<code>ceil(m/2)</code>，因为除了根结点每个结点的孩子个数满足：$t \leq keyNum \leq 2t$，如果取<code>floor(m/2)</code>会发现无法满足上式，所以<strong>一棵含有n个总关键字数的m阶的B树的最大高度是</strong>：$log_{ceil(m/2)}(n+1)/2$。（ceil向上取整，floor向下取整）<br><br><br><br>### 搜索<br><br>设$x$是根结点，被搜索的关键字是$k$。<br><br><div align="left"><img src="//isjinhao.github.io/2019/02-MySQL/搜索.jpg"></div><br>需要说明一下，伪代码中$key$和$c$的起始下标都为1。NIL代表空。<br><br><br><br>### 插入<br><br>插入的时候会遇到两种情况：<br><br>1. 将新的关键字插在一个已经存在但<strong>未满</strong>的结点上：直接插入；<br>2. 将新的关键字插在一个已经存在但<strong>已满</strong>的结点上：分裂后插入；<br><br>#### 分裂<br><br>将一个满的结点$y$（有$2t-1$个关键字）按照中间关键字分裂成两个各含有$t-1$个关键字的结点，中间关键字被升到$y$的父结点。如果$y$的父结点也是满的，也需要分裂，最终满结点的分裂会向上传播。如果向上传播时全程都是满结点会把根结点分裂，使B树的高度增1。分裂是使B树增高的唯一办法。<br><br>但是在实际操作中不是等到找出插入过程中实际要分裂的结点才做分裂，而是在沿着树向下查找时分裂所有遇到的满结点，这样就能保证在插入的时候节点一定非满。<br><br><div align="left"><img src="//isjinhao.github.io/2019/02-MySQL/分裂.jpg"></div><br>$x$是被分裂的结点的父节点，$y$是$x$的第$i$个孩子。<br><br><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/分裂举例.jpg"></div><br>#### 非满结点插入<br><br><div align="left"><img src="//isjinhao.github.io/2019/02-MySQL/非满结点插入.jpg"></div><br>$x$是被插入的节点，$k$是插入的键。解释几行代码：<br><br>- 12行：被操作的节点从磁盘中读入到内存中，然后在内存中进行操作。<br>- 7行+17行：每次插入的都是叶节点。<br><br><br><br>#### 完整插入过程<br><br><div align="left"><img src="//isjinhao.github.io/2019/02-MySQL/完整插入过程.jpg"></div><br>此时对根的分裂需要创建两个节点，而且对根的分裂是B树长高的唯一办法。而且在分裂之后我们会发现根节点必然会有一个关键字，这也对应了定义中的B树的根至少有两个孩子。<br><br><br><br>### 创建<br><br>分配空节点：<br><br><div align="left"><img src="//isjinhao.github.io/2019/02-MySQL/创建.jpg"></div><br>分配之后循环调用插入即可。<br><br><br><br>### 删除<br><br>在删除时需要注意两个部分：<br><br>1. 除根节点外，被删除关键字的节点在删除后仍然要满足$keyNum \geq t-1$。<br>2. 删除后需要重新安排这个结点的孩子。<br><br>#### 操作<br><br>1. 如果关键字$k$在结点$x$中，并且$x$是叶节点，从$x$中删除$k$<br>2. 如果关键字$k$在结点$x$中，但$x$是内部非根节点：上移孩子结点中的某相近元素（“左孩子最右边的节点”或“右孩子最左边的节点”）到父节点中，并且递归被上移的孩子。删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于$ceil(m/2)-1$，则需要看其某相邻兄弟结点是否贫困（结点中元素个数等于$ceil(m/2)-1$）如果非贫困，则父节点下降一个元素来此节点，兄弟结点上升一个元素。如果其相邻兄弟都贫困，则该结点与其相邻的某一兄弟结点进行“合并“成一个结点。<br><br>#### 举例<br><br><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/B树删除.jpg"></div><br>- 刪除H：直接删除<br>- 删除T：W上升到T的位置，4上升到W的位置<br>- 删除R：删除导致只有1个元素，已经小于最小元素数目$ceil(5/2)-1=2$，由于右相邻兄弟结点不贫困，所以先向父节点借一个元素T下移到该叶子结点中，代替原来S的位置，S前移；然后W上移到父结点中，X、Y、Z依次前移。<br><br><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/删除2.jpg"></div><br>- 删除E：因为E所在的结点和相邻的兄弟结点的关键字都刚好达标，删除后不能再向父节点借元素，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点与含有A和C的相邻兄弟结点进行合并成一个结点。但是此时还没有结束，此时的情况如下图第一幅，此时父节点只包含一个元素G，没达标。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有Q,X）含有的元素个数大于2，咱们可以将M下移到元素很少的子结点中，将Q上移到M的位置，但此时咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，即树的高度减少一层。<br><br><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/删除3.jpg"></div><br><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/删除4.jpg"></div><br>### B+树<br><br>在B树中，我们做操作的时候都默认了关键字和其对应的数据都存在一个页面中，但是实际上可以只存储关键字，而且仅存关键字可以让每页能存储更多的数据。基于此点和为了更好的在文件系统中存取数据，诞生了B+树。<br><br>#### 定义<br><br><code>B+树</code>可以被视为每个节点仅包含键（不是键值对），并且链接了各叶节点叶的B树。和B树的区别如下：<br><br>- 所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 （而B树的叶子节点并没有包括全部需要查找的信息）。<br>- 所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 （而B树的非终节点也包含需要查找的有效信息）<br><br><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/B+树.jpg"></div><br>#### 为什么数据库使用B+树作为索引<br><br>- B+树的磁盘读写代价更低。B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。<br><br>- B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。而B+树只要遍历叶子节点就可以实现整棵树的遍历。<br>- <code>B+树</code>对<code>range-query</code>的支持很强大。比如要查<code>5-10</code>之间的，<code>B+树</code>一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。<br><br>#### 分裂<br><br>B+树的分裂和B树没有太大区别，只是分裂后注意叶子结点需要有链接到下个结点的指针。<br><br><br><br>### B*树<br><br>#### 定义<br><br>B*树是B+树的变体，在B+树的基础上（所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针）:<br><br>- B*树中非根和非叶子结点再增加指向兄弟的指针；<br>- B*树定义了非叶子结点关键字个数至少为$ceil((2/3) \ast m)$，即块的最低使用率为2/3（代替B+树的1/2）。<br><br><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/Bast.jpg"></div><br>#### 分裂<br><br>当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。<br><br><br><br>### 总结<br><br>B树及其变形可以非常好的处理一维空间存储的问题。它的思想就是把一维直线分为若干段线段，当我们查找满足某个要求的点的时候，只要去查找它所属的线段即可。也可以说要查找某一满足条件的点，先去找到满足条件的线段，然后遍历所在线段上的点，即可找到答案。<br><br><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/B树.jpg"></div><br>### 对比<br><br>- <code>B树</code>：有序数组+平衡多叉树；<br>- <code>B+树</code>：有序数组链表+平衡多叉树；<br>- <code>B*树</code>：一棵丰满的B+树。<br><br><br><br>## 多列索引<br><br>假如有如下表：<br><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People(</span><br><span class="line">last_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">first_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">dob <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">gender enum(<span class="string">'m'</span>, <span class="string">'f'</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">key</span>(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><br>对应的<code>B树</code>如下（Mysql中实际上应该是B+树，但是在高性能mysql这本书里使用的是B树）：<br><br><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/举例B树.jpg"></div><br>### 匹配原则<br><br>多列索引的特点就和英语一样，比如查找mysql这个单词，对于第一个单词是有序的，所以先按顺序找到m，再m范围下的单词也是有序的，再找到y，以此类推。所以建立的索引对如下类型的查询有效：<br><br>#### 全值匹配<br><br>和索引中定义的所有列进行匹配，如查找姓名为<code>Cuba Allen</code>，出生于<code>1996-01-01</code>的人。<br><br>#### 匹配最左前缀<br><br>前面提到的索引可用于查找所有姓为<code>Allen</code>的人，即只使用索引的第一列。<br><br>#### 匹配列前缀<br><br>也可以只匹配某一列的值的开头部分，例如前面提到的索引可用于查找所有以<code>J</code>开头的姓的人。这里使用了索引的第一列。<br><br>#### 匹配范围值<br><br>例如前面提到的索引可用于查找姓在<code>Allen</code>和<code>Barrymore</code>之间的人。这里也只用了索引的第一列。<br><br>#### 精确匹配某一列并范围匹配另外一列<br><br>前面提到的索引也可用于查找所有姓为<code>Allen</code>，并且名字是<code>K</code>开头的人。<br><br><br><br>### 多列索引在代码中的使用<br><br>假设建立的索引是<code>(a,b,c)</code>：<br><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mytable <span class="keyword">where</span> a=<span class="number">3</span> <span class="keyword">and</span> b=<span class="number">5</span> <span class="keyword">and</span> c=<span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 三个索引都在where条件里面用到了，而且都发挥了作用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mytable <span class="keyword">where</span> c=<span class="number">4</span> <span class="keyword">and</span> b=<span class="number">6</span> <span class="keyword">and</span> a=<span class="number">3</span>; </span><br><span class="line"><span class="comment">-- where里面的条件顺序在查询之前会被mysql自动优化，效果跟上一句一样</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mytable <span class="keyword">where</span> a=<span class="number">3</span> <span class="keyword">and</span> c=<span class="number">7</span>; </span><br><span class="line"><span class="comment">-- a用到索引，b没有用，所以c是没有用到索引效果的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mytable <span class="keyword">where</span> a=<span class="number">3</span> <span class="keyword">and</span> b&gt;<span class="number">7</span> <span class="keyword">and</span> c=<span class="number">3</span>;</span><br><span class="line"><span class="comment">-- a用到了，b也用到了，c没有用到，这个地方b是范围值，也算断点，只不过自身用到了索引</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mytable <span class="keyword">where</span> b=<span class="number">3</span> <span class="keyword">and</span> c=<span class="number">4</span>;</span><br><span class="line"><span class="comment">-- 因为a索引没有使用，所以这里 bc都没有用上索引效果</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mytable <span class="keyword">where</span> a&gt;<span class="number">4</span> <span class="keyword">and</span> b=<span class="number">7</span> <span class="keyword">and</span> c=<span class="number">9</span>;</span><br><span class="line"><span class="comment">-- a用到了 b没有使用，c没有使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mytable <span class="keyword">where</span> a&gt;<span class="number">4</span> <span class="keyword">and</span> b <span class="keyword">like</span> <span class="string">'%xxx%'</span> <span class="keyword">and</span> c=<span class="number">9</span>;</span><br><span class="line"><span class="comment">-- a用到了 b没有使用，c没有使用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mytable <span class="keyword">where</span> a=<span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> b;</span><br><span class="line"><span class="comment">-- a用到了索引，b在结果排序中也用到了索引的效果，前面说了，a下面任意一段的b是排好序的</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mytable <span class="keyword">where</span> a=<span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> c;</span><br><span class="line"><span class="comment">-- a用到了索引，但是这个地方c没有发挥排序效果，因为中间断点了</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> mytable <span class="keyword">where</span> b=<span class="number">3</span> <span class="keyword">order</span> <span class="keyword">by</span> a;</span><br><span class="line"><span class="comment">-- b没有用到索引，排序中a也没有发挥索引效果</span></span><br></pre></td></tr></table></figure><br><br>## 索引分类和创建<br><br>### 分类<br><br>#### 普通索引<br><br>MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。<br><br>#### 唯一索引<br><br>索引列中的值必须是唯一的，但是允许为空值，<br><br>#### 主键索引<br><br>是一种特殊的唯一索引，不允许有空值。后面会有介绍，在INNODB中，主键索引是聚簇索引。<br><br><br><br>### 创建<br><br>#### 建表时创建<br><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line">(</span><br><span class="line">    [col_name data_type],</span><br><span class="line">    ...,</span><br><span class="line">[<span class="keyword">UNIQUE</span>] [<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>] [index_name] (col_name[<span class="keyword">length</span>], ...) [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><br><br>#### 后期添加<br><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] [<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>] [index_name]</span><br><span class="line">(col_name[<span class="keyword">length</span>], ...) [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><br><br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>] index_name <span class="keyword">ON</span> table_name</span><br><span class="line">(col_name[<span class="keyword">length</span>], ...) [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><br><br><code>INDEX</code>和<code>KEY</code>具有相同的效果。<code>length</code>是指该列在<code>B+树</code>中的关键字所占的长度。<br><br><br><br>### 聚簇索引和非聚簇索引<br><br>#### 聚簇索引<br><br>聚簇的意思是键值和数据行紧凑地存储在一起，因为无法把数据行放在两个不同的地方，所以一个表只有一个聚簇索引。而主键会被默认添加上聚簇索引，如果没有主键，<code>INNODB</code>会选择一个非空索引来替代，如果没有这样的索引，<code>INNODB</code>会隐式定义一个主键来作为聚簇索引。<br><br><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/聚簇索引.jpg"></div><br>#### 非聚簇索引<br><br>非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。又被称为二级索引。INNODB的二级索引其叶子结点上保存的是<code>KEY+PRIMARY COL</code>。<br><br><br><br>### INNODB索引<br><br><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/聚簇索引INNODB.jpg"></div><br>注意：INNODB中主键索引就是聚簇索引。<br><br><br><br>### MyISAM索引<br><br><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/非聚簇索引MYISAM.jpg"></div><h2 id="单表DQL数据准备"><a href="#单表DQL数据准备" class="headerlink" title="单表DQL数据准备"></a>单表DQL数据准备</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> product(</span><br><span class="line">pid <span class="built_in">int</span> primary <span class="keyword">key</span>,</span><br><span class="line">pname <span class="built_in">varchar</span>(<span class="number">20</span>),</span><br><span class="line">price <span class="keyword">double</span>,</span><br><span class="line">category_id <span class="built_in">varchar</span>(<span class="number">32</span>)</span><br><span class="line">);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">1</span>,<span class="string">'联想'</span>,<span class="number">5000</span>,<span class="string">'c001'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">2</span>,<span class="string">'海尔'</span>,<span class="number">3000</span>,<span class="string">'c001'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">3</span>,<span class="string">'雷神'</span>,<span class="number">5000</span>,<span class="string">'c001'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">4</span>,<span class="string">'JACK JONES'</span>,<span class="number">800</span>,<span class="string">'c002'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">5</span>,<span class="string">'真维斯'</span>,<span class="number">200</span>,<span class="string">'c002'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">6</span>,<span class="string">'花花公子'</span>,<span class="number">440</span>,<span class="string">'c002'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">7</span>,<span class="string">'劲霸'</span>,<span class="number">2000</span>,<span class="string">'c002'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">8</span>,<span class="string">'香奈儿'</span>,<span class="number">800</span>,<span class="string">'c003'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">9</span>,<span class="string">'相宜本草'</span>,<span class="number">200</span>,<span class="string">'c003'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">10</span>,<span class="string">'面霸'</span>,<span class="number">5</span>,<span class="string">'c003'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">11</span>,<span class="string">'好想你枣'</span>,<span class="number">56</span>,<span class="string">'c004'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">12</span>,<span class="string">'香飘飘奶茶'</span>,<span class="number">1</span>,<span class="string">'c005'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> product(pid,pname,price,category_id) <span class="keyword">VALUES</span>(<span class="number">13</span>,<span class="string">'果9'</span>,<span class="number">1</span>,<span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure><h3 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h3><ul><li>查询表的所有字段信息：<code>select * from 表名;</code></li><li>查询表中某字段信息：<code>select 字段1, 字段2 from 表名;</code></li><li>去掉重复值：<code>select distinct 字段1, 字段2, ... from 表名;</code><ul><li>若有多个字段则所有字段相等才被算为重复值。</li></ul></li><li>查询结果是表达式（运算查询）：将商品的价格+10元进行显示，<code>select pname,price+10 from product;</code></li><li>别名查询，使用的关键字是as（as可以省略的）：<ul><li>表别名：<code>select * from product as p;</code></li><li>列别名：<code>select pname as pn from product;</code></li></ul></li></ul><h3 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h3><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">&gt; &lt; &lt;= &gt;= = &lt;&gt;!=</td><td style="text-align:center">大于、小于、大于(小于)等于、不等于</td></tr><tr><td style="text-align:center">BETWEEN …AND…</td><td style="text-align:center">显示在某一区间的值(含头含尾)(也可以是日期)</td></tr><tr><td style="text-align:center">IN(set)</td><td style="text-align:center">显示在in列表中的值，例：<code>in(100,200)</code></td></tr><tr><td style="text-align:center">LIKE ‘张%’</td><td style="text-align:center">%代表零个或多个任意字符，_代表一个字符。例如：<code>first_name like ‘_a%’</code></td></tr><tr><td style="text-align:center">IS NULL / IS NOT NULL</td><td style="text-align:center">判断为空/不为空</td></tr><tr><td style="text-align:center">and</td><td style="text-align:center">多个条件同时成立</td></tr><tr><td style="text-align:center">or</td><td style="text-align:center">多个条件任一成立</td></tr><tr><td style="text-align:center">not</td><td style="text-align:center">不成立，例：<code>where not(salary&gt;100);</code></td></tr></tbody></table><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><ul><li>查询商品名称为“花花公子”的商品所有信息：<code>SELECT * FROM product WHERE pname = &#39;花花公子&#39;</code></li><li>查询价格为800商品：<code>SELECT * FROM product WHERE price = 800</code></li><li>查询价格不是800的所有商品：<ul><li><code>SELECT * FROM product WHERE price != 800</code></li><li><code>SELECT * FROM product WHERE price &lt;&gt; 800</code></li><li><code>SELECT * FROM product WHERE NOT(price = 800)</code></li></ul></li><li>查询商品价格大于60元的所有商品信息：<code>SELECT * FROM product WHERE price &gt; 60;</code></li><li>查询商品价格在200到1000之间所有商品：<ul><li><code>SELECT * FROM product WHERE price &gt;= 200 AND price &lt;=1000;</code></li><li><code>SELECT * FROM product WHERE price BETWEEN 200 AND 1000;</code></li></ul></li><li>查询商品价格是200或800的所有商品：<ul><li><code>SELECT * FROM product WHERE price = 200 OR price = 800;</code></li><li><code>SELECT * FROM product WHERE price IN (200,800);</code></li></ul></li><li>查询含有’霸’字的所有商品：<code>SELECT * FROM product WHERE pname LIKE &#39;%霸%&#39;;</code></li><li>查询以’香’开头的所有商品：<code>SELECT * FROM product WHERE pname LIKE &#39;香%&#39;;</code></li><li>查询第二个字为’想’的所有商品：<code>SELECT * FROM product WHERE pname LIKE &#39;_想%&#39;;</code></li><li>查询没有分类的商品：<code>SELECT * FROM product WHERE category_id IS NULL;</code></li><li>查询有分类的商品：<code>SELECT * FROM prod quct WHERE category_id IS NOT NULL</code></li><li>查询所有价格大于2000的电脑商品或者价格大于1000的服装商品：<code>SELECT * FROM product WHERE (price &gt; 2000 AND category_id=&#39;c001&#39;) OR (price &gt;1000 AND category_id=&#39;c002&#39;);</code></li></ul><h3 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h3><h3 id="SELECT-FROM-表名-ORDER-BY-排序字段-ASC-DESC"><a href="#SELECT-FROM-表名-ORDER-BY-排序字段-ASC-DESC" class="headerlink" title="SELECT * FROM 表名 ORDER BY 排序字段 ASC|DESC;"></a><code>SELECT * FROM 表名 ORDER BY 排序字段 ASC|DESC;</code></h3><ul><li>ASC： 升序 (默认)</li><li>DESC：降序</li></ul><h4 id="例："><a href="#例：" class="headerlink" title="例："></a>例：</h4><ul><li>查询所有商品信息，使用价格排序(降序)：<br><code>SELECT * FROM product ORDER BY price DESC;</code></li><li>在价格排序(降序)的基础上，以分类排序(降序)：<br><code>SELECT * FROM product ORDER BY price DESC, category_id DESC;</code></li><li>显示商品的价格(去重复)，并排序(降序)：<br><code>SELECT DISTINCT price FROM product ORDER BY price DESC;</code></li></ul><h3 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h3><h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><ul><li>SELECT不仅可以作用于字段，还可以作用于聚合函数。<ul><li>count(…)：统计指定列不为NULL的记录行数；</li><li>sum(…)：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；</li><li>max(…)：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；</li><li>min(…)：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；</li><li>avg(…)：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；</li></ul></li><li>例：<ul><li>查询商品的总条数：<code>SELECT COUNT(*) FROM product;</code></li><li>查询价格大于200的商品总条数：<code>SELECT COUNT(*) FROM product WHERE price &gt; 200;</code></li><li>查询分类为’c001’的商品价格总和：<br><code>SELECT SUM(price) FROM product WHERE category_id = &#39;c001&#39;;</code></li><li>查询分类为’c002’商品的平均价格：<br><code>SELECT AVG(price) FROM product WHERE category_id = &#39;c002&#39;;</code></li><li>查询商品的最大价格和最小价格：<code>SELECT MAX(price),MIN(price) FROM product;</code></li></ul></li></ul><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><ul><li>分组查询是指使用group by字句对查询信息进行分组。<br>​ <code>SELECT 字段1, 字段2… FROM 表名 GROUP BY 分组字段 HAVING 分组条件;</code></li><li>HAVING：<br>分组操作中的having子语句，是用于在分组后对数据进行过滤的，作用类似于where条件。与where的区别:<ul><li>having是在分组后对数据进行过滤。where是在分组前对数据进行过滤。</li><li>having后面可以使用聚合函数过滤数据。where后面不可以使用聚合函数。</li></ul></li><li>例：<ul><li>统计各个分类商品的个数：<br><code>SELECT category_id ,COUNT(*) FROM product GROUP BY category_id;</code></li><li>统计各个分类商品的个数,且只显示个数大于1的信息：<br><code>SELECT category_id, COUNT(*) FROM product GROUP BY category_id HAVING COUNT(*) &gt; 1;</code></li></ul></li></ul><h3 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h3><p>由于数据量很大，显示屏长度有限，因此对数据需要采取分页显示方式。例如数据共有30条，每页显示5条。</p><ul><li>格式：<br><code>SELECT 字段1，字段2... FROM 表明 LIMIT M, N;</code><ul><li>M: 整数，表示从第几条索引开始，计算方式 （当前页-1）*每页显示条数</li><li>N: 整数，表示查询多少条数据</li></ul></li><li>例：<ul><li><code>SELECT 字段1，字段2... FROM 表明 LIMIT 0,5;</code></li><li><code>SELECT 字段1，字段2... FROM 表明 LIMIT 5,5;</code></li></ul></li></ul><h2 id="多表数据准备"><a href="#多表数据准备" class="headerlink" title="多表数据准备"></a>多表数据准备</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：创建 scott 数据库中的 dept 表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">    deptno      <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> <span class="keyword">COMMENT</span> <span class="string">'部门编号'</span>,</span><br><span class="line">    dname       <span class="built_in">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">COMMENT</span> <span class="string">'部门名称'</span>,</span><br><span class="line">    loc         <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">COMMENT</span> <span class="string">'部门所在位置'</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'部门表'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：创建 scott 数据库中的 emp 表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">    empno           <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> <span class="keyword">COMMENT</span> <span class="string">'雇员编号'</span>,</span><br><span class="line">    ename           <span class="built_in">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">COMMENT</span> <span class="string">'雇员姓名'</span>,</span><br><span class="line">    job             <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">COMMENT</span> <span class="string">'雇员职位'</span>,</span><br><span class="line">    mgr             <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">COMMENT</span> <span class="string">'雇员对应的领导的编号'</span>,</span><br><span class="line">    hiredate        <span class="built_in">DATE</span> <span class="keyword">COMMENT</span> <span class="string">'雇员的雇佣日期'</span>,</span><br><span class="line">    sal             <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">COMMENT</span> <span class="string">'雇员的基本工资'</span>,</span><br><span class="line">    comm            <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">COMMENT</span> <span class="string">'奖金'</span>,</span><br><span class="line">    deptno          <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">COMMENT</span> <span class="string">'所在部门'</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(deptno) <span class="keyword">REFERENCES</span> dept(deptno)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'雇员表'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：创建数据库 scott 中的 salgrade 表，工资等级表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> salgrade(</span><br><span class="line">    grade       <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">COMMENT</span> <span class="string">'工资等级'</span>,</span><br><span class="line">    losal       <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">COMMENT</span> <span class="string">'此等级的最低工资'</span>,</span><br><span class="line">    hisal       <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">COMMENT</span> <span class="string">'此等级的最高工资'</span>  </span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'工资等级表'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：创建数据库 scott 的 bonus 表，工资表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> bonus(</span><br><span class="line">    ename       <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">COMMENT</span> <span class="string">'雇员姓名'</span>,</span><br><span class="line">    job         <span class="built_in">VARCHAR</span>(<span class="number">9</span>) <span class="keyword">COMMENT</span> <span class="string">'雇员职位'</span>,</span><br><span class="line">    sal         <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">COMMENT</span> <span class="string">'雇员工资'</span>,</span><br><span class="line">    comm        <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">COMMENT</span> <span class="string">'雇员资金'</span>  </span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'工资表'</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：插入数据库 scott 中表 dept 的初始化数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">VALUES</span> (<span class="number">10</span>,<span class="string">'ACCOUNTING'</span>,<span class="string">'NEW YORK'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">VALUES</span> (<span class="number">20</span>,<span class="string">'RESEARCH'</span>,<span class="string">'DALLAS'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">VALUES</span> (<span class="number">30</span>,<span class="string">'SALES'</span>,<span class="string">'CHICAGO'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">VALUES</span> (<span class="number">40</span>,<span class="string">'OPERATIONS'</span>,<span class="string">'BOSTON'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：插入数据库 scott 中表 emp 的初始数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7369</span>,<span class="string">'SMITH'</span>,<span class="string">'CLERK'</span>,<span class="number">7902</span>,<span class="string">'1980-12-17'</span>,<span class="number">800</span>,<span class="literal">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7499</span>,<span class="string">'ALLEN'</span>,<span class="string">'SALESMAN'</span>,<span class="number">7698</span>,<span class="string">'1981-2-20'</span>,<span class="number">1600</span>,<span class="number">300</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7521</span>,<span class="string">'WARD'</span>,<span class="string">'SALESMAN'</span>,<span class="number">7698</span>,<span class="string">'1981-2-22'</span>,<span class="number">1250</span>,<span class="number">500</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7566</span>,<span class="string">'JONES'</span>,<span class="string">'MANAGER'</span>,<span class="number">7839</span>,<span class="string">'1981-4-2'</span>,<span class="number">2975</span>,<span class="literal">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7654</span>,<span class="string">'MARTIN'</span>,<span class="string">'SALESMAN'</span>,<span class="number">7698</span>,<span class="string">'1981-9-28'</span>,<span class="number">1250</span>,<span class="number">1400</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7698</span>,<span class="string">'BLAKE'</span>,<span class="string">'MANAGER'</span>,<span class="number">7839</span>,<span class="string">'1981-5-1'</span>,<span class="number">2850</span>,<span class="literal">NULL</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7782</span>,<span class="string">'CLARK'</span>,<span class="string">'MANAGER'</span>,<span class="number">7839</span>,<span class="string">'1981-6-9'</span>,<span class="number">2450</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7788</span>,<span class="string">'SCOTT'</span>,<span class="string">'ANALYST'</span>,<span class="number">7566</span>,<span class="string">'87-7-13'</span>,<span class="number">3000</span>,<span class="literal">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7839</span>,<span class="string">'KING'</span>,<span class="string">'PRESIDENT'</span>,<span class="literal">NULL</span>,<span class="string">'1981-11-7'</span>,<span class="number">5000</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7844</span>,<span class="string">'TURNER'</span>,<span class="string">'SALESMAN'</span>,<span class="number">7698</span>,<span class="string">'1981-9-8'</span>,<span class="number">1500</span>,<span class="number">0</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7876</span>,<span class="string">'ADAMS'</span>,<span class="string">'CLERK'</span>,<span class="number">7788</span>,<span class="string">'87-7-13'</span>,<span class="number">1100</span>,<span class="literal">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7900</span>,<span class="string">'JAMES'</span>,<span class="string">'CLERK'</span>,<span class="number">7698</span>,<span class="string">'1981-12-3'</span>,<span class="number">950</span>,<span class="literal">NULL</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7902</span>,<span class="string">'FORD'</span>,<span class="string">'ANALYST'</span>,<span class="number">7566</span>,<span class="string">'1981-12-3'</span>,<span class="number">3000</span>,<span class="literal">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7934</span>,<span class="string">'MILLER'</span>,<span class="string">'CLERK'</span>,<span class="number">7782</span>,<span class="string">'1982-1-23'</span>,<span class="number">1300</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：插入数据库 scott 中表 salgrade 的初始数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">700</span>,<span class="number">1200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">1201</span>,<span class="number">1400</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">1401</span>,<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="number">2001</span>,<span class="number">3000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="number">3001</span>,<span class="number">9999</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">dept( </span><br><span class="line">    DEPTNO,//部门编号，由两位数字所组成</span><br><span class="line">    DNAME,//部门名称，最多由14个字符所组成, </span><br><span class="line">    LOC//部门所在的位置</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">emp(       </span><br><span class="line">    EMPNO,//雇员的编号，由四位数字所组成</span><br><span class="line">    ENAME,//雇员的姓名，由10位字符所组成</span><br><span class="line">    JOB,//雇员的职位</span><br><span class="line">    MGR,//雇员对应的经理编号，经理也是雇员</span><br><span class="line">    HIREDATE,//雇员的雇佣日期</span><br><span class="line">    SAL,//基本工资，其中有两位小数，五倍整数，一共是七位</span><br><span class="line">    COMM,//奖金，佣金</span><br><span class="line">    DEPTNO//雇员所在的部门编号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">salgrade(  </span><br><span class="line">    GRADE,//工资的等级</span><br><span class="line">    LOSAL,//此等级的最低工资</span><br><span class="line">    HISAL//此等级的最高工资</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">bonus(   </span><br><span class="line">    ENAME,//雇员姓名</span><br><span class="line">    JOB,//雇员职位</span><br><span class="line">    SAL,//雇员的工资</span><br><span class="line">    COMM//雇员的奖金</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h3><p>自连接就是自己和自己连接，在使用时将一张表看做多张表使用。</p><ul><li><p>查询员工编号，员工姓名，经理的编号，经理的姓名</p><p>KING没有经理，所以查询出来只有13条记录</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">e1.empno,</span><br><span class="line">e1.ename,</span><br><span class="line">e1.mgr,</span><br><span class="line">m1.ename</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">emp m1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.mgr = m1.empno</span><br></pre></td></tr></table></figure><p></p><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/自连接01.jpg"></div><p></p><ul><li>查询员工编号，员工姓名，员工的部门名称，经理的编号，经理的姓名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">e1.empno,</span><br><span class="line">e1.ename,</span><br><span class="line">d1.dname,</span><br><span class="line">e1.mgr,</span><br><span class="line">m1.ename</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">emp m1,</span><br><span class="line">dept d1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.mgr = m1.empno</span><br><span class="line">    <span class="keyword">AND</span> e1.deptno = d1.deptno</span><br></pre></td></tr></table></figure><p></p><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/自连接02.jpg"></div><p></p><ul><li>查询员工编号，员工姓名，员工的部门名称，经理的编号，经理的姓名，经理的部门名称</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">e1.empno,</span><br><span class="line">e1.ename,</span><br><span class="line">d1.dname,</span><br><span class="line">e1.mgr,</span><br><span class="line">m1.ename,</span><br><span class="line">d2.dname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">emp m1,</span><br><span class="line">dept d1,</span><br><span class="line">dept d2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.mgr = m1.empno</span><br><span class="line">    <span class="keyword">AND</span> e1.deptno = d1.deptno</span><br><span class="line">    <span class="keyword">AND</span> m1.deptno = d2.deptno</span><br></pre></td></tr></table></figure><p></p><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/自连接03.jpg"></div><br>这里有一个难点是为什么需要拓展出两张部门表？这里需要理解刚才说的一句话：<code>在使用时将一张表看做多张表使用</code>，想象一下，如果真实存在一张员工表和一张经理表，<code>员工表.部门=部门.id</code>，<code>经理表.部门=部门.id</code>，不就等于是经理和员工在一个部门才能要求吗？这个题意明显不符。<p></p><ul><li>查询员工编号，员工姓名，员工的部门名称，员工的工资等级，经理的编号，经理的姓名，经理的部门名称</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">e1.empno,</span><br><span class="line">e1.ename,</span><br><span class="line">d1.dname,</span><br><span class="line">s1.grade,</span><br><span class="line">e1.mgr,</span><br><span class="line">m1.ename,</span><br><span class="line">d2.dname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">emp m1,</span><br><span class="line">dept d1,</span><br><span class="line">dept d2,</span><br><span class="line">salgrade s1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.mgr = m1.empno</span><br><span class="line"><span class="keyword">AND</span> e1.deptno = d1.deptno</span><br><span class="line"><span class="keyword">AND</span> m1.deptno = d2.deptno</span><br><span class="line"><span class="keyword">AND</span> e1.sal <span class="keyword">BETWEEN</span> s1.losal<span class="keyword">AND</span> s1.hisal</span><br></pre></td></tr></table></figure><p></p><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/自连接04.jpg"></div><p></p><ul><li>查询员工编号，员工姓名，员工的部门名称，员工的工资等级，经理的编号，经理的姓名，经理的部门名称，员工所属经理的工资等级</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">e1.empno,</span><br><span class="line">e1.ename,</span><br><span class="line">d1.dname,</span><br><span class="line">s1.grade,</span><br><span class="line">e1.mgr,</span><br><span class="line">m1.ename,</span><br><span class="line">d2.dname,</span><br><span class="line">s2.grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">emp m1,</span><br><span class="line">dept d1,</span><br><span class="line">dept d2,</span><br><span class="line">salgrade s1,</span><br><span class="line">salgrade s2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.mgr = m1.empno</span><br><span class="line"><span class="keyword">AND</span> e1.deptno = d1.deptno</span><br><span class="line"><span class="keyword">AND</span> m1.deptno = d2.deptno</span><br><span class="line"><span class="keyword">AND</span> e1.sal <span class="keyword">BETWEEN</span> s1.losal <span class="keyword">AND</span> s1.hisal</span><br><span class="line"><span class="keyword">AND</span> m1.sal <span class="keyword">BETWEEN</span> s2.losal <span class="keyword">AND</span> s2.hisal</span><br></pre></td></tr></table></figure><p></p><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/自连接05.jpg"></div><p></p><ul><li>查询员工编号，员工姓名，员工的部门名称，员工的工资等级，经理的编号，经理的姓名，经理的部门名称，经理的工资等级（将工资等级 1,2,3,4 显示成 中文的 一级 二级 三级…）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">e1.empno,</span><br><span class="line">e1.ename,</span><br><span class="line">d1.dname,</span><br><span class="line"><span class="keyword">CASE</span> s1.grade</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'一级'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'二级'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">3</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'三级'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">4</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'四级'</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="string">'五级'</span></span><br><span class="line"><span class="keyword">END</span> <span class="string">"等级"</span>,</span><br><span class="line">e1.mgr,</span><br><span class="line">m1.ename,</span><br><span class="line">d2.dname,</span><br><span class="line"><span class="keyword">CASE</span> s2.grade</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'一级'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'二级'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">3</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'三级'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">4</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'四级'</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="string">'五级'</span></span><br><span class="line"><span class="keyword">END</span> <span class="string">"等级"</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">emp m1,</span><br><span class="line">dept d1,</span><br><span class="line">dept d2,</span><br><span class="line">salgrade s1,</span><br><span class="line">salgrade s2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.mgr = m1.empno</span><br><span class="line"><span class="keyword">AND</span> e1.deptno = d1.deptno</span><br><span class="line"><span class="keyword">AND</span> m1.deptno = d2.deptno</span><br><span class="line"><span class="keyword">AND</span> e1.sal <span class="keyword">BETWEEN</span> s1.losal <span class="keyword">AND</span> s1.hisal</span><br><span class="line"><span class="keyword">AND</span> m1.sal <span class="keyword">BETWEEN</span> s2.losal <span class="keyword">AND</span> s2.hisal</span><br></pre></td></tr></table></figure><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>数据准备：<code>insert into emp(empno,ename) values(9527,&#39;HUAAN&#39;);</code></p><p>左外连接以左表为基准，右表能匹配上左表则匹配，右表没有一条记录匹配上左表，左表显示为空。</p><p>右连接是以右表为基准，左表能匹配上右表则匹配，左表没有一条记录匹配上右表，右表显示为空。</p><ul><li>查询员工所在的部门</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept d1 <span class="keyword">ON</span> e1.deptno = d1.deptno;</span><br></pre></td></tr></table></figure><ul><li>查询部门的员工</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept d1 <span class="keyword">ON</span> e1.deptno = d1.deptno;</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><ul><li>查询最高工资的员工信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sal = (<span class="keyword">SELECT</span> <span class="keyword">max</span>(sal) <span class="keyword">FROM</span> emp);</span><br></pre></td></tr></table></figure><ul><li>查询出比雇员7654的工资高,同时和7788从事相同工作的员工信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sal &gt; (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sal</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">empno = <span class="number">7654</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AND</span> job = (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">job</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">empno = <span class="number">7788</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>查询每个部门最低工资的员工信息和他所在的部门信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询每个部门的最低工资,分组统计</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">deptno,</span><br><span class="line"><span class="keyword">min</span>(sal) minsal</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 员工工资等于他所处部门的最低工资</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">deptno,</span><br><span class="line"><span class="keyword">min</span>(sal) minsal</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">deptno</span><br><span class="line">) t1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.deptno = t1.deptno</span><br><span class="line"><span class="keyword">AND</span> e1.sal = t1.minsal;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询部门相关信息</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">deptno,</span><br><span class="line"><span class="keyword">min</span>(sal) minsal</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">deptno</span><br><span class="line">) t1,</span><br><span class="line">dept d1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.deptno = t1.deptno</span><br><span class="line"><span class="keyword">AND</span> e1.sal = t1.minsal</span><br><span class="line"><span class="keyword">AND</span> e1.deptno = d1.deptno;</span><br></pre></td></tr></table></figure><ul><li>查询领导信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">empno <span class="keyword">IN</span> (<span class="keyword">SELECT</span> mgr <span class="keyword">FROM</span> emp);</span><br></pre></td></tr></table></figure><ul><li>查询不是领导的信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误的写法</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">empno <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> mgr <span class="keyword">FROM</span> emp);</span><br><span class="line"><span class="comment"># &lt;&gt; ALL 等价于 NOT IN</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">empno &lt;&gt; <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> mgr <span class="keyword">FROM</span> emp);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的写法</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">empno <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">mgr</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">mgr <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>查询出比20号部门所有员工薪资高的员工信息 10 20 30</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法1</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sal &gt; (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">max</span>(sal)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">deptno = <span class="number">20</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法2</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sal &gt; <span class="keyword">ALL</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sal</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">deptno = <span class="number">20</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>查询有员工的部门的信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">dept d1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.deptno = d1.deptno</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p></p><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/exist1.jpg"></div><p></p><ul><li>补充<code>EXISTS</code></li></ul><p>假设有三张表，学生、课程、选课表。查询选修了全部课程的同学。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">从上面的例子可以看到EXITSTS其实是对外部表的某个字段做循环。循环变量带入内部表后判断</span></span><br><span class="line"><span class="comment">从内部表能否查出来信息，能查出来表示真（留下），查不出来表示假（去除）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以这个题就是对每个学生做循环，把学生带入内部查询，查询学生是否有未选修的课，如果有</span></span><br><span class="line"><span class="comment">学生去除，否则学生留下，所以选用not exists：</span></span><br><span class="line"><span class="comment">select * from student where not exists (学生未选修的课)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">假设某次循环的学号是 110，此时需要拿course中的每个课号到sc表中做循环，查询在sc表的</span></span><br><span class="line"><span class="comment">学号为110且course.no = sc.cno的情况下，记录是否存在，记录存在course去除，记录不存</span></span><br><span class="line"><span class="comment">在course留下，所以选用not exists：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">select * from course where not exists</span></span><br><span class="line"><span class="comment">        select * from sc where 110 = sc.sno and sc.cno = course.no;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这样，可以查出学号为110的同学未选修的课程。</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">把两次分析的合并之后：</span></span><br><span class="line"><span class="comment">select * from student where not exists(</span></span><br><span class="line"><span class="comment">select * from course where not exists(</span></span><br><span class="line"><span class="comment">                select * from sc where </span></span><br><span class="line"><span class="comment">                student.no = sc.sno and sc.cno = course.no;</span></span><br><span class="line"><span class="comment">            )</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>现在还是这三张表，我们换个题，查询被所有学生选修的课程信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">对课程做循环，把课程带入内部查询，如果有学生未选此课，课程去除，否则课程留下，</span></span><br><span class="line"><span class="comment">所以选用not exists：：</span></span><br><span class="line"><span class="comment">select * from course where not exists (未被选的课)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">假设某次循环，课号为120，此时拿student中的每个学号到sc表做循环，查询在sc表的课号为</span></span><br><span class="line"><span class="comment">120且student.no = sc.sno的情况下，记录是否存在，记录存在student去除，记录不存在</span></span><br><span class="line"><span class="comment">student留下，所以选用not exists：：</span></span><br><span class="line"><span class="comment">select * from student where not exists </span></span><br><span class="line"><span class="comment">select * from sc where student.no = sc.sno and 120 = sc.no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">两次分析合并</span></span><br><span class="line"><span class="comment">select * from course where not exists(</span></span><br><span class="line"><span class="comment">select * from student where not exists(</span></span><br><span class="line"><span class="comment">select * from sc where </span></span><br><span class="line"><span class="comment">course.no = sc.cno and sc.sno = student.no</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>查询没有一个学生选择的课：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对course做循环，如果存在学生选此课去除，没有学生选此课保留，选用not exists：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对内部循环，记录存在保留，记录不存在去除，选用exists：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> course <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> sc <span class="keyword">where</span> </span><br><span class="line">        course.no = sc.cno <span class="keyword">and</span> sc.sno = student.no</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h3><p>A：原子性（Atomicity）：事务是数据库的逻辑工作单位事务中包括的诸操作要么都做，要么都不做。</p><p>C：一致性（Consistency）：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。</p><ul><li><p>一致性状态：数据库中只包含成功事务提交的结果。</p></li><li><p>不一致状态：数据库中包含失败事务的结果。</p></li></ul><p>I：隔离性（Isolation）：一个事务内部的操作及使用的数据对其他并发事务是隔离的。也就是说一个事务在执行的时候不知道是否有其他事务和它一起在对相同的数据做操作，事务之间是相对不可见的。</p><p>D：持续性（Durability）：持续性也称永久性。一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。</p><h3 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h3><p>由于事务的隔离性，不同事务若同时相同的数据做操作，可能会引发问题，即事务的并发问题。按照问题解决的难度由低至高可分为四类。</p><h4 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h4><p>一个事务对数据对象的修改被另一个事务的修改所覆盖。分为两类：</p><ul><li>第一类：事务T1、T2同时读取A为10，T1将A减1后提交，T2将A也减1后<strong>提交</strong>，此时数据库中数据为9。T1的修改被T2覆盖。</li><li>第一类：事务T1、T2同时读取A为10，T1将A减1后提交，T2将A也减1后<strong>回滚</strong>，此时数据库中数据为10。T1的修改被T2覆盖。</li></ul><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><p>由于一个事物的回滚，使得另一个事务读到的数据无效。事务T1中读A为100，修改A未300，还未提交时事务T2读C为300，但由于T1因某原因进行事务回滚。A又被重置为100。T2读取到的是脏数据。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><p>在一个事务的两次“读”同一数据之间，有另一个事务的“updata”发生。如在事务T1中第一次读A为100，读B为200，A+B为300，在事务T2中把A修改为200，事务T2第二次读A为200，读B为200，A+B为400。同一事务两次读取的数据不一致。</p><h4 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h4><p>在一个事务的两次“读”同一数据之间，有另一个事务的“insert”发生。如在事务T1中第一次读<code>count(*)</code>为100，事务T2插入一条数据，事务T1中第二次读<code>count(*)</code>为101，同一事务两次读取的数据不一致。</p><h3 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h3><p>加锁是解决事务并发问题的常见手段。数据库中的锁从读写的角度可分为两类：共享锁和排它锁。</p><ul><li>排它锁（X锁）：只允许当前事务T对数据进行“读”、“写”，其它事务对数据R的任何锁请求被拒绝直到T释放R上的X锁。</li><li>共享锁（S锁）：允许当前事务T对数据R进行“读”，不允许“写“，而其它事务对R的S申请被允许，X请求拒绝。</li></ul><p>带来的效果是：</p><ul><li>X锁：数据对象当前只能由一个事务操作。</li><li>S锁：多个事务允许同时“读”一个数据。</li></ul><h3 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h3><p>在运用X锁和S锁对数据对象加锁时，还需要约定一些规则 ，例如何时申请X锁或S锁、持锁时间、何时释放等。称这些规则为封锁协议。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。</p><h4 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h4><p>对T要“写”的R加X锁，直到T结束。此时可以解决丢失更新。此时仍然会发生：</p><ul><li>脏读：事务T2可以绕过X锁读取数据，且读取到的是T1回滚的数据。</li><li>不可重复读：事务T2的两次读之间可以发生T1的”update“。</li><li>幻读：事务T2的两次读之间可以发生T1的”insert“。</li></ul><h4 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h4><ul><li>T发生“写”加X锁，直到T结束；（一级封锁协议）</li><li>T发生“读”R加S锁，读完即释放。</li></ul><p>此时可以解决丢失修改和脏读。</p><ul><li>事务T1先对R进行写（加X锁），则事务T2在读时没法加S锁，直至T1结束。</li><li>事务T2先对R进行读（加S锁），则事务T1在写时需要等待读结束（T1不一定结束）。</li></ul><p>此时仍然会发生：</p><ul><li>不可重复读：事务T1在第一次读之后（释放S锁），事务T2进行了”update”操作，事务T1再读得到的数据和上次不一致。</li><li>幻读：事务T1在第一次读之后（释放S锁），事务T2进行了”insert”操作，事务T1再读得到的数据和上次不一致。</li></ul><h4 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h4><ul><li>T发生“写”加X锁，直到T结束。</li><li>T发生“读”加S锁，直到T结束。</li></ul><p>此时可以解决任何并发问题，因为无论对数据进行读还是写都要加锁：</p><ul><li>写：先加X锁，之后任何读写都被禁止。</li><li>读：先加S锁，之后任何写操作都被被禁止。</li></ul><p>三级封锁协议仅允许不同的事务同时发生读操作。</p><h4 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h4><ul><li>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁。</li><li>在释放一个封锁之后，事务不再获得任何其他封锁。</li></ul><p>满足所有遵守两段锁协议的事务，其并行执行的结果一定是正确的：</p><ul><li>先加X锁：X锁结束前（在两段锁协议中，不一定要事务结束才能释放X锁）任何锁都不能加上去，X锁结束后此事务不能再进行任何读写操作。</li><li>先加S锁：S锁结束前，只能对其加S锁，即只允许多个事务同时读。一旦释放一个S锁，便任何锁都加不上去，只能完成为完成的读，不能再进行新的读写操作。</li></ul><p>满足三级封锁协议的一定满足两段锁协议：</p><ul><li>先加X锁，两种协议下事务结束之前任何读写都会被禁止。</li><li>先加S锁，在两段锁协议中，若第一个锁的释放之后紧跟的事件就是事务的结束，此时就是三级封锁协议，即三级封锁协议是两段锁协议的一部分。</li></ul><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><p>读未提交：READ UNCOMMITTED。对应一级封锁协议。</p><p>读已提交：READ COMMITTED。对应二级封锁协议。</p><p>可重复读：REPEATABLE READ。二级封锁协议加上不允许事务读取在该事务开始后新提交的数据。即防止了不可重复读的发生。</p><p>可串行化：SERIALIZABLE。对应三级封锁协议。</p><h3 id="MySql特点"><a href="#MySql特点" class="headerlink" title="MySql特点"></a>MySql特点</h3><ol><li>MySql默认的事务隔离级别是读已提交</li><li>MySql的事务是自动提交，即即使未事务，MySql也会把每个SQL语句放在一个事务中运行，这个事务是MySql自动添加上去的。</li></ol><h2 id="MySQL-基础架构分析"><a href="#MySQL-基础架构分析" class="headerlink" title="MySQL 基础架构分析"></a>MySQL 基础架构分析</h2><h3 id="1-1-MySQL-基本架构概览"><a href="#1-1-MySQL-基本架构概览" class="headerlink" title="1.1 MySQL 基本架构概览"></a>1.1 MySQL 基本架构概览</h3><p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p><p>先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。</p><ul><li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li><strong>查询缓存:</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li><strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li><li><strong>执行器:</strong> 执行语句，然后从存储引擎返回数据。</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/3/23/169a8bc60a083849?w=950&amp;h=1062&amp;f=jpeg&amp;s=38189" alt="img"></p><p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p><ul><li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</li><li><strong>存储引擎</strong>： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。</strong></li></ul><h3 id="1-2-Server-层基本组件介绍"><a href="#1-2-Server-层基本组件介绍" class="headerlink" title="1.2 Server 层基本组件介绍"></a>1.2 Server 层基本组件介绍</h3><h4 id="连接器"><a href="#连接器" class="headerlink" title="连接器"></a>连接器</h4><p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p><p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即时管理员修改了该用户的权限，该用户也是不受影响的。</p><h4 id="查询缓存-MySQL-8-0-版本后移除"><a href="#查询缓存-MySQL-8-0-版本后移除" class="headerlink" title="查询缓存(MySQL 8.0 版本后移除"></a>查询缓存(MySQL 8.0 版本后移除</h4><p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p><p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 sql 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询预计，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p><p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p><p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p><p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p><h4 id="分析器"><a href="#分析器" class="headerlink" title="分析器"></a>分析器</h4><p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p><p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p><p><strong>第二步，语法分析</strong>，主要就是判断你输入的 sql 是否正确，是否符合 MySQL 的语法。</p><p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p><h4 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h4><p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p><p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p><h4 id="执行器"><a href="#执行器" class="headerlink" title="执行器"></a>执行器</h4><p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p><h3 id="语句分析"><a href="#语句分析" class="headerlink" title="语句分析"></a>语句分析</h3><h4 id="查询语句"><a href="#查询语句" class="headerlink" title="查询语句"></a>查询语句</h4><p>说了以上这么多，那么究竟一条 sql 语句是如何执行的呢？其实我们的 sql 可以分为两种，一种是查询，一种是更新（增加，更新，删除）。我们先分析下查询语句，语句如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> tb_student  A <span class="keyword">where</span> A.age=<span class="string">'18'</span> <span class="keyword">and</span> A.name=<span class="string">' 张三 '</span>;</span><br></pre></td></tr></table></figure><p>结合上面的说明，我们分析下这个语句的执行流程：</p><ul><li><p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 sql 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p></li><li><p>通过分析器进行词法分析，提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student,需要查询所有的列，查询条件是这个表的 id=’1’。然后判断这个 sql 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p></li><li><p>接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。</span><br><span class="line">b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。</span><br></pre></td></tr></table></figure><p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p></li><li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p></li></ul><h4 id="更新语句"><a href="#更新语句" class="headerlink" title="更新语句"></a>更新语句</h4><p>以上就是一条查询 sql 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？sql 语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update tb_student A set A.age=&apos;19&apos; where A.name=&apos; 张三 &apos;;</span><br></pre></td></tr></table></figure><p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块式 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p><ul><li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li><li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li><li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li><li>更新完成。</li></ul><p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p><p>这是因为最开始 MySQL 并没与 InnoDB 引擎( InnoDB 引擎是其他公司以插件形式插入 MySQL 的) ，MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p><p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p><ul><li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 bingog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li><li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li></ul><p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binglog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binglog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p><ul><li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li><li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li></ul><p>这样就解决了数据一致性的问题。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用,redolog 只有 InnoDB 有。</li><li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li><li>查询语句的执行流程如下：权限校验（如果命中缓存）—》查询缓存—》分析器—》优化器—》权限校验—》执行器—》引擎</li><li>更新语句执行流程如下：分析器—-》权限校验—-》执行器—》引擎—redo log(prepare 状态—》binlog—》redo log(commit状态)</li></ul><h2 id="关系-amp-关系模式"><a href="#关系-amp-关系模式" class="headerlink" title="关系 &amp; 关系模式"></a>关系 &amp; 关系模式</h2><p>关系模式相当于一张二维表的框架，在这个框架下填入数据，称为关系模式的一个实例，或者叫关系R。关系模式的形式化定义是：$R(U,D,DOM,F)$</p><ul><li>R：关系名</li><li>U：组成该关系的属性名集合</li><li>D：U中属性所来自的域<ul><li>域：一组具有相同数据类型的值的集合</li></ul></li><li>DOM：属性向域的映像集合</li><li>F：属性间数据的依赖关系集合</li></ul><p>由于D和DOM域与关系模式的设计无关，因此在讨论关系数据库理论时可以把关系模式看做：$R(U,F)$</p><p>关系的形式化定义：当且仅当$U$上的一个关系$r$满足$F$时，r称为关系模式$R(U,F)$上的一个关系。</p><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>关系模式的设计直接影响着后续增删查改等的操作。如果设计的不合理就会发生各种各样的问题：</p><ul><li>数据冗余太大</li><li>更新异常</li><li>插入异常</li><li>删除异常</li></ul><p>比如对于一个描述学校在校生信息数据库：$Student&lt;U,F&gt;$，$U=\lbrace Sno,Sdept,Mname,Cname,Grade\rbrace$会发生的问题：</p><ul><li>冗余问题：每个系的系主任姓名重复出现，重复次数与该系所有学生的所有课程成绩次数相同</li><li>更新问题：如果某系的系主任更换后，该数据库该系中所有的元组都要更新</li><li>插入异常：如果一个系刚成立，尚无学生，则无法把该系的系主任存入数据库</li><li>删除异常：如果某个系的学生都毕业了，在删除该系学生的同时，该系系主任的信息也会被删除</li></ul><p>一个好的模式不能发生插入异常、删除异常和更新异常，数据冗余应该尽可能少。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>范式指的是规范化的关系模式，而规范也就是条件，满足不同的条件可以分别解除上述所说的不同问题。</p><h3 id="问题发生的原因"><a href="#问题发生的原因" class="headerlink" title="问题发生的原因"></a>问题发生的原因</h3><p>之所以会发生上诉的问题其实就是由于数据依赖。而数据依赖可以分为两种：函数依赖和多值依赖。但这两种依赖关系不是平级，而是递进的关系，所以我们先介绍函数依赖。</p><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>设$R(U)$是一个属性集$U$上的关系模式，$X$和$Y$是$U$的子集。若对于$R(U)$的任意两个可能的关系$r_1$、$r_2$，若$r_1[x]=r_2[x]$，则$r_1[y]=r_2[y]$，则称$X$决定$Y$，或者$Y$依赖$X$。记作$X \rightarrow Y$。</p><p>对于$X$、$Y$范围的不同，可以再次分为：</p><ul><li>非平凡函数依赖：如果$X \rightarrow Y$但$Y \nsubseteq X$，则称$X \rightarrow Y$是非平凡函数依赖</li><li>平凡函数依赖：如果$X \rightarrow Y$但$Y \subseteq X$，则称$X \rightarrow Y$是非平凡函数依赖。<ul><li>例：$(Sno,Sname) \rightarrow Sname$</li></ul></li></ul><p>所以，在关系模式中，平凡函数依赖是一定是可以被满足的，所以我们在以后的讨论中不再关注平凡函数依赖，只关注非平凡函数依赖。而我们对于非平凡函数依赖又可以分为以下几类：</p><ul><li>完全函数依赖：如果$X \rightarrow Y$，并且对于任意的真子集$X_i$，都无法做到$X_i \rightarrow Y$，则称$Y$对$X$是完全函数依赖。</li><li>部分函数依赖：如果$X \rightarrow Y$，存在真子集$X_i$，可以做到$X_i \rightarrow Y$，则称$Y$对$X$是部分函数依赖。</li><li>传递函数依赖：如果$X \rightarrow Y$，$Y \rightarrow Z$且$Y \nrightarrow X$，则称$X$对$X$有传递函数依赖。</li></ul><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>在关系模型中的每一个具体关系$R$中，如果每个属性都是不可再分的，则称$R$属于第一范式，记作$R \in 1NF$。</p><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>$R \in 1NF$且每一个非主属性完全函数依赖于码，则$R \in 2NF$。依赖有直接依赖和传递依赖。</p><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>$R \in 2NF$且$R$中的每个非主属性不传递依赖于主码，则关系$R$是第三范式，$R \in 3NF$。</p><h3 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h3><p>从低级范式到高级范式的方法是模式分解。</p><p>举例：对于一个关系$R(SNO,SNA,CNO,GRADE,CNA,TNA,TAGE)$（学号、姓名、课号、成绩、课程名称、教师姓名、教师年龄）。</p><p>现实语义：如果假设一个教师可以交多门课且一门课仅由一个教师讲授，可得R的函数依赖集：</p><ul><li>$SNO \rightarrow SNM$</li><li>$(SNO,CNO) \rightarrow GRADE$</li><li>$CNO \rightarrow CNA$</li><li>$CNO \rightarrow TNA$</li><li>$TNA \rightarrow TAGE$</li></ul><p>函数依赖图如下：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/函数依赖图.jpg" style="width:50%"></div><br>分解为第二范式：<p></p><ul><li>$R1&lt;(SNO,SNA),SNO \rightarrow SNA&gt;$</li><li>$R2&lt;(SNO,CNO,GRADE), (SNO,CNO) \rightarrow GRADE&gt;$</li><li>$R3&lt;(CNO,CNA,TNA,TAGE),CNO \rightarrow CNA, CNO \rightarrow TNA, TNA \rightarrow TAGE&gt;$</li></ul><p>分解为第三范式：</p><ul><li>$R1&lt;(SNO,SNA),SNO \rightarrow SNA&gt;$</li><li>$R2&lt;(SNO,CNO,GRADE), (SNO,CNO) \rightarrow GRADE&gt;$</li><li>$R3&lt;(CNO,CNA,TNA),CNO \rightarrow CNA, CNO \rightarrow TNA&gt;$</li><li>$R3&lt;(CNO,TAGE),CNO \rightarrow TAGE&gt;$</li></ul><h3 id="第三范式的问题"><a href="#第三范式的问题" class="headerlink" title="第三范式的问题"></a>第三范式的问题</h3><p>仓库保管$WPE(W#,P#,E#,QNT)$，（ 仓库号，器件号，职工号，数量）。</p><p>一个职工只能管理一个仓库的某类型器件，一个仓库的某类型器件数量是确定的，一个员工管理的某类型器件数量是一定的。</p><p>函数依赖：</p><ol><li>$(W#, P#) \rightarrow QNT$</li><li>$(E#,P#) \rightarrow QNT$</li><li>$(W#,P#) \rightarrow E#$</li><li>$E# \rightarrow W#$</li></ol><p>函数依赖图：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/函数依赖图2.jpg" style="width:50%"></div><br>此时关系模式$WPE$有两个侯选码，$(W#,P#)$ ，$(E#,P#)$，假设确定$(E#,P#)$为主码，那么某新职工分配来仓库，处于学习阶段，但没有独立承但任务，即有$E#$但无$P#$，缺少码的组成部分，无法插入到该关系，即插入异常。这是由于<strong>主属性$W#$对另一个侯选码$(E#,P#)$的部分函数依赖</strong>。<p></p><h3 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h3><p>BC范式的定义：每个决定因素都包含码，则$R \in BCNF$。</p><p>而既然每个决定因素都要包含码，则此时意味着必须放弃某些函数依赖，即失去某些现实语义。如例子中若选择$(E#,P#)$，则只能保存函数依赖中的2和4。</p><h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h3><p>设$R(U)$是属性集U上的一个关系模式。$X$，$Y$，$Z$是的$U$的子集，并且$Z=U-X-Y$。关系模式$R(U)$中多值依赖（记做，$X \rightarrow \rightarrow Y$）成立，当且仅当对$R(U)$的任一关系$r$，给定的一对$(x,z)$值有一组$Y$的值，这组值仅仅决定于$x$值而与$z$值无关。</p><p>若$X \rightarrow \rightarrow Y$，$Z$为空，则称$X \rightarrow \rightarrow Y$为平凡的多值依赖。 所以我们以下只讨论非平凡的函数依赖。</p><h4 id="例-1"><a href="#例-1" class="headerlink" title="例"></a>例</h4><p>比如对于关系模型$Teaching(C,T,B)$便是存在多值依赖（码为全属性）：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/02-MySQL/teaching.jpg" style="width:80%"></div><p></p><h3 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h3><p>如果对于$R$的每个非平凡多值依赖$X \rightarrow \rightarrow Y$，$X$都含有码，则$R$都含有码。</p><p>多值依赖的解决依然是分解。如上例中分解为：</p><ul><li>$R(C,T)$</li><li>$R(C,B)$</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;B树&quot;&gt;&lt;a href=&quot;#B树&quot; class=&quot;headerlink&quot; title=&quot;B树&quot;&gt;&lt;/a&gt;B树&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/categories/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/tags/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="面试" scheme="https://isjinhao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>01-Java基础</title>
    <link href="https://isjinhao.github.io/2019/01-Java%E5%9F%BA%E7%A1%80/"/>
    <id>https://isjinhao.github.io/2019/01-Java基础/</id>
    <published>2019-07-28T08:38:28.000Z</published>
    <updated>2019-08-27T11:19:20.998Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --><h2 id="JVM-amp-JDK-amp-JRE"><a href="#JVM-amp-JDK-amp-JRE" class="headerlink" title="JVM &amp; JDK &amp; JRE"></a>JVM &amp; JDK &amp; JRE</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><p><strong>什么是字节码?采用字节码的好处是什么?</strong></p><blockquote><p>在 Java 中，JVM可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote><p><strong>Java 程序从源代码到运行一般有下面3步：</strong></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/01-Java基础/Java 程序运行过程.png"></div><br>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了 JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。<p></p><blockquote><p>HotSpot采用了惰性评估（Lazy Evaluation）的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9引入了一种新的编译模式AOT（Ahead of Time Compilation），它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。</p></blockquote><p><strong>总结：</strong></p><p>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><h3 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h3><p>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。</p><p>JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><p>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装JDK了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p><h2 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h2><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理机制，不需要程序员手动释放无用内存</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是程序在运行时出现的会导致程序运行终止的错误。这种错误是不能通过编译系统检查出来的。常见的异常的发生原因为系统资源错误和用户操所错误两种。</p><p>Java把异常信息封装成一个类。当发生某种异常时将某种对应的类作为异常信息抛出。异常的根类时Throwable，其有两个直接子类 Error和Exception。Error是描述系统资源错误的类。Exception是描述用户操作错误的类。</p><p>发生了Error就是必须修改代码或调整外部环境问题，程序肯定会终止。比如需要开辟一个内存大小为99999999个int的数组。一般来说Error很少发生。发生了Exception就要进行处理，使程序运行下去，如数组越界异常。而Exception又可以分为两种，一种是程序本身存在的问题引发的异常（健壮性不够），即：RuntimeException；一种是程序本身可能没有问题，但遇到诸如文件不存在所导致的错误，Excption中除了RuntimeException外都是此种异常。而RuntimeException是不允许存在的，遇到RuntimeException就说明程序有问题，需要修改代码。</p><p></p><div align="center"><img width="65%" src="//isjinhao.github.io/2019/01-Java基础/受查非受查异常.png"></div><p></p><h3 id="受查异常、非受查异常"><a href="#受查异常、非受查异常" class="headerlink" title="受查异常、非受查异常"></a>受查异常、非受查异常</h3><p>Java语言规范规定派生于Error类或RuntimeException类的异常都称为非受查异常，其余异常都被成为受查异常。受查异常就是必须告诉它的调用者可能会出现异常，让其调用者抛出或者捕获处理，这类异常如果没有在程序中进行异常处理，编译不通过。非受查异常则不需要。</p><h3 id="声明受查异常（throws）"><a href="#声明受查异常（throws）" class="headerlink" title="声明受查异常（throws）"></a>声明受查异常（throws）</h3><p>除了Error和RuntimeException的异常都是受查异常，这些异常如：IOException、SQLException等，在可能发生的方法中需要被声明。同时非受查异常最好不要被声明。需要使用throws声明异常后的情况如下：</p><ul><li>调用一个抛出受查异常的方法：<code>public int read() throws IOException</code></li><li>方法中使用throw语句抛出了受查异常。</li></ul><h3 id="抛出异常（throw）"><a href="#抛出异常（throw）" class="headerlink" title="抛出异常（throw）"></a>抛出异常（throw）</h3><p>throw可以用于抛出异常对象，一般是受查异常对象。格式如下例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;    </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"出现异常"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="return和finally的决斗"><a href="#return和finally的决斗" class="headerlink" title="return和finally的决斗"></a>return和finally的决斗</h3><p>一旦进入<code>try … catch …</code>的异常捕获结构，无论try和catch的语句块有没有return语句，finally一定会被执行，但是如果finally中还有return语句，return之后的不会被执行。同时后来的return值会覆盖之前的return值。但若未进入异常捕获结构则return后不允许有语句，因为即使有也一定不会被执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewReview</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(test());</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Integer <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"111"</span>);</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">System.out.println(<span class="string">"222"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//System.out.println("333");// 报错</span></span><br><span class="line">&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">System.out.println(<span class="string">"---"</span>);</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">System.out.println(<span class="string">"```"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//System.out.println("...");// 报错</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">//System.out.println("bbb");// 报错</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">111</span></span><br><span class="line"><span class="comment">    ---</span></span><br><span class="line"><span class="comment">    aaa</span></span><br><span class="line"><span class="comment">    100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><h3 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h3><p>当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p><h3 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h3><p>只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。即父类的final方法是不能被子类所覆盖的。</p><p>重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义方法签名相同的方法，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。（注：类的private方法会隐式地被指定为final方法。）</p><h3 id="修饰变量"><a href="#修饰变量" class="headerlink" title="修饰变量"></a>修饰变量</h3><p>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。</p><ul><li>当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；</li><li>如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。</li></ul><p>final修饰一个成员变量，必须要显示初始化。这里有两种初始化方式，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>Object 类的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。该方法更像是一个对象生命周期的临终方法，当该方法被系统调用则代表该对象即将“死亡”，但是需要注意的是，我们主动行为上去调用该方法并不会导致该对象“死亡”，这是一个被动的方法（其实就是回调方法），不需要我们调用。</p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><h3 id="修饰方法-1"><a href="#修饰方法-1" class="headerlink" title="修饰方法"></a>修饰方法</h3><ul><li><p>在静态方法中不能访问类的非静态成员变量和非静态成员方法。</p></li><li><p>在非静态成员方法中是可以访问静态成员方法/变量的。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewReview</span> <span class="keyword">extends</span> <span class="title">Dad</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">test();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;<span class="comment">// static方法可以被重新定义</span></span><br><span class="line">System.out.println(<span class="string">"son"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dad</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"dad"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">父类先于子类、静态先于普通</span></span><br><span class="line"><span class="comment">base static</span></span><br><span class="line"><span class="comment">    test static</span></span><br><span class="line"><span class="comment">    base constructor</span></span><br><span class="line"><span class="comment">    test constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Test"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"MyClass"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">test static</span></span><br><span class="line"><span class="comment">    myclass static</span></span><br><span class="line"><span class="comment">    person static</span></span><br><span class="line"><span class="comment">    person Test</span></span><br><span class="line"><span class="comment">    test constructor</span></span><br><span class="line"><span class="comment">    person MyClass</span></span><br><span class="line"><span class="comment">    myclass constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。<strong>而在生成对象的时候，必须先初始化父类的成员变量</strong>，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。</p><h2 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h2><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><ul><li>参数列表必须完全与被重写方法的相同；</li><li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类</li><li>访问权限不能比父类中被重写的方法的访问权限更低。</li><li>父类的成员方法只能被它的子类重写。</li><li>声明为final的方法不能被重写。</li><li>声明为static的方法<strong>不能被重写</strong>，但是能够被再次声明。</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li><li>重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul><li>被重载的方法必须改变参数列表（参数个数或类型不一样）；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的检查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th style="text-align:center">区别点</th><th style="text-align:center">重载方法</th><th style="text-align:center">重写方法</th></tr></thead><tbody><tr><td style="text-align:center">参数列表</td><td style="text-align:center">必须修改</td><td style="text-align:center">一定不能修改</td></tr><tr><td style="text-align:center">返回类型</td><td style="text-align:center">可以修改</td><td style="text-align:center">一定不能修改</td></tr><tr><td style="text-align:center">异常</td><td style="text-align:center">可以修改</td><td style="text-align:center">可以减少或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td style="text-align:center">访问</td><td style="text-align:center">可以修改</td><td style="text-align:center">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table><h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>抽象类中可以定义构造器</li><li>可以有抽象方法和具体方法</li><li>抽象类中可以定义成员变量</li><li>有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法</li><li>抽象一个类只能继承一个抽象类</li><li>抽象类可以包含静态方法</li></ul><p>抽象方法不可同时是静态的、不能同时是本地的、也不能同时被synchronized修饰。</p><ul><li>抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。</li><li>本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。</li><li>synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>接口中不能定义构造器</li><li>方法全部都是抽象方法</li><li>抽象类中的成员可以是 private、默认、protected、public</li><li>接口中定义的成员变量实际上都是常量</li><li>接口中不能有静态方法</li><li>一个类可以实现多个接口</li></ul><h3 id="接口和抽象类的区别是什么"><a href="#接口和抽象类的区别是什么" class="headerlink" title="接口和抽象类的区别是什么"></a>接口和抽象类的区别是什么</h3><ol><li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li><li>接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。</li><li>接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。</li><li>从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li></ol><p>备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。</p><h2 id="基本类型和包装类型"><a href="#基本类型和包装类型" class="headerlink" title="基本类型和包装类型"></a>基本类型和包装类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">200</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">200</span>);</span><br><span class="line">Integer c = <span class="number">200</span>;</span><br><span class="line">Integer e = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> d = <span class="number">200</span>;</span><br><span class="line">Object o = <span class="number">200</span>;</span><br><span class="line">System.out.println(<span class="string">"基本类型和数字常量    ==判断"</span> + (o == c));</span><br><span class="line">System.out.println(<span class="string">"基本类型和数字常量    equal判断"</span> + c.equals(o));</span><br><span class="line">System.out.println(<span class="string">"两个new出来的对象    ==判断"</span> + (a == b));</span><br><span class="line">System.out.println(<span class="string">"两个new出来的对象    equal判断"</span> + a.equals(b));</span><br><span class="line">System.out.println(<span class="string">"new出的对象和用int赋值的Integer   ==判断"</span> + (a == c));</span><br><span class="line">System.out.println(<span class="string">"new出的对象和用int赋值的Integer   equal判断"</span> + (a.equals(c)));</span><br><span class="line">System.out.println(<span class="string">"两个用int赋值的Integer    ==判断"</span> + (c == e));</span><br><span class="line">System.out.println(<span class="string">"两个用int赋值的Integer    equal判断"</span> + (c.equals(e)));</span><br><span class="line">System.out.println(<span class="string">"基本类型和new出的对象   ==判断"</span> + (d == a));</span><br><span class="line">System.out.println(<span class="string">"基本类型和new出的对象   equal判断"</span> + (a.equals(d)));</span><br><span class="line">System.out.println(<span class="string">"基本类型和自动装箱的对象   ==判断"</span> + (d == c));</span><br><span class="line">System.out.println(<span class="string">"基本类型和自动装箱的对象   equal判断"</span> + (c.equals(d)));</span><br><span class="line"></span><br><span class="line">Integer f = <span class="number">100</span>;</span><br><span class="line">Integer g = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 如果在-128到127之间相等的话，它们会共用一块内存</span></span><br><span class="line">System.out.println(f == g);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动装箱发生的过程是：基本类型转换为包装类型。自动拆箱发生的过程是：包装类型转换为基本类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"i1=i2   "</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">"i1=i2+i3   "</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">"i1=i4   "</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">"i4=i5   "</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">"i4=i5+i6   "</span> + (i4 == i5 + i6));   </span><br><span class="line">System.out.println(<span class="string">"40=i5+i6   "</span> + (<span class="number">40</span> == i5 + i6));  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i1=i2   true</span></span><br><span class="line"><span class="comment">    i1=i2+i3   true</span></span><br><span class="line"><span class="comment">    i1=i4   false</span></span><br><span class="line"><span class="comment">    i4=i5   false</span></span><br><span class="line"><span class="comment">    语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数</span></span><br><span class="line"><span class="comment">    值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终</span></span><br><span class="line"><span class="comment">    这条语句转为40 == 40进行数值比较。</span></span><br><span class="line"><span class="comment">    i4=i5+i6   true</span></span><br><span class="line"><span class="comment">    40=i5+i6   true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Java 基本类型的包装类中：Byte，Short，Integer，Long，Character，Boolean实现了常量池技术；Float，Double 并没有实现常量池技术。</p><p>Character缓存了[0,127]之间的数据，Boolean缓存了true和false，其他4种包装类默认创建了数值[-128,127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。</p><h3 id="int的范围"><a href="#int的范围" class="headerlink" title="int的范围"></a>int的范围</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 补码会进行循环</span></span><br><span class="line">System.out.println(Integer.MAX_VALUE);<span class="comment">// 2147483647</span></span><br><span class="line">System.out.println(Integer.MAX_VALUE + <span class="number">1</span>);<span class="comment">// -2147483648</span></span><br><span class="line">System.out.println(Integer.MAX_VALUE + <span class="number">2</span>);<span class="comment">// -2147483647</span></span><br><span class="line"></span><br><span class="line">System.out.println(Integer.MIN_VALUE);<span class="comment">// -2147483648</span></span><br><span class="line">System.out.println(Integer.MIN_VALUE - <span class="number">1</span>);<span class="comment">// 2147483647</span></span><br><span class="line">System.out.println(Integer.MIN_VALUE - <span class="number">2</span>);<span class="comment">// 2147483646</span></span><br></pre></td></tr></table></figure><h3 id="基本类型之间的转换"><a href="#基本类型之间的转换" class="headerlink" title="基本类型之间的转换"></a>基本类型之间的转换</h3><ul><li>byte、short、int、long：小范围向大范围的可以自动转，大范围向小范围需要强制转。</li><li>char可以自动转换为int、long，可以强制转换为short、byte。byte、short、int、long都需要强制转换才能转为char。</li><li>float自动转换为double，double强制转换为float。</li><li>byte、short、int、long可以自动float和double。反之需要强制转换。</li><li><code>+=</code>和<code>-=</code>包含自动转换，即<code>short s1 = 1; s1 += 1;</code>不会报错。</li></ul><h2 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h2><h3 id="多层浅拷贝"><a href="#多层浅拷贝" class="headerlink" title="多层浅拷贝"></a>多层浅拷贝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">Body body = <span class="keyword">new</span> Body(<span class="keyword">new</span> Head(<span class="keyword">new</span> Face(<span class="keyword">new</span> String(<span class="string">"丑"</span>))));</span><br><span class="line">Body body1 = (Body) body.clone();</span><br><span class="line">System.out.println(<span class="string">"body == body1 : "</span> + (body == body1));</span><br><span class="line">System.out.println(<span class="string">"body.head == body1.head : "</span> + (body.head == body1.head));</span><br><span class="line">System.out.println(body.head.face == body1.head.face);</span><br><span class="line">System.out.println(body.head.face.name == body1.head.face.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> Head head;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Body</span><span class="params">(Head head)</span> </span>&#123; <span class="keyword">this</span>.head = head; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">Body newBody = (Body) <span class="keyword">super</span>.clone();</span><br><span class="line">newBody.head = (Head) head.clone();</span><br><span class="line"><span class="keyword">return</span> newBody;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Head</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> Face face;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Head</span><span class="params">(Face face)</span> </span>&#123; <span class="keyword">this</span>.face = face; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">Head newHead = (Head)<span class="keyword">super</span>.clone();</span><br><span class="line">newHead.face = (Face) face.clone();</span><br><span class="line"><span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Face</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Face</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">Face newFace = (Face)<span class="keyword">super</span>.clone();</span><br><span class="line">newFace.name = <span class="keyword">new</span> String(<span class="keyword">this</span>.name);</span><br><span class="line"><span class="keyword">return</span> newFace;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"Hao LUO"</span>, <span class="number">33</span>, <span class="keyword">new</span> Car(<span class="string">"Benz"</span>, <span class="number">300</span>));</span><br><span class="line">Person p2 = CloneUtils.clone(p1); <span class="comment">// 深度克隆</span></span><br><span class="line">p2.getCar().setBrand(<span class="string">"BYD"</span>);</span><br><span class="line">System.out.println(p1);</span><br><span class="line">System.out.println(p2);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneUtils</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">CloneUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">oos.writeObject(obj);</span><br><span class="line">ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray());</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line"><span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">9102017020286042305L</span>;</span><br><span class="line"><span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line"><span class="keyword">private</span> Car car; <span class="comment">// 座驾</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Car car)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// ... getter方法和setter方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", car="</span> + car + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5713945027627603702L</span>;</span><br><span class="line"><span class="keyword">private</span> String brand; <span class="comment">// 品牌</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSpeed; <span class="comment">// 最高时速</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand, <span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.brand = brand;</span><br><span class="line"><span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ... getter和setter方法</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Car [brand="</span> + brand + <span class="string">", maxSpeed="</span> + maxSpeed + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="keyword">this</span>.key = key; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line">    <span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span></span><br><span class="line">    Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span></span><br><span class="line">    Generic&lt;String&gt; genericString = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"key_vlaue"</span>);</span><br><span class="line">    System.out.println(<span class="string">"key is "</span> + genericInteger.getKey().getClass());</span><br><span class="line">    System.out.println(<span class="string">"key is "</span> + genericString.getKey().getClass());</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型接口的实现"><a href="#泛型接口的实现" class="headerlink" title="泛型接口的实现"></a>泛型接口的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当实现泛型接口的类，未传入泛型实参时：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>当实现泛型接口的类，传入泛型实参时：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="keyword">this</span>.key = key; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showKeyValue</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Generic&lt;Integer&gt; gInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123</span>);</span><br><span class="line">    Generic&lt;Number&gt; gNumber = <span class="keyword">new</span> Generic&lt;Number&gt;(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">    showKeyValue(gNumber);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// showKeyValue这个方法编译器会为我们报错：</span></span><br><span class="line">        <span class="comment">// Generic&lt;java.lang.Integer&gt; cannot be applied to Generic&lt;java.lang.Number&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// showKeyValue(gInteger);</span></span><br><span class="line">        </span><br><span class="line">        showKeyValue1(gNumber);<span class="comment">// 正常 </span></span><br><span class="line">    showKeyValue1(gInteger);<span class="comment">// 正常</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Generic&lt;Integer&gt;</code>不能被看作为<code>Generic&lt;Number&gt;</code>的子类。由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</p><p>类型通配符一般是使用<code>？</code>代替具体的类型实参，注意了，此处<code>？</code>是类型实参，而不是类型形参 。再直白点的意思就是，此处的<code>？</code>和Number、String、Integer一样都是一种实际的类型，可以把<code>？</code>看成所有类型的父类。是一种真实的类型。可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。</p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型类，是在实例化类的时候指明泛型的具体类型；<strong>泛型方法，是在调用方法的时候指明泛型的具体类型</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span></span><br><span class="line"><span class="function">  IllegalAccessException</span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="泛型”方法”的详细举例"><a href="#泛型”方法”的详细举例" class="headerlink" title="泛型”方法”的详细举例"></a>泛型”方法”的详细举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="keyword">this</span>.key = key; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">            public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">                 this.key = keu</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">        public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">        &#125;  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类中的泛型方法"><a href="#类中的泛型方法" class="headerlink" title="类中的泛型方法"></a>类中的泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFruit</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"fruit"</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"apple"</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Person"</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//方法中的T和类上声明的T一致</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">        <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">        <span class="comment">//编译器会报警告：The type parameter T is hiding the type T</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> GenericFruit().new Apple();</span><br><span class="line">        Person person = <span class="keyword">new</span> GenericFruit().new Person();</span><br><span class="line"></span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = <span class="keyword">new</span> GenericFruit().new GenerateTest&lt;Fruit&gt;();</span><br><span class="line">        <span class="comment">//apple是Fruit的子类，所以这里可以</span></span><br><span class="line">        generateTest.show_1(apple);</span><br><span class="line">        <span class="comment">//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span></span><br><span class="line">        <span class="comment">//generateTest.show_1(person);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法都可以成功</span></span><br><span class="line">        generateTest.show_2(apple);</span><br><span class="line">        generateTest.show_2(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法也都可以成功</span></span><br><span class="line">        generateTest.show_3(apple);</span><br><span class="line">        generateTest.show_3(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h3><p>类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong>即：<strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法</strong> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          "StaticGenerator cannot be refrenced from static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型上下边界"><a href="#泛型上下边界" class="headerlink" title="泛型上下边界"></a>泛型上下边界</h3><h4 id="上边界"><a href="#上边界" class="headerlink" title="上边界"></a>上边界</h4><p>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型</p><blockquote><p>类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="keyword">this</span>.key = key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>类的成员方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;? extends Number&gt; obj)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>泛型方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h5><p>类C中方法：<code>void setC(T t)</code>。在传入<code>&lt;? extends Fruit&gt;</code>之后：<code>void setC(&lt;? extends Fruit&gt; t)</code>。这时编译器就不知道你传过来的是什么类型，编译不会通过。但是类中的方法可以返回T，因为已经知道了它的上限是A，在调用之后用A来接收一下返回的对象就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GenerateTest&lt;? extends Fruit&gt; generateTest2 = <span class="keyword">new</span> GenericFruit().new GenerateTest&lt;&gt;();</span><br><span class="line">generateTest2.setC(apple);  <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><h4 id="下边界"><a href="#下边界" class="headerlink" title="下边界"></a>下边界</h4><p><code>&lt;? super A&gt;</code>表示传入的只能是A的超类或超接口。此时，类中的方法void setC(T t)可以传入A或A的子类作为参数。但返回时只能返回Object对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenerateTest&lt;? <span class="keyword">super</span> Apple&gt; generateTest2 = <span class="keyword">new</span> GenericFruit().new GenerateTest&lt;&gt;();Object object = generateTest2.get();</span><br></pre></td></tr></table></figure><h3 id="泛型数组"><a href="#泛型数组" class="headerlink" title="泛型数组"></a>泛型数组</h3><p>sun的说明文档，在java中是<strong>”不能创建一个确切的泛型类型的数组”</strong>的。也就是说下面的这个例子是不可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>而使用通配符创建泛型数组是可以的，如下面这个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>这样也是可以的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p>下面使用<a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank" rel="noopener">Sun</a><a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank" rel="noopener">的一篇文档</a>的一个例子来说明这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.    </span></span><br><span class="line">Object o = lsa;</span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check    </span></span><br><span class="line">String s = lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error: ClassCastException.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>下面采用通配符的方式是被允许的:<strong>数组的类型不可以是类型变量，除非是采用通配符的方式</strong>，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.    </span></span><br><span class="line">Integer i = (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123; <span class="keyword">this</span>.radius = radius; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"drawshape"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> test = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> test = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">            System.out.println(count);   <span class="comment">//外部类的静态成员</span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.test);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Draw draw = <span class="keyword">new</span> Outer(<span class="number">20</span>).new Draw();</span><br><span class="line">    draw.drawSahpe();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.this.成员变量</span><br><span class="line">外部类.this.成员方法</span><br></pre></td></tr></table></figure><p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        getDrawInstance().drawSahpe();   <span class="comment">//必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Draw <span class="title">getDrawInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Draw();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式：</span></span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        Outter.Inner inner = outter.new Inner();  <span class="comment">//必须通过Outter对象来创建</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第二种方式：</span></span><br><span class="line">        Outter.Inner inner1 = outter.getInnerInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="keyword">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如上面的例子：</p><ul><li>private：则只能在外部类的内部访问；</li><li>public：则任何地方都能访问；</li><li>protected：只能在同一个包下或者继承外部类的情况下访问；</li><li>默认访问权限：则只能在同一个包下访问。</li></ul><p>这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段线程允许代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"thread run"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">thread.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$数字.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。</span></span><br><span class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="局部内部类和匿名内部类只能访问局部final变量"><a href="#局部内部类和匿名内部类只能访问局部final变量" class="headerlink" title="局部内部类和匿名内部类只能访问局部final变量"></a>局部内部类和匿名内部类只能访问局部final变量</h3><p>想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;  &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">                <span class="comment">//a = 10;</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们需要知道：内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在（只有没有人再引用它时，才可能死亡）。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的”copy”。这样就好像延长了局部变量的生命周期。</p><p>那么新问题又出现了：将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？就将局部变量设置为<code>final</code>，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。这实际上也是一种妥协。</p><h2 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h2><ul><li><p>java.lang.NullPointerException ：空指针异常；</p><ul><li>出现原因：调用了未经初始化的对象或者是不存在的对象。</li></ul></li><li><p>java.lang.ClassNotFoundException ：指定的类找不到；</p><ul><li>出现原因：类的名称和路径加载错误；通常都是程序试图通过字符串来加载某个类时可能引发异常。</li></ul></li><li><p>java.lang.NumberFormatException ：字符串转换为数字异常；</p><ul><li>出现原因：字符型数据中包含非数字型字符。</li></ul></li><li><p>java.lang.IndexOutOfBoundsException ：数组角标越界异常，常见于操作数组对象时发生。</p></li><li><p>java.lang.ClassCastException ：数据类型转换异常</p></li><li><p>SQLException ：SQL 异常，常见于操作数据库时的 SQL 语句错误。</p></li></ul><h2 id="枚举和switch"><a href="#枚举和switch" class="headerlink" title="枚举和switch"></a>枚举和switch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(TestEnum.FRI.getClass()); <span class="comment">//class TestEnum</span></span><br><span class="line">System.out.println(TestEnum.FRI);<span class="comment">// FRI</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> TestEnum &#123;</span><br><span class="line"> MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch中可以跟的类型有byte、short、char、int、String、枚举。<strong>没有long</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"200"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (str) &#123;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">// default 只能定义一次</span></span><br><span class="line">System.out.println(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="string">"100"</span>:</span><br><span class="line">System.out.println(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="string">"1000"</span>:</span><br><span class="line">System.out.println(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str = 200;</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//1000</span></span><br><span class="line"><span class="comment">//1000</span></span><br><span class="line"><span class="comment">//因为不能匹配100或1000，所以从defalut口进入。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//str = 100;</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//1000</span></span><br><span class="line"><span class="comment">//1000</span></span><br><span class="line"><span class="comment">//因为可以匹配100，从第二个口进入。</span></span><br></pre></td></tr></table></figure><h2 id="随机数和round"><a href="#随机数和round" class="headerlink" title="随机数和round"></a>随机数和round</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得随机数：greater than or equal to 0.0 and less than 1.0</span></span><br><span class="line"><span class="keyword">double</span> iRandom = Math.random();</span><br><span class="line">System.out.println(iRandom);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得区间在[0, n)之间的随机整数</span></span><br><span class="line">Random random2 = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> nextInt = random2.nextInt(<span class="number">10</span>);</span><br><span class="line">System.out.println(nextInt);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负数：加0.5之后向小的取整</span></span><br><span class="line">System.out.println(Math.round(-<span class="number">11.6</span>));</span><br><span class="line">System.out.println(Math.round(-<span class="number">11.5</span>));</span><br><span class="line"><span class="comment">// 正数：加0.5之后向大的取整</span></span><br><span class="line">System.out.println(Math.round(<span class="number">11.6</span>));</span><br><span class="line">System.out.println(Math.round(<span class="number">11.5</span>));</span><br></pre></td></tr></table></figure><h2 id="String和字符串常量池"><a href="#String和字符串常量池" class="headerlink" title="String和字符串常量池"></a>String和字符串常量池</h2><p>字符串常量池只是常量池技术在字符串这个类上的实现，但是为了方便叙述，本条知识点使用常量池和字符串常量池等价。</p><h3 id="String对象的两种创建方式"><a href="#String对象的两种创建方式" class="headerlink" title="String对象的两种创建方式"></a>String对象的两种创建方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用双引号声明出来的 String 对象会直接存储在常量池中。</span></span><br><span class="line"><span class="comment">// 使用双引号声明时会调用ldc命令，所以其检查的是字符串常量池。</span></span><br><span class="line">String str1 = <span class="string">"abcd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于new String()则会在堆中创建一个String对象，并返回该对象的引用。</span></span><br><span class="line"><span class="comment">// Initializes a newly created String object so that it represents the same sequence </span></span><br><span class="line"><span class="comment">// of characters as the argument; in other words, the newly created string is a copy </span></span><br><span class="line"><span class="comment">// of the argument string. Unless an explicit copy of original is needed, use of this </span></span><br><span class="line"><span class="comment">// constructor is unnecessary since Strings are immutable.</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p></p><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/2019-07-11_165800.jpg"></div><p></p><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p>String.intern() 是一个 Native 方法，JDK对它的解释是（水平有限，不再翻译）：</p><blockquote><p>A pool of strings, initially empty, is maintained privately by the class String. When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.（笔者注：add的意思不是克隆一份，就是把这个对象的引用放在常量池中，JDK8中字符串常量池可以存放字符串对象，也可以存放字符串对象的引用，返回的引用是指向常量池中的字符串对象）<br>It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.<br>All literal strings and string-valued constant expressions are interned.</p></blockquote><p>大致意思是：如果字符串常量池中已经有了这个字符串，那么直接返回字符串常量池中的它的引用，如果没有，那就将它的引用保存一份到字符串常量池，然后直接返回这个引用。判断字符串是否相等使用<code>equals</code>方法。</p><h3 id="题"><a href="#题" class="headerlink" title="题"></a>题</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"计算机"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">"计算机"</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的String对象一个是常量池中的String对象</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的String对象</span></span><br></pre></td></tr></table></figure><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Hollis"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"Hollis"</span>);</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"Hollis"</span>).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/01-Java基础/例2.jpg"></div><p></p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">// 常量池中有"1"，堆中有字符串"1"，s是堆中中"1"的引用</span></span><br><span class="line"></span><br><span class="line">String s2 = <span class="string">"1"</span>;</span><br><span class="line"><span class="comment">// s2是常量池中"1"的引用</span></span><br><span class="line"></span><br><span class="line">s.intern();</span><br><span class="line"><span class="comment">// "1"已经存在常量池中，返回常量池中"1"的引用，但没有被接收</span></span><br><span class="line"></span><br><span class="line">System.out.println(s == s2);<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"2"</span>);</span><br><span class="line"><span class="comment">// 常量池中有"1"，"2"。new String("1") + new String("2");的底层是使用StringBuffer的append</span></span><br><span class="line"><span class="comment">// 方 法将"1"和"2"拼接在一块，然后调用toString方法new出"12"；所以此时的“12”字符串是创建在堆区的；</span></span><br><span class="line"></span><br><span class="line">s3.intern();</span><br><span class="line"><span class="comment">// 常量池中没有"12"，intern后常量池中存放堆中"12"的引用</span></span><br><span class="line"></span><br><span class="line">String s4 = <span class="string">"12"</span>;</span><br><span class="line"><span class="comment">// 从常量池中拿"12"，和堆中的"12"是同一个"12"</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;</span><br><span class="line"><span class="comment">// 常量池中有"z"和"xy"，堆中有"xyz"</span></span><br><span class="line"></span><br><span class="line">String s2 = s1.intern();  </span><br><span class="line"><span class="comment">// 常量池中有一个指向堆中"xyz"的引用，s2和这个引用相等，即s2指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s1.intern());    <span class="comment">//true </span></span><br><span class="line"><span class="comment">// s1指向堆中"xyz"，s1.intern()也指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s1.intern()); <span class="comment">//true</span></span><br><span class="line"><span class="comment">// s2指向堆中"xyz"的引用</span></span><br></pre></td></tr></table></figure><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;</span><br><span class="line"><span class="comment">// 常量池中有"z"和"xy"，堆中有"xyz"，s1指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"xyz"</span>);</span><br><span class="line"><span class="comment">// 常量池中有"xyz"，s3指向堆中的第二个"xyz"</span></span><br><span class="line"></span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"><span class="comment">// s2指向常量池中的"xyz"</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s3);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s1.intern());    <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s1.intern());  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h4 id="6"><a href="#6" class="headerlink" title="6"></a>6</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;</span><br><span class="line"><span class="comment">// 常量池中有"z"和"xy"，堆中有"xyz"，s1指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"><span class="comment">// 常量池中有一个指向堆中"xyz"的引用，s2和这个引用相等，即s2指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"xyz"</span>);</span><br><span class="line"><span class="comment">// 常量池中有一个指向堆中"xyz"的引用，不再在常量池中创建"xyz"，将常量池中的"xyz"复制一份到堆中</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s3);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s1.intern());    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s1.intern());<span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="7"><a href="#7" class="headerlink" title="7"></a>7</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;</span><br><span class="line"><span class="comment">// 常量池中有"z"和"xy"，堆中有"xyz"，s1指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"><span class="comment">// 常量池中有一个指向堆中"xyz"的引用，s2和这个引用相等，即s2指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="string">"xyz"</span>;</span><br><span class="line"><span class="comment">// 常量池中有一个指向堆中"xyz"的引用，不再在常量池中创建"xyz"，s3指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s3);<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s1.intern());    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s1.intern());<span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="8"><a href="#8" class="headerlink" title="8"></a>8</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"xy"</span> + <span class="string">"z"</span>;</span><br><span class="line"><span class="comment">// 常量池中存在 "xy"  "z"  "xyz"</span></span><br></pre></td></tr></table></figure><h4 id="9"><a href="#9" class="headerlink" title="9"></a>9</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;</span><br><span class="line"><span class="comment">// 常量池中有"z"和"xy"，堆中有"xyz"，s1指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="string">"xyz"</span>;</span><br><span class="line"><span class="comment">// 常量池中有"xyz"，s3指向常量池中的"xyz"</span></span><br><span class="line"></span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"><span class="comment">// s2指向常量池中的"xyz"</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">System.out.println(s2 == s3);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s1.intern());<span class="comment">//false</span></span><br><span class="line">System.out.println(s2 == s1.intern()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="String、StringBuilder-amp-StringBuffer"><a href="#String、StringBuilder-amp-StringBuffer" class="headerlink" title="String、StringBuilder &amp; StringBuffer"></a>String、StringBuilder &amp; StringBuffer</h2><h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a><strong>可变性</strong></h3><p>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。</p><p>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的。</p><p>AbstractStringBuilder.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a><strong>性能</strong></h3><p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><h3 id="对于三者使用的总结："><a href="#对于三者使用的总结：" class="headerlink" title="对于三者使用的总结："></a><strong>对于三者使用的总结：</strong></h3><ol><li>操作少量的数据: 适用String</li><li>单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder</li><li>多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer</li></ol><p>Java中字符串相加，编译的时候会创建StringBuilder类，然后利用StringBuilder的append()方法相加。所以不能在循环里使用<code>+</code>，需要在循环外面使用创建StringBuilder的对象，在循环内进行append()操作。</p><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前日期</span></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">"Current Date="</span> + today);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据年、月、日创建日期</span></span><br><span class="line">LocalDate firstDay_2014 = LocalDate.of(<span class="number">2014</span>, Month.JANUARY, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"Specific Date="</span> + firstDay_2014);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不合法的参数会报 java.time.DateTimeException</span></span><br><span class="line"><span class="comment">// LocalDate feb29_2014 = LocalDate.of(2014, Month.FEBRUARY, 29);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Current date in "Asia/Kolkata", you can get it from ZoneId javadoc</span></span><br><span class="line">LocalDate todayKolkata = LocalDate.now(ZoneId.of(<span class="string">"Asia/Kolkata"</span>));</span><br><span class="line">System.out.println(<span class="string">"Current Date in IST="</span> + todayKolkata);</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.time.zone.ZoneRulesException: Unknown time-zone ID: IST</span></span><br><span class="line"><span class="comment">// LocalDate todayIST = LocalDate.now(ZoneId.of("IST"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Getting date from the base date: 01/01/1970</span></span><br><span class="line">LocalDate dateFromBase = LocalDate.ofEpochDay(<span class="number">365</span>);</span><br><span class="line">System.out.println(<span class="string">"365th day from base date= "</span> + dateFromBase);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到某年的多少天</span></span><br><span class="line">LocalDate hundredDay2014 = LocalDate.ofYearDay(<span class="number">2014</span>, <span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">"100th day of 2014="</span> + hundredDay2014);</span><br></pre></td></tr></table></figure><h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Current Time</span></span><br><span class="line">LocalTime time = LocalTime.now();</span><br><span class="line">System.out.println(<span class="string">"Current Time = "</span> + time);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating LocalTime by providing input arguments</span></span><br><span class="line">LocalTime specificTime = LocalTime.of(<span class="number">12</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">40</span>);</span><br><span class="line">System.out.println(<span class="string">"Specific Time of Day = "</span> + specificTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try creating time by providing invalid inputs</span></span><br><span class="line"><span class="comment">// LocalTime invalidTime = LocalTime.of(25,20);</span></span><br><span class="line"><span class="comment">// Exception in thread "main" java.time.DateTimeException:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Invalid value for HourOfDay (valid values 0 - 23): 25</span></span><br><span class="line"><span class="comment">// Current date in "Asia/Kolkata", you can get it from ZoneId javadoc</span></span><br><span class="line">LocalTime timeKolkata = LocalTime.now(ZoneId.of(<span class="string">"Asia/Kolkata"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Current Time in IST = "</span> + timeKolkata);</span><br><span class="line"><span class="comment">// java.time.zone.ZoneRulesException: Unknown time-zone ID: IST</span></span><br><span class="line"><span class="comment">// LocalTime todayIST = LocalTime.now(ZoneId.of("IST"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Getting time from the base date: 00:00:00</span></span><br><span class="line">LocalTime specificSecondTime = LocalTime.ofSecondOfDay(<span class="number">10000</span>);</span><br><span class="line">System.out.println(<span class="string">"10000th second time = "</span> + specificSecondTime);</span><br></pre></td></tr></table></figure><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Current Date</span></span><br><span class="line">LocalDateTime today = LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">"Current DateTime1 = "</span> + today);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Current Date using LocalDate and LocalTime</span></span><br><span class="line">today = LocalDateTime.of(LocalDate.now(), LocalTime.now());</span><br><span class="line">System.out.println(<span class="string">"Current DateTime2 = "</span> + today);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating LocalDateTime by providing input arguments</span></span><br><span class="line">LocalDateTime specificDate = LocalDateTime.of(<span class="number">2014</span>, Month.JANUARY, <span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(<span class="string">"Specific Date = "</span> + specificDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try creating date by providing invalid inputs</span></span><br><span class="line"><span class="comment">// LocalDateTime feb29_2014 = LocalDateTime.of(2014, Month.FEBRUARY, 28, 25, 1, 1);</span></span><br><span class="line"><span class="comment">// Exception in thread "main" java.time.DateTimeException:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Invalid value for HourOfDay (valid values 0 - 23): 25</span></span><br><span class="line"><span class="comment">// Current date in "Asia/Kolkata", you can get it from ZoneId javadoc</span></span><br><span class="line">LocalDateTime todayKolkata = LocalDateTime.now(ZoneId.of(<span class="string">"Asia/Kolkata"</span>));</span><br><span class="line">System.out.println(<span class="string">"Current Date in IST = "</span> + todayKolkata);</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.time.zone.ZoneRulesException: Unknown time-zone ID: IST</span></span><br><span class="line"><span class="comment">// LocalDateTime todayIST = LocalDateTime.now(ZoneId.of("IST"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Getting date from the base date: 01/01/1970</span></span><br><span class="line">LocalDateTime dateFromBase = LocalDateTime.ofEpochSecond(<span class="number">10000</span>, <span class="number">0</span>, ZoneOffset.UTC);</span><br><span class="line">System.out.println(<span class="string">"10000th second time from 01/01/1970= "</span> + dateFromBase);</span><br></pre></td></tr></table></figure><h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Current timestamp</span></span><br><span class="line">Instant timestamp = Instant.now();</span><br><span class="line">System.out.println(<span class="string">"Current Timestamp = "</span> + timestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为 milliseconds from 01/01/1970</span></span><br><span class="line"><span class="keyword">long</span> epochMilli = timestamp.toEpochMilli();</span><br><span class="line">System.out.println(epochMilli);</span><br></pre></td></tr></table></figure><h3 id="Date-amp-SimpleDateFormat"><a href="#Date-amp-SimpleDateFormat" class="headerlink" title="Date &amp; SimpleDateFormat"></a>Date &amp; SimpleDateFormat</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat oldFormatter = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy/MM/dd"</span>);</span><br><span class="line">Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(oldFormatter.format(date1));</span><br></pre></td></tr></table></figure><h3 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Date now = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime = now.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br><span class="line">LocalTime localTime = now.toInstant().atZone(ZoneId.systemDefault()).toLocalTime();</span><br><span class="line">LocalDate localDate = now.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();</span><br><span class="line"></span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(localTime);</span><br><span class="line">System.out.println(localDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalTime 和 LocalDate 没有atZone方法</span></span><br><span class="line">Date oldLocalDateTime = </span><br><span class="line">Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());</span><br><span class="line">System.out.println(oldLocalDateTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = </span><br><span class="line">localDateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();</span><br><span class="line"><span class="keyword">long</span> time = now.getTime();</span><br><span class="line">System.out.println(millis);</span><br><span class="line">System.out.println(time);</span><br><span class="line"></span><br><span class="line">LocalDateTime parseLocalDateTime = </span><br><span class="line">Instant.ofEpochMilli(millis).atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br><span class="line">LocalDate parseLocalDate = </span><br><span class="line">Instant.ofEpochMilli(millis).atZone(ZoneId.systemDefault()).toLocalDate();</span><br><span class="line"></span><br><span class="line">System.out.println(parseLocalDateTime);</span><br><span class="line">System.out.println(parseLocalDate);</span><br></pre></td></tr></table></figure><h3 id="获取年月日时钟秒"><a href="#获取年月日时钟秒" class="headerlink" title="获取年月日时钟秒"></a>获取年月日时钟秒</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime dt = LocalDateTime.now();</span><br><span class="line">System.out.println(dt.getYear());</span><br><span class="line">System.out.println(dt.getMonthValue()); <span class="comment">// 1 - 12</span></span><br><span class="line">System.out.println(dt.getDayOfMonth());</span><br><span class="line">System.out.println(dt.getHour());</span><br><span class="line">System.out.println(dt.getMinute());</span><br><span class="line">System.out.println(dt.getSecond());</span><br></pre></td></tr></table></figure><h3 id="获得某月第一天-最后一天"><a href="#获得某月第一天-最后一天" class="headerlink" title="获得某月第一天/最后一天"></a>获得某月第一天/最后一天</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"><span class="comment">//本月的第一天</span></span><br><span class="line">LocalDate firstday = LocalDate.of(today.getYear(), today.getMonth(), <span class="number">1</span>);</span><br><span class="line"><span class="comment">//本月的最后一天</span></span><br><span class="line">LocalDate lastDay =today.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">System.out.println(<span class="string">"本月的第一天       "</span> + firstday);</span><br><span class="line">System.out.println(<span class="string">"本月的最后一天   "</span> + lastDay);</span><br></pre></td></tr></table></figure><h3 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dtf1 = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd  HH:mm:ss"</span>);</span><br><span class="line">DateTimeFormatter dtf2 = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd"</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">LocalDate ld = LocalDate.now();</span><br><span class="line"></span><br><span class="line">System.out.println(ldt);</span><br><span class="line">System.out.println(ld);</span><br><span class="line"></span><br><span class="line">String format1 = ldt.format(dtf1);<span class="comment">// 日期格式化为字符串</span></span><br><span class="line">String format2 = ld.format(dtf2);<span class="comment">// 日期格式化为字符串</span></span><br><span class="line">System.out.println(format1);</span><br><span class="line">System.out.println(format2);</span><br><span class="line"></span><br><span class="line">LocalDateTime parse1 = LocalDateTime.parse(format1, dtf1);</span><br><span class="line">LocalDate parse2 = LocalDate.parse(format2, dtf2);</span><br><span class="line"></span><br><span class="line">System.out.println(parse1);<span class="comment">// 字符串转化为日期</span></span><br><span class="line">System.out.println(parse2);<span class="comment">// 字符串转化为日期</span></span><br></pre></td></tr></table></figure><h2 id="equals-和hashCode"><a href="#equals-和hashCode" class="headerlink" title="equals()和hashCode()"></a>equals()和hashCode()</h2><p>Java 对于 eqauls 方法和 hashCode 方法是这样规定的：</p><ul><li>如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；</li><li>如果两个对象的 hashCode 相同，它们并不一定相同。</li></ul><h3 id="equals-需要满足的性质"><a href="#equals-需要满足的性质" class="headerlink" title="equals()需要满足的性质"></a>equals()需要满足的性质</h3><ul><li>自反性：x.equals(x)必须返回 true</li><li>对称性：x.equals(y)返回 true 时，y.equals(x)也必须返回 true</li><li>传递性：x.equals(y)和 y.equals(z)都返回 true 时，x.equals(z)也必须返回 true</li><li>一致性：当x 和 y 引用的对象信息没有被修改时，多次调用 x.equals(y)应该得到同样的返回值，</li><li>对于任何非 null 值的引用 x，x.equals(null)必须返回 false。</li></ul><h3 id="实现高质量的-equals"><a href="#实现高质量的-equals" class="headerlink" title="实现高质量的 equals ()"></a>实现高质量的 equals ()</h3><ul><li>使用==操作符检查”参数是否为这个对象的引用”；</li><li>使用 instanceof 操作符检查”参数是否为正确的类型”；</li><li>对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；</li><li>编写完 equals 方法后，问自己它是否满足对称性、传递性、一致性和空值返回false；</li><li>重写 equals 时总是要重写 hashCode；</li><li>不要将 equals 方法参数中的 Object 对象替换为其他的类型，在重写时不要忘掉@Override注解。</li></ul><h3 id="正确使用equals方法"><a href="#正确使用equals方法" class="headerlink" title="正确使用equals方法"></a>正确使用equals方法</h3><p>推荐使用：<code>Objects.equals(o1, o2)</code>，此方法的底层实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static boolean equals(Object a, Object b) &#123;</span><br><span class="line">    // 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span><br><span class="line">    return (a == b) || (a != null &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a>两者的关系</h3><p>在使用到哈希机制的集合时需要同时重写equles方法和hashCode方法。即重写对象的散列码是为了更好的支持基于哈希机制的Java集合类，例如 Hashtable, HashMap, HashSet 等，如果不重写hashCode()，在使用哈希机制的集合类时会出错。</p><p>当把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。但不同对象的hashCode可能重复，所以哈希机制的集合会在判断hashCode之后再判断一次equals。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"eee"</span>, <span class="number">100</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"eee"</span>, <span class="number">100</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">"aaa"</span>, <span class="number">200</span>);</span><br><span class="line">        Person p4 = <span class="keyword">new</span> Person(<span class="string">"EEE"</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印set</span></span><br><span class="line">        System.out.printf(<span class="string">"set:%s\n"</span>, set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> name.hashCode() ^ age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [age="</span> + age + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;  </span><br><span class="line">            <span class="keyword">if</span>(obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果是同一个对象返回true，反之返回false  </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断是否类型相同  </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">              </span><br><span class="line">            Person person = (Person)obj;  </span><br><span class="line">            <span class="keyword">return</span> name.equals(person.name) &amp;&amp; age==person.age;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>假设无人驾驶的标准是Oracle公司制定的，Google想使用Java语言来开发无人驾驶系统，那么首先它需要创建一个类实现Oracle公司提供的无人驾驶的接口（接口为AIDriving，类为GoogleAIDriving）。</p><ul><li><p>AIDriving</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AIDriving</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;  <span class="comment">//无人驾驶汽车启动的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;   <span class="comment">//无人驾驶汽车停止的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>GoogleAIDriving</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoogleAIDriving</span> <span class="keyword">implements</span> <span class="title">AIDriving</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Google汽车启动了..."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Google汽车停止了..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="传统方法-继承"><a href="#传统方法-继承" class="headerlink" title="传统方法-继承"></a>传统方法-继承</h3><p>这个时候国内某汽车制造公司（设为A公司）想使用Google提供的无人驾驶系统。但是Google提供的系统不太适合我国国情，所以A公司的工程师就想在Google系统的基础上进行定制。他们选择的方式是继承GoogleAIDriving，创建一个自己的类：A1GoogleAIDriving。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A1GoogleAIDriving</span> <span class="keyword">extends</span> <span class="title">GoogleAIDriving</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"在中国启动汽车"</span>);</span><br><span class="line"><span class="keyword">super</span>.start();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"在中国停止汽车"</span>);</span><br><span class="line"><span class="keyword">super</span>.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="装饰者模式-1"><a href="#装饰者模式-1" class="headerlink" title="装饰者模式"></a>装饰者模式</h3><p>但理想很美好，现实很残忍。GoogleAIDriving被定义为一个final类（不能被继承），这个是可以理解的，因为如果GoogleAIDriving不是一个final类，任何继承GoogleAIDriving的类都可以对其start()、stop()方法进行覆盖，如果覆盖时出现bug就可能会出现大问题。所以像启动、停止这种核心功能是不允许汽车制造商随意修改的。A公司的工程师就想到了使用装饰者模式来增强功能（设类为A2GoogleAIDriving）。</p><p>装饰者模式该怎么做呢？</p><ol><li>首先，装饰类得和被装饰类实现相同的接口，即AIDriving；</li><li>第二，在装饰类中定义一个AIDriving类型的属性，即AIDriving car；</li><li>第三，有一个参数为AIDriving类型的构造函数，即A2GoogleAIDriving(AIDriving car)；</li><li>第四，装饰类的每个方法都要调用被装饰类相应的方法；</li><li>第五，使用第三步中的构造函数创建装饰类；</li><li>第六，在装饰类的方法中自定义功能。</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li>创建装饰类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A2GoogleAIDriving</span> <span class="keyword">implements</span> <span class="title">AIDriving</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> AIDriving car;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A2GoogleAIDriving</span><span class="params">(AIDriving car)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"在中国启动汽车..."</span>);</span><br><span class="line">car.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"在中国停止汽车..."</span>);</span><br><span class="line">car.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="调用装饰类"><a href="#调用装饰类" class="headerlink" title="调用装饰类"></a>调用装饰类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">GoogleAIDriving car = <span class="keyword">new</span> GoogleAIDriving();</span><br><span class="line">A2GoogleAIDriving aCar = <span class="keyword">new</span> A2GoogleAIDriving(car);</span><br><span class="line">aCar.start();</span><br><span class="line"> <span class="comment">/* Console : </span></span><br><span class="line"><span class="comment">  在中国启动汽车...</span></span><br><span class="line"><span class="comment">Google汽车启动了... */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BigInteger-amp-BigDecimal"><a href="#BigInteger-amp-BigDecimal" class="headerlink" title="BigInteger&amp;BigDecimal"></a>BigInteger&amp;BigDecimal</h2><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>理论上可以表示无限大的数字。常用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BigInteger <span class="title">abs</span><span class="params">()</span>  返回大整数的绝对值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger val)</span> 返回两个大整数的和</span></span><br><span class="line"><span class="function">BigInteger <span class="title">and</span><span class="params">(BigInteger val)</span>  返回两个大整数的按位与的结果</span></span><br><span class="line"><span class="function">BigInteger <span class="title">andNot</span><span class="params">(BigInteger val)</span> 返回两个大整数与非的结果</span></span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger val)</span>  返回两个大整数的商</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span>   返回大整数的<span class="keyword">double</span>类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span>   返回大整数的<span class="keyword">float</span>类型的值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">gcd</span><span class="params">(BigInteger val)</span>  返回大整数的最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> 返回大整数的整型值</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span> 返回大整数的<span class="keyword">long</span>型值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">max</span><span class="params">(BigInteger val)</span> 返回两个大整数的最大者</span></span><br><span class="line"><span class="function">BigInteger <span class="title">min</span><span class="params">(BigInteger val)</span> 返回两个大整数的最小者</span></span><br><span class="line"><span class="function">BigInteger <span class="title">mod</span><span class="params">(BigInteger val)</span> 用当前大整数对val求模</span></span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger val)</span> 返回两个大整数的积</span></span><br><span class="line"><span class="function">BigInteger <span class="title">negate</span><span class="params">()</span> 返回当前大整数的相反数</span></span><br><span class="line"><span class="function">BigInteger <span class="title">not</span><span class="params">()</span> 返回当前大整数的非</span></span><br><span class="line"><span class="function">BigInteger <span class="title">or</span><span class="params">(BigInteger val)</span> 返回两个大整数的按位或</span></span><br><span class="line"><span class="function">BigInteger <span class="title">pow</span><span class="params">(<span class="keyword">int</span> exponent)</span> 返回当前大整数的exponent次方</span></span><br><span class="line"><span class="function">BigInteger <span class="title">remainder</span><span class="params">(BigInteger val)</span> 返回当前大整数除以val的余数</span></span><br><span class="line"><span class="function">BigInteger <span class="title">leftShift</span><span class="params">(<span class="keyword">int</span> n)</span> 将当前大整数左移n位后返回</span></span><br><span class="line"><span class="function">BigInteger <span class="title">rightShift</span><span class="params">(<span class="keyword">int</span> n)</span> 将当前大整数右移n位后返回</span></span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger val)</span>返回两个大整数相减的结果</span></span><br><span class="line"><span class="function"><span class="keyword">byte</span>[] <span class="title">toByteArray</span><span class="params">(BigInteger val)</span>将大整数转换成二进制反码保存在<span class="keyword">byte</span>数组中</span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> 将当前大整数转换成十进制的字符串形式</span></span><br><span class="line"><span class="function">BigInteger <span class="title">xor</span><span class="params">(BigInteger val)</span> 返回两个大整数的异或</span></span><br></pre></td></tr></table></figure><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。具体原理和浮点数的编码方式有关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999964</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">"0.9"</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">"0.8"</span>);</span><br><span class="line">BigDecimal x = a.subtract(b);<span class="comment">// 0.1</span></span><br><span class="line">BigDecimal y = b.subtract(c);<span class="comment">// 0.1</span></span><br><span class="line">System.out.println(x.equals(y));<span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal(<span class="keyword">int</span>)       创建一个具有参数所指定整数值的对象。      </span><br><span class="line">BigDecimal(<span class="keyword">double</span>)    创建一个具有参数所指定双精度值的对象。     </span><br><span class="line">BigDecimal(<span class="keyword">long</span>)      创建一个具有参数所指定长整数值的对象。     </span><br><span class="line">BigDecimal(String)    创建一个具有参数所指定以字符串表示的数值的对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(BigDecimal)       BigDecimal对象中的值相加，然后返回这个对象。</span><br><span class="line">subtract(BigDecimal)  BigDecimal对象中的值相减，然后返回这个对象。</span><br><span class="line">multiply(BigDecimal)  BigDecimal对象中的值相乘，然后返回这个对象。</span><br><span class="line">divide(BigDecimal)    BigDecimal对象中的值相除，然后返回这个对象。</span><br><span class="line">toString()            将BigDecimal对象的数值转换成字符串。    </span><br><span class="line">doubleValue()         将BigDecimal对象中的值以双精度数返回。   </span><br><span class="line">floatValue()          将BigDecimal对象中的值以单精度数返回。   </span><br><span class="line">longValue()           将BigDecimal对象中的值以长整数返回。    </span><br><span class="line">intValue()            将BigDecimal对象中的值以整数返回。</span><br></pre></td></tr></table></figure><p>我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="number">1.01</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="number">1.02</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">"1.01"</span>);</span><br><span class="line">BigDecimal d = <span class="keyword">new</span> BigDecimal(<span class="string">"1.02"</span>);</span><br><span class="line">System.out.println(a.add(b));</span><br><span class="line">System.out.println(c.add(d));</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">2.0300000000000000266453525910037569701671600341796875</span></span><br><span class="line"><span class="number">2.03</span></span><br></pre></td></tr></table></figure><h3 id="整型包装类值的比较"><a href="#整型包装类值的比较" class="headerlink" title="整型包装类值的比较"></a>整型包装类值的比较</h3><p>所有整形包装类对象值得比较必须使用equals方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">3</span>;</span><br><span class="line">Integer y = <span class="number">3</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true</span></span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList"></a>Arrays.asList</h2><p><code>Arrays.asList()</code>将数组转换为集合后,底层其实还是数组。<strong>传递的数组必须是对象数组，而不是基本类型。</strong><code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="keyword">int</span> [] array=(<span class="keyword">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。我们使用包装类型数组就可以解决这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><p><strong>使用集合的修改方法:add()、remove()、clear()会抛出异常。</strong><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> </span></span><br><span class="line"><span class="class"><span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看一下<code>java.util.AbstractList</code>的<code>remove()</code>方法，这样我们就明白为啥会抛出<code>UnsupportedOperationException</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正确的数组转集合的方法：<code>List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code></p><h2 id="Comparable-amp-Comparator"><a href="#Comparable-amp-Comparator" class="headerlink" title="Comparable &amp; Comparator"></a>Comparable &amp; Comparator</h2><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><blockquote><p>This interface imposes a total ordering on the objects of each class that implements it. This ordering is referred to as the class’s natural ordering, and the class’s compareTo method is referred to as its natural comparison method.</p><p>Lists (and arrays) of objects that implement this interface can be sorted automatically by Collections.sort (and Arrays.sort). Objects that implement this interface can be used as keys in a sorted map or as elements in a sorted set, without the need to specify a comparator.</p></blockquote><p>compareTo 方法的返回值有三种情况：</p><ul><li>e1.compareTo(e2) &gt; 0 即 e1 &gt; e2</li><li>e1.compareTo(e2) = 0 即 e1 = e2</li><li>e1.compareTo(e2) &lt; 0 即 e1 &lt; e2</li></ul><p>满足上述规则的是升序排序，与上诉规则相反则是降序排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Set&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">50</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">30</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">90</span>));</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;Person&gt; iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="keyword">if</span>(age &gt; o.age)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(age &lt; o.age)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Person [age="</span> + age + <span class="string">"]"</span>; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Note that null is not an instance of any class, and e.compareTo(null) should throw a NullPointerException even though e.equals(null) returns false.</p></blockquote><blockquote><p>The natural ordering for a class C is said to be consistent with equals if and only if e1.compareTo(e2) == 0 has the same boolean value as e1.equals(e2) for every e1 and e2 of class C. It is strongly recommended (though not required) that natural orderings be consistent with equals. This is so because sorted sets (and sorted maps)without explicit comparators behave “strangely” when they are used with elements (or keys) whose natural ordering is inconsistent with equals. In particular, such a sorted set (or sorted map) violates（违反） the general contract for set (or map), which is defined in terms of（依据） the equals method.</p><p>For example, if one adds two keys a and b such that (!a.equals(b) &amp;&amp; a.compareTo(b) == 0) to a sorted set that does not use an explicit comparator, the second add operation returns false (and the size of the sorted set does not increase) because a and b are equivalent from the sorted set’s perspective.</p></blockquote><p>这段话的意思是如果compareTo规则和equals规则不同就会发生奇怪的问题，即在<code>!a.equals(b) &amp;&amp; a.compareTo(b) == 0</code>这种情况下，不能插入集合中，因为从排序集合判断是否相等使用compareTo的规则。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    </span><br><span class="line">    Set&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">50</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">50</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">90</span>));</span><br><span class="line">    </span><br><span class="line">    Iterator&lt;Person&gt; iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    </span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="keyword">if</span>(age == o.age)<span class="comment">// 模仿 a.compareTo(b) == 0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(age &gt; o.age)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Person [age="</span> + age + <span class="string">"]"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span> || !(obj <span class="keyword">instanceof</span> Person))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Person p = (Person)obj;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.age == <span class="number">50</span> || p.age == <span class="number">50</span>) &#123;<span class="comment">// 模仿 !a.equals(b)</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.age == p.age) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age.hashCode(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Person [age=50]</span></span><br><span class="line"><span class="comment">// Person [age=90]</span></span><br></pre></td></tr></table></figure><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p>使用自然排序需要类实现 Comparable，并且在内部重写 comparaTo 方法。而 Comparator 则是在外部制定排序规则，然后作为排序策略参数传递给某些类，比如 Collections.sort(), Arrays.sort(), 或者一些内部有序的集合（比如 SortedSet，SortedMap 等）。<strong>同时存在时采用 Comparator（定制排序）的规则进行比较。</strong></p><p>使用方式主要分三步：</p><ol><li>创建一个 Comparator 接口的实现类，并赋值给一个对象。在 compare 方法中针对自定义类写排序规则。</li><li>将 Comparator 对象作为参数传递给 排序类的某个方法</li><li>向排序类中添加 compare 方法中使用的自定义类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">    Comparator&lt;Person&gt; com = <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(o1.getAge() &gt; o2.getAge())</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(o1.getAge() &lt; o2.getAge())</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Set&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(com);</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">50</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">20</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">90</span>));</span><br><span class="line">    Iterator&lt;Person&gt; iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Person [age="</span> + age + <span class="string">"]"</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的一点是，compare的相等规则需要个equals相同。</p><h2 id="集合概览"><a href="#集合概览" class="headerlink" title="集合概览"></a>集合概览</h2><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/01-Java基础/2019-08-04_154726.jpg"></div><p></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><strong>Arraylist：</strong> Object数组</li><li><strong>Vector：</strong> Object数组，线程安全。</li><li><strong>LinkedList：</strong> 双向链表</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><strong>HashMap：</strong> JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li><li><strong>LinkedHashMap：</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><strong>TreeMap：</strong> 红黑树</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li><strong>HashSet（无序，唯一）:</strong> 基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li><strong>LinkedHashSet：</strong> LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</li><li><strong>TreeSet（有序，唯一）：</strong> 红黑树（自平衡的排序二叉树)</li></ul><h2 id="ArrayList分析"><a href="#ArrayList分析" class="headerlink" title="ArrayList分析"></a>ArrayList分析</h2><p><strong>ArrayList有三种方式来初始化，构造方法源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">//初始容量大于0</span></span><br><span class="line">        <span class="comment">//创建initialCapacity大小的数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">//初始容量等于0</span></span><br><span class="line">        <span class="comment">//创建空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//初始容量小于0，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">*如果指定的集合为null，throws NullPointerException。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p><h3 id="add"><a href="#add" class="headerlink" title="add"></a><code>add</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的元素追加到此列表的末尾。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">//添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ensureCapacityInternal"><a href="#ensureCapacityInternal" class="headerlink" title="ensureCapacityInternal()"></a><code>ensureCapacityInternal()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当我们要 add 进第1个元素到 ArrayList 时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。elementData.length 为0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code>不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。</li></ul><p>直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。</p><h3 id="grow"><a href="#grow" class="headerlink" title="grow()"></a><code>grow()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//若新容量大于MAX_ARRAY_SIZE，执行hugeCapacity()方法来比较minCapacity和MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">//若minCapacity大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 </span></span><br><span class="line">    <span class="comment">//MAX_ARRAY_SIZE 即为Integer.MAX_VALUE - 8。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍！</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><p><strong>我们再来通过例子探究一下grow() 方法 ：</strong></p><ul><li>当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为10，add方法中 return true,size增为1。</li><li>当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true，size增为11。</li><li>以此类推······</li></ul><p>如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p><p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p><ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h3 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy()"></a><code>System.arraycopy()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class="line"><span class="comment"> *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span></span><br><span class="line"><span class="comment"> *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf()"></a><code>Arrays.copyOf()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, </span><br><span class="line">                               <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                     Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容。</p><h3 id="ensureCapacity"><a href="#ensureCapacity" class="headerlink" title="ensureCapacity"></a><code>ensureCapacity</code></h3><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span><br><span class="line"> *</span><br><span class="line"> * @param   minCapacity   所需的最小容量</span><br><span class="line"> */</span><br><span class="line">public void ensureCapacity(int minCapacity) &#123;</span><br><span class="line">    int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        // any size if not default element table</span><br><span class="line">        ? 0</span><br><span class="line">        // larger than default for default empty table. It&apos;s already</span><br><span class="line">        // supposed to be at default size.</span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">    if (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数</strong></p><p>我们通过下面的代码实际测试以下这个方法的效果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnsureCapacityTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"使用ensureCapacity方法前："</span>+(endTime - startTime));</span><br><span class="line"></span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"><span class="keyword">long</span> startTime1 = System.currentTimeMillis();</span><br><span class="line">list.ensureCapacity(N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime1 = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"使用ensureCapacity方法后："</span>+(endTime1 - startTime1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用ensureCapacity方法前：4637</span><br><span class="line">使用ensureCapacity方法后：241</span><br></pre></td></tr></table></figure><p>通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p><h2 id="LinkedList分析"><a href="#LinkedList分析" class="headerlink" title="LinkedList分析"></a>LinkedList分析</h2><p>LinkedList是一个实现了List接口和Deque接口的双端链表。 LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性；LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list=Collections.synchronizedList(new LinkedList(...));</span><br></pre></td></tr></table></figure><h3 id="内部结构分析"><a href="#内部结构分析" class="headerlink" title="内部结构分析"></a>内部结构分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">E item;<span class="comment">//节点值</span></span><br><span class="line">    Node&lt;E&gt; next;<span class="comment">//后继节点</span></span><br><span class="line">    Node&lt;E&gt; prev;<span class="comment">//前驱节点</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>空构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>用已有的集合创建链表的构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><p><strong>add(E e)</strong> 方法：将元素添加到链表尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);<span class="comment">//这里就只调用了这一个方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 链接使e作为最后一个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode;<span class="comment">//新建节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    l.next = newNode;<span class="comment">//指向后继元素也就是指向下一个元素</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>add(int index,E e)</strong>：在指定位置添加元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index); <span class="comment">//检查索引是否处于[0-size]之间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index == size)<span class="comment">//添加在链表尾部</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span><span class="comment">//添加在链表中间</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>linkBefore方法需要给定两个参数，一个插入节点的值，一个指定的node，所以我们又调用了Node(index)去找到index对应的node</p><p><strong>addAll(Collection c )：将集合插入到链表尾部</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>addAll(int index, Collection c)：</strong> 将集合从指定位置开始插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1:检查index范围是否在size之内</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2:toArray()方法把集合的数据存到对象数组中</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3：得到插入位置的前驱节点和后继节点</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="comment">//如果插入位置为尾部，前驱节点为last，后继节点为null</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则，调用node()方法得到后继节点，再得到前驱节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4：遍历数据将数据插入</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        <span class="comment">//创建新节点</span></span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//如果插入位置在链表头部</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果插入位置在尾部，重置last节点</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则，将插入的链表与先前链表连接起来</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面可以看出addAll方法通常包括下面四个步骤：</p><ol><li>检查index范围是否在size之内</li><li>toArray()方法把集合的数据存到对象数组中</li><li>得到插入位置的前驱和后继节点</li><li>遍历数据，将数据插入到指定位置</li></ol><p><strong>addFirst(E e)：</strong> 将元素添加到链表头部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f);<span class="comment">//新建节点，以头节点为后继节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">//如果链表为空，last节点也指向该节点</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="comment">//否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>addLast(E e)：</strong> 将元素添加到链表尾部，与 <strong>add(E e)</strong> 方法一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="根据位置取数据的方法"><a href="#根据位置取数据的方法" class="headerlink" title="根据位置取数据的方法"></a>根据位置取数据的方法</h3><p><strong>get(int index)：</strong> 根据指定索引返回数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查index范围是否在size之内</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//调用Node(index)去找到index对应的node然后返回它的值</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取头节点（index=0）数据方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>区别：</strong> getFirst()，element()，peek()，peekFirst() 这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中<strong>getFirst()</strong> 和<strong>element()</strong> 方法将会在链表为空时，抛出异常</p><p>element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException<br><strong>获取尾节点（index=-1）数据方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两者区别：</strong> <strong>getLast()</strong> 方法在链表为空时，会抛出<strong>NoSuchElementException</strong>，而<strong>peekLast()</strong> 则不会，只是会返回 <strong>null</strong>。</p><h3 id="根据对象得到索引的方法"><a href="#根据对象得到索引的方法" class="headerlink" title="根据对象得到索引的方法"></a>根据对象得到索引的方法</h3><p><strong>int indexOf(Object o)：</strong> 从头遍历找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从头遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从头遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>int lastIndexOf(Object o)：</strong> 从尾遍历找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从尾遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从尾遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="检查链表是否包含某对象的方法"><a href="#检查链表是否包含某对象的方法" class="headerlink" title="检查链表是否包含某对象的方法"></a>检查链表是否包含某对象的方法</h3><p><strong>contains(Object o)：</strong> 检查对象o是否存在于链表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h3><p><strong>remove()</strong> ,<strong>removeFirst(),pop():</strong> 删除头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>removeLast(),pollLast():</strong> 删除尾节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>区别：</strong> removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。</p><p><strong>remove(Object o):</strong> 删除指定元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果删除对象为null</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//从头开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">//找到元素</span></span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//从链表中移除找到的元素</span></span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从头开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">//找到元素</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                <span class="comment">//从链表中移除找到的元素</span></span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。</p><p>unlink(Node x) 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next;<span class="comment">//得到后继节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;<span class="comment">//得到前驱节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除前驱指针</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next;<span class="comment">//如果删除的节点是头节点,令头节点指向该节点的后继节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next;<span class="comment">//将前驱节点的后继节点指向后继节点</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除后继指针</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev;<span class="comment">//如果删除的节点是尾节点,令尾节点指向该节点的前驱节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>remove(int index)</strong>：删除指定位置的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查index范围</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//将节点删除</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LinkedList类常用方法测试"><a href="#LinkedList类常用方法测试" class="headerlink" title="LinkedList类常用方法测试"></a>LinkedList类常用方法测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建存放int类型的linkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">/************************** linkedList的基本操作 ************************/</span></span><br><span class="line">        linkedList.addFirst(<span class="number">0</span>); <span class="comment">// 添加元素到列表开头</span></span><br><span class="line">        linkedList.add(<span class="number">1</span>); <span class="comment">// 在列表结尾添加元素</span></span><br><span class="line">        linkedList.add(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 在指定位置添加元素</span></span><br><span class="line">        linkedList.addLast(<span class="number">3</span>); <span class="comment">// 添加元素到列表结尾</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"LinkedList（直接输出的）: "</span> + linkedList);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"getFirst()获得第一个元素: "</span> + linkedList.getFirst()); <span class="comment">// 返回此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"getLast()获得第最后一个元素: "</span> + linkedList.getLast()); <span class="comment">// 返回此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"removeFirst()删除第一个元素并返回: "</span> + linkedList.removeFirst()); <span class="comment">// 移除并返回此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"removeLast()删除最后一个元素并返回: "</span> + linkedList.removeLast()); <span class="comment">// 移除并返回此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"After remove:"</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">"contains()方法判断列表是否包含1这个元素:"</span> + linkedList.contains(<span class="number">1</span>)); <span class="comment">// 判断此列表包含指定元素，如果是，则返回true</span></span><br><span class="line">        System.out.println(<span class="string">"该linkedList的大小 : "</span> + linkedList.size()); <span class="comment">// 返回此列表的元素个数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 位置访问操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.set(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 将此列表中指定位置的元素替换为指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">"After set(1, 3):"</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">"get(1)获得指定位置（这里为1）的元素: "</span> + linkedList.get(<span class="number">1</span>)); <span class="comment">// 返回此列表中指定位置处的元素</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Search操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"indexOf(3): "</span> + linkedList.indexOf(<span class="number">3</span>)); <span class="comment">// 返回此列表中首次出现的指定元素的索引</span></span><br><span class="line">        System.out.println(<span class="string">"lastIndexOf(3): "</span> + linkedList.lastIndexOf(<span class="number">3</span>));<span class="comment">// 返回此列表中最后出现的指定元素的索引</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Queue操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"peek(): "</span> + linkedList.peek()); <span class="comment">// 获取但不移除此列表的头</span></span><br><span class="line">        System.out.println(<span class="string">"element(): "</span> + linkedList.element()); <span class="comment">// 获取但不移除此列表的头</span></span><br><span class="line">        linkedList.poll(); <span class="comment">// 获取并移除此列表的头</span></span><br><span class="line">        System.out.println(<span class="string">"After poll():"</span> + linkedList);</span><br><span class="line">        linkedList.remove();</span><br><span class="line">        System.out.println(<span class="string">"After remove():"</span> + linkedList); <span class="comment">// 获取并移除此列表的头</span></span><br><span class="line">        linkedList.offer(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"After offer(4):"</span> + linkedList); <span class="comment">// 将指定元素添加到此列表的末尾</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** Deque操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.offerFirst(<span class="number">2</span>); <span class="comment">// 在此列表的开头插入指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">"After offerFirst(2):"</span> + linkedList);</span><br><span class="line">        linkedList.offerLast(<span class="number">5</span>); <span class="comment">// 在此列表末尾插入指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">"After offerLast(5):"</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">"peekFirst(): "</span> + linkedList.peekFirst()); <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"peekLast(): "</span> + linkedList.peekLast()); <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">        linkedList.pollFirst(); <span class="comment">// 获取并移除此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"After pollFirst():"</span> + linkedList);</span><br><span class="line">        linkedList.pollLast(); <span class="comment">// 获取并移除此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"After pollLast():"</span> + linkedList);</span><br><span class="line">        linkedList.push(<span class="number">2</span>); <span class="comment">// 将元素推入此列表所表示的堆栈（插入到列表的头）</span></span><br><span class="line">        System.out.println(<span class="string">"After push(2):"</span> + linkedList);</span><br><span class="line">        linkedList.pop(); <span class="comment">// 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span></span><br><span class="line">        System.out.println(<span class="string">"After pop():"</span> + linkedList);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        linkedList.removeFirstOccurrence(<span class="number">3</span>); <span class="comment">// 从此列表中移除第一次出现的指定元素（从头部到尾部遍历列表）</span></span><br><span class="line">        System.out.println(<span class="string">"After removeFirstOccurrence(3):"</span> + linkedList);</span><br><span class="line">        linkedList.removeLastOccurrence(<span class="number">3</span>); <span class="comment">// 从此列表中移除最后一次出现的指定元素（从尾部到头部遍历列表）</span></span><br><span class="line">        System.out.println(<span class="string">"After removeFirstOccurrence(3):"</span> + linkedList);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/************************** 遍历操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            linkedList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器遍历</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = linkedList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Iterator："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 顺序遍历(随机遍历)</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">            linkedList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"for："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 另一种for循环遍历</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : linkedList)</span><br><span class="line">            ;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"for2："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过pollFirst()或pollLast()来遍历LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; temp1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        temp1.addAll(linkedList);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (temp1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            temp1.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"pollFirst()或pollLast()："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过removeFirst()或removeLast()来遍历LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; temp2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        temp2.addAll(linkedList);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (temp2.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            temp2.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"removeFirst()或removeLast()："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HashMap分析"><a href="#HashMap分析" class="headerlink" title="HashMap分析"></a>HashMap分析</h2><p>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。</p><p>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。</p><h3 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h3><h4 id="JDK1-8之前"><a href="#JDK1-8之前" class="headerlink" title="JDK1.8之前"></a>JDK1.8之前</h4><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedListDemo &#123;</span><br><span class="line">    static final int hash(Object key) &#123;</span><br><span class="line">      int h;</span><br><span class="line">      // key.hashCode()：返回散列值也就是hashcode</span><br><span class="line">      // ^ ：按位异或</span><br><span class="line">      // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br><span class="line">      return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line"></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><h4 id="JDK1-8之后"><a href="#JDK1-8之后" class="headerlink" title="JDK1.8之后"></a>JDK1.8之后</h4><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><a href="https://camo.githubusercontent.com/20de7e465cac279842851258ec4d1ec1c4d3d7d1/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32322f36373233333736342e6a7067" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/20de7e465cac279842851258ec4d1ec1c4d3d7d1/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d382d32322f36373233333736342e6a7067" alt="JDK1.8之后的HashMap底层数据结构"></a></p><p><strong>类的属性：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;    </span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;   </span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; </span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; </span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; </span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>; </span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; </span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table; </span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;   </span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>loadFactor加载因子</strong></p><p>loadFactor加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor越小，也就是趋近于0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p><strong>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值</strong>。</p><p>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p></li><li><p><strong>threshold</strong></p><p><strong>threshold = capacity * loadFactor</strong>，<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p></li></ul><p><strong>Node节点类源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>树节点类源码:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;    <span class="comment">// 左</span></span><br><span class="line">        TreeNode&lt;K,V&gt; right;   <span class="comment">// 右</span></span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;           <span class="comment">// 判断颜色</span></span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回根节点</span></span><br><span class="line">        <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> r;</span><br><span class="line">                r = p;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h3><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>putMapEntries方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p><p><strong>对putVal方法添加元素的分析如下：</strong></p><ul><li>①如果定位到的数组位置没有元素 就直接插入。</li><li>②如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ul><p><a href="https://camo.githubusercontent.com/725bb9953df54438fadb74a1bea180ed817b9e27/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f322f313635393862663735386337343765363f773d39393926683d36373926663d706e6726733d3534343836" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/725bb9953df54438fadb74a1bea180ed817b9e27/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f392f322f313635393862663735386337343765363f773d39393926683d36373926663d706e6726733d3534343836" alt="put方法"></a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值，转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h4><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap常用方法测试"><a href="#HashMap常用方法测试" class="headerlink" title="HashMap常用方法测试"></a>HashMap常用方法测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 键不能重复，值可以重复</span></span><br><span class="line">        map.put(<span class="string">"san"</span>, <span class="string">"张三"</span>);</span><br><span class="line">        map.put(<span class="string">"si"</span>, <span class="string">"李四"</span>);</span><br><span class="line">        map.put(<span class="string">"wu"</span>, <span class="string">"王五"</span>);</span><br><span class="line">        map.put(<span class="string">"wang"</span>, <span class="string">"老王"</span>);</span><br><span class="line">        map.put(<span class="string">"wang"</span>, <span class="string">"老王2"</span>);<span class="comment">// 老王被覆盖</span></span><br><span class="line">        map.put(<span class="string">"lao"</span>, <span class="string">"老王"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------直接输出hashmap:-------"</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历HashMap</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.获取Map中的所有键</span></span><br><span class="line">        System.out.println(<span class="string">"-------foreach获取Map中所有的键:------"</span>);</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.print(key+<span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 2.获取Map中所有值</span></span><br><span class="line">        System.out.println(<span class="string">"-------foreach获取Map中所有的值:------"</span>);</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">            System.out.print(value+<span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class="line">        System.out.println(<span class="string">"-------得到key的值的同时得到key所对应的值:-------"</span>);</span><br><span class="line">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys2) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">"："</span> + map.get(key)+<span class="string">"   "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 另外一种不常用的遍历方式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class="line">        <span class="comment">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class="line">        <span class="comment">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class="line">        <span class="comment">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class="line">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">"--"</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashMap其他常用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"after map.size()："</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">"after map.isEmpty()："</span>+map.isEmpty());</span><br><span class="line">        System.out.println(map.remove(<span class="string">"san"</span>));</span><br><span class="line">        System.out.println(<span class="string">"after map.remove()："</span>+map);</span><br><span class="line">        System.out.println(<span class="string">"after map.get(si)："</span>+map.get(<span class="string">"si"</span>));</span><br><span class="line">        System.out.println(<span class="string">"after map.containsKey(si)："</span>+map.containsKey(<span class="string">"si"</span>));</span><br><span class="line">        System.out.println(<span class="string">"after containsValue(李四)："</span>+map.containsValue(<span class="string">"李四"</span>));</span><br><span class="line">        System.out.println(map.replace(<span class="string">"si"</span>, <span class="string">"李四2"</span>));</span><br><span class="line">        System.out.println(<span class="string">"after map.replace(si, 李四2):"</span>+map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TreeMap分析"><a href="#TreeMap分析" class="headerlink" title="TreeMap分析"></a>TreeMap分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>在此分析一下Map的体系结构：</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/01-Java基础/2019-08-06_200249.jpg"></div><br>AbstractMap是一个实现Map接口的抽象类，它实现了一个Map的骨架，方便开发者来实现一个自己的Map。如果开发者需要实现一个自己的不可变的Map，只需要继承它再实现entrySet方法。如果开发者想需要实现一个自己的可变的Map，在不可变Map的基础上还需要实现put方法，并且在其的iterator上实现remove方法。<p></p><p>SortedMap是一个键有序的Map，存在Comparator时使用其规则，否则使用Comparable的规则。</p><p>NavigableMap是一个导航Map，它含有的方法可以帮助寻找一个键的上一个键，下一个键，或者按键值逆序等。</p><h3 id="红黑树的特点"><a href="#红黑树的特点" class="headerlink" title="红黑树的特点"></a>红黑树的特点</h3><ul><li>每个结点都有颜色，红色或者黑色</li><li>根结点是黑色的</li><li>每个叶结点是黑色的（设叶结点是NIL，但它不是一个空节点，是一个哨兵）</li><li>如果一个结点是红色的，则它的两个子结点都是黑色的</li><li>对每个结点，从该结点到其所有后代结点的简单路径上，均包含相同数目的黑色结点</li></ul><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果实体不支持自然排序，有没有传入排序器，报异常。此行代码只做类型检查</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line"></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)<span class="comment">// key &lt; t.key</span></span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">// key &gt; t.key</span></span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);  <span class="comment">// key和t.key相等时覆盖</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// t为空时会走到此步，parent为最后一个经过的有数据的节点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 返回的是旧的 value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            <span class="comment">// y是x的叔叔结点</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色</span></span><br><span class="line">            <span class="comment">// 将父结点和叔叔结点涂黑，将爷爷结点涂红</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的右子</span></span><br><span class="line">            <span class="comment">// 当前结点的父结点做为新的当前结点，以新当前结点为支点左旋</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当前结点的父结点是红色，叔叔结点是黑色，当前结点是其父结点的左子</span></span><br><span class="line">                <span class="comment">// 父结点变为黑色，祖父结点变为红色，在祖父结点为支点右旋</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="comment">// 当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色</span></span><br><span class="line">            <span class="comment">// 将父结点和叔叔结点涂黑，将爷爷结点涂红</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的左子</span></span><br><span class="line">            <span class="comment">// 当前结点的父结点做为新的当前结点，以新当前结点为支点右旋</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的左子</span></span><br><span class="line">                <span class="comment">// 父结点变为黑色，祖父结点变为红色，在祖父结点为支点左旋</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    V oldValue = p.value;</span><br><span class="line">    deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> oldValue;<span class="comment">// 返回旧的value</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If strictly internal, copy successor's element to p and then make p</span></span><br><span class="line">    <span class="comment">// point to successor.</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// s 是后继</span></span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// p 拷贝到 s</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// p 现在指向需要被删除的结点</span></span><br><span class="line">        p = s;</span><br><span class="line">    &#125; <span class="comment">// p has 2 children</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到了这里，无论原始的p有无孩子，p都是被即将被删除的结点</span></span><br><span class="line">    <span class="comment">// Start fixup at replacement node, if it exists.</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// replacement指向有数据的子树，设为R子树，此子树会替代原始的子树</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;<span class="comment">// 有孩子</span></span><br><span class="line">        <span class="comment">// Link replacement to parent</span></span><br><span class="line">        <span class="comment">// R子树的父亲指向即将被删除的结点的父亲</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="comment">// 如果即将被删除的结点没有父亲（有孩子）</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">       <span class="comment">// 把R子树挂上去</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">       <span class="comment">// 把R子树挂上去</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到了这步，p已经被替换掉了。将其的连接结点都置空</span></span><br><span class="line">        <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Fix replacement</span></span><br><span class="line">        <span class="comment">// R子树上去后，如果是删除的结点是黑色，需要调整</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    <span class="comment">// 和第39行的区别是：第39行的情况p是一个根结点，而此种情况就p这一个结点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">// return if we are the only node.</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 没有孩子，有父亲，是个叶结点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//  No children. Use self as phantom replacement and unlink.</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            <span class="comment">// 转下去分析修复</span></span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 是上一步的R子树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真正要修复的情况是：被删除的结点是黑色且升上去的结点也是黑色（此时黑高会减1）</span></span><br><span class="line">    <span class="comment">// 算法的目的是让x指向的那棵树是红结点且整棵树不违反红黑树的性质</span></span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 总共有四种违反红黑树性质的情况。</span></span><br><span class="line">        <span class="comment">// 若被删除的结点树红色，直接删除，无任何影响</span></span><br><span class="line">        <span class="comment">// 若被删除的结点是黑色，但是上来的结点是红色，直接将其染黑就行了</span></span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当前结点是黑+黑且兄弟结点为红色（此时父结点和兄弟结点的子结点为黑）</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把父结点染成红色，把兄弟结点染成黑色，左旋</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                <span class="comment">// 旋转不改变x的指向</span></span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                sib = rightOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ---到了这步，x仍然指向这一轮迭代初的结点，sib会转为黑色</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">// 兄弟结点的两个子结点全为黑色，兄弟结点染红</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                <span class="comment">// 走到此步，退出循环，x此时为红色</span></span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 兄弟结点是黑色，兄弟的左子是红色，右子是黑色</span></span><br><span class="line">                <span class="comment">// 把兄弟结点染红，兄弟左子结点染黑，之后再以兄弟结点为支点解右旋</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateRight(sib);</span><br><span class="line">                    <span class="comment">// 调整兄弟结点的指向</span></span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 到了这步，兄弟结点是黑色，兄弟结点的右子是红色</span></span><br><span class="line">                <span class="comment">// 把兄弟结点染成当前结点父结点的颜色，把当前结点父结点染成黑色，</span></span><br><span class="line">                <span class="comment">// 兄弟结点右子染成黑色，之后以当前结点的父结点为支点进行左旋</span></span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(rightOf(sib), BLACK);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                sib = leftOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Collections和Arrays常见方法"><a href="#Collections和Arrays常见方法" class="headerlink" title="Collections和Arrays常见方法"></a>Collections和Arrays常见方法</h2><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><h4 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。</span></span></span><br></pre></td></tr></table></figure><h4 id="查找-替换操作"><a href="#查找-替换操作" class="headerlink" title="查找,替换操作"></a>查找,替换操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(Collection coll)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOfSubList</span><span class="params">(List source, list target)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span> <span class="comment">//用新元素替换旧元素</span></span></span><br></pre></td></tr></table></figure><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><h4 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序 : sort()"></a>排序 : <code>sort()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// sort(int[] a)方法按照数字顺序排列指定的数组。</span></span><br><span class="line">Arrays.sort(a);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(a):"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort(int[] a,int fromIndex,int toIndex)按升序排列数组的指定范围</span></span><br><span class="line"><span class="keyword">int</span> b[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line">Arrays.sort(b, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(b, 2, 6):"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : b) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// parallelSort(int[] a) 按照数字顺序排列指定的数组(并行的)。同sort方法一样也有按范围的排序</span></span><br><span class="line">Arrays.parallelSort(c);</span><br><span class="line">System.out.println(<span class="string">"Arrays.parallelSort(c)："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : c) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallelSort给字符数组排序，sort也可以</span></span><br><span class="line"><span class="keyword">char</span> d[] = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line">Arrays.parallelSort(d);</span><br><span class="line">System.out.println(<span class="string">"Arrays.parallelSort(d)："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> d2 : d) &#123;</span><br><span class="line">System.out.print(d2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找-binarySearch"><a href="#查找-binarySearch" class="headerlink" title="查找 : binarySearch()"></a>查找 : <code>binarySearch()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] e = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="comment">// 排序后再进行二分查找，否则找不到</span></span><br><span class="line">Arrays.sort(e);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(e)"</span> + Arrays.toString(e));</span><br><span class="line">System.out.println(<span class="string">"Arrays.binarySearch(e, 'c')："</span>);</span><br><span class="line"><span class="keyword">int</span> s = Arrays.binarySearch(e, <span class="string">'c'</span>);</span><br><span class="line">System.out.println(<span class="string">"字符c在数组的位置："</span> + s);</span><br></pre></td></tr></table></figure><h4 id="比较-equals"><a href="#比较-equals" class="headerlink" title="比较: equals()"></a>比较: <code>equals()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] e = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="keyword">char</span>[] f = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 元素数量相同，并且相同位置的元素相同。 另外，如果两个数组引用都是null，则它们被认为是相等的 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 输出true</span></span><br><span class="line">System.out.println(<span class="string">"Arrays.equals(e, f):"</span> + Arrays.equals(e, f));</span><br></pre></td></tr></table></figure><h4 id="填充-fill"><a href="#填充-fill" class="headerlink" title="填充 : fill()"></a>填充 : <code>fill()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] g = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="comment">// 数组中所有元素重新分配值</span></span><br><span class="line">Arrays.fill(g, <span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.fill(g, 3)："</span>);</span><br><span class="line"><span class="comment">// 输出结果：333333333</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : g) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] h = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, &#125;;</span><br><span class="line"><span class="comment">// 数组中指定范围元素重新分配值</span></span><br><span class="line">Arrays.fill(h, <span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.fill(h, 0, 2, 9);："</span>);</span><br><span class="line"><span class="comment">// 输出结果：993333666</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : h) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转列表-asList"><a href="#转列表-asList" class="headerlink" title="转列表 asList()"></a>转列表 <code>asList()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回由指定数组支持的固定大小的列表。</span></span><br><span class="line"><span class="comment">* （将返回的列表更改为“写入数组”。）该方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()相结合 。</span></span><br><span class="line"><span class="comment">* 返回的列表是可序列化的，并实现RandomAccess 。</span></span><br><span class="line"><span class="comment">* 此方法还提供了一种方便的方式来创建一个初始化为包含几个元素的固定大小的列表如下：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Moe"</span>, <span class="string">"Curly"</span>);</span><br><span class="line">System.out.println(stooges);</span><br></pre></td></tr></table></figure><h4 id="转字符串-toString"><a href="#转字符串-toString" class="headerlink" title="转字符串 toString()"></a>转字符串 <code>toString()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回指定数组的内容的字符串表示形式。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span>[] k = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line">System.out.println(Arrays.toString(k));<span class="comment">// [a, f, b, c, e, A, C, B]</span></span><br></pre></td></tr></table></figure><h4 id="复制-copyOf"><a href="#复制-copyOf" class="headerlink" title="复制 copyOf()"></a>复制 <code>copyOf()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copyOf 方法实现数组复制,h为数组，6为复制的长度</span></span><br><span class="line"><span class="keyword">int</span>[] h = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, &#125;;</span><br><span class="line"><span class="keyword">int</span> i[] = Arrays.copyOf(h, <span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.copyOf(h, 6);："</span>);</span><br><span class="line"><span class="comment">// 输出结果：123333</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : i) &#123;</span><br><span class="line">System.out.print(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// copyOfRange将指定数组的指定范围复制到新数组中</span></span><br><span class="line"><span class="keyword">int</span> j[] = Arrays.copyOfRange(h, <span class="number">6</span>, <span class="number">11</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.copyOfRange(h, 6, 11)："</span>);</span><br><span class="line"><span class="comment">// 输出结果66600(h数组只有9个元素这里是从索引6到索引11复制所以不足的就为0)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j2 : j) &#123;</span><br><span class="line">System.out.print(j2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><h2 id="序列化-1"><a href="#序列化-1" class="headerlink" title="序列化"></a>序列化</h2><p>把变量从内存中变成可存储或传输的过程称之为序列化，把字节序列恢复为Java对象的过程称为对象的反序列化。对象的序列化主要有两种用途：</p><ol><li>把对象的字节序列永久的保存到硬盘上，通常存放在一个文件中。</li><li>在网络上传送对象的字节序列。</li></ol><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/01-Java基础/序列化.png"></div><p></p><h3 id="默认序列化"><a href="#默认序列化" class="headerlink" title="默认序列化"></a>默认序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Path path = Paths.get(<span class="string">"test"</span>);</span><br><span class="line">Person temp = <span class="keyword">new</span> Person(<span class="string">"陈钰琪"</span>, <span class="number">19</span>, <span class="string">"411x2x19xx1x2x6x1x"</span>, <span class="number">20000</span>d);</span><br><span class="line"></span><br><span class="line">ObjectOutputStream out = </span><br><span class="line"><span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(path.toFile()));</span><br><span class="line">out.writeObject(temp);</span><br><span class="line"></span><br><span class="line">ObjectInputStream in = </span><br><span class="line"><span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(path.toFile()));</span><br><span class="line">Person readObject = (Person)in.readObject();</span><br><span class="line">System.out.println(readObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">485348963313276072L</span>;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age, String id, Double money)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.money = money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter和setter</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", </span></span><br><span class="line"><span class="string">age="</span> + age + <span class="string">", id="</span> + id + <span class="string">", money="</span> + money + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>版本号是为了控制对象的版本而存在的，版本号一致才可认为可以进行对应的序列化和反序列化。比如我们使用上面的代码把一个Person写入temp文件了，然后修改<code>serialVersionUID = 485348963313276072L;</code>，会发现爆出<code>java.io.InvalidClassException</code>。</p><h3 id="单例的处理"><a href="#单例的处理" class="headerlink" title="单例的处理"></a>单例的处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MySingleton</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MySingleton INSTANCE = <span class="keyword">new</span> MySingleton(); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE; &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123; </span><br><span class="line">    <span class="comment">// instead of the object we're on, return the class variable INSTANCE </span></span><br><span class="line"><span class="keyword">return</span> INSTANCE; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化”组装”一个新对象时，就会自动调用这个readResolve方法来返回我们指定好的对象了，单例规则也就得到了保证。</p><p>​</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;JVM-amp-JDK-amp-JRE&quot;&gt;&lt;a href=&quot;#JVM-amp-JDK-amp-JRE&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/categories/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
    
      <category term="应届求职复习" scheme="https://isjinhao.github.io/tags/%E5%BA%94%E5%B1%8A%E6%B1%82%E8%81%8C%E5%A4%8D%E4%B9%A0/"/>
    
      <category term="面试" scheme="https://isjinhao.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Java邮件发送</title>
    <link href="https://isjinhao.github.io/2019/Java%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
    <id>https://isjinhao.github.io/2019/Java邮件发送/</id>
    <published>2019-07-26T04:01:16.000Z</published>
    <updated>2019-07-26T04:04:44.497Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --><h2 id="Maven依赖"><a href="#Maven依赖" class="headerlink" title="Maven依赖"></a>Maven依赖</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.mail<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.4.7<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不要修改版本号，这个版本之间的差异很大。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(MailConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailVerification</span> </span>&#123;</span><br><span class="line"><span class="comment">// 收件人地址</span></span><br><span class="line"><span class="keyword">private</span> String recipientAddress;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String info;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> MailConfig mailconfig;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendVerCode</span><span class="params">(String info, String recipientAddress)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.info = info;</span><br><span class="line"><span class="keyword">this</span>.recipientAddress = recipientAddress;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、连接邮件服务器的参数配置</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//设置用户的认证方式</span></span><br><span class="line">        props.setProperty(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>);</span><br><span class="line">        <span class="comment">//设置传输协议</span></span><br><span class="line">        props.setProperty(<span class="string">"mail.transport.protocol"</span>, <span class="string">"smtp"</span>);</span><br><span class="line">        <span class="comment">//设置发件人的SMTP服务器地址</span></span><br><span class="line">        props.setProperty(<span class="string">"mail.smtp.host"</span>, <span class="string">"smtp.163.com"</span>);</span><br><span class="line">        <span class="comment">//2、创建定义整个应用程序所需的环境信息的 Session 对象</span></span><br><span class="line">        Session session = Session.getInstance(props);</span><br><span class="line">        <span class="comment">//设置调试信息在控制台打印出来</span></span><br><span class="line">        session.setDebug(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//3、创建邮件的实例对象</span></span><br><span class="line">        Message msg = getMimeMessage(session);</span><br><span class="line">        <span class="comment">//4、根据session对象获取邮件传输对象Transport</span></span><br><span class="line">        Transport transport = session.getTransport();</span><br><span class="line">        <span class="comment">//设置发件人的账户名和密码</span></span><br><span class="line">        transport.connect(mailconfig.getSenderAccount(), mailconfig.getSenderPassword());</span><br><span class="line">        <span class="comment">//发送邮件，并发送到所有收件人地址，message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人</span></span><br><span class="line">        transport.sendMessage(msg, msg.getAllRecipients());</span><br><span class="line">        <span class="comment">//如果只想发送给指定的人，可以如下写法</span></span><br><span class="line">        <span class="comment">//transport.sendMessage(msg, new Address[]&#123;new InternetAddress("xxx@qq.com")&#125;);</span></span><br><span class="line">        <span class="comment">//5、关闭邮件连接</span></span><br><span class="line">        transport.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获得创建一封邮件的实例对象</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> session</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> MessagingException</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> AddressException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> MimeMessage <span class="title">getMimeMessage</span><span class="params">(Session session)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">// 创建一封邮件的实例对象</span></span><br><span class="line">MimeMessage msg = <span class="keyword">new</span> MimeMessage(session);</span><br><span class="line"><span class="comment">// 设置发件人地址</span></span><br><span class="line">msg.setFrom(<span class="keyword">new</span> InternetAddress(mailconfig.getSenderAddress()));</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 设置收件人地址（可以增加多个收件人、抄送、密送），即下面这一行代码书写多行 MimeMessage.RecipientType.TO:发送</span></span><br><span class="line"><span class="comment"> * MimeMessage.RecipientType.CC：抄送 MimeMessage.RecipientType.BCC：密送</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">msg.setRecipient(MimeMessage.RecipientType.TO, <span class="keyword">new</span> InternetAddress(recipientAddress));</span><br><span class="line">msg.setRecipient(MimeMessage.RecipientType.CC, <span class="keyword">new</span> InternetAddress(mailconfig.getSenderAddress()));</span><br><span class="line"></span><br><span class="line">msg.setSubject(<span class="string">"航班管理系统验证码"</span>, <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="comment">// 设置邮件正文</span></span><br><span class="line">msg.setContent(<span class="string">"您好，您的验证码是： "</span>  + info + <span class="string">" ,请在30分钟内完成验证！"</span>, <span class="string">"text/html;charset=UTF-8"</span>);</span><br><span class="line"><span class="comment">// 设置邮件的发送时间,默认立即发送</span></span><br><span class="line">msg.setSentDate(<span class="keyword">new</span> Date());</span><br><span class="line"><span class="keyword">return</span> msg;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"as.email"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String senderAddress;</span><br><span class="line">    <span class="keyword">private</span> String senderAccount;</span><br><span class="line">    <span class="keyword">private</span> String senderPassword;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSenderAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> senderAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSenderAddress</span><span class="params">(String senderAddress)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.senderAddress = senderAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSenderAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> senderAccount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSenderAccount</span><span class="params">(String senderAccount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.senderAccount = senderAccount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSenderPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> senderPassword;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSenderPassword</span><span class="params">(String senderPassword)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.senderPassword = senderPassword;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Maven依赖&quot;&gt;&lt;a href=&quot;#Maven依赖&quot; class=&quot;headerlink&quot; title=&quot;Maven依赖&quot;&gt;&lt;/a&gt;
      
    
    </summary>
    
      <category term="邮件发送" scheme="https://isjinhao.github.io/categories/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
    
    
      <category term="邮件发送" scheme="https://isjinhao.github.io/tags/%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>centos7下mysql5.6安装和卸载</title>
    <link href="https://isjinhao.github.io/2019/centos7%E4%B8%8Bmysql5-6%E5%AE%89%E8%A3%85%E5%92%8C%E5%8D%B8%E8%BD%BD/"/>
    <id>https://isjinhao.github.io/2019/centos7下mysql5-6安装和卸载/</id>
    <published>2019-07-16T02:43:13.000Z</published>
    <updated>2019-08-07T02:01:25.918Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol><li>卸载mariadb：<code>yum remove maria*</code></li><li>下载安装包文件：<code>wget http://repo.mysql.com/mysql-community-release-el7-5.noarch.rpm</code></li><li>安装rpm包：<code>rpm -ivh mysql-community-release-el7-5.noarch.rpm</code></li><li>安装mysql：<code>yum install mysql-server</code></li><li>启动 mysql 服务：<code>systemctl start mysqld.service</code><ol><li>重启：<code>systemctl restart mysqld.service</code></li><li>停止：<code>systemctl stop mysqld.service</code></li><li>设置开机启动：<code>systemctl enable mysqld.service</code></li></ol></li><li>设置密码：<ol><li><code>mysql -u root</code></li><li><code>use mysql;</code></li><li><code>update user set password=PASSWORD(&quot;这里输入root用户密码&quot;) where User=&#39;root&#39;;</code></li><li><code>flush privileges;</code></li></ol></li><li>设置root远程主机登录：<code>GRANT ALL PRIVILEGES ON *.* TO root@&quot;%&quot; IDENTIFIED BY &quot;密码&quot;;</code><ol><li><code>GRANT ALL PRIVILEGES ON *.* TO &#39;your username&#39;@&#39;%&#39; IDENTIFIED BY &#39;your password&#39;;</code></li></ol></li><li>设置全局编码集</li></ol><div align="center"><img width="80%" src="//isjinhao.github.io/2019/centos7下mysql5-6安装和卸载/2019-07-16_110314.jpg"></div><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><ol><li>查看MySQL的安装情况：<code>rpm -qa|grep -i mysql</code></li><li>停止服务：<code>service mysql stop</code></li><li>卸载第一步查询出来的所有结果：<code>rpm -ev 名字 --nodeps</code></li><li>查找mysql之前使用过的目录：<code>find / -name mysql</code></li><li>删除所有mysql之前使用过的所有目录</li><li>删除配置文件：<code>rm -rf /etc/my.cnf</code></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;ol&gt;&lt;li&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="centos7" scheme="https://isjinhao.github.io/tags/centos7/"/>
    
  </entry>
  
  <entry>
    <title>UML基础</title>
    <link href="https://isjinhao.github.io/2019/UML%E5%9F%BA%E7%A1%80/"/>
    <id>https://isjinhao.github.io/2019/UML基础/</id>
    <published>2019-07-03T04:23:18.000Z</published>
    <updated>2019-07-16T03:52:45.199Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --><h2 id="object"><a href="#object" class="headerlink" title="object"></a>object</h2><p>An object is an entity with a well-defined boundary and identity that encapsulates state and behavior.</p><p>State is represented by attributes and relationships.</p><p>Behavior is represented by operations, methods, and state machines.</p><blockquote><p>An Object Has State</p></blockquote><p>The state of an object is one of the possible conditions in which an object may exist.</p><p>The state of an object normally changes over time.</p><blockquote><p>An Object Has Behavior</p></blockquote><p>Behavior determines how an object acts and reacts.</p><p>The visible behavior [bɪ’heɪvjə] of an object is modeled by the set of messages it can respond to (operations the object can perform).</p><blockquote><p>An Object Has Identity</p></blockquote><p>Each object has a unique identity, even if the state is identical to that of another object.</p><h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>A class is a description of a set of objects that share the same properties and behavior. An object is an instance of a class.</p><blockquote><p>The Relationship Between Classes and Objects</p></blockquote><p>A class is an abstract definition of an object. It defines the structure and behavior of each object in the class. It serves as a template for creating objects.</p><p>Objects are grouped into classes.</p><p>An object is an instance of a class.</p><h2 id="What-Is-an-Operation"><a href="#What-Is-an-Operation" class="headerlink" title="What Is an Operation?"></a>What Is an Operation?</h2><p>An operation is the implementation of a service that can be requested from any object of the class to affect behavior.</p><p>A class may have any number of operations or none at all.</p><blockquote><p>Objects Need to Collaborate</p></blockquote><p>Objects are useless unless they can collaborate [kəˈlæbəreɪt] together to solve a problem.</p><ul><li><p>Each object is responsible for its own behavior and status.</p></li><li><p>No one object can carry out every responsibility on its own.</p></li></ul><p>How do objects interact with each other?</p><ul><li>They interact through messages.</li></ul><h2 id="What-is-a-message"><a href="#What-is-a-message" class="headerlink" title="What is a message?"></a>What is a message?</h2><p>A specification of a communication between objects that conveys information with the expectation that activity will ensue(跟着发生)</p><p>One object asks another object to perform an operation.</p><h3 id="What-Is-Abstraction"><a href="#What-Is-Abstraction" class="headerlink" title="What Is Abstraction?"></a>What Is Abstraction?</h3><p>Abstraction can be defined as: Process allowing to focus on most important aspects while ignoring less important details</p><p>Allows us to manage complexity by concentrating on essential aspects making an entity different from others</p><blockquote><p>Abstraction</p></blockquote><p>Emphasizes relevant characteristics.</p><p>Suppresses（抑制） other characteristics.</p><h3 id="What-Is-Encapsulation"><a href="#What-Is-Encapsulation" class="headerlink" title="What Is Encapsulation?"></a>What Is Encapsulation?</h3><p>Encapsulation means to design, produce, and describe software so that it can be easily used without knowing the details of how it works.</p><p>Also known as information hiding</p><p>An analogy:</p><p>When you drive a car, you don’t have know the details of how many cylinders(汽缸) the engine has or how the gasoline and air are mixed and ignited(点火).</p><p>Instead you only have to know how to use the controls.</p><ul><li>Encapsulation allows objects to be viewed as ‘black boxes’</li></ul><ul><li>It protects an object’s internal state from being corrupted by other objects.</li></ul><ul><li>Also, other objects are protected from changes in the object implementation.</li></ul><ul><li>隔离复杂度</li></ul><h3 id="What-Is-Inheritance"><a href="#What-Is-Inheritance" class="headerlink" title="What Is Inheritance ?"></a>What Is Inheritance ?</h3><ul><li>Inheritance [ɪnˈherɪtəns]—a way of organizing classes</li></ul><ul><li>Classes with properties in common can be grouped so that their common properties are only defined once.</li></ul><ul><li>增加了软件重用的机会</li></ul><h3 id="Polymorphism"><a href="#Polymorphism" class="headerlink" title="Polymorphism"></a>Polymorphism</h3><p>Polymorphism—the same word or phrase can be mean different things in different contexts</p><p>Analogy（类比）: in English, bank can mean side of a river or a place to put money</p><p>In Java, two or more classes could each have a method called output</p><p>Each output method would do the right thing for the class that it was in.</p><ul><li>One output might display a number where as a different one might display a name.</li></ul><p>What Is Polymorphism?</p><ul><li>消息发送方不需要知道消息接收方属于那个子类</li><li>同一类族的接收者可以按自己的方式处理消息</li><li>同一类族的接收者可以按自己的方式处理同一个消息</li><li>有多种对象可以按自己的方式处理相同的数据</li></ul><h3 id="What-is-an-Interface"><a href="#What-is-an-Interface" class="headerlink" title="What is an Interface?"></a>What is an Interface?</h3><p>An interface is a collection of operations that specify a service of a class or component.</p><p>Interfaces formalize（正式化） polymorphism</p><p>Interfaces support “plug-and-play(即插即用)” architectures</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><blockquote><p>类</p></blockquote><p>定义了对象群体的逻辑结构，包括属性和操作。系统运行时，类作为产生对象的模板，在物理层面是不存在的</p><blockquote><p>对象</p></blockquote><p>系统运行时必须为每一个需要的对象分配内存、保存数据对象存在于物理层面，每个对象都有自己的数据空间。所有的对象共享同一块代码空间</p><p>属性Attribute ==状态state == 信息information</p><p>操作operation == 方法method ==行为behaviour = = 职责responsibility</p><h2 id="Procedural-Programming"><a href="#Procedural-Programming" class="headerlink" title="Procedural Programming"></a>Procedural Programming</h2><p>This programming paradigm（范式） is essentially an abstraction of machine /assembly language.</p><p>Program is organized around procedures.</p><p>Focus on data structures, algorithms and sequencing of steps</p><blockquote><p>Programs = Algorithm + Data Structure</p></blockquote><ul><li><p>An algorithm is a set of instructions for solving a problem</p></li><li><p>A data structure is a construct used to organize data in a specific way.</p></li><li>Most computer languages, from early examples like FORTRAN and ALGOL to more recent languages like C and Ada have been imperative or procedural.</li></ul><h2 id="Object-Oriented-Programming"><a href="#Object-Oriented-Programming" class="headerlink" title="Object-Oriented Programming"></a>Object-Oriented Programming</h2><p>A design and programming technique</p><p>Some terminology:</p><ul><li>object - usually a person, place or thing (a noun)</li><li><p>method - an action performed by an object (a verb)</p></li><li><p>type or class - a category of similar objects (such as automobiles)</p></li></ul><p>Objects have both data and methods</p><p>Objects of the same class have the same data elements and methods</p><p>Objects send and receive messages to invoke actions</p><p>C语言是一种面向过程的思维方式</p><p>程序的运行“一切尽在掌握中”：从main()函数的逐条语句开始执行、调用了子程序就必须一层层返回，最终又返回main函数</p><p>系统需要完成的功能，分配到各个子函数，由main函数统一调度</p><p>比较</p><p>面向过程侧重于考虑方法的编写（哪个方法做什么事，不考虑所涉及的数据在哪里）</p><p>面向对象则致力于将数据和方法先做一个封装（分配一个对象做事，先考虑所需要的数据是否和它在一起）</p><h2 id="What-is-modeling"><a href="#What-is-modeling" class="headerlink" title="What is modeling?"></a>What is modeling?</h2><p>A model is an abstraction of things.</p><p>Emphasizes relevant characteristics.</p><p>Suppresses other characteristics.</p><blockquote><p>建模目的</p></blockquote><p>We build models to better understand the system we are developing.</p><p>Modeling achieves four aims.</p><ul><li><p>模型帮助我们按照实际情况或按照我们所需要的样式对系统进行可视化</p></li><li><p>模型允许我们详细说明系统的结构或行为</p></li><li><p>模型给出了一个指导我们构造系统的模板</p></li><li><p>模型对我们作出的决策进行文档化</p></li></ul><p>We build models of complex systems because we cannot comprehend such a system in its entirety.</p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>Unified Modeling Language 统一建模语言</p><ol><li>作用：建立软件模型，可以用UML对软件密集型系统的制品（artifact：软件开发过程中产生的各种各样的产物）进行可视化、详述、构造和文档化。</li><li>建模语言：提供统一的交流词汇和规则</li><li>可视化: 通过标准图符构成图形来描述模型</li><li>通用标准: 成为软件建模的标准语言,并且在其他领域也得到应用。</li></ol><h3 id="UML的构成"><a href="#UML的构成" class="headerlink" title="UML的构成"></a>UML的构成</h3><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_215443.jpg"></div><h2 id="Building-Blocks-of-the-UML"><a href="#Building-Blocks-of-the-UML" class="headerlink" title="Building Blocks of the UML"></a>Building Blocks of the UML</h2><p>The vocabulary of the UML encompasses three kinds of building blocks:</p><ul><li><p>Things: the abstractions that are first-class citizens in a model;</p></li><li><p>Relationships: relationships tie these things together;</p></li><li><p>Diagrams: diagrams group interesting collections of things.</p></li></ul><h3 id="Things-in-the-UML"><a href="#Things-in-the-UML" class="headerlink" title="Things in the UML"></a>Things in the UML</h3><p>There are four kinds of things in the UML:</p><ul><li><p>Structural things: class, interface, collaboration, use case, active class, component, node</p></li><li><p>Behavioral things: interaction, state machine, activity</p></li><li><p>Grouping things: package</p></li><li><p>Annotational(注释) things: note</p></li></ul><p>These things are the basic object-oriented building blocks of the UML.</p><h4 id="Structural-things-in-the-UML"><a href="#Structural-things-in-the-UML" class="headerlink" title="Structural things in the UML"></a>Structural things in the UML</h4><p>the nouns of UML models.</p><p>the mostly static parts of a model, either conceptual or physical</p><p>Collectively, the structural things are called classifiers</p><h5 id="Structural-things-Class"><a href="#Structural-things-Class" class="headerlink" title="Structural things - Class"></a>Structural things - Class</h5><p>A class is a description of a set of objects that share the same attributes, operations, relationships, and semantics(语义).</p><p>A class is represented using a compartmented(间隔间) rectangle</p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_193200.jpg"></div><br>A class is comprised of three sections<br><br>- The first section contains the class name<br><br>- The second section shows the structure (attributes)<br><br>- The third section shows the behavior (operations)<br><br><br><br>Representing Objects<br><br>An object is represented as rectangles with underlined names<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_194100.jpg"></div><br>##### Structural things - Interface<br><br>An interface is a collection of operations that specify a service of a class or component.<br><br>Interfaces support “plug-and-play” architectures<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_194156.jpg"></div><br>##### Structural things – Use Case<br><br>a use case is a description of set of sequence of actions that a system performs that yields an observable result of value to a particular actor.<br><br>A use case is used to structure(组织) the behavioral things in a model.<br><br>A use case is realized by a collaboration.<br><br>Graphically, a use case is rendered as an ellipse [ɪˈlɪps] with solid lines, usually including only its name.<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_195115.jpg"></div><br>##### Structural things - Collaboration<br><br>In the context of a system‘s architecture, a collaboration allows you to name a conceptual chunk(大块) that encompasses both static and dynamic aspects.<br><br>A collaboration names a society of classes, interfaces, and other elements that work together to provide some cooperative [kəʊ’ɒpərətɪv] behavior that’s bigger than the sum of all its parts.<br><br>You use collaborations to specify the realization of use cases and operations, and to model the architecturally significant mechanisms of your system.<br><br>A collaboration is also the specification of how an element, such as a classifier (including a class, interface, component, node, or use case) or an operation, is realized by a set of classifiers and associations playing specific roles used in a specific way.<br><br>Graphically, a collaboration is rendered as an ellipse(椭圆) with dashed lines.<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_195950.jpg"></div><br>##### Structural things – Active Class<br><br>an active class is a class whose objects own one or more processes or threads and therefore can initiate control activity.<br><br>Graphically, an active class is rendered as a class with double lines on the left and right; it usually includes its name, attributes, and operations.<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_200116.jpg"></div><br>##### Structural things – Component<br><br>A component is a modular part of the system design that hides its implementation behind a set of external interfaces.<br><br>系统中遵从一组接口且提供其实现的物理的、可替换的部分。<br><br>构件是物理抽象，可以替换的文件。类是逻辑抽象，包含属性和方法。逻辑抽象出来的东西用文件写出来，这些源文件就是构件。<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_200209.jpg"></div><br>eg：<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_200247.jpg"></div><br>##### Structural things – Node<br><br>a node is a physical element that exists at run time and represents a computational resource, generally having at least some memory and, often, processing capability.<br><br>A set of components may reside（安置、居住） on a node and may also migrate from node to node.<br><br>Graphically, a node is rendered as a cube, usually including only its name.<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_200516.jpg"></div><br>#### Behavioral things in the UML<br><br>the verbs of UML models.<br><br>the mostly dynamic parts of a model<br><br>three primary kinds<br><br>- Among a set of objects: interaction<br><br>- For an object: state machine<br><br>- The sequence of steps: activity<br><br><br><br>##### Behavioral things - Interaction<br><br>an interaction is a behavior that comprises（包括） a set of messages exchanged among a set of objects within a particular context to accomplish a specific purpose.<br><br>An interaction involves（包含、涉及） a number of other elements, including messages, action sequences (the behavior invoked by a message), and links (the connection between objects).<br><br>Graphically, a message is rendered as a directed line, almost always including the name of its operation.<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_201810.jpg"></div><br>&gt; What Is an Interaction Diagram?<br><br>An interaction diagram shows an interaction, consisting of a set of objects and their relationships, including the messages that may be dispatched（派遣，分发） among them.<br><br>It models the dynamic aspects of a system.<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_203358.jpg"></div><br>&gt; What Is a Sequence Diagram?<br><br>A sequence diagram is an interaction diagram that emphasizes the time ordering of messages.<br><br>The diagram shows<br><br>- The objects participating in the interaction.<br><br>- The sequence of messages exchanged.<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_203528.jpg"></div><br>&gt; What Is a Communication Diagram?<br><br>A communication diagram emphasizes the organization of the objects that participate in an interaction.<br><br>The communication diagram shows<br><br>- The objects participating in the interaction.<br><br>- Links( physical or conceptual connection among objects) between the objects.<br><br>- Messages passed between the objects.<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_203846.jpg"></div><br>##### Behavioral things - State machine<br><br>a state machine is a behavior that specifies the sequences of states an object or an interaction goes through during its lifetime in response to events, together with its responses to those events.<br><br>A state machine involves a number of other elements, including states, transitions, events, and activities.<br><br>Graphically, a state is rendered as a rounded rectangle, usually including its name and its substates（子状态）, if any（如果有）.<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_210300.jpg"></div><br><div align="center"><img width="70%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_211131.jpg"></div><br>Behavioral things - Activity<br><br>an activity is a behavior that specifies the sequence of steps a computational process performs<br><br>In an activity, the focus is on the flows among steps without regard to which object performs each step.<br><br>A step of an activity is called an action.<br><br>Graphically, an action is rendered as a rounded rectangle with a name indicating its purpose. States and actions are distinguished by their different contexts.<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_211234.jpg"></div><br>#### Grouping things in the UML<br><br>##### Grouping things - Package<br><br>- Grouping things are the organizational parts of UML models.<br><br>- Structural things, behavioral things, and even other grouping things may be placed in a package.<br><br>- Unlike components (which exist at run time), a package is purely conceptual (meaning that it exists only at development time).<br><br>- Graphically, a package is rendered as a tabbed folder, usually including only its name and, sometimes, its contents.<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_212150.jpg"></div><br>#### Annotational things in the UML<br><br>##### Annotational things - Note<br><br>Annotational things are the explanatory(解释性的) parts of UML models.<br><br>These are the comments（解释） you may apply to describe, illuminate（阐释）, and remark about any element in a model.<br><br>There is one primary kind of annotational thing, called a note.<br><br>A note is simply a symbol for rendering constraints and comments attached to an element or a collection of elements.<br><br>Graphically, a note is rendered as a rectangle with a dog-eared corner, together with a textual or graphical comment.<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_212634.jpg"></div><br>### Relationships in the UML<br><br>There are four kinds of relationships in the UML:<br><br>- Association<br><br>- Dependency<br><br>- Generalization<br><br>- Realization<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_212938.jpg"></div><br>#### What Is an Association<br><br>The semantic relationship between two or more classes that specifies connections among their instances<br><br>- A structural relationship, specifying that objects of one thing are connected to objects of another<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_214111.jpg"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_214134.jpg"></div><br>#### Relationships: Dependency<br><br>A relationship between two model elements where a change in one may cause a change in the other.<br><br>Non-structural, “using” relationship.<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_214353.jpg"></div><br>#### Relationships: Generalization<br><br>A relationship among classes where one class shares the structure and/or behavior of one or more classes<br><br>Defines a hierarchy of abstractions in which a subclass inherits from one or more superclasses<br><br>- Single inheritance<br><br>- Multiple inheritance<br><br>an “is-a-kind of” relationship<br><br><br><br>#### Relationships: Realization<br><br>One classifier serves as the contract that the other classifier agrees to carry out<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_214942.jpg"></div><br>### Diagrams in the UML<br><br>The UML1.x includes nine such diagrams:<br><br>- Use-case diagrams: to illustrate requirement.<br><br>- Class diagrams: to illustrate logical structure.<br><br>- Object diagrams: to illustrate objects and links.<br><br>- State diagrams: to illustrate behavior.<br><br>- Component diagrams: to illustrate physical structure of the software.<br><br>- Deployment diagrams: to show the mapping of software to hardware configurations.<br><br>- Interaction diagrams (i.e., collaboration and sequence diagrams): to illustrate behavior.<br><br>- Activity diagrams: to illustrate the flow of events in a use-case.<br><br>A diagram is a view into a model<br><br>A model is a complete description of a system from a particular perspective<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_215343.jpg"></div><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_215420.jpg"></div><br>## 规则<br><br>命名<br><br>规定对要素(事物)、关系、图命名。例如：student为一个类的名字<br><br>范围<br><br>UML成员所定义的内容起作用的上下文环境。<br><br>可视性<br><br>UML成员能被其他成员引用的方式。三种：<br><br>- public（+）：公共<br>- protected（#）：保护<br>- private（-）：私有<br><br>完整性<br><br>保证事物正确、一致地相互联系。<br><br>执行<br><br>运行或模拟动态模型的含义是什么<br><br><br><br>## UML的公共机制<br><br>UML的公共机制有：<br><br>- 规范说明<br><br>- 修饰<br><br>- 通用划分<br><br>- 扩展机制<br><br>### 规格说明，pecification<br><br>UML对每一个元素都有确定的图形表示符号，但对该图形符号还有语法、语义的文字说明。例如，Actor：参与者，UML表示为：<br><br><div align="center"><img width="15%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_220719.jpg"></div><br>### 修饰，adornment<br><br>图形符号表示一个元素的主要特征，此外，可以加上修饰，表示该元素的其它特征。例如：矩形框表示一个类，有类名，属性，操作等。但也可增加“可视性” 等修饰。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_220809.jpg"></div><br>### 通用划分（common division）<br><br>一种保证不同抽象概念层次的机制。有两种通用划分的形式：<br><br>抽象-实例：例如，类-对象，用例-具体用例<br><br>接口-实现：接口表示约定，实现表示对约定的实施<br><br><br><br>## Extension mechanism of the UML<br><br>- Stereotype<br><br>- Tagged value<br><br>- Constraint<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_221407.jpg"></div><br>### Extension mechanism - Stereotypes<br><br>A stereotype is an extension of the vocabulary of the UML, allowing you to create new kinds of building blocks similar to existing ones but specific to your problem.<br><br>Stereotypes must be based on certain existing types or classes in the metamodel. Stereotypes may extend the semantics, but not the structure of pre-existing types and classes. Certain stereotypes are predefined in the UML, others may be user defined.<br><br><br><br>### Extension mechanism - Tagged Values<br><br>Many kinds of elements have detailed properties that do not have a visual notation. In addition, users can define new element properties using the tagged value mechanism.<br><br>A tagged value is an extension of the properties of a UML element, allowing you to create new information in that element’s specification.<br><br>A tagged value is a keyword-value pair that may be attached to any kind of model element. The keyword is called a tag.<br><br>Common examples of tagged values are：<br><br>- {Author = (Dave,Ron)}<br><br>- {Version Number = 3}<br><br>- {Location = d:\java\uml\examples}<br><br>- {Location = Node: Middle Tier}<br><br>### Extension mechanism - Constraint<br><br>A constraint is an extension of the semantics of a UML elements, allowing you to add new rules or to modify existing ones.<br><br>Constraints may be written as free-form text. If you want to specify your semantics more precisely, you can use the UML’s Object Constraint Language (OCL).<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_224902.jpg"></div><br>### 小结<br><br>- Modeling Comments - use notes<br>- Modeling New Building Blocks - use stereotype.<br>- Modeling New Properties - use tagged values.<br>- Modeling New Semantics - use constraint<br><br><br><br>## UML的4+1视图<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-01_225144.jpg"></div><br>## UML可以用在系统开发的各个阶段<br><br>- 业务模型：业务用例图，活动图，状态图，实体图；<br>- 需求模型：用例图，活动图，状态图等<br>- 逻辑模型：类图，交互图，活动图，状态图等<br>- 设计模型：类图，交互图，活动图，状态图等<br>- 实现模型：构件图等<br>- 测试模型：用例图，类图，交互图等<br><br><br><br>## 用例<br><br>A sequence of actions a system performs that yields an observable result of value to a particular actor<br><br>UML中用例用椭圆表示，使用动宾结构或主谓结构命名。<br><br>### 用例的特点<br><br>- 用例从使用系统的角度描述系统中的信息，即站在系统外部查看系统功能，不反映功能的实现方式。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_085712.jpg"></div><br>- 用例描述用户提出的一些可见需求，对应一个具体的用户目标。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_085758.jpg"></div><br>- 用例反映系统与用户的一次交互过程，应该具有交互的信息的传递。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_085835.jpg"></div><br>- 用例是对系统行为的描述，属于UML的动态建模部分。<br>- 通过读卡机，储户插入ATM卡<br>- ATM系统从卡上读取银行ID、帐号、并验证帐号。<br>- 储户键入密码，系统检验密码。<br>- 储户按确认键，输入取款金额。<br>- ATM把帐号和取款金额传递给银行系统，取回帐户余额。<br>- ATM输出现金，并显示帐户余额。<br>- ATM记录事务到日志文件。<br><br><br><br>## What Is an Actor<br><br>- Actors are not part of the system.<br>- Actors represent roles a user of the system can play(扮演).<br>- They can represent a human, a machine, or another system.<br>- They can actively interchange（交换） information with the system.<br>- They can be a giver of information.<br>- They can be a passive recipient of information.<br><br>Actors are EXTERNAL.<br><br><br><br>### 参与者<br><br>参与者(actor)是指系统以外的、需要使用系统或与系统交互的事物，包括: 人、设备、外部系统等。其它译名有: 活动者、执行者、行动者等。例，一个银行业务系统中的参与者：<br><br>1. 客户：从系统获取信息并执行金融交易<br>2. 管理人员：创建系统的用户，获取并更新信息<br>3. 厂商：接受作为转账支付结果的资金<br>4. Mail系统：与系统交互，发送或接收邮件<br><br>An actor represents a role that a human, hardware device, or another system can play.<br><br>UML中的Actor实际上是一个版型化的类, 可以有三种表示形式：<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_090821.jpg"></div><br>由于Actor实际上是一个类, 因此它们之间可以存在一定的关系,如：<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_090906.jpg"></div><br>## 脚本<br><br>脚本(scenario)在UML中指贯穿用例的一条单一路径，用来显示用例中的正常和特殊情况。<br><br>系统在某个特定的执行期内所发生的一系列事件。其它译名：情景、场景、情节、剧本。<br><br>每个用例有一系列脚本，包括一个主要脚本，以及几个次要脚本。相对于主要脚本，次要脚本描述了执行路径中的异常或可选择的情况。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_091229.jpg"></div><br>## 用例之间的关系<br><br>用例与参与者之间：关联(association)关系。<br><br>用例之间的关系有：泛化(generalization)、包含(include)、扩展(extend)等。<br><br><br><br>### 关联关系<br><br>参与者与用例之间是关联关系，表示参与者与用例之间具有使用，交互信息的关联。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_091350.jpg"></div><br>### 泛化关系<br><br>泛化关系代表一般与特殊的关系，与继承类似。在泛化关系中，子用例继承了父用例的行为和含义，子用例也可以增加新的行为和含义或覆盖父用例中的行为和含义。<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_091502.jpg"></div><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_091556.jpg"></div><br>### 包含关系<br><br>包含关系是指一个用例（基本用例）的行为包含了另一个用例（包含用例）的行为。包含关系是依赖关系的版型。<br><br><div align="center"><img width="60%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_091722.jpg"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_091744.jpg"></div><br>### 扩展关系<br><br>扩展关系的基本含义与泛化关系类似，但对扩展用例有更多限制, 即基本用例必须声明若干“扩展点”，扩展用例只能在扩展点上增加行为和含义，以扩展到新用例。扩展关系是依赖关系版型。<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_091913.jpg"></div><br>### 关系比较<br><br>- 扩展关系的基本用例是 well formed 的。一个基本用例执行时，可以执行或不执行扩展用例。<br>- 包含关系的基本用例可以不是或是 well formed 的。执行基本用例时，一定会执行包含用例。<br>- 需要重复处理两个或多个用例时吗，可以考虑包含关系。<br>- 处理正常行为的变型且只是偶而描述时，可以考虑只使用泛化关系。<br>- 处理正常行为的变型且希望采用更多控制方式时，可以在基本用例中设置扩展点，使用扩展关系。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_092400.jpg"></div><br>## 用例的描述<br><br>- 用例描述是指对一个用例的功能进行的文字描述，是参与者与系统交互动作序列的说明。<br><br>- 用例描述才是用例的主要部分，是后续的交互图分析和类图分析必不可少的部分。<br><br>- 用例采用自然语言描述参与者与系统的交互行为，要易于理解，其读者是开发人员、用户、项目经理、测试人员等。<br><br>### 错误描述<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_092647.jpg"></div><br>### 正确描述<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_092713.jpg"></div><br>### 用例规约的主要组成<br><br>- 用例名称<br><br>- 用例标识<br><br>- 涉及的参与者<br><br>- 描述<br><br>- 用例的规格说明<br>- 前置条件 PreConditions<br>- 后置条件 PostConditions<br>- 正常事件流 Flow of events<br>- 备选事件流 Alternate flow<br><br>- 其它<br>- 非功能需求、设计约束、尚存在的问题<br><br>#### 前置、后置条件-1<br><br>- 前置条件约束在用例开始前系统的状态<br>- 把它们看做是看门人，它阻止参与者触发该用例直到满足所有条件<br>- 说明在用例触发之前什么必须为真<br><br>- 后置条件约束用例执行后系统的状态<br>- 用例执行后什么必须为真<br>- 对于有多个事件流的用例，则应该有多个后置条件<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_092919.jpg"></div><br>#### 事件流描述要点<br><br>- 只书写“可观测”的语句、<br>- 系统通过ADO建立数据库连接，传送SQL查询语句，从“商品表”查询商品的详细信息……<br>- 系统按照查询条件搜索商品的详细信息<br><br>- 使用主动语句<br><br>- 句子必须以参与者或系统作为主语<br>- 出纳员接收顾客的付款—顾客的付款数可能高于商品总额<br>- 出纳员录入顾客所付的现金总额<br>- 系统显示出应找还给顾客的余额，打印付款收据<br><br>- 不要涉及界面细节<br>- 会员从下拉框中选择类别<br>- 会员在相应文本框中输入查询条件<br>- 会员点击“确定”按钮<br><br>- 分支和循环<br>- 分支：参与者的选择<br>- 分支：另一条成功线路<br>- 分支：系统进行验证<br>- 循环：直接描述<br><br><br><br>## 寻找用例的方法<br><br>- start with actors, then identify what they want to do What functions will the actor want from the system<br><br>- 系统是否存储和检索信息<br><br>- Are any actors notified when the system changes ?<br><br>- Are there external events that notify the system ?<br><br>- 哪个参与者触发了活动？Which actors trigger activity ?<br><br><br><br>## 用例的常见问题分析<br><br>### 用例的粒度问题<br><br>对于一个目标系统进行用例分析后得到的用例数目有多少比较合适?<br><br>- 用例要有路径，路径要有步骤；而这一切都是可观测的<br><br>- 最常犯错误：粒度过细，陷入功能分解。过细的粒度，一般都会导致技术语言的描述，而不再是业务语言。如把步骤当用例，或者把系统活动当用例。<br><br><div align="center"><img width="60%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_093727.jpg"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_093745.jpg"></div><br>## 用例模型<br><br>- 用例模型包括：<br>- 系统边界<br>- 参与者<br>- 用例<br>- 用例图<br>- 用例描述<br><br>- 是面向对象设计的输入<br><br>- 是开发部门与顾客之间的合同<br><br>- 是软件设计部门与软件工程师之间的合同<br><br>- 是开发部门领导、非直接开发人员，了解系统的主要信息来源<br><br><br><br>## 交互图的概念<br><br>- 交互图(interaction)：用来描述对象之间及对象与参与者之间的动态协作关系，以及协作过程中行为次序的图形文档。<br>- 交互图的类型：顺序图，协作图<br><br>- 交互图的作用：用于描述用例的行为，显示该用例中所涉及的对象和这些对象之间的消息传递情况。<br><br><br><br>## 顺序图的概念<br><br>顺序图(sequence diagram)：用来描述为了完成确定事务，对象之间按照时间进行消息交互的顺序关系。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_094251.jpg"></div><br>### 对象及命名<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_094336.jpg"></div><br>### 生命线<br><br>表示对象存在的时间，对象下面一条虚线表示。<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_094401.jpg"></div><br>### 控制焦点(Focus of Control, FOC)<br><br>小矩形，表示这个时间段内对象将执行操作。<br><br><div align="center"><img width="60%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_094437.jpg"></div><br>#### 激活期<br><br>- 休眠的对象收到一个消息时，开始活动，称为激活<br>- 激活的对象要么执行自己的代码，要么在等待另一个对象的返回<br>- 激活期外，对象处在休眠期，什么事都不做，但它仍然存在，等待消息的激活<br><br><br><br>### 消息<br><br>带箭头的连线，表示对象之间传输的信息。<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_094556.jpg"></div><br>#### 消息解释<br><br>对象之间传输的信息。消息有以下类型：<br><br>##### 调用消息（procedure call）<br><br>- 调用消息(也称为同步消息)的发送者把控制传递给接收者，然后停止活动，等到消息接收者放弃或返回控制。<br><br>- 调用消息必有一个与之配对的返回消息, 但是可以不用画出.<br><br><div align="center"><img width="60%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_094856.jpg"></div><br>#### 异步消息<br><br>异步消息的发送者通过消息把信号传递给接收者，然后继续自己活动，不等待接收者返回消息或控制。<br><br><div align="center"><img width="60%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_095200.jpg"></div><br>#### 返回消息<br><br>返回消息表示从过程调用返回。如果是从过程调用返回，则返回消息是隐含的，可以不画出来。对于非过程调用，如果有返回消息，必须画出来。<br><br><div align="center"><img width="60%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_095140.jpg"></div><br>#### 消息的语法格式<br><br>- display (x,y) 简单消息<br><br>- p:= find (specs) 嵌套消息，消息带返回值、<br><br>- [x&lt;0]5: invert (x,color) 条件消息<br><br>- [i:=1..n]: update() 循环消息<br><br><br><br>### 建立顺序图<br><br>1. 从用例中识别交互过程;<br>2. 识别参与交互过程的对象;<br>3. 为每一个对象设置生命线,并确定对象的存在期限;哪些对象存在于整个交互过程，哪些对象在交互过程中被创建和销毁。<br>4. 从引发交互的初始消息开始,在对象生命线上依次画出交互的消息;<br><br><br><br>### Use Case：Register New Member<br><br>1. The customer fills out an application form containing the customer’s name, address and phone number and gives this to the clerk.<br>2. The clerk issues a request to add a new member.<br>3. The system asks for data about the new member.<br>4. The clerk enters the data into the system.<br>5. Reads in data, and if the member can be added, generates an identification number for the member and remembers information about the member. Informs the clerk if the member was added and outputs the member’s name, address, phone and id.<br>6. The clerk gives the user his identification number.<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_095537.jpg"></div><br>### Use Case：Adding New Book<br><br>1. The library receives a shipment of books from the publisher<br>2. The clerk issues a request to add a new book.<br>3. The system asks for the identifier, title, and author name of the book.<br>4. The clerk generates the unique identifier, enters the identifier, title, and author name of a book.<br>5. The system attempts to enter the information in the catalog and informs the clerk about the result. It then asks if the clerk wants to enter information about another book.<br>6. The clerk answers in the affirmative or in the negative.<br>7. If the answer is in the affirmative, the system goes to Step 3. Otherwise, it exits.<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_095715.jpg"></div><br>## 用例：借书<br><br>- 参与者：图书管理员<br>- 事件流：<br>1. 管理员进入图书借阅界面，用例开始。<br>2. 管理员输入借书证上的读者编号。<br>3. 系统检验借书证合法性吗，如果正确,则显示借阅者(姓名、学院、年级等信息)及其以前所借图书的信息。<br>- A1：借书证编码有错。<br>- A2: 如果该借阅者所借图书已经超期，则提示，本次拒借。<br><br>4. 管理员输入图书条码。<br>5. 系统显示所借图书的信息。<br>6. 管理员确认借书，系统保存借书信息（包括时间，读者号，图书编号等）。<br>7. 用例结束。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_095916.jpg"></div><br>## 协作图<br><br>- 协作图的概念：用来描述系统的行为是如何由系统的成分协作实现的图，各对象之间消息联系的结构关系。<br>- 协作图样式和元素：<br><br><div align="center"><img width="60%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_100027.jpg"></div><br>### 建立协作图<br><br>1. 从用例中识别交互过程;<br>2. 识别参与交互过程的对象;<br>3. 确定对象之间的链，以及链上的消息;<br>4. 从引发交互的初始消息开始,将随后每个消息附在相应的链上;<br><br>### 顺序图与协作图的异同<br><br>- 顺序图和协作图都属于交互图,用来描述对象之间的动态关系。<br>- 顺序图强调消息的时间顺序，协作图强调参与交互的对象的组织关系。<br>- 顺序图和协作图在语义上是等价的，两者可以相互转换。<br><br><br><br>#### 写出Class A伪代码<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_102225.jpg"></div><br><div align="center"><img width="60%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_102246.jpg"></div><br>## 图书馆还书处理的交互图<br><br>用例：还书<br><br>参与者：图书管理员<br><br>事件流：<br><br>- 管理员进入图书借阅界面，用例开始。<br>- 系统要求输入读者编号及所还图书的条码。管理员输入相应信息。<br>- 系统显示所还图书的图书、读者信息、借书记录信息。<br>- 图书管理员确认还书（登记还书时间）。<br>- 用例结束。<br><br><br><br>### 识别交互过程<br><br>读者在还书时，先由管理员把借书证上的读者编号及所借图书的图书编号扫描给系统，系统接收到这个信息，则显示这个该读者信息,以及这本书的信息、借书记录信息。<br><br>管理员确认还书,则系统登记还书信息，并返回还书成功信息，还书过程完成。<br><br>### 画图<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_102603.jpg"></div><br>## 类的概念<br><br>类的定义：类(class): 具有相似结构、行为和关系的一组对象。<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_103115.jpg"></div><br>缩略表示：<br><br><div align="center"><img width="70%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_103342.jpg"></div><br>## 类的版型<br><br>### 边界类<br><br>边界类位于系统与外界的交界处,承担系统与外界的信息交互功能。<br><br><div align="center"><img width="70%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_103453.jpg"></div><br>边界类处在用例图中，参与者与用例的关联处，可以根据用例图发现边界类。<br><br><br><br>### 实体类<br><br>实体类对应着现实中的客观实物，用来保存信息，一般对应着数据表、文件等。实体类可以从现实中存在的客观事物，以及需要持久存放的信息两方面来发现。<br><br><div align="center"><img width="70%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_103611.jpg"></div><br>### 控制类<br><br>控制类负责其他类工作的类，控制调控的作用。一个用例中最少会有一个控制类，用来控制用例中的事件顺序，也可以在多个用例之间共用。控制类较少接收消息，发出较多(控制)消息。<br><br><div align="center"><img width="70%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_103656.jpg"></div><br>## 类之间的关系<br><br>### 关联<br><br>模型元素之间的一种语义联系,它是对具有共同的结构特性、行为特性、关系和语义的链接（link，对象之间物理上或概念上的连接）的描述。<br><br>关联可以分为单向关联，双向关联。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_104022.jpg"></div><br>#### 关联的特性<br><br>- 关联名：用来描述关联的作用。<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_104114.jpg"></div><br>- 关联的角色：关联的两端可以以某种角色参与关联。<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_104149.jpg"></div><br>- 关联的多重性：表示可以有多少个对象参与该关联。<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_104228.jpg"></div><br>- 关联类：通过关联类描述关联的属性，操作，及其它信息。<br>- 增加关联类的准则<br>- 有某个属性与关联相关<br>- 关联类的实例具有依赖于关联的生命期<br>- 两个概念之间有多对多关联，并且存在与关联自身相关的信息<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_104321.jpg"></div><br>- ##### 关联的约束<br><br>通过约束加强关联的含义。例如，“帐户”不能同时与“人”和“公司”有关联。<br><br><div align="center"><img width="70%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_104548.jpg"></div><br>- 限定关联<br><br>通过限定符(qualifier)来规定关联的限定关系。<br><br><div align="center"><img width="70%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_104906.jpg"></div><br>#### 关联的种类<br><br>- 一元(自返)关联<br><br><div align="center"><img width="30%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_104955.jpg"></div><br>- 二元关联<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_105018.jpg"></div><br>- 三元关联<br><br>三元关联是功能齐全的关联，可以有关联类。<br><br><div align="center"><img width="70%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_110554.jpg"></div><br>- 多元关联<br><br>编程语言不能表示多元关联，需要提升为一个类<br><br><div align="center"><img width="70%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_110629.jpg"></div><br>### 聚集和组合<br><br>#### 聚集<br><br>聚集(aggregation): 表示类之间一种松散的整体与部分的组成关系，是一种特殊的关联。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_110945.jpg"></div><br>#### 组合<br><br>组合(composition)：表示类之间一种紧密的整体与部分的组成关系，也是一种特殊的关联。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_111035.jpg"></div><br>#### 聚集与组合的区别<br><br>- 聚集松散，组合紧密<br><br>- 一个部分事物对象可以属于多个聚集对象,但一个部分事物对象仅能属于一个组合对象<br><br>- 聚集的对象生命周期可以不同,但组合对象则是同存同亡。<br><br><br><br>### 泛化<br><br>泛化(generalization)：表示事物之间的一般与特殊的关系；也可以称为继承关系。泛化关系除了表示类与类之间的关系之外，还可以表示参与者、用例、包、构件、接口等建模元素之间的关系。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_113645.jpg"></div><br>### 依赖<br><br>依赖(dependency): 表示两个元素X、Y，如果X的变化必然导致Y的变化，则称Y依赖X。依赖关系不仅限于类，用例、包、构件之间都可以存在依赖关系。 如果类A和类B有关联关系，那么就有依赖关系。只表示出关联关系，不用表示出依赖关系。依赖关系本身不生成专门的实现代码。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_113817.jpg"></div><br>### 派生属性和派生关联<br><br>派生属性和派生关联的概念：可以从其它属性或关联计算推演得到的属性和关联。在派生的名字前面加/，以示区别。派生容易产生不一致，应注意。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_114154.jpg"></div><br>#### 抽象类和接口<br><br>抽象类：只有声明，没有具体实现，不能实例化；<br><br><div align="center"><img width="30%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_114235.jpg"></div><br>接口：不包含属性，只有方法声明<br><br><div align="center"><img width="60%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_114258.jpg"></div><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_114344.jpg"></div><br>## 类图<br><br>类图(Class Diagram): 是由类，相关建模元素（接口、包），及其关系构成的图，用来描述类之间的静态关系。类图在系统中处在核心位置。也是UML中最为重要的一种图。<br><br>售票系统的类图：顾客可多次订票，但每一次订票只能由一个顾客来执行。有两种订票方式：个人票或套票；前者只是一张票，后者包括多张票。每一张票不是个人票就是套票中的一张，但是不能又是个人票又是套票中的一张。每场演出都有多张票可供预定，每张票对应一个唯一的座位号。每次演出用剧目名、日期和时间来标识。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_114448.jpg"></div><br>### 类图的抽象层次<br><br>在系统的不同开发阶段，类图可以具有不同的抽象程度。随着开发的深入，类图应该越来越详细、具体。可以分为：概念层，说明层，实现层。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_114643.jpg"></div><br>### 构造类图<br><br>#### 寻找类的方法<br><br>- 根据用例描述中的名词确定候选类。<br><br>- 根据边界类、控制类和实体类的划分来帮助发现类。<br><br>- 参考设计模式来确定类。<br><br>- 根据软件开发过程的指导寻找类。<br><br><br><br>#### 构造类图时注意<br><br>- 不要试图使用所有的符号，20％的建模元素能满足80％的建模需求。<br><br>- 不要过早陷入细节, 根据不同阶段，采用不同层次类图，逐步细化。<br><br>- 构造完成要将模型与目标问题对照验证其是否合理，是否反应了应用领域的实际情况。<br><br><br><br>## 对象图<br><br>&gt; 对象图的概念<br><br>对象图表示一组对象及其它们之间的联系。对象是系统的详细状态在某一时刻的快照，通常用来表示复杂类图的一个实例。<br><br>&gt; 说明<br><br>- 对象图并不在任何时间都是必须的；<br>- Rose2003不支持对象图。<br><br><br><br>## 类的关系具有四种<br><br>- 关联：表示类中对象之间的链接关系<br><br>- 组成：表示事物之间的整体和部分关系，（聚合，组合）<br><br>- 泛化：表示事物的一般和特殊关系<br><br>- 依赖：事物之间的因果关系<br><br><br><br>## 状态图<br><br>状态图(state chart diagram)：用来描述一个特定的对象所有可能的状态，以及由于各种事件的发生而引起的状态之间的转移和变化。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_134436.jpg"></div><br>## 状态图的要素—–状态<br><br>### 概念<br><br>是指对象在其生命周期中，满足某些条件、执行某些活动、或等待某些事件时的一个状况（时间段）。<br><br>### 状态的表示和要素<br><br>- 状态的表示：用圆角的矩形框表示状态。<br><br>- 状态的要素：包括状态名，进入/退出动作、内部转移，子状态等。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_135250.jpg"></div><br>eg:<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_135323.jpg"></div><br>### 状态的类型<br><br>初态、终态、中间状态、组合状态、历史状态等。一个状态图只能有一个初态，但是结束状态可能有多个，也可以没有终态。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_135637.jpg"></div><br>#### 组合状态和子状态<br><br>嵌套在另一个状态中的状态称为子状态;包含子状态的状态称为组合状态.<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_135809.jpg"></div><br>#### 历史状态<br><br>历史状态是伪状态, 其目的是记住从组合状态中退出时所处的子状态, 当再次进入组合状态时, 可以直接进入这个子状态, 而不是再从组合状态的初态开始.<br><br>- 浅(shallow)历史状态，只记住最外层组合状态的历史<br><br><div align="center"><img width="5%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_140333.jpg"></div><br>- 深(deep)历史状态, 可以记住任意深度的组合状态的历史.<br><br><div align="center"><img width="5%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_140411.jpg"></div><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_140508.jpg"></div><br>## 状态图的要素—–转移<br><br>转移(transition): 是一个状态向另外一个状态的转换（瞬时变化）。转移是两种状态之间的一种关系，表示对象将在第一个状态执行一定的动作，并在某个特定事件发生且满足某个特定的警戒条件时进入第二个状态。<br><br>转移的格式：<code>event-name [‘(‘parameters’)’] [‘[’guard-condition’]’] [’/’action]</code><br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_141428.jpg"></div><br>对于一个给定的状态，最终只能产生一个转移，因此从一个状态出发的几个转移之间应该是互斥的，包括：事件不同；事件相同但警戒条件互斥。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_141724.jpg"></div><br>## 状态图的要素—–事 件<br><br>### 概念<br><br>事件(event)：是指在确定的时间和位置所发生的对于对象起作用的事情。事件的发生将引起一些动作，使对象发生状态的转移。<br><br>动作（action）：动作是对象类中一个操作的执行，动作具有原子性和不可中断特性。<br><br>### 描述<br><br>事件名称[参数表]<br><br>- 字符串，常为接收对象类中的一个操作。<br>- 事件的形式参数，可以省略<br><br>### 事件的类型<br><br>- 调用事件(call event)：是表示对操作的调用<br><br><div align="center"><img width="70%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_142010.jpg"></div><br>- 变化事件(change event)：因满足某种条件（参量变化）而引起的事件，变化条件用when表示。(由满足布尔表达式而引起的事件，不断测试表达式，直到表达式为真)<br><br><div align="center"><img width="70%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_142141.jpg"></div><br>- 时间事件：满足某一时间表达式而引起的事件,时间事件用after,when表示。<br><br><div align="center"><img width="70%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_142232.jpg"></div><br>## 状态图的作用<br><br>用来描述一个对象在其生命周期中所表现出来的状态和行为。当在系统建模过程中需要描述某个事物或对象的不同状态，以及状态之间转移的事件和动作时，用状态图。 但状态图并不是对每一个对象都需要的。<br><br><br><br>## 如何绘制状态图<br><br>1. 选择对象与视点<br>2. 寻找主要的状态<br>3. 确定状态之间的转移（换）<br>4. 细化状态内的活动与转换<br>5. 用组合状态来展开细节<br><br><br><br>## 活动图<br><br>活动图(activity diagram)是UML的动态视图之一，用来描述系统的工作流程和并发行为。活动图是状态图的一个变体，活动图中一个活动结束后将立即进入下一个活动（不需要事件的触发）。<br><br><br><br>### 使用活动图<br><br>- 活动图的用途是对人类组织的现实世界中的工作流程建模。<br>- 也可以对具体操作建模，用于描述计算过程的细节。<br>- 活动图有助于理解系统高层活动的执行行为，而不涉及建立交互图所必须的消息传送细节。<br>- 软件公司可以用活动图对一个软件的开发过程建模；<br>- 会计师事务所可以用活动图对任意数目的财务往来进行建模；<br>- 贸易公司可以用活动图对订单批准过程进行建模；<br>- 科研人员还可以对诸如求Fibonacci数列第n个数的数值之类的操作进行建模。<br><br><br><br>## 活动图的要素<br><br>### 活动<br><br>是活动图主要结点,用两边为弧的条形框表示,中间填活动名 。<br><br><div align="center"><img width="40%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_164527.jpg"></div><br>### 活动流（控制流）<br><br>描述活动之间的有向关系，反映一个活动向另外一个活动之间的转移。用带箭头的实线表示。<br><br><div align="center"><img width="60%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_164613.jpg"></div><br>### 分支<br><br>表示从一个活动按照某种条件转移到几个不同的活动。<br><br><div align="center"><img width="60%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_164818.jpg"></div><br>### 分叉和汇合<br><br>表示并发的同步行为，用同步杆表示。分叉表示一个控制流被多个控制流替代，替代后的控制流是并发的。汇合与分叉含义相反。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_164858.jpg"></div><br>### 泳道<br><br>是活动图中的区域划分，每一个泳道代表一个责任区域。一个泳道中包括一组相关活动。<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_164947.jpg"></div><br>### 对象流<br><br>反映活动与对象之间的依赖关系，表示对象对活动的作用或活动对对象的影响，用依赖关系表示。<br><br><div align="center"><img width="90%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_165504.jpg"></div><br>## 活动图的用途<br><br>活动图具有广泛地用途,在软件建模中,活动图可以用来：<br><br>- 描述工作流：也被称为业务流程，通常对于涉及众多参与者的非常复杂的业务流程建模，简单的业务流程，用例文本就够用了。总之，分析理解用例。<br><br>- 用户下订单后，填写收货信息，选择支付方式，如果用户想要取消订单或订单超过了时限则该订单取消，否则系统处理付款，生成送货单，然后由供应商发货，修改订单项状态，然后等所有的订单项全都送货完毕，这样一笔订单就完成了。<br><br>-<div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_170020.jpg"></div><ul><li>描述算法流程</li></ul><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_170414.jpg"></div><p></p><h2 id="例"><a href="#例" class="headerlink" title="例"></a>例</h2><p>绘制一张活动图，描述登录电子邮件系统的细节。</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_170854.jpg"></div><p></p><h2 id="状态图与活动图的比较"><a href="#状态图与活动图的比较" class="headerlink" title="状态图与活动图的比较"></a>状态图与活动图的比较</h2><ul><li>都是对系统的动态行为建模</li><li>描述对象不同<ul><li>状态图：描述对象状态及状态之间的转移；</li><li>活动图：描述从活动到活动的控制流。</li></ul></li><li>使用场合不同<ul><li>状态图：描述对象在其生命期中的行为状态变化；状态图中的动作和事件对应类模型中对象上的操作。</li><li>活动图：描述工作流程的过程变化。分析用例、理解涉及多个用例的工作流程等。</li></ul></li></ul><h2 id="OOAD"><a href="#OOAD" class="headerlink" title="OOAD"></a>OOAD</h2><h3 id="What-is-Analysis"><a href="#What-is-Analysis" class="headerlink" title="What is Analysis ?"></a>What is Analysis ?</h3><p>Analysis is investigation of the problem and requirements, rather than a solution.</p><ul><li>For example, if a new online trading system is desired,<ul><li>how will it be used? What are its functions?</li></ul></li><li>requirements analysis ：an investigation of the requirements</li></ul><h3 id="What-is-design"><a href="#What-is-design" class="headerlink" title="What is design?"></a>What is design?</h3><p>Design is a conceptual solution that fulfills the requirements 概念性的、满足 需求的解决方案</p><blockquote><p>Design is a conceptual solution that fulfills the requirements。</p></blockquote><h3 id="What-is-OOA"><a href="#What-is-OOA" class="headerlink" title="What is OOA"></a>What is OOA</h3><p>finding and describing the objects or concepts in the problem domain</p><h3 id="What-is-OOD"><a href="#What-is-OOD" class="headerlink" title="What is OOD"></a>What is OOD</h3><p>defining software objects and how they collaborate to fulfill the requirements</p><p>For example, Airplane example of object and class discovery</p><blockquote><p>OOA</p></blockquote><p>in the case of the flight information system, some of the concepts include：Plane, Flight, and Pilot.</p><blockquote><p>OOD</p></blockquote><p>a Plane software object may have a tailNumber attribute and a getFlightHistory() method.</p><h2 id="OOAD-Simple-Example"><a href="#OOAD-Simple-Example" class="headerlink" title="OOAD Simple Example"></a>OOAD Simple Example</h2><h3 id="Rudimentary（最基本的过程）-process"><a href="#Rudimentary（最基本的过程）-process" class="headerlink" title="Rudimentary（最基本的过程） process"></a>Rudimentary（最基本的过程） process</h3><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_172815.jpg"></div><p></p><h3 id="Dice-game-example"><a href="#Dice-game-example" class="headerlink" title="Dice game example"></a>Dice game example</h3><h4 id="Step1-Use-Case"><a href="#Step1-Use-Case" class="headerlink" title="Step1: Use Case"></a>Step1: Use Case</h4><ul><li><p>Player is requested to roll the dice.</p></li><li><p>System presents results:</p></li><li><p>If the dice face value totals (&gt;=)seven, player wins; otherwise, player loses</p></li></ul><h4 id="Step2-Domain-Model"><a href="#Step2-Domain-Model" class="headerlink" title="Step2: Domain Model"></a>Step2: Domain Model</h4><ul><li><p>OOA的结果体现在领域模型中，显示重要的领域概念或者对象</p></li><li><p>What is domain model?</p><ul><li>a visual representation of conceptual classes or real-situation(真实) objects in a domain.</li><li>Domain models have also been called conceptual models , domain object models, and analysis object models.</li></ul></li><li><p>有哪些概念类呢？</p></li></ul><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_173655.jpg"></div><p></p><h4 id="Step3-Interactions"><a href="#Step3-Interactions" class="headerlink" title="Step3: Interactions"></a>Step3: Interactions</h4><ul><li>Assignment of responsibilities among objects</li><li>Sequence or Communication diagrams</li></ul><p>在现实里，是Player扔的骰子。在软件设计中，由DiceGame 对 象 扔 骰 子dice (给Dice 对象发送一个消息)。 软件设计需要从真实世界的事物中获取一些灵感、启发，但是，不能完全模仿真实世界。</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_173858.jpg"></div><p></p><h4 id="Step4-Design-Class-Diagrams-DCD"><a href="#Step4-Design-Class-Diagrams-DCD" class="headerlink" title="Step4: Design Class Diagrams (DCD)"></a>Step4: Design Class Diagrams (DCD)</h4><ul><li>Software classes（软件类） with methods according to responsibilities and attributes according to visibility</li></ul><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_174011.jpg"></div><p></p><ul><li><p>the domain model showing real-world classes</p></li><li><p>this diagram shows software classes</p></li></ul><h2 id="Object-Oriented-Analysis"><a href="#Object-Oriented-Analysis" class="headerlink" title="Object Oriented Analysis"></a>Object Oriented Analysis</h2><ul><li><p>Identifying objects 识别对象</p></li><li><p>Organising the objects: 组织对象</p><ul><li>classifying the objects identified, so similar objects can later be defined in the same class.</li></ul></li><li><p>Identifying relationships between objects: 定义对象之间的关系</p><ul><li>this helps to determine inputs and outputs of an object.</li></ul></li><li><p>Defining operations of the objects: 定义对象的操作</p><ul><li><p>the way of processing data within an object.</p></li><li><p>Also known as ‘responsibility assignment’</p></li><li><p>这一步，主要在设计阶段完成</p></li></ul></li><li><p>Defining objects internally: 定义对象内部细节</p><ul><li>information held within the objects.</li></ul></li></ul><h2 id="名词法定义概念"><a href="#名词法定义概念" class="headerlink" title="名词法定义概念"></a>名词法定义概念</h2><h3 id="名词法定义概念类"><a href="#名词法定义概念类" class="headerlink" title="名词法定义概念类"></a>名词法定义概念类</h3><p>The system controls a recycling machine for returnable bottles, cans and crates. The machine can be used by several customers at the same time and each customer can return all three types of item on the same occasion. The system has to check, for each item, what type has been returned.</p><p>The system will register how many items each customer returns and when the customer asks for a receipt, the system will print out what was deposited , the value of the returned items and the total return sum that will be paid to the customer.</p><ul><li>recycling machine</li><li>bottles, cans, and crates</li><li>machine</li><li>customers, customer</li><li>types of item, item, type, returned items</li><li>system</li><li>receipt(收据)</li><li>return sum</li></ul><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_225907.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_225931.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_225948.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230007.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230025.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230045.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230103.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230121.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230137.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230155.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230224.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230506.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230524.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230540.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230604.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230622.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230647.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230707.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_230725.jpg"></div><p></p><h2 id="分析模型法"><a href="#分析模型法" class="headerlink" title="分析模型法"></a>分析模型法</h2><ul><li><p>用于描述系统规格说明</p></li><li><p>一个健壮、稳定的模型，必须与实现环境无关</p></li><li><p>实现环境的任何变化，不会影响到系统的逻辑结构</p></li><li><p>分析模型能够关注到系统的信息、行为、展示（输入/出）等特性</p><p>特性：Behaviour - Information - Presentation</p></li></ul><p>The model is defined in information - behaviour - presentationspace.</p><h2 id="分析模型的语义"><a href="#分析模型的语义" class="headerlink" title="分析模型的语义"></a>分析模型的语义</h2><ul><li><p>An entity object models information that shows the state of a system. This information is often used to record the effects of operations and therefore is related to the behaviors of the system.</p></li><li><p>A boundary/interface object models inputs and outputs and operations that process them.</p></li><li><p>A control object models functionality/operations regarding to validate and decide whether to process and pass information from the interface object to the entity object or the way around.</p></li></ul><h2 id="分析模型的使用"><a href="#分析模型的使用" class="headerlink" title="分析模型的使用"></a>分析模型的使用</h2><h3 id="Identifying-interface-objects"><a href="#Identifying-interface-objects" class="headerlink" title="Identifying interface objects"></a>Identifying interface objects</h3><ul><li>functions directly related to actors</li></ul><h3 id="Identifying-entity-objects"><a href="#Identifying-entity-objects" class="headerlink" title="Identifying entity objects"></a>Identifying entity objects</h3><ul><li>information used in an use case and functions of processing the information</li></ul><h3 id="Identifying-control-objects"><a href="#Identifying-control-objects" class="headerlink" title="Identifying control objects"></a>Identifying control objects</h3><ul><li>functions that link interface objects and entity objects</li></ul><h2 id="1-4-分析模型案例：废品回收机"><a href="#1-4-分析模型案例：废品回收机" class="headerlink" title="1.4 分析模型案例：废品回收机"></a>1.4 分析模型案例：废品回收机</h2><ul><li>Identifying interface objects：Printer Customer Panel</li><li><p>Identifying entity objects</p><ul><li>Crate, Bottle, Can</li><li>Deposit item</li><li>Receipt basis</li></ul></li><li><p>Identifying control objects</p><ul><li>Deposit item receiver</li></ul></li></ul><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_232231.jpg"></div><p></p><h2 id="CRC"><a href="#CRC" class="headerlink" title="CRC"></a>CRC</h2><ul><li><p>Classes (of objects) 类</p></li><li><p>Responsibilities (of the objects in each class) 职责</p></li><li><p>Collaborations (with objects in other classes) 协作</p><ul><li>In UML, these will be examples of “associations”</li></ul></li></ul><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_232438.jpg"></div><p></p><h2 id="Domain-Models"><a href="#Domain-Models" class="headerlink" title="Domain Models"></a>Domain Models</h2><p>A domain model is a representation of real-world conceptual classes</p><ul><li><p>not a representation of software components.</p></li><li><p>not a set of diagrams describing software classes,</p></li><li><p>not software objects with responsibilities.</p></li></ul><p>A domain model is a visual representation of conceptual classes or real-world objects in a domain of interest</p><ul><li>They have also been called conceptual models, domain object models, and analysis object models.</li></ul><h2 id="Domain-Modeling-Guidelines"><a href="#Domain-Modeling-Guidelines" class="headerlink" title="Domain Modeling Guidelines"></a>Domain Modeling Guidelines</h2><ul><li><p>A Common Mistake in Identifying Conceptual Classes</p><ul><li>Perhaps the most common mistake when creating a domain model is to represent something as an attribute when it should have been a concept.</li><li>A rule of thumb (经验法则)to help prevent this mistake is:<ul><li>If we do not think of some conceptual class X as a number or text in the real world, X is probably a conceptual class, not an attribute.</li></ul></li></ul></li><li><p>As an example, should store be an attribute of Sale, or a separate conceptual class Store?</p><ul><li>In the real world, a store is not considered a number or text - the term suggests a legal entity, an organization, and something occupies space. Therefore, Store should be a concept.</li></ul></li><li>As another example, consider the domain of airline reservations. Should destination be an attribute of Flight, or a separate conceptual class Airport?<ul><li>In the real world, a destination airport is not considered a number or text—it is a massive thing that occupies space. Therefore, Airport should be a concept.</li></ul></li></ul><h2 id="What-are-System-Sequence-Diagrams"><a href="#What-are-System-Sequence-Diagrams" class="headerlink" title="What are System Sequence Diagrams?"></a>What are System Sequence Diagrams?</h2><ul><li><p>A system sequence diagram (SSD) is a picture that shows, for a particular scenario of a use case, the events that external actors generate, their order and inter-system （与系统交互）events</p></li><li><p>All systems are treated as a black box; the emphasis of the diagram is events that cross the system boundary from actors to systems</p></li></ul><h3 id="Guideline"><a href="#Guideline" class="headerlink" title="Guideline"></a>Guideline</h3><ul><li><p>Draw an SSD for a main success scenario of each use case, and frequent or complex.</p></li><li><p>alternative scenarios</p></li></ul><h3 id="The-Relationship-between-SSDs-and-Use-Cases"><a href="#The-Relationship-between-SSDs-and-Use-Cases" class="headerlink" title="The Relationship between SSDs and Use Cases?"></a>The Relationship between SSDs and Use Cases?</h3><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_234200.jpg"></div><p></p><h2 id="Why-draw-SSD"><a href="#Why-draw-SSD" class="headerlink" title="Why draw SSD?"></a>Why draw SSD?</h2><ul><li>Basically, a software system reacts to three things:<ul><li>external events from actors (humans or computers),</li><li>timer events,</li><li>faults or exceptions (which are often from external sources).</li></ul></li><li><p>It is useful to know what, precisely, are the external input events— the system events. They are an important part of analyzing system behavior</p></li><li><p>Before proceeding to a detailed design of how a software application will work, it is useful to investigate and define its behavior as a “black box.“</p></li><li><p>System behavior is a description of what a system does, without explaining how it does it.</p><ul><li>One part of that description is a system sequence diagram(SSD)</li><li>Other parts include the use cases and system operation contracts</li></ul></li></ul><h2 id="What-is-Contract-契约"><a href="#What-is-Contract-契约" class="headerlink" title="What is Contract?(契约)"></a>What is Contract?(契约)</h2><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_234758.jpg"></div><p></p><h2 id="Example-enterItem"><a href="#Example-enterItem" class="headerlink" title="Example : enterItem"></a>Example : enterItem</h2><ul><li><p>Operation: enterItem(itemID:ItemID,quantity:integer)</p></li><li><p>Cross References: Process Sale</p></li><li><p>Preconditions: There is a sale underway</p></li><li>Postconditions:<ul><li>A SalesLineItem instance sli was created(instance creation)</li><li>sli was associated with current Sale(association formed)</li><li>sli.quantity became quantity(attribute modification)</li><li>Sli was associated with a ProductDescription, based on itemID match (association formed)</li></ul></li></ul><h2 id="分层架构"><a href="#分层架构" class="headerlink" title="分层架构"></a>分层架构</h2><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-02_235316.jpg"></div><p></p><ul><li><p>可以做到关注分离（separation of concerns），减少耦合和依赖性，增强内聚性</p></li><li><p>封装和分解了相关的复杂性</p></li><li><p>某些层可以被替换（例如UI层）</p></li><li><p>较低层可以被复用</p></li><li><p>通过逻辑划分，有助于团队开发</p></li></ul><h2 id="Designing-Objects-对象设计"><a href="#Designing-Objects-对象设计" class="headerlink" title="Designing Objects(对象设计)"></a>Designing Objects(对象设计)</h2><ul><li><p>Static modeling (Design Class Diagram, Package)</p></li><li><p>Dynamic modeling (Sequence and Communication Diagram)</p><ul><li>Principles of responsibility assignment</li><li>Design Pattern</li></ul></li></ul><h2 id="GRASP"><a href="#GRASP" class="headerlink" title="GRASP"></a>GRASP</h2><p>General Responsibility Assignment software patterns.</p><ul><li><p>Doing responsibilities of an object include:</p><ul><li>doing something itself, such as creating an object or doing a calculation</li><li>initiating action in other objects</li><li>controlling and coordinating activities in other objects</li></ul></li><li><p>Knowing responsibilities of an object include:</p><ul><li>knowing about private encapsulated data</li><li>knowing about related objects</li><li>knowing about things it can derive or calculate</li></ul></li></ul><p>For example</p><ul><li><p>“a Sale is responsible for creating SalesLineItems” (a doing),</p></li><li><p>“a Sale is responsible for knowing its total” (a knowing).</p></li></ul><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-03_000514.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-03_000546.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-03_000608.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-03_000654.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-03_000806.jpg"></div><p></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-03_000830.jpg"></div><p></p><h2 id="GRASP-1"><a href="#GRASP-1" class="headerlink" title="GRASP"></a>GRASP</h2><h3 id="GRASP-Creator"><a href="#GRASP-Creator" class="headerlink" title="GRASP  - Creator"></a>GRASP - Creator</h3><h4 id="Problem"><a href="#Problem" class="headerlink" title="Problem:"></a>Problem:</h4><p>Who creates an A?</p><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><p>Assign class B the responsibility to create an instance of class A if one of these is true (the more the better):</p><ul><li>B “contains” or compositely aggregates A.</li><li>B records A.</li><li>B closely uses A.</li><li>B has the initializing data for A.</li></ul><h3 id="GRASP-Information-Expert"><a href="#GRASP-Information-Expert" class="headerlink" title="GRASP  - Information Expert"></a>GRASP - Information Expert</h3><h3 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem:"></a>Problem:</h3><p>What is a basic principle by which to assign responsibilities to objects?</p><h3 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h3><p>Assign a responsibility to the class that has the information needed to fulfill it.</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/UML基础/2019-07-03_001025.jpg"></div><p></p><h3 id="GRASP-Low-Coupling"><a href="#GRASP-Low-Coupling" class="headerlink" title="GRASP  - Low Coupling"></a>GRASP - Low Coupling</h3><h4 id="Problem-2"><a href="#Problem-2" class="headerlink" title="Problem:"></a>Problem:</h4><p>How to reduce the impact of change?</p><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution"></a>Solution</h4><ul><li><p>Assign responsibilities so that (unnecessary) coupling remains low.</p></li><li><p>Use this principle to evaluate alternatives.</p></li></ul><h4 id="Discussion"><a href="#Discussion" class="headerlink" title="Discussion"></a>Discussion</h4><ul><li><p>What is Coupling ？</p></li><li><p>面向对象语言中，TypeX到TypeY耦合的常见形式？</p></li></ul><h3 id="GRASP-Controller"><a href="#GRASP-Controller" class="headerlink" title="GRASP  - Controller"></a>GRASP - Controller</h3><h3 id="Problem-3"><a href="#Problem-3" class="headerlink" title="Problem:"></a>Problem:</h3><p>What first object beyond the UI layer receives and coordinates (“controls”) a system operation?</p><h3 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution"></a>Solution</h3><p>Assign the responsibility to an object representing one of these choices:</p><ul><li>Represents the overall “system,” a “root object,” a device that the software is running within, or a major subsystem (these are all variations of a facade controller). 外观控制器</li><li>Represents a use case scenario within which the system operation occurs (a use case or session controller)，<usecasename>Handler. 会话控制器</usecasename></li></ul><h3 id="GRASP-High-Cohesion"><a href="#GRASP-High-Cohesion" class="headerlink" title="GRASP  - High Cohesion"></a>GRASP - High Cohesion</h3><h4 id="Problem-4"><a href="#Problem-4" class="headerlink" title="Problem:"></a>Problem:</h4><p>How to keep objects focused, understandable, and manageable, and as a side effect, support Low Coupling?</p><h4 id="Solution-4"><a href="#Solution-4" class="headerlink" title="Solution"></a>Solution</h4><p>Assign responsibilities so that cohesion remains high.</p><p>Use this to evaluate alternatives.</p><h2 id="OO设计的原则"><a href="#OO设计的原则" class="headerlink" title="OO设计的原则"></a>OO设计的原则</h2><ul><li><p>开闭原则(Open/Closed Principle, OCP)</p></li><li><p>Liskov替换原则(Liskov Substitution Principle, LSP)</p></li><li><p>依赖倒置原则(Dependency Inversion Principle, DSP)</p></li><li><p>接口分离原则(Interface Segregation Principle, ISP)</p></li></ul><h2 id="GoF设计模式的分类"><a href="#GoF设计模式的分类" class="headerlink" title="GoF设计模式的分类"></a>GoF设计模式的分类</h2><p>创建型：抽象了创建对象的过程，使得系统不依赖于系统中的对象是如何创建、组合和表示的。例如：Factory method, Singleton.</p><p>结构型：描述如何组合类和对象。例如：Adapter，Façade</p><p>行为型：描述算法和对象间职责的分配。主要考虑对象之间的通信方式。例如：Iterator, Visitor</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:50 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;object&quot;&gt;&lt;a href=&quot;#object&quot; class=&quot;headerlink&quot; title=&quot;object&quot;&gt;&lt;/a&gt;obj
      
    
    </summary>
    
      <category term="UML" scheme="https://isjinhao.github.io/categories/UML/"/>
    
    
      <category term="UML" scheme="https://isjinhao.github.io/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>springboot</title>
    <link href="https://isjinhao.github.io/2019/springboot/"/>
    <id>https://isjinhao.github.io/2019/springboot/</id>
    <published>2019-06-26T00:58:46.000Z</published>
    <updated>2019-07-02T16:24:46.083Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Aug 28 2019 15:56:49 GMT+0800 (GMT+08:00) --&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
      <category term="springboot" scheme="https://isjinhao.github.io/categories/springboot/"/>
    
    
      <category term="springboot" scheme="https://isjinhao.github.io/tags/springboot/"/>
    
  </entry>
  
</feed>
