<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ISJINHAO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://isjinhao.github.io/"/>
  <updated>2019-03-26T12:48:18.540Z</updated>
  <id>https://isjinhao.github.io/</id>
  
  <author>
    <name>ISJINHAO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>10-索引</title>
    <link href="https://isjinhao.github.io/2019/10-%E7%B4%A2%E5%BC%95/"/>
    <id>https://isjinhao.github.io/2019/10-索引/</id>
    <published>2019-03-26T07:29:37.000Z</published>
    <updated>2019-03-26T12:48:18.540Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:34 GMT+0800 (GMT+08:00) --><h2 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h2><p>使用索引是因为索引是查询性能优化最有效的手段。Mysql中的索引分为两种：<code>B+树</code>和<code>Hash表</code>，但是我们在这里只介绍基于<code>B+树</code>的索引。INNODB引擎也只支持<code>B+树</code>索引。</p><p>Mysql的索引是在存储引擎级别设置的。</p><h2 id="索引匹配原则"><a href="#索引匹配原则" class="headerlink" title="索引匹配原则"></a>索引匹配原则</h2><p>假如有如下表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People(</span><br><span class="line">last_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">first_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">dob <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">gender enum(<span class="string">'m'</span>, <span class="string">'f'</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">key</span>(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>对应的<code>B+树</code>如下：</p><div align="center"><img src="/2019/10-索引/举例B树.jpg"></div><p>建立的索引对如下类型的查询有效：</p><h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>和索引中定义的所有列进行匹配，如查找姓名为<code>Cuba Allen</code>，出生于<code>1996-01-01</code>的人。</p><h3 id="匹配最左前缀"><a href="#匹配最左前缀" class="headerlink" title="匹配最左前缀"></a>匹配最左前缀</h3><p>前面提到的索引可用于查找所有姓为<code>Allen</code>的人，即只使用索引的第一列。</p><h3 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h3><p>也可以只匹配某一列的值的开头部分，例如前面提到的索引可用于查找所有以<code>J</code>开头的姓的人。这里使用了索引的第一列。</p><h3 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h3><p>例如前面提到的索引可用于查找姓在<code>Allen</code>和<code>Barrymore</code>之间的人。这里也只用了索引的第一列。</p><h3 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h3><p>前面提到的索引也可用于查找所有姓为<code>Allen</code>，并且名字是<code>K</code>开头的人。</p><h2 id="索引分类和创建"><a href="#索引分类和创建" class="headerlink" title="索引分类和创建"></a>索引分类和创建</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。</p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>索引列中的值必须是唯一的，但是允许为空值，</p><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>是一种特殊的唯一索引，不允许有空值。后面会有介绍，在INNODB中，主键索引是聚簇索引。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="建表时创建"><a href="#建表时创建" class="headerlink" title="建表时创建"></a>建表时创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line">(</span><br><span class="line">    [col_name data_type],</span><br><span class="line">    ...,</span><br><span class="line">[<span class="keyword">UNIQUE</span>] [<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>] [index_name] (col_name[<span class="keyword">length</span>], ...) [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="后期添加"><a href="#后期添加" class="headerlink" title="后期添加"></a>后期添加</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] [<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>] [index_name]</span><br><span class="line">(col_name[<span class="keyword">length</span>], ...) [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>] index_name <span class="keyword">ON</span> table_name</span><br><span class="line">(col_name[<span class="keyword">length</span>], ...) [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p><code>INDEX</code>和<code>KEY</code>具有相同的效果。<code>length</code>是指该列在<code>B+树</code>中的关键字所占的长度。</p><h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇的意思是键值和数据行紧凑地存储在一起，因为无法把数据行放在两个不同的地方，所以一个表只有一个聚簇索引。而主键会被默认添加上聚簇索引，如果没有主键，<code>INNODB</code>会选择一个非空索引来替代，如果没有这样的索引，<code>INNODB</code>会隐式定义一个主键来作为聚簇索引。</p><div align="center"><img src="/2019/10-索引/聚簇索引.jpg"></div><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。又被称为二级索引。INNODB的二级索引其叶子结点上保存的是<code>KEY+PRIMARY COL</code>。</p><h3 id="INNODB索引"><a href="#INNODB索引" class="headerlink" title="INNODB索引"></a>INNODB索引</h3><div align="center"><img src="/2019/10-索引/聚簇索引INNODB.jpg"></div><p>注意：INNODB中主键索引就是聚簇索引。</p><h3 id="MyISAM索引"><a href="#MyISAM索引" class="headerlink" title="MyISAM索引"></a>MyISAM索引</h3><div align="center"><img src="/2019/10-索引/非聚簇索引MYISAM.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:34 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;索引基础&quot;&gt;&lt;a href=&quot;#索引基础&quot; class=&quot;headerlink&quot; title=&quot;索引基础&quot;&gt;&lt;/a&gt;索引基础&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>B树</title>
    <link href="https://isjinhao.github.io/2019/B%E6%A0%91/"/>
    <id>https://isjinhao.github.io/2019/B树/</id>
    <published>2019-03-25T07:39:51.000Z</published>
    <updated>2019-03-26T12:48:26.252Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --><h2 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h2><h3 id="磁盘构造"><a href="#磁盘构造" class="headerlink" title="磁盘构造"></a>磁盘构造</h3><div align="center"><img src="/2019/B树/磁盘.jpg"></div><p>当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头（又叫磁头）下通过，就可以进行数据的读/写了。</p><p>一般磁盘分为固定头盘（磁头固定）和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。</p><p>活动头盘 （如上图）的磁头是可移动的。每一个盘面上只有一个磁头（磁头是双向的，因此正反盘面都能读写）。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的（行动整齐划一）。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。</p><h3 id="访问时间"><a href="#访问时间" class="headerlink" title="访问时间"></a>访问时间</h3><p>典型的磁盘访问时间包括以下三个部分：</p><ol><li>寻道时间$T_s$：$T_s = s$</li><li>旋转延迟时间$T_τ$：$T_t = \frac{1}{2r}$</li><li>磁盘访问时间 ：$T_t=\frac{b}{rN}$</li></ol><p>$s$是指磁头从当前位置定位到开始点的时间，$b$是传输的字节数，$r$是每秒的转数，$N$是一条磁道上的字节数。$总时间 = T_s + \frac{1}{2r} + \frac{b}{rN}$</p><p>这其中，时间开销最大的是$s$，台式机的旋转速度一般是7200转/分钟（RPM），即旋转一周需要8.33ms，所以式子中的$s$平均为4.165ms，而且磁臂的移动也需要时间，通常磁盘的平均存储时间是$8-11ms$。而硅存储的常见存取时间是50ns，即$s$约为一次存取时间200000倍。通常一页的长度为$2^{11}-2^{14}$，即使磁盘一般是一次读取连续的几个页面，定位到信息的时间也比存取信息的时间多。所以当大量数据存储在外存磁盘中时，需要一种合理高效的数据结构来降低访问外存的时间：B树。需要说一下，B树的英文名是<code>B-tree</code>，所以有时候有人会把<code>B树</code>叫做<code>B-树</code>，这两个名词是同一个意思。</p><p>B树的典型执行过程中，B树算法的运行时间取决于<code>DISK-READ</code>和<code>DISK-WRITE</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = a pointer to some object</span><br><span class="line">DISK-READ(x)</span><br><span class="line">operations of x</span><br><span class="line">DISK-WRITE(x)</span><br></pre></td></tr></table></figure><p>通常一个B树的结点和磁盘的一页一样大，这样一次读写操作能获取更多的信息。而每页能存储多少个数据和关键字大小有关。下图中的B树每个结点有1000个数据（B树中结点的度数为结点数据个数+1，见后面的定义），高度为2。所以它可以存储超过十亿个关键字，查找某个关键字至多进行两次磁盘访问。</p><div align="center"><img src="/2019/B树/B树举例.jpg"></div><h2 id="B树的定义"><a href="#B树的定义" class="headerlink" title="B树的定义"></a>B树的定义</h2><h3 id="B树的定义-1"><a href="#B树的定义-1" class="headerlink" title="B树的定义"></a>B树的定义</h3><ul><li><p>每个结点有如下属性：</p><ol><li>$x.n$：表示当前存储在结点$x$中的关键字个数。</li><li>每个结点中的关键字以非降序方式存放：$x.key_1 \leq x.key_2 \leq \cdots \leq x.key_n$。</li><li>$x.leaf$：一个布尔值，如果$x$是叶结点，则为$true$，否则为$false$。</li></ol></li><li><p>每个内部结点还包含包含$x.n+1$个指向其孩子的指针：$x.c_1, x.c_2, \cdots , x.c_n $，叶结点的$c_i$属性没有定义。</p></li><li><p>关键字$x.key_i​$对存储在各子树中的关键字范围加以分割：如果$k_i​$为任意一个存储在以$x.c_i​$为根的子树中的关键字，满足：$k_i \leq x.key_1 \leq k_2 \leq x.key_2 \leq \cdots \leq x.key_{x.n} \leq k_{x.n+1}​$。</p></li><li>每个叶结点具有相同的深度，即树的高度h。</li><li>每个结点关键字所包含的关键字个数有上界和下界。用一个被称为B树的最小度数的固定整数$t​$来表示这些界，$t \geq 2​$。<ol><li>除了根结点外的每个结点都至少有$t-1​$个关键字，因此，除了根结点以外的每个内部结点至少有$t​$个孩子。如果树非空，根结点至少有一个关键字。</li><li>每个结点至多可包含$2t-1$个关键字，因此一个内部结点至多可有$2t$个孩子，当一个结点恰好有$2t-1$个关键字时，该结点是满的。</li><li>$t=2​$的树是最简单的，每个内部结点有2个、3个或4个孩子。</li></ol></li></ul><p>那么为什么最小度数不能取1呢？因为最小度数取1之后，内部结点（设指向其的指针为p）可以包含0个关键字，此时包含0个关键字的结点只有一个孩子（设为c），这个结点就被浪费了，我们其实可以直接让p指向c。</p><h3 id="B树的高度"><a href="#B树的高度" class="headerlink" title="B树的高度"></a>B树的高度</h3><p>对任意一棵包含n（$n \geq 1​$）个关键字、最小度数为t的B树来说，有：$h \leq log_t{\frac{n+1}{2}}​$。证明：</p><p>假设根所在的层深度为0，则高度为h的B树在深度为1的层至少包含2个结点，在深度为2的层至少包含$2t$个结点，在深度为3的层至少包含$2t^2$个结点…直到深度为h的层至少包含$2t^{h-1}$个结点。可得关于关键字个数n的关键字：$n \geq 1+(t-1)\sum_{i=1}^h2t^i-1 = 1+2(t-1)(\frac{t^h-1}{t-1})=2t^h-1$</p><p>$\Longrightarrow t^h \leq (n+1)/2$</p><p>$\Longrightarrow h \leq log_t{\frac{n+1}{2}}$</p><h3 id="B树的阶"><a href="#B树的阶" class="headerlink" title="B树的阶"></a>B树的阶</h3><p>我们经常会遇到一个B数的术语：阶，假如树中的结点最多含有m个孩子，此B树的阶为m。当阶为偶数的时候，我们可以把定义中的$t$替换成$m/2$，但是当阶为奇数的时候就要考虑一个问题了，除根结点外的每个内部结点至少含有<code>ceil(m/2)</code>个结点还是<code>floor(m/2)</code>个结点？应该是<code>ceil(m/2)</code>，因为除了根结点每个结点的孩子个数满足：$t \leq keyNum \leq 2t$，如果取<code>floor(m/2)</code>会发现无法满足上式，所以<strong>一棵含有n个总关键字数的m阶的B树的最大高度是</strong>：$log_{ceil(m/2)}(n+1)/2$。</p><h2 id="B树的操作"><a href="#B树的操作" class="headerlink" title="B树的操作"></a>B树的操作</h2><p>以下的操作都遵循两个规定：</p><ul><li>B树的根结点始终在主存中，这样就不用对根做<code>DISK-READ</code>操作。然而，当根结点被改变后需要对根结点做一次<code>DISK-WRITE</code>操作。</li><li>任何被当做参数的结点在被传递之前，都要对它们先做一次<code>DISK-READ</code>操作。</li></ul><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>设$x$是根结点，被搜索的关键字是$k$。</p><div align="left"><img src="/2019/B树/搜索.jpg"></div><p>需要说明一下，伪代码中$key$和$c​$的起始下标都为1。NIL代表空。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入的时候会遇到两种情况：</p><ol><li>将新的关键字插在一个已经存在但<strong>未满</strong>的结点上：直接插入；</li><li>将新的关键字插在一个已经存在但<strong>已满</strong>的结点上：分裂后插入；</li></ol><h4 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h4><p>将一个满的结点$y$（有$2t-1$个关键字）按照中间关键字分裂成两个各含有$t-1$个关键字的结点，中间关键字被升到$y$的父结点。如果$y​$的父结点也是满的，也需要分裂，最终满结点的分裂会向上传播。如果向上传播时全程都是满结点会把根结点分裂，使B树的高度增1。分裂是使B树增高的唯一办法。</p><p>但是在实际操作中不是等到找出插入过程中实际要分裂的结点才做分裂，而是在沿着树向下查找时分裂所有遇到的满结点，这样就能保证在插入的时候节点一定非满。</p><div align="left"><img src="/2019/B树/分裂.jpg"></div><p>$x$是被分裂的结点的父节点，$y$是$x$的第$i​$个孩子。</p><div align="center"><img src="/2019/B树/分裂举例.jpg"></div><h4 id="非满结点插入"><a href="#非满结点插入" class="headerlink" title="非满结点插入"></a>非满结点插入</h4><div align="left"><img src="/2019/B树/非满结点插入.jpg"></div><p>$x$是被插入的节点，$k$是插入的键。解释几行代码：</p><ul><li>12行：被操作的节点从磁盘中读入到内存中，然后在内存中进行操作。</li><li>7行+17行：每次插入的都是叶节点。</li></ul><h4 id="完整插入过程"><a href="#完整插入过程" class="headerlink" title="完整插入过程"></a>完整插入过程</h4><div align="left"><img src="/2019/B树/完整插入过程.jpg"></div><p>此时对根的分裂需要创建两个节点，而且对根的分裂是B树长高的唯一办法。而且在分裂之后我们会发现根节点必然会有一个关键字，这也对应了定义中的B树的根至少有两个孩子。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>分配空节点：</p><div align="left"><img src="/2019/B树/创建.jpg"></div><p>分配之后循环调用插入即可。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在删除时需要注意两个部分：</p><ol><li>除根节点外，被删除关键字的节点在删除后仍然要满足$keyNum \geq t-1$。</li><li>删除后需要重新安排这个结点的孩子。</li></ol><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ol><li>如果关键字$k$在结点$x$中，并且$x$是叶节点，从$x$中删除$k$</li><li>如果关键字$k$在结点$x$中，但$x$是内部非根节点：上移孩子结点中的某相近元素（“左孩子最右边的节点”或“右孩子最左边的节点”）到父节点中，并且递归被上移的孩子。删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于$ceil(m/2)-1$，则需要看其某相邻兄弟结点是否贫困（结点中元素个数等于$ceil(m/2)-1$）如果非贫困，则父节点下降一个元素来此节点，兄弟结点上升一个元素。如果其相邻兄弟都贫困，则该结点与其相邻的某一兄弟结点进行“合并“成一个结点。</li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><div align="center"><img src="/2019/B树/B树删除.jpg"></div><ul><li>刪除H：直接删除</li><li>删除T：W上升到T的位置，4上升到W的位置</li><li>删除R：删除导致只有1个元素，已经小于最小元素数目$ceil(5/2)-1=2$，由于右相邻兄弟结点不贫困，所以先向父节点借一个元素T下移到该叶子结点中，代替原来S的位置，S前移；然后W上移到父结点中，X、Y、Z依次前移。</li></ul><div align="center"><img src="/2019/B树/删除2.jpg"></div><ul><li>删除E：因为E所在的结点和相邻的兄弟结点的关键字都刚好达标，删除后不能再向父节点借元素，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点与含有A和C的相邻兄弟结点进行合并成一个结点。但是此时还没有结束，此时的情况如下图第一幅，此时父节点只包含一个元素G，没达标。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有Q,X）含有的元素个数大于2，咱们可以将M下移到元素很少的子结点中，将Q上移到M的位置，但此时咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，即树的高度减少一层。</li></ul><div align="center"><img src="/2019/B树/删除3.jpg"></div><div align="center"><img src="/2019/B树/删除4.jpg"></div><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>在B树中，我们做操作的时候都默认了关键字和其对应的数据都存在一个页面中，但是实际上可以只存储关键字，而且仅存关键字可以让每页能存储更多的数据。基于此点和为了更好的在文件系统中存取数据，诞生了B+树。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>B+树</code>可以被视为每个节点仅包含键（不是键值对），并且链接了各叶节点叶的B树。和B树的区别如下：</p><ul><li>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 （而B树的叶子节点并没有包括全部需要查找的信息）。</li><li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 （而B树的非终节点也包含需要查找的有效信息）</li></ul><div align="center"><img src="/2019/B树/B+树.jpg"></div><h3 id="为什么数据库使用B-树作为索引"><a href="#为什么数据库使用B-树作为索引" class="headerlink" title="为什么数据库使用B+树作为索引"></a>为什么数据库使用B+树作为索引</h3><ul><li>B+树的磁盘读写代价更低。B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li></ul><ul><li>B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。而B+树只要遍历叶子节点就可以实现整棵树的遍历。</li><li><code>B+树</code>对<code>range-query</code>的支持很强大。比如要查<code>5-10</code>之间的，<code>B+树</code>一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。</li></ul><h3 id="分裂-1"><a href="#分裂-1" class="headerlink" title="分裂"></a>分裂</h3><p>B+树的分裂和B树没有太大区别，只是分裂后注意叶子结点需要有链接到下个结点的指针。</p><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>B*树是B+树的变体，在B+树的基础上（所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针）:</p><ul><li>B*树中非根和非叶子结点再增加指向兄弟的指针；</li><li>B*树定义了非叶子结点关键字个数至少为$ceil((2/3) \ast m)$，即块的最低使用率为2/3（代替B+树的1/2）。</li></ul><div align="center"><img src="/2019/B树/Bast.jpg"></div><h3 id="分裂-2"><a href="#分裂-2" class="headerlink" title="分裂"></a>分裂</h3><p>当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>B树及其变形可以非常好的处理一维空间存储的问题。它的思想就是把一维直线分为若干段线段，当我们查找满足某个要求的点的时候，只要去查找它所属的线段即可。也可以说要查找某一满足条件的点，先去找到满足条件的线段，然后遍历所在线段上的点，即可找到答案。</p><div align="center"><img src="/2019/B树/B树.jpg"></div><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li><p><code>B树</code>：有序数组+平衡多叉树；</p></li><li><p><code>B+树</code>：有序数组链表+平衡多叉树；</p></li><li><p><code>B*树</code>：一棵丰满的B+树。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/v_JULY_v/article/details/6530142" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/details/6530142</a></li><li><a href="https://en.wikipedia.org/wiki/B%2B_tree#Overview" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/B%2B_tree#Overview</a></li><li><a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/B-tree</a></li><li>算法导论</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;磁盘访问时间&quot;&gt;&lt;a href=&quot;#磁盘访问时间&quot; class=&quot;headerlink&quot; title=&quot;磁盘访问时间&quot;&gt;&lt;/a&gt;磁盘访
      
    
    </summary>
    
      <category term="DSA" scheme="https://isjinhao.github.io/categories/DSA/"/>
    
    
      <category term="DSA" scheme="https://isjinhao.github.io/tags/DSA/"/>
    
      <category term="树" scheme="https://isjinhao.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>09-Mysql结构和存储引擎</title>
    <link href="https://isjinhao.github.io/2019/09-Mysql%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>https://isjinhao.github.io/2019/09-Mysql结构和存储引擎/</id>
    <published>2019-03-24T13:27:56.000Z</published>
    <updated>2019-03-25T07:39:25.800Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:34 GMT+0800 (GMT+08:00) --><h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><div align="center"><img src="/2019/09-Mysql结构和存储引擎/Mysql体系结构.jpg"></div><p>Mysql大致可以被分为四层：</p><h3 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h3><ul><li>Connectors指的是不同语言中与SQL的交互</li></ul><h3 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h3><ul><li>Management Serveices &amp; Utilities：系统管理和控制工具，例如备份恢复、Mysql复制、集群等</li><li>Connection Pool: 连接池，管理缓冲用户连接、用户名、密码、权限校验、线程处理等需要缓存的需求</li><li>SQL Interface: SQL接口，接受用户的SQL命令，并且返回用户需要查询的结果。比如<code>select * from</code>就是调用SQL Interface。</li><li>Parser: 解析器，SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本， 主要功能：<ol><li>将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的</li><li>如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的</li></ol></li><li><p>Optimizer：查询优化器，SQL语句在查询之前会使用查询优化器对查询进行优化。他使用的是“选取-投影-联接”策略进行查询。 用一个例子就可以理解：<code>select uid,name from user where gender = 1;</code></p><ul><li>先根据where语句进行选取，而不是先将表全部查询出来以后再进行gender过滤</li><li>再根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤</li><li>再将这两个查询条件联接起来生成最终查询结果</li></ul></li><li><p>Cache和Buffer（高速缓存区）：查询缓存，如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。 通过LRU算法将数据的冷端溢出，未来得及时刷新到磁盘的数据页，叫脏页。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。</p></li></ul><h3 id="第三级"><a href="#第三级" class="headerlink" title="第三级"></a>第三级</h3><ul><li>Engine：存储引擎。存储引擎是MySql中具体的与文件打交道的子系统。现在有很多种存储引擎，各个存储引擎的优势各不一样，最常用的<code>MyISAM</code>，<code>InnoDB</code>，<code>BDB</code>。默认下<code>MySql</code>是使用InnoDB引擎。</li></ul><h3 id="第四级"><a href="#第四级" class="headerlink" title="第四级"></a>第四级</h3><p>外存中真正存储数据的物理空间。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>Mysql中真正和外存打交道的是存储引擎。一般有两种最常见的引擎：</p><h3 id="INNODB"><a href="#INNODB" class="headerlink" title="INNODB"></a>INNODB</h3><div align="center"><img src="/2019/09-Mysql结构和存储引擎/INNODB.jpg"></div><ul><li><p>是缓存层，由一个大的innodb buffer pool和很多个其他小的内存组件组成，用来缓冲数据的，innodb的数据读取写入不是直接操作文件，而是从文件加载到缓存，在缓冲里做操作，再flush到磁盘文件。所以INNODE可以支持事务。</p></li><li><p>是各种后台线程，例如IO线程、日志线程、监控线程等；</p></li><li><p>是各种数据文件层，例如INNODB的数据文件、redo log等；</p></li></ul><h3 id="MYISAM"><a href="#MYISAM" class="headerlink" title="MYISAM"></a>MYISAM</h3><ul><li>MYISAM存储引擎的数据组织形式是一种堆表，和索引组织表相区别（INNODB的数据组织形式是索引组织表）。 例如插入一条数据id=2（d为主键，表里已经存在id=1和id=3数据）。<ul><li>MYISAM存储引擎：如果插入id=2，数据的插入位置和id=1 id=3无关系，也就是无序的； 堆表的插入特性是无序的。</li><li>INNODB存储引擎：如果插入id=2，会插入到id=1和id=3之间，因为INNODB是索引组织表是有有序的；索引组织表的最大特点是根据主键去查询效率非常快。</li></ul></li><li>MYISAM存储引擎不支持事务；</li><li>INNODB存储引擎的缓存不缓存数据，只缓存索引。数据缓存是交给操作系统的内存来缓存的。这种会有问题：如果查询一个大表，会消耗大量操作系统内存，如果表中碎片很大可能会浪费大量操作系统内存。</li><li>锁粒度较大：使用的是读写锁（读的时候不允许写，写的时候不允许读，只有读的时候允许读）</li></ul><p>参考：<a href="https://www.cnblogs.com/zhoubaojian/articles/7866231.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoubaojian/articles/7866231.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:34 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;MySQL体系结构&quot;&gt;&lt;a href=&quot;#MySQL体系结构&quot; class=&quot;headerlink&quot; title=&quot;MySQL体系结构
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>08-Mysql的锁</title>
    <link href="https://isjinhao.github.io/2019/08-Mysql%E7%9A%84%E9%94%81/"/>
    <id>https://isjinhao.github.io/2019/08-Mysql的锁/</id>
    <published>2019-03-24T12:31:10.000Z</published>
    <updated>2019-03-25T00:45:05.850Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:34 GMT+0800 (GMT+08:00) --><p>数据库的锁按照不同的分类可以分成很多类，常见的分类如下：</p><h2 id="悲观锁-amp-乐观锁"><a href="#悲观锁-amp-乐观锁" class="headerlink" title="悲观锁 &amp; 乐观锁"></a>悲观锁 &amp; 乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁就是在操作数据时，总是认为操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟<code>java</code>中的<code>synchronized</code>很相似，所以悲观锁需要耗费较多的时间。悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。不用考虑悲观锁，它对于应用程序员是透明的。</p><p>说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。<strong>共享锁和排它锁是悲观锁的不同的实现</strong>，它俩都属于悲观锁的范畴。参考：<a href="https://isjinhao.github.io/2019/06-%E4%BA%8B%E5%8A%A1/#more">https://isjinhao.github.io/2019/06-%E4%BA%8B%E5%8A%A1/#more</a></p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>首先先说一下，乐观锁不是锁，只是人们都习惯这样叫。对于乐观锁来说在操作数据时，总是认为操作不会出现数据冲突，所以不会上锁。那么如何控制并发问题呢？这其实是在应用程序级完成的功能，一般来说可以用数据版本（<code>Version</code>）记录机制实现。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的<code>version</code>字段来实现。当读取数据时，将<code>version</code>字段的值一同读出，数据每更新一次，对此<code>version</code>值加1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的<code>version</code>值进行比对，如果数据库表当前版本号与第一次取出来的<code>version</code>值相等，则予以更新，否则认为是过期数据。</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>数据库表设计，三个字段，分别是<code>id</code>，<code>value</code>，<code>version</code>。</p><p>每次更新表中的value字段时，为了防止发生冲突，需要这样两步操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">value</span>,<span class="keyword">version</span> <span class="keyword">from</span> <span class="keyword">TABLE</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">value</span>=<span class="number">2</span>,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125; and version=#&#123;version&#125;;</span></span><br></pre></td></tr></table></figure><h2 id="按加锁的粒度分"><a href="#按加锁的粒度分" class="headerlink" title="按加锁的粒度分"></a>按加锁的粒度分</h2><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>是Mysql中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分ySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。特点是开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。分为共享锁和排他锁。特点是开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><h3 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h3><p>表级锁是Mysql中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。特点是开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><p>存储引擎参考：<a href="https://isjinhao.github.io/2019/09-Mysql%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/#more">https://isjinhao.github.io/2019/09-Mysql%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/#more</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:34 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;数据库的锁按照不同的分类可以分成很多类，常见的分类如下：&lt;/p&gt;&lt;h2 id=&quot;悲观锁-amp-乐观锁&quot;&gt;&lt;a href=&quot;#悲观锁-amp-乐
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>09-磁盘存储器的管理</title>
    <link href="https://isjinhao.github.io/2019/09-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <id>https://isjinhao.github.io/2019/09-磁盘存储器的管理/</id>
    <published>2019-03-21T03:33:26.000Z</published>
    <updated>2019-03-23T13:05:30.596Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:34 GMT+0800 (GMT+08:00) --><p>文件管理的目标是管理文件的组织方式，管理文件的访问权等。而磁盘存储器的管理是管理存储器的使用，如何高效利用存储器。他俩是棋与棋盘的关系。</p><h2 id="连续组织方式"><a href="#连续组织方式" class="headerlink" title="连续组织方式"></a>连续组织方式</h2><p>文件的信息存放在若干连续的物理块中。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/连续组织方式.jpg" style="width:70%"></div><ul><li>优点<ul><li>简单</li><li>支持顺序存取和随机存取</li><li>顺序存取速度快，所需的磁盘寻道次数和寻道时间最少</li></ul></li><li>缺点<ul><li>文件不能动态增长（预留空间：浪费、重新分配和移动）</li><li>不利于文件插入和删除</li><li>外部碎片问题</li></ul></li></ul><h2 id="链接组织方式"><a href="#链接组织方式" class="headerlink" title="链接组织方式"></a>链接组织方式</h2><h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>在文件的目录中记录该文件的第一和最后一个盘块的指针，每一个盘块的指针指向文件的下一物理块号。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/隐式链接.jpg"></div><ul><li>优点<ul><li>文件可动态增长</li><li>有利于文件的插入和删除</li><li>提高了磁盘空间利用率,不存在外部碎片问题</li></ul></li><li>缺点<ul><li>存取速度慢，不适于随机存取</li><li>可靠性问题，如指针出错</li><li>更多的寻道次数和寻道时间</li><li>链接指针占用一定的空间</li></ul></li></ul><h3 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h3><p>将链接文件各物理块的指针显示地放在内存的一张链接表（文件分配表，File Allocation Table）中。在FCB的物理地址中填写其首指针所对应的盘块号。由于文件分配表示存储在内存中的，可以大大减少访问磁盘的次数。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/显示链接.jpg" style="width:70%"></div><h3 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h3><p>微软公司早、中期推出的操作系统一直都是采用的FAT技术，即利用文件分配表FAT来记录每个文件中所有盘块之间的链接。FAT中引入了“卷”的概念，支持将一个物理磁盘分成四个逻辑磁盘，每个逻辑磁盘就是一个卷（也称为分区），每个卷都可以被单独格式化和使用。把盘块作为基本分配单位，同时每个分区中都配有两张相同的文件分配表FAT1和FAT2。</p><p>FAT技术的发展有三个阶段：FAT12、FAT16和FAT32</p><h4 id="FAT12"><a href="#FAT12" class="headerlink" title="FAT12"></a>FAT12</h4><p>FAT表的每个表项占用12个bit。所以最多有$2^{12}$个表项，每个盘块的大小是512B，则每个磁盘分区的容量是2MB，能处理的磁盘最大容量是8MB。</p><p>为了增大FAT能管理的最大容量，引入了“簇”的概念，每个簇是一组相邻的扇区，这样如果分配时以簇为单位进行分配就能管理更大的磁盘容量，但是相应的簇内零头也会更大，降低磁盘的利用率。</p><h4 id="FAT16"><a href="#FAT16" class="headerlink" title="FAT16"></a>FAT16</h4><p>FAT表的每个表项占用16个bit。最多有$2^{16}$个表项。</p><h4 id="FAT32"><a href="#FAT32" class="headerlink" title="FAT32"></a>FAT32</h4><p>FAT表的每个表项占用16个bit。最多有$2^{32}$个表项。同时每个簇固定为4KB。所以最大可管理$4 \ast 2^{10} \ast 2^{32} = 2TB$大小的空间。</p><h3 id="NTFS"><a href="#NTFS" class="headerlink" title="NTFS"></a>NTFS</h3><h2 id="索引组织方式"><a href="#索引组织方式" class="headerlink" title="索引组织方式"></a>索引组织方式</h2><h3 id="单级索引组织方式"><a href="#单级索引组织方式" class="headerlink" title="单级索引组织方式"></a>单级索引组织方式</h3><p>一个文件的信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构索引表，并将这些块的块号存放在一个索引表中。一个索引表就是磁盘块地址数组，其中第i个条目指向文件的第i块。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/索引组织方式.jpg" style="width:60%"></div>·<br><br>### 多级索引组织方式<br><br><div align="center"><img src="/2019/09-磁盘存储器的管理/多级索引组织方式.jpg"></div><h3 id="增量式索引组织方式"><a href="#增量式索引组织方式" class="headerlink" title="增量式索引组织方式"></a>增量式索引组织方式</h3><p>可以更好的满足大、中、小文件的组织。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/增量组织方式.jpg"></div><h2 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h2><p>文件存储空间的管理包括空闲块的组织分配和回收。</p><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>把一个连续未分配区域称为“空闲文件”，系统为所有空闲文件单独建立一个目录。表目内容：序号，第一个空白块号，空白块个数。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/空闲链表.jpg"></div><ul><li><p>分配算法：内存管理中的首次适应算法、循环首次适应算法。</p></li><li><p>合并：空闲区邻接合并</p></li></ul><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>空闲盘块链：所有空闲盘块拉成一条链，分配时从头分配，回收时链接在尾部。</p><p>空闲盘区链：每个连续的盘块组成一个盘区，每个盘区包含本盘区的大小和下一个盘区的地址。</p><h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><p>用一串二进制位反映磁盘空间中分配使用情况，每个物理块对应一位，分配物理块为1，否则为0。申请物理块时，可以在位示图中查找为0的位，返回对应物理块号；归还时；将对应位转置0。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/位示图法.jpg"></div><h3 id="成组链接法（重点）"><a href="#成组链接法（重点）" class="headerlink" title="成组链接法（重点）"></a>成组链接法（重点）</h3><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接法.jpg"></div><ul><li>把所有的空闲盘块按每n个一组分成m个组。</li><li>最后一个组放在内存的空闲盘块号栈中，其他组存在外存上。空闲盘块号栈是一个临界资源，只允许一个进程同时访问。</li><li><p>数据结构，一个size为n+1的栈。图上是一个倒着的的栈（栈底在上方，栈顶在下方）</p></li><li><p>一个n+1的栈实际可用盘块只有n（图上只有99个可用盘块），因为栈底是一个计数器，指示当前有多少个可用盘块，但是可用盘块中有一个是指向下一个组，即stack[1]指向下一个组。如果stack[1]==0表示此时是最后一组。</p></li><li>分配时从栈顶开始向下分配，直至分配出n-1个盘块，此时如果再想分配一个块就需要把下一个组调入空闲盘块号栈。调入后新组覆盖旧组。<strong>然后把新组在外存中占用的盘块分配出去。</strong></li><li>回收时从栈底向上回收，如果计数器==100时还有空闲盘块（设这个盘块编号为p）要回收，就把空闲盘块号栈内的组取出来存在p中，在空闲盘块号栈内新开辟一个组，新组的stack[1]指向p。</li></ul><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>此题题目及来源：<a href="https://blog.csdn.net/ajay666/article/details/73569654" target="_blank" rel="noopener">https://blog.csdn.net/ajay666/article/details/73569654</a></p><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接例.jpg"></div><p>分配3个盘块后，回收它所占的5个盘块，回收的盘块号依次为700、711、703、788、701，画出分配回收过程。</p><h4 id="第一次分配"><a href="#第一次分配" class="headerlink" title="第一次分配"></a>第一次分配</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接例1.jpg"></div><h4 id="第二次分配"><a href="#第二次分配" class="headerlink" title="第二次分配"></a>第二次分配</h4><p>注意：300号盘块中存储的组信息调入空闲盘块号栈之后其自己也可以被分配。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接例2.jpg"></div><h4 id="第三次分配"><a href="#第三次分配" class="headerlink" title="第三次分配"></a>第三次分配</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接例3.jpg"></div><h4 id="第一次回收"><a href="#第一次回收" class="headerlink" title="第一次回收"></a>第一次回收</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/第一次回收.jpg"></div><h4 id="第二次回收"><a href="#第二次回收" class="headerlink" title="第二次回收"></a>第二次回收</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/第二次回收.jpg"></div><h4 id="第三次-amp-第四次-amp-第五次回收"><a href="#第三次-amp-第四次-amp-第五次回收" class="headerlink" title="第三次&amp;第四次&amp;第五次回收"></a>第三次&amp;第四次&amp;第五次回收</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/第三四五次回收.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:34 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;文件管理的目标是管理文件的组织方式，管理文件的访问权等。而磁盘存储器的管理是管理存储器的使用，如何高效利用存储器。他俩是棋与棋盘的关系。&lt;/p&gt;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>为什么硬链接不能作用于目录</title>
    <link href="https://isjinhao.github.io/2019/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%B8%8D%E8%83%BD%E4%BD%9C%E7%94%A8%E4%BA%8E%E7%9B%AE%E5%BD%95/"/>
    <id>https://isjinhao.github.io/2019/为什么硬链接不能作用于目录/</id>
    <published>2019-03-21T01:36:08.000Z</published>
    <updated>2019-03-23T03:23:08.203Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --><p>笔者最初遇见这个问题的时候是因为知道了在Linux系统中，目录其实也是一种文件，只不过是一种比较特殊的文件，既然都是文件，那为什么不能对它做硬链接呢？想弄明白这个，就需要知道两个知识，目录和文件共享。因为链接的目的就是要实现文件共享。</p><p>通常可以定义为文件控制块（FCB）的有序集合。但是并不是说目录中的每一个目录项都是一个FCB，只能是每一个目录项都能唯一确定一个FCB。这是由于如果每个目录项都是FCB会引起文件共享问题。比如下图：对于文件<code>F8</code>，<code>D5:p</code>、<code>D6:e</code>、<code>D3:p</code>都保存了<code>F8</code>的物理地址，即从某个盘块开始，总长度多少等。此时如果<code>D6:e</code>对<code>F8</code>进行了删除操作，<code>D5:p</code>和<code>D3:P</code>都无法察觉，仍然会认为在它们存储的位置上有文件，即一个目录项对文件的操作对其他目录项来说是不可见的。</p><div align="center"><img src="/2019/为什么硬链接不能作用于目录/有向无环图.jpg" width="80%;"></div><p>为了解决这个问题，引入索引节点。将文件的物理地址和其他的属性放在索引结点中，只在目录项中存放文件名和指向索引结点的指针。任何用户对文件进行操作，引起相应索引结点内容的改变。此种方法即Linux中的硬链接。</p><div align="center"><img src="/2019/为什么硬链接不能作用于目录/利用索引节点.jpg" width="60%;"></div><p>所以如果我们对文件做硬链接，比如对<code>Test r</code>做硬链接生成<code>thirdHardLink</code>，那么就是<code>thirdHardLink</code>的指针指向索引节点，索引节点的<code>count</code>修改为3。</p><p>Linux限制了对目录做硬链接，那么假如我们是设计者，想对一个目录做硬链接可以怎么做呢？</p><ul><li><p>第一种方法是把对目录生成的硬链接单独作为一种文件类型，如果我们想使用目录中的某个文件时，操作系统的处理步骤是<code>HardLinkDir-&gt;Dir-&gt;指向索引节点的指针指针-&gt;索引节点</code>。可以看出此种方法的代价很大。</p><div align="center"><img src="/2019/为什么硬链接不能作用于目录/设计1.jpg"></div></li><li><p>第二种方法是把目录的每个目录项拷贝一份，但这样不就是拷贝<code>cp</code>了吗，没有必要再实现对目录的硬链接了。</p></li><li><p>第三种方法是把每个目录项的文件名拷贝一份，<code>HardLink</code>的指针指向原目录项的指针位置。但是这种方法也需要把对目录生成的硬链接单独作为一种文件类型，代价很大。</p><div align="center"><img src="/2019/为什么硬链接不能作用于目录/设计3.jpg"></div></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;笔者最初遇见这个问题的时候是因为知道了在Linux系统中，目录其实也是一种文件，只不过是一种比较特殊的文件，既然都是文件，那为什么不能对它做硬链
      
    
    </summary>
    
      <category term="Linux" scheme="https://isjinhao.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://isjinhao.github.io/tags/Linux/"/>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>08-文件管理</title>
    <link href="https://isjinhao.github.io/2019/08-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>https://isjinhao.github.io/2019/08-文件管理/</id>
    <published>2019-03-20T11:14:43.000Z</published>
    <updated>2019-03-23T03:23:08.206Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --><h2 id="文件管理概述"><a href="#文件管理概述" class="headerlink" title="文件管理概述"></a>文件管理概述</h2><p>计算机中有很多的程序和数据都是保存在外存中，在需要使用的时候才调入内存中。而如何保存这些信息是很重要的问题，因为不同类型的文件存储的数据格式不同，但这些格式却必须“迎合”硬件只能存储二进制数据的硬性条件。所以操作系统提供了文件管理的功能，让使用者能在不了解文件特性和外存特性的情况下完成文件的存储和查找等功能。同时还提供了文件共享和安全管理等功能。</p><h3 id="文件系统-amp-文件"><a href="#文件系统-amp-文件" class="headerlink" title="文件系统 &amp; 文件"></a>文件系统 &amp; 文件</h3><p>操作系统中负责管理和存储文件信息的软件称为文件管理系统，简称文件系统。包含：文件系统的接口，对对象操纵和管理的软件集合，对象及属性三部分。它负责对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。包含创建文件、删除文件等功能。</p><p>文件是指具有文件名的若干相关元素的集合，可以分成有结构文件和无结构文件，无结构文件可以看成一个字符流。有结构文件是由一组记录的集合，记录又是一组数据项的集合。</p><ul><li><p>数据项：用来描述一个对象的某种属性的字符集。例如学生的学号、姓名等。</p></li><li><p>记录：一组数据项的集合，用来描述一个对象在某方面的属性，例如学生的成绩。能唯一标识一个记录的一个或多个数据项叫做关键字。</p></li></ul><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>不同的文件类型由于本身存储的信息具有不同的结构，在管理的时候也是不同。所以文件会被分成很多类型，下面是常用的文件分类方法：</p><ul><li><p>按用途分类：系统文件、库文件、用户文件。</p></li><li><p>按文件中数据的形式分类：源文件、目标文件、可执行文件。</p></li><li><p>按存储控制属性分类：可读、可写、可执行文件。</p></li><li><p>按组织形式和处理方法分类：普通文件、目录文件、特殊文件。</p></li></ul><h3 id="剖析文件和目录"><a href="#剖析文件和目录" class="headerlink" title="剖析文件和目录"></a>剖析文件和目录</h3><p>我们刚才在定义中说道，文件是指具有文件名的若干相关元素的集合，在有结构文件中这些元素是数据项集合的集合，在无结构文件指的是字符流。所以文件的概念中本身是：</p><div align="center"><img src="/2019/08-文件管理/文件.png"></div><h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p>文件系统从底层到高层可分成三部分：对象及其属性、对对象操纵和管理的软件集合、文件系统接口：</p><ul><li><p>对象及其属性：文件管理系统管理的文件如下：</p><ul><li><p>文件：在文件管理系统中有着各种不同类型的文件，它们都作为文件管理的直接对象。</p></li><li><p>目录：用于对文件的存储和检索，目录的每个目录项包含了一个文件或目录的信息。</p></li><li><p>磁盘存储空间：文件和目录必定占用存储空间，对这部分空间的有效管理不仅能提高外存的利用率，而且能提高对文件的存取速度。</p></li></ul></li><li><p>对对象操纵和管理的软件集合：该层是文件管理系统的核心部分。文件系统的功能大多是在这一层实现的。如：文件存储的管理、文件目录的管理、将文件的逻辑地址转换为物理地址的机制、文件读写控制的管理、文件的共享和保护等功能。这些功能被可分为四层：</p><ul><li><p>I/O控制层：文件系统的最底层、主要由磁盘驱动程序等组成。</p></li><li><p>基本文件系统层：主要用于处理内存和磁盘之间数据块的交换。</p></li><li><p>基本I/O管理程序：完成与磁盘I/O有关的事务，如将文件的逻辑块号转换为物理块号、管理磁盘中的空闲盘块、I/O缓冲的指定等。</p></li><li><p>逻辑文件系统：管控对文件的操作，如控制用户或应用程序对文件的读写等。</p></li></ul></li><li><p>文件系统的接口：操作系统提供给用户或应用程序用来使用文件系统的接口：</p><ul><li>命令接口：用户与文件系统直接交互的接口，如Shell命令。</li><li>程序接口：应用程序可以通过一系列命令调用文件系统的服务。</li></ul></li></ul><h2 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h2><p>当用户要求对一个文件实施多次读/写操作时，如果每次都检索目录效率较低，所以为了避免多次重复的检索目录，OS提供了“打开（Open）”操作，当此操作被执行时，OS会把被打开文件的信息存为“打开文件表”的一个条目，然后把这个条目编号返回用户，这样用户就可以通过这个编号和文件之间建立一个连接，也就可以进行文件的读写等操作。当用户再次向系统发出请求时，把这个编号提交给OS，OS通过这个编号在打开文件表中查找文件信息就可以减少检索时间。而关闭就是OS从“打开文件表”上删除此条目，这样断开了用户和文件之间的连接。</p><h2 id="文件的逻辑结构和物理结构"><a href="#文件的逻辑结构和物理结构" class="headerlink" title="文件的逻辑结构和物理结构"></a>文件的逻辑结构和物理结构</h2><ul><li><p>逻辑结构：从用户的角度来看，文件是能被存取的基本单位。</p></li><li><p>物理结构：文件在磁盘上存储时的组织形式。</p></li></ul><h3 id="逻辑文件按结构分类"><a href="#逻辑文件按结构分类" class="headerlink" title="逻辑文件按结构分类"></a>逻辑文件按结构分类</h3><ul><li><p>有结构文件：每个文件用于描述实体集中的一个实体。每个记录的长度对OS来说都是可知的。但记录之间可以分为定长和变长两种。</p><ul><li><p>定长记录：所有记录的长度都是相同的、所有记录中的各数据项都处在记录中相同的位置具有相同的顺序和长度。</p></li><li><p>变长记录：各记录的长度不相同。比如论文的摘要可能长度差距很大，不能在存储之前估计出所需要的空间。</p></li></ul></li><li><p>无结构文件：系统中运行的大量的源程序、可执行文件、文本文件等都是无结构文件，即流式文件。其文件长度是以字节为单位的。</p></li></ul><h3 id="逻辑文件按组织方式分类"><a href="#逻辑文件按组织方式分类" class="headerlink" title="逻辑文件按组织方式分类"></a>逻辑文件按组织方式分类</h3><p>组织方式指的是文件中记录的组织方式。只对有结构文件有效。可以分成：顺序文件、索引文件、索引顺序文件。</p><h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><p>指由一系列记录按某种顺序排列所形成的的文件。</p><ul><li><p>串结构：按存入时间的先后顺序排列。所以检索时必须从头挨个查找，效率低。</p></li><li><p>顺序结构：用户指定一个字段作为关键字，他可以是任意类型的变量。如sql文件。</p></li></ul><h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>为变长记录文件创建一张索引表，索引表是定长记录文件，检索时，先查找索引表，再根据指针所指的地址读取记录。可以解决变长文件记录较难直接存取的问题。</p><div align="center"><img src="/2019/08-文件管理/索引文件.jpg"></div><h3 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h3><p>将顺序文件的所有记录分成若干组，为顺序文件建立一张索引表，索引表中为每组的第一个记录建立一个索引项。检索时，先检索索引表，找到记录所在记录组的第一个记录的表项，再顺序查找主文件，得到要求的记录。</p><div align="center"><img src="/2019/08-文件管理/索引顺序文件.jpg"></div><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><p>包含三类信息：</p><ul><li><p>基本信息类：文件名、文件物理位置、文件逻辑结构、文件物理结构</p></li><li><p>控制信息类：各类用户的读、写、可执行文件等。</p></li><li><p>使用信息类：文件的建立时间，当前的使用信息，上一次修改的时间，是否被进程锁住等。</p></li></ul><h3 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h3><p>为了唯一确定外存中的一个文件，必须要把文件的FCB加载进内存，而每次加载的数据大小是一定的，所以为了一次能多加载进内存一个文件标识。将FCB分成两部分：</p><h4 id="磁盘索引节点"><a href="#磁盘索引节点" class="headerlink" title="磁盘索引节点"></a>磁盘索引节点</h4><ul><li>文件主标识符</li><li>文件类型</li><li>文件存取权限</li><li>文件物理地址</li><li>文件长度</li><li>文件连接计数：本人理解为硬链接计数</li><li>文件存取时间</li></ul><h4 id="内存索引节点。"><a href="#内存索引节点。" class="headerlink" title="内存索引节点。"></a>内存索引节点。</h4><ul><li>索引节点编号</li><li>状态</li><li>访问计数</li><li>文件所属文件系统的逻辑设备号：不明白</li><li>链接指针：不明白</li></ul><h3 id="树形结构目录"><a href="#树形结构目录" class="headerlink" title="树形结构目录"></a>树形结构目录</h3><p>在树形结构目录中，目录应该保存文件的信息。</p><div align="center"><img src="/2019/08-文件管理/文件目录.jpg"></div><p>同时目录的目录项要能既作为目录文件的FCB，又作为数据文件的FCB。</p><div align="center"><img src="/2019/08-文件管理/树形文件目录.jpg"></div><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><h3 id="基于有向无循环图实现文件共享"><a href="#基于有向无循环图实现文件共享" class="headerlink" title="基于有向无循环图实现文件共享"></a>基于有向无循环图实现文件共享</h3><div align="center"><img src="/2019/08-文件管理/有向无环图.jpg" style="width:80%"></div><p>此种方法存在问题：</p><p>比如对于文件<code>F8</code>，<code>D5:p</code>、<code>D6:e</code>、<code>D3:p</code>都保存了<code>F8</code>的物理地址，即从某个盘块开始，总长度多少等。此时如果<code>D6:e</code>对<code>F8</code>进行了删除操作，<code>D5:p</code>和<code>D3:P</code>都无法察觉，仍然会认为在它们存储的位置上有文件，即一个目录项对文件的操作对其他目录项来说是不可见的。</p><h3 id="利用索引节点"><a href="#利用索引节点" class="headerlink" title="利用索引节点"></a>利用索引节点</h3><div align="center"><img src="/2019/08-文件管理/利用索引节点.jpg" style="width:60%"></div><p>引入索引结点，将文件的物理地址和其他的属性放在索引结点中，只在目录项中存放文件名和指向索引结点的指针。由任何用户对文件进行Append操作或修改，引起相应索引结点内容的改变。此种方法即Linux中的硬链接。</p><h3 id="利用符号链接实现文件共享"><a href="#利用符号链接实现文件共享" class="headerlink" title="利用符号链接实现文件共享"></a>利用符号链接实现文件共享</h3><p>建立符号链接文件，它是一种特殊类型的文件，其内容是被链接文件的路径名。建立符号链接文件，并不影响原文件，实际上它们各是一个文件。可以建立任意的别名关系，甚至原文件是在其他计算机上。只有文件主才有指向索引结点的指针，而其他共享用户只有该文件的路径名。</p><div align="center"><img src="/2019/08-文件管理/利用符号链接.jpg"></div><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><h3 id="访问权-amp-保护域"><a href="#访问权-amp-保护域" class="headerlink" title="访问权&amp;保护域"></a>访问权&amp;保护域</h3><ul><li>访问权：一个进程能对某对象执行操作的权利，用&lt;对象名，权集&gt;表示，如<code>&lt;F1, {R/W}&gt;</code>表示进程对F1有读和写的权利。</li><li>保护域：进程对一组对象访问权的集合，进程只能在域内进行操作。</li></ul><h3 id="进程和域的联系方式"><a href="#进程和域的联系方式" class="headerlink" title="进程和域的联系方式"></a>进程和域的联系方式</h3><p>进程和域之间是一对多的关系，即一个进程可以联系多个域。此时进程的运行分为多个阶段，每个阶段联系一个域，这样就可以根据运行的实际需要规定进程每个阶段所能访问的对象。</p><h3 id="访问矩阵"><a href="#访问矩阵" class="headerlink" title="访问矩阵"></a>访问矩阵</h3><div align="center"><img src="/2019/08-文件管理/访问矩阵.jpg"></div><ul><li>R：在域内运行的进程对文件具有读权限</li><li>W：在域内运行的进程对文件具有写权限</li><li>$R^\ast$：在域内运行的进程能把其对文件的读权限扩展到其他域中，但在其他域中是R权限，不再是$R^\ast$。</li><li><p>$W^\ast$：在域内运行的进程能把其对文件的写权限扩展到其他域中，但在其他域中是W权限，不再是$W^\ast$。</p></li><li><p>S：在域Di中运行的进程能转移到域Dj中运行，如图中在域D3运行的进程能转移到域D2中运行。</p></li><li>O：在域中运行的进程能增加或删除对某文件的访问权。</li><li>Control：在域Di中运行的进程能删除在域Dj中运行进程对各对象的访问权。如图中在D2中运行的进程能删除在D3中运行进程的访问权。</li></ul><h3 id="访问矩阵的实现"><a href="#访问矩阵的实现" class="headerlink" title="访问矩阵的实现"></a>访问矩阵的实现</h3><h4 id="访问控制表"><a href="#访问控制表" class="headerlink" title="访问控制表"></a>访问控制表</h4><p>将访问对象按列划分，为每一列建立一张访问控制表，在该表中把属于对象的所有空项都删除。此时表中的每一项都是一个有序对<code>&lt;域，权集&gt;</code>构成。</p><h4 id="访问权限表"><a href="#访问权限表" class="headerlink" title="访问权限表"></a>访问权限表</h4><p>将访问矩阵按行划分，每一行是一个访问权限表，表中的每一项表示该域对某对象的访问权限。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;文件管理概述&quot;&gt;&lt;a href=&quot;#文件管理概述&quot; class=&quot;headerlink&quot; title=&quot;文件管理概述&quot;&gt;&lt;/a&gt;文件管
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>07-输入输出系统</title>
    <link href="https://isjinhao.github.io/2019/07-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://isjinhao.github.io/2019/07-输入输出系统/</id>
    <published>2019-03-20T09:41:00.000Z</published>
    <updated>2019-03-25T08:28:00.952Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --><p>输入输出系统和OS中的其他部分有很大区别，因为其他部分都是在说计算机接受任务后该怎么运行能又快又可靠的完成任务并把结果输出。而输入输出系统是怎么快速稳定的将任务的需求输入和任务的结果输出。</p><p>又由于输入输出设备种类繁多，比如输入设备中的键盘、鼠标、网卡、摄像头，输出设备中的打印机、音频等。所以输入输出系统被划分很多层次来尽可能屏蔽物理细节。</p><h2 id="IO系统的基本功能"><a href="#IO系统的基本功能" class="headerlink" title="IO系统的基本功能"></a>IO系统的基本功能</h2><ul><li><p>隐藏物理设备的细节：只需要使用简单的命令就能操作各种具有不同实现的硬件完成相应需求。</p></li><li><p>与设备的无关性：用户不需要指定哪些设备完成功能，只需要描述需求，OS会选择一个设备完成功能。</p></li><li><p>提高处理机和IO设备的利用率：IO设备之间一般是相互独立的，因此设备之间能够并行操作，所以OS应让处理机和设备之间能并行操作。</p></li><li><p>对IO设备进行控制：</p><ul><li>轮询的可编程IO方式。</li><li>采用中断你的可编程IO方式。</li><li>直接存储器访问方式。</li><li>IO通道方式。</li></ul></li><li><p>确保对设备的正确共享。</p></li><li><p>错误处理。</p></li></ul><h2 id="IO软件的层次结构"><a href="#IO软件的层次结构" class="headerlink" title="IO软件的层次结构"></a>IO软件的层次结构</h2><div align="center"><img src="/2019/07-输入输出系统/IO软件层次.jpg"></div><ul><li>用户层软件：提供设备与用户交互的接口，用户可以使用该层提供的功能直接控制设备。</li><li>设备独立性软件：设备分配，设备保护，设备分配，设备回收，数据缓存等。</li><li>设备驱动软件：发出控制设备的命令。</li><li>中断处理程序：保存被中断的进程的CPU环境，转入相应的中断处理程序仅需处理，处理完毕后再恢复被中断进程的现场，返回到被中断的进程。</li></ul><h2 id="IO系统各模块层次视图"><a href="#IO系统各模块层次视图" class="headerlink" title="IO系统各模块层次视图"></a>IO系统各模块层次视图</h2><div align="center"><img src="/2019/07-输入输出系统/IO各模块层次视图.jpg"></div><ul><li>块设备：输入输出以数据块为单位的设备。如磁盘。</li><li>流设备：字符设备的输入输出，如键盘。</li><li>网络通信接口：网卡。</li></ul><h2 id="IO设备和设备控制器"><a href="#IO设备和设备控制器" class="headerlink" title="IO设备和设备控制器"></a>IO设备和设备控制器</h2><p>直接和IO设备对接的是设备控制器。</p><div align="center"><img src="/2019/07-输入输出系统/IO设备和设备控制器.jpg"></div><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>接收和识别命令（控制寄存器、命令译码器）：设备控制器将CPU送来的命令写入控制器寄存器中，并进行译码。</li><li>数据交换（数据寄存器）。</li><li>设备状态的了解和报告（状态寄存器）。</li><li>地址识别（地址译码器）：系统中的每个设备都有自己的地址段，设备接口电路中有多个寄存器，一个寄存器有唯一的一个地址，每个地址为I/O端口，该地址称为I/O端口地址。设备控制器必须能识别每个设备的地址。</li><li>数据缓冲：缓冲器。</li><li>差错控制：差错检测码。</li></ol><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li><p>设备控制器和处理机的接口：用于实现CPU与设备控制器之间的通信。</p></li><li><p>设备控制器和设备的接口。</p></li><li><p>IO逻辑：在一个设备控制器上，可以连一个或多个设备。相应的，在控制器中就有一个或多个设备接口，一个接口连一台设备，控制器中的I/O逻辑根据处理机发来的地址信号，去选择一个设备接口。控制器中的I/O逻辑用来实现对设备的控制。通过接收CPU 发来的命令和地址信息，对所选设备进行控制</p></li></ul><h3 id="CPU如何控制设备控制器"><a href="#CPU如何控制设备控制器" class="headerlink" title="CPU如何控制设备控制器"></a>CPU如何控制设备控制器</h3><p>CPU控制内存时需要指定指令地址、数据地址等。控制设备控制器亦如此，一般有两种控制方式：</p><ul><li>利用特定IO指令：利用特殊的IO指令控制设备控制器。</li><li>内存映像IO：不再区分内存和控制器中的寄存器地址。假如有一个地址K，当0&lt;=K&lt;N时被认为是内存地址，K&gt;=N时被认为是寄存器地址。</li></ul><h3 id="IO通道"><a href="#IO通道" class="headerlink" title="IO通道"></a>IO通道</h3><p>有了设备控制器之后，CPU便可以操作控制器完成对IO设备的控制，但是此时数据交换仍然需要CPU的全程参与，所以引入IO通道来使数据传送、IO设备的组织管理等都独立于CPU。</p><p>通道是独立于CPU的专门负责数据输入/输出传输工作的处理机，对外部设备实现统一管理，代替CPU对输入/输出操作进行控制，从而使输入，输出操作可与CPU并行操作。通道执行通道程序来控制IO操作。与CPU的区别：</p><ul><li>通道程序指令类型单一</li><li>通道没有自己的内存，通道程序在主机的内存中，即通道与CPU共享内存。</li></ul><h4 id="字节多路通道"><a href="#字节多路通道" class="headerlink" title="字节多路通道"></a>字节多路通道</h4><p>主要连接以字节为单位的低速IO设备。如打印机，终端。</p><ul><li><p>按字节交叉方式工作的通道。通常含有许多非分配型子通道，其数量从几十个到数百个，每一个子通道连接一台I/O设备。这些子通道按时间片轮转方式共享主通道。</p></li><li><p>字节多路通道以字节为单位传输信息，它可以分时地执行多个通道程序。当一个通道程序控制某台设备传送一个字节后，通道硬件就控制转去执行另一个通道程序，控制另一台设备传送信息。</p></li></ul><div align="center"><img src="/2019/07-输入输出系统/字节多路通道.jpg"></div><h4 id="数组选择通道"><a href="#数组选择通道" class="headerlink" title="数组选择通道"></a>数组选择通道</h4><p>主要连接磁盘，磁带等高速I/O设备</p><p>选择通道是按数组方式进行数据传送，每次传送一批数据，故传送速度很高。</p><p>选择通道在一段时间内只能执行一个通道程序，只允许一台设备进行数据传输。当这台设备数据传输完成后，再选择与通道连接的另一台设备，执行它的相应的通道程序。这种独占性又使得通道利用率很低。</p><div align="center"><img src="/2019/07-输入输出系统/数组选择通道.jpg"></div><h4 id="数组多路通道"><a href="#数组多路通道" class="headerlink" title="数组多路通道"></a>数组多路通道</h4><p>主要连接高速设备。</p><ul><li><p>结合了数组选择通道传送速度高和字节多路通道能进行分时并行操作的优点。它先为一台设备执行一条通道指令，然后自动转接，为另一台设备执行一条通道指令。它含有多个非分配型的子通道，既有很高的数据传输率，又能获得令人满意的通道利用率</p></li><li><p>对通道程序采用多道程序设计的硬件实现</p></li><li><p>可以连接多台高速设备，数据传输按数组方式，一段时间内可以执行多道通道程序</p></li></ul><h4 id="解决瓶颈"><a href="#解决瓶颈" class="headerlink" title="解决瓶颈"></a>解决瓶颈</h4><p>通道执行通道程序，向控制器发出命令，并具有向CPU发中断信号的功能。一旦CPU发出指令，启动通道，则通道独立于CPU工作。但是，由于通道价格贵，通道数量少，往往使之成为IO的“瓶颈”。解决办法是在不增加通道的前提下，增加设备到主机间的通路，一个通道可连接多个控制器，一个控制器可连接多个设备，形成树形交叉连接。</p><div align="center"><img src="/2019/07-输入输出系统/解决瓶颈.jpg"></div><h2 id="中断机构和中断处理程序"><a href="#中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h2><p><a href="https://isjinhao.github.io/2019/%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD/#more">https://isjinhao.github.io/2019/%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD/#more</a></p><h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol><li>接受设备独立性软件发来的命令和参数，将接收到的抽象要求转换为具体要求</li><li>检查用户IO请求的合法性，了解IO设备的状态，传递有关参数，设置设备的工作方式</li><li>发出IO命令，如果设备空闲，启动IO设备完成指定的IO操作；如果设备忙碌，则将请求挂在设备队列上等待</li><li>及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。</li><li>对于设置有通道的计算机系统，驱动程序还应能够根据用户的IO请求，自动地构成通道程序。</li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>驱动程序主要是在设备无关性软件和设备控制器之间的一个通信程序</li><li>驱动程序与IO设备特性密切相关：通常由硬件厂商提供</li><li>驱动程序与I/O控制方式密切相关:中断驱动和DMA方式</li><li>驱动程序与硬件相关,部分代码需用汇编语言编写</li><li>驱动程序应允许可重入</li></ol><h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><ol><li>将抽象要求转换为具体要求<ol><li>通常设备控制器中都有若干个寄存器，分别用于暂存命令、数据和参数等；</li><li>用户及上层软件对设备控制器的具体情况毫无了解，因而只能向它们发出抽象的要求(命令)，但不能直接传送给设备控制器。需要将抽象要求转换为具体要求(命令码，数据，参数)。例如，将抽象要求中的盘块号转换为磁盘的盘面、磁道号及扇区。这一转换工作只能由驱动程序来完成；</li><li>在OS中只有驱动程序才同时了解抽象要求和设备控制器中的寄存器情况；也只有它才知道命令、数据和参数应分别送往哪个寄存器。</li></ol></li><li>检查IO请求的合法性</li><li>读出和检查设备的状态</li><li>传送必要的参数，设置工作方式</li><li>启动I/O设备<ol><li>在完成上述准备工作后，驱动程序可以向控制器中的命令寄存器传送相应的控制命令</li><li>对于字符设备，若发出的是写命令，驱动程序将把一个数据传送给控制器；若发出的是读命令，则驱动程序等待接收数据，并通过从控制器中的状态寄存器读入状态字的方法，来确定数据是否到达。</li><li>驱动程序发出IO命令后，基本的IO是在设备控制器的控制下进行的，通常IO操作所要完成的工作较多，需要一定的时间，如读/写一个盘块中的数据，此时，驱动程序进程把自己阻塞起来，直至中断到来时才将它唤醒。</li></ol></li></ol><h3 id="对IO设备的控制方式"><a href="#对IO设备的控制方式" class="headerlink" title="对IO设备的控制方式"></a>对IO设备的控制方式</h3><h4 id="使用轮询的可编程I-O方式"><a href="#使用轮询的可编程I-O方式" class="headerlink" title="使用轮询的可编程I/O方式"></a>使用轮询的可编程I/O方式</h4><p>CPU发出启动外设的I/O指令，同时将忙/闲标志置为1。如果外设的工作没有完成，则标志一直为1，CPU不断循环检测该标志，直到标志为不忙为止。</p><div align="center"><img src="/2019/07-输入输出系统/轮询可编程.jpg"></div><h4 id="使用中断的可编程I-O方式"><a href="#使用中断的可编程I-O方式" class="headerlink" title="使用中断的可编程I/O方式"></a>使用中断的可编程I/O方式</h4><p>CPU设定I/O设备的初始值，然后不再忙等待，运行其他进程，当前进程阻塞；I/O设备完成对当前数据的处理后，向CPU发出中断，I/O中断处理程序将负责传送剩余数据。</p><div align="center"><img src="/2019/07-输入输出系统/中断可编程.jpg"></div><h4 id="直接存储器访问-DMA-方式"><a href="#直接存储器访问-DMA-方式" class="headerlink" title="直接存储器访问(DMA)方式"></a>直接存储器访问(DMA)方式</h4><p>采用中断驱动IO方式时的CPU，是以字为单位进行干预的。如果将这种方式用于块设备的I／O，是极其低效的。如：为了从磁盘中读出1KB的数据块；需要中断1K次CPU。而DMA方式使用独立的DMA控制器代替CPU的工作，I/O设备与DMA通信，DMA在传输完成一个数据缓冲区之后再向CPU发中断。</p><ul><li>数据传输的基本单位是数据块，即CPU与IO设备之间，每次传送至少是一个数据块，主要用在块设备的IO操作中。</li><li>在DMA方式中，利用总线直接连接外设和内存，由DMA控制机构窃取总线占有权，完成外设与内存间的成批数据交换。所传送的数据是从设备直接送入内存的，或者相反。</li><li>仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的，不再需要CPU进行干预。</li></ul><h4 id="I-O通道控制方式"><a href="#I-O通道控制方式" class="headerlink" title="I/O通道控制方式"></a>I/O通道控制方式</h4><p>使用DMA方式，CPU每发出一条I/O指令，只能读写一个连续的数据块。如果需要一次去读多个离散的数据块且将它们分别送到不同的内存区域，则需要CPU分别发出多条I/O指令及进行多次中断处理，才能完成。</p><p>而IO通道可实现CPU、通道和I/O设备三者的并行操作，进一步提高CPU与外设之间的并行工作能力，使I/O操作形成独立于CPU的体系，减少CPU的负担，使外设与内存的数据交换更加灵活，从而更有效地提高整个系统的资源利用率。</p><p>参见4.4。</p><h2 id="与设备无关的I-O软件"><a href="#与设备无关的I-O软件" class="headerlink" title="与设备无关的I/O软件"></a>与设备无关的I/O软件</h2><p>为了便于对外设进行管理，系统对每台进入计算机系统中的设备都给定一个对应的编号，作为调用时识别和区分设备用。这种编号无任何重复，一般被称为设备的绝对号（或物理设备名）。早期操作系统，应用程序直接使用物理设备名称，非常不灵活。所以引入逻辑设备名，规定用户申请外设时，只需要向系统说明所需用的某类设备真正在实际中使用哪台设备，由系统根据这类设备的应用情况作出分配。</p><h3 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h3><p>在多道程序环境下，设备不允许用户自行使用，而必须由系统分配。对于进程的IO请求，只要是安全（无死锁），设备分配程序便按照一定的策略进行设备分配。数据结构：</p><ul><li><p>系统设备表SDT：System Device Table。</p><ul><li>整个系统中只有一张，全面反映了系统中的外设资源的类型、数量、占用情况等。</li><li>在SDT表中，每个接入系统中的外围设备都占有一个表目项。登录了该设备的名称、标识、设备控制表DCT的入口地址、设备驱动程序的入口地址及占用设备的进程名称等相关信息。</li></ul><div align="center"><img src="/2019/07-输入输出系统/SDT.jpg"></div></li><li><p>设备控制表DCT ：Device Control Table。每台设备都有一张设备控制表DCT，用于记录本设备的情况。</p><ul><li>Type：设备类型</li><li>Deviceid:设备标识符</li><li>设备队列队首指针</li><li>设备状态：标识设备忙或者空闲；</li><li>与设备连接的控制器表指针。</li><li>重复执行次数</li></ul><div align="center"><img src="/2019/07-输入输出系统/DCT.jpg"></div></li><li><p>控制器控制表COCT：Controller Control Table。每个控制器都有一张，用于记录某控制器的使用分配情况及与该控制器相连的通道的情况。</p><ul><li>控制器号：控制器的内部标识符。</li><li>控制器状态：控制器忙/闲，好/坏的状态标志。</li><li>通道指针：指向与该控制器相联的通道控制表CHCT，当控制器与若干通道连接时该项内含多个指针。</li><li>等待队列指针：指向等待该控制器的I/O进程队列</li></ul><div align="center"><img src="/2019/07-输入输出系统/COCT.jpg"></div></li><li><p>通道控制表CHCT：Channel Control Table。反映了通道的情况，系统中的每个通道一张CHCT。</p><ul><li>通道号：通道内部标识符</li><li>通道状态：通道的各种状态（好/坏，已分/未分等）的反映</li><li>等待队列指针：等待该通道的I/O进程队列的首位置</li></ul><div align="center"><img src="/2019/07-输入输出系统/CHCT.jpg"></div></li></ul><h3 id="设备分配算法"><a href="#设备分配算法" class="headerlink" title="设备分配算法"></a>设备分配算法</h3><div align="center"><img src="/2019/07-输入输出系统/设备分配算法.jpg"></div><h2 id="用户层的I-O软件"><a href="#用户层的I-O软件" class="headerlink" title="用户层的I/O软件"></a>用户层的I/O软件</h2><h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>用户层软件必须使用一组系统调用来取得操作系统服务，在高级语言中都提供了相应的库函数来完成此功能。</p><h3 id="SPOOLing程序"><a href="#SPOOLing程序" class="headerlink" title="SPOOLing程序"></a>SPOOLing程序</h3><p>多道程序技术将一台CPU虚拟为多台CPU，从而可以提高CPU的利用率。而SPOOLing系统是模拟脱机输入输出系统来实现多个用户共享一台物理IO设备。</p><ul><li>脱机输入输出系统的IO处理机 对应 SPOOLing程序。</li><li>脱机输入输出系统的高速缓冲 对应 内存。</li></ul><div align="center"><img src="/2019/07-输入输出系统/SPOOLing.jpg"></div><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><h3 id="单缓冲区"><a href="#单缓冲区" class="headerlink" title="单缓冲区"></a>单缓冲区</h3><div align="center"><img src="/2019/07-输入输出系统/单缓冲区.jpg"></div><h3 id="双缓冲区"><a href="#双缓冲区" class="headerlink" title="双缓冲区"></a>双缓冲区</h3><p>为输入或输出分配两个缓冲区，让两个缓冲区交替工作，形成并行操作的方式。</p><div align="center"><img src="/2019/07-输入输出系统/双缓冲.jpg"></div><h3 id="环形缓冲区"><a href="#环形缓冲区" class="headerlink" title="环形缓冲区"></a>环形缓冲区</h3><ul><li>空缓冲区R：用于存放数据（指针：Nexti）</li><li>已装满数据的缓冲区G：其中的数据提供给进程使用。（指针：Nextg）</li><li>现行工作缓冲区C：当前进程使用的缓冲区。（指针：Current）</li></ul><div align="center"><img src="/2019/07-输入输出系统/环形缓冲.jpg"></div><h2 id="磁盘存储器的性能和调度"><a href="#磁盘存储器的性能和调度" class="headerlink" title="磁盘存储器的性能和调度"></a>磁盘存储器的性能和调度</h2><div align="center"><img src="/2019/07-输入输出系统/磁盘.jpg"></div><p>当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头（又叫磁头）下通过，就可以进行数据的读/写了。</p><p>一般磁盘分为固定头盘（磁头固定）和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。</p><p>活动头盘 （如上图）的磁头是可移动的。每一个盘面上只有一个磁头（磁头是双向的，因此正反盘面都能读写）。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的（行动整齐划一）。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。</p><h3 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h3><ol><li>寻道时间$T_s$：$T_s = s$</li><li>旋转延迟时间$T_τ​$：$T_t = \frac{1}{2r}​$</li><li>磁盘访问时间 ：$T_t=\frac{b}{rN}$</li></ol><p>$s$是指磁头从当前位置定位到开始点的时间，$b$是传输的字节数，$r$是每秒的转数，$N$是一条磁道上的字节数。$总时间 = T_s + \frac{1}{2r} + \frac{b}{rN}$</p><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>假设磁盘访问序列：98，183，37，122，14，124，65，67，读写头起始位置：53。</p><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>按访问请求到达的先后次序服务。</p><div align="center"><img src="/2019/07-输入输出系统/先来先服务.jpg"></div><h4 id="最短寻道时间优先"><a href="#最短寻道时间优先" class="headerlink" title="最短寻道时间优先"></a>最短寻道时间优先</h4><div align="center"><img src="/2019/07-输入输出系统/最短寻道.jpg"></div><h4 id="扫描算法"><a href="#扫描算法" class="headerlink" title="扫描算法"></a>扫描算法</h4><p>当设备无访问请求时，磁头不动；当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复。</p><div align="center"><img src="/2019/07-输入输出系统/扫描算法.jpg"></div><h4 id="循环扫描算法"><a href="#循环扫描算法" class="headerlink" title="循环扫描算法"></a>循环扫描算法</h4><p>CSCAN算法规定磁头单向移动，例如由里向外移动，当磁头移到最外的磁道并访问后磁头立即返回到最里的欲访<br>问磁道，即最小磁道号紧接最大磁道号构成循环，进行循环扫描。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;输入输出系统和OS中的其他部分有很大区别，因为其他部分都是在说计算机接受任务后该怎么运行能又快又可靠的完成任务并把结果输出。而输入输出系统是怎么
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>07-Mysql高级操作</title>
    <link href="https://isjinhao.github.io/2019/07-Mysql%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/"/>
    <id>https://isjinhao.github.io/2019/07-Mysql高级操作/</id>
    <published>2019-03-20T08:27:31.000Z</published>
    <updated>2019-03-24T12:30:36.506Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:34 GMT+0800 (GMT+08:00) --><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><div align="center"><img src="/2019/07-Mysql高级操作/表结构.jpg"></div><p>这个是本人数据库课程设计中的表结构，数据库课程设计写的是学院成绩管理系统，就是可以通过excel把学生的绩点、竞赛情况、大创项目情况导入到系统中，然后学生、班长、辅导员三个级别的用户可以从三个层次看到成绩。表结构：</p><ul><li>studentinfos：学号、密码、姓名、专业、班级、绩点、级别（学生是第一级）</li><li>courses：课号、姓名、类型（必修课、公共选修课、专业选修课等）、重要系数（理学院套餐、专业核心课程一般是1.2，选修课等一般是1.0）、学分、年度。</li><li>scores：唯一标识（没吊用…）、学号、课号、成绩、年度、学期</li><li><p>classdamins：班号、密码、班级名称、级别（班长是第二级别）</p></li><li><p>candp：唯一标识、项目或比赛的名称、年度、级别、是否是负责人、学号、状态</p></li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] [ALGORITHM = &#123;UNDEFINED | <span class="keyword">MERGE</span> | TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> view_name [(column_list)]</span><br><span class="line"><span class="keyword">AS</span> SELECT_statement</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> | <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>]</span><br></pre></td></tr></table></figure><p>把每个班学生的绩点、学分、通过率创建一个视图：<code>classstudentscores</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> classstudentscores <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="string">`scores`</span>.<span class="string">`stu_id`</span> <span class="keyword">AS</span> <span class="string">`id`</span>,</span><br><span class="line"><span class="string">`studentinfos`</span>.<span class="string">`name`</span> <span class="keyword">AS</span> <span class="string">`name`</span>,</span><br><span class="line"><span class="string">`studentinfos`</span>.<span class="string">`pwd`</span> <span class="keyword">AS</span> <span class="string">`pwd`</span>,</span><br><span class="line"><span class="string">`studentinfos`</span>.<span class="string">`cclass`</span> <span class="keyword">AS</span> <span class="string">`cclass`</span>,</span><br><span class="line"><span class="string">`studentinfos`</span>.<span class="string">`gpa`</span> <span class="keyword">AS</span> <span class="string">`gpa`</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="string">`courses`</span>.<span class="string">`credit`</span>) <span class="keyword">AS</span> <span class="string">`allcre`</span>,</span><br><span class="line"><span class="string">`getStudentPassRate`</span> (<span class="string">`scores`</span>.<span class="string">`stu_id`</span>) <span class="keyword">AS</span> <span class="string">`passrate`</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="string">`studentinfos`</span>,</span><br><span class="line"><span class="string">`scores`</span>,</span><br><span class="line"><span class="string">`courses`</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="string">`studentinfos`</span>.<span class="string">`id`</span> = <span class="string">`scores`</span>.<span class="string">`stu_id`</span></span><br><span class="line"><span class="keyword">AND</span> <span class="string">`scores`</span>.<span class="string">`cou_id`</span> = <span class="string">`courses`</span>.<span class="string">`id`</span></span><br><span class="line"><span class="keyword">AND</span> <span class="string">`scores`</span>.<span class="string">`score`</span> &gt; <span class="number">59</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="string">`scores`</span>.<span class="string">`stu_id`</span></span><br></pre></td></tr></table></figure><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>视图是可以更新的，对视图的更新最终会反应到基本表上，但是并非所有的视图都是可更新的。如果视图包含下述结构中的任何一种，那么它就是不可更新的：</p><ol><li>聚合函数（SUM(), MIN(), MAX(), COUNT()等）。</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>UNION或UNION ALL</li><li>位于选择列表中的子查询</li><li>Join</li><li>FROM子句中的不可更新视图</li><li>WHERE子句中的子查询，引用FROM子句中的表。</li><li>ALGORITHM = TEMPTABLE（使用临时表总会使视图成为不可更新的）。</li></ol><h3 id="WITH-CHECK-OPTION"><a href="#WITH-CHECK-OPTION" class="headerlink" title="WITH CHECK OPTION"></a><code>WITH CHECK OPTION</code></h3><ul><li><p>LOCAL参数表示更新视图时只要满足该视图本身定义的条件即可。</p></li><li><p>CASCADED参数表示更新视图时需要满足所有相关视图和表的条件。没有指明时，该参数为默认值。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用<code>with check option</code>之后，通过视图进行的修改，必须也能通过该视图看到修改后的结果。总结如下：</p><ol><li>视图只操作它可以查询出来的数据，对于它查询不出的数据，即使基表有，也不可以通过视图来操作。</li><li>对于update，有with check option，要保证update后，数据要被视图查询出来</li><li>对于delete，有无with check option都一样</li><li>对于insert，有with check option，要保证insert后，数据要被视图查询出来</li><li>对于没有where子句的视图，使用with check option是多余的</li></ol><h3 id="视图创建算法"><a href="#视图创建算法" class="headerlink" title="视图创建算法"></a>视图创建算法</h3><ul><li><code>MERGE</code>算法：MySQL首先将输入查询与定义视图的SELECT语句组合成单个查询。 然后MySQL执行组合查询返回结果集。 如果SELECT语句包含集合函数、DISTINCT、GROUP BY、HAVING、LIMIT、UNION、UNION ALL、子查询，则不允许使用<code>MERGE</code>算法。如果SELECT语句无引用表，则也不允许使用<code>MERGE</code>算法。 如果不允许<code>MERGE</code>算法，MySQL将算法更改为<code>UNDEFINED</code>。</li><li>使用<code>TEMPTABLE</code>算法，MySQL首先根据定义视图的SELECT语句创建一个临时表，然后针对该临时表执行输入查询。因为MySQL必须创建临时表来存储结果集并将数据从基表移动到临时表，所以<code>TEMPTABLE</code>算法的效率比<code>MERGE</code>算法效率低。 另外，使用<code>TEMPTABLE</code>算法的视图是不可更新的。</li></ul><p>原文链接：<a href="https://www.yiibai.com/mysql/create-sql-views-mysql.html" target="_blank" rel="noopener">https://www.yiibai.com/mysql/create-sql-views-mysql.html</a></p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>教程链接：<a href="https://www.yiibai.com/mysql/stored-procedure.html" target="_blank" rel="noopener">https://www.yiibai.com/mysql/stored-procedure.html</a></p><p><strong>一定要注意，Mysql的游标只能用于存储过程和函数。</strong></p><p>例：获得班级的平均绩点</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> getClassGpa;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> getClassGpa(<span class="keyword">IN</span> <span class="string">`classID`</span> <span class="built_in">varchar</span>(<span class="number">20</span>), <span class="keyword">OUT</span> <span class="string">`avgpa`</span> <span class="keyword">double</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> cgpa <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">sum</span> <span class="keyword">DOUBLE</span> <span class="keyword">DEFAULT</span> <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> done <span class="built_in">int</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">num</span> <span class="built_in">int</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> cur <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> gpa <span class="keyword">from</span> studentinfos <span class="keyword">where</span> cclass = classID;</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">for</span> <span class="keyword">not</span> <span class="keyword">found</span> <span class="keyword">set</span> done = <span class="literal">TRUE</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">sum</span>=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">num</span>=<span class="number">0</span>;</span><br><span class="line">open cur;</span><br><span class="line">read_loop:LOOP</span><br><span class="line">FETCH CUR INTO cgpa;</span><br><span class="line">if done then</span><br><span class="line">leave read_loop;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">sum</span> = <span class="keyword">sum</span> + cgpa;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">num</span> = <span class="keyword">num</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">close cur;</span><br><span class="line"><span class="keyword">set</span> avgpa = <span class="keyword">sum</span>/<span class="keyword">num</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sum</span>,avgpa;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>本质上和存储过程没区别。只是函数只能返回一个变量的限制。而存储过程可以返回多个。而且函数是可以嵌入在sql中使用，可以在select中调用，而存储过程不行。通常如果返回值只有一个使用函数，其他情况使用存储过程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`getClassNotPassRate`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> <span class="string">`getClassNotPassRate`</span> (<span class="string">`classID`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)) <span class="keyword">RETURNS</span> <span class="keyword">DOUBLE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span><span class="keyword">sum</span> <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span>notPassSum <span class="keyword">DOUBLE</span>;</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> <span class="keyword">sum</span> <span class="keyword">FROM</span>scores,studentinfos</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">scores.stu_id = studentinfos.id</span><br><span class="line"><span class="keyword">AND</span> studentinfos.cclass = classID;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> notPassSum <span class="keyword">FROM</span> scores, studentinfos</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">scores.stu_id = studentinfos.id</span><br><span class="line"><span class="keyword">AND</span> studentinfos.cclass = classID</span><br><span class="line"><span class="keyword">AND</span> scores.score &lt; <span class="number">60</span>;</span><br><span class="line">IF (sum = 0) </span><br><span class="line">THEN RETURN 0; </span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">RETURN notPassSum / sum;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>教程：<a href="https://www.yiibai.com/mysql/triggers.html" target="_blank" rel="noopener">https://www.yiibai.com/mysql/triggers.html</a></p><p>例：在录入学生成绩时，触发器根据新录入的学生成绩的系统中已有的学生选课成绩计算出录入之后的学生GPA。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`changeGpa`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="string">`changeGpa`</span> <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="string">`scores`</span> <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> myavg <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> allcre <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> temp <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">sum</span> <span class="keyword">DOUBLE</span> <span class="keyword">DEFAULT</span> <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> t <span class="built_in">INTEGER</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> t1 <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> t2 <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> done <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">FALSE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> cur <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">SELECT</span> scores.score, courses.coefficient, courses.credit <span class="keyword">from</span> studentinfos, scores, courses </span><br><span class="line">       <span class="keyword">where</span> studentinfos.id = scores.stu_id <span class="keyword">and</span> scores.cou_id = courses.id <span class="keyword">and</span> stu_id = new.stu_id;</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">for</span> <span class="keyword">not</span> <span class="keyword">found</span> <span class="keyword">set</span> done = <span class="literal">TRUE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(courses.credit) <span class="keyword">into</span> allcre <span class="keyword">from</span> studentinfos, scores, courses </span><br><span class="line">       <span class="keyword">where</span> studentinfos.id = scores.stu_id <span class="keyword">and</span> scores.cou_id = courses.id <span class="keyword">and</span> stu_id = new.stu_id <span class="keyword">and</span> score&gt;=<span class="number">60</span>;</span><br><span class="line">open cur;</span><br><span class="line">read_loop:loop</span><br><span class="line">FETCH cur into t, t1, t2;</span><br><span class="line">IF done THEN LEAVE read_loop; <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">if(t &lt; 60) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 60) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 64) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">1.6</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 66) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">1.7</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 68) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 72) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">2.3</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 75) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">2.7</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 78) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">3.0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 82) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">3.3</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 85) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">3.7</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 90) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">4.0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">sum</span>=temp*t1*t2+<span class="keyword">sum</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">close cur;</span><br><span class="line"><span class="keyword">set</span> myavg = <span class="keyword">sum</span>/allcre;</span><br><span class="line"><span class="keyword">UPDATE</span> studentinfos <span class="keyword">SET</span> gpa = myavg <span class="keyword">where</span> <span class="keyword">id</span> = new.stu_id;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:34 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;数据&quot;&gt;&lt;a href=&quot;#数据&quot; class=&quot;headerlink&quot; title=&quot;数据&quot;&gt;&lt;/a&gt;数据&lt;/h2&gt;&lt;div ali
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>06-事务</title>
    <link href="https://isjinhao.github.io/2019/06-%E4%BA%8B%E5%8A%A1/"/>
    <id>https://isjinhao.github.io/2019/06-事务/</id>
    <published>2019-03-20T07:20:54.000Z</published>
    <updated>2019-03-24T07:29:36.457Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:34 GMT+0800 (GMT+08:00) --><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>原子性（Atomicity）：事务是数据库的逻辑工作单位事务中包括的诸操作要么都做，要么都不做。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>一致性（Consistency）：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。</p><ul><li><p>一致性状态：数据库中只包含成功事务提交的结果。</p></li><li><p>不一致状态：数据库中包含失败事务的结果。</p></li></ul><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>隔离性（Isolation）：一个事务内部的操作及使用的数据对其他并发事务是隔离的。也就是说一个事务在执行的时候不知道是否有其他事务和它一起在对相同的数据做操作，事务之间是相对不可见的。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>持续性（Durability）：持续性也称永久性。一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。</p><h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><p>由于事务的隔离性，不同事务若同时相同的数据做操作，可能会引发问题，即事务的并发问题。按照问题解决的难度由低至高可分为四类。</p><h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p>一个事务对数据对象的修改被另一个事务的修改所覆盖。分为两类：</p><ul><li>第一类：事务T1、T2同时读取A为10，T1将A减1后提交，T2将A也减1后<strong>提交</strong>，此时数据库中数据为9。T1的修改被T2覆盖。</li><li>第一类：事务T1、T2同时读取A为10，T1将A减1后提交，T2将A也减1后<strong>回滚</strong>，此时数据库中数据为10。T1的修改被T2覆盖。</li></ul><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>由于一个事物的回滚，使得另一个事务读到的数据无效。事务T1中读A为100，修改A未300，还未提交时事务T2读C为300，但由于T1因某原因进行事务回滚。A又被重置为100。T2读取到的是脏数据。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>在一个事务的两次“读”同一数据之间，有另一个事务的“updata”发生。如在事务T1中第一次读A为100，读B为200，A+B为300，在事务T2中把A修改为200，事务T2第二次读A为200，读B为200，A+B为400。同一事务两次读取的数据不一致。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>在一个事务的两次“读”同一数据之间，有另一个事务的“insert”发生。如在事务T1中第一次读<code>count(*)</code>为100，事务T2插入一条数据，事务T1中第二次读<code>count(*)</code>为101，同一事务两次读取的数据不一致。</p><h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><p>加锁是解决事务并发问题的常见手段。数据库中的锁从读写的角度可分为两类：共享锁和排它锁。</p><ul><li>排它锁（X锁）：只允许当前事务T对数据进行“读”、“写”，其它事务对数据R的任何锁请求被拒绝直到T释放R上的X锁。</li><li>共享锁（S锁）：允许当前事务T对数据R进行“读”，不允许“写“，而其它事务对R的S申请被允许，X请求拒绝。</li></ul><p>带来的效果是：</p><ul><li>X锁：数据对象当前只能由一个事务操作。</li><li>S锁：多个事务允许同时“读”一个数据。</li></ul><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><p>在运用X锁和S锁对数据对象加锁时，还需要约定一些规则 ，例如何时申请X锁或S锁、持锁时间、何时释放等。称这些规则为封锁协议。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。</p><h3 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h3><p>对T要“写”的R加X锁，直到T结束。此时可以解决丢失更新。此时仍然会发生：</p><ul><li>脏读：事务T2可以绕过X锁读取数据，且读取到的是T1回滚的数据。</li><li>不可重复读：事务T2的两次读之间可以发生T1的”update“。</li><li>幻读：事务T2的两次读之间可以发生T1的”insert“。</li></ul><h3 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h3><ul><li><p>T发生“写”加X锁，直到T结束；（一级封锁协议）</p></li><li><p>T发生“读”R加S锁，读完即释放。</p></li></ul><p>此时可以解决丢失修改和脏读。</p><ul><li>事务T1先对R进行写（加X锁），则事务T2在读时没法加S锁，直至T1结束。</li><li>事务T2先对R进行读（加S锁），则事务T1在写时需要等待读结束（T1不一定结束）。</li></ul><p>此时仍然会发生：</p><ul><li>不可重复读：事务T1在第一次读之后（释放S锁），事务T2进行了”update”操作，事务T1再读得到的数据和上次不一致。</li><li>幻读：事务T1在第一次读之后（释放S锁），事务T2进行了”insert”操作，事务T1再读得到的数据和上次不一致。</li></ul><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><ul><li><p>T发生“写”加X锁，直到T结束。</p></li><li><p>T发生“读”加S锁，直到T结束。</p></li></ul><p>此时可以解决任何并发问题，因为无论对数据进行读还是写都要加锁：</p><ul><li>写：先加X锁，之后任何读写都被禁止。</li><li>读：先加S锁，之后任何写操作都被被禁止。</li></ul><p>三级封锁协议仅允许不同的事务同时发生读操作。</p><h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><ul><li><p>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁。</p></li><li><p>在释放一个封锁之后，事务不再获得任何其他封锁。</p></li></ul><p>满足所有遵守两段锁协议的事务，其并行执行的结果一定是正确的：</p><ul><li>先加X锁：X锁结束前（在两段锁协议中，不一定要事务结束才能释放X锁）任何锁都不能加上去，X锁结束后此事务不能再进行任何读写操作。</li><li>先加S锁：S锁结束前，只能对其加S锁，即只允许多个事务同时读。一旦释放一个S锁，便任何锁都加不上去，只能完成为完成的读，不能再进行新的读写操作。</li></ul><p>满足三级封锁协议的一定满足两段锁协议：</p><ul><li>先加X锁，两种协议下事务结束之前任何读写都会被禁止。</li><li>先加S锁，在两段锁协议中，若第一个锁的释放之后紧跟的事件就是事务的结束，此时就是三级封锁协议，即三级封锁协议是两段锁协议的一部分。</li></ul><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>READ UNCOMMITTED。对应一级封锁协议。</p><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>READ COMMITTED。对应二级封锁协议。</p><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>REPEATABLE READ。二级封锁协议加上不允许事务读取在该事务开始后新提交的数据。即防止了不可重复读的发生。</p><h3 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h3><p>SERIALIZABLE。对应三级封锁协议。</p><h2 id="MySql特点"><a href="#MySql特点" class="headerlink" title="MySql特点"></a>MySql特点</h2><ol><li>MySql默认的事务隔离级别是读已提交</li><li>MySql的事务是自动提交，即即使未事务，MySql也会把每个SQL语句放在一个事务中运行，这个事务是MySql自动添加上去的。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:34 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;headerlink&quot; title=&quot;ACID&quot;&gt;&lt;/a&gt;ACID&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="https://isjinhao.github.io/2019/Servlet/"/>
    <id>https://isjinhao.github.io/2019/Servlet/</id>
    <published>2019-03-20T04:55:20.000Z</published>
    <updated>2019-03-24T08:32:50.385Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:34 GMT+0800 (GMT+08:00) --><h2 id="Servlet的创建"><a href="#Servlet的创建" class="headerlink" title="Servlet的创建"></a>Servlet的创建</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Servlet是指任何实现了Servlet接口的类。一般情况下Servlet用来扩展基于HTTP协议的Web服务器，它可以接受响应通过HTTP协议从客户端发过来的信息。</p><p>Servlet是一个类，但Servlet类的对象是由Web服务器创建的，不是由开发者创建的。并且多个客户端访问同一个Servlet时只会创建一个Servlet对象。即Servlet是单实例多线程的。</p><p>图片来至：<a href="https://blog.csdn.net/qq_19782019/article/details/80292110" target="_blank" rel="noopener">https://blog.csdn.net/qq_19782019/article/details/80292110</a></p><div align="center"><img src="/2019/Servlet/servlet创建.gif"></div><h3 id="Servlet接口"><a href="#Servlet接口" class="headerlink" title="Servlet接口"></a>Servlet接口</h3><ul><li><p>void init(ServletConfig config)：在服务器创建 Servlet对象时执行。</p></li><li><p>void destroy()：在服务器关闭时调用。</p></li><li><p>ServletConfig getServletConfig()：返回一个ServletConfig对象。</p></li><li><p>String getServletInfo()：得到Servlet的信息。如作者、版本等。</p></li><li><p>void service(ServletRequest req, ServletResponse res) ：被服务器调用去获得和响应从服务器发来的请求。</p></li></ul><h3 id="Servlet的生命周期"><a href="#Servlet的生命周期" class="headerlink" title="Servlet的生命周期"></a>Servlet的生命周期</h3><ul><li><p>Servlet何时创建：默认第一次访问Servlet时创建该对象。</p></li><li><p>Servlet何时销毁：服务器关闭Servlet就销毁了。</p></li><li><p>每次访问必然执行的方法：service(ServletRequest req, ServletResponse res)。</p></li></ul><h3 id="实现Servlet接口"><a href="#实现Servlet接口" class="headerlink" title="实现Servlet接口"></a>实现Servlet接口</h3><h3 id="继承HttpSerlvet类"><a href="#继承HttpSerlvet类" class="headerlink" title="继承HttpSerlvet类"></a>继承HttpSerlvet类</h3><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:34 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Servlet的创建&quot;&gt;&lt;a href=&quot;#Servlet的创建&quot; class=&quot;headerlink&quot; title=&quot;Servlet
      
    
    </summary>
    
      <category term="Java Web" scheme="https://isjinhao.github.io/categories/Java-Web/"/>
    
    
      <category term="Java Web" scheme="https://isjinhao.github.io/tags/Java-Web/"/>
    
  </entry>
  
  <entry>
    <title>汤姆猫和超文本传输协议</title>
    <link href="https://isjinhao.github.io/2019/%E6%B1%A4%E5%A7%86%E7%8C%AB%E5%92%8C%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE/"/>
    <id>https://isjinhao.github.io/2019/汤姆猫和超文本传输协议/</id>
    <published>2019-03-20T04:11:39.000Z</published>
    <updated>2019-03-20T04:30:55.947Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><h3 id="Tomcat结构"><a href="#Tomcat结构" class="headerlink" title="Tomcat结构"></a>Tomcat结构</h3><div align="center"><img src="/2019/汤姆猫和超文本传输协议/tomcat目录结构.jpg"></div><h4 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h4><p>用来存放Tomcat的可执行文件：</p><ul><li><code>startup.bat</code>是windows系统下启动Tomcat的可执行文件；</li><li><code>shutdown.bat</code>是windows系统下关闭Tomca的可执行文件。</li><li><code>startup.sh</code>是Linux下的启动Tomcat的可执行文件；</li><li><code>shutdown.sh</code>是linux下关闭Tomca的可执行文件。</li></ul><h4 id="conf"><a href="#conf" class="headerlink" title="conf"></a>conf</h4><p>存放Tomcat服务器全局配置的各种文件。</p><ul><li><code>web.xml</code>：给动态Web工程提供相应的配置，比如Session的过期时间，如果在工程的<code>web.xml</code>中覆盖了同种配置，以工程配置优先。</li><li><code>server.xml</code>：配置和服务器本身相关的信息，如用什么编码集解析URL，</li></ul><h4 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h4><p>存放的是tomcat运行时和项目运行时必须的jar包。如果我们想把某个jar包让所有工程都能使用而不用每个工程都导入，直接将其放入lib文件夹下即可。</p><h4 id="logs"><a href="#logs" class="headerlink" title="logs"></a>logs</h4><p>存放的是日志文件</p><h4 id="webapps"><a href="#webapps" class="headerlink" title="webapps"></a>webapps</h4><p>存放要发布的Web项目。将Web项目打包成War包，放在此目录下，在Tomcat启动时会将War解压并发布。</p><h4 id="work"><a href="#work" class="headerlink" title="work"></a>work</h4><p>用来存放jsp文件文件在运行时产生的java文件和class文件。</p><h2 id="Dynamic-Web项目结构"><a href="#Dynamic-Web项目结构" class="headerlink" title="Dynamic Web项目结构"></a>Dynamic Web项目结构</h2><h3 id="Web项目结构"><a href="#Web项目结构" class="headerlink" title="Web项目结构"></a>Web项目结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">myweb(目录名:项目名)</span><br><span class="line">|</span><br><span class="line">|---资源文件  html img css js   可以存放到文件夹下</span><br><span class="line">|---WEB-INF(目录:特点,通过浏览器直接访问不到)</span><br><span class="line">||</span><br><span class="line">||---lib(目录:项目运行的jar包)</span><br><span class="line">||---classes(目录:存放的class文件)</span><br><span class="line">||---web.xml(核心配置文件,在web2.5版本中必须有,web3.0版本不是必须的)</span><br></pre></td></tr></table></figure><h3 id="手动创建一个Web项目并发布"><a href="#手动创建一个Web项目并发布" class="headerlink" title="手动创建一个Web项目并发布"></a>手动创建一个Web项目并发布</h3><div align="center"><img src="/2019/汤姆猫和超文本传输协议/创建web项目.jpg"></div><ul><li><code>http://localhost:8080/test-web/test.html</code></li></ul><div align="center"><img src="/2019/汤姆猫和超文本传输协议/helloworld.jpg"></div><ul><li><code>http://localhost:8080/test-web/WEB-INF/test.html</code></li></ul><div align="center"><img src="/2019/汤姆猫和超文本传输协议/WEB-INF.jpg"></div><h2 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h2><h3 id="请求行"><a href="#请求行" class="headerlink" title="请求行"></a>请求行</h3><p><code>请求的方式 请求的资源 协议/版本</code>。</p><h3 id="请求头"><a href="#请求头" class="headerlink" title="请求头"></a>请求头</h3><p>key-value类型的数据。</p><ul><li><code>Accept</code>：浏览器可接受的mime类型，如：<code>text/html,image/*</code>。</li><li><code>Accept-Charset</code>：浏览器解析所用哪个的字符集，如：<code>ISO-8859-1</code>。</li><li><code>Accept-Encoding</code>：浏览器能够进行解码的数据编码方式，比如<code>gzip</code>。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。</li><li><code>Accept-Language</code>：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。这个指的是中文、英语这种语言。</li><li><code>Host</code>：被访问的主机。</li><li><code>If-Modified-Since</code>：在发送HTTP请求时，把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较。如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中。</li><li><code>Referer</code>：告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。</li><li><code>User-Agent</code>：浏览器内核。客户端浏览器的信息， 如。<code>Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)</code></li><li><code>Cookie</code>：客户端会话技术。</li></ul><h3 id="请求体"><a href="#请求体" class="headerlink" title="请求体"></a>请求体</h3><p><code>post</code>请求的参数。只有表单提交或异步提交时明确指定<code>method=&quot;post&quot;</code>这时候是post请求，其他的都是get请求。格式：参数名称=值&amp;参数名称=值。</p><h3 id="响应行"><a href="#响应行" class="headerlink" title="响应行"></a>响应行</h3><p><code>版本/协议 响应的状态码 状态码说明</code>。常见的状态码：</p><ul><li><code>200</code>：响应成功</li><li><code>302</code>：重定向</li><li><code>304</code>：读缓存</li><li><code>404</code>：用户访问的数据不存在</li><li><code>500</code>：服务器内部错误</li></ul><h3 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h3><ul><li><p><code>Location</code>：跳转方向，仅配合状态码302使用才有作用，如 <code>https://www.baicu.com</code>。</p></li><li><p><code>Server</code>：服务器型号</p></li><li><code>Content-Encoding</code>：Servlet应该通过查看<code>Accept-Encoding</code>头（即<code>request.getHeader(&quot;Accept-Encoding&quot;)</code>）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</li><li><code>Content-Length</code>：数据长度</li><li>Content-Type: text/html; charset=GB2312 –数据类型</li><li><code>Last-Modified</code>：客户可以通过<code>If-Modified-Since</code>请求头提供一个日期，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。<code>Last-Modified</code>也可用setDateHeader方法来设置。</li><li><code>Refresh</code>：表示浏览器应该在多少时间之后刷新文档，以秒计。但只刷新一次。除了刷新当前文档之外，还可以通过<code>setHeader(&quot;Refresh&quot;, &quot;5; URL=http://host/path&quot;)</code>让浏览器读取指定的页面。</li><li><code>Content-Disposition</code>：指示浏览器不要解析文档，而是以附加形式下载。如<code>attachment; filename=aaa.zip</code>。</li><li><code>Set-Cookie</code>：设置cookie。</li></ul><h3 id="响应体"><a href="#响应体" class="headerlink" title="响应体"></a>响应体</h3><p>浏览器解析的内容。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Tomcat&quot;&gt;&lt;a href=&quot;#Tomcat&quot; class=&quot;headerlink&quot; title=&quot;Tomcat&quot;&gt;&lt;/a&gt;Tom
      
    
    </summary>
    
      <category term="Java Web" scheme="https://isjinhao.github.io/categories/Java-Web/"/>
    
    
      <category term="Java Web" scheme="https://isjinhao.github.io/tags/Java-Web/"/>
    
  </entry>
  
  <entry>
    <title>为什么分页存储管理页面大小是2的n次幂</title>
    <link href="https://isjinhao.github.io/2019/%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F%E6%98%AF2%E7%9A%84n%E6%AC%A1%E5%B9%82/"/>
    <id>https://isjinhao.github.io/2019/为什么分页存储管理页面大小是2的n次幂/</id>
    <published>2019-03-18T10:13:07.000Z</published>
    <updated>2019-03-18T10:28:08.773Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --><p>在分页存储管理方式中，进程中存储的是逻辑地址，通过地址变换机构将逻辑地址转变为物理地址。逻辑地址形式为<code>page: offset</code>。页面大小为什么满足2的n次幂，原因有下：</p><h2 id="方便计算"><a href="#方便计算" class="headerlink" title="方便计算"></a>方便计算</h2><p>如果要将（线性）地址转换为<code>page：offset</code>，则需要将地址除以页面大小，并将整数答案作为页面，将余数作为偏移量。 这是使用编程语言中的整数除法和模数运算符完成的。 计算机将地址表示为数字，存储为二进制位。 这是一个示例地址：<code>12</code>是二进制<code>1100</code>。 如果页面大小为<code>3</code>，那么我们需要计算<code>12/3</code>和<code>12%3</code>来查找页面和偏移量（分别为<code>4</code>、<code>0</code>）。 但是，如果页面大小为<code>4</code>（<code>2</code>的幂），则二进制中的<code>4</code>为<code>100</code>，此时使用特殊的“快捷方式”计算整数除法和模数：右移进行除法，按位与进行取模。所以： <code>12/4 == 12&gt;&gt;2</code>（右移两位） <code>12%4 == 12&amp;(4-1)</code>（<code>1100</code>和<code>11</code>按位与）。同时页面大小转为2进制可以使用左移，可以减小时间开销。</p><h2 id="充分利用空间"><a href="#充分利用空间" class="headerlink" title="充分利用空间"></a>充分利用空间</h2><p>如果页面大小不满足2的n次幂，假如是5，则页内偏移地址，采用2位则每页有一个地址不能使用，采用3位则<code>111</code>、<code>110</code>、<code>101</code>未被使用。怎么做都不能完全利用地址空间。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在分页存储管理方式中，进程中存储的是逻辑地址，通过地址变换机构将逻辑地址转变为物理地址。逻辑地址形式为&lt;code&gt;page: offset&lt;/c
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>05-多表DQL</title>
    <link href="https://isjinhao.github.io/2019/05-%E5%A4%9A%E8%A1%A8DQL/"/>
    <id>https://isjinhao.github.io/2019/05-多表DQL/</id>
    <published>2019-03-17T12:33:03.000Z</published>
    <updated>2019-03-19T12:20:33.791Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --><h2 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：创建 scott 数据库中的 dept 表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dept(</span><br><span class="line">    deptno      <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> <span class="keyword">COMMENT</span> <span class="string">'部门编号'</span>,</span><br><span class="line">    dname       <span class="built_in">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">COMMENT</span> <span class="string">'部门名称'</span>,</span><br><span class="line">    loc         <span class="built_in">VARCHAR</span>(<span class="number">50</span>) <span class="keyword">COMMENT</span> <span class="string">'部门所在位置'</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'部门表'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：创建 scott 数据库中的 emp 表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> emp(</span><br><span class="line">    empno           <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT PRIMARY <span class="keyword">KEY</span> <span class="keyword">COMMENT</span> <span class="string">'雇员编号'</span>,</span><br><span class="line">    ename           <span class="built_in">VARCHAR</span>(<span class="number">15</span>) <span class="keyword">COMMENT</span> <span class="string">'雇员姓名'</span>,</span><br><span class="line">    job             <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">COMMENT</span> <span class="string">'雇员职位'</span>,</span><br><span class="line">    mgr             <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">COMMENT</span> <span class="string">'雇员对应的领导的编号'</span>,</span><br><span class="line">    hiredate        <span class="built_in">DATE</span> <span class="keyword">COMMENT</span> <span class="string">'雇员的雇佣日期'</span>,</span><br><span class="line">    sal             <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">COMMENT</span> <span class="string">'雇员的基本工资'</span>,</span><br><span class="line">    comm            <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">COMMENT</span> <span class="string">'奖金'</span>,</span><br><span class="line">    deptno          <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">COMMENT</span> <span class="string">'所在部门'</span>,</span><br><span class="line">    <span class="keyword">FOREIGN</span> <span class="keyword">KEY</span>(deptno) <span class="keyword">REFERENCES</span> dept(deptno)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'雇员表'</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：创建数据库 scott 中的 salgrade 表，工资等级表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> salgrade(</span><br><span class="line">    grade       <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">COMMENT</span> <span class="string">'工资等级'</span>,</span><br><span class="line">    losal       <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">COMMENT</span> <span class="string">'此等级的最低工资'</span>,</span><br><span class="line">    hisal       <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> <span class="keyword">COMMENT</span> <span class="string">'此等级的最高工资'</span>  </span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'工资等级表'</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：创建数据库 scott 的 bonus 表，工资表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> bonus(</span><br><span class="line">    ename       <span class="built_in">VARCHAR</span>(<span class="number">10</span>) <span class="keyword">COMMENT</span> <span class="string">'雇员姓名'</span>,</span><br><span class="line">    job         <span class="built_in">VARCHAR</span>(<span class="number">9</span>) <span class="keyword">COMMENT</span> <span class="string">'雇员职位'</span>,</span><br><span class="line">    sal         <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">COMMENT</span> <span class="string">'雇员工资'</span>,</span><br><span class="line">    comm        <span class="built_in">DECIMAL</span>(<span class="number">7</span>,<span class="number">2</span>) <span class="keyword">COMMENT</span> <span class="string">'雇员资金'</span>  </span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">INNODB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span>=<span class="string">'工资表'</span>;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：插入数据库 scott 中表 dept 的初始化数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">VALUES</span> (<span class="number">10</span>,<span class="string">'ACCOUNTING'</span>,<span class="string">'NEW YORK'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">VALUES</span> (<span class="number">20</span>,<span class="string">'RESEARCH'</span>,<span class="string">'DALLAS'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">VALUES</span> (<span class="number">30</span>,<span class="string">'SALES'</span>,<span class="string">'CHICAGO'</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> dept <span class="keyword">VALUES</span> (<span class="number">40</span>,<span class="string">'OPERATIONS'</span>,<span class="string">'BOSTON'</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：插入数据库 scott 中表 emp 的初始数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7369</span>,<span class="string">'SMITH'</span>,<span class="string">'CLERK'</span>,<span class="number">7902</span>,<span class="string">'1980-12-17'</span>,<span class="number">800</span>,<span class="literal">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7499</span>,<span class="string">'ALLEN'</span>,<span class="string">'SALESMAN'</span>,<span class="number">7698</span>,<span class="string">'1981-2-20'</span>,<span class="number">1600</span>,<span class="number">300</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7521</span>,<span class="string">'WARD'</span>,<span class="string">'SALESMAN'</span>,<span class="number">7698</span>,<span class="string">'1981-2-22'</span>,<span class="number">1250</span>,<span class="number">500</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7566</span>,<span class="string">'JONES'</span>,<span class="string">'MANAGER'</span>,<span class="number">7839</span>,<span class="string">'1981-4-2'</span>,<span class="number">2975</span>,<span class="literal">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7654</span>,<span class="string">'MARTIN'</span>,<span class="string">'SALESMAN'</span>,<span class="number">7698</span>,<span class="string">'1981-9-28'</span>,<span class="number">1250</span>,<span class="number">1400</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7698</span>,<span class="string">'BLAKE'</span>,<span class="string">'MANAGER'</span>,<span class="number">7839</span>,<span class="string">'1981-5-1'</span>,<span class="number">2850</span>,<span class="literal">NULL</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7782</span>,<span class="string">'CLARK'</span>,<span class="string">'MANAGER'</span>,<span class="number">7839</span>,<span class="string">'1981-6-9'</span>,<span class="number">2450</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7788</span>,<span class="string">'SCOTT'</span>,<span class="string">'ANALYST'</span>,<span class="number">7566</span>,<span class="string">'87-7-13'</span>,<span class="number">3000</span>,<span class="literal">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7839</span>,<span class="string">'KING'</span>,<span class="string">'PRESIDENT'</span>,<span class="literal">NULL</span>,<span class="string">'1981-11-7'</span>,<span class="number">5000</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7844</span>,<span class="string">'TURNER'</span>,<span class="string">'SALESMAN'</span>,<span class="number">7698</span>,<span class="string">'1981-9-8'</span>,<span class="number">1500</span>,<span class="number">0</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7876</span>,<span class="string">'ADAMS'</span>,<span class="string">'CLERK'</span>,<span class="number">7788</span>,<span class="string">'87-7-13'</span>,<span class="number">1100</span>,<span class="literal">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7900</span>,<span class="string">'JAMES'</span>,<span class="string">'CLERK'</span>,<span class="number">7698</span>,<span class="string">'1981-12-3'</span>,<span class="number">950</span>,<span class="literal">NULL</span>,<span class="number">30</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7902</span>,<span class="string">'FORD'</span>,<span class="string">'ANALYST'</span>,<span class="number">7566</span>,<span class="string">'1981-12-3'</span>,<span class="number">3000</span>,<span class="literal">NULL</span>,<span class="number">20</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> emp <span class="keyword">VALUES</span>    (<span class="number">7934</span>,<span class="string">'MILLER'</span>,<span class="string">'CLERK'</span>,<span class="number">7782</span>,<span class="string">'1982-1-23'</span>,<span class="number">1300</span>,<span class="literal">NULL</span>,<span class="number">10</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：插入数据库 scott 中表 salgrade 的初始数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="number">700</span>,<span class="number">1200</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">2</span>,<span class="number">1201</span>,<span class="number">1400</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">3</span>,<span class="number">1401</span>,<span class="number">2000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">4</span>,<span class="number">2001</span>,<span class="number">3000</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> salgrade <span class="keyword">VALUES</span> (<span class="number">5</span>,<span class="number">3001</span>,<span class="number">9999</span>);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">dept( </span><br><span class="line">    DEPTNO,//部门编号，由两位数字所组成</span><br><span class="line">    DNAME,//部门名称，最多由14个字符所组成, </span><br><span class="line">    LOC//部门所在的位置</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">emp(       </span><br><span class="line">    EMPNO,//雇员的编号，由四位数字所组成</span><br><span class="line">    ENAME,//雇员的姓名，由10位字符所组成</span><br><span class="line">    JOB,//雇员的职位</span><br><span class="line">    MGR,//雇员对应的经理编号，经理也是雇员</span><br><span class="line">    HIREDATE,//雇员的雇佣日期</span><br><span class="line">    SAL,//基本工资，其中有两位小数，五倍整数，一共是七位</span><br><span class="line">    COMM,//奖金，佣金</span><br><span class="line">    DEPTNO//雇员所在的部门编号</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">salgrade(  </span><br><span class="line">    GRADE,//工资的等级</span><br><span class="line">    LOSAL,//此等级的最低工资</span><br><span class="line">    HISAL//此等级的最高工资</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">bonus(   </span><br><span class="line">    ENAME,//雇员姓名</span><br><span class="line">    JOB,//雇员职位</span><br><span class="line">    SAL,//雇员的工资</span><br><span class="line">    COMM//雇员的奖金</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>自连接就是自己和自己连接，在使用时将一张表看做多张表使用。</p><ul><li><p>查询员工编号，员工姓名，经理的编号，经理的姓名</p><p>KING没有经理，所以查询出来只有13条记录</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">e1.empno,</span><br><span class="line">e1.ename,</span><br><span class="line">e1.mgr,</span><br><span class="line">m1.ename</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">emp m1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.mgr = m1.empno</span><br></pre></td></tr></table></figure><div align="center"><img src="/2019/05-多表DQL/自连接01.jpg"></div><ul><li>查询员工编号，员工姓名，员工的部门名称，经理的编号，经理的姓名</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">e1.empno,</span><br><span class="line">e1.ename,</span><br><span class="line">d1.dname,</span><br><span class="line">e1.mgr,</span><br><span class="line">m1.ename</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">emp m1,</span><br><span class="line">dept d1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.mgr = m1.empno</span><br><span class="line">    <span class="keyword">AND</span> e1.deptno = d1.deptno</span><br></pre></td></tr></table></figure><div align="center"><img src="/2019/05-多表DQL/自连接02.jpg"></div><ul><li>查询员工编号，员工姓名，员工的部门名称，经理的编号，经理的姓名，经理的部门名称</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">e1.empno,</span><br><span class="line">e1.ename,</span><br><span class="line">d1.dname,</span><br><span class="line">e1.mgr,</span><br><span class="line">m1.ename,</span><br><span class="line">d2.dname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">emp m1,</span><br><span class="line">dept d1,</span><br><span class="line">dept d2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.mgr = m1.empno</span><br><span class="line">    <span class="keyword">AND</span> e1.deptno = d1.deptno</span><br><span class="line">    <span class="keyword">AND</span> m1.deptno = d2.deptno</span><br></pre></td></tr></table></figure><div align="center"><img src="/2019/05-多表DQL/自连接03.jpg"></div><p>这里有一个难点是为什么需要拓展出两张部门表？这里需要理解刚才说的一句话：<code>在使用时将一张表看做多张表使用</code>，想象一下，如果真实存在一张员工表和一张经理表，<code>员工表.部门=部门.id</code>，<code>经理表.部门=部门.id</code>，不就等于是经理和员工在一个部门才能要求吗？这个题意明显不符。</p><ul><li>查询员工编号，员工姓名，员工的部门名称，员工的工资等级，经理的编号，经理的姓名，经理的部门名称</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">e1.empno,</span><br><span class="line">e1.ename,</span><br><span class="line">d1.dname,</span><br><span class="line">s1.grade,</span><br><span class="line">e1.mgr,</span><br><span class="line">m1.ename,</span><br><span class="line">d2.dname</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">emp m1,</span><br><span class="line">dept d1,</span><br><span class="line">dept d2,</span><br><span class="line">salgrade s1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.mgr = m1.empno</span><br><span class="line"><span class="keyword">AND</span> e1.deptno = d1.deptno</span><br><span class="line"><span class="keyword">AND</span> m1.deptno = d2.deptno</span><br><span class="line"><span class="keyword">AND</span> e1.sal <span class="keyword">BETWEEN</span> s1.losal<span class="keyword">AND</span> s1.hisal</span><br></pre></td></tr></table></figure><div align="center"><img src="/2019/05-多表DQL/自连接04.jpg"></div><ul><li>查询员工编号，员工姓名，员工的部门名称，员工的工资等级，经理的编号，经理的姓名，经理的部门名称，员工所属经理的工资等级</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">e1.empno,</span><br><span class="line">e1.ename,</span><br><span class="line">d1.dname,</span><br><span class="line">s1.grade,</span><br><span class="line">e1.mgr,</span><br><span class="line">m1.ename,</span><br><span class="line">d2.dname,</span><br><span class="line">s2.grade</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">emp m1,</span><br><span class="line">dept d1,</span><br><span class="line">dept d2,</span><br><span class="line">salgrade s1,</span><br><span class="line">salgrade s2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.mgr = m1.empno</span><br><span class="line"><span class="keyword">AND</span> e1.deptno = d1.deptno</span><br><span class="line"><span class="keyword">AND</span> m1.deptno = d2.deptno</span><br><span class="line"><span class="keyword">AND</span> e1.sal <span class="keyword">BETWEEN</span> s1.losal <span class="keyword">AND</span> s1.hisal</span><br><span class="line"><span class="keyword">AND</span> m1.sal <span class="keyword">BETWEEN</span> s2.losal <span class="keyword">AND</span> s2.hisal</span><br></pre></td></tr></table></figure><div align="center"><img src="/2019/05-多表DQL/自连接05.jpg"></div><ul><li>查询员工编号，员工姓名，员工的部门名称，员工的工资等级，经理的编号，经理的姓名，经理的部门名称，经理的工资等级（将工资等级 1,2,3,4 显示成 中文的 一级 二级 三级…）</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">e1.empno,</span><br><span class="line">e1.ename,</span><br><span class="line">d1.dname,</span><br><span class="line"><span class="keyword">CASE</span> s1.grade</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'一级'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'二级'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">3</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'三级'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">4</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'四级'</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="string">'五级'</span></span><br><span class="line"><span class="keyword">END</span> <span class="string">"等级"</span>,</span><br><span class="line">e1.mgr,</span><br><span class="line">m1.ename,</span><br><span class="line">d2.dname,</span><br><span class="line"><span class="keyword">CASE</span> s2.grade</span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">1</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'一级'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">2</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'二级'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">3</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'三级'</span></span><br><span class="line"><span class="keyword">WHEN</span> <span class="number">4</span> <span class="keyword">THEN</span></span><br><span class="line"><span class="string">'四级'</span></span><br><span class="line"><span class="keyword">ELSE</span></span><br><span class="line"><span class="string">'五级'</span></span><br><span class="line"><span class="keyword">END</span> <span class="string">"等级"</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">emp m1,</span><br><span class="line">dept d1,</span><br><span class="line">dept d2,</span><br><span class="line">salgrade s1,</span><br><span class="line">salgrade s2</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.mgr = m1.empno</span><br><span class="line"><span class="keyword">AND</span> e1.deptno = d1.deptno</span><br><span class="line"><span class="keyword">AND</span> m1.deptno = d2.deptno</span><br><span class="line"><span class="keyword">AND</span> e1.sal <span class="keyword">BETWEEN</span> s1.losal <span class="keyword">AND</span> s1.hisal</span><br><span class="line"><span class="keyword">AND</span> m1.sal <span class="keyword">BETWEEN</span> s2.losal <span class="keyword">AND</span> s2.hisal</span><br></pre></td></tr></table></figure><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><p>数据准备：<code>insert into emp(empno,ename) values(9527,&#39;HUAAN&#39;);</code></p><p>左外连接以左表为基准，右表能匹配上左表则匹配，右表没有一条记录匹配上左表，左表显示为空。</p><p>右连接是以右表为基准，左表能匹配上右表则匹配，左表没有一条记录匹配上右表，右表显示为空。</p><ul><li>查询员工所在的部门</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept d1 <span class="keyword">ON</span> e1.deptno = d1.deptno;</span><br></pre></td></tr></table></figure><ul><li>查询部门的员工</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1</span><br><span class="line"><span class="keyword">RIGHT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept d1 <span class="keyword">ON</span> e1.deptno = d1.deptno;</span><br></pre></td></tr></table></figure><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><ul><li>查询最高工资的员工信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sal = (<span class="keyword">SELECT</span> <span class="keyword">max</span>(sal) <span class="keyword">FROM</span> emp);</span><br></pre></td></tr></table></figure><ul><li>查询出比雇员7654的工资高,同时和7788从事相同工作的员工信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sal &gt; (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sal</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">empno = <span class="number">7654</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">AND</span> job = (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">job</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">empno = <span class="number">7788</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>查询每个部门最低工资的员工信息和他所在的部门信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询每个部门的最低工资,分组统计</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">deptno,</span><br><span class="line"><span class="keyword">min</span>(sal) minsal</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">deptno;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 员工工资等于他所处部门的最低工资</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">deptno,</span><br><span class="line"><span class="keyword">min</span>(sal) minsal</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">deptno</span><br><span class="line">) t1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.deptno = t1.deptno</span><br><span class="line"><span class="keyword">AND</span> e1.sal = t1.minsal;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询部门相关信息</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1,</span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">deptno,</span><br><span class="line"><span class="keyword">min</span>(sal) minsal</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line">deptno</span><br><span class="line">) t1,</span><br><span class="line">dept d1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.deptno = t1.deptno</span><br><span class="line"><span class="keyword">AND</span> e1.sal = t1.minsal</span><br><span class="line"><span class="keyword">AND</span> e1.deptno = d1.deptno;</span><br></pre></td></tr></table></figure><ul><li>查询领导信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">empno <span class="keyword">IN</span> (<span class="keyword">SELECT</span> mgr <span class="keyword">FROM</span> emp);</span><br></pre></td></tr></table></figure><ul><li>查询不是领导的信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 错误的写法</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">empno <span class="keyword">NOT</span> <span class="keyword">IN</span> (<span class="keyword">SELECT</span> mgr <span class="keyword">FROM</span> emp);</span><br><span class="line"><span class="comment"># &lt;&gt; ALL 等价于 NOT IN</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">empno &lt;&gt; <span class="keyword">ALL</span> (<span class="keyword">SELECT</span> mgr <span class="keyword">FROM</span> emp);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正确的写法</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">empno <span class="keyword">NOT</span> <span class="keyword">IN</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">mgr</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">mgr <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>查询出比20号部门所有员工薪资高的员工信息 10 20 30</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写法1</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sal &gt; (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="keyword">max</span>(sal)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">deptno = <span class="number">20</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写法2</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">sal &gt; <span class="keyword">ALL</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">sal</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">deptno = <span class="number">20</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>查询有员工的部门的信息</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">dept d1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="keyword">EXISTS</span> (</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">*</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">emp e1</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">e1.deptno = d1.deptno</span><br><span class="line">);</span><br></pre></td></tr></table></figure><div align="center"><img src="/2019/05-多表DQL/exist1.jpg"></div><ul><li>补充<code>EXISTS</code></li></ul><p>假设有三张表，学生、课程、选课表。查询选修了全部课程的同学。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">从上面的例子可以看到EXITSTS其实是对外部表的某个字段做循环。循环变量带入内部表后判断</span></span><br><span class="line"><span class="comment">从内部表能否查出来信息，能查出来表示真（留下），查不出来表示假（去除）。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">所以这个题就是对每个学生做循环，把学生带入内部查询，查询学生是否有未选修的课，如果有</span></span><br><span class="line"><span class="comment">学生去除，否则学生留下，所以选用not exists：</span></span><br><span class="line"><span class="comment">select * from student where not exists (学生未选修的课)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">假设某次循环的学号是 110，此时需要拿course中的每个课号到sc表中做循环，查询在sc表的</span></span><br><span class="line"><span class="comment">学号为110且course.no = sc.cno的情况下，记录是否存在，记录存在course去除，记录不存</span></span><br><span class="line"><span class="comment">在course留下，所以选用not exists：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">select * from course where not exists</span></span><br><span class="line"><span class="comment">        select * from sc where 110 = sc.sno and sc.cno = course.no;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">这样，可以查出学号为110的同学未选修的课程。</span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">把两次分析的合并之后：</span></span><br><span class="line"><span class="comment">select * from student where not exists(</span></span><br><span class="line"><span class="comment">select * from course where not exists(</span></span><br><span class="line"><span class="comment">                select * from sc where </span></span><br><span class="line"><span class="comment">                student.no = sc.sno and sc.cno = course.no;</span></span><br><span class="line"><span class="comment">            )</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>现在还是这三张表，我们换个题，查询被所有学生选修的课程信息</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">思路：</span></span><br><span class="line"><span class="comment">对课程做循环，把课程带入内部查询，如果有学生未选此课，课程去除，否则课程留下，</span></span><br><span class="line"><span class="comment">所以选用not exists：：</span></span><br><span class="line"><span class="comment">select * from course where not exists (未被选的课)</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">假设某次循环，课号为120，此时拿student中的每个学号到sc表做循环，查询在sc表的课号为</span></span><br><span class="line"><span class="comment">120且student.no = sc.sno的情况下，记录是否存在，记录存在student去除，记录不存在</span></span><br><span class="line"><span class="comment">student留下，所以选用not exists：：</span></span><br><span class="line"><span class="comment">select * from student where not exists </span></span><br><span class="line"><span class="comment">select * from sc where student.no = sc.sno and 120 = sc.no</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">结果：</span></span><br><span class="line"><span class="comment">两次分析合并</span></span><br><span class="line"><span class="comment">select * from course where not exists(</span></span><br><span class="line"><span class="comment">select * from student where not exists(</span></span><br><span class="line"><span class="comment">select * from sc where </span></span><br><span class="line"><span class="comment">course.no = sc.cno and sc.sno = student.no</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>查询没有一个学生选择的课：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对course做循环，如果存在学生选此课去除，没有学生选此课保留，选用not exists：</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">对内部循环，记录存在保留，记录不存在去除，选用exists：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> course <span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span> student <span class="keyword">where</span> <span class="keyword">exists</span>(</span><br><span class="line">        <span class="keyword">select</span> * <span class="keyword">from</span> sc <span class="keyword">where</span> </span><br><span class="line">        course.no = sc.cno <span class="keyword">and</span> sc.sno = student.no</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;数据准备&quot;&gt;&lt;a href=&quot;#数据准备&quot; class=&quot;headerlink&quot; title=&quot;数据准备&quot;&gt;&lt;/a&gt;数据准备&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>06-虚拟存储器</title>
    <link href="https://isjinhao.github.io/2019/06-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8/"/>
    <id>https://isjinhao.github.io/2019/06-虚拟存储器/</id>
    <published>2019-03-17T06:43:36.000Z</published>
    <updated>2019-03-17T12:30:18.711Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --><h2 id="传统存储器的问题"><a href="#传统存储器的问题" class="headerlink" title="传统存储器的问题"></a>传统存储器的问题</h2><p>传统的内存管理方式要求将一个作业全部装入内存才可以运行，由此造成了以下两种情况：</p><ul><li><p>大作业对内存的要求超出物理内存总容量，致使其无法运行。</p></li><li><p>内存由于容量的限制，只能装入少量的作业使其运行，而其它大量作业留在外存。</p></li></ul><h3 id="解决原理"><a href="#解决原理" class="headerlink" title="解决原理"></a>解决原理</h3><h4 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h4><ol><li>程序执行时， 除了少部分的转移和过程调用指令外，在大多数情况下仍是顺序执行的。</li><li>过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域， 但经研究看出，过程调用的深度在大多数情况下都不超过5。</li><li>程序中存在许多循环结构， 这些虽然只由少数指令构成， 但是它们将多次执行。</li><li>程序中还包括许多对数据结构的处理， 如对数组进行操作， 它们往往都局限于很小的范围内。</li></ol><h4 id="表现两个方面"><a href="#表现两个方面" class="headerlink" title="表现两个方面"></a>表现两个方面</h4><ol><li>时间局限性。如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环。</li><li>空间局限性。一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</li></ol><h4 id="基于局部性原理"><a href="#基于局部性原理" class="headerlink" title="基于局部性原理"></a>基于局部性原理</h4><p>在程序装入时，不必将其全部读入到内存，而只需将当前需要执行的部分页或段读入到内存，就可让程序开始执行。在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统，将相应的页或段调入到内存，然后继续执行程序。</p><h3 id="虚拟存储器定义"><a href="#虚拟存储器定义" class="headerlink" title="虚拟存储器定义"></a>虚拟存储器定义</h3><p>所谓虚拟存储器， 是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、 中、 小型机器和微型机中。</p><h3 id="实现虚拟存储器的条件"><a href="#实现虚拟存储器的条件" class="headerlink" title="实现虚拟存储器的条件"></a>实现虚拟存储器的条件</h3><p>由于一个作业被分成多次地调入内存运行，所以在内存分配时必须采用离散分配方式。同时需要解决以下问题：</p><ul><li>页表（段表）的设计（软件支持）</li><li>程序不在内存时去外存调度需要中断（硬件支持）</li><li>逻辑地址转换为物理地址（软件硬件支持）</li><li>如何给每个进程分配物理块</li><li>一个页（段）进入内存时，淘汰哪个页（段）</li></ul><h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>用于将用户逻辑地址空间变换为内存的物理地址空间。在页表中增加若干项，以便于标志程序或数据的状态。</p><div align="center"><img src="/2019/06-虚拟存储器/页表设计.jpg"></div><ul><li>状态位（存在位）P：表示该页是否调入内存。</li><li>访问字段A：用于记录该页在某段时间内被访问的次数。</li><li>修改位M：表示该页在调入内存后是否被修改过。未修改过不必写回外存，修改要写回外存。</li><li>外存地址：该页在外存上的地址，通常是物理块号。</li></ul><h3 id="缺页中断机构"><a href="#缺页中断机构" class="headerlink" title="缺页中断机构"></a>缺页中断机构</h3><ul><li>在地址映射过程中，在页表中发现所要访问的页不在内存，则产生缺页中断。操作系统接到此中断信号后，就调出缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使进程继续运行下去。</li><li>如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应页表项目的状态位及相应的内存块号。</li><li>若此时内存中没有空闲块，则要淘汰某页，若该页在内存期间被修改过，则要将其写回外存。</li><li>缺页中断发生在指令执行期间，而通常情况下，CPU是在一条指令执行完后，才检查是否有中断请求到达；一条指令在执行期间，可能产生多次缺页中断。所以硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处，继续执行。</li></ul><h3 id="地址转换机构"><a href="#地址转换机构" class="headerlink" title="地址转换机构"></a>地址转换机构</h3><div align="center"><img src="/2019/06-虚拟存储器/请求分页地址转换机构.jpg"></div><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="最小物理块数的确定"><a href="#最小物理块数的确定" class="headerlink" title="最小物理块数的确定"></a>最小物理块数的确定</h4><p>最小物理块数：保证进程正常运行所需的最小物理块数。与计算机的硬件机构有关，取决于指令的格式、功能和寻址方式。</p><h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p>在请求分页中，可采取两种分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置<br>换和局部置换（置换范围不同）。于是组合出三种适用的策略：</p><ul><li>固定分配局部置换：分配固定数目的内存空间，在整个运行期间都不改变。如果缺页，则先从该进程在内存的页面中选中一页，进行换出操作，然后再调入一页。</li><li>可变分配全局置换：每个进程预先分配一定数目的物理块，同时OS也保持一个空闲物理块队列。当缺页时，首先将对OS所占有的空闲块进行分配，从而增加了各进程的物理块数。当OS的空闲块全部用完，将引起换出操作。</li><li>可变分配局部置换：系统根据缺页率动态调整各进程占有的物理块数目，使其保持在一个比较低的缺页率状态下。</li></ul><h4 id="物理块分配算法"><a href="#物理块分配算法" class="headerlink" title="物理块分配算法"></a>物理块分配算法</h4><ul><li><p>平均分配算法：将系统中所有可供分配的物理块，平均分配给各个进程。</p></li><li><p>按比例分配算法：按照进程的大小比例分配物理块。</p></li><li><p>考虑优先权的分配算法：为了对于紧迫的作业，能够尽快完成。可以将内存的物理块分成两部分，一部分按照比例分配给各进程，另一部分根据进程优先级，适当增加其相应的份额，分配给各进程。</p></li></ul><h3 id="页面调入"><a href="#页面调入" class="headerlink" title="页面调入"></a>页面调入</h3><h4 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h4><ul><li><p>提前取页：预先装入主存一页或几页（提前页）。</p></li><li><p>请求取页：当用到某页而不在主存时即缺页时取页。</p></li></ul><h4 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h4><p>外存有两个部分：文件区和对换区。对换区I/O操作速度比文件区相对快一些，因此一般应当尽量使用对换区来调入页面。对于不同情况，采用不同的策略：</p><ul><li><p>系统有足够的对换空间：全部从对换区调入。</p></li><li><p>系统对换空间不足：未修改的从文件区调入，修改的从对换区调入。</p></li><li><p>UNIX的调入方式：未运行过的从文件区调入，运行过的放在对换区，允许页面共享。</p></li></ul><h4 id="页面调入过程"><a href="#页面调入过程" class="headerlink" title="页面调入过程"></a>页面调入过程</h4><ol><li>进程需要的页面不在内存，引起缺页中断</li><li>中断处理程序保留现场环境，转入缺页中断处理程序</li><li>中断处理程序查找页表，得到对应的外存物理块号。如果内存有空闲，则启动磁盘操作，将所缺的页面读入，并修改页表。否则，到4。</li><li>执行置换算法，选出要换出的页面，如果该页修改过，应将其写入磁盘，然后将所缺页调入内存，修改相应表项，将其存在位置为<code>1</code>，并放入快表。</li><li>利用修改后的页表，形成物理地址，访问内存数据。</li></ol><h4 id="缺页率"><a href="#缺页率" class="headerlink" title="缺页率"></a>缺页率</h4><ul><li><p>假设进程逻辑空间为n页，系统为其分配物理块数为<code>m</code>。</p></li><li><p>如果进程运行过程中，访问页面成功次数为S，访问页面失败次数为F，总页面访问次数<code>A=S+F</code>，则进程运行过程中 缺页率<code>f=F/A</code>。</p></li></ul><p>影响缺页率的主要因素：</p><ul><li><p>页面大小：页面越大，缺页率越小</p></li><li><p>进程所分配物理块数：物理块越多，缺页率越小</p></li><li><p>页面置换算法：合理的置换算法能更少将页面调入调出</p></li><li><p>程序固有特性：比如做循环操作时，缺页率较低，因为执行的命令都是一系列大致相同的指令。</p></li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h4><p>所选择的被淘汰页面，将是以后永不使用的， 或许是在最长（未来）时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。这是一种理想情况，是实际执行中无法预知的，因而不能实现。可用作性能评价的依据。</p><p>例：假定系统为某进程分配了三个物理块， 并考虑有以下的页面号引用串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure><p>进程运行时， 先将7，0，1三个页面装入内存。 以后， 当进程要访问页面2时， 将会产生缺页中断。此时OS根据最佳置换算法， 将选择页面7予以淘汰。</p><div align="center"><img src="/2019/06-虚拟存储器/最佳置换算法.jpg"></div><h4 id="先进先出页面置换算法"><a href="#先进先出页面置换算法" class="headerlink" title="先进先出页面置换算法"></a>先进先出页面置换算法</h4><p>选择装入最早的页面被置换。可以通过链表来表示各页的建立时间先后。</p><div align="center"><img src="/2019/06-虚拟存储器/先进先出算法.jpg"></div><h4 id="最近最久未使用置换算法"><a href="#最近最久未使用置换算法" class="headerlink" title="最近最久未使用置换算法"></a>最近最久未使用置换算法</h4><p>选择内存中最久未使用的页面被置换。这是局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。</p><div align="center"><img src="/2019/06-虚拟存储器/LRU.jpg"></div><h5 id="硬件支持"><a href="#硬件支持" class="headerlink" title="硬件支持"></a>硬件支持</h5><ul><li><p>寄存器：每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，于是寄存器数<br>值最小的是最久未使用页面。</p><div align="center"><img src="/2019/06-虚拟存储器/寄存器LRU.jpg"></div></li></ul><ul><li><p>栈：一个特殊的栈，每当进程访问某页面时，便把被访问的页面移到栈顶，于是栈底的是最久未使用页面。</p><div align="center"><img src="/2019/06-虚拟存储器/栈LRU.jpg"></div></li></ul><h4 id="最少使用置换算法"><a href="#最少使用置换算法" class="headerlink" title="最少使用置换算法"></a>最少使用置换算法</h4><p>选择到当前时间为止被访问次数最少的页面被置换。</p><ul><li>实现方法1：每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，这样，在最近一段时间内时用最少的页面将是$\sum_{R_i}$最小的页。</li><li>实现方法2：每页设置访问计数器，每当页面被访问时，该页面的访问计数器加1；发生缺页中断时，淘汰计数值最小的页面，并将所有计数清零。</li></ul><h4 id="Clock置换算法"><a href="#Clock置换算法" class="headerlink" title="Clock置换算法"></a>Clock置换算法</h4><p>也称最近未使用算法（NRU, Not Recently Used），它是LRU（最近最久未使用算法）和FIFO的折衷。</p><p>内存中所有页面通过链接指针形成一个循环队列，每页有一个使用访问位，若该页被访问则置1。置换时采用一个指针，从当前指针位置开始按地址先后检查各页，寻找访问位为0的页面作为被置换页。指针经过的访问位为1的页都修改0，最后指针停留在被置换页的下一个页。</p><h4 id="改进Clock置换算法"><a href="#改进Clock置换算法" class="headerlink" title="改进Clock置换算法"></a>改进Clock置换算法</h4><p>由于Clock算法不考虑换出页面时，页面是否修改过的问题。这样在换出的页面如果被修改过的话，则必须做拷回磁盘处理，开销比较大。于是，改进型的Clock算法为每个页又增加了一个修改位。选择页面时，尽量选择既未使用又没有修改的页面。</p><p>访问位A，修改位M有四种不同情形：</p><ul><li><p>1类(A=0，M=0）既未访问，又没有修改，最佳淘汰页</p></li><li><p>2类(A=0，M=1）未访问，但是有修改，效率低的淘汰页</p></li><li><p>3类(A=1，M=0）被访问，但没有修改</p></li><li><p>4类(A=1，M=1）既被访问，又有修改</p></li></ul><p>算法：</p><ol><li>指针从当前位置开始，开始第一轮扫描循环队列，寻找A=0且M=0的页面，找到则可换出。</li><li>如果找不到，则开始第二轮扫描，寻找A=0且M=1的页面，并且每经过一个页面时，将其访问位A设置为0。如果找到一个第2类页面，则可换出。</li><li>如果仍旧未找到合适的换出页面，则此时指针回到初始位置，且所有页面其访问位A为0。再转回1继续工作。</li></ol><h4 id="页面缓冲算法"><a href="#页面缓冲算法" class="headerlink" title="页面缓冲算法"></a>页面缓冲算法</h4><p>在请求分页系统中，进程在运行的时候经常会发生页面换进换出的情况。而影响换进换出效率的原因如下：</p><ul><li>页面置换算法：好的页面置换算法能使进程运行中具有较低的缺页率，从而可以减少换进换出的开销。</li><li>写会磁盘的频率。</li><li>读入内存的频率。</li></ul><p>而页面缓存算法就是降低读写磁盘的频率来降低开销。做法如下：</p><ul><li>空闲页面链表：当有一个未被修改的页要换出时，实际上并不将其换出到外存，而是把它们所在的物理块挂在空闲链表的末尾。如果以后某进程请求此页时，便将其从空闲页面链表上取下。</li><li>修改页面链表：和空闲页面链表的功能一样，只是说此链表是存放已修改页面的。</li></ul><p>当链表上挂有足够多的页面时，将它们一齐写入磁盘，这样可以降低读写磁盘的频率。</p><h3 id="访问内存的有效时间"><a href="#访问内存的有效时间" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3><ul><li><p>被访问页在主存，且相应页表项在快表：$EAT= \lambda +t$</p><ul><li>查找快表+访问实际物理地址</li></ul></li><li><p>被访问页在主存，但相应页表项不在快表：$ EAT= \lambda +t + t + \lambda$</p><ul><li>查找快表+读取页表+读取数据+更新快表</li></ul></li><li><p>被访问页不在主存：$EAT= \lambda + t + \varepsilon + t + \lambda​$</p><ul><li>查找快表+读取页表+缺页中断处理+读取数据+等新快表</li></ul></li><li><p>内存的有效访问时间为：$EAT= \lambda + t + (1 - a ) \ast [f \ast ( \varepsilon + \lambda + t)+(1-f) \ast(\lambda+t)]$</p><ul><li><code>a</code>为命中率，<code>f</code>为缺页率。</li><li>查找快表+访问内存一次+未命中不需要请求缺页访问快表+未命中时不需要请求缺页访问内存+未命中需要请求缺页访问快表+未命中时需要请求缺页访问内存+未命中时需要请求缺页开销。</li></ul></li></ul><h2 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h2><h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>由于只装入一个进程的部分程序和数据便可开始运行，故希望运行更多进程，增加多道程序度。但在多道程序环境下，并不是多道程序的度越高，系统吞吐量越大。当CPU的利用率达到某一峰值后，若继续增加多道程度，将产生“抖动”。</p><p>抖动是指同时运行进程太多，分配给每个进程物理块太少，进程在运行时频繁缺页，必须请求调页，等待页面调进调出的进程增多，磁盘访问时间急剧增加，进程大部分时间用于页面换进换出，处理机利用率急剧下降并趋于0。</p><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>基于程序运行的局部性原理，程序运行时，对页面的访问并不均匀，一段时间仅局限于较少的页面；另一段时间，有可能局限于另一些较少的页面，如果能预知这些页面，并提前调入，将大大减少缺页率工作集，是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。</p><ul><li>方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。</li></ul><p>定义：是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。</p><ul><li>方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。</li></ul><p>工作集$ \omega (t, \Delta) $是二元函数。某进程在时间<code>t</code>的工作集记为$ \omega (t, \Delta) $，其中，$\Delta$为工作集的窗口尺寸。</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><ul><li><p>窗口大小$\Delta$选择得过小，频繁产生缺页中断。</p></li><li><p>窗口大小$\Delta$选择得很大，失去了虚拟存储器的意义</p></li></ul><div align="center"><img src="/2019/06-虚拟存储器/工作集.jpg"></div><h3 id="抖动的预防方法"><a href="#抖动的预防方法" class="headerlink" title="抖动的预防方法"></a>抖动的预防方法</h3><ul><li><p>采取局部置换策略：仅允许进程在自身范围内进行置换，不影响其他进程</p></li><li><p>在CPU调度程序中引入工作集算法：调入新作业时，应该检查每个进程在内存中的驻留集是否足够大</p></li><li><p><code>L=S</code>准则：<code>产生缺页的平均时间L=系统处理进程缺页的平均时间S</code></p></li><li><p>选择暂停的进程：使某些低优先级的进程进程挂起，从而腾出内存空间</p></li></ul><h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><ul><li><p>请求分页系统建立的虚拟存储器，是以页面为单位进行换入、换出操作的。</p></li><li><p>在请求分段系统中实现的虚拟存储器，以分段为单位进行换入和换出。</p></li><li><p>程序在运行之前，只需要装入必要的若干个分段即可运行。当访问的分段不在内存时，可由OS将所缺少的段调入内存。</p></li></ul><p>使用请求分段存储管理方式可以对动态链接有很好的支持。</p><h3 id="请求段表机制"><a href="#请求段表机制" class="headerlink" title="请求段表机制"></a>请求段表机制</h3><div align="center"><img src="/2019/06-虚拟存储器/段表.jpg"></div><ul><li><p>存取方式：标记本段存取属性。如读R，写W，执行X</p></li><li><p>访问字段A：记录本段使用的频繁程度</p></li><li><p>修改位：是否在调入内存后做过修改</p></li><li><p>存在位：本段是否装入内存</p></li><li><p>增补位：该段是否动态增长过</p></li></ul><h3 id="缺段中断机构"><a href="#缺段中断机构" class="headerlink" title="缺段中断机构"></a>缺段中断机构</h3><p>要有专门的缺段中断处理程序。特点：</p><ul><li>指令和操作数必定不会跨越在段边界上。</li><li>由于段的长度是不固定的，处理比缺页系统复杂。</li><li>调入一个段可能要淘汰几个内存中的段。</li></ul><h3 id="请求中断处理"><a href="#请求中断处理" class="headerlink" title="请求中断处理"></a>请求中断处理</h3><div align="center"><img src="/2019/06-虚拟存储器/请求中断处理.jpg"></div><h3 id="地址中断机构"><a href="#地址中断机构" class="headerlink" title="地址中断机构"></a>地址中断机构</h3><div align="center"><img src="/2019/06-虚拟存储器/地址变换机构.jpg"></div><h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3><h4 id="共享段表"><a href="#共享段表" class="headerlink" title="共享段表"></a>共享段表</h4><div align="center"><img src="/2019/06-虚拟存储器/共享段表.jpg"></div><ul><li>共享进程计数：多少进程在使用此段。</li><li>存取控制手段：每个共享段，应为不同进程赋予不同的存取权限。</li><li>断号：同一个共享段在不同进程那有不同的断号。</li></ul><h4 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h4><p>第一个请求的进程，由系统分配一物理块，调入共享段，设置相关表项信息，并置<code>count=1</code>； 以后的进程，在自己的段表中增加一项，填入共享段的信息，在共享段表项中做<code>count=count+1</code>，填写进程相关信息。</p><h4 id="回收"><a href="#回收" class="headerlink" title="回收"></a>回收</h4><ol><li>做count=count-1；</li><li>若count=0 ，则该共享段被回收。</li></ol><h4 id="分段保护"><a href="#分段保护" class="headerlink" title="分段保护"></a>分段保护</h4><ul><li>越界检查：在进行存储访问时，要将逻辑地址的段号与段表长度进行比较，如果超出则发生越界中断信号；其次，将段内地址与段表中该段的长度进行比较，如果有效才进行转换，否则产生越界中断信号。</li><li><p>存取控制检查：用于规定对该段的访问权限。通常的访问方式有：</p><ul><li>读：允许用户对该段/页内任何信息或其副本进行读操作。</li><li>写：允许用户修改该段/页内任何信息直至撤消整个段/页。</li><li>执行：用户可以执行该段/页程序，数据段/页除外。</li><li>增加：用户可在段/页的末尾添加信息，但不允许修改已存在于段/页中的信息。</li></ul></li><li><p>环保护检查：是一种功能较完善的保护机制。</p><ul><li>思想：将所有的程序分成不同的级别，分别放置在不同的环上。内环（编号小，在内侧）的程序具有高优先权，外环的程序优先权低。</li><li>操作系统核心安排在0环内；重要程序和操作系统服务安排在中间环；一般应用程序安排在外环。</li><li>一个程序可以直接访问在相同环或低优先级环（比自身相对靠外的环）上的数据。</li><li>一个程序访问高优先级（比自己靠内的环）时，通过系统调用方式实现。</li></ul></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;传统存储器的问题&quot;&gt;&lt;a href=&quot;#传统存储器的问题&quot; class=&quot;headerlink&quot; title=&quot;传统存储器的问题&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>redis入门</title>
    <link href="https://isjinhao.github.io/2019/redis%E5%85%A5%E9%97%A8/"/>
    <id>https://isjinhao.github.io/2019/redis入门/</id>
    <published>2019-03-16T03:06:04.000Z</published>
    <updated>2019-03-16T11:33:11.558Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p>本人使用的是<code>redis-3.0.0</code>和<code>阿里云centos7</code>服务器。</p><ul><li><p>上传<code>redis-3.0.0</code>到服务器。</p></li><li><p>安装<code>gcc</code>环境：<code>yum install gcc-g++</code></p></li><li><p>解压<code>redis-3.0.0</code>：<code>tar -zxvf ...</code></p></li><li><p>进入解压后的<code>redis</code>文件夹</p></li><li><p>执行：<code>make</code></p></li><li><p>安装：<code>make PREFIX=/usr/local/redis install</code></p></li><li><p>拷贝<code>redis</code>文件夹的<code>redis.conf</code>到<code>/usr/local/redis</code>下</p></li><li><p>修改<code>/usr/local/redis</code>下的<code>redis.conf</code>，搜索以<code>daemonize</code>开头的行，将此行修改为<code>daemonize yes</code>。修改后<code>redis</code>以后台进程运行。</p></li><li><p>开放端口：<code>redis</code>默认端口是<code>6379</code>。</p><ol><li><p><code>/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT</code></p></li><li><div align="center"><img src="/2019/redis入门/开放端口.jpg"></div></li></ol></li><li><p>启动服务器：<code>./xxx/redis-server xxx/redis.conf</code></p></li><li><p>使用客户端连接服务器：<code>./xxx/redis-cli -h ip地址 -p 6379</code></p></li><li><p>连接测试：<code>ping</code>显示<code>PONG</code>表名成功</p><div align="center"><img src="/2019/redis入门/连接成功.jpg"></div></li><li><p>关闭客户端：<code>quit</code></p></li><li><p>关闭服务器：<code>./bin/redis-cli shutdown</code></p></li></ul><h2 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h2><h3 id="存储string"><a href="#存储string" class="headerlink" title="存储string"></a>存储<code>string</code></h3><ul><li><p>设置：<code>set key value</code></p></li><li><p>取值：<code>get key</code></p></li><li><p>删除：<code>del username</code></p></li></ul><div align="center"><img src="/2019/redis入门/string赋值取值删除.jpg"></div><ul><li>数值相加减<ul><li>加一：<code>incr key</code></li><li>减一：<code>decr key</code></li><li>加x：<code>incrby key x</code></li><li>减x：<code>decrby key x</code></li></ul></li></ul><div align="center"><img src="/2019/redis入门/string数值相加减.jpg"></div><ul><li>字符串拼接</li></ul><div align="center"><img src="/2019/redis入门/string拼接.jpg"></div><h3 id="存储Map"><a href="#存储Map" class="headerlink" title="存储Map"></a>存储<code>Map</code></h3><ul><li><p>赋值：</p></li><li><p>赋多值：</p><div align="center"><img src="/2019/redis入门/map赋值.jpg"></div></li><li><p>取值：</p><div align="center"><img src="/2019/redis入门/map取值.jpg"></div></li><li><p>删除字段：</p></li><li><p>删除map：</p><div align="center"><img src="/2019/redis入门/map删除.jpg"></div></li><li><p>判断字段存在：</p></li><li><p>获取全部entry：</p></li><li><p>获取全部key：</p></li><li><p>获取全部value：</p><div align="center"><img src="/2019/redis入门/map补充.jpg"></div></li></ul><h3 id="存储list"><a href="#存储list" class="headerlink" title="存储list"></a>存储list</h3><ul><li><p>头部添加：</p></li><li><p>尾部添加：</p><div align="center"><img src="/2019/redis入门/list两端添加.jpg"></div><div align="center"><img src="/2019/redis入门/查看列表值个数.jpg"></div></li><li><p>查看列表：</p><div align="center"><img src="/2019/redis入门/查看链表.jpg"></div></li><li><p>头部弹出：</p></li><li><p>尾部弹出：</p><div align="center"><img src="/2019/redis入门/两端弹出.jpg"></div></li><li><p><code>lpushx key value</code>：仅当<code>key</code>存在时才向头部插入</p></li><li><p><code>rpush key value</code>：仅当<code>key</code>存在时才向尾部插入</p></li><li><p>删除：<code>irem key count value</code>：<code>count&gt;0</code>时从头部开始删除<code>|count|</code>个值为<code>value</code>的元素；<code>count&lt;0</code>时从尾部开始删除<code>|count|</code>个值为<code>value</code>的元素；<code>count=0</code>时删除全部的值为<code>|value|</code>的元素。</p></li><li><p>设置：<code>lset key index value</code>：设置链表中索引值为<code>index</code>的元素，<code>0</code>是链表头，<code>-1</code>是链表尾。索引值不存在抛异常。</p></li><li><p><code>lindex key index</code>：通过索引获取列表中的元素</p></li><li><p><code>linsert key before|after pivot value</code>：在列表的元素前或者后插入元素</p></li><li><p><code>rpoplpush source destination</code>：移除列表的最后一个元素，并将该元素添加到另一个列表并返回</p></li></ul><h3 id="存储set"><a href="#存储set" class="headerlink" title="存储set"></a>存储<code>set</code></h3><ul><li><code>SADD key member1 member2...</code>：向集合添加一个或多个成员</li><li><p><code>SREM key member1 member2...</code>：移除集合中一个或多个成员</p></li><li><p><code>SISMEMBER key member</code>：判断 member 元素是否是集合 key 的成员</p><ul><li>1：存在</li><li>0：key不存在或member不存在</li></ul></li><li><p><code>sdiff key1 key2</code>：返回集合<code>key1-key2</code>的数据</p></li><li><p><code>sinter key1 key2 ...</code>：返回集合<code>key1,key2,...</code>的交集</p></li><li><p><code>sunion key1 key2 ...</code>：返回集合<code>key1,key2,...</code>的并集</p></li><li><p><code>scard key</code>：返回集合的数量</p></li><li><p><code>srandmember key</code>：随机返回集合中的一个数据</p></li><li><p>集合运算拓展</p><div align="center"><img src="/2019/redis入门/集合运算拓展.jpg"></div></li></ul><h3 id="存储sortedset"><a href="#存储sortedset" class="headerlink" title="存储sortedset"></a>存储<code>sortedset</code></h3><p>有序集合和集合一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。</p><ul><li><code>ZADD key score1 member1 [score2 member2]</code>：向有序集合添加一个或多个成员，或者更新已存在成员的分数。</li><li><code>ZSCORE key member</code>：返回有序集中，成员的分数值。</li><li><code>ZREM key member1 member2 ...</code>：移除有序集合中的一个或多个成员</li><li><code>ZRANGE key start stop [WITHSCORES]</code>：通过索引区间返回有序集合成指定区间内的成员。<code>withscores</code>表示返回的成员包含分数。</li><li><code>ZREVRANGE key start stop [WITHSCORES]</code>：返回有序集中指定区间内的成员，通过索引，分数从高到底。<code>withscores</code>表示返回的成员包含分数。</li><li><code>ZREMRANGEBYRANK key start stop</code>：移除有序集合中给定的排名区间的所有成员</li><li><code>ZREMRANGEBYSCORE key min max</code>：移除有序集合中给定的分数区间的所有成员</li></ul><h2 id="keys的通用操作"><a href="#keys的通用操作" class="headerlink" title="keys的通用操作"></a>keys的通用操作</h2><ul><li><code>keys pattern</code>：获取所有和<code>pattern</code>匹配的key。</li><li><code>del key1, key2, ...</code>：删除指定key。</li><li><code>exists key</code>：<code>key</code>是否存在。</li><li><code>rename key newkey</code>：为当前的<code>key</code>重命名。</li><li><code>expire key</code>：为<code>key</code>设置过期时间，单位：秒。</li><li><code>ttl key</code>：获取<code>key</code>所剩的时间，如果没有设置超时，返回<code>-1</code>，<code>key</code>不存在返回<code>-2</code>。</li><li><code>type key</code>：以字符串形式返回<code>key</code>的类型。<code>key</code>不存在返回<code>none</code>。</li></ul><h2 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h2><p><code>jedis</code>是<code>Java</code>操作<code>redis</code>的一套规范。使用<code>jedis</code>需要有两个包。<code>commons-pool2-2.3.jar</code>和<code>jedis-2.7.0.jar</code>。</p><h3 id="入门使用"><a href="#入门使用" class="headerlink" title="入门使用"></a>入门使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Jedis jedis = <span class="keyword">new</span> Jedis(<span class="string">"59.110.143.226"</span>, <span class="number">6379</span>);</span><br><span class="line">jedis.set(<span class="string">"name"</span>, <span class="string">"zhangsan"</span>);</span><br><span class="line">String string = jedis.get(<span class="string">"name"</span>);</span><br><span class="line">System.out.println(string);</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工具类连接"><a href="#工具类连接" class="headerlink" title="工具类连接"></a>工具类连接</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">maxTotal=20</span><br><span class="line">maxWaitMillis=7000</span><br><span class="line">host=59.110.143.226</span><br><span class="line">port=6379</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JedisPoolUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisPoolConfig jc = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> maxTotal = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> maxWaitMillis = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String host = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> port=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> JedisPool pool=<span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">jc=<span class="keyword">new</span> JedisPoolConfig();</span><br><span class="line"><span class="comment">//获取properties中的配置数据</span></span><br><span class="line">ResourceBundle re = ResourceBundle.getBundle(<span class="string">"jedis"</span>);</span><br><span class="line">maxTotal=Integer.parseInt(re.getString(<span class="string">"maxTotal"</span>));</span><br><span class="line">maxWaitMillis=Long.parseLong(re.getString(<span class="string">"maxWaitMillis"</span>));</span><br><span class="line"></span><br><span class="line">jc.setMaxTotal(maxTotal);</span><br><span class="line">jc.setMaxWaitMillis(maxWaitMillis);</span><br><span class="line">host = re.getString(<span class="string">"host"</span>);</span><br><span class="line">port = Integer.parseInt(re.getString(<span class="string">"port"</span>));</span><br><span class="line"><span class="comment">//创建Jedis池</span></span><br><span class="line">    pool=<span class="keyword">new</span> JedisPool(jc, host, port);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Jedis <span class="title">getJedis</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> pool.getResource();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUtils</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Jedis jedis=JedisPoolUtils.getJedis();</span><br><span class="line">jedis.set(<span class="string">"username2"</span>, <span class="string">"xiaowang"</span>);</span><br><span class="line">String string = jedis.get(<span class="string">"username2"</span>);</span><br><span class="line">System.out.println(string);</span><br><span class="line">jedis.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h2><p><code>redis</code>的一个实例可以有多个数据库，就像一个<code>mysql</code>可以有多个数据库一样。一个<code>redis</code>实例最多可以提供16个数据库，下标从0到15，默认是0号数据库，连接其他数据库使用<code>select num</code>。</p><div align="center"><img src="/2019/redis入门/redis选择数据库.jpg"></div><ul><li>移动<code>key</code>到指定数据库</li></ul><div align="center"><img src="/2019/redis入门/移动key.jpg"></div><h2 id="消息订阅与发布"><a href="#消息订阅与发布" class="headerlink" title="消息订阅与发布"></a>消息订阅与发布</h2><p>订阅就是一个客户端在某个频道里发消息，其它订阅到此频道的客户端接收消息。</p><ul><li><p>订阅：</p><div align="center"><img src="/2019/redis入门/订阅到单频道.jpg"></div></li><li><p>发布消息：</p><div align="center"><img src="/2019/redis入门/发布消息.jpg"></div></li><li><p>批量订阅：</p><div align="center"><img src="/2019/redis入门/批量订阅.jpg"></div></li><li><p>发布消息：</p><div align="center"><img src="/2019/redis入门/批量订阅发布.jpg"></div></li></ul><h2 id="redis持久化"><a href="#redis持久化" class="headerlink" title="redis持久化"></a>redis持久化</h2><h3 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h3><p>每隔指定时间自动把内存中数据写入一个文件，下次启动时加载文件，这样内存中就有上次的数据。<code>redis</code>默认的持久化方式。</p><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>在<code>redis.conf</code>的140多行有如下配置是RDB配置。</p><div align="center"><img src="/2019/redis入门/RDB配置.jpg"></div><ul><li><code>save 900 1</code>：每900秒至少有1个key发生变化，则备份内存快照。</li><li><code>save 300 10</code>：每300秒至少有10个key发生变化，则备份内存快照。</li><li><code>save 60 10000</code>：每60秒至少有10000个key发生变化，则备份内存快照。</li></ul><p>位置：</p><div align="center"><img src="/2019/redis入门/RDB位置.jpg"></div><h3 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h3><p>把对<code>redis</code>的操作存在一个文件中，下次开机时按照文件的记录再次将数据存在内存中。</p><h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p><code>appendonly no</code>改为<code>appendonly yes</code>。</p><div align="center"><img src="/2019/redis入门/aof开启.jpg"></div><div align="center"><img src="/2019/redis入门/aof配置2.jpg"></div><ul><li><code>appendfsync always</code>：每次有数据修改时，都会写入AOF文件</li><li><code>appendfsync everysec</code>：每秒同步一次，写入AOF文件</li><li><code>appendfsynv no</code>：从不同步。</li></ul><p>手动重写aof文件命令：<code>bgrewriteaof</code>。</p><h2 id="启动多个redis"><a href="#启动多个redis" class="headerlink" title="启动多个redis"></a>启动多个redis</h2><ol><li>拷贝安装目录下的<code>redis</code>文件夹</li><li>修改<code>redis.conf</code>文件的端口号</li><li>启动<code>redis</code>时指定配置文件，保证端口号不同</li><li>关闭时指定端口号，如：<code>./bin/redis-cli -p 端口号 shutdown</code></li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;环境安装&quot;&gt;&lt;a href=&quot;#环境安装&quot; class=&quot;headerlink&quot; title=&quot;环境安装&quot;&gt;&lt;/a&gt;环境安装&lt;/h2&gt;
      
    
    </summary>
    
      <category term="redis" scheme="https://isjinhao.github.io/categories/redis/"/>
    
    
      <category term="redis" scheme="https://isjinhao.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>05-内存管理</title>
    <link href="https://isjinhao.github.io/2019/05-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>https://isjinhao.github.io/2019/05-内存管理/</id>
    <published>2019-03-15T04:23:48.000Z</published>
    <updated>2019-03-18T10:30:12.514Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --><h2 id="存储器的层次"><a href="#存储器的层次" class="headerlink" title="存储器的层次"></a>存储器的层次</h2><p>我们都知道存储器的容量和速度是限制计算机发展的一大原因，人们对存储器的要求需要既快又大，但是这样带来的结果就是存储器的造价非常昂贵，所以不可能在计算机中全部配置既快又大的存储器。所以现代的计算机系统中都配置了多层结构的存储器系统来平衡速度差异问题。</p><div align="center"><img src="/2019/05-内存管理/存储器分级.jpg"></div><p>存储器一般被分成六层，不过在只有前四层属于内存，所以此篇只介绍前四层：</p><h3 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h3><ul><li><p>用于保存进程运行时的程序和数据。</p></li><li><p>对于微机系统和大中型机，容量为数十MB到数GB；对于嵌入式系统，容量为数十KB到数MB。</p></li><li>CPU从主存读取指令和数据。</li><li>CPU与外设交换信息要依托主存。</li><li>为缓解CPU执行指令速度和主存访问速度的矛盾，引入寄存器和高速缓冲。</li></ul><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ul><li><p>访问速度做快，完全与CPU协调工作，价格十分昂贵，容量不可能很大。</p></li><li><p>长度一般以字为单位。</p></li><li><p>对于微机系统和大中型机，可能有几十个甚至上百个；对于嵌入式系统，仅有几个到几十个。</p></li></ul><h3 id="高速缓冲"><a href="#高速缓冲" class="headerlink" title="高速缓冲"></a>高速缓冲</h3><ul><li><p>容量大于或远大于寄存器，比内存小两到三个数量级左右，从几十KB到几MB。</p></li><li><p>访问速度快于主存。</p></li><li><p>将主存中经常访问的信息存放在高速缓冲，减少访问主存次数。</p></li></ul><h3 id="磁盘缓冲"><a href="#磁盘缓冲" class="headerlink" title="磁盘缓冲"></a>磁盘缓冲</h3><ul><li><p>将一部分频繁使用的磁盘数据和信息，暂时存放在磁盘缓冲中，减少访问磁盘次数。</p></li><li><p>不是实际存在的存储介质，利用主存的存储空间，暂存从磁盘读出或写入的信息。</p></li></ul><p>总结一下：磁盘缓冲是为了解决内存和外存的速度差异而在内存中开辟的一块用于暂存磁盘数据的存储介质。主存储器是保存进程运行时的程序和数据的。寄存器是和CPU速度匹配的存储器，直接给CPU提供数据。虽然CPU是直接从寄存器去取指令和数据，但是寄存器的数据来源最终还是主存储器，所以为了减少访问CPU的次数，产生了高速缓冲来缓和寄存器和主存储器的矛盾。至于为什么能缓和呢？这是由于<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/15572003" target="_blank" rel="noopener">程序局部性原理</a>。</p><h2 id="程序的装入和链接"><a href="#程序的装入和链接" class="headerlink" title="程序的装入和链接"></a>程序的装入和链接</h2><p>用户程序要在系统中运行，必须将它装入内存，其中有三个过程。</p><ul><li><p>编译：由编译程序（Complier）将用户源代码编译成若干个目标模块（Object Module）；</p></li><li><p>链接：由链接程序（Linker）将编译后形成的目标模块以及它们所需要的库函数，链接在一起，形成一个装入模块（Load Module）；</p></li><li>装入：由装入程序(Loader)将装入模块装入内存。</li></ul><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>链接程序的功能是将经过编译或汇编后得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块。</p><h4 id="静态链接方式"><a href="#静态链接方式" class="headerlink" title="静态链接方式"></a>静态链接方式</h4><p>生成可执行文件时进行链接。主要有两步。</p><ol><li>修改相对地址。</li><li>变换外部调用符号。</li></ol><h4 id="装入时动态链接"><a href="#装入时动态链接" class="headerlink" title="装入时动态链接"></a>装入时动态链接</h4><p>目标模块是在装入内存时，边装入边链接的。装入时动态链接方式有以下优点：</p><ul><li><p>便于修改和更新。</p></li><li><p>便于实现对目标模块的共享。</p></li></ul><h4 id="运行时动态链接"><a href="#运行时动态链接" class="headerlink" title="运行时动态链接"></a>运行时动态链接</h4><p>将对某些模块的链接推迟到执行时才执行，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存， 把它链接到调用者模块上。</p><p>凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。</p><h3 id="装入"><a href="#装入" class="headerlink" title="装入"></a>装入</h3><p>装入是将一个具有执行资格的模块加载进内存。</p><h4 id="绝对装入方式"><a href="#绝对装入方式" class="headerlink" title="绝对装入方式"></a>绝对装入方式</h4><p>在可执行文件中指定内存地址，装入时直接定位在上述（即文件中记录的地址）内存地址。逻辑地址和物理地址完全相同。</p><h4 id="可重定位装入方式"><a href="#可重定位装入方式" class="headerlink" title="可重定位装入方式"></a>可重定位装入方式</h4><p>编译程序所生成的目标模块中采用逻辑地址，根据当前内存情况，将装入模块装入到适当位置。地址映射是在装入模块装入内存时一次性进行的，即是静态重定位。</p><div align="center"><img src="/2019/05-内存管理/静态重定位.jpg"></div><h4 id="动态运行时装入方式"><a href="#动态运行时装入方式" class="headerlink" title="动态运行时装入方式"></a>动态运行时装入方式</h4><p>静态重定位时程序装入内存后不能移动，而且通常需要占用连续的内存空间。所以与其对应的动态重定位是将地址映射工作推迟到程序真正执行时才进行。</p><div align="center"><img src="/2019/05-内存管理/动态重定位.jpg"></div><h3 id="现代计算机运行过程"><a href="#现代计算机运行过程" class="headerlink" title="现代计算机运行过程"></a>现代计算机运行过程</h3><ul><li><p>预处理</p><ul><li>把存储在不同文件中的源程序聚合在一起。</li><li>把被称为宏的缩写语句转换为原始语句。</li></ul></li><li><p>编译：将高级语言翻译成汇编语言或机器语言。</p></li><li><p>链接</p><ul><li>将多个可重定位的机器代码文件（包括库文件）连接到一起。</li><li>解决外部内存地址（一个文件中的代码会引用其他文件中的数据对象或过程，这些数据对象或过程的地址对于此文件来说就是外部地址）问题。</li></ul></li><li><p>装入</p><p>确定程序在内中的绝对地址（即修改程序起始地址），将修改后的指令和数据放到内存中适当的位置。</p></li></ul><h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>连续分配是指为一个用户程序分配空间的时候，将所有程序装入到一段连续的物理内存中。在早期（20世纪60-80<br>年代）的操作系统中，这种分配内存的方式曾经被广泛的使用。</p><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>这是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。内存分为以下两个分区：系统区和用户区。操作系统使用系统区；应用程序装入到用户区，可使用用户区全部空间。</p><div align="center"><img src="/2019/05-内存管理/单一连续分配.jpg"></div><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>固定分区式分配，是最早使用的一种可运行多道程序的存储管理方式。它将内存空间划分为若干个固定大小的区域，每个分区大小可相同，也可不同。OS占一区，其余每个分区中可以装入一道作业。</p><p>为了便于内存分配，系统需建立一张分区使用表。当有一用户程序要装入时，从表中找出一个能满足要求的、尚未分配的分区分配给该程序，然后修改分区使用表。</p><div align="center"><img src="/2019/05-内存管理/固定分区分配.jpg"></div><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>空闲分区表<ul><li>每个空闲分区占用一个表项。</li><li>分区表的表项中包含分区号、分区始址及分区大小等表目。</li><li>表长不易确定。</li><li>占用额外内存。</li></ul></li><li>空闲分区链表<ul><li>利用各空闲分区自身的单元组成双向链表。</li><li>操作速度较慢。</li></ul></li></ul><div align="center"><img src="/2019/05-内存管理/动态分区数据结构.jpg"></div><h4 id="分区分配"><a href="#分区分配" class="headerlink" title="分区分配"></a>分区分配</h4><div align="center"><img src="/2019/05-内存管理/分区分配.jpg"></div><h4 id="分区回收"><a href="#分区回收" class="headerlink" title="分区回收"></a>分区回收</h4><ul><li>如果回收区的前后有空闲区，可分为图示三种情况。回收时将空闲区和回收区合并。</li></ul><div align="center"><img src="/2019/05-内存管理/分区回收.jpg"></div><ul><li>如果回收区的前后无空闲区，新建一个表项，填写信息插入。</li></ul><h4 id="分区检索算法"><a href="#分区检索算法" class="headerlink" title="分区检索算法"></a>分区检索算法</h4><h5 id="顺序检索算法"><a href="#顺序检索算法" class="headerlink" title="顺序检索算法"></a>顺序检索算法</h5><ul><li>首次适应算法：按各空闲分区首址的升序的方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从头查找，找到符合要求的第一个分区。</li><li>循环首次适应算法：分配空闲空间时，不是从链首（或表头）开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找。</li><li>最佳适应算法：按空闲区大小的升序方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从<br>头查找，找到符合要求的第一个分区。就说明它是最适合的（即最佳的）。</li><li>最坏适应算法：按空闲区大小的降序方法组织，分配时总是取空闲分区表（或空闲分区链）中的第一项，<br>若大小不能满足申请者的要求，则表示系统中无满足要求的空闲区，分配失败；否则分配。</li></ul><h5 id="索引检索算法"><a href="#索引检索算法" class="headerlink" title="索引检索算法"></a>索引检索算法</h5><ul><li>快速适应算法：将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应一种空闲分区类型，并记录其表头指针。空闲分区的分类是根据进程常用的空间大小进行划分，对于其他大小的分区，可以放在一个特殊的空闲区链表中。</li><li>伙伴系统：分区大小均为2的K次幂。假设系统可利用空间容量为$2^m$个字，系统运行过程中，不断划分，将空闲分区根据大小分类。为长度为n的进程分配分区时，首先计算$i$值使得$2^{i-1}≦n≦2^i$。先找大小为$2^i$的分区分配，否则找大小为$2^{i+1}$的分区分配，把$2^{i+1}$分区分成两个$2^i$分区（互称伙伴），一个分配，另一个加入$2^i​$的空闲分区链表。分配可能经过多次分割，回收可能进行多次合并。</li><li>哈希算法：根据空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最近分配策略。</li></ul><h4 id="紧凑"><a href="#紧凑" class="headerlink" title="紧凑"></a>紧凑</h4><p>可变式分区也有零头问题。在系统不断地分配和回收中，必定会出现一些不连续的小的空闲区，称为外零头。虽然可能所有零头的总和超过某一个作业的要求，但是由于不连续而无法分配。解决零头的方法是拼接（或称紧凑），即向一个方向（例如向低地址端）移动已分配的作业，使那些零散的小空闲区在另一方向连成一片。分区的拼接技术，一方面是要求能够对作业进行重定位，另一方面系统在拼接时要耗费较多的时间。</p><div align="center"><img src="/2019/05-内存管理/紧凑.jpg"></div><h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>页面：将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。</p></li><li><p>物理块：把内存空间分成与页面相同大小的若干个存储块，称为（物理）块或页框（frame）。</p></li><li><p>页面碎片：由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。</p></li><li><p>页面大小：每一页可进行编址的地址数目。页面大小应该<a href="https://isjinhao.github.io/2019/为什么分页存储管理页面大小是2的n次幂/#more">满足2的n此幂</a>。</p></li><li><p>逻辑地址：</p><div align="center"><img src="/2019/05-内存管理/分页逻辑地址.jpg"></div></li><li><p>页表：系统为每个进程建一张页表，其在内存的起始地址和长度记录在该进程的PCB中。</p><div align="center"><img src="/2019/05-内存管理/页表.jpg"></div></li><li><p>页表项：页表的每一行。</p></li><li>页表项长度：每个页表项占用的编址个数。从逻辑地址那里我们可以看到页号占用了20位，对应的块号也要占用20位，当然块号本身可能不止$2^{20}$个。又由于为了控制对物理块的读写等操作，会在页表项中加上控制字段。如果内存按字节编址，即每个编址可以存储8个二进制位，那么页表项占用的二进制位总数大于内存的字长度。我们需要把一个页表项拆开存放在多个编址后的空间中。</li></ul><div align="center"><img src="/2019/05-内存管理/页表项.jpg" style="width:80%"></div><h3 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h3><div align="center"><img src="/2019/05-内存管理/页表基本地址变换.jpg"></div><p>$物理地址=块号+块内地址=F(逻辑地址的页号*页表项长度+页表始址)+业内地址$。</p><p>每次进行地址变换需要访问两次内存，内存速度较慢，所以影响计算机整体性能。</p><h3 id="具有快表的地址变换"><a href="#具有快表的地址变换" class="headerlink" title="具有快表的地址变换"></a>具有快表的地址变换</h3><p>根据程序局部性原理，把最近使用的页表项存放在快表中，下次再进行地址变换时先去快表中查找对应项，如果没找到再去内存中查找，然后把新找到的页表项存放在快表中，如果快表已满，采用某种算法淘汰一份。</p><div align="center"><img src="/2019/05-内存管理/具有快表的页表地址变换.jpg"></div><h3 id="有效访问时间"><a href="#有效访问时间" class="headerlink" title="有效访问时间"></a>有效访问时间</h3><p>设t是访问内存的时间，a是快表命中率，λ是查找快表所需的时间。</p><ul><li><p>普通地址变换时间：<code>t+t</code></p></li><li><p>具有快表的地址变换时间：$ a \ast \lambda + (1-a) \ast (t+\lambda)$。</p></li></ul><h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><p>对于两级页表，是将页表再进行分页，页面的大小与内存物理块的大小相同。逻辑地址结构可描述如下：</p><div align="center"><img src="/2019/05-内存管理/两级页表.jpg"></div><h3 id="两级页表地址变换"><a href="#两级页表地址变换" class="headerlink" title="两级页表地址变换"></a>两级页表地址变换</h3><div align="center"><img src="/2019/05-内存管理/两级页表地址变换.jpg"></div><p>可推广至N级页表。</p><h3 id="反置页表"><a href="#反置页表" class="headerlink" title="反置页表"></a>反置页表</h3><p>页表是按每个进程的页号排序，指示出物理块号的位置，反置页表是按物理块号排序，指示出每个页隶属的进程和页号。</p><p>此方法需要为每个进程创建一个外部页表，即将页表建立在外存中。进程进行地址变换时先从反置页表里查找，如果查找不到则去外村中查找，再将查找到的页表项调入内存。</p><div align="center"><img src="/2019/05-内存管理/反置页表.jpg"></div><h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><p>之前的分区管理都是为了更好的利用内存。为了满足程序员在编程上的要求引入了分段管理方式。</p><ul><li><p>方便编程：通常，用户把自己的作业按照逻辑关系划分为若干个段，每个段都是从0开始编址，并有自己的名字和长度。因此，希望要访问的逻辑地址是由段名（段号）和段内偏移量（段内地址）决定的。例如，下述的两条指令便是使用段名和段内地址：其中，前一条指令的含义是将分段A中D单元内的值读入寄存器1；后一条指令的含义是将寄存器1的内容存入B分段的C单元中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD 1，[A] |〈D〉；</span><br><span class="line">STORE 1，[B] |〈C〉；</span><br></pre></td></tr></table></figure></li><li><p>信息共享：在实现对程序和数据的共享时，是以信息的逻辑单位为基础的。比如，共享某个例程和函数。分页系统中的“页”只是存放信息的物理单位（块），并无完整的意义，不便于实现共享；然而段却是信息的逻辑单位。由此可知，为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适应。</p></li><li><p>信息保护：信息保护同样是对信息的逻辑单位进行保护，因此，分段管理方式能更有效和方便地实现信息保护功能。</p></li><li>动态增长：在实际应用中，往往有些段，特别是数据段，在使用过程中会不断地增长，而事先又无法确切地知道数据段会增长到多大。前述的其它几种存储管理方式，都难以应付这种动态增长的情况，而分段存储管理方式却能较好地解决这一问题。</li><li>动态链接：动态链接是指在作业运行之前，并不把几个目标程序段链接起来。要运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段（目标程序）调入内存并进行链接。可见，动态链接也要求以段作为管理的单位。</li></ul><h3 id="分段地址"><a href="#分段地址" class="headerlink" title="分段地址"></a>分段地址</h3><div align="center"><img src="/2019/05-内存管理/分段地址.jpg"></div><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><div align="center"><img src="/2019/05-内存管理/段表.jpg"></div><h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><div align="center"><img src="/2019/05-内存管理/分段地址映射.jpg"></div><h3 id="地址变换-1"><a href="#地址变换-1" class="headerlink" title="地址变换"></a>地址变换</h3><div align="center"><img src="/2019/05-内存管理/分段地址变换.jpg"></div><h3 id="分页和分段的主要区别"><a href="#分页和分段的主要区别" class="headerlink" title="分页和分段的主要区别"></a>分页和分段的主要区别</h3><ul><li>页是信息的物理单位，段则是信息的逻辑单位；</li><li>页的的大小固定且由系统决定，而段的长度不固定，由用户所编写的程序决定；</li><li>分页的地址空间是一维的，而分段的地址空间是二维的。</li><li>分页是系统管理的需要；分段是为了更好满足用户的需要。</li></ul><h2 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h2><p>分段结构具有逻辑上清晰的优点，但它的一个致命弱点是每个段必须占据主存储器的连续区域，于是，要装入一个分段时可能要移动已在主存储器中的信息，为了克服这个缺点，可兼用分段和分页的方法，构成段页式存储管理。每个作业仍按逻辑分段，但对每一段不是按单一的连续整体存放到存储器中，而是把每个段再分成若干个页面，每一段不必占据连续的主存空间，可把它按页存放在不连续的主存块中。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>逻辑地址空间分段，段内分页，内存分块（页框），存储管理的分配单位是：物理块（页框）</li><li>地址结构：段号，页号，页内偏移地址。</li><li>每个作业一张段表，每段一张页表。地址变换：先查段表，再查该段的页表。</li></ul><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><div align="center"><img src="/2019/05-内存管理/段表地址映射.jpg"></div><h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><div align="center"><img src="/2019/05-内存管理/段表地址变换.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;存储器的层次&quot;&gt;&lt;a href=&quot;#存储器的层次&quot; class=&quot;headerlink&quot; title=&quot;存储器的层次&quot;&gt;&lt;/a&gt;存储器
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>04-死锁及处理</title>
    <link href="https://isjinhao.github.io/2019/04-%E6%AD%BB%E9%94%81%E5%8F%8A%E5%A4%84%E7%90%86/"/>
    <id>https://isjinhao.github.io/2019/04-死锁及处理/</id>
    <published>2019-03-14T03:23:45.000Z</published>
    <updated>2019-03-15T04:12:49.326Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --><h2 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h2><h3 id="可重用资源和消耗性资源"><a href="#可重用资源和消耗性资源" class="headerlink" title="可重用资源和消耗性资源"></a>可重用资源和消耗性资源</h3><ul><li>可重用性资源：可供用户重复使用多次的资源。特点：<ul><li>互斥访问</li><li>系统中此资源数目相对固定</li><li>系统中大多数资源属于此类</li></ul></li><li>可消耗性资源：临时性资源<ul><li>由进程动态创建和消耗，数目是可以不断变化的，比如信号量、进程通信的信息等。</li></ul></li></ul><h3 id="可抢占性资源和不可抢占性资源"><a href="#可抢占性资源和不可抢占性资源" class="headerlink" title="可抢占性资源和不可抢占性资源"></a>可抢占性资源和不可抢占性资源</h3><ul><li>可抢占性资源：CPU和主存，不会引起死锁。</li><li>不可抢占性资源：只能进程自行释放。如打印机，因为如果打印到一半，打印机被抢占，造成的结果只能是此次打印作废，所以它是不可抢占资源。</li></ul><h2 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h2><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。</p><div align="center"><img src="/2019/04-死锁及处理/死锁举例.jpg"></div><h2 id="死锁的起因"><a href="#死锁的起因" class="headerlink" title="死锁的起因"></a>死锁的起因</h2><h3 id="竞争不可抢占性资源引起死锁"><a href="#竞争不可抢占性资源引起死锁" class="headerlink" title="竞争不可抢占性资源引起死锁"></a>竞争不可抢占性资源引起死锁</h3><p>一个资源只能同时被一个进程使用，但是下图P1在获得R1后还去申请R2，同时P2获得R2后还去申请R1，陷入僵局，引发死锁。</p><div align="center"><img src="/2019/04-死锁及处理/竞争不可抢占资源.jpg"></div><h3 id="竞争可消耗性资源引起死锁"><a href="#竞争可消耗性资源引起死锁" class="headerlink" title="竞争可消耗性资源引起死锁"></a>竞争可消耗性资源引起死锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P1：receive(p3,m3)； send(p2,m1)；</span><br><span class="line">P2：receive(p1,m1)； send(p3,m2)；</span><br><span class="line">P3：receive(p2,m2)； send(p1,m3)；</span><br></pre></td></tr></table></figure><p>如上代码，P1在等待P3给P1发消息，P2在等待P1给它P2发消息，P3在等待P2给P3发消息。造成一个死循环。</p><h3 id="进程推进顺序非法"><a href="#进程推进顺序非法" class="headerlink" title="进程推进顺序非法"></a>进程推进顺序非法</h3><p>在下图中，X轴表示进程P1推进图，Y轴表示进程P2推进图。如果按照4号路线推进，可以看出P1在经过b、d段的执行之后，获得R1，P2在进过a、c、e段的执行之后获得R2。此时如果不加以处理，系统一定会进入死锁状态，因为接下来P1在拥有R1后又去申请R2，P2在拥有R2后又去申请R1。</p><div align="center"><img src="/2019/04-死锁及处理/进程推进顺序非法.jpg"></div><h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><ul><li>互斥条件：某段时间内，某资源只能由一个进程使用；</li><li>请求和保持条件：进程因请求资源而阻塞时，对已分配给它的资源保持不放；</li><li>不可抢占条件 ：资源在未使用完前，不能被剥夺，由使用进程释放；</li><li>循环等待条件 ：发生死锁时，有向图必构成一环路。</li></ul><h2 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h2><p>共有三类做法：</p><ul><li>第一类是预防死锁，也就是破坏死锁产生的条件（破坏其中一个就可以），这样系统就永远不会产生死锁。</li></ul><ul><li>第二类是死锁避免，死锁产生的根本原因是系统资源分配出现问题，如果能进行合理的资源分配就能避免死锁的发生。</li></ul><ul><li>第三类是死锁发生后的检测和解除。</li></ul><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p>预防死锁是给系统施加一个条件使其永远不可能满足死锁产生的必要条件，但是互斥条件是不能被破坏的条件，所以预防死锁有三类做法：</p><h3 id="破坏“请求和保持”条件"><a href="#破坏“请求和保持”条件" class="headerlink" title="破坏“请求和保持”条件"></a>破坏“请求和保持”条件</h3><p>即进程在请求资源时，它不能持有不可抢占资源。有两种做法：</p><ol><li>所有进程在开始运行之前，一次性的申请其在整个运行过程中的全部资源，如果申请成功，进程便陷入等待。这样进程在运行的时候就不会再发出请求。</li><li>进程在只获得运行初期所需的资源后便开始运行，但是进程在运行过程中需要逐步释放以分配给自己的资源，等初期获得所有资源都被释放后才能请求其他资源。</li></ol><h3 id="破坏“不可抢占”条件"><a href="#破坏“不可抢占”条件" class="headerlink" title="破坏“不可抢占”条件"></a>破坏“不可抢占”条件</h3><p>当进程保持了某些不可被抢占资源，且提出的新需求又不能被满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这种预防策略的代价非常昂贵，比如进程请求的打印机被强制剥夺后，之前的工作等于作废。</p><h3 id="破坏“循环等待”条件"><a href="#破坏“循环等待”条件" class="headerlink" title="破坏“循环等待”条件"></a>破坏“循环等待”条件</h3><p>常见的方法是“资源有序分配”。其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号升序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程，在拥有大编号资源再申请小编号资源时需要释放和小资源编号相等及以上的编号。</p><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>避免死锁讲道理是属于死锁的预防，但是它和预防死锁不同，预防死锁是破坏死锁产生的条件，避免死锁是防止系统进入不安全状态。所以我们就要明白什么是安全状态，它和死锁产生的必要条件有什么区别。</p><h3 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h3><p>安全状态指的是系统能按某种进程推进顺序<code>(P1, P2, …, Pn)</code>为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。此时，序列<code>(P1, P2, …, Pn)</code>为安全序列。如果系统无法找到这样一个序列，则称系统处于不安全状态。</p><p>为什么能找到这样的序列系统就是安全的呢？其实它是一个递推的关系，假如系统在时刻<code>i</code>发起申请资源请求，其此时状态为<code>a</code>，系统会判断它申请成功后是否还能寻找到一个安全序列，如果能找到便可以分配，否则便是系统不安全状态。假如系统申请到了资源，还想发出申请请求，便会再次判断请求成功之后能否找到安全序列，由此递推下去可保证整个系统能避免死锁。</p><h3 id="安全状态和死锁必要条件的区别"><a href="#安全状态和死锁必要条件的区别" class="headerlink" title="安全状态和死锁必要条件的区别"></a>安全状态和死锁必要条件的区别</h3><p>仍以此图为例。假如我们采用的是预防死锁策略中的破坏“请求和保持”条件里的第一个做法，那么推进顺序就不可能为4，因为进程P1在执行的时候需要获取全部资源才能执行。但对于避免死锁来说，系统可以按照4号推进顺序推进到e段和阴影区的交界处，然后进程P2在申请资源R2的时候会去判断分配R2给P2之后系统能否找到安全序列，事实上是找不到的，所以R2便不会分配给P2，这样系统就进入不了阴影区，从而可以避免死锁。</p><p>所以预防死锁和避免死锁的区别是：</p><ul><li><p>预防死锁是每个进程在执行之前确保其自身不陷入死锁状态，如果每个进程都能不陷入死锁状态，系统便能永远安全。即从单个进程角度静态解决问题。</p></li><li><p>但避免死锁是在每一次进行资源分配时判断分配之后是否系统处于安全状态，如果处于安全状态便可分配，否则便不能分配。即从系统整体角度动态解决问题。</p></li></ul><div align="center"><img src="/2019/04-死锁及处理/进程推进顺序非法.jpg"></div><h3 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ol><li>可利用资源向量$Available$：是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果$Available[j]=K$，则表示系统中现有$R_j$类资源K个。</li><li>最大需求矩阵$Max$：这是一个$n×m$的矩阵，它定义了系统中$n$个进程中的每一个进程对$m$类资源的最大需求。如果$Max[i, j]=K$，则表示进程$i$需要$R_j$类资源的最大数目为K。</li><li>分配矩阵$Allocation$：这也是一个$n×m$的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果$Allocation[i,j]=K$，则表示进程i当前已分得$R_j$类资源的 数目为K。</li><li>需求矩阵$Need$：这也是一个$n×m$的矩阵，用以表示每一个进程尚需的各类资源数。如果$Need[i,j]=K$，则表示进程$i$还需要$R_j$类资源K个，方能完成其任务。</li></ol><p>可得：$Need[i,j]=Max[i,j]-Allocation[i,j]​$</p><h4 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h4><p>设进程$cusneed$提出请求$REQUEST[i]$，则银行家算法按如下规则进行判断。</p><ol><li>如果$REQUEST[cusneed] [i]&lt;= Need[cusneed][i]​$，则转2；否则，出错。</li><li>如果$REQUEST [cusneed] [i]&lt;= Available[i]$，则转3；否则，等待。</li><li>系统试探分配资源，修改相关数据：<ol><li>$Available[i]-=REQUEST[cusneed][i]$;</li><li>$Allocation[cusneed][i]+=REQUEST[cusneed][i]$;</li><li>$Need[cusneed][i]-=REQUEST[cusneed][i]$;</li></ol></li><li>系统执行安全性检查算法，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。</li></ol><h4 id="安全性算法"><a href="#安全性算法" class="headerlink" title="安全性算法"></a>安全性算法</h4><ol><li>设置两个工作向量$Work=Available​$、$Finish=false​$。</li><li>从进程集合中找到一个满足下述条件的进程$i$，$Finish[i]==false;$$Need[i, j]&lt;=Work[j];$，如找到，执行3；否则，执行4。</li><li>设进程获得资源，可顺利执行，直至完成，从而释放资源。$Work[i]=Work[i]+Allocation[i,j];​$，$Finish[i]=true;​$，循环2。</li><li>如所有的进程$Finish= true​$，则表示安全；否则系统不安全。</li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><ul><li>假定系统中有五个进程$\lbrace P0, P1, P2, P3, P4\rbrace$和三类资源$\lbrace A,B, C\rbrace$，各种资源的数量分别为10、5、7，在$T0$时刻的资源分配情况如图所示。</li></ul><div align="center"><img src="/2019/04-死锁及处理/T0.jpg"></div><ul><li>$T0​$时刻的安全性</li></ul><div align="center"><img src="/2019/04-死锁及处理/T1.jpg"></div><ul><li>$P1$请求资源：$P1$发出请求向量$Request1(1,0,2)​$，系统按银行家算法进行检查。<ul><li>$Request_1(1, 0, 2)≤Need_1(1, 2, 2)​$</li><li>$Request_1(1, 0, 2)≤Available_1(3, 3, 2)$</li><li>系统先假定可为$P1​$分配资源，并修改$Available,Allocation_1和Need_1​$向量。由此得到的资源变换情况如上上图括号所示。</li><li>再利用安全性算法检查此时系统是否安全。</li></ul></li></ul><div align="center"><img src="/2019/04-死锁及处理/T2.jpg"></div><ul><li><p>$P4$请求资源：$P4$发出请求向量$Request_4(3,3,0)$，系统按银行家算法进行检查。</p><ul><li>$Request_4(3, 3, 0)≤Need_4(4, 3, 1);$。</li><li>$Request_4(3, 3, 0)&gt;Available(2, 3, 0)​$，让$P4​$等待。</li></ul></li><li><p>$P0$请求资源：$P0$发出请求向量$Requst_0(0,2,0)$，系统按银行家算法进行检查。</p><ul><li>$Request_0(0, 2, 0)≤Need_0(7, 4, 3);$</li><li>$Request_0(0, 2, 0)≤Available(2, 3, 0);$</li><li>系统暂时先假定可为$P0$分配资源，并修改有关数据，如下图所示。</li></ul><div align="center"><img src="/2019/04-死锁及处理/T3.jpg"></div></li><li><p>进行安全性检查：此时可用资源$Available(2,1,0)$已经不能满足任何进程的需要，进入不安全状态，因此系统不分配资源。</p></li></ul><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p>在图中找一既非阻塞又非独立的进程节点$P_i$，如顺利，$P_i$可获得所有资源直至运行完毕。消去$P_i$所有的请求边和分配边，即释放占有的所有资源，同理再选下一进程节点$P_{i+1}, …, $若能消去所有的边，那么该图是可完全简化的，否则该图是不可完全简化的。</p><div align="center"><img src="/2019/04-死锁及处理/死锁的检测.jpg"></div><p>具体做法如下：</p><ol><li>可利用资源向量$Available[]$，它表示了m类资源中每一类资源的可用数目。</li><li>把不占用资源的进程（向量$Allocation[i]∶= 0$）记入L表中，即$L_i \bigcup L$。</li><li>从进程集合中找到一个$Request_i≤Work$的进程，做如下处理：<ol><li>将其资源分配图简化，释放出资源，增加工作向量$Work∶ =Work+Allocation_i$。</li><li>将它记入L表中。</li></ol></li><li>若不能把所有进程都记入L表中， 便表明系统状态S的资源分配图是不可完全简化的。 因此，该系统状态将发生死锁。</li></ol><h4 id="死锁的解除"><a href="#死锁的解除" class="headerlink" title="死锁的解除"></a>死锁的解除</h4><p>死锁解除有多种做法，如下是按代价递减排序的几种。</p><ol><li>撤销所有死锁的进程。</li><li>将每个进程回退到先前定义的某个检查点，再重新启动所有进程。</li><li>逐个撤销死锁进程，直至死锁不存在。撤销进程的顺序应是基于某种最小代价原则，每次撤销后，死锁检测算法应该重新检测死锁是否依然存在。</li><li>剥夺进程P的资源交给进程Q，P同时会退到获得此资源的节点上。</li></ol><p>对于3和4，选择的标准可以如下：</p><ul><li>以占用处理器的时间最小；</li><li>以产生的输出少；</li><li>所估计的剩余运行时间最长；</li><li>所占用的资源最少；</li><li>优先权最低。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;资源分类&quot;&gt;&lt;a href=&quot;#资源分类&quot; class=&quot;headerlink&quot; title=&quot;资源分类&quot;&gt;&lt;/a&gt;资源分类&lt;/h2&gt;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>时钟中断</title>
    <link href="https://isjinhao.github.io/2019/%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD/"/>
    <id>https://isjinhao.github.io/2019/时钟中断/</id>
    <published>2019-03-13T13:28:43.000Z</published>
    <updated>2019-03-17T12:30:08.971Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --><h2 id="中断的理解"><a href="#中断的理解" class="headerlink" title="中断的理解"></a>中断的理解</h2><p>说到中断还不得不从现代操作系统的特性说起，无论是桌面PC操作系统还是嵌入式都是多任务的操作系统，而很遗憾，处理器往往是单个的，即使在硬件成本逐渐下降，但处理器的数量依然不可能做到每个任务一个CPU，所以CPU必须作为一种全局的资源让所有任务共享。即什么时候给任务A用，什么时候给任务B用……这就是进程调度，具体的安排就由调度算法决定了。</p><p>进程如何去调度？现代操作系统一般都是采用基于时间片的优先级调度算法，把CPU的时间划分为很细粒度的时间片，一个任务每次只能时间这么多的时间，时间到了就必须交出使用权，即换其他的任务使用。这种要看操作系统的定时器机制了。那么时间片到之后，系统做了什么呢？这就要用到我们的中断了，时间片到了由定时器触发一个软中断，然后进入相应的处理历程。当然这一点不足以表明中断的重要，计算机操作系统自然离不开外部设备：鼠标、键盘、网卡、磁盘等等。就拿网卡来讲，我计算机并不知道时候数据包会来到，我能保证的就是数据来了我能正常接收就行了。但是我又不可能一直等着接收数据包，要是这样其他任务就死完了。所以合理的办法是，你数据包来到之后，通知我，然后我再对你处理，怎么通知呢？？答：中断！键盘、鼠标亦是如此！</p><h2 id="中断的定义"><a href="#中断的定义" class="headerlink" title="中断的定义"></a>中断的定义</h2><p>指处理机处理程序运行中出现的紧急事件的整个过程.程序运行过程中，系统外部、系统内部或者现行程序本身若出现紧急事件，处理机立即中止现行程序的运行，自动转入相应的处理程序（中断服务程序），待处理完后，再返回原来的程序运行，这整个过程称为程序中断。可分为两类：</p><h3 id="硬中断（Hardware-Interrupt）"><a href="#硬中断（Hardware-Interrupt）" class="headerlink" title="硬中断（Hardware Interrupt）"></a>硬中断（Hardware Interrupt）</h3><ul><li>外部中断：一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断是可屏蔽的。</li><li>内部中断是指因硬件出错（如突然掉电、奇偶校验错等）,或运算出错（除数为零、运算溢出、单步中断等）所引起的中断，内部中断是不可屏蔽的。</li></ul><h3 id="软中断（Software-Interrupt）"><a href="#软中断（Software-Interrupt）" class="headerlink" title="软中断（Software Interrupt）"></a>软中断（Software Interrupt）</h3><p>软中断是利用硬中断的概念，用软件方式进行模拟，实现宏观上的异步执行效果。很多情况下，软中断和”信号”有些类似，同时，软中断又是和硬中断相对应的，硬中断是外部设备对CPU的中断，软中断通常是硬中断服务程序（模拟硬件发出中断的程序）对内核的中断，信号则是由内核（或其他进程）对某个进程的中断。</p><h2 id="时钟中断"><a href="#时钟中断" class="headerlink" title="时钟中断"></a>时钟中断</h2><p>在Linux的0号中断是一个定时器中断。在固定的时间间隔都发生一次中断，也是说每秒发生该中断的频率都是固定的。该频率是常量HZ，该值一般是在100 ~ 1000之间。该中断的作用是为了定时更新系统日期和时间，使系统时间不断地得到跳转。另外该中断的中断处理函数除了更新系统时间外，还需要更新本地CPU统计数。若进程的时间片递减到0，进程则被调度出去而放弃CPU使用权。</p><p>Linux的OS时钟的物理产生原因是可编程定时/计数器产生的输出脉冲，这个脉冲送入CPU，就可以引发一个中断请求信号，我们就把它叫做<code>时钟中断</code>。</p><p><code>时钟中断</code>是特别重要的一个中断，因为整个操作系统的活动都受到它的激励。系统利用时钟中断维持系统时间、促使环境的切换，以保证所有进程共享CPU；利用时钟中断进行记帐、监督系统工作以及确定未来的调度优先级等工作。可以说，<code>时钟中断</code>是整个操作系统的脉搏。</p><p>参考：</p><ul><li><p><a href="https://www.jb51.net/article/133782.htm" target="_blank" rel="noopener">https://www.jb51.net/article/133782.htm</a></p></li><li><p><a href="https://blog.csdn.net/wlf_go/article/details/80237491" target="_blank" rel="noopener">https://blog.csdn.net/wlf_go/article/details/80237491</a></p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;中断的理解&quot;&gt;&lt;a href=&quot;#中断的理解&quot; class=&quot;headerlink&quot; title=&quot;中断的理解&quot;&gt;&lt;/a&gt;中断的理解&lt;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="计算机组成原理" scheme="https://isjinhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>c与cpp</title>
    <link href="https://isjinhao.github.io/2019/c%E4%B8%8Ecpp/"/>
    <id>https://isjinhao.github.io/2019/c与cpp/</id>
    <published>2019-03-13T00:01:36.000Z</published>
    <updated>2019-03-13T10:00:54.572Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>绝对值在$10^9$范围以内或者是32位的整数都可以定义成<code>int</code>型。</li><li><p>绝对值在$10^{18}$范围以内或者是64位以内的整数可以定义为<code>long long</code>型。</p></li><li><p>如果<code>long long</code>型赋大于$2^{31}-1$的初值，则需要在初值后面加上<code>LL</code>。</p></li><li>遇到浮点型数据不要使用<code>float</code>，都应该使用<code>double</code>。</li><li>小写字母的ASCII值开始于97，大写字母的ASCII值开始于65。小写字母比大写字母大32。</li><li><code>\0</code>表示NULL。</li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><table><thead><tr><th style="text-align:center">运算符</th><th style="text-align:center">含义</th><th style="text-align:center">语法</th><th style="text-align:center">效果</th></tr></thead><tbody><tr><td style="text-align:center"><code>&lt;&lt;</code></td><td style="text-align:center">左移</td><td style="text-align:center"><code>a &lt;&lt; x</code></td><td style="text-align:center">整数a按二进制位左移x位</td></tr><tr><td style="text-align:center"><code>&gt;&gt;</code></td><td style="text-align:center">右移</td><td style="text-align:center"><code>a &gt;&gt; x</code></td><td style="text-align:center">整数a按二进制位右移x位</td></tr><tr><td style="text-align:center"><code>&amp;</code></td><td style="text-align:center">位与</td><td style="text-align:center"><code>a &amp; b</code></td><td style="text-align:center">整数a和b按二进制对齐，进行按位与运算</td></tr><tr><td style="text-align:center">$\mid$</td><td style="text-align:center">位或</td><td style="text-align:center">$a \mid b$</td><td style="text-align:center">整数a和b按二进制对齐，进行按位或运算</td></tr><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center">位异或</td><td style="text-align:center"><code>a ^ b</code></td><td style="text-align:center">整数a和b按二进制对齐，进行按位或运算</td></tr><tr><td style="text-align:center"><code>~</code></td><td style="text-align:center">位取反</td><td style="text-align:center"><code>~a</code></td><td style="text-align:center">整数a在二进制下各位取反</td></tr></tbody></table><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ul><li>按位与：除了11为1，其他都是0；</li><li>按位或：除了00为0，其他都是1；</li><li>按位异或：相同为0，不同为1。</li></ul><h3 id="无穷大"><a href="#无穷大" class="headerlink" title="无穷大"></a>无穷大</h3><ul><li><p><code>const int INF = (1 &lt;&lt; 30) - 1;</code></p></li><li><p><code>const int INF = 0x3fffffff;</code></p></li></ul><h2 id="scanf"><a href="#scanf" class="headerlink" title="scanf"></a><code>scanf</code></h2><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">格式符</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center"><code>%d</code></td><td style="text-align:center"><code>scanf(&quot;%d&quot;, &amp;n)</code></td></tr><tr><td style="text-align:center"><code>long long</code></td><td style="text-align:center"><code>%lld</code></td><td style="text-align:center"><code>scanf(&quot;%lld&quot;, &amp;ll)</code></td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center"><code>%f</code></td><td style="text-align:center"><code>scanf(&quot;%f&quot;, &amp;fl)</code></td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center"><code>%lf</code></td><td style="text-align:center"><code>scanf(&quot;%lf&quot;, &amp;db)</code></td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center"><code>%c</code></td><td style="text-align:center"><code>scanf(&quot;%d&quot;, &amp;c)</code></td></tr><tr><td style="text-align:center"><code>字符串（char数组）</code></td><td style="text-align:center"><code>%s</code></td><td style="text-align:center"><code>scanf(&quot;%d&quot;, str)</code></td></tr></tbody></table><p><code>scanf</code>双引号之内的字符串其实类似一个匹配模式，我们输入的参数只要能匹配这个模式其实都算对。比如在输入时间时：<code>scanf(&quot;%d:%d:%d&quot;, &amp;hour, &amp;minute, &amp;second)</code>。输入的参数只要是：<code>h​:m:​d</code>的形式就行。</p><p>除了字符类型（<code>%c</code>），<code>scanf</code>对于其他类型都是默认以空白符（空格、换行等）判断结束标志的。但是在使用字符类型时可以读入空白符。如对于<code>scanf(&quot;%d%c%s&quot;, &amp;a, %c, str)</code>，我们输入<code>1 a bad</code>，得到的结果是<code>a=1, c= , str=a</code>。</p><h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a><code>printf</code></h2><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">格式符</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center"><code>%d</code></td><td style="text-align:center"><code>printf(&quot;%d&quot;, n)</code></td></tr><tr><td style="text-align:center"><code>long long</code></td><td style="text-align:center"><code>%lld</code></td><td style="text-align:center"><code>printf(&quot;%lld&quot;, ll)</code></td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center"><code>%f</code></td><td style="text-align:center"><code>printf(&quot;%f&quot;, fl)</code></td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center"><code>%f</code></td><td style="text-align:center"><code>printf(&quot;%f&quot;, db)</code></td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center"><code>%c</code></td><td style="text-align:center"><code>ptintf(&quot;%d&quot;, c)</code></td></tr><tr><td style="text-align:center"><code>字符串（char数组）</code></td><td style="text-align:center"><code>%s</code></td><td style="text-align:center"><code>ptintf(&quot;%d&quot;, str)</code></td></tr></tbody></table><p>输出<code>%</code>和<code>\</code>：<code>printf(&quot;%%&quot;)</code>，<code>printf(&quot;\\&quot;)</code></p><h3 id="md-amp-0md-amp-md"><a href="#md-amp-0md-amp-md" class="headerlink" title="%md &amp; %0md &amp; %.md"></a><code>%md</code> &amp; <code>%0md</code> &amp; <code>%.md</code></h3><ul><li><p><code>%md</code>：使不足m位的int型变量以m位且右对齐输出，高位以空格补齐，若变量本身超过m位，则保持原样。</p></li><li><p><code>%0md</code>：使不足m位的int型变量以m位且右对齐输出，高位以0补齐，若变量本身超过m位，则保持原样。</p></li><li><code>%.mf</code>：让浮点数保留m位小数输出。如果题目要求保留xx位小数，使用这个格式便是正确的。<ul><li>这种格式不是四舍五入：它是<a href="https://baike.baidu.com/item/%E5%9B%9B%E8%88%8D%E5%85%AD%E5%85%A5%E4%BA%94%E6%88%90%E5%8F%8C/9062547?fr=aladdin" target="_blank" rel="noopener">四舍六入偶成双</a>。</li></ul></li></ul><h2 id="getchar-amp-putchar"><a href="#getchar-amp-putchar" class="headerlink" title="getchar &amp; putchar"></a><code>getchar</code> &amp; <code>putchar</code></h2><p><code>getchar()</code>输入单个字符，<code>putchar(char c)</code>输出单个字符。如<code>char c = getchar();</code>，<code>getchar()</code>可以读入换行符。</p><h2 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a><code>typedef</code></h2><p>给复杂的数据类型定义一个别名。如：<code>typedef long long ll</code>。</p><h2 id="常用math函数"><a href="#常用math函数" class="headerlink" title="常用math函数"></a>常用math函数</h2><ul><li>double类型取绝对值：<code>fabs(double x)</code></li><li>double类型向上取整：<code>floor(double x)</code></li><li>double类型向下取整：<code>ceil(double x)</code></li><li>求$r_p$：<code>pow(double r, double p)</code></li><li>取double类型的算术平方根：<code>sqrt(double x)</code></li><li>得到以自然对数为底的对数：<code>log(double x)</code><ul><li>得到以a为底b的对数：$log_ab$=<code>log(b)/log(a)</code></li></ul></li><li>四舍五入：<code>round (double x)</code></li><li>三角函数：<ul><li><code>sin(double x)</code>，<code>cos(double x)</code>，<code>tan(double x)</code>：参数是弧度制。</li><li><code>asin(double x)</code>，<code>acos(double x)</code>，<code>atan(double x)</code>。</li></ul></li></ul><h2 id="memset"><a href="#memset" class="headerlink" title="memset"></a><code>memset</code></h2><p><code>memset(数组名, 值, sizeof(数组名));</code>。<code>memset</code>是按字节赋值，也就是说所有的字节都会被赋值为相同的数值，比如对于<code>int a[10]</code>，使用<code>memset(a, 1, sizeof(a);</code>，则四十个字节上的二进制结果都是<code>00000001</code>。由于0的二进制补码全为0，-1的二进制补码全为1，所以memset一般只用于赋值0和-1。</p><h2 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h2><ul><li>仅在初始化的时候可以直接赋值字符串，如：<code>char str[4] = &quot;PAT&quot;;</code></li><li><code>gets(str)</code>：读入一行字符串，以换行符作为输入结束。</li><li><code>puts(str)</code>：输出一行字符串，即输出字符串+换行符。</li><li><code>gets()</code>和<code>scanf()</code>在读入字符串时会自动添加结束符（<code>\0</code>）。</li></ul><h2 id="string-h头文件"><a href="#string-h头文件" class="headerlink" title="string.h头文件"></a><code>string.h</code>头文件</h2><ul><li><code>strlen()</code>：获得字符数组中第一个<code>\0</code>前的字符个数（不包含<code>\0</code>）。</li><li><p><code>strcmp(str1, str2)</code>：比较两个字符串的大小（字典序）：</p><ul><li><code>str1 &lt; str2</code>：返回负整数；</li><li><code>str1 == str2</code>：返回0；</li><li><code>str1 &gt; str2</code>：返回正整数；</li></ul></li><li><p><code>strcpy(str1, str2)</code>：把<code>str2</code>复制给<code>str1</code>，包含结束符<code>\0</code>。</p></li><li><code>strcat(str1, str2)</code>：把<code>str2</code>粘贴在<code>str1</code>后面（覆盖<code>str1</code>的<code>\0</code>）。</li></ul><h2 id="sscanf-amp-sprintf"><a href="#sscanf-amp-sprintf" class="headerlink" title="sscanf &amp; sprintf"></a><code>sscanf</code> &amp; <code>sprintf</code></h2><p>用于处理字符串问题：</p><ul><li><code>sscanf(原位置，格式符，目的位置)</code>：把原位置里的数据输入到目的位置中。</li><li><code>sprintf(目的位置, 格式符, 原位置)</code>：把原位置里的数据输出到目的位置中。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">100</span>] = <span class="string">"123"</span>;</span><br><span class="line"><span class="built_in">sscanf</span>(str, <span class="string">"%d"</span>, &amp;n);<span class="comment">//字符转int时不是强转为ASCII，是字面值相同。</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, n);<span class="comment">//123</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理复杂的字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">double</span> db;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">100</span>] = <span class="string">"2048:3.14,hello"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">sscanf</span>(str1, <span class="string">"%d:%lf,%s"</span>, &amp;n, &amp;db, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"n=%d, db=%.2f, str2=%s\n"</span>, n, db, str2); <span class="comment">//n=2048, db=3.14, str2=hello</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">double</span> db = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="keyword">char</span> str1[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">100</span>] = <span class="string">"good"</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str1, <span class="string">"%d:%.2lf,%s"</span>, n, db, str2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"str2=%s\n"</span>, str1);<span class="comment">//str2=12:3.14,good</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li><p>指针存储的地址的类型称为基类型。</p></li><li><p>基类型必须和指针变量存储的地址类型相同。</p></li><li><p>进行加减法得到的是其基类型偏移的位数。如，两个int型指针相减，等价于两个指针之间差了几个int。</p></li><li><p>指针作为函数的参数，传递的是地址的拷贝</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testPointer</span><span class="params">(<span class="keyword">int</span> *p1, <span class="keyword">int</span> * p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p1 = p1 + <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *p1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line">testPointer(&amp;a[<span class="number">1</span>], &amp;a[<span class="number">5</span>]);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>指针在创建的时候赋予初值。否则可能出现问题。如<code>int *temp;</code>，temp会被赋予一个随机空间，可能指向系统功能区，此时程序运行就会问题。</p></li></ul><h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul><li><p>结构体限制：结构体内部不能定义本类型，但可以定义本类型的指针。</p></li><li><p>结构体的构造函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">studentInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="keyword">char</span> gender;</span><br><span class="line">studentInfo()&#123;&#125;</span><br><span class="line">studentInfo(<span class="keyword">char</span> _gender): gender(_gender) &#123;&#125;</span><br><span class="line">studentInfo(<span class="keyword">int</span> _id, <span class="keyword">char</span> _gender): id(_id), gender(_gender) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">studentInfo stu = studentInfo(<span class="number">10086</span>, <span class="string">'M'</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; stu.id &lt;&lt; <span class="string">" "</span> &lt;&lt; stu.gender &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="浮点数的比较"><a href="#浮点数的比较" class="headerlink" title="浮点数的比较"></a>浮点数的比较</h2><p>计算机采用有限位的二进制代码，因此浮点数在计算机中的存储并不总是精确的，具体参考<code>IEEE754</code>规则。所以我们需要定义一个极小数<code>eps</code>（一般定义为$10^{-8}$）对这种误差进行修正。</p><ul><li><p>等于运算</p><div align="center"><img src="/2019/c与cpp/等于.jpg"></div></li><li><p>大于运算</p><div align="center"><img src="/2019/c与cpp/大于.jpg"></div></li><li><p>小于运算</p><div align="center"><img src="/2019/c与cpp/小于.jpg"></div></li><li><p>大于等于运算</p><div align="center"><img src="/2019/c与cpp/大于等于.jpg"></div></li><li><p>小于等于运算</p><div align="center"><img src="/2019/c与cpp/小于等于.jpg"></div></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Equ(a, b) ((fabs((a) - (b))) &lt; (eps))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> More(a, b) ((a) &gt; (b + (eps)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Less(a, b) ((a) &lt; (b - (eps)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MoreEqu(a, b) ((a) &gt; (b - (eps)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LessEqu(a, b) ((a) &lt; (b + (eps)))</span></span><br></pre></td></tr></table></figure><h2 id="单点测试"><a href="#单点测试" class="headerlink" title="单点测试"></a>单点测试</h2><p>提交的程序被执行多次，每次执行会输入一组数据，得到输出后和此组数据的结果做比较，如果相同则判断此测试点通过，总成绩等于N次执行的成绩之和。PAT采用的是单点测试的方案。</p><h2 id="多点测试"><a href="#多点测试" class="headerlink" title="多点测试"></a>多点测试</h2><p>提交的程序被执行一次，会把所有的测试数据都输入，如果其中一组输出出错，则此题错误。所以此时需要程序能有循环读入多组数据的能力。大多数OJ系统采用这种方案，如<code>codeup</code>。下面介绍三种读入方案：</p><h3 id="while-EOF"><a href="#while-EOF" class="headerlink" title="while ... EOF"></a><code>while ... EOF</code></h3><p>应用于没有给定输入的结束条件，默认读到文件末尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while-break"><a href="#while-break" class="headerlink" title="while ... break"></a><code>while ... break</code></h3><p>应用于题目要求输入的数据满足某个条件时停止输入</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n) != EOF)&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while-T"><a href="#while-T" class="headerlink" title="while(T--)"></a><code>while(T--)</code></h3><p>当题目给出测试数据组数时采用这种方案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> T = <span class="number">20</span>；</span><br><span class="line"><span class="keyword">while</span>(T--)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Tue Mar 26 2019 20:48:35 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;
      
    
    </summary>
    
      <category term="算法笔记" scheme="https://isjinhao.github.io/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="C" scheme="https://isjinhao.github.io/tags/C/"/>
    
      <category term="C++" scheme="https://isjinhao.github.io/tags/C/"/>
    
      <category term="PAT" scheme="https://isjinhao.github.io/tags/PAT/"/>
    
  </entry>
  
</feed>
