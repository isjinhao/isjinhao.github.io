<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ISJINHAO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://isjinhao.github.io/"/>
  <updated>2019-04-01T15:03:00.236Z</updated>
  <id>https://isjinhao.github.io/</id>
  
  <author>
    <name>ISJINHAO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>类加载机制</title>
    <link href="https://isjinhao.github.io/2019/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>https://isjinhao.github.io/2019/类加载机制/</id>
    <published>2019-04-01T15:03:00.000Z</published>
    <updated>2019-04-01T15:03:00.236Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JVM中的锁优化</title>
    <link href="https://isjinhao.github.io/2019/JVM%E4%B8%AD%E7%9A%84%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>https://isjinhao.github.io/2019/JVM中的锁优化/</id>
    <published>2019-04-01T11:43:04.000Z</published>
    <updated>2019-04-03T01:10:40.283Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><h2 id="Java线程的实现方式"><a href="#Java线程的实现方式" class="headerlink" title="Java线程的实现方式"></a>Java线程的实现方式</h2><h3 id="OS中线程的实现方式"><a href="#OS中线程的实现方式" class="headerlink" title="OS中线程的实现方式"></a>OS中线程的实现方式</h3><p>参考：</p><ul><li><a href="https://isjinhao.github.io/2019/02-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/">https://isjinhao.github.io/2019/02-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6/</a></li><li>计算机操作系统（汤子瀛）</li></ul><h3 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h3><p>Java线程的实现机制和操作系统本身有关，限于笔者水平，我们下面介绍的Java线程都是基于<code>Linux</code>平台的实现。</p><p>在<code>Linux</code>平台上，一条Java线程会映射到一个轻量级进程（LWP）之中，而LWP的本质是供程序使用内核线程的接口，每个LWP都会对应一个内核支持线程（KLT），KLT的调度是内核通过操纵调度器（Thread Scheduler）完成，TS的功能就是将KLT的任务映射到各个处理器上。从这可以看出Java线程的创建、撤销、同步等操作都需要进行用户态和内核态的转换，是一种消耗较大的操作。</p><div align="center"><img src="/2019/JVM中的锁优化/java线程实现.jpg" style="width:80%"></div><h3 id="Java线程的状态"><a href="#Java线程的状态" class="headerlink" title="Java线程的状态"></a>Java线程的状态</h3><div align="center"><img src="/2019/JVM中的锁优化/线程状态.jpg" style="width:95%"></div><h2 id="自旋锁和自适应自旋"><a href="#自旋锁和自适应自旋" class="headerlink" title="自旋锁和自适应自旋"></a>自旋锁和自适应自旋</h2><p>最常控制同步的手段是互斥，也即<code>synchronized</code>，但是从上面的分析我们可以知道互斥操作对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态进行。不过虚拟机的开发团队意识到，共享数据的锁定时间在大多数情况下只会持续很短一段时间，所以对于多处理机的机器来说，我们可以让后请求锁的线程执行一个忙循环而不放弃处理器的执行时间。这就是自旋锁。</p><p>从上面的分析可知，自旋锁在多处理机的机器上可以减少内核态与用户态之间切换的消耗，但自旋本身是要占用处理机时间的，如果自旋等待的时间太多就会白白消耗处理机资源。</p><p>所以在JDK6中引入了自适应的自旋锁，自旋的时间由上次在同一个锁上的自旋时间以及锁的拥有者决定。。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋有很大几率成功，允许自旋较长的时间。如果对于某个锁很少自旋成功过，则以后可能会省略掉自旋过程。</p><h2 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h2><p>锁消除指的是虚拟机即时编译器在运行时，检测到对不可能发生共享的数据进行加锁就会进行锁消除。锁消除的判定依赖来源于逃逸分析的数据支持。这里会有一个问题就是：对象会不会发生逃逸其实是程序员可以感知到的，如果对于一段代码不可能存在竞争自然不会加锁。但是实际上Java中很多的同步不是程序员可以控制的。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1 + s2 + s3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们都知道String是一个不可变的对象，对于字符串的连接总是通过生成新的String对象来进行的，比如上面代码的实际操作是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concatString</span><span class="params">(String s1, String s2, String s3)</span></span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    sb.append(s3);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而<code>StringBuffer.append()</code>方法中有一个同步块，锁的就是<code>sb</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> StringBuffer <span class="title">append</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    toStringCache = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">super</span>.append(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这种锁程序员无法控制，但是JVM可以进行锁消除来优化代码。</p><h2 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h2><p>原则上，我们在编写并发代码的时候希望同步快范围越小越好，这样是为了使需要同步的操作数量尽可能变小。这种原则在大多数情况下都是合理的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁和解锁的操作出现在循环体中，会增加很多不必要的消耗，此时虚拟机会把锁的范围扩大来减少加锁解锁的操作。比如上面代码的<code>append()</code>操作就是如此。</p><h2 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h2><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。</p><p>HotSpot虚拟机的对象头(Object Header)包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”。</p><p>但是对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额 外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志 位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示。</p><div align="center"><img src="/2019/JVM中的锁优化/MarkWord.jpg" style="width:90%"></div><ul><li>epoch：偏向时间戳</li></ul><p>对象头的另外一部分是类型指针，即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说查找对象的元数据信息并不一定要经过对象本身（比如通过句柄访问对象时就可以不通过对象本身获得类型）。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中无法确定数组的大小。</p><h3 id="轻量级锁-1"><a href="#轻量级锁-1" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>轻量级锁的本质是减少传统的重量级锁使用操作系统互斥量产生的性能消耗。具体过程如下：</p><ol><li>在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁标志为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，官方称之为 Displaced Mark Word。</li><li>拷贝对象头中的Mark Word复制到锁记录中。</li><li>拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock record里的owner指针指向object mark word。如果更新成功，则执行步骤4，否则执行步骤5。</li><li>如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，即表示此对象处于轻量级锁定状态。</li><li>如果这个更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行。否则说明多个线程竞争锁，轻量级锁就要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word中存储的就是指向重量级锁（互斥量）的指针，后面等待锁的线程也要进入阻塞状态。 而当前线程便尝试使用自旋来获取锁，自旋就是为了不让线程阻塞，而采用循环去获取锁的过程。</li></ol><div align="center"><img src="/2019/JVM中的锁优化/轻量级锁.jpg" style="width:90%"></div><p>这里我们需要注意两个问题，</p><ul><li>第一：CAS是对<code>Mark Word</code>进行的CAS。</li><li>第二就是要考虑一个问题，为什么更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧？在代码进入同步块的时候，同步对象锁状态为无锁状态，把对象头中的Mark Word复制到锁记录中后如果发生了线程调度，可能再调度回来的时候别的线程CAS成功，所以本线程会CAS失败，此时对象的Mark Word指向别的线程的栈帧。但是在这个过程中怎么既能CAS失败，又指向本线程的栈帧呢？笔者没有弄懂。</li></ul><p>我们可以看到在有竞争的条件下，轻量级锁会膨胀为重量级锁，此时不仅使用到信号量，还会增加多余的CAS操作，所以在有竞争的条件下，轻量级锁的引入会增加线程同步消耗。不过事实证明：“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”，这是轻量级锁存在的必要。</p><h2 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h2><p>轻量级锁的目的是在无竞争的情况下使用CAS操作去除同步使用的互斥量。而偏向锁就是在无竞争的情况下把整个同步都去掉，连CAS都不用做了。具体过程：</p><ol><li>访问Mark Word中偏向锁的标识是否设置成1，锁标志位是否为01，确认为可偏向状态。</li><li>如果为可偏向状态，则测试线程ID是否指向当前线程，如果是，进入步骤5，否则进入步骤3。</li><li>如果线程ID并未指向当前线程，则通过CAS操作竞争锁。如果竞争成功，则将Mark Word中线程ID设置为当前线程ID，然后执行5；如果竞争失败，执行4。</li><li>如果CAS获取偏向锁失败，则表示有竞争。当到达全局安全点（safepoint）（在这个时间点上没有字节码正在执行）时获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码。（撤销偏向锁的时候会导致stop the word）</li><li>执行同步代码。</li></ol><p>撤销操作：</p><p>偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动去释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态，撤销偏向锁后恢复到未锁定（标志位为“01”）或轻量级锁（标志位为“00”）的状态。</p><div align="center"><img src="/2019/JVM中的锁优化/偏向锁.jpg" style="width:80%"></div><h2 id="锁膨胀"><a href="#锁膨胀" class="headerlink" title="锁膨胀"></a>锁膨胀</h2><p>一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，当到来第一个线程时，这个线程在修改对象头成为偏向锁的时候使用CAS操作，这时候的CAS是对对象头中的偏向线程ID做，会将偏向线程ID该为本线程的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。</p><p>一旦有第二个线程访问这个对象（个人理解，即使第一个线程运行结束，它持有的偏向锁不会主动释放，即对象头不会被修改），所以第二个线程可以看到对象时偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。</p><p>轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</p><div align="center"><img src="/2019/JVM中的锁优化/java_synchronized.png" style="width:100%"></div><p>掘金上的巨佬，提出了一些意见：按照图中流程，<em>如果发现锁已经膨胀为重量级锁，就直接使用互斥量mutex阻塞当前线程</em>。然而，自旋锁的一大好处就是减少线程切换的开销。在这里没有必要直接阻塞当前线程，大可以像轻量级锁一样，自旋一会，失败了再阻塞。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/choukekai/article/details/63688332" target="_blank" rel="noopener">https://blog.csdn.net/choukekai/article/details/63688332</a></li><li><a href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/" target="_blank" rel="noopener">https://blog.dreamtobe.cn/2015/11/13/java_synchronized/</a></li><li><a href="https://juejin.im/post/5a5c09d051882573282164ae" target="_blank" rel="noopener">https://juejin.im/post/5a5c09d051882573282164ae</a></li><li>深入理解JVM第二版（周志明）</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;Java线程的实现方式&quot;&gt;&lt;a href=&quot;#Java线程的实现方式&quot; class=&quot;headerlink&quot; title=&quot;Java线
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Class文件结构</title>
    <link href="https://isjinhao.github.io/2019/Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/"/>
    <id>https://isjinhao.github.io/2019/Class文件结构/</id>
    <published>2019-04-01T09:13:47.000Z</published>
    <updated>2019-04-01T14:03:28.210Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JIT和逃逸分析</title>
    <link href="https://isjinhao.github.io/2019/JIT%E5%92%8C%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90/"/>
    <id>https://isjinhao.github.io/2019/JIT和逃逸分析/</id>
    <published>2019-04-01T09:13:32.000Z</published>
    <updated>2019-04-01T14:03:28.217Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><h2 id="JIT"><a href="#JIT" class="headerlink" title="JIT"></a>JIT</h2><p>全称：Just-In-Time Compilation。</p><p>在部分商用虚拟机中（如HotSpot），Java程序最初是通过解释器（Interpreter）进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与<strong>本地平台相关的机器码</strong>，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（Just In Time Compiler，下文统称JIT编译器）。</p><p>引入JIT编译器的Java程序运行过程如下图：</p><div align="center"><img src="/2019/JIT和逃逸分析/Java文件运行.jpg" style="width:60%"></div><p>即时编译器并不是虚拟机必须的部分，Java虚拟机规范并没有规定Java虚拟机内必须要有即时编译器存在，更没有限定或指导即时编译器应该如何去实现。但是，即时编译器编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键的指标之一，它也是虚拟机中最核心且最能体现虚拟机技术水平的部分。</p><p>由于Java虚拟机规范并没有具体的约束规则去限制即使编译器应该如何实现，所以这部分功能完全是与虚拟机具体实现相关的内容，如无特殊说明，我们提到的编译器、即时编译器都是指Hotspot虚拟机内的即时编译器，虚拟机也是特指HotSpot虚拟机。</p><p>HotSpot虚拟机在JDK8中默认开启了JIT。</p><div align="center"><img src="/2019/JIT和逃逸分析/mixedmode.jpg" style="width:80%"></div><p>上图中的mixed mode便是指在硬件上跑程序时，使用解释和JIT编译的混合模式。</p><h3 id="设定HotSpot工作模式"><a href="#设定HotSpot工作模式" class="headerlink" title="设定HotSpot工作模式"></a>设定HotSpot工作模式</h3><ul><li>解释模式：<code>-Xint</code></li><li>编译模式：<code>-Xcomp</code></li><li>混合模式：<code>-Xmixed</code></li></ul><h3 id="热点探测"><a href="#热点探测" class="headerlink" title="热点探测"></a>热点探测</h3><p>如何判断方法或一段代码或是不是热点代码呢？要知道方法或一段代码是不是热点代码，是不是需要触发即时编译，需要进行Hot Spot Detection（热点探测）。目前主要的热点探测方式有以下两种：</p><h4 id="基于采样的热点探测"><a href="#基于采样的热点探测" class="headerlink" title="基于采样的热点探测"></a>基于采样的热点探测</h4><p>采用这种方法的虚拟机会周期性地检查各个线程的栈顶，如果发现某些方法经常出现在栈顶，那这个方法就是“热点方法”。这种探测方法的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</p><h4 id="基于计数器的热点探测"><a href="#基于计数器的热点探测" class="headerlink" title="基于计数器的热点探测"></a>基于计数器的热点探测</h4><p>采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阀值，就认为它是“热点方法”。这种统计方法实现复杂一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是它的统计结果相对更加精确严谨。</p><h3 id="HotSpot的热点检测方式？"><a href="#HotSpot的热点检测方式？" class="headerlink" title="HotSpot的热点检测方式？"></a>HotSpot的热点检测方式？</h3><p>在HotSpot虚拟机中使用的是第二种——基于计数器的热点探测方法，因此它为每个方法准备了两个计数器：方法调用计数器和回边计数器。在确定虚拟机运行参数的前提下，这两个计数器都有一个确定的阈值，当计数器超过阈值溢出了，就会触发JIT编译。</p><h4 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h4><p>顾名思义，这个计数器用于统计方法被调用的次数。</p><p>当一个方法被调用时，会先检查该方法是否存在被JIT编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在已被编译过的版本，则将此方法的调用计数器值加1，然后判断方法调用计数器与回边计数器值之和是否超过方法调用计数器的阈值。如果超过阈值，那么将会向即时编译器提交一个该方法的代码编译请求。</p><p>如果不做任何设置，执行引擎并不会同步等待编译请求完成，而是继续进行解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译工作完成之后，这个方法的调用入口地址就会系统自动改写成新的，下一次调用该方法时就会使用已编译的版本。</p><div align="center"><img src="/2019/JIT和逃逸分析/方法调用计数器.png" style="width:60%"></div><p>回边计数器<br>它的作用就是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为“回边”。</p><div align="center"><img src="/2019/JIT和逃逸分析/回边计数器.png" style="width:60%"></div><h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>在《深入理解Java虚拟机中》关于Java堆内存有这样一段描述：</p><blockquote><p>但是，随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。</p></blockquote><p>这里只是简单提了一句，并没有深入分析，笔者在刚到这里由于对JIT、逃逸分析等技术不了解，无法真正理解上面这段话的含义，但现在略有理解。JIT刚才已经介绍过，逃逸分析这部分摘取周志明老师的深入理解JVM第二版。</p><h3 id="逃逸"><a href="#逃逸" class="headerlink" title="逃逸"></a>逃逸</h3><p>逃逸分析的基本行为就是分析对象动态作用域：</p><h4 id="方法逃逸"><a href="#方法逃逸" class="headerlink" title="方法逃逸"></a>方法逃逸</h4><p>当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StringBuffer <span class="title">craeteStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉代码中返回了<code>sb</code>，这样这个StringBuffer有可能被其他方法所改变，这样它的作用域就不只是在方法内部，虽然它是一个局部变量，称其逃逸到了方法外部。如果想要StringBuffer sb不逃出方法，可以这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">createStringBuffer</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    sb.append(s1);</span><br><span class="line">    sb.append(s2);</span><br><span class="line">    <span class="keyword">return</span> sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="线程逃逸"><a href="#线程逃逸" class="headerlink" title="线程逃逸"></a>线程逃逸</h4><p>同理，如果一个对象可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，则称为线程逃逸。</p><h3 id="逃逸分析-1"><a href="#逃逸分析-1" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><p>如果能证明一个对象不会逃逸到方法或线程以外，也就是别的方法或线程无法通过任何途径访问这个对象，则可能为这个变量进行一些高效的优化。</p><h3 id="如何优化"><a href="#如何优化" class="headerlink" title="如何优化"></a>如何优化</h3><h4 id="栈上分配"><a href="#栈上分配" class="headerlink" title="栈上分配"></a>栈上分配</h4><p>Java虚拟机中，在Java堆上分配创建对象的内存空间几乎是Java程序员都清楚的常识了，Java堆中的对象对于各个线程都是共享可见的，只要持有这个对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但回收动作无论是筛选可回收对象还是回收和整理内存都需要耗费时间。如果确定一个对象不会逃逸出方法之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随着栈帧的出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力会小很多。</p><h4 id="同步消除"><a href="#同步消除" class="headerlink" title="同步消除"></a>同步消除</h4><p>线程同步本身是一个很耗时的过程，如果逃逸分析能够确定一个变量不会逃逸出线程，无法被其他线程访问，那这个变量的读写肯定就不会有竞争，对这个变量实施的同步措施也就可以消除掉。</p><h4 id="标量替换"><a href="#标量替换" class="headerlink" title="标量替换"></a>标量替换</h4><p>标量是指一个数据已经无法再分解成更小的数据来显示了，Java虚拟机中的原始数据类型（ing、long等数值类型以及引用类型）都不能再进一步分解，他们就可以称为标量。相应的，如果一个数据可以继续分解，那么就把它叫做聚合量。对象就是常见的聚合量。如果把一个Java对象拆散，根据程序访问的情况，将其使用到的成员变量恢复原始类型来访问就叫做标量替换。如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散的话，程序运行的时候就可以不创建这个对象，而改为直接创建若干个标量来代替。</p><h3 id="逃逸分析开启"><a href="#逃逸分析开启" class="headerlink" title="逃逸分析开启"></a>逃逸分析开启</h3><p>JDK8中JIT和逃逸分析都是默认开启的， JVM参数如下：</p><ul><li><p><code>-XX:+DoEscapeAnalysis</code> ： 表示开启逃逸分析</p></li><li><p><code>-XX:-DoEscapeAnalysis</code> ： 表示关闭逃逸分析</p></li></ul><h3 id="逃逸分析测试"><a href="#逃逸分析测试" class="headerlink" title="逃逸分析测试"></a>逃逸分析测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> a1 = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">        alloc();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> a2 = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">"cost "</span> + (a2 - a1) + <span class="string">" ms"</span>);</span><br><span class="line">    <span class="comment">// 为了方便查看堆内存中对象个数，线程sleep</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e1) &#123;</span><br><span class="line">        e1.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭逃逸分析"><a href="#关闭逃逸分析" class="headerlink" title="关闭逃逸分析"></a>关闭逃逸分析</h4><ol><li><p>DOS窗口执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx4G -Xms4G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError Test</span><br></pre></td></tr></table></figure></li><li><p>新开一个DOS窗口，输入<code>jps</code>，找到Test进程，使用<code>jmap -histo PID</code>查看。</p><div align="center"><img src="/2019/JIT和逃逸分析/不开启逃逸分析测试.jpg" style="width:80%"></div></li></ol><h4 id="开启逃逸分析"><a href="#开启逃逸分析" class="headerlink" title="开启逃逸分析"></a>开启逃逸分析</h4><ol><li><p>DOS窗口执行命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xmx4G -Xms4G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError Test</span><br></pre></td></tr></table></figure></li><li><p>新开一个DOS窗口，输入<code>jps</code>，找到Test进程，使用<code>jmap -histo PID</code>查看。</p><div align="center"><img src="/2019/JIT和逃逸分析/开启逃逸分析测试.jpg" style="width:80%"></div></li></ol><p>可以发现开启逃逸分析之后，堆中只创建了11万个对象。不开启就会创建100万个对象。</p><h3 id="逃逸分析并不成熟"><a href="#逃逸分析并不成熟" class="headerlink" title="逃逸分析并不成熟"></a>逃逸分析并不成熟</h3><p>关于逃逸分析的论文在1999年就已经发表了，但直到JDK 1.6才有实现，而且这项技术到如今也并不是十分成熟的。</p><p>其根本原因就是无法保证逃逸分析的性能消耗一定能高于他的消耗。虽然经过逃逸分析可以做标量替换、栈上分配、和锁消除。但是逃逸分析自身也是需要进行一系列复杂的分析的，这其实也是一个相对耗时的过程。</p><p>一个极端的例子，就是经过逃逸分析之后，发现没有一个对象是不逃逸的。那这个逃逸分析的过程就白白浪费掉了。</p><p>虽然这项技术并不十分成熟，但是他也是即时编译器优化技术中一个十分重要的手段。</p><h2 id="JIT和逃逸分析的联系"><a href="#JIT和逃逸分析的联系" class="headerlink" title="JIT和逃逸分析的联系"></a>JIT和逃逸分析的联系</h2><p>最开始的时候笔者一直以为，逃逸分析是JIT中的优化技术，为什么呢？因为逃逸分析的代价较大，而JIT是对热点代码进行优化，如果对诸如循环等代码进行逃逸分析，只需要分析一次就可以得到循环中的代码是否满足逃逸的条件，可以淡化逃逸分析的代价。但事实上是笔者的一个错误理解。测试中即使关闭JIT也可以开启逃逸分析。如<code>java -Xint -XX:+DoEscapeAnalysis Test</code>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/sunxianghuang/article/details/52094859" target="_blank" rel="noopener">https://blog.csdn.net/sunxianghuang/article/details/52094859</a></li><li>深入理解JVM第二版，周志明</li><li><a href="http://ju.outofmemory.cn/entry/354837" target="_blank" rel="noopener">http://ju.outofmemory.cn/entry/354837</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;JIT&quot;&gt;&lt;a href=&quot;#JIT&quot; class=&quot;headerlink&quot; title=&quot;JIT&quot;&gt;&lt;/a&gt;JIT&lt;/h2&gt;&lt;p&gt;全
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>基于比较的三种简单排序</title>
    <link href="https://isjinhao.github.io/2019/%E5%9F%BA%E4%BA%8E%E6%AF%94%E8%BE%83%E7%9A%84%E4%B8%89%E7%A7%8D%E7%AE%80%E5%8D%95%E6%8E%92%E5%BA%8F/"/>
    <id>https://isjinhao.github.io/2019/基于比较的三种简单排序/</id>
    <published>2019-04-01T07:32:23.000Z</published>
    <updated>2019-04-01T14:03:28.215Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    简单排序：</span></span><br><span class="line"><span class="comment">        平均时间复杂度都是O(N方)级别。包括：冒泡排序、插入排序、选择排序 </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    说明：</span></span><br><span class="line"><span class="comment">        实现的算法都是升序排序。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;e1, <span class="keyword">int</span> &amp;e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = e1;</span><br><span class="line">    e1 = e2;</span><br><span class="line">    e2 = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    冒泡排序（稳定）：</span></span><br><span class="line"><span class="comment">        重复地走访过要排序的元素列，一次比较两个相邻的元素，如果他们的顺序（如从大到小、首字母从</span></span><br><span class="line"><span class="comment">        A到Z）错误就把他们交换过来。走访元素的工作是重复地进行直到没有相邻元素需要交换，也就是说</span></span><br><span class="line"><span class="comment">        该元素已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端</span></span><br><span class="line"><span class="comment">        （升序或降序排列），就如同碳酸饮料中二氧化碳的气泡最终会上浮到顶端一样，故名“冒泡排序”。</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)    <span class="comment">//len - 1 趟就行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - i - <span class="number">1</span>; j++) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(flag == <span class="number">0</span>)   <span class="comment">//某趟排序没有进行交换时，排序结束 </span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    插入排序（稳定）：</span></span><br><span class="line"><span class="comment">        从索引为1的元素（设为temp）开始开始，每次把之前的元素调整成有序序列。由于之前的元素都是有序序列， </span></span><br><span class="line"><span class="comment">        从后向前若temp小于当前遍历到的元素（arr[j]），此元素后移。否则退出此次遍历。退出后把temp插入当前的arr[j]。 </span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = arr[i], j;</span><br><span class="line">        <span class="keyword">for</span>(j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j--)</span><br><span class="line">            arr[j + <span class="number">1</span>] = arr[j];</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    选择排序（不稳定）：</span></span><br><span class="line"><span class="comment">        每次从待排序的数据元素中选出最小的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectSort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> min = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &lt; len; j++)</span><br><span class="line">            <span class="keyword">if</span>(arr[j] &lt; arr[min])</span><br><span class="line">                min = j;</span><br><span class="line">        swap(arr[min], arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line">    srand((<span class="keyword">unsigned</span>)time(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        arr[i] = rand() % <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    selectSort(arr, <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span clas
      
    
    </summary>
    
      <category term="DS" scheme="https://isjinhao.github.io/categories/DS/"/>
    
    
      <category term="DSA" scheme="https://isjinhao.github.io/tags/DSA/"/>
    
      <category term="排序" scheme="https://isjinhao.github.io/tags/%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>HTML基础</title>
    <link href="https://isjinhao.github.io/2019/HTML%E5%9F%BA%E7%A1%80/"/>
    <id>https://isjinhao.github.io/2019/HTML基础/</id>
    <published>2019-03-31T14:20:42.000Z</published>
    <updated>2019-03-31T14:26:48.553Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">target</span>=<span class="string">"_self"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="target的属性值"><a href="#target的属性值" class="headerlink" title="target的属性值"></a>target的属性值</h3><ul><li><code>_self</code>：在本窗口中打开目标页面。默认属性值。</li><li><code>_blank</code>：在新的浏览器窗口打开目标页面。</li><li><code>_parent</code>：这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标<code>_self</code>等效，即如果不使用<code>frameset</code>，就和<code>_self</code>等效。</li><li><code>_top</code>：这个目标使得文档载入包含这个超链接的窗口，用<code>_top</code>目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。</li><li><code>其他值</code>：给一堆超链接以相同的target值，这种方式可以使得一组超链接在同一窗口打开，即<strong>通过单击一个窗口中的不同链接控制另一窗口内容变化</strong>。首先，浏览器会找与target值相符的框架或者窗口中的文档，有则在其中显示文档。如果不存在，浏览器打开一个新窗口，给其指定一个标识为target值，之后只要该窗口不关闭，其它超链接就可以指向这个新窗口。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.com.hk"</span> <span class="attr">target</span>=<span class="string">"HelloWorld"</span>&gt;</span>google<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://cn.bing.com"</span> <span class="attr">target</span>=<span class="string">"HelloWorld"</span>&gt;</span>必应<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">target</span>=<span class="string">"HelloWorld"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.soso.com"</span> <span class="attr">target</span>=<span class="string">"HelloWorld"</span>&gt;</span>搜搜<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="锚链接"><a href="#锚链接" class="headerlink" title="锚链接"></a>锚链接</h3><p>跳转至网页的指定部分。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"tar"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1000行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#tar"</span>&gt;</span>锚链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="链接邮件"><a href="#链接邮件" class="headerlink" title="链接邮件"></a>链接邮件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:xxx@yyy.zzz"</span>&gt;</span>发送邮件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="水平线标签"><a href="#水平线标签" class="headerlink" title="水平线标签"></a>水平线标签</h2><p><code>&lt;hr /&gt;</code></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">border</span>=<span class="string">"xxx"</span> <span class="attr">alt</span>=<span class="string">"yyy"</span> <span class="attr">title</span>=<span class="string">"zzz"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片分类"><a href="#图片分类" class="headerlink" title="图片分类"></a>图片分类</h3><ul><li><code>bmp</code>：<code>windows</code>系统下的标准位图（像素点构成的图）格式。文件较大，不建议大量使用。</li><li><code>gif</code>：动图。但是只支持256种色彩，不适合保存图片。</li><li><code>jpeg</code>：又称<code>jpg</code>，有损压缩的图片。<ul><li>有损压缩：只对图像或声波中的某些频率成分不敏感的特性，允许压缩过程中损失一定的信息；虽然不能完全恢复原始数据，但是所损失的部分对理解原始图像的影响缩小，却换来了大得多的压缩比。</li></ul></li><li><code>png</code>：无损压缩图片。</li></ul><h3 id="alt"><a href="#alt" class="headerlink" title="alt"></a><code>alt</code></h3><p>图片无法加载时，用于替换图片内容的文字。</p><h3 id="title"><a href="#title" class="headerlink" title="title"></a><code>title</code></h3><p>鼠标悬停时显示的文字。</p><h3 id="图片热点"><a href="#图片热点" class="headerlink" title="图片热点"></a>图片热点</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> =<span class="string">"planets.gif"</span> <span class="attr">alt</span>=<span class="string">"Planets"</span> <span class="attr">usemap</span> =<span class="string">"#planetmap"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"planetmap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"0,0,110,260"</span> <span class="attr">href</span>=<span class="string">"sun.htm"</span> <span class="attr">alt</span>=<span class="string">"Sun"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">"129,161,10"</span> <span class="attr">href</span>=<span class="string">"mercur.htm"</span> <span class="attr">alt</span>=<span class="string">"Mercury"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">"180,139,14"</span> <span class="attr">href</span>=<span class="string">"venus.htm"</span> <span class="attr">alt</span>=<span class="string">"Venus"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="http://www.w3school.com.cn/tags/att_area_coords.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/tags/att_area_coords.asp</a></p><h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><div align="center"><img src="/2019/HTML基础/html和css基础/tab.png" style="width:80%"></div><h2 id="滚动字幕"><a href="#滚动字幕" class="headerlink" title="滚动字幕"></a>滚动字幕</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">marquee</span>&gt;</span>默认的滚动字幕（左←右）<span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">direction</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (1).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (2).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (3).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (4).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (5).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (6).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (7).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (8).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"02_11 (9).jpg"</span> <span class="attr">width</span>=<span class="string">"128"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">height</span>=<span class="string">"150"</span> <span class="attr">bgcolor</span>=<span class="string">"#eeeeee"</span> <span class="attr">direction</span>=<span class="string">"up"</span> <span class="attr">scrollamount</span>=<span class="string">"220"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>1111111111111111<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>2222222222222222<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>3333333333333333<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>4444444444444444<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>5555555555555555<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">marquee</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ul><li>cellpadding：规定单元边沿与其内容之间的空白</li><li><p>cellspacing：规定的是单元之间的空间。</p></li><li><p>colspan：合并列</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">width</span>=<span class="string">"400"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"30%"</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">colspan</span>=<span class="string">"2"</span> <span class="attr">width</span>=<span class="string">"70%"</span>&gt;</span>考试成绩<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"35%"</span>&gt;</span>理论：79分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">width</span>=<span class="string">"35%"</span>&gt;</span>上机：88分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>理论：87分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>上机：74分<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>rowspan：合并列</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">"1"</span> <span class="attr">width</span>=<span class="string">"90%"</span> <span class="attr">align</span>=<span class="string">"center"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">bgcolor</span>=<span class="string">"#eeeeee"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"30%"</span>&gt;</span>日期<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"30%"</span>&gt;</span>时间<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">th</span> <span class="attr">width</span>=<span class="string">"40%"</span>&gt;</span>上映电影<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"3"</span>&gt;</span>8月1日<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>8:00-11:00<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>哈利珀特7<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>11:00-13:00<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>哈利珀特7<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>13:00-15:00<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>阿凡达2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">rowspan</span>=<span class="string">"2"</span>&gt;</span>8月2日<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>8:00-11:00<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>哈利珀特7<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>13:00-15:00<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span>&gt;</span>阿凡达2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;超链接&quot;&gt;&lt;a href=&quot;#超链接&quot; class=&quot;headerlink&quot; title=&quot;超链接&quot;&gt;&lt;/a&gt;超链接&lt;/h2&gt;&lt;fig
      
    
    </summary>
    
      <category term="前端" scheme="https://isjinhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://isjinhao.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="https://isjinhao.github.io/tags/HTML/"/>
    
  </entry>
  
  <entry>
    <title>Java的GC</title>
    <link href="https://isjinhao.github.io/2019/Java%E7%9A%84GC/"/>
    <id>https://isjinhao.github.io/2019/Java的GC/</id>
    <published>2019-03-31T07:58:38.000Z</published>
    <updated>2019-04-01T07:27:56.217Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:13 GMT+0800 (GMT+08:00) --><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>程序计数器、虚拟机栈、本地方法栈这些区域不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。垃圾收集器关注的是堆和方法区中的垃圾。</p><h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><h3 id="对象判死算法"><a href="#对象判死算法" class="headerlink" title="对象判死算法"></a>对象判死算法</h3><h4 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。但这种计数法无法解决循环引用的问题，即若A对象中有属性B，B对象中有属性A，则A、B永远都有计数。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><div align="center"><img src="/2019/Java的GC/可达性算法.jpg" style="width:80%"></div><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul><h3 id="再谈引用"><a href="#再谈引用" class="headerlink" title="再谈引用"></a>再谈引用</h3><p>在Java1.2之前，引用的定义是这样的：</p><blockquote><p>如果reference类型的数据中存储的数值代表的是另外一块内存中的起始地址，就称这块内存代表着一个引用。</p></blockquote><p>我们可以看到，这个引用的定义是非常狭隘的，因为他不能描述一些“鸡肋”对象，即我们最希望的是能描述这样一类对象：当内存空间还足够时，则能保存在内中，如果内存空间在回收后仍然很紧张则可以抛弃这些对象。所以，在Java1.2以后提出了新的引用定义：</p><ul><li>强引用：在代码中普遍存在的，类似<code>Object obj = new Object();</code>。只要强引用还存在，垃圾回收期就永远不会回收被引用的对象</li><li>软引用：用来描述一些还有用，但并非必须的对象。这样当系统要发生内存溢出异常之前，就会把软引用列进第二次垃圾回收的计划中。</li><li>弱引用：比软引用还弱的引用，被弱引用的对象只能存活到下一次垃圾回收之前。</li><li>虚引用：最弱的一种引用关系了。使用虚引用的唯一目的就是在这个对象回收前收到一个系统回收通知。</li></ul><h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使是不可达对象，也并非是非死不可的，这时候它们暂时处于”缓刑“阶段，真正宣告一个对象死亡，至少要经过<strong>两次标记过程</strong>：</p><p>如果对象在进行根搜索后发现跟root不同根，就被标记一次，同时进行筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法，”没有必要执行”的原因如下：当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>已经被JVM调用过（说明一个对象的<code>finalize()</code>方法只能执行一次）。如果这个对象有必要执行<code>finalize()</code>方法，JVM就会把它放在<code>F-Queue</code>中，稍后<code>JVM</code>会触发一个低优先级的线程去执行。<strong>但是去执行并不承诺会等待它运行结束，因为如果一个对象在finalize()方法中执行缓慢，甚至发生了死循环，就会导致F-Queue其他对象永久处于等待状态，更严重的话可能会拖垮整个内存回收系统。</strong><code>finalize()</code>是对象逃脱死亡命运的最后一次机会，稍后<code>GC</code>将会对<code>F-Queue</code>进行第二次小规模的标记，如果在<code>finalize()</code>中将自己和root挂在一个根上（比如把自己赋值给某个类变量或者对象的成员变量），那么在这第二次标记将会被移除出“即将回收的集合”：如果对象还没有逃脱，那么就基本上真的被回收了。</p><p>不过非常不推荐使用finalize()方法自救对象，因为这是Java刚诞生为了使C/C++程序员更容易接受它作的一个妥协。它的运行带价高昂，不确定性大，无法保证各个对象的调用顺序。<strong>有些教材中提到它使用“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方法都可以做的更好、更及时，Java程序员完全可以忘掉Java有finalize()。</strong></p><p><code>finalize()</code>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"haha, i'm still alive!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line">        <span class="comment">//对象第一次拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"5555, i'm dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对象第二次拯救自己，但是却跪了。因为finalize只能执行一次呀，亲！！</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"5555, i'm dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output:</span></span><br><span class="line"><span class="comment">    finalize method executed!</span></span><br><span class="line"><span class="comment">    haha, i'm still alive!</span></span><br><span class="line"><span class="comment">    5555, i'm dead!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>永久代的垃圾收集主要回收两部分内容：</p><ul><li>废弃常量：以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</li><li>无用的类：判断一个类是无用的类的条件比废弃变量要苛刻的多，要同时满足3个条件才能算是“无用的类”：<ol><li>该类所有的实例都已经被回收，意思是堆上没有该对象的实例了</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法（因为通过反射，就一定要加载该类）</li></ol></li></ul><p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h3><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。有两个问题：一是效率不高，因为当对象数量比较多的时候一一进行标记和清除较复杂；二是会产生内存碎片，当需要大的连续内存空间时，即使碎片内存总和远大于需求，也会触发垃圾回收操作。</p><div align="center"><img src="/2019/Java的GC/标记清除算法.jpg" style="width:80%"></div><h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。实现简单，运行高效，但是空间缩小为原来的一半了。<strong>现在的商业JVM采用这种算法来回收新生代，IBM经过调研发现，新生代的对象98%都是朝生夕死的，所有并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。</strong>当回收时，将Eden和Survivor还存活着的对象一次性拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。<strong>HotSpot虚拟机默认Eden和Survivor的大小比例是8：1</strong>，也就是每次新生代中可用内存空间为整个内存空间的9/10，只有10%的内存是用来浪费的。当然了，我们无法保证每次回收只有少于10%的对象存活，当存活对象大于10%，就会借用其他内存（这里指老年代）进行分配担保。分配担保的详细介绍在后面。</p><h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。（老年代一般采用这个方法）</p><h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>当前商业虚拟机的垃圾回收都采用分代收集算法，这种算法没有啥特别的，就是<strong>根据对象的存活周期的不同将内存划分为几块</strong>，一般是把Java堆分为新生代和老年代，这样就可以根据每个代不同的特点采用最适当的回收算法。比如新生代存活对象少，就采用复制算法；老年代存活对象少，复制的话代价太大，就可以采用标记-整理算法。</p><h2 id="HotSpot-的算法实现"><a href="#HotSpot-的算法实现" class="headerlink" title="HotSpot 的算法实现"></a>HotSpot 的算法实现</h2><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>可达性分析在逐个检查引用链和GC停顿（保证分析工作的一致性）上浪费时间较多。主流Java虚拟机使用的都是准确式GC，即虚拟机应当有办法直接得知哪些地方存放着对象的引用。HotSpot是通过一个OopMap的数据结构来达到这个目的的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p><h3 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h3><p>HotSpot没有为每条指令都生成OopMap，那样占用空间太多，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p><p>另一个问题是如何让所有线程都跑到最近的安全点停顿。这里有两种方案可供选择：<strong>抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）</strong>，其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</p><h3 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h3><p>如果线程没有在执行呢，比如线程处于Sleep状态或者Blocked状态，就需要安全区域解决了。安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</p><p>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p><h3 id="OopMap和安全点辨析"><a href="#OopMap和安全点辨析" class="headerlink" title="OopMap和安全点辨析"></a>OopMap和安全点辨析</h3><p>OopMap 记录了栈上本地变量到堆上对象的引用关系。其作用是：垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收。但问题是，栈上的本地变量表里面只有一部分数据是 Reference 类型的（它们是我们所需要的），那些非 Reference 类型的数据对我们而言毫无用处，但我们还是不得不对整个栈全部扫描一遍，这是对时间和资源的一种浪费。</p><p>一个很自然的想法是，能不能用空间换时间，在某个时候把栈上代表引用的位置全部记录下来，这样到真正 gc 的时候就可以直接读取，而不用再一点一点的扫描了。事实上，大部分主流的虚拟机也正是这么做的，比如 HotSpot ，它使用一种叫做 OopMap 的数据结构来记录这类信息。</p><p>我们知道，一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面可能有多个安全点。 gc 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的<code>OopMap</code>，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的<code>OopMap</code>，通过栈中记录的被引用对象的内存地址，即可找到这些对象（ GC Roots ）。</p><p>参考：<a href="https://dsxwjhf.iteye.com/blog/2201685" target="_blank" rel="noopener">https://dsxwjhf.iteye.com/blog/2201685</a></p><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><div align="center"><img src="/2019/Java的GC/hotspot_gc.jpg" style="width:60%"></div><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>最基本，历史最悠久。新生代的，“单线程的”，只会用一个CPU或一个线程工作，并且收集时，必须暂停所有的工作线程，直到收集结束。它依然是虚拟机运行在<code>Client</code>端的默认新生代收集器。简单而高效，因为它不需要考虑线程切换，只专注一次把收集工作搞定，而且在<code>Client</code>端，新生代的内存一般只有几十M或者一两百M的样子，完成一次收集工作完全可以控制在几十毫秒或者一百毫秒左右，不会有很大的停顿感。</p><div align="center"><img src="/2019/Java的GC/serial.jpg" style="width:80%"></div><h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>这个本质上就是Serial收集器的多线程版本。许多运行在Server模式下的虚拟机中首选的<strong>新生代收集器</strong>，其中还有一个与性能无关<strong>但很重要的原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作</strong>。（原因是Parallel Scavenge收集器和后面的G1收集器都没有使用传统的GC收集器代码框架，而是另外独立实现的，其余几种收集器则共用了框架代码）。ParNew收集器也是使用<code>-XX:+UseConcMarkSweepGC</code>选项后的默认新生代收集器，当然也可以使用<code>-XX:+UseParNewGC</code>选项来显式指定使用</p><p>单CPU的话一般会考虑用Serial，多CPU的话一般考虑用ParNew，<strong>它默认开启的收集器线程数和CPU核数相同，当你想控制的时候，可以使用<code>-XX:ParallelGCThreads</code>参数来限制收集器的线程数。</strong></p><p>然后提前解释一下<strong>并行</strong>和<strong>并发</strong>的概念，因为后面会有几个并发和并行的收集器：</p><ul><li>并行(Parallel)：指多条垃圾收集线程并行工作，<strong>但此时用户线程仍然处于等待状态</strong>。所以，遇到 Parallel 关键字的话，都是并行。所以当它们工作的时候，用户线程是阻塞的。所以也是 stop the world</li><li>并发(Concurrent)：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会根据时间片轮转交替进行），用户程序继续运行，而垃圾收集程序运行在另外一个CPU上。所以遇到 concurrent 关键字就是 GC 线程和用户线程在一段时间内交叉运行，不会将用户线程阻塞，不是 stop the world</li></ul><div align="center"><img src="/2019/Java的GC/parnew.jpg" style="width:80%"></div><h3 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h3><p>Parallel Scavenge也是<strong>一个新生代收集器</strong>，它也是<strong>使用复制算法</strong>的收集器，同时也是<strong>并行的多线程收集器</strong>。它的目标是达到可控制的CPU吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾回收时间）。比如虚拟机运行了100分钟，垃圾回收使用了1分钟，那么吞吐量就是99%。</p><p>这就说说一下应用场景了。</p><ul><li>停顿时间（垃圾回收时间）： 停顿时间越短越适合于用户交互的程序，良好的响应速度能提升用户体验</li><li>高吞吐量： 可以最高效率的利用CPU时间，尽快的完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务</li></ul><p>为了这两个目的，Parallel Scavenge收集器提供了2个参数：</p><ul><li><code>-XX:MaxGCPauseMillis</code>：大于0的毫秒数，收集器将尽力保证内存回收时间不超过这个值。不过不要异想天开认为把这个值设的特别小，就能使系统垃圾收集速度更快，GC停顿时间缩短肯定是有代价的，它会牺牲吞吐量和新生代空间来实现。</li><li><code>-XX:GCTimeRatio</code>：大于0小于100的整数.假如设为N，那么垃圾收集时间占总时间的比率就是1/(1+N),比如设置为19,占比就是1/(1+19)=5%，默认值是99，即1%。</li><li><code>-XX:+UseAdaptiveSizePolicy</code>：这也是一个有用的参数，放在这里说一下。它是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（<code>-Xmn</code>）、Eden、Survivor区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以一同最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（<code>GC Ergonomics</code>）。<strong>自适应调节策略也是Parallel Scavenge收集器和ParNew收集器的一个重要区别</strong></li></ul><h3 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”<strong>标记-整理</strong>“算法。这个收集器的主要意义就是被Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用；另外一个就是CMS的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。</p><h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。是在JDK 1.6之后才提供的。前面说过，Parallel Scavenge收集器采用了独立的架构，无法和CMS配合使用。那么，在JDK 1.6以前，Parallel Scavenge只能和Serial Old配合使用。因为Serial Old是单线程的，所以在多CPU情况下无法发挥性能，所以根本实现不了高吞吐量的需求，直到JDK 1.6推出了Parallel Old之后，Parallel Scavenge收集器和Parallel Old搭配，才真正实现了对吞吐量优先的控制。所以，<strong>在注重吞吐量及CPU资源敏感的场合，都可以考虑Parallel Scavenge和Parallel Old组合</strong>。</p><div align="center"><img src="/2019/Java的GC/parallel.jpg" style="width:80%"></div><h3 id="CMS（Comcurrent-Mark-Sweep）收集器"><a href="#CMS（Comcurrent-Mark-Sweep）收集器" class="headerlink" title="CMS（Comcurrent Mark Sweep）收集器"></a>CMS（Comcurrent Mark Sweep）收集器</h3><p>CMS收集器是<strong>以获取最短回收停顿时间为目标的收集器</strong>。目前很大一部分的Java应用都集中在互联网站或者B/S系统上，这类应用<strong>尤其重视服务的响应速度，希望系统停顿时间最短，给用户最佳的用户体验。而CMS收集器就非常符合这类应用的需求</strong></p><p>从名字上可以看出，”Mark Sweep“是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤：</p><ol><li>初始标记：初始标记仅仅只是标记一下GC roots能直接关联到的对象，速度很快，需要stop the world。</li><li>并发标记：并发标记就是进行GC Roots Tracing（可达性算法）的过程。</li><li>重新标记：重新标记则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变化的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍微长一些，但远比并发标记的时间短，需要stop the world。</li><li>并发清除：垃圾清除</li></ol><div align="center"><img src="/2019/Java的GC/cms.jpg" style="width:80%"></div><p>由于整个过程中，并发标记和并发清除时间最长，收集器线程可以和用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><p>CMS收集器的优点在于<strong>并发收集、低停顿</strong>，但是也不是完美的，主要有3个显著的缺点：</p><ol><li>CMS收集器对CPU资源非常敏感。默认情况下，CMS的收集线程数=(CPU数目+3)/4，当CPU个数大于4的时候，CMS的收集线程不会超过整个CPU占用率的25%。但是在CPU个数比较小的情况下，CPU占用就会突然增大，这样对于初始标记和并发标记这样”Stop The World”的过程来说，用户就会明显感觉到停顿。</li><li><strong>CMS收集器无法处理浮动垃圾，可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生</strong>。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，它<strong>需要预留一部分空间提供并发收集时的线程使用。在JDK1.5默认设置下，CMS收集器在老年代使用了68%的空间会被激活，这是一个偏保守的设置。</strong>如果在应用中，老年代增长不是太快，可以适当调高这个参数-XX:CMSInitiatingOccupancyFraction。要是CMS运行期间预留的内存无法满足程序的需要，就会出现”Concurrent Mode Failure”失败，这时候JVM会启动后备方案：临时启动Serial Old收集器来重新进行老年代的垃圾收集，因为是单线程，停顿时间就会更长了。所以如果大量出现”Concurrent Mode Failure”，就可以将这个值调低</li><li>CMS是基于<strong>标记-清除</strong>算法实现的收集器，所以会产生内存碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦：老年代还有空间但是没有连续的足够大的空间，于是不得不触发一次Full GC。为了解决这个问题，有一个开关叫做-XX:+UseCMSCompactAtFullCollection，用于在Full GC时开启内存碎片的合并整理过程。当然，这个内存整理没法并发，只有”Stop The World”了。另外，虚拟机还设计了一个参数-XX:CMSFullGCsBeforeCompaction,用于指定在多少次不压缩的Full GC后，跟着来一次带压缩的。</li></ol><h3 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h3><p>G1是一款面向服务端应用的垃圾收集器。与其他GC收集器相比，G1具备如下特点。</p><ul><li>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。</li><li>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</li><li>空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。</li><li>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</li></ul><p>G1收集器的运作大致可划分为以下几个步骤：</p><ul><li>初始标记（Initial Marking）</li><li>并发标记（Concurrent Marking）</li><li>最终标记（Final Marking）</li><li>筛选回收（Live Data Counting and Evacuation）</li></ul><h3 id="理解GC日志"><a href="#理解GC日志" class="headerlink" title="理解GC日志"></a>理解GC日志</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">33.125: [GC [DefNew: 3324K-&gt;152K(3712K), 0.0025925 secs] 3324K-&gt;152K(11904K), 0.0031680 secs]</span><br><span class="line">100.667: [Full GC [Tenured: 0K-&gt;210K(10240K), 0.0149142 secs] 4603K-&gt;210K(19456K), [Perm : 2999K-&gt;2999K(21248K)], 0.0150007 secs] [Times: user=0.01 sys=0.00, real=0.02 secs]</span><br></pre></td></tr></table></figure><p>最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</p><p>GC日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“[Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“[Full GC（System）”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Full GC 283.736: [ParNew: 261599k-&gt;261599k(261592k), 0.0000288sec]]</span><br></pre></td></tr></table></figure><p>接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的。</p><p>后面方括号内部的“3324K-&gt;152K（3712K）”含义是“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-&gt;152K（11904K）”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量（Java堆总容量）”。</p><p>再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“[Times：user=0.01 sys=0.00，real=0.02 secs]”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致。</p><h3 id="参数总结"><a href="#参数总结" class="headerlink" title="参数总结"></a>参数总结</h3><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">UseSerialGC</td><td style="text-align:center">虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收</td></tr><tr><td style="text-align:center">UseParNewGC</td><td style="text-align:center">打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收</td></tr><tr><td style="text-align:center">UseConcMarkSweepGC</td><td style="text-align:center">打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后壁收集器使用</td></tr><tr><td style="text-align:center">UseParallelGC</td><td style="text-align:center">虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old（PS MarkSweep）的收集器组合进行内存回收</td></tr><tr><td style="text-align:center">UseParallelOldGC</td><td style="text-align:center">打开此开关后，使用Parallel Scavenge+Parallel Old的收集器组合进行内存回收</td></tr><tr><td style="text-align:center">SurvivorRatio</td><td style="text-align:center">新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survivor=8:1</td></tr><tr><td style="text-align:center">PretenureSizeThreshold</td><td style="text-align:center">直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td></tr><tr><td style="text-align:center">MaxTenuringThreshold</td><td style="text-align:center">晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄加1，当超过这个参数值时就进入老年代</td></tr><tr><td style="text-align:center">UseAdaptiveSizePolicy</td><td style="text-align:center">动态调整Java堆中各个区域的大小以及进入老年代的年龄</td></tr><tr><td style="text-align:center">HandlePromotionFailure</td><td style="text-align:center">是否允许分配担保失败，即老年代的剩余空间不足以应对新生代的整个Eden和Survivor区的所有对象都存活的极端情况</td></tr><tr><td style="text-align:center">ParallelGCThreads</td><td style="text-align:center">设置并行GC时进行内存回收的线程数</td></tr><tr><td style="text-align:center">GCTimeRatio</td><td style="text-align:center">GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td style="text-align:center">MaxGCPauseMillis</td><td style="text-align:center">设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td style="text-align:center">CMSinitiatingOccupancyFraction</td><td style="text-align:center">设置CMS收集器在老年代空间被使用多少后出发垃圾收集。默认值为68%，仅在使用CMS收集器时生效</td></tr><tr><td style="text-align:center">UseCMSCompactAtFullCollection</td><td style="text-align:center">设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效</td></tr><tr><td style="text-align:center">CMSFullGCsBeforeCompaction</td><td style="text-align:center">设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效</td></tr></tbody></table><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><h3 id="Minor-GC和Full-GC"><a href="#Minor-GC和Full-GC" class="headerlink" title="Minor GC和Full GC"></a>Minor GC和Full GC</h3><ul><li>Minor GC：发生在新生代的GC。C触发条件：当Eden区满时。</li><li>Full GC（也叫Major GC）：发生在老年代的GC，通常会触发MinorGC。Major GC的速度一般会比Minor GC慢10倍以上。触发条件：<ul><li>调用System.gc时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、From Space区向To Space区复制时，对象大小大于To Space可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul></li></ul><h3 id="对象优先在Eden分配"><a href="#对象优先在Eden分配" class="headerlink" title="对象优先在Eden分配"></a>对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><p>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Sur-vivor区之间发生大量的内存复制。注意PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效。</p><h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。</p><h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p><h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进程一次Minor GC（尽管此次GC是有风险的），如果小于或者不允许冒险，需要进行一次Full GC。</p><p>在JDK 6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>深入理解JVM第二版（周志明）</li><li><a href="http://howiefh.github.io/2015/04/08/jvm-note-2/" target="_blank" rel="noopener">http://howiefh.github.io/2015/04/08/jvm-note-2/</a></li><li><a href="https://blog.csdn.net/yhyr_ycy/article/details/52566105" target="_blank" rel="noopener">https://blog.csdn.net/yhyr_ycy/article/details/52566105</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:13 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;程序计数器
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>直接引用和符号引用</title>
    <link href="https://isjinhao.github.io/2019/%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8/"/>
    <id>https://isjinhao.github.io/2019/直接引用和符号引用/</id>
    <published>2019-03-31T07:30:20.000Z</published>
    <updated>2019-03-31T12:10:36.470Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><p>在JVM中，类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。而解析阶段即是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><h2 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h2><p>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个<code>Java</code>类将会编译成一个<code>class</code>文件。在编译时，<code>Java</code>类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如<code>org.simple.People</code>类引用了<code>org.simple.Language</code>类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号<code>org.simple.Language</code>（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示<code>Language</code>类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p><h2 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h2><p>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://blog.csdn.net/u014656992/article/details/51107127" target="_blank" rel="noopener">https://blog.csdn.net/u014656992/article/details/51107127</a></p></li><li><p>深入理解Java虚拟机第七章</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在JVM中，类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。而解析阶段
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>常量池和String</title>
    <link href="https://isjinhao.github.io/2019/%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8CString/"/>
    <id>https://isjinhao.github.io/2019/常量池和String/</id>
    <published>2019-03-31T02:19:14.000Z</published>
    <updated>2019-04-01T05:58:12.460Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>常量池及String在JDK6、JDK7、JDK8中的实现以及在不同虚拟机中的实现有很大区别，限于笔者水平无法兼顾到太多版本之间的差异，所以下文章中的解释和测试都<strong>仅仅针对于HotSpot虚拟机的JDK8</strong>。</p><h2 id="常量池和运行时常量池"><a href="#常量池和运行时常量池" class="headerlink" title="常量池和运行时常量池"></a>常量池和运行时常量池</h2><p>在刚开始学习Java内存模型的时候笔者掉进入过一个大坑，即认为常量池是运行时常量池的简称。但是实际上这两者是不一样池子，运行时常量池的英文：<code>Runtime Constant Pool</code>，常量池的英文：<code>Constant Pool Table</code>，运行时常量池是方法区的一部分。常量池是Class文件中的一部分，用于存放编译期生成的各种字面量和符号引用。符号引用和直接引用请参考：<a href="https://isjinhao.github.io/2019/%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8/#more">https://isjinhao.github.io/2019/%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8/#more</a></p><h3 id="常量池的内容"><a href="#常量池的内容" class="headerlink" title="常量池的内容"></a>常量池的内容</h3><div align="center"><img src="/2019/常量池和String/常量池里的内容.png" style="width:100%"></div><h3 id="常量池到运行时常量池"><a href="#常量池到运行时常量池" class="headerlink" title="常量池到运行时常量池"></a>常量池到运行时常量池</h3><p>静态常量池存储的是当class文件被java虚拟机加载进来后存放在方法区的一些字面量和符号引用，字面量包括字符串，基本类型的常量，符号引用其实引用的就是常量池里面的字符串，但符号引用不是直接存储字符串，而是存储字符串在常量池里的索引。</p><p>动态常量池是当class文件被加载完成后，java虚拟机会将静态常量池里的内容转移到动态常量池里，在静态常量池的符号引用有一部分是会被转变为直接引用的，比如说类的静态方法或私有方法，实例构造方法，父类方法，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的一些方法是在这个方法被第一次调用的时候才会将符号引用转变为直接引用的。</p><div align="center"><img src="/2019/常量池和String/常量池和运行时常量池.jpg" style="width:80%"></div><h2 id="8种基本类型的包装类和常量池"><a href="#8种基本类型的包装类和常量池" class="headerlink" title="8种基本类型的包装类和常量池"></a>8种基本类型的包装类和常量池</h2><p>Java中基本类型的包装类的大部分都实现了常量池技术，即Byte、Short、Integer、Long、Character、Boolean。他么默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer 缓存代码 ：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">     <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">         <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出TRUE</span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">400</span>;</span><br><span class="line">Integer i2 = <span class="number">400</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出false</span></span><br></pre></td></tr></table></figure><h3 id="Integer比较更丰富的一个例子"><a href="#Integer比较更丰富的一个例子" class="headerlink" title="Integer比较更丰富的一个例子"></a>Integer比较更丰富的一个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"i1=i2   "</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">"i1=i2+i3   "</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">"i1=i4   "</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">"i4=i5   "</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">"i4=i5+i6   "</span> + (i4 == i5 + i6));   </span><br><span class="line">System.out.println(<span class="string">"40=i5+i6   "</span> + (<span class="number">40</span> == i5 + i6));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    i1=i2   true</span></span><br><span class="line"><span class="comment">    i1=i2+i3   true</span></span><br><span class="line"><span class="comment">    i1=i4   false</span></span><br><span class="line"><span class="comment">    i4=i5   false</span></span><br><span class="line"><span class="comment">    i4=i5+i6   true</span></span><br><span class="line"><span class="comment">    40=i5+i6   true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>语句<code>i4 == i5 + i6</code>，因为<code>+</code>这个操作符不适用于<code>Integer</code>对象，首先<code>i5</code>和<code>i6</code>进行自动拆箱操作，进行数值相加，即<code>i4 == 40</code>。然后<code>Integer</code>对象无法与数值进行直接比较，所以<code>i4</code>自动拆箱转为<code>int</code>值<code>40</code>，最终这条语句转为<code>40 == 40</code>进行数值比较。</p><h2 id="String类和常量池"><a href="#String类和常量池" class="headerlink" title="String类和常量池"></a>String类和常量池</h2><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>英文名字：<code>String Pool</code>，字符串常量池的本质是一个<code>StringTable</code>类（它是一个<code>HashSet</code>）。这个<code>StringTable</code>在每个HotSpot VM的实例只有一份，被所有的类共享。但它只存储运行时常量池里<code>String</code>对象的引用，而不存储<code>String</code>对象的内容，根据这个引用可以得到具体的<code>String</code>对象。注意，字符串常量池是字符串类维护的。字符串常量池只是为了加快<code>String</code>类型常量的检索。</p><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p>String.intern() 是一个 Native 方法，JDK对它的解释是（水平有限，不再翻译）：</p><blockquote><p>A pool of strings, initially empty, is maintained privately by the class String. When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.<br>It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.<br>All literal strings and string-valued constant expressions are interned.</p></blockquote><p>大致意思是：如果字符串常量池中已经有了这个字符串，那么直接返回字符串常量池中的它的引用，如果没有，那就将它的引用保存一份到字符串常量池，然后直接返回这个引用。判断字符串是否相等使用<code>equals</code>方法。</p><h3 id="字面量进入字符串常量池的时机"><a href="#字面量进入字符串常量池的时机" class="headerlink" title="字面量进入字符串常量池的时机"></a>字面量进入字符串常量池的时机</h3><p>就HotSpot VM的实现来说，在加载类的时候，字符串字面量会进入当前类的运行时常量池，不会进入<code>String Pool</code>。加载类的时候，没有解析字符串字面量，等到执行ldc指令的时候就会触发这个解析的动作。解析指符号引用替换为直接引用的过程，参见：<a href="https://isjinhao.github.io/2019/%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8/#more">https://isjinhao.github.io/2019/%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8/#more</a></p><p>ldc指令的语义是：到当前类的运行时常量池（<code>Runtime Constant Pool</code>）去查找该index对应的项，如果该项尚未resolve则resolve之，并返回resolve后的内容。 在遇到String类型常量时，resolve的过程如果发现<code>StringTable</code>已经有了内容匹配的<code>java.lang.String</code>的引用，则直接返回这个引用，反之，如果<code>StringTable</code>里尚未有内容匹配的<code>String</code>实例的引用，则会在<code>Java</code>堆里创建一个对应内容的<code>String</code>对象，然后在StringTable记录下这个引用，并返回这个引用出去。</p><p>可见，ldc指令是否需要创建新的<code>String</code>实例，全看在第一次执行这一条ldc指令时，StringTable是否已经记录了一个对应内容的<code>String</code>的引用。</p><h3 id="字符串常量池中有哪些字符串的引用"><a href="#字符串常量池中有哪些字符串的引用" class="headerlink" title="字符串常量池中有哪些字符串的引用"></a>字符串常量池中有哪些字符串的引用</h3><ul><li>由字面量创建的String在字符串常量池中都有一份引用</li><li>被<code>new</code>出来的对象调用intern()方法后再字符串常量池中才有一份引用</li></ul><h3 id="获得String对象"><a href="#获得String对象" class="headerlink" title="获得String对象"></a>获得String对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abcd"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li><p>直接使用双引号声明出来的 String 对象会直接存储在常量池中。使用双引号声明时会调用ldc命令，所以其检查的是字符串常量池。</p></li><li><p>对于<code>new String()</code>则会在堆中创建一个String对象，并返回该对象的引用。</p><blockquote><p>Initializes a newly created String object so that it represents the same sequence of characters as the argument; in other words, the newly created string is a copy of the argument string. Unless an explicit copy of original is needed, use of this constructor is unnecessary since Strings are immutable.</p></blockquote></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><ul><li><p>Q：<code>String s = new String(&quot;123&quot;);</code>定义了几个对象。</p></li><li><p>A：若常量池中已经存在”123”，则直接引用，也就是此时只会创建一个对象，如果常量池中不存”123”，则先创建后将在堆中创建”123”的一份拷贝，并把这个拷贝的引用返回。此时字符串常量池中有”123“的引用。</p></li></ul><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Hollis"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"Hollis"</span>);</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"Hollis"</span>).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><div align="center"><img src="/2019/常量池和String/例2.jpg" style="width:80%"></div><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">String s2 = <span class="string">"1"</span>;</span><br><span class="line">s.intern();</span><br><span class="line">System.out.println(s == s2);<span class="comment">//false</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"2"</span>);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = <span class="string">"12"</span>;</span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：常量池中有&quot;1&quot;，堆中有字符串&quot;1&quot;，字符串常量池中是常量池中&quot;1&quot;的引用，s是堆中的引用</span><br><span class="line">2：在字符串常量池中检索，有&quot;1&quot;，则得到常量池中&quot;1&quot;的引用</span><br><span class="line">5：常量池中有&quot;1&quot;，&quot;2&quot;。new String(&quot;1&quot;) + new String(&quot;2&quot;);的底层是使用StringBuffer的append方法将&quot;2&quot;和&quot;2&quot;拼接在一块，然后调用toString方法new出“22”；所以此时的“22”字符串是创建在堆区的；</span><br><span class="line">6：在字符串常量池中检索，没有&quot;22&quot;，把堆中该对象的引用放在字符串常量池中</span><br><span class="line">7：检查字符串常量池，有&quot;2&quot;的引用，指向堆</span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;  </span><br><span class="line">String s2=s1.intern();  </span><br><span class="line">System.out.println(s1==s1.intern());    <span class="comment">//true </span></span><br><span class="line">System.out.println(s2==s1.intern());</span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：堆中有&quot;xyz&quot;，常量池中有&quot;xy&quot;，&quot;z&quot;</span><br><span class="line">2：把堆中的&quot;xyz&quot;的引用存在字符串常量池中。</span><br><span class="line">3：都指向堆中</span><br><span class="line">4：都指向堆中</span><br></pre></td></tr></table></figure><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">"xyz"</span>) ;  </span><br><span class="line">String s2=s1.intern();  </span><br><span class="line">System.out.println(s1==s1.intern());  <span class="comment">//false</span></span><br><span class="line">System.out.println(s2==s1.intern());  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：常量池中有&quot;xyz&quot;，堆中有&quot;xyz&quot;</span><br><span class="line">2：s2指向常量池中的&quot;xyz&quot;</span><br><span class="line">3：s1.intern()指向常量池，s1指向堆</span><br><span class="line">4：s2指向堆</span><br></pre></td></tr></table></figure><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"xy"</span> + <span class="string">"z"</span>;</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println( s1==s1.intern() );  <span class="comment">//true</span></span><br><span class="line">System.out.println( s2==s1.intern() );  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：编译期可以确定s1是&quot;xyz&quot;，所以编译器会优化。在常量池中有&quot;xyz&quot;</span><br><span class="line">2：s2指向常量池中的&quot;xyz&quot;</span><br><span class="line">3：都指向常量池中的&quot;xyz&quot;</span><br><span class="line">4：都指向常量池中的&quot;xyz&quot;</span><br></pre></td></tr></table></figure><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;  </span><br><span class="line">String s3 = <span class="string">"xyz"</span>;</span><br><span class="line">String s2=s1.intern();  </span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">System.out.println(s2 == s3);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1==s1.intern());<span class="comment">//false</span></span><br><span class="line">System.out.println(s2==s1.intern()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1：堆中有&quot;xyz&quot;，常量池中有&quot;xy&quot;和&quot;z&quot;，s1指向堆中的&quot;xyz&quot;</span><br><span class="line">2：检索字符串常量池，没有&quot;xyz&quot;，在常量池中创建&quot;xyz&quot;，s3指向常量池中的&quot;xyz&quot;</span><br><span class="line">3：字符串常量池有&quot;xyz&quot;的引用，且指向常量池，s2指向常量池中&quot;xyz&quot;</span><br><span class="line">4：s1指向堆中的&quot;xyz&quot;，s2指向常量池中&quot;xyz&quot;</span><br><span class="line">5：s1指向堆中的&quot;xyz&quot;，s3指向常量池中的&quot;xyz&quot;</span><br><span class="line">6：都指向常量池中&quot;xyz&quot;</span><br><span class="line">7：s1指向堆中的&quot;xyz&quot;，s1==s1.intern指向常量池中的&quot;xyz&quot;</span><br><span class="line">8：s2指向常量池中&quot;xyz&quot;，s1==s1.intern指向常量池中的&quot;xyz&quot;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/wangbiao007/article/details/78545189" target="_blank" rel="noopener">https://blog.csdn.net/wangbiao007/article/details/78545189</a></li><li><a href="https://blog.csdn.net/Mypromise_TFS/article/details/81504137" target="_blank" rel="noopener">https://blog.csdn.net/Mypromise_TFS/article/details/81504137</a></li><li><a href="https://www.zhihu.com/question/55994121" target="_blank" rel="noopener">https://www.zhihu.com/question/55994121</a></li><li>深入理解JVM第二版</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h2&gt;&lt;p&gt;常量池及S
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="https://isjinhao.github.io/2019/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://isjinhao.github.io/2019/Java内存模型/</id>
    <published>2019-03-30T07:48:32.000Z</published>
    <updated>2019-03-31T12:10:36.472Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM则是JRE中的核心组成部分，承担分析和执行Java字节码的工作。在Java历史上有很多发行的Java虚拟机，但目前一般都是<code>HotSpot</code>。查看本机JVM：<code>java -version</code></p><div align="center"><img src="/2019/Java内存模型/查看JVM.jpg" style="width:80%"></div><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>Java虚拟机在执行Java程序的时候会把它所管理的内存区域划分为若干个不同的数据区域。根据JVM规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。</p><h2 id="运行时数据区划分"><a href="#运行时数据区划分" class="headerlink" title="运行时数据区划分"></a>运行时数据区划分</h2><h3 id="JDK6"><a href="#JDK6" class="headerlink" title="JDK6"></a>JDK6</h3><div align="center"><img src="/2019/Java内存模型/1.6内存模型.jpg" style="width:60%"></div><h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><div align="center"><img src="/2019/Java内存模型/1.8内存模型.jpg" style="width:60%"></div><h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p><strong>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p><strong>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息）</p><p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向一条字节码指令的地址）。</p><p><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong></p><ul><li><p><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</p></li><li><p><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</p></li></ul><p>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><p><strong>扩展：那么方法/函数如何调用？</strong></p><p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>Java方法有两种返回方式：</p><ul><li><p>return 语句。</p></li><li><p>抛出异常。</p></li></ul><p>不管哪种返回方式都会导致栈帧被弹出。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p><h3 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h3><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代。再细致一点有：<code>Eden空间</code>、<code>From Survivor</code>、<code>To Survivor</code>空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TwVibBF785ic5RU2iafKlnVEsC7XwTj6XECpS7ibPzdgmc3pqrvwf99HymgMU9xJnAMfsicDsuY1XxVlug/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>上图所示的eden区、s0区、s1区都属于新生代，tentired区属于老年代。大部分情况，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0或者s1，并且对象的年龄还会加 1（<code>Eden区-&gt;Survivor</code> 区后对象的初始年龄变为1），当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p><strong>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</strong></p><p>HotSpot 虚拟机中方法区也常被称为 <strong>“永久代”</strong>，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p><p><strong>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</strong></p><p>JDK 1.8 的时候，方法区被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p>我们可以使用参数： <code>-XX:MetaspaceSize</code> 来指定元数据区的大小。与永久区很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p><ul><li>字面量就是指这个量本身，比如字面量3。也就是指3. 再比如 string类型的字面量”ABC”, 这个”ABC” 通过字来描述。 可以理解成一眼就能知道的量。</li></ul><p>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><p><strong>JDK1.8及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。</strong></p><p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p><h4 id="为什么永久代向元空间的转换"><a href="#为什么永久代向元空间的转换" class="headerlink" title="为什么永久代向元空间的转换"></a>为什么永久代向元空间的转换</h4><ul><li><p>字符串存在永久代中，容易出现性能问题和内存溢出。</p></li><li><p>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p></li><li><p>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p></li></ul><h2 id="类的各个部分分别在哪个位置"><a href="#类的各个部分分别在哪个位置" class="headerlink" title="类的各个部分分别在哪个位置"></a>类的各个部分分别在哪个位置</h2><ul><li>字节码：方法区</li><li>字节码对象：堆</li><li>普通对象：大部分存在于堆。更多参考：<a href="https://blog.csdn.net/rickiyeat/article/details/76802085" target="_blank" rel="noopener">https://blog.csdn.net/rickiyeat/article/details/76802085</a></li><li>对象的属性：大部分存在于堆</li><li>static属性：常量池</li><li>方法：方法区</li><li>方法中的局部变量：Java虚拟机栈</li><li>String对象：堆或常量池</li><li>final属性：常量池</li></ul><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><div align="center"><img src="/2019/Java内存模型/对象的创建.jpg" style="width:80%"></div><ul><li><p><strong>类加载检查：</strong> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p></li><li><p><strong>分配内存：</strong> 在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p></li></ul><h3 id="内存分配的两种方式"><a href="#内存分配的两种方式" class="headerlink" title="内存分配的两种方式"></a><strong>内存分配的两种方式</strong></h3><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。详细可参考：深入理解Java虚拟机第二版第三章。</p><ul><li>指针碰撞：假设JAVA堆中的内存时绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式成为“指针碰撞”。</li><li>空闲链表：如果JAVA堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式成为“空闲列表”。</li><li><strong>初始化零值：</strong> 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>设置对象头：</strong> 初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li><li><strong>执行 init 方法：</strong> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li></ul><h3 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a><strong>内存分配并发问题</strong></h3><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，否则比如当虚拟机正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存就会引发严重的问题。通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在Eden区分配一块儿内存，称为本地线程分配缓存（Thread Local Allocation Buffer，TLAB），JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。</li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为3块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的自身运行时数据</strong>（哈希码、GC分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种：</p><ul><li><strong>句柄：</strong> 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li></ul><div align="center"><img src="/2019/Java内存模型/句柄.jpg" style="width:80%"></div><ul><li><strong>直接指针</strong>：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</li></ul><div align="center"><img src="/2019/Java内存模型/指针.jpg" style="width:80%"></div><p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485068&amp;idx=1&amp;sn=c37267fe59978dbfcd6a9a54eee1c502&amp;chksm=cea24947f9d5c051008233a6a938e802b710ccf919f4215f84dcc0bf1fdad7d0101d37497d33&amp;xtrack=1&amp;scene=0&amp;subscene=131&amp;clicktime=1553930626&amp;ascene=7&amp;devicetype=android-27&amp;version=2700033c&amp;nettype=cmnet&amp;abtest_cookie=BQABAAgACgALABIAEwAGAJ%2BGHgAjlx4AVpkeAM%2BZHgDamR4A3JkeAAAA&amp;lang=zh_CN&amp;pass_ticket=G969oFWgvfNjcImZ43XVMVLnTmWNWI4qDunqFFIS7NA%3D&amp;wx_header=1" target="_blank" rel="noopener">JavaGuide</a></p></li><li><p>深入理解Java虚拟机</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h2&gt;&lt;p&gt;J
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>基于winpcap的cpp控制台网络协议分析</title>
    <link href="https://isjinhao.github.io/2019/%E5%9F%BA%E4%BA%8Ewinpcap%E7%9A%84cpp%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    <id>https://isjinhao.github.io/2019/基于winpcap的cpp控制台网络协议分析/</id>
    <published>2019-03-28T06:59:27.000Z</published>
    <updated>2019-03-30T01:31:08.780Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:13 GMT+0800 (GMT+08:00) --><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h3><ul><li>winpcap4.1.3</li><li>vs2015</li></ul><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><ul><li><code>新建项目-&gt;Visual C++项目-&gt;Win32控制台项目</code>，在<code>Win32应用程序向导</code>窗口中的<code>应用程序设置-&gt;附加选项</code>选中<code>空项目</code>。</li><li>将<code>WinPcap</code>开发包中的Include和Lib两个文件夹复制到新建项目所在文件夹下。</li><li>点击项目，右击，然后点击属性<ul><li><code>C/C++-&gt;常规-&gt;附加包含目录</code>：如 ..\include</li><li><code>链接器-&gt;常规-&gt;附加库目录</code>：如 ..\lib</li><li><code>链接器-&gt;输入-&gt;附加依赖项</code>：wpcap.lib（winpcap的包），ws2_32.lib（windows的socket）</li></ul></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pcap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">eth_address</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_char byte1;</span><br><span class="line">u_char byte2;</span><br><span class="line">u_char byte3;</span><br><span class="line">u_char byte4;</span><br><span class="line">u_char byte5;</span><br><span class="line">u_char byte6;</span><br><span class="line">&#125;eth_address;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4 bytes IP address */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_address</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_char byte1;</span><br><span class="line">u_char byte2;</span><br><span class="line">u_char byte3;</span><br><span class="line">u_char byte4;</span><br><span class="line">&#125;ip_address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IPv4 header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_charver_ihl;<span class="comment">// Version (4 bits) + Internet header length (4 bits)</span></span><br><span class="line">u_chartos;<span class="comment">// Type of service </span></span><br><span class="line">u_short tlen;<span class="comment">// Total length </span></span><br><span class="line">u_short identification; <span class="comment">// Identification</span></span><br><span class="line">u_short flags_fo;<span class="comment">// Flags (3 bits) + Fragment offset (13 bits)</span></span><br><span class="line">u_charttl;<span class="comment">// Time to live</span></span><br><span class="line">u_charproto;<span class="comment">// Protocol</span></span><br><span class="line">u_short crc;<span class="comment">// Header checksum</span></span><br><span class="line">ip_addresssaddr;<span class="comment">// Source address</span></span><br><span class="line">ip_addressdaddr;<span class="comment">// Destination address</span></span><br><span class="line">u_intop_pad;<span class="comment">// Option + Padding</span></span><br><span class="line">&#125;ip_header;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UDP header*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">udp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_short sport;<span class="comment">// Source port</span></span><br><span class="line">u_short dport;<span class="comment">// Destination port</span></span><br><span class="line">u_short len;<span class="comment">// Datagram length</span></span><br><span class="line">u_short crc;<span class="comment">// Checksum</span></span><br><span class="line">&#125;udp_header;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MAC header*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">eth_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">eth_address daddr;</span><br><span class="line">eth_address saddr;</span><br><span class="line">u_short type;</span><br><span class="line">&#125;eth_header;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_short hardtype;<span class="comment">//硬件类型字段</span></span><br><span class="line">u_short prototype;<span class="comment">//协议类型字段</span></span><br><span class="line">u_char htlen;<span class="comment">//硬件地址的长度,以字节为单位.对于以太网上IP地址的ARP请求或应答来说,它们的值为6</span></span><br><span class="line">u_char ptlen;<span class="comment">//协议地址的长度,以字节为单位.对于以太网上IP地址的ARP请求或应答来说,它们的值为4</span></span><br><span class="line">u_short op;<span class="comment">//操作字段</span></span><br><span class="line">eth_address arp_esa;<span class="comment">//发送端MAC地址</span></span><br><span class="line">ip_address arp_isa;<span class="comment">//发送端IP地址</span></span><br><span class="line">eth_address arp_eda;<span class="comment">//目的端MAC地址</span></span><br><span class="line">ip_address arp_ida;<span class="comment">//目的端IP地址</span></span><br><span class="line">&#125;arp_header;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">icmp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_char type;<span class="comment">//ICMP报文类型</span></span><br><span class="line">u_char code;<span class="comment">//代码</span></span><br><span class="line">u_short checksum;<span class="comment">//校验和</span></span><br><span class="line">u_short identifier;<span class="comment">//标识符</span></span><br><span class="line">u_short sequence_number;<span class="comment">//序列号</span></span><br><span class="line">&#125;icmp_header;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TCP header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_shortsport;<span class="comment">//源端口</span></span><br><span class="line">u_short dport;<span class="comment">//目的端口</span></span><br><span class="line">u_long  sequence_number;<span class="comment">//序号（4字节ntohl）  </span></span><br><span class="line">u_long  acknowlegement_number;<span class="comment">//确认号</span></span><br><span class="line">u_short hlen_bl_flags;<span class="comment">//数据偏移+保留+控制位</span></span><br><span class="line">u_short window_size;<span class="comment">//窗口（发送方自己的接收窗口）</span></span><br><span class="line">u_short checksum;<span class="comment">//检验和（首部+数据）</span></span><br><span class="line">u_short urg;<span class="comment">//紧急指针</span></span><br><span class="line">u_long  option;<span class="comment">//可选+填充</span></span><br><span class="line">&#125;tcp_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dns_packet</span> //报文<span class="title">head</span>+<span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u_short id;<span class="comment">//每一个占2个字节，共12个字节</span></span><br><span class="line">    u_short flags;<span class="comment">//标志第一个为0代表查询报文</span></span><br><span class="line">    u_short ques;</span><br><span class="line">    u_short answer;</span><br><span class="line">    u_short author;</span><br><span class="line">    u_short addition;</span><br><span class="line">    u_char dns_data;<span class="comment">//查询问题部分</span></span><br><span class="line">&#125;dns_packet;</span><br></pre></td></tr></table></figure><h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pcap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers.c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DNSPORT 53</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出基本信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintBaseInfo</span><span class="params">(<span class="keyword">const</span> struct pcap_pkthdr *header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">ltime</span>;</span></span><br><span class="line"><span class="keyword">char</span> timestr[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">time_t</span> local_tv_sec;</span><br><span class="line"></span><br><span class="line">local_tv_sec = header-&gt;ts.tv_sec;</span><br><span class="line">ltime=localtime(&amp;local_tv_sec);</span><br><span class="line">strftime(timestr, <span class="keyword">sizeof</span> timestr, <span class="string">"%H:%M:%S"</span>, ltime);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n\n\n监听到Mac帧的时间：%s   MAC帧长度:%d Byte(s)\n"</span>, timestr, header-&gt;len * <span class="number">4</span>);  <span class="comment">/* 以四字节为单位 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出硬件地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintEthAddress</span><span class="params">(eth_address eth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02X:%02X:%02X:%02X:%02X:%02X"</span>, </span><br><span class="line">eth.byte1,</span><br><span class="line">eth.byte2,</span><br><span class="line">eth.byte3,</span><br><span class="line">eth.byte4,</span><br><span class="line">eth.byte5,</span><br><span class="line">eth.byte6</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出IP地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintIPAddress</span><span class="params">(ip_address ia)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d.%d.%d.%d"</span>, </span><br><span class="line">ia.byte1,</span><br><span class="line">ia.byte2,</span><br><span class="line">ia.byte3,</span><br><span class="line">ia.byte4</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出网络层协议类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintNetType</span><span class="params">(u_short type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"网络层协议： "</span>);</span><br><span class="line"><span class="keyword">if</span>(type==<span class="number">0x0800</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"IP协议"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">0x0806</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ARP协议"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">0x8035</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"RARP协议"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"接收到非本程序能处理的网络层协议类型！"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析Mac帧：</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">网络层协议类型：源MAC -&gt; 目的MAC</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">网络层协议类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u_short <span class="title">handleMac</span><span class="params">(eth_header *eth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short type=ntohs(eth-&gt;type);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Mac地址： "</span>);</span><br><span class="line">myPrintEthAddress(eth-&gt;saddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-&gt;"</span>);</span><br><span class="line">myPrintEthAddress(eth-&gt;daddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleARPAndRARP</span><span class="params">(arp_header *ah)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short arp_ht;<span class="comment">//硬件地址的类型.它的值为1即表示以太网地址</span></span><br><span class="line">u_short arp_pt;<span class="comment">//要映射的协议地址类型.它的值为0x0800，即表示IP地址</span></span><br><span class="line">u_short arp_op;<span class="comment">//四种操作类型,它们是ARP请求(值为1)、ARP应答(值为2)、RARP请求(值为3)和RARP应答(值为4)</span></span><br><span class="line">arp_ht=ntohs(ah-&gt;hardtype);<span class="comment">//硬件地址的类型.它的值为1即表示以太网地址</span></span><br><span class="line">arp_pt=ntohs(ah-&gt;prototype);<span class="comment">//要映射的协议地址类型.它的值为0x0800，即表示IP地址</span></span><br><span class="line">arp_op=ntohs(ah-&gt;op);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"硬件地址类型为：%d\t\t\t"</span>,arp_ht);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"协议地址类型为：0x%04X\n"</span>,arp_pt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"硬件地址长度为：%d\t\t\t"</span>,ah-&gt;htlen);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"协议地址长度为：%d\n"</span>,ah-&gt;ptlen);</span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：ARP请求报文。\n本机Mac地址："</span>);</span><br><span class="line">myPrintEthAddress(ah-&gt;arp_esa);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t正在请求"</span>);</span><br><span class="line">myPrintIPAddress(ah-&gt;arp_ida);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"的Mac地址\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：ARP应答报文。\n应答方的Mac地址："</span>);</span><br><span class="line">myPrintEthAddress(ah-&gt;arp_eda);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t应答方的IP地址"</span>);</span><br><span class="line">myPrintIPAddress(ah-&gt;arp_ida);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">3</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：RARP请求报文\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">4</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：RARP应答报文\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> all_ip_len = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">u_short <span class="title">handleIP</span><span class="params">(ip_header *ih)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_int ip_ver;<span class="comment">//版本</span></span><br><span class="line">u_int ip_len;<span class="comment">//首部长度</span></span><br><span class="line">u_short ip_tlen;    <span class="comment">//总长度</span></span><br><span class="line">u_short ip_ident;<span class="comment">//标识</span></span><br><span class="line">u_short ip_flag_fo; <span class="comment">//标志和片偏移</span></span><br><span class="line">u_int ip_flag;<span class="comment">//标志（3位，值为2还有分片且允许分片,1不能分片,0没有分片且允许分片）</span></span><br><span class="line">u_int ip_fo;<span class="comment">//片偏移</span></span><br><span class="line">u_short ip_type;<span class="comment">//协议</span></span><br><span class="line">u_short ip_crc;<span class="comment">//首部检验和</span></span><br><span class="line">u_long ip_op_pad;<span class="comment">//可选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* retireve the position of the ip header */</span><span class="comment">//检索IP首部的位置</span></span><br><span class="line">ip_ver = (ih-&gt;ver_ihl &gt;&gt; <span class="number">4</span>);<span class="comment">//版本</span></span><br><span class="line">ip_len = (ih-&gt;ver_ihl &amp; <span class="number">0xf</span>) * <span class="number">4</span>;<span class="comment">//首部长度，与运算，可以只取ip头部的版本长度字段的后4位</span></span><br><span class="line">ip_tlen=ntohs(ih-&gt;tlen);<span class="comment">//总长度</span></span><br><span class="line">ip_ident=ntohs(ih-&gt;identification);<span class="comment">//标识</span></span><br><span class="line">ip_flag_fo = ntohs(ih-&gt;flags_fo);<span class="comment">//2字节存放，会有字节序问题</span></span><br><span class="line">ip_flag = (ip_flag_fo &gt;&gt; <span class="number">13</span>);<span class="comment">//标志</span></span><br><span class="line">ip_fo = (ip_flag_fo &amp; <span class="number">0x1fff</span>);<span class="comment">//片偏移</span></span><br><span class="line">ip_type = ih-&gt;proto;<span class="comment">//上层协议类型</span></span><br><span class="line">ip_crc = ntohs(ih-&gt;crc);<span class="comment">//首部校验和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印IP数据报首部*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"版本：%d\t\t\t"</span>,ip_ver);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部长度：%d\n"</span>,ip_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"区分服务：%d\t\t"</span>, ih-&gt;tos);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"总长度：%d\n"</span>, ip_tlen);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标识：%d\t\t"</span>, ip_ident);</span><br><span class="line"><span class="keyword">if</span> (ip_flag == <span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：DF=1（不能分片），MF=0（没有后续分片）\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (ip_flag == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：DF=0（允许分片），MF=1（还有后续分片）\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (ip_flag == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：DF=0（允许分片），MF=0（没有后续分片）\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"片偏移：%d\t\t"</span>,ip_fo*<span class="number">8</span>);<span class="comment">//片偏移以8字节为单位</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"生存时间：%d\n"</span>,ih-&gt;ttl);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"协议：%d\t\t\t"</span>,ih-&gt;proto);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部校验和：%d\n"</span>,ip_crc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"IP地址：  "</span>);</span><br><span class="line"></span><br><span class="line">myPrintIPAddress(ih-&gt;saddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" -&gt; "</span>);</span><br><span class="line">myPrintIPAddress(ih-&gt;daddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (ip_len == <span class="number">20</span>)<span class="comment">//IP首部长度&gt;20时才有</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部长度为20，IP报文首部没有可选字段。\n"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ip_op_pad = ntohl(ih-&gt;op_pad);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"可选自段内容为：%u\n"</span>, ip_op_pad);</span><br><span class="line">&#125;</span><br><span class="line">all_ip_len = ip_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ip_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleICMP</span><span class="params">(icmp_header *ich)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short icmp_checksum;<span class="comment">//校验和</span></span><br><span class="line">u_short icmp_ident;<span class="comment">//标识符</span></span><br><span class="line">u_short icmp_seqnum;<span class="comment">//序列号</span></span><br><span class="line"></span><br><span class="line">icmp_checksum = ntohs(ich-&gt;checksum);<span class="comment">//校验和</span></span><br><span class="line">icmp_ident = ntohs(ich-&gt;identifier);<span class="comment">//标识符</span></span><br><span class="line">icmp_seqnum = ntohs(ich-&gt;sequence_number);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n运输层协议：  ICMP协议\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印ICMP报文首部*/</span></span><br><span class="line"><span class="keyword">if</span> (ich-&gt;type == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ICMP类型：回显应答\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ich-&gt;type == <span class="number">8</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ICMP类型：回显请求\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ICMP类型：其他\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"代码：%d\t\t"</span>,ich-&gt;code);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"校验和：%d\n"</span>,icmp_checksum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标识符：%d\t\t"</span>,icmp_ident);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"序列号：%d\n"</span>,icmp_seqnum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u_int udp_len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handleUDP</span><span class="params">(udp_header *uh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short sport, dport;<span class="comment">//端口</span></span><br><span class="line">u_short uh_len; <span class="comment">//长度</span></span><br><span class="line">u_short uh_crc; <span class="comment">//校验和</span></span><br><span class="line"></span><br><span class="line">sport = ntohs( uh-&gt;sport );<span class="comment">//源端口</span></span><br><span class="line">dport = ntohs( uh-&gt;dport );<span class="comment">//目的端口</span></span><br><span class="line">uh_len = ntohs(uh-&gt;len);<span class="comment">//长度</span></span><br><span class="line">uh_crc = ntohs(uh-&gt;crc);<span class="comment">//校验和</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n运输层协议：  UDP协议\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"端口号：%d -&gt; %d\n"</span>, sport, dport);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"长度：%d\t\t"</span>, uh_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"校验和：%d\n"</span>, uh_crc);</span><br><span class="line"></span><br><span class="line">udp_len = uh_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sport == DNSPORT || dport == DNSPORT)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleTCP</span><span class="params">(tcp_header *th)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_shorttcp_sport;<span class="comment">//源端口</span></span><br><span class="line">u_short tcp_dport;<span class="comment">//目的端口</span></span><br><span class="line">u_long  tcp_seqnum;<span class="comment">//序号（4字节ntohl）  </span></span><br><span class="line">u_long  tcp_acknum;<span class="comment">//确认号</span></span><br><span class="line">u_short tcp_hlen_bl_flags;<span class="comment">//数据偏移+保留+控制位</span></span><br><span class="line">u_short  tcp_hlen;</span><br><span class="line">u_short  tcp_bl;</span><br><span class="line">u_short  tcp_flags_urg;<span class="comment">//紧急1有效 </span></span><br><span class="line">u_short  tcp_flags_ack;<span class="comment">//确认=1时，确认号有效</span></span><br><span class="line">u_short  tcp_flags_psh;<span class="comment">//推送1有效，可以不用填满缓存就发报</span></span><br><span class="line">u_short  tcp_flags_rst;<span class="comment">//复位1有效，重新建立连接</span></span><br><span class="line">u_short  tcp_flags_syn;<span class="comment">//同步syn=1,ack=0时，表明这是一个连接请求报文；syn=1,ack=1,接受连接请求</span></span><br><span class="line">u_short  tcp_flags_fin;<span class="comment">//释放连接=1时，表示数据报</span></span><br><span class="line">u_short tcp_window_size;<span class="comment">//窗口（发送方自己的接收窗口）</span></span><br><span class="line">u_short tcp_checksum;<span class="comment">//检验和（首部+数据）</span></span><br><span class="line">u_short tcp_urg;<span class="comment">//紧急指针</span></span><br><span class="line">u_long tcp_option;</span><br><span class="line"></span><br><span class="line">tcp_sport=ntohs(th-&gt;sport);<span class="comment">//源端口</span></span><br><span class="line">tcp_dport=ntohs(th-&gt;dport);<span class="comment">//目的端口</span></span><br><span class="line">tcp_seqnum=ntohl(th-&gt;sequence_number);<span class="comment">//序号（4字节ntohl）  </span></span><br><span class="line">tcp_acknum=ntohl(th-&gt;acknowlegement_number);<span class="comment">//确认号</span></span><br><span class="line">tcp_hlen_bl_flags=ntohs(th-&gt;hlen_bl_flags);<span class="comment">//数据偏移4+保留6+控制位6</span></span><br><span class="line">tcp_hlen=(tcp_hlen_bl_flags &gt;&gt; <span class="number">12</span>)*<span class="number">4</span>;<span class="comment">//以4字节为单位</span></span><br><span class="line">tcp_bl=(tcp_hlen_bl_flags &amp; <span class="number">0x0fc0</span>);<span class="comment">//保留</span></span><br><span class="line">tcp_flags_urg=(tcp_hlen_bl_flags &amp; <span class="number">0x0020</span>);<span class="comment">//紧急1有效                                                    ----- </span></span><br><span class="line">tcp_flags_ack=(tcp_hlen_bl_flags &amp; <span class="number">0x0010</span>);<span class="comment">//确认=1时，确认号有效</span></span><br><span class="line">tcp_flags_psh=(tcp_hlen_bl_flags &amp; <span class="number">0x0008</span>);<span class="comment">//推送1有效，可以不用填满缓存就发报</span></span><br><span class="line">tcp_flags_rst=(tcp_hlen_bl_flags &amp; <span class="number">0x0004</span>);<span class="comment">//复位1有效，重新建立连接</span></span><br><span class="line">tcp_flags_syn=(tcp_hlen_bl_flags &amp; <span class="number">0x0002</span>);<span class="comment">//同步syn=1,ack=0时，表明这是一个连接请求报文；syn=1,ack=1,接受连接请求</span></span><br><span class="line">tcp_flags_fin=(tcp_hlen_bl_flags &amp; <span class="number">0x0001</span>);<span class="comment">//释放连接=1时，表示数据报</span></span><br><span class="line">tcp_window_size=ntohs(th-&gt;window_size);<span class="comment">//窗口（发送方自己的接收窗口）</span></span><br><span class="line">tcp_checksum=ntohs(th-&gt;checksum);<span class="comment">//检验和（首部+数据）</span></span><br><span class="line">tcp_urg=ntohs(th-&gt;urg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n运输层协议：  TCP协议\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印TCP数据报首部*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"端口号：%d -&gt; %d\n"</span>,tcp_sport,tcp_dport);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"序号：%u\t"</span>,tcp_seqnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"确认号：%u\n"</span>,tcp_acknum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数据偏移：%d\t\t"</span>,tcp_hlen);<span class="comment">//首部长度</span></span><br><span class="line"><span class="comment">//printf("保留：%d\n",tcp_bl);</span></span><br><span class="line"><span class="comment">/*控制字段,标志位*/</span></span><br><span class="line"><span class="keyword">if</span> (tcp_flags_urg == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：URG\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_ack == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：ACK\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_psh == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：PSH\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_rst == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：RST\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_syn == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：SYN\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_fin == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：FIN\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"窗口：%d\t\t"</span>,tcp_window_size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"检验和：%d\n"</span>,tcp_checksum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"紧急指针：%d\t\t"</span>,tcp_urg);<span class="comment">//URG=1时才有用，窗口大小为0也能发送</span></span><br><span class="line"><span class="keyword">if</span>(tcp_hlen == <span class="number">20</span>)<span class="comment">//数据偏移(TCP首部长度)&gt;20时才有</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部长度为20字节，没有填充字段。\n"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tcp_option = ntohl(th-&gt;option);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"填充字段:%u\n"</span>, tcp_option);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Callback function invoked by libpcap for every incoming packet */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_handler</span><span class="params">(u_char *param, <span class="keyword">const</span> struct pcap_pkthdr *header, <span class="keyword">const</span> u_char *pkt_data)</span>   <span class="comment">//param 无用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">eth_header *eth;</span><br><span class="line">u_short macType;</span><br><span class="line"></span><br><span class="line">myPrintBaseInfo(header);</span><br><span class="line"></span><br><span class="line">eth=(eth_header *) (pkt_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤以太网头部</span></span><br><span class="line">pkt_data += <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HandleMac</span></span><br><span class="line">macType=handleMac(eth);</span><br><span class="line">myPrintNetType(macType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理ARP 和 RARP</span></span><br><span class="line"><span class="keyword">if</span>(macType==<span class="number">0x0806</span> || macType==<span class="number">0x8035</span>)</span><br><span class="line">&#123;</span><br><span class="line">arp_header *ap;</span><br><span class="line">ap = (arp_header *)(pkt_data);</span><br><span class="line">handleARPAndRARP(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理IP</span></span><br><span class="line"><span class="keyword">if</span>(macType==<span class="number">0x0800</span>)</span><br><span class="line">&#123;</span><br><span class="line">u_short ip_type;</span><br><span class="line">ip_header *ih;</span><br><span class="line">ih = (ip_header *) (pkt_data);</span><br><span class="line">ip_type = handleIP(ih);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ip_type == <span class="number">1</span>) &#123;</span><br><span class="line">icmp_header *ich;</span><br><span class="line">ich = (icmp_header *)((u_char*)ih + all_ip_len);</span><br><span class="line">handleICMP(ich);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">17</span>)&#123;</span><br><span class="line">udp_header *uh;</span><br><span class="line">uh = (udp_header *) ((u_char*)ih + all_ip_len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(handleUDP(uh))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct dns_packet *pdns;</span></span><br><span class="line"><span class="comment">pdns = (struct dns_packet *)(pkt_data + all_ip_len + udp_len); // sport+dport+length+checksum,DNS头指针</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">u_char *query=&amp;(pdns-&gt;dns_data);//定位到查询部分头部</span></span><br><span class="line"><span class="comment">printf("QueryDomain=");</span></span><br><span class="line"><span class="comment">u_char domainname[100]=&#123;0&#125;;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">u_int i=0;</span></span><br><span class="line"><span class="comment">//query++;//把点去了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while(*query)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf("%d", *query);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if(*query &lt; 0x10)//48以后出现数字和英文字母</span></span><br><span class="line"><span class="comment">printf(".");</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">printf("%c", *query);</span></span><br><span class="line"><span class="comment">query++;</span></span><br><span class="line"><span class="comment">i++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf("\n"); */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">6</span>)&#123;</span><br><span class="line">tcp_header *th;</span><br><span class="line">th=(tcp_header *) ((u_char*)ih + all_ip_len);</span><br><span class="line">handleTCP(th);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pcap_if_t</span> *alldevs;</span><br><span class="line"><span class="keyword">pcap_if_t</span> *d;</span><br><span class="line"><span class="keyword">int</span> inum;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">pcap_t</span> *adhandle;</span><br><span class="line"><span class="keyword">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line">u_int netmask;</span><br><span class="line"><span class="keyword">char</span> packet_filter[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析IP数据报输入：\t1\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析ARP数据报输入：\t2\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析TCP数据报输入：\t3\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析UDP数据报输入：\t4\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析ICMP数据报输入：\t5\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析MAC、IP、ARP、TCP、UDP、IMCP输入\t6\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">packet_filter = <span class="string">"ip"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)</span><br><span class="line">packet_filter = <span class="string">"arp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">packet_filter = <span class="string">"ip and tcp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">4</span>)</span><br><span class="line">packet_filter = <span class="string">"ip and udp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">5</span>)</span><br><span class="line">packet_filter = <span class="string">"ip and icmp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">packet_filter = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"InputError : check the number you input! exit(1)"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_program</span> <span class="title">fcode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pcap_findalldevs(&amp;alldevs, errbuf) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error in pcap_findalldevs: %s\n"</span>, errbuf);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(d=alldevs; d; d=d-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d. %s"</span>, ++i, d-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (d-&gt;description)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" (%s)\n"</span>, d-&gt;description);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" (No description available)\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter the interface number (1-%d):"</span>,i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;inum);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if the user specified a valid adapter */</span></span><br><span class="line"><span class="keyword">if</span>(inum &lt; <span class="number">1</span> || inum &gt; i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nAdapter number out of range.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Jump to the selected adapter */</span></span><br><span class="line"><span class="keyword">for</span>(d=alldevs, i=<span class="number">0</span>; i&lt; inum<span class="number">-1</span> ;d=d-&gt;next, i++);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open the adapter */</span></span><br><span class="line"><span class="keyword">if</span> ((adhandle= pcap_open_live(d-&gt;name,<span class="comment">// name of the device</span></span><br><span class="line"> <span class="number">65536</span>,<span class="comment">// portion of the packet to capture. </span></span><br><span class="line"><span class="comment">// 65536 grants that the whole packet will be captured on all the MACs.</span></span><br><span class="line"> <span class="number">1</span>,<span class="comment">// promiscuous mode (nonzero means promiscuous)</span></span><br><span class="line"> <span class="number">1000</span>,<span class="comment">// read timeout</span></span><br><span class="line"> errbuf<span class="comment">// error buffer</span></span><br><span class="line"> )) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the link layer. We support only Ethernet for simplicity. */</span></span><br><span class="line"><span class="keyword">if</span>(pcap_datalink(adhandle) != DLT_EN10MB)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nThis program works only on Ethernet networks.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(d-&gt;addresses != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">/* Retrieve the mask of the first address of the interface */</span></span><br><span class="line">netmask=((struct sockaddr_in *)(d-&gt;addresses-&gt;netmask))-&gt;sin_addr.S_un.S_addr;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">/* If the interface is without addresses we suppose to be in a C class network */</span></span><br><span class="line">netmask=<span class="number">0xffffff</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//compile the filter</span></span><br><span class="line"><span class="keyword">if</span> (pcap_compile(adhandle, &amp;fcode, packet_filter, <span class="number">1</span>, netmask) &lt;<span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nUnable to compile the packet filter. Check the syntax.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set the filter</span></span><br><span class="line"><span class="keyword">if</span> (pcap_setfilter(adhandle, &amp;fcode)&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nError setting the filter.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nlistening on %s...\n"</span>, d-&gt;description);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* At this point, we don't need any more the device list. Free it */</span></span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* start the capture */</span></span><br><span class="line">pcap_loop(adhandle, <span class="number">0</span>, packet_handler, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li><p>听到网卡上Mac帧时的回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_handler</span><span class="params">(u_char *param, </span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">const</span> struct pcap_pkthdr *header, <span class="keyword">const</span> u_char *pkt_data)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出基本信息：包括监听到帧的时间，帧的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintBaseInfo</span><span class="params">(<span class="keyword">const</span> struct pcap_pkthdr *header)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出硬件地址，格式：<code>xx:xx:xx:xx:xx:xx</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintEthAddress</span><span class="params">(eth_address eth)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出IP地址，格式：<code>xx.xx.xx.xx</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintIPAddress</span><span class="params">(ip_address ia)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出网络层协议类型，格式：<code>网络层协议：xxxx</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintNetType</span><span class="params">(u_short type)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析Mac帧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u_short <span class="title">handleMac</span><span class="params">(eth_header *eth)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析ARP和RARP帧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleARPAndRARP</span><span class="params">(arp_header *ah)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析IP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u_short <span class="title">handleIP</span><span class="params">(ip_header *ih)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析ICMP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleICMP</span><span class="params">(icmp_header *ich)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析UDP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handleUDP</span><span class="params">(udp_header *uh)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析TCP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleTCP</span><span class="params">(tcp_header *th)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:13 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;
      
    
    </summary>
    
      <category term="网络编程" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机网络" scheme="https://isjinhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="winpcap" scheme="https://isjinhao.github.io/tags/winpcap/"/>
    
  </entry>
  
  <entry>
    <title>11-关系数据库理论</title>
    <link href="https://isjinhao.github.io/2019/11-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/"/>
    <id>https://isjinhao.github.io/2019/11-关系数据库理论/</id>
    <published>2019-03-27T14:58:59.000Z</published>
    <updated>2019-03-30T01:31:08.777Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><h2 id="关系-amp-关系模式"><a href="#关系-amp-关系模式" class="headerlink" title="关系 &amp; 关系模式"></a>关系 &amp; 关系模式</h2><p>关系模式相当于一张二维表的框架，在这个框架下填入数据，称为关系模式的一个实例，或者叫关系R。关系模式的形式化定义是：$R(U,D,DOM,F)​$</p><ul><li>R：关系名</li><li>U：组成该关系的属性名集合</li><li>D：U中属性所来自的域<ul><li>域：一组具有相同数据类型的值的集合</li></ul></li><li>DOM：属性向域的映像集合</li><li>F：属性间数据的依赖关系集合</li></ul><p>由于D和DOM域与关系模式的设计无关，因此在讨论关系数据库理论时可以把关系模式看做：$R(U,F)​$</p><p>关系的形式化定义：当且仅当$U$上的一个关系$r$满足$F$时，r称为关系模式$R(U,F)$上的一个关系。</p><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>关系模式的设计直接影响着后续增删查改等的操作。如果设计的不合理就会发生各种各样的问题：</p><ul><li>数据冗余太大</li><li>更新异常</li><li>插入异常</li><li>删除异常</li></ul><p>比如对于一个描述学校在校生信息数据库：$Student&lt;U,F&gt;$，$U=\lbrace Sno,Sdept,Mname,Cname,Grade\rbrace$会发生的问题：</p><ul><li>冗余问题：每个系的系主任姓名重复出现，重复次数与该系所有学生的所有课程成绩次数相同</li><li>更新问题：如果某系的系主任更换后，该数据库该系中所有的元组都要更新</li><li>插入异常：如果一个系刚成立，尚无学生，则无法把该系的系主任存入数据库</li><li>删除异常：如果某个系的学生都毕业了，在删除该系学生的同时，该系系主任的信息也会被删除</li></ul><p>一个好的模式不能发生插入异常、删除异常和更新异常，数据冗余应该尽可能少。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>范式指的是规范化的关系模式，而规范也就是条件，满足不同的条件可以分别解除上述所说的不同问题。</p><h3 id="问题发生的原因"><a href="#问题发生的原因" class="headerlink" title="问题发生的原因"></a>问题发生的原因</h3><p>之所以会发生上诉的问题其实就是由于数据依赖。而数据依赖可以分为两种：函数依赖和多值依赖。但这两种依赖关系不是平级，而是递进的关系，所以我们先介绍函数依赖。</p><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>设$R(U)$是一个属性集$U$上的关系模式，$X$和$Y$是$U$的子集。若对于$R(U)$的任意两个可能的关系$r_1$、$r_2$，若$r_1[x]=r_2[x]$，则$r_1[y]=r_2[y]$，则称$X$决定$Y$，或者$Y$依赖$X$。记作$X \rightarrow Y$。</p><p>对于$X​$、$Y​$范围的不同，可以再次分为：</p><ul><li>非平凡函数依赖：如果$X \rightarrow Y​$但$Y \nsubseteq X​$，则称$X \rightarrow Y​$是非平凡函数依赖</li><li>平凡函数依赖：如果$X \rightarrow Y$但$Y \subseteq X$，则称$X \rightarrow Y$是非平凡函数依赖。<ul><li>例：$(Sno,Sname) \rightarrow Sname$</li></ul></li></ul><p>所以，在关系模式中，平凡函数依赖是一定是可以被满足的，所以我们在以后的讨论中不再关注平凡函数依赖，只关注非平凡函数依赖。而我们对于非平凡函数依赖又可以分为以下几类：</p><ul><li>完全函数依赖：如果$X \rightarrow Y​$，并且对于任意的真子集$X_i​$，都无法做到$X_i \rightarrow Y​$，则称$Y​$对$X​$是完全函数依赖。</li><li>部分函数依赖：如果$X \rightarrow Y​$，存在真子集$X_i​$，可以做到$X_i \rightarrow Y​$，则称$Y​$对$X​$是部分函数依赖。</li><li>传递函数依赖：如果$X \rightarrow Y$，$Y \rightarrow Z$且$Y \nrightarrow X$，则称$X$对$X$有传递函数依赖。</li></ul><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>在关系模型中的每一个具体关系$R$中，如果每个属性都是不可再分的，则称$R$属于第一范式，记作$R \in 1NF$。</p><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>$R \in 1NF​$且每一个非主属性完全函数依赖于码，则$R \in 2NF​$。依赖有直接依赖和传递依赖。</p><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>$R \in 2NF$且$R$中的每个非主属性不传递依赖于主码，则关系$R$是第三范式，$R \in 3NF$。</p><h3 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h3><p>从低级范式到高级范式的方法是模式分解。</p><p>举例：对于一个关系$R(SNO,SNA,CNO,GRADE,CNA,TNA,TAGE)$（学号、姓名、课号、成绩、课程名称、教师姓名、教师年龄）。</p><p>现实语义：如果假设一个教师可以交多门课且一门课仅由一个教师讲授，可得R的函数依赖集：</p><ul><li>$SNO \rightarrow SNM$</li><li>$(SNO,CNO) \rightarrow GRADE​$</li><li>$CNO \rightarrow CNA$</li><li>$CNO \rightarrow TNA$</li><li>$TNA \rightarrow TAGE​$</li></ul><p>函数依赖图如下：</p><div align="center"><img src="/2019/11-关系数据库理论/函数依赖图.jpg" style="width:50%"></div><p>分解为第二范式：</p><ul><li><p>$R1&lt;(SNO,SNA),SNO \rightarrow SNA&gt;​$</p></li><li><p>$R2&lt;(SNO,CNO,GRADE), (SNO,CNO) \rightarrow GRADE&gt;​$</p></li><li><p>$R3&lt;(CNO,CNA,TNA,TAGE),CNO \rightarrow CNA, CNO \rightarrow TNA, TNA \rightarrow TAGE&gt;​$</p></li></ul><p>分解为第三范式：</p><ul><li><p>$R1&lt;(SNO,SNA),SNO \rightarrow SNA&gt;$</p></li><li><p>$R2&lt;(SNO,CNO,GRADE), (SNO,CNO) \rightarrow GRADE&gt;$</p></li><li><p>$R3&lt;(CNO,CNA,TNA),CNO \rightarrow CNA, CNO \rightarrow TNA&gt;​$</p></li><li>$R3&lt;(CNO,TAGE),CNO \rightarrow TAGE&gt;$</li></ul><h3 id="第三范式的问题"><a href="#第三范式的问题" class="headerlink" title="第三范式的问题"></a>第三范式的问题</h3><p>仓库保管$WPE(W#,P#,E#,QNT)$，（ 仓库号，器件号，职工号，数量）。</p><p>一个职工只能管理一个仓库的某类型器件，一个仓库的某类型器件数量是确定的，一个员工管理的某类型器件数量是一定的。</p><p>函数依赖：</p><ol><li>$(W#, P#) \rightarrow QNT$</li><li>$(E#,P#) \rightarrow QNT$</li><li>$(W#,P#) \rightarrow E#​$</li><li>$E# \rightarrow W#$</li></ol><p>函数依赖图：</p><div align="center"><img src="/2019/11-关系数据库理论/函数依赖图2.jpg" style="width:50%"></div><p>此时关系模式$WPE​$有两个侯选码，$(W#,P#)​$ ，$(E#,P#)​$，假设确定$(E#,P#)​$为主码，那么某新职工分配来仓库，处于学习阶段，但没有独立承但任务，即有$E#​$但无$P#​$，缺少码的组成部分，无法插入到该关系，即插入异常。这是由于<strong>主属性$W#​$对另一个侯选码$(E#,P#)​$的部分函数依赖</strong>。</p><h3 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h3><p>BC范式的定义：每个决定因素都包含码，则$R \in BCNF​$。</p><p>而既然每个决定因素都要包含码，则此时意味着必须放弃某些函数依赖，即失去某些现实语义。如例子中若选择$(E#,P#)$，则只能保存函数依赖中的2和4。</p><h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h3><p>设$R(U)$是属性集U上的一个关系模式。$X$，$Y$，$Z$是的$U$的子集，并且$Z=U-X-Y$。关系模式$R(U)$中多值依赖（记做，$X \rightarrow \rightarrow Y$）成立，当且仅当对$R(U)$的任一关系$r$，给定的一对$(x,z)$值有一组$Y$的值，这组值仅仅决定于$x$值而与$z$值无关。</p><p>若$X \rightarrow \rightarrow Y$，$Z$为空，则称$X \rightarrow \rightarrow Y$为平凡的多值依赖。 所以我们以下只讨论非平凡的函数依赖。</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>比如对于关系模型$Teaching(C,T,B)$便是存在多值依赖（码为全属性）：</p><div align="center"><img src="/2019/11-关系数据库理论/teaching.jpg" style="width:80%"></div><h3 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h3><p>如果对于$R$的每个非平凡多值依赖$X \rightarrow \rightarrow Y$，$X$都含有码，则$R$都含有码。</p><p>多值依赖的解决依然是分解。如上例中分解为：</p><ul><li>$R(C,T)$</li><li>$R(C,B)$</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;关系-amp-关系模式&quot;&gt;&lt;a href=&quot;#关系-amp-关系模式&quot; class=&quot;headerlink&quot; title=&quot;关系 &amp;a
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CPP中的字节序</title>
    <link href="https://isjinhao.github.io/2019/CPP%E4%B8%AD%E7%9A%84%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    <id>https://isjinhao.github.io/2019/CPP中的字节序/</id>
    <published>2019-03-27T13:26:28.000Z</published>
    <updated>2019-03-27T14:12:15.059Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。</p><ul><li><p>大端字节序：高位字节在前，低位字节在后。</p></li><li><p>小端字节序：低位字节在前，高位字节在后。</p></li></ul><p>假如我们要存储<code>0x01234567</code>，大端法和小端法如下：</p><div align="center"><img src="/2019/CPP中的字节序/大端.gif" style="width:70%"></div><h2 id="为什么会有小端字节序"><a href="#为什么会有小端字节序" class="headerlink" title="为什么会有小端字节序"></a>为什么会有小端字节序</h2><p>人类能接受的字节序肯定是大端存储，所以很多人会不理解为什么还要有小端字节序呢？其实计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。</p><p>个人觉得之所以会存在小端字节序是由于计算机电路在计算时先处理低位字节，存储单元里的数据按小端字节序存储方便计算。</p><h2 id="字节序的处理"><a href="#字节序的处理" class="headerlink" title="字节序的处理"></a>字节序的处理</h2><ul><li><p>其实只有读取的时候，才必须区分字节序，其他情况都不用考虑。</p></li><li><p>数据长度大于1字节（8bits）时才需要区分字节序。</p></li></ul><p>虽然在计算机中存储和具体的平台相关，但是规定在网络中传输的数据采用大端传输，即如果有一串网络流为：<code>010101000100110101010</code>，实际发送时越左边的越先发送到网络中。</p><h3 id="C语言中处理字节序"><a href="#C语言中处理字节序" class="headerlink" title="C语言中处理字节序"></a>C语言中处理字节序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为16位主机字节序的值，返回值是16位网络字节序的值</span></span><br><span class="line"><span class="keyword">uing16_t</span> htons(<span class="keyword">uint16_t</span> host16bitvalue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为32位主机字节序的值，返回值是32位网络字节序的值</span></span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> host32bitvalue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为16位网络字节序的值，返回值是16位主机字节序的值</span></span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> net16bitvalue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为16位网络字节序的值，返回值是16位主机字节序的值</span></span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> net32bitvalue);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;字节序&quot;&gt;&lt;a href=&quot;#字节序&quot; class=&quot;headerlink&quot; title=&quot;字节序&quot;&gt;&lt;/a&gt;字节序&lt;/h2&gt;&lt;p&gt;计
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="https://isjinhao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="字节序" scheme="https://isjinhao.github.io/tags/%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    
      <category term="计算机组成原理" scheme="https://isjinhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="https://isjinhao.github.io/2019/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://isjinhao.github.io/2019/物理层/</id>
    <published>2019-03-27T05:15:14.000Z</published>
    <updated>2019-03-27T13:11:04.558Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><h3 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h3><p>数字通信中对数字信号的计量单位。在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>假如基带信号是<code>101011000110111010...</code>，如果直接发送，则每个码元携带一个比特的信息（每个码元只有2种状态），但是如果将信号中的三个比特编为一组，即101，011，000，110，111，010…，三个比特共有8种不同的排列，我们可以用不同的调制方法来表示这种信，如8种不同的振幅，频率，相位等，如果采用相位调制，相位$\phi_0$表示000，$\phi_1$表示001，以此类推，那么接收端如果收到相位是$\phi_0$的信号就知道表示的是000，以此类推，这样一个码元就不知不觉的传输了三个比特位的信号，此时每个码元有8种状态。一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难。</p><h3 id="编码级别"><a href="#编码级别" class="headerlink" title="编码级别"></a>编码级别</h3><p>如果把n个比特编码成一个码元，则此时编码状态$M=2^n$，其表示当前传输时有多少不同的状态，如8级编码，会有：<code>000、001、010 …</code></p><h2 id="奈斯准则"><a href="#奈斯准则" class="headerlink" title="奈斯准则"></a>奈斯准则</h2><h3 id="码间串扰"><a href="#码间串扰" class="headerlink" title="码间串扰"></a>码间串扰</h3><p>码元的传输速率是有限制的，超过某上限就会出现码间串扰问题。这是由于在真正传输中，信号在传输时都不是理想化的，如下图就是理想化的高低电平和真实传输时的高低电平。</p><div align="center"><img src="/2019/物理层/真实和理想.jpg" style="width:50%"></div><p>假如此时速度太快，就可能把低电平和高电平弄混。而最高的码元传输速率被奈斯准则限制。</p><h3 id="奈斯准则内容"><a href="#奈斯准则内容" class="headerlink" title="奈斯准则内容"></a>奈斯准则内容</h3><ul><li>理想低通信道（能通过信号频率在某值之下）的最高码元传输速率为：$2W Baud$。</li></ul><div align="center"><img src="/2019/物理层/低通信道.png" style="width:80%"></div><ul><li>理想带通信道（能通过信号频率在某范围之内）的最高码元传输速率为：$1W Baud$。</li></ul><div align="center"><img src="/2019/物理层/带通信道.png" style="width:80%"></div><p>W是理想低通信道的带宽，单位为赫(Hz)。Baud 是波特，是码元传输速率的单位，1 波特为每秒传送 1 个码元。</p><h3 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h3><p>单位时间内数据通信系统所传输的码元个数（信号个数），单位是波特（Baud）。</p><h3 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h3><p>表示单位时间内数据通信系统传输的比特数，单位是比特/秒（b/s或bps）。$比特率 = 波特率 * log_2M$</p><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><h3 id="编码级数限制"><a href="#编码级数限制" class="headerlink" title="编码级数限制"></a>编码级数限制</h3><p>虽然码元传输速率有限制，但是如果我们能尽可能提高编码级数不就能提升信息传输速率了吗？但事实上信号传输速率不受限于调制技术，而是受限于信噪比。举个例子，如果我们是在天气晴朗的一天出门，我们穿任意颜色衣服都能被分辨出来，但是如果我们在沙尘暴天气出门，穿<code>橘黄</code>和<code>橙黄</code>两种颜色的衣服别人自然就认不出来了。在这个比喻中衣服的颜色代表码元，确定衣服的颜色代表信息，沙尘暴就是噪声。</p><h3 id="香农公式内容"><a href="#香农公式内容" class="headerlink" title="香农公式内容"></a>香农公式内容</h3><p>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率$C=W \ast log_2(1+PS/PN)（b/s）​$。</p><ul><li>其中$W$是信道的带宽。$PS$是信号的能量。$PN$是噪声的能量。</li><li>信噪比：$S/N=10lg{PS/PN}$。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>设带宽是<code>1MHz</code>，信噪比是<code>24dB</code>，则信道的最高信息传输速率为：$C=1M \ast log_2{(1+(10^{2.4}))}=7.98Mbps$。</p><h2 id="奈氏准则vs香农公式"><a href="#奈氏准则vs香农公式" class="headerlink" title="奈氏准则vs香农公式"></a>奈氏准则vs香农公式</h2><div align="center"><img src="/2019/物理层/香农公式和奈斯准则.png" style="width:80%"></div><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>电路交换中独占电路资源，并不是指用户线和中继线都被此次交换所独占，而是说在两个用户建立连接之后，除非连接中断，否则他们当前所拥有的资源不会被释放，即使他们之间不传输信息。而如何在中继线上实现多组用户通信就是多路复用技术。</p><p>产生多路复用的物理基础是：传输媒体的带宽或容量往往会大于传输单一信号的需求，使用多路复用，为了有效地利用通信线路，希望一个信道同时传输多路信号。</p><p>这种技术会将链路/网络资源（如带宽）划分为“资源片”，将资源片分配给各路“呼叫”（calls），每路呼叫独占分配到的资源片进行通信，资源片可能“闲置”</p><p>常见的复用技术有：频分多路复用、时分多路复用、波分多路复用、码分多路复用。</p><div align="center"><img src="/2019/物理层/多路复用.png" style="width:80%"></div><h3 id="频分多路复用"><a href="#频分多路复用" class="headerlink" title="频分多路复用"></a>频分多路复用</h3><p>FMD：Frequency-division multiplexing，是指载波带宽被划分为多种不同频带的子信道，每个子信道可以并行传送一路信号的一种多路复用技术。也就是说信道的可用频带被分成若干个互不交叠的频段，每路信号用其中一个频段传输，因而可以用滤波器将它们分别滤出来，然后分别解调接收。</p><div align="center"><img src="/2019/物理层/频分多路复用.png" style="width:40%"></div><h3 id="时分多路复用"><a href="#时分多路复用" class="headerlink" title="时分多路复用"></a>时分多路复用</h3><p>TDM：time division multiplexing，它使不同的信号在不同的时间内传送，将整个传输时间分为许多时间间隔（Time Slot，TS，又称为时隙），每个时间片被一路信号占用。TDM就是通过在时间上交叉发送每一路信号的一部分来实现一条电路传送多路信号的。电路上的每一短暂时刻只有一路信号存在。因数字信号是有限个离散值，所以TDM多应用于数字通信系统。</p><div align="center"><img src="/2019/物理层/时分多路复用.png" style="width:70%"></div><h3 id="波分多路复用"><a href="#波分多路复用" class="headerlink" title="波分多路复用"></a>波分多路复用</h3><p>将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器（亦称合波器，Multiplexer）汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；在接收端，经解复用器（亦称分波器或称去复用器，Demultiplexer）将各种波长的光载波分离，然后由光接收机作进一步处理以恢复原信号。</p><div align="center"><img src="/2019/物理层/波分多路复用.png" style="width:70%"></div><h3 id="码分多路复用"><a href="#码分多路复用" class="headerlink" title="码分多路复用"></a>码分多路复用</h3><p>为每个用户分配一个唯一的mbit的码片序列（chipping sequence），二进制下的0用-1表示，二进制下的1用+1表示。在信道上传输的信号 = 原始数据 <em>码片序列，比如码片序列是：(-1, 1, 1)，需要传一个0，应该是 -1 </em>(-1, 1, 1)，所以传输的就是(1, -1, -1)。</p><p>同时为了保证数据之间不相互影响，被共享的用户所占有的码片应该相互正交的。即：$\frac{1}{m}S_i \cdot S_j = 0 (i \neq j)​$。而信道上真正传输的数据是各用户发送数据的叠加值。</p><div align="center"><img src="/2019/物理层/码分多路复用.png" style="width:80%"></div><h3 id="数字信号在模拟信道传输"><a href="#数字信号在模拟信道传输" class="headerlink" title="数字信号在模拟信道传输"></a>数字信号在模拟信道传输</h3><p>数字信号需要编码后才能传输。常见的三种编码：</p><ol><li>NRZ编码：进制数字0、1分别用两种电平来表示。常用-5V表示1，+5V表示0。</li><li>曼切斯特编码：用电压的变化表示0和1：高→低 &lt;=&gt; 0，低→高 &lt;=&gt; 1。</li><li>差分曼切斯特编码：在码元开始处有无跳变来表示0和1：有 &lt;=&gt; 0，无 &lt;=&gt; 1。</li></ol><div align="center"><img src="/2019/物理层/数字信号编码.png" style="width:80%"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;码元&quot;&gt;&lt;a href=&quot;#码元&quot; class=&quot;headerlink&quot; title=&quot;码元&quot;&gt;&lt;/a&gt;码元&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://isjinhao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://isjinhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础</title>
    <link href="https://isjinhao.github.io/2019/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>https://isjinhao.github.io/2019/计算机网络基础/</id>
    <published>2019-03-26T13:43:16.000Z</published>
    <updated>2019-03-27T13:11:04.558Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:13 GMT+0800 (GMT+08:00) --><p>本人是非通信专业学生，加上本身水平有限，对于物理层和计算机网络基础错误会较多，敬请指出。</p><h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>信道是数据交换的载体。狭义上说人和人之间交流所承载信息的空气就是信道。广义上说它还可以包括有关的变换装置，这样的话信道往往被分成信道编码器、信道本身和信道译码器。</p><p>简易通信系统模型如下：</p><div align="center"><img src="/2019/计算机网络基础/信道.png"></div><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>计算机网络就是互联的、自治的计算机集合。自治指的是所有的计算机直接没有主从关系；互联指的是互联互通，能进行数据交换。</p><p>计算机网络的本质是一种通信网络，只不过信源和信宿都是主机。它是计算机技术和通信技术的结合。</p><h2 id="主机（host）"><a href="#主机（host）" class="headerlink" title="主机（host）"></a>主机（host）</h2><p>诸如手机、电脑、服务器等端系统（end systems）。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>如果想实现多个计算机之间的互联，按照之前的想法是每两台计算机进行连接，但这样太麻烦，一个好的做法是把这个计算机连接在某一中心上，这个中心把所有连接上来的计算机进行互联，在链路层这个中心叫做交换机。</p><div align="center"><img src="/2019/计算机网络基础/交换机.png" style="width:25%"></div><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>分组是带有地址信息的信息小片，可以理解成是计算机把一个文件切片后打成的包裹，由两部分构成：地址信息和真正传输的东西。</p><div align="center"><img src="/2019/计算机网络基础/分组.jpg"></div><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>是计算机网络的一种专用计算机，它只有一个功能，就是转发分组。可以简单的理解为路由器是电子化的邮局，全国所有的邮局之间互联，是包裹能够传递，路由器之间互联，是分组能够正确转发。</p><p>路由器和交换机的区别是：交换机将计算机连在一起，构成局域网；路由器将局域网连在一起，形成互联网。</p><h2 id="计算机网络基本原理"><a href="#计算机网络基本原理" class="headerlink" title="计算机网络基本原理"></a>计算机网络基本原理</h2><p>分组交换技术，也就是拆分分组、传输分组、合并分组的技术。</p><p>这个技术的优点就是便宜，因为把数据打包成分组和分组拆分都在计算机中进行，网络上只进行分组的转发，就使得网络的结构很简单，路由器设计也很简单。这一中原则被叫做“端到端的原则”，即能在端系统做的事情不在网络上实现。</p><div align="center"><img src="/2019/计算机网络基础/计算机网络基本原则.jpg" style="width:60%"></div><h2 id="分组交换技术"><a href="#分组交换技术" class="headerlink" title="分组交换技术"></a>分组交换技术</h2><ol><li>一个主机至少连接一个路由器：数据最终是通过路由器进行转发的，所以一个主机至少得连接一个路由器。</li><li>分组存储转发：分组完全进入路由器后，路由器按照地址信息检索转发表。注意不是第一个bit或Byte进入时就开始转发，是全部进入才转发。</li><li>分组独立选择路径：一个文件被分成多个分组，但这些分组之间是独立的，路由器给他们看成相互独立的数据。分组的组装是通过接收方进行的，和网络无关。</li></ol><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><h3 id="组成细节角度"><a href="#组成细节角度" class="headerlink" title="组成细节角度"></a>组成细节角度</h3><p>ISP网络互联形成的网络之网络。由运行各种网路应用的计算设备，光纤、铜缆、无线电等通信链路、路由器和交换机等组成的分组交换设备组成。</p><h3 id="服务角度"><a href="#服务角度" class="headerlink" title="服务角度"></a>服务角度</h3><p>是为网络应用提供通信服务的通信基础设施和为网络应用提供的应用编程接口。</p><h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>ISP，全称为Internet Service Provider，因特网服务提供商，即指提供互联网服务的公司。能提供拨号上网服务、网上浏览、下载文件、收发电子邮件等服务。</p><h2 id="网络的结构"><a href="#网络的结构" class="headerlink" title="网络的结构"></a>网络的结构</h2><ul><li>网络边缘：位于“网络边缘”运行网络应用程序的端系统。</li></ul><ul><li>接入网络、物理介质：有线或无线的通信链路。</li></ul><ul><li>网络核心：互联的路由器（或分组转发设备）。构成“网络之网络”的关键。</li></ul><div align="center"><img src="/2019/计算机网络基础/计算机网络结构.png" style="width:30%"></div><h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><p>客户/服务器应用模型：依赖于专用服务器，如Web应用。</p><p>对等应用模型：不依赖专用服务器，通信在对等实体之间进行，如P2P应用。</p><h2 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h2><p>接入网络是一种用户网络，它连接用户到特定的服务提供商并通过承载网络到达其他网络。两个被用户关心的特征：带宽（数据传输速率，bps）、独占/共享（独占是带宽为某用户独用，共享是多个用户分用同一带宽）。</p><div align="center"><img src="/2019/计算机网络基础/接入网络.jpg" style="width:50%"></div><h2 id="数字用户线路：DSL"><a href="#数字用户线路：DSL" class="headerlink" title="数字用户线路：DSL"></a>数字用户线路：DSL</h2><p>是以电话线为传输介质的传输技术组合。DSL技术在传递公用电话网络的用户环路上支持对称和非对称传输ADSL：上行速度较慢，下行速度较快）模式。</p><p>用DSL接入Internet时用户一方会有DSL调制解调器，被接入方会有DSL接入多路复用器与多个用户进行接入。</p><div align="center"><img src="/2019/计算机网络基础/DSL.png" style="width:60%"></div><h2 id="电缆网络"><a href="#电缆网络" class="headerlink" title="电缆网络"></a>电缆网络</h2><p>又被称为混合光纤同轴电缆网络。也是一种非对称式的接入网络。但它是共享网络，多个用户共同接入一个解调器。</p><div align="center"><img src="/2019/计算机网络基础/电缆网络.png" style="width:80%"></div><h2 id="常见网络接入"><a href="#常见网络接入" class="headerlink" title="常见网络接入"></a>常见网络接入</h2><h3 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h3><h3 id="家庭接入-1"><a href="#家庭接入-1" class="headerlink" title="家庭接入"></a>家庭接入</h3><div align="center"><img src="/2019/计算机网络基础/家庭接入.png" style="width:75%"></div><h3 id="机构（企业）接入"><a href="#机构（企业）接入" class="headerlink" title="机构（企业）接入"></a>机构（企业）接入</h3><div align="center"><img src="/2019/计算机网络基础/企业接入.png" style="width:70%"></div><h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3><div align="center"><img src="/2019/计算机网络基础/无线局域网.png"></div><h3 id="广域局域网"><a href="#广域局域网" class="headerlink" title="广域局域网"></a>广域局域网</h3><div align="center"><img src="/2019/计算机网络基础/广域局域网.png" style="width:40%"></div><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心的功能是：路由（routing）：确定分组从源到目的传输路径；转发（forwarding）：将分组从路由器的输入端口交换至正确的输出端口。</p><div align="center"><img src="/2019/计算机网络基础/网络核心.png" style="width:70%"></div><h2 id="Internet结构"><a href="#Internet结构" class="headerlink" title="Internet结构"></a>Internet结构</h2><div align="center"><img src="/2019/计算机网络基础/Internet结构.png" style="width:70%"></div><ul><li><p><code>一级ISP包含</code>：网通、电信等商业ISP，还包含谷歌、微软等内容提供商网络。</p></li><li><p><code>IXP</code>：全称：Internet eXchange Point，即互联网交换中心。互联网Internet是由众多的网络互相连接而形成的全球性网络，互联网交换中心负责这些不同的网络之间互相通信的交换点，是互联网的关键基础设施。</p></li></ul><h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>包含三个阶段：建立连接、通信、释放连接。最显著的特点是独占电路资源。最典型的是电话网络。（下图的中继线上可以存在多组用户通信，详见复用技术）</p><div align="center"><img src="/2019/计算机网络基础/电路交换.png" style="width:80%"></div><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>报文交换是指把信息整个打包，然后经过存储转发送到目的地。</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>分组交换是把信息拆分成不同的分组，然后把所有的分组相继发送给路由器，路由器通过路由&amp;转发把数据传输到目的地。</p><ul><li>和报文交换的区别是：报文交换不拆分信息。</li></ul><ul><li>和电路交换的区别是：如果把每个分组看成原子单位，区别就是各分组走不同的路径，不需要独占资源。</li></ul><h3 id="图解三种交换"><a href="#图解三种交换" class="headerlink" title="图解三种交换"></a>图解三种交换</h3><div align="center"><img src="/2019/计算机网络基础/图解三种交换.png" style="width:80%"></div><h3 id="分组交换的优势"><a href="#分组交换的优势" class="headerlink" title="分组交换的优势"></a>分组交换的优势</h3><ul><li>和报文交换相比：速度快，因为在报文交换时，同一时间只有一个路由器在工作，其他路由器在等待。路由器的存储空间小，最低存储空间和分组大小差不多。</li></ul><ul><li>和电路交换相比：分组交换允许更多用户同时使用网络，让网络资源充分共享。</li></ul><h3 id="分组交换的劣势"><a href="#分组交换的劣势" class="headerlink" title="分组交换的劣势"></a>分组交换的劣势</h3><p>可能产生拥塞（congestion）：分组延迟和丢失。需要协议处理可靠数据传输和拥塞控制。</p><h2 id="RFC文档"><a href="#RFC文档" class="headerlink" title="RFC文档"></a>RFC文档</h2><p>Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。目前RFC文件是由Internet Society（ISOC）赞助发行。基本的互联网通信协议都有在RFC文件内详细说明。RFC文件还额外加入许多的论题在标准内，例如对于互联网新开发的协议及发展中所有的记录。因此几乎所有的互联网标准都有收录在RFC文件之中。</p><h2 id="IETF"><a href="#IETF" class="headerlink" title="IETF"></a>IETF</h2><p>全称：The Internet Engineering Task Force，国际互联网工程任务组。全球互联网最具权威的技术标准化组织，主要任务是负责互联网相关技术规范的研发和制定，是一个由为互联网技术工程及发展做出贡献的专家自发参与和管理的国际民间机构。主要任务是负责互联网相关技术标准的研发和制定，是国际互联网业界具有一定权威的网络相关技术研究团体。绝大多数国际互联网技术标准出自IETF。</p><h2 id="时延和网络利用率"><a href="#时延和网络利用率" class="headerlink" title="时延和网络利用率"></a>时延和网络利用率</h2><p>若令D0表示网络空闲时的时延，D表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示D和D0之间的关系：$D=\frac{D_0}{1-U}$。</p><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>network protocol。为进行网络中的数据交换而建立的规则、标准或约定。其中规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到的消息或发生的事件而产生的动作。也可以说网络协议规定了网络中所有信息的发送和接受过程。</p><h3 id="协议三要素"><a href="#协议三要素" class="headerlink" title="协议三要素"></a>协议三要素</h3><ul><li>语义：语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。</li></ul><ul><li>语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。</li></ul><ul><li>时序：时序是对事件发生顺序的详细说明。（也可称为“同步”）。</li></ul><p>总结：语义表示要做什么，语法表示要怎么做，时序表示做的顺序。</p><h2 id="速率-amp-带宽"><a href="#速率-amp-带宽" class="headerlink" title="速率 &amp; 带宽"></a>速率 &amp; 带宽</h2><ul><li><p>速率：又称数据率，数据传输速率或比特率。单位bps、kbps、Mbps、Gbps。</p></li><li><p>带宽：数字信道所能传输的最大数据率。单位bps等。</p></li></ul><h2 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h2><p>如果路由器的缓存满了，再到达的分组会被路由器丢弃，即造成丢包现象。丢包率 = 丢包数 / 已发分组数。</p><h2 id="分组延迟"><a href="#分组延迟" class="headerlink" title="分组延迟"></a>分组延迟</h2><ul><li>结点处理延迟：差错检测、确定输出链路；</li></ul><ul><li>排队延迟：等待输出链路可用、取决于路由器拥塞程度；</li></ul><ul><li>传输延迟：分组长度/链路带宽；</li></ul><ul><li>传播延迟：物理链路长度/信号传输速度。</li></ul><div align="center"><img src="/2019/计算机网络基础/分组延迟.jpg" style="width:60%"></div><h2 id="流量强度"><a href="#流量强度" class="headerlink" title="流量强度"></a>流量强度</h2><p>设链路带宽为R(bps)，分组长度为L(bits)，平均每组到达速率为v。则：</p><ul><li>$L \ast v / R \longrightarrow 0 ​$时：平均排队延迟很小；</li></ul><ul><li>$L \ast v / R \longrightarrow 1$时：平均排队延迟很大；</li></ul><ul><li>$L \ast v / R &gt; 1​$时：超出服务能力，延迟 趋向于 无限大。</li></ul><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>$时延带宽积 = 传播时延 \ast 带宽$，单位：bit。实际意义是：从我们向某一信道上发送第一个bit，到这个bit被接收方接受这个时间里，发送方总共向信道上发送了多少bit。也可以称为以比特为单位的链路长度，比如某段链路长度为n比特。</p><h2 id="吞吐率-量（Throughput）"><a href="#吞吐率-量（Throughput）" class="headerlink" title="吞吐率/量（Throughput）"></a>吞吐率/量（Throughput）</h2><p>发送端与接收端之间的传送数据率（b/s）。端到端的吞吐量取决于瓶颈链路。</p><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><p>指通信系统的整体设计，它为网络硬件、软件、协议、存取控制和拓扑提供标准。</p><p>计算机网络是一个非常复杂的系统，需要解决的问题很多并且性质各不相同。所以，在设计时，就使用了“分层”的思想，即将庞大而复杂的问题分为若干较小的易于处理的局部问题。各层之间是按照功能进行分层的，同时每层遵循相应的网络协议完成本层功能。</p><h2 id="OSI参考模型的通信过程"><a href="#OSI参考模型的通信过程" class="headerlink" title="OSI参考模型的通信过程"></a>OSI参考模型的通信过程</h2><p>七层结构：物理层、数据链路层、网络层、传输层、对话层、表示层和应用层。</p><ul><li>端系统需要完成七层的功能，中间系统完成三层功能。</li></ul><ul><li><p>协议之间是对等的，比如应用层的协议对发送方来说是如何把信息传输到表示层，而对接收方来说，是如何把从表示层传来的信息还原到应用层。</p></li><li><p>对于后四层，从逻辑上说不需要经过中间系统，所以被称为“端-端层”。</p></li></ul><div align="center"><img src="/2019/计算机网络基础/osi.png" style="width:70%"></div><h3 id="OSI参考模型的数据封装"><a href="#OSI参考模型的数据封装" class="headerlink" title="OSI参考模型的数据封装"></a>OSI参考模型的数据封装</h3><ul><li><p>后六层每层在把数据向下一层传输时都会加上控制信息。而物理层不再封装，因为到达它的数据已经时二进制数据，直接传输就行。</p></li><li><p>数据链路层传送给物理层时一般加头加尾，其他层只加头。头是首部，尾是循环冗余校验。</p></li></ul><div align="center"><img src="/2019/计算机网络基础/osi数据.png" style="width:80%"></div><h3 id="PDU"><a href="#PDU" class="headerlink" title="PDU"></a>PDU</h3><p>协议数据单元。可能包括地址：标识发送端/接收端等；差错检测编码：用于差错检测或纠正；协议控制：一些如优先级、服务质量、安全控制等信息。</p><h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p>四层结构：应用层、运输层、网际层和网络接口层。</p><p>所有的应用都架构在IP上，在网络接口层只要能构建IP，能进行分组就可以算是网络的一部分，这是互联网发展迅速的一大原因。</p><div align="center"><img src="/2019/计算机网络基础/TCPIP模型.png" style="width:70%"></div><h2 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h2><p>五层结构：物理层、链路层、网络层、传输层和应用层。此模型结合了OSI概念清晰，分工明确的优点和TCP/IP简单实用的优点。</p><h3 id="五层传输模型的数据封装"><a href="#五层传输模型的数据封装" class="headerlink" title="五层传输模型的数据封装"></a>五层传输模型的数据封装</h3><div align="center"><img src="/2019/计算机网络基础/五层模型.png" style="width:70%"></div><h3 id="三种模型对应"><a href="#三种模型对应" class="headerlink" title="三种模型对应"></a>三种模型对应</h3><div align="center"><img src="/2019/计算机网络基础/三种模型对应.png" style="width:70%"></div><h2 id="物理层实现的功能概述"><a href="#物理层实现的功能概述" class="headerlink" title="物理层实现的功能概述"></a>物理层实现的功能概述</h2><p>核心功能：<strong>透明地传送比特流</strong>。解决的问题一般如下：</p><ul><li><p>接口特性：</p><ul><li>机械特性：接口的几何形状，位置等等；</li><li>电气特性：使用电压的高低等等；</li><li>功能特性：各个引脚的作用等等；</li><li>规程特性：工作的过程是什么样的，如哪个引脚先发送数据，哪个后发送等。</li></ul></li><li><p>比特编码：用信号的什么特征表示信息，如什么时候用0，什么时候用1。</p></li><li><p>数据率：在物理层上传输数据的速率。</p></li><li><p>比特同步：解决时钟同步问题，发送端何时发送数据，接收端何时接受数据。</p></li><li><p>传输模式：</p><ul><li>单工通信：一个为确定的发送端、一个为确定的接收端，不能互换。</li><li>半双工：发送端和接收端可以互换，但是随时间交替的。</li><li>双工：两端可以同时发送和接受数据。</li></ul></li></ul><h2 id="数据链路层功能概述"><a href="#数据链路层功能概述" class="headerlink" title="数据链路层功能概述"></a>数据链路层功能概述</h2><p>核心功能：<strong>在两个相邻结点之间的链路上“透明”地传送数据</strong>。解决的问题如下：</p><ul><li><p>组帧：来自网络层的数据被加头加尾后形成的数据叫做帧。组帧问题包含：头和尾里包含什么信息等。</p></li><li><p>物理寻址：物理层只进行比特流的传输，其他的都不做。物理寻址是在数据链路层做的，也就是数据链路层传输层给物理层的数据包含处理好的地址。</p></li><li><p>流量控制：使数据的发送和数据的接收尽可能平衡，防止数据太多造成丢失等。</p></li><li><p>差错处理：检测并重传损坏或丢失帧，并避免重复帧。</p></li><li><p>访问（接入）控制：在任一时刻觉得哪个设备拥有链路使用权。</p></li></ul><div align="center"><img src="/2019/计算机网络基础/链路层.png" style="width:80%"></div><h2 id="网络层功能概述"><a href="#网络层功能概述" class="headerlink" title="网络层功能概述"></a>网络层功能概述</h2><p>核心功能：</p><ol><li>负责为分组交换网上的不同主机提供通信服务。</li><li>选择合适的路由，是源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</li></ol><p>解决的问题：</p><ul><li><p>逻辑寻址：全局唯一逻辑地址，确保数据分组被送达的主机，如IP地址。</p></li><li><p>路由和分组转发：确保在网络中数据能从源主机到目的主机</p><div align="center"><img src="/2019/计算机网络基础/网络层.png" style="width:70%"></div></li></ul><h2 id="传输层功能"><a href="#传输层功能" class="headerlink" title="传输层功能"></a>传输层功能</h2><p>核心功能：负责向两个主机中进程之间的通信提供服务。</p><p>解决的问题：</p><ul><li><p>分段与重组：网络层传输的分组大小是有限制的。应用层的</p></li><li><p>SAP寻址：确保将完整报文提交给正确进程，如端口号</p><ul><li>SAP：Service Access Point，在同一系统中相邻两层的实体进行交互的地方。</li></ul></li><li>连接控制：有两种协议，面向连接的TCP和无连接的UDP。</li><li>流量控制：匹配发送方和接收方的速度。</li><li>差错控制：如发送的报文接收方没有接受到或者接收方缓冲区由于满把报文丢弃该怎么处理。</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>核心功能：直接为用户的应用进程提供服务。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:13 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本人是非通信专业学生，加上本身水平有限，对于物理层和计算机网络基础错误会较多，敬请指出。&lt;/p&gt;&lt;h2 id=&quot;信道&quot;&gt;&lt;a href=&quot;#信道
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://isjinhao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://isjinhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>10-索引</title>
    <link href="https://isjinhao.github.io/2019/10-%E7%B4%A2%E5%BC%95/"/>
    <id>https://isjinhao.github.io/2019/10-索引/</id>
    <published>2019-03-26T07:29:37.000Z</published>
    <updated>2019-03-26T12:48:34.366Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><h2 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h2><p>使用索引是因为索引是查询性能优化最有效的手段。Mysql中的索引分为两种：<code>B+树</code>和<code>Hash表</code>，但是我们在这里只介绍基于<code>B+树</code>的索引。INNODB引擎也只支持<code>B+树</code>索引。</p><p>Mysql的索引是在存储引擎级别设置的。</p><h2 id="索引匹配原则"><a href="#索引匹配原则" class="headerlink" title="索引匹配原则"></a>索引匹配原则</h2><p>假如有如下表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People(</span><br><span class="line">last_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">first_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">dob <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">gender enum(<span class="string">'m'</span>, <span class="string">'f'</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">key</span>(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>对应的<code>B+树</code>如下：</p><div align="center"><img src="/2019/10-索引/举例B树.jpg"></div><p>建立的索引对如下类型的查询有效：</p><h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>和索引中定义的所有列进行匹配，如查找姓名为<code>Cuba Allen</code>，出生于<code>1996-01-01</code>的人。</p><h3 id="匹配最左前缀"><a href="#匹配最左前缀" class="headerlink" title="匹配最左前缀"></a>匹配最左前缀</h3><p>前面提到的索引可用于查找所有姓为<code>Allen</code>的人，即只使用索引的第一列。</p><h3 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h3><p>也可以只匹配某一列的值的开头部分，例如前面提到的索引可用于查找所有以<code>J</code>开头的姓的人。这里使用了索引的第一列。</p><h3 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h3><p>例如前面提到的索引可用于查找姓在<code>Allen</code>和<code>Barrymore</code>之间的人。这里也只用了索引的第一列。</p><h3 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h3><p>前面提到的索引也可用于查找所有姓为<code>Allen</code>，并且名字是<code>K</code>开头的人。</p><h2 id="索引分类和创建"><a href="#索引分类和创建" class="headerlink" title="索引分类和创建"></a>索引分类和创建</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。</p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>索引列中的值必须是唯一的，但是允许为空值，</p><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>是一种特殊的唯一索引，不允许有空值。后面会有介绍，在INNODB中，主键索引是聚簇索引。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="建表时创建"><a href="#建表时创建" class="headerlink" title="建表时创建"></a>建表时创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line">(</span><br><span class="line">    [col_name data_type],</span><br><span class="line">    ...,</span><br><span class="line">[<span class="keyword">UNIQUE</span>] [<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>] [index_name] (col_name[<span class="keyword">length</span>], ...) [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="后期添加"><a href="#后期添加" class="headerlink" title="后期添加"></a>后期添加</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] [<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>] [index_name]</span><br><span class="line">(col_name[<span class="keyword">length</span>], ...) [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>] index_name <span class="keyword">ON</span> table_name</span><br><span class="line">(col_name[<span class="keyword">length</span>], ...) [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p><code>INDEX</code>和<code>KEY</code>具有相同的效果。<code>length</code>是指该列在<code>B+树</code>中的关键字所占的长度。</p><h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇的意思是键值和数据行紧凑地存储在一起，因为无法把数据行放在两个不同的地方，所以一个表只有一个聚簇索引。而主键会被默认添加上聚簇索引，如果没有主键，<code>INNODB</code>会选择一个非空索引来替代，如果没有这样的索引，<code>INNODB</code>会隐式定义一个主键来作为聚簇索引。</p><div align="center"><img src="/2019/10-索引/聚簇索引.jpg"></div><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。又被称为二级索引。INNODB的二级索引其叶子结点上保存的是<code>KEY+PRIMARY COL</code>。</p><h3 id="INNODB索引"><a href="#INNODB索引" class="headerlink" title="INNODB索引"></a>INNODB索引</h3><div align="center"><img src="/2019/10-索引/聚簇索引INNODB.jpg"></div><p>注意：INNODB中主键索引就是聚簇索引。</p><h3 id="MyISAM索引"><a href="#MyISAM索引" class="headerlink" title="MyISAM索引"></a>MyISAM索引</h3><div align="center"><img src="/2019/10-索引/非聚簇索引MYISAM.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;索引基础&quot;&gt;&lt;a href=&quot;#索引基础&quot; class=&quot;headerlink&quot; title=&quot;索引基础&quot;&gt;&lt;/a&gt;索引基础&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>B树</title>
    <link href="https://isjinhao.github.io/2019/B%E6%A0%91/"/>
    <id>https://isjinhao.github.io/2019/B树/</id>
    <published>2019-03-25T07:39:51.000Z</published>
    <updated>2019-03-26T12:48:34.366Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><h2 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h2><h3 id="磁盘构造"><a href="#磁盘构造" class="headerlink" title="磁盘构造"></a>磁盘构造</h3><div align="center"><img src="/2019/B树/磁盘.jpg"></div><p>当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头（又叫磁头）下通过，就可以进行数据的读/写了。</p><p>一般磁盘分为固定头盘（磁头固定）和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。</p><p>活动头盘 （如上图）的磁头是可移动的。每一个盘面上只有一个磁头（磁头是双向的，因此正反盘面都能读写）。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的（行动整齐划一）。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。</p><h3 id="访问时间"><a href="#访问时间" class="headerlink" title="访问时间"></a>访问时间</h3><p>典型的磁盘访问时间包括以下三个部分：</p><ol><li>寻道时间$T_s$：$T_s = s$</li><li>旋转延迟时间$T_τ$：$T_t = \frac{1}{2r}$</li><li>磁盘访问时间 ：$T_t=\frac{b}{rN}$</li></ol><p>$s$是指磁头从当前位置定位到开始点的时间，$b$是传输的字节数，$r$是每秒的转数，$N$是一条磁道上的字节数。$总时间 = T_s + \frac{1}{2r} + \frac{b}{rN}$</p><p>这其中，时间开销最大的是$s$，台式机的旋转速度一般是7200转/分钟（RPM），即旋转一周需要8.33ms，所以式子中的$s$平均为4.165ms，而且磁臂的移动也需要时间，通常磁盘的平均存储时间是$8-11ms$。而硅存储的常见存取时间是50ns，即$s$约为一次存取时间200000倍。通常一页的长度为$2^{11}-2^{14}$，即使磁盘一般是一次读取连续的几个页面，定位到信息的时间也比存取信息的时间多。所以当大量数据存储在外存磁盘中时，需要一种合理高效的数据结构来降低访问外存的时间：B树。需要说一下，B树的英文名是<code>B-tree</code>，所以有时候有人会把<code>B树</code>叫做<code>B-树</code>，这两个名词是同一个意思。</p><p>B树的典型执行过程中，B树算法的运行时间取决于<code>DISK-READ</code>和<code>DISK-WRITE</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = a pointer to some object</span><br><span class="line">DISK-READ(x)</span><br><span class="line">operations of x</span><br><span class="line">DISK-WRITE(x)</span><br></pre></td></tr></table></figure><p>通常一个B树的结点和磁盘的一页一样大，这样一次读写操作能获取更多的信息。而每页能存储多少个数据和关键字大小有关。下图中的B树每个结点有1000个数据（B树中结点的度数为结点数据个数+1，见后面的定义），高度为2。所以它可以存储超过十亿个关键字，查找某个关键字至多进行两次磁盘访问。</p><div align="center"><img src="/2019/B树/B树举例.jpg"></div><h2 id="B树的定义"><a href="#B树的定义" class="headerlink" title="B树的定义"></a>B树的定义</h2><h3 id="B树的定义-1"><a href="#B树的定义-1" class="headerlink" title="B树的定义"></a>B树的定义</h3><ul><li><p>每个结点有如下属性：</p><ol><li>$x.n$：表示当前存储在结点$x$中的关键字个数。</li><li>每个结点中的关键字以非降序方式存放：$x.key_1 \leq x.key_2 \leq \cdots \leq x.key_n$。</li><li>$x.leaf$：一个布尔值，如果$x$是叶结点，则为$true$，否则为$false$。</li></ol></li><li><p>每个内部结点还包含包含$x.n+1$个指向其孩子的指针：$x.c_1, x.c_2, \cdots , x.c_n $，叶结点的$c_i$属性没有定义。</p></li><li><p>关键字$x.key_i​$对存储在各子树中的关键字范围加以分割：如果$k_i​$为任意一个存储在以$x.c_i​$为根的子树中的关键字，满足：$k_i \leq x.key_1 \leq k_2 \leq x.key_2 \leq \cdots \leq x.key_{x.n} \leq k_{x.n+1}​$。</p></li><li>每个叶结点具有相同的深度，即树的高度h。</li><li>每个结点关键字所包含的关键字个数有上界和下界。用一个被称为B树的最小度数的固定整数$t​$来表示这些界，$t \geq 2​$。<ol><li>除了根结点外的每个结点都至少有$t-1​$个关键字，因此，除了根结点以外的每个内部结点至少有$t​$个孩子。如果树非空，根结点至少有一个关键字。</li><li>每个结点至多可包含$2t-1$个关键字，因此一个内部结点至多可有$2t$个孩子，当一个结点恰好有$2t-1$个关键字时，该结点是满的。</li><li>$t=2​$的树是最简单的，每个内部结点有2个、3个或4个孩子。</li></ol></li></ul><p>那么为什么最小度数不能取1呢？因为最小度数取1之后，内部结点（设指向其的指针为p）可以包含0个关键字，此时包含0个关键字的结点只有一个孩子（设为c），这个结点就被浪费了，我们其实可以直接让p指向c。</p><h3 id="B树的高度"><a href="#B树的高度" class="headerlink" title="B树的高度"></a>B树的高度</h3><p>对任意一棵包含n（$n \geq 1​$）个关键字、最小度数为t的B树来说，有：$h \leq log_t{\frac{n+1}{2}}​$。证明：</p><p>假设根所在的层深度为0，则高度为h的B树在深度为1的层至少包含2个结点，在深度为2的层至少包含$2t$个结点，在深度为3的层至少包含$2t^2$个结点…直到深度为h的层至少包含$2t^{h-1}$个结点。可得关于关键字个数n的关键字：$n \geq 1+(t-1)\sum_{i=1}^h2t^i-1 = 1+2(t-1)(\frac{t^h-1}{t-1})=2t^h-1$</p><p>$\Longrightarrow t^h \leq (n+1)/2$</p><p>$\Longrightarrow h \leq log_t{\frac{n+1}{2}}$</p><h3 id="B树的阶"><a href="#B树的阶" class="headerlink" title="B树的阶"></a>B树的阶</h3><p>我们经常会遇到一个B数的术语：阶，假如树中的结点最多含有m个孩子，此B树的阶为m。当阶为偶数的时候，我们可以把定义中的$t$替换成$m/2$，但是当阶为奇数的时候就要考虑一个问题了，除根结点外的每个内部结点至少含有<code>ceil(m/2)</code>个结点还是<code>floor(m/2)</code>个结点？应该是<code>ceil(m/2)</code>，因为除了根结点每个结点的孩子个数满足：$t \leq keyNum \leq 2t$，如果取<code>floor(m/2)</code>会发现无法满足上式，所以<strong>一棵含有n个总关键字数的m阶的B树的最大高度是</strong>：$log_{ceil(m/2)}(n+1)/2$。</p><h2 id="B树的操作"><a href="#B树的操作" class="headerlink" title="B树的操作"></a>B树的操作</h2><p>以下的操作都遵循两个规定：</p><ul><li>B树的根结点始终在主存中，这样就不用对根做<code>DISK-READ</code>操作。然而，当根结点被改变后需要对根结点做一次<code>DISK-WRITE</code>操作。</li><li>任何被当做参数的结点在被传递之前，都要对它们先做一次<code>DISK-READ</code>操作。</li></ul><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>设$x$是根结点，被搜索的关键字是$k$。</p><div align="left"><img src="/2019/B树/搜索.jpg"></div><p>需要说明一下，伪代码中$key$和$c​$的起始下标都为1。NIL代表空。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入的时候会遇到两种情况：</p><ol><li>将新的关键字插在一个已经存在但<strong>未满</strong>的结点上：直接插入；</li><li>将新的关键字插在一个已经存在但<strong>已满</strong>的结点上：分裂后插入；</li></ol><h4 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h4><p>将一个满的结点$y$（有$2t-1$个关键字）按照中间关键字分裂成两个各含有$t-1$个关键字的结点，中间关键字被升到$y$的父结点。如果$y​$的父结点也是满的，也需要分裂，最终满结点的分裂会向上传播。如果向上传播时全程都是满结点会把根结点分裂，使B树的高度增1。分裂是使B树增高的唯一办法。</p><p>但是在实际操作中不是等到找出插入过程中实际要分裂的结点才做分裂，而是在沿着树向下查找时分裂所有遇到的满结点，这样就能保证在插入的时候节点一定非满。</p><div align="left"><img src="/2019/B树/分裂.jpg"></div><p>$x$是被分裂的结点的父节点，$y$是$x$的第$i​$个孩子。</p><div align="center"><img src="/2019/B树/分裂举例.jpg"></div><h4 id="非满结点插入"><a href="#非满结点插入" class="headerlink" title="非满结点插入"></a>非满结点插入</h4><div align="left"><img src="/2019/B树/非满结点插入.jpg"></div><p>$x$是被插入的节点，$k$是插入的键。解释几行代码：</p><ul><li>12行：被操作的节点从磁盘中读入到内存中，然后在内存中进行操作。</li><li>7行+17行：每次插入的都是叶节点。</li></ul><h4 id="完整插入过程"><a href="#完整插入过程" class="headerlink" title="完整插入过程"></a>完整插入过程</h4><div align="left"><img src="/2019/B树/完整插入过程.jpg"></div><p>此时对根的分裂需要创建两个节点，而且对根的分裂是B树长高的唯一办法。而且在分裂之后我们会发现根节点必然会有一个关键字，这也对应了定义中的B树的根至少有两个孩子。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>分配空节点：</p><div align="left"><img src="/2019/B树/创建.jpg"></div><p>分配之后循环调用插入即可。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在删除时需要注意两个部分：</p><ol><li>除根节点外，被删除关键字的节点在删除后仍然要满足$keyNum \geq t-1$。</li><li>删除后需要重新安排这个结点的孩子。</li></ol><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ol><li>如果关键字$k$在结点$x$中，并且$x$是叶节点，从$x$中删除$k$</li><li>如果关键字$k$在结点$x$中，但$x$是内部非根节点：上移孩子结点中的某相近元素（“左孩子最右边的节点”或“右孩子最左边的节点”）到父节点中，并且递归被上移的孩子。删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于$ceil(m/2)-1$，则需要看其某相邻兄弟结点是否贫困（结点中元素个数等于$ceil(m/2)-1$）如果非贫困，则父节点下降一个元素来此节点，兄弟结点上升一个元素。如果其相邻兄弟都贫困，则该结点与其相邻的某一兄弟结点进行“合并“成一个结点。</li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><div align="center"><img src="/2019/B树/B树删除.jpg"></div><ul><li>刪除H：直接删除</li><li>删除T：W上升到T的位置，4上升到W的位置</li><li>删除R：删除导致只有1个元素，已经小于最小元素数目$ceil(5/2)-1=2$，由于右相邻兄弟结点不贫困，所以先向父节点借一个元素T下移到该叶子结点中，代替原来S的位置，S前移；然后W上移到父结点中，X、Y、Z依次前移。</li></ul><div align="center"><img src="/2019/B树/删除2.jpg"></div><ul><li>删除E：因为E所在的结点和相邻的兄弟结点的关键字都刚好达标，删除后不能再向父节点借元素，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点与含有A和C的相邻兄弟结点进行合并成一个结点。但是此时还没有结束，此时的情况如下图第一幅，此时父节点只包含一个元素G，没达标。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有Q,X）含有的元素个数大于2，咱们可以将M下移到元素很少的子结点中，将Q上移到M的位置，但此时咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，即树的高度减少一层。</li></ul><div align="center"><img src="/2019/B树/删除3.jpg"></div><div align="center"><img src="/2019/B树/删除4.jpg"></div><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>在B树中，我们做操作的时候都默认了关键字和其对应的数据都存在一个页面中，但是实际上可以只存储关键字，而且仅存关键字可以让每页能存储更多的数据。基于此点和为了更好的在文件系统中存取数据，诞生了B+树。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>B+树</code>可以被视为每个节点仅包含键（不是键值对），并且链接了各叶节点叶的B树。和B树的区别如下：</p><ul><li>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 （而B树的叶子节点并没有包括全部需要查找的信息）。</li><li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 （而B树的非终节点也包含需要查找的有效信息）</li></ul><div align="center"><img src="/2019/B树/B+树.jpg"></div><h3 id="为什么数据库使用B-树作为索引"><a href="#为什么数据库使用B-树作为索引" class="headerlink" title="为什么数据库使用B+树作为索引"></a>为什么数据库使用B+树作为索引</h3><ul><li>B+树的磁盘读写代价更低。B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li></ul><ul><li>B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。而B+树只要遍历叶子节点就可以实现整棵树的遍历。</li><li><code>B+树</code>对<code>range-query</code>的支持很强大。比如要查<code>5-10</code>之间的，<code>B+树</code>一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。</li></ul><h3 id="分裂-1"><a href="#分裂-1" class="headerlink" title="分裂"></a>分裂</h3><p>B+树的分裂和B树没有太大区别，只是分裂后注意叶子结点需要有链接到下个结点的指针。</p><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>B*树是B+树的变体，在B+树的基础上（所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针）:</p><ul><li>B*树中非根和非叶子结点再增加指向兄弟的指针；</li><li>B*树定义了非叶子结点关键字个数至少为$ceil((2/3) \ast m)$，即块的最低使用率为2/3（代替B+树的1/2）。</li></ul><div align="center"><img src="/2019/B树/Bast.jpg"></div><h3 id="分裂-2"><a href="#分裂-2" class="headerlink" title="分裂"></a>分裂</h3><p>当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>B树及其变形可以非常好的处理一维空间存储的问题。它的思想就是把一维直线分为若干段线段，当我们查找满足某个要求的点的时候，只要去查找它所属的线段即可。也可以说要查找某一满足条件的点，先去找到满足条件的线段，然后遍历所在线段上的点，即可找到答案。</p><div align="center"><img src="/2019/B树/B树.jpg"></div><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li><p><code>B树</code>：有序数组+平衡多叉树；</p></li><li><p><code>B+树</code>：有序数组链表+平衡多叉树；</p></li><li><p><code>B*树</code>：一棵丰满的B+树。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/v_JULY_v/article/details/6530142" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/details/6530142</a></li><li><a href="https://en.wikipedia.org/wiki/B%2B_tree#Overview" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/B%2B_tree#Overview</a></li><li><a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/B-tree</a></li><li>算法导论</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;磁盘访问时间&quot;&gt;&lt;a href=&quot;#磁盘访问时间&quot; class=&quot;headerlink&quot; title=&quot;磁盘访问时间&quot;&gt;&lt;/a&gt;磁盘访
      
    
    </summary>
    
      <category term="DSA" scheme="https://isjinhao.github.io/categories/DSA/"/>
    
    
      <category term="DSA" scheme="https://isjinhao.github.io/tags/DSA/"/>
    
      <category term="树" scheme="https://isjinhao.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>09-Mysql结构和存储引擎</title>
    <link href="https://isjinhao.github.io/2019/09-Mysql%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>https://isjinhao.github.io/2019/09-Mysql结构和存储引擎/</id>
    <published>2019-03-24T13:27:56.000Z</published>
    <updated>2019-03-25T07:39:25.800Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><div align="center"><img src="/2019/09-Mysql结构和存储引擎/Mysql体系结构.jpg"></div><p>Mysql大致可以被分为四层：</p><h3 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h3><ul><li>Connectors指的是不同语言中与SQL的交互</li></ul><h3 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h3><ul><li>Management Serveices &amp; Utilities：系统管理和控制工具，例如备份恢复、Mysql复制、集群等</li><li>Connection Pool: 连接池，管理缓冲用户连接、用户名、密码、权限校验、线程处理等需要缓存的需求</li><li>SQL Interface: SQL接口，接受用户的SQL命令，并且返回用户需要查询的结果。比如<code>select * from</code>就是调用SQL Interface。</li><li>Parser: 解析器，SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本， 主要功能：<ol><li>将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的</li><li>如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的</li></ol></li><li><p>Optimizer：查询优化器，SQL语句在查询之前会使用查询优化器对查询进行优化。他使用的是“选取-投影-联接”策略进行查询。 用一个例子就可以理解：<code>select uid,name from user where gender = 1;</code></p><ul><li>先根据where语句进行选取，而不是先将表全部查询出来以后再进行gender过滤</li><li>再根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤</li><li>再将这两个查询条件联接起来生成最终查询结果</li></ul></li><li><p>Cache和Buffer（高速缓存区）：查询缓存，如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。 通过LRU算法将数据的冷端溢出，未来得及时刷新到磁盘的数据页，叫脏页。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。</p></li></ul><h3 id="第三级"><a href="#第三级" class="headerlink" title="第三级"></a>第三级</h3><ul><li>Engine：存储引擎。存储引擎是MySql中具体的与文件打交道的子系统。现在有很多种存储引擎，各个存储引擎的优势各不一样，最常用的<code>MyISAM</code>，<code>InnoDB</code>，<code>BDB</code>。默认下<code>MySql</code>是使用InnoDB引擎。</li></ul><h3 id="第四级"><a href="#第四级" class="headerlink" title="第四级"></a>第四级</h3><p>外存中真正存储数据的物理空间。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>Mysql中真正和外存打交道的是存储引擎。一般有两种最常见的引擎：</p><h3 id="INNODB"><a href="#INNODB" class="headerlink" title="INNODB"></a>INNODB</h3><div align="center"><img src="/2019/09-Mysql结构和存储引擎/INNODB.jpg"></div><ul><li><p>是缓存层，由一个大的innodb buffer pool和很多个其他小的内存组件组成，用来缓冲数据的，innodb的数据读取写入不是直接操作文件，而是从文件加载到缓存，在缓冲里做操作，再flush到磁盘文件。所以INNODE可以支持事务。</p></li><li><p>是各种后台线程，例如IO线程、日志线程、监控线程等；</p></li><li><p>是各种数据文件层，例如INNODB的数据文件、redo log等；</p></li></ul><h3 id="MYISAM"><a href="#MYISAM" class="headerlink" title="MYISAM"></a>MYISAM</h3><ul><li>MYISAM存储引擎的数据组织形式是一种堆表，和索引组织表相区别（INNODB的数据组织形式是索引组织表）。 例如插入一条数据id=2（d为主键，表里已经存在id=1和id=3数据）。<ul><li>MYISAM存储引擎：如果插入id=2，数据的插入位置和id=1 id=3无关系，也就是无序的； 堆表的插入特性是无序的。</li><li>INNODB存储引擎：如果插入id=2，会插入到id=1和id=3之间，因为INNODB是索引组织表是有有序的；索引组织表的最大特点是根据主键去查询效率非常快。</li></ul></li><li>MYISAM存储引擎不支持事务；</li><li>INNODB存储引擎的缓存不缓存数据，只缓存索引。数据缓存是交给操作系统的内存来缓存的。这种会有问题：如果查询一个大表，会消耗大量操作系统内存，如果表中碎片很大可能会浪费大量操作系统内存。</li><li>锁粒度较大：使用的是读写锁（读的时候不允许写，写的时候不允许读，只有读的时候允许读）</li></ul><p>参考：<a href="https://www.cnblogs.com/zhoubaojian/articles/7866231.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoubaojian/articles/7866231.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;MySQL体系结构&quot;&gt;&lt;a href=&quot;#MySQL体系结构&quot; class=&quot;headerlink&quot; title=&quot;MySQL体系结构
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>08-Mysql的锁</title>
    <link href="https://isjinhao.github.io/2019/08-Mysql%E7%9A%84%E9%94%81/"/>
    <id>https://isjinhao.github.io/2019/08-Mysql的锁/</id>
    <published>2019-03-24T12:31:10.000Z</published>
    <updated>2019-03-25T00:45:05.850Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><p>数据库的锁按照不同的分类可以分成很多类，常见的分类如下：</p><h2 id="悲观锁-amp-乐观锁"><a href="#悲观锁-amp-乐观锁" class="headerlink" title="悲观锁 &amp; 乐观锁"></a>悲观锁 &amp; 乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁就是在操作数据时，总是认为操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟<code>java</code>中的<code>synchronized</code>很相似，所以悲观锁需要耗费较多的时间。悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。不用考虑悲观锁，它对于应用程序员是透明的。</p><p>说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。<strong>共享锁和排它锁是悲观锁的不同的实现</strong>，它俩都属于悲观锁的范畴。参考：<a href="https://isjinhao.github.io/2019/06-%E4%BA%8B%E5%8A%A1/#more">https://isjinhao.github.io/2019/06-%E4%BA%8B%E5%8A%A1/#more</a></p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>首先先说一下，乐观锁不是锁，只是人们都习惯这样叫。对于乐观锁来说在操作数据时，总是认为操作不会出现数据冲突，所以不会上锁。那么如何控制并发问题呢？这其实是在应用程序级完成的功能，一般来说可以用数据版本（<code>Version</code>）记录机制实现。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的<code>version</code>字段来实现。当读取数据时，将<code>version</code>字段的值一同读出，数据每更新一次，对此<code>version</code>值加1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的<code>version</code>值进行比对，如果数据库表当前版本号与第一次取出来的<code>version</code>值相等，则予以更新，否则认为是过期数据。</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>数据库表设计，三个字段，分别是<code>id</code>，<code>value</code>，<code>version</code>。</p><p>每次更新表中的value字段时，为了防止发生冲突，需要这样两步操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">value</span>,<span class="keyword">version</span> <span class="keyword">from</span> <span class="keyword">TABLE</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">value</span>=<span class="number">2</span>,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125; and version=#&#123;version&#125;;</span></span><br></pre></td></tr></table></figure><h2 id="按加锁的粒度分"><a href="#按加锁的粒度分" class="headerlink" title="按加锁的粒度分"></a>按加锁的粒度分</h2><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>是Mysql中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分ySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。特点是开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。分为共享锁和排他锁。特点是开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><h3 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h3><p>表级锁是Mysql中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。特点是开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><p>存储引擎参考：<a href="https://isjinhao.github.io/2019/09-Mysql%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/#more">https://isjinhao.github.io/2019/09-Mysql%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/#more</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;数据库的锁按照不同的分类可以分成很多类，常见的分类如下：&lt;/p&gt;&lt;h2 id=&quot;悲观锁-amp-乐观锁&quot;&gt;&lt;a href=&quot;#悲观锁-amp-乐
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>09-磁盘存储器的管理</title>
    <link href="https://isjinhao.github.io/2019/09-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <id>https://isjinhao.github.io/2019/09-磁盘存储器的管理/</id>
    <published>2019-03-21T03:33:26.000Z</published>
    <updated>2019-03-23T13:05:30.596Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --><p>文件管理的目标是管理文件的组织方式，管理文件的访问权等。而磁盘存储器的管理是管理存储器的使用，如何高效利用存储器。他俩是棋与棋盘的关系。</p><h2 id="连续组织方式"><a href="#连续组织方式" class="headerlink" title="连续组织方式"></a>连续组织方式</h2><p>文件的信息存放在若干连续的物理块中。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/连续组织方式.jpg" style="width:70%"></div><ul><li>优点<ul><li>简单</li><li>支持顺序存取和随机存取</li><li>顺序存取速度快，所需的磁盘寻道次数和寻道时间最少</li></ul></li><li>缺点<ul><li>文件不能动态增长（预留空间：浪费、重新分配和移动）</li><li>不利于文件插入和删除</li><li>外部碎片问题</li></ul></li></ul><h2 id="链接组织方式"><a href="#链接组织方式" class="headerlink" title="链接组织方式"></a>链接组织方式</h2><h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>在文件的目录中记录该文件的第一和最后一个盘块的指针，每一个盘块的指针指向文件的下一物理块号。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/隐式链接.jpg"></div><ul><li>优点<ul><li>文件可动态增长</li><li>有利于文件的插入和删除</li><li>提高了磁盘空间利用率,不存在外部碎片问题</li></ul></li><li>缺点<ul><li>存取速度慢，不适于随机存取</li><li>可靠性问题，如指针出错</li><li>更多的寻道次数和寻道时间</li><li>链接指针占用一定的空间</li></ul></li></ul><h3 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h3><p>将链接文件各物理块的指针显示地放在内存的一张链接表（文件分配表，File Allocation Table）中。在FCB的物理地址中填写其首指针所对应的盘块号。由于文件分配表示存储在内存中的，可以大大减少访问磁盘的次数。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/显示链接.jpg" style="width:70%"></div><h3 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h3><p>微软公司早、中期推出的操作系统一直都是采用的FAT技术，即利用文件分配表FAT来记录每个文件中所有盘块之间的链接。FAT中引入了“卷”的概念，支持将一个物理磁盘分成四个逻辑磁盘，每个逻辑磁盘就是一个卷（也称为分区），每个卷都可以被单独格式化和使用。把盘块作为基本分配单位，同时每个分区中都配有两张相同的文件分配表FAT1和FAT2。</p><p>FAT技术的发展有三个阶段：FAT12、FAT16和FAT32</p><h4 id="FAT12"><a href="#FAT12" class="headerlink" title="FAT12"></a>FAT12</h4><p>FAT表的每个表项占用12个bit。所以最多有$2^{12}$个表项，每个盘块的大小是512B，则每个磁盘分区的容量是2MB，能处理的磁盘最大容量是8MB。</p><p>为了增大FAT能管理的最大容量，引入了“簇”的概念，每个簇是一组相邻的扇区，这样如果分配时以簇为单位进行分配就能管理更大的磁盘容量，但是相应的簇内零头也会更大，降低磁盘的利用率。</p><h4 id="FAT16"><a href="#FAT16" class="headerlink" title="FAT16"></a>FAT16</h4><p>FAT表的每个表项占用16个bit。最多有$2^{16}$个表项。</p><h4 id="FAT32"><a href="#FAT32" class="headerlink" title="FAT32"></a>FAT32</h4><p>FAT表的每个表项占用16个bit。最多有$2^{32}$个表项。同时每个簇固定为4KB。所以最大可管理$4 \ast 2^{10} \ast 2^{32} = 2TB$大小的空间。</p><h3 id="NTFS"><a href="#NTFS" class="headerlink" title="NTFS"></a>NTFS</h3><h2 id="索引组织方式"><a href="#索引组织方式" class="headerlink" title="索引组织方式"></a>索引组织方式</h2><h3 id="单级索引组织方式"><a href="#单级索引组织方式" class="headerlink" title="单级索引组织方式"></a>单级索引组织方式</h3><p>一个文件的信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构索引表，并将这些块的块号存放在一个索引表中。一个索引表就是磁盘块地址数组，其中第i个条目指向文件的第i块。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/索引组织方式.jpg" style="width:60%"></div>·<br><br>### 多级索引组织方式<br><br><div align="center"><img src="/2019/09-磁盘存储器的管理/多级索引组织方式.jpg"></div><h3 id="增量式索引组织方式"><a href="#增量式索引组织方式" class="headerlink" title="增量式索引组织方式"></a>增量式索引组织方式</h3><p>可以更好的满足大、中、小文件的组织。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/增量组织方式.jpg"></div><h2 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h2><p>文件存储空间的管理包括空闲块的组织分配和回收。</p><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>把一个连续未分配区域称为“空闲文件”，系统为所有空闲文件单独建立一个目录。表目内容：序号，第一个空白块号，空白块个数。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/空闲链表.jpg"></div><ul><li><p>分配算法：内存管理中的首次适应算法、循环首次适应算法。</p></li><li><p>合并：空闲区邻接合并</p></li></ul><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>空闲盘块链：所有空闲盘块拉成一条链，分配时从头分配，回收时链接在尾部。</p><p>空闲盘区链：每个连续的盘块组成一个盘区，每个盘区包含本盘区的大小和下一个盘区的地址。</p><h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><p>用一串二进制位反映磁盘空间中分配使用情况，每个物理块对应一位，分配物理块为1，否则为0。申请物理块时，可以在位示图中查找为0的位，返回对应物理块号；归还时；将对应位转置0。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/位示图法.jpg"></div><h3 id="成组链接法（重点）"><a href="#成组链接法（重点）" class="headerlink" title="成组链接法（重点）"></a>成组链接法（重点）</h3><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接法.jpg"></div><ul><li>把所有的空闲盘块按每n个一组分成m个组。</li><li>最后一个组放在内存的空闲盘块号栈中，其他组存在外存上。空闲盘块号栈是一个临界资源，只允许一个进程同时访问。</li><li><p>数据结构，一个size为n+1的栈。图上是一个倒着的的栈（栈底在上方，栈顶在下方）</p></li><li><p>一个n+1的栈实际可用盘块只有n（图上只有99个可用盘块），因为栈底是一个计数器，指示当前有多少个可用盘块，但是可用盘块中有一个是指向下一个组，即stack[1]指向下一个组。如果stack[1]==0表示此时是最后一组。</p></li><li>分配时从栈顶开始向下分配，直至分配出n-1个盘块，此时如果再想分配一个块就需要把下一个组调入空闲盘块号栈。调入后新组覆盖旧组。<strong>然后把新组在外存中占用的盘块分配出去。</strong></li><li>回收时从栈底向上回收，如果计数器==100时还有空闲盘块（设这个盘块编号为p）要回收，就把空闲盘块号栈内的组取出来存在p中，在空闲盘块号栈内新开辟一个组，新组的stack[1]指向p。</li></ul><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>此题题目及来源：<a href="https://blog.csdn.net/ajay666/article/details/73569654" target="_blank" rel="noopener">https://blog.csdn.net/ajay666/article/details/73569654</a></p><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接例.jpg"></div><p>分配3个盘块后，回收它所占的5个盘块，回收的盘块号依次为700、711、703、788、701，画出分配回收过程。</p><h4 id="第一次分配"><a href="#第一次分配" class="headerlink" title="第一次分配"></a>第一次分配</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接例1.jpg"></div><h4 id="第二次分配"><a href="#第二次分配" class="headerlink" title="第二次分配"></a>第二次分配</h4><p>注意：300号盘块中存储的组信息调入空闲盘块号栈之后其自己也可以被分配。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接例2.jpg"></div><h4 id="第三次分配"><a href="#第三次分配" class="headerlink" title="第三次分配"></a>第三次分配</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接例3.jpg"></div><h4 id="第一次回收"><a href="#第一次回收" class="headerlink" title="第一次回收"></a>第一次回收</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/第一次回收.jpg"></div><h4 id="第二次回收"><a href="#第二次回收" class="headerlink" title="第二次回收"></a>第二次回收</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/第二次回收.jpg"></div><h4 id="第三次-amp-第四次-amp-第五次回收"><a href="#第三次-amp-第四次-amp-第五次回收" class="headerlink" title="第三次&amp;第四次&amp;第五次回收"></a>第三次&amp;第四次&amp;第五次回收</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/第三四五次回收.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Wed Apr 03 2019 09:11:12 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;文件管理的目标是管理文件的组织方式，管理文件的访问权等。而磁盘存储器的管理是管理存储器的使用，如何高效利用存储器。他俩是棋与棋盘的关系。&lt;/p&gt;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
