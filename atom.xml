<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ISJINHAO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://isjinhao.github.io/"/>
  <updated>2019-03-31T12:10:36.466Z</updated>
  <id>https://isjinhao.github.io/</id>
  
  <author>
    <name>ISJINHAO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java的GC</title>
    <link href="https://isjinhao.github.io/2019/Java%E7%9A%84GC/"/>
    <id>https://isjinhao.github.io/2019/Java的GC/</id>
    <published>2019-03-31T07:58:38.000Z</published>
    <updated>2019-03-31T12:10:36.466Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;!-- rebuild by neat --&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>直接引用和符号引用</title>
    <link href="https://isjinhao.github.io/2019/%E7%9B%B4%E6%8E%A5%E5%BC%95%E7%94%A8%E5%92%8C%E7%AC%A6%E5%8F%B7%E5%BC%95%E7%94%A8/"/>
    <id>https://isjinhao.github.io/2019/直接引用和符号引用/</id>
    <published>2019-03-31T07:30:20.000Z</published>
    <updated>2019-03-31T12:10:36.470Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><p>在JVM中，类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。而解析阶段即是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><h2 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h2><p>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>等类型的常量出现。符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。在Java中，一个<code>Java</code>类将会编译成一个<code>class</code>文件。在编译时，<code>Java</code>类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如<code>org.simple.People</code>类引用了<code>org.simple.Language</code>类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号<code>org.simple.Language</code>（假设是这个，当然实际中是由类似于CONSTANT_Class_info的常量来表示的）来表示<code>Language</code>类的地址。各种虚拟机实现的内存布局可能有所不同，但是它们能接受的符号引用都是一致的，因为符号引用的字面量形式明确定义在Java虚拟机规范的Class文件格式中。</p><h2 id="直接引用"><a href="#直接引用" class="headerlink" title="直接引用"></a>直接引用</h2><p>直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://blog.csdn.net/u014656992/article/details/51107127" target="_blank" rel="noopener">https://blog.csdn.net/u014656992/article/details/51107127</a></p></li><li><p>深入理解Java虚拟机第七章</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;在JVM中，类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载7个阶段。而解析阶段
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>常量池和String</title>
    <link href="https://isjinhao.github.io/2019/%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%92%8CString/"/>
    <id>https://isjinhao.github.io/2019/常量池和String/</id>
    <published>2019-03-31T02:19:14.000Z</published>
    <updated>2019-03-31T12:10:36.469Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><p>常量池及String在JDK6、JDK7、JDK8中的实现以及在不同虚拟机中的实现有很大区别，限于笔者水平无法兼顾到太多版本之间的差异，所以下文章中的解释和测试都<strong>仅仅针对于HotSpot虚拟机的JDK8</strong>。</p><h2 id="常量池和运行时常量池"><a href="#常量池和运行时常量池" class="headerlink" title="常量池和运行时常量池"></a>常量池和运行时常量池</h2><p>在刚开始学习Java内存模型的时候笔者掉进入过一个大坑，即认为常量池是运行时常量池的简称。但是实际上这两者是不一样池子，运行时常量池的英文：<code>Runtime Constant Pool</code>，常量池的英文：<code>Constant Pool Table</code>，运行时常量池是方法区的一部分。常量池是Class文件中的一部分，用于存放编译期生成的各种字面量和符号引用。符号引用和直接引用请参考：<a href="https://blog.csdn.net/qq_34402394/article/details/72793119" target="_blank" rel="noopener">https://blog.csdn.net/qq_34402394/article/details/72793119</a></p><h3 id="常量池的内容"><a href="#常量池的内容" class="headerlink" title="常量池的内容"></a>常量池的内容</h3><div align="center"><img src="/2019/常量池和String/常量池里的内容.png" style="width:100%"></div><h3 id="常量池到运行时常量池"><a href="#常量池到运行时常量池" class="headerlink" title="常量池到运行时常量池"></a>常量池到运行时常量池</h3><p>静态常量池存储的是当class文件被java虚拟机加载进来后存放在方法区的一些字面量和符号引用，字面量包括字符串，基本类型的常量，符号引用其实引用的就是常量池里面的字符串，但符号引用不是直接存储字符串，而是存储字符串在常量池里的索引。</p><p>动态常量池是当class文件被加载完成后，java虚拟机会将静态常量池里的内容转移到动态常量池里，在静态常量池的符号引用有一部分是会被转变为直接引用的，比如说类的静态方法或私有方法，实例构造方法，父类方法，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的一些方法是在这个方法被第一次调用的时候才会将符号引用转变为直接引用的。</p><div align="center"><img src="/2019/常量池和String/常量池和运行时常量池.jpg" style="width:80%"></div><h2 id="8种基本类型的包装类和常量池"><a href="#8种基本类型的包装类和常量池" class="headerlink" title="8种基本类型的包装类和常量池"></a>8种基本类型的包装类和常量池</h2><p>Java中基本类型的包装类的大部分都实现了常量池技术，即Byte、Short、Integer、Long、Character、Boolean。他么默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer 缓存代码 ：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">     <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">         <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出TRUE</span></span><br><span class="line"></span><br><span class="line">Integer i1 = <span class="number">400</span>;</span><br><span class="line">Integer i2 = <span class="number">400</span>;</span><br><span class="line">System.out.println(i1==i2);<span class="comment">//输出false</span></span><br></pre></td></tr></table></figure><h3 id="Integer比较更丰富的一个例子"><a href="#Integer比较更丰富的一个例子" class="headerlink" title="Integer比较更丰富的一个例子"></a>Integer比较更丰富的一个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"i1=i2   "</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">"i1=i2+i3   "</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">"i1=i4   "</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">"i4=i5   "</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">"i4=i5+i6   "</span> + (i4 == i5 + i6));   </span><br><span class="line">System.out.println(<span class="string">"40=i5+i6   "</span> + (<span class="number">40</span> == i5 + i6));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    i1=i2   true</span></span><br><span class="line"><span class="comment">    i1=i2+i3   true</span></span><br><span class="line"><span class="comment">    i1=i4   false</span></span><br><span class="line"><span class="comment">    i4=i5   false</span></span><br><span class="line"><span class="comment">    i4=i5+i6   true</span></span><br><span class="line"><span class="comment">    40=i5+i6   true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>解释：</p><p>语句<code>i4 == i5 + i6</code>，因为<code>+</code>这个操作符不适用于<code>Integer</code>对象，首先<code>i5</code>和<code>i6</code>进行自动拆箱操作，进行数值相加，即<code>i4 == 40</code>。然后<code>Integer</code>对象无法与数值进行直接比较，所以<code>i4</code>自动拆箱转为<code>int</code>值<code>40</code>，最终这条语句转为<code>40 == 40</code>进行数值比较。</p><h2 id="String类和常量池"><a href="#String类和常量池" class="headerlink" title="String类和常量池"></a>String类和常量池</h2><h3 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h3><p>英文名字：<code>String Pool</code>，字符串常量池的本质是一个<code>StringTable</code>类（它是一个<code>HashSet</code>）。这个<code>StringTable</code>在每个HotSpot VM的实例只有一份，被所有的类共享。但它只存储运行时常量池里<code>String</code>对象的引用，而不存储<code>String</code>对象的内容，根据这个引用可以得到具体的<code>String</code>对象。注意，字符串常量池是字符串类维护的。字符串常量池只是为了加快<code>String</code>类型常量的检索。</p><h3 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h3><p>String.intern() 是一个 Native 方法，JDK对它的解释是（水平有限，不再翻译）：</p><blockquote><p>A pool of strings, initially empty, is maintained privately by the class String. When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.<br>It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.<br>All literal strings and string-valued constant expressions are interned.</p></blockquote><p>大致意思是：如果字符串常量池中已经有了这个字符串，那么直接返回字符串常量池中的它的引用，如果没有，那就将它的引用保存一份到字符串常量池，然后直接返回这个引用。判断字符串是否相等使用<code>equals</code>方法。</p><h3 id="字面量进入字符串常量池的时机"><a href="#字面量进入字符串常量池的时机" class="headerlink" title="字面量进入字符串常量池的时机"></a>字面量进入字符串常量池的时机</h3><p>就HotSpot VM的实现来说，在加载类的时候，字符串字面量会进入当前类的运行时常量池，不会进入<code>String Pool</code>。加载类的时候，没有解析（解析指符号引用替换为直接引用的过程，参见：）字符串字面量，等到执行ldc指令的时候就会触发这个解析的动作。</p><p>ldc指令的语义是：到当前类的运行时常量池（<code>Runtime Constant Pool</code>）去查找该index对应的项，如果该项尚未resolve则resolve之，并返回resolve后的内容。 在遇到String类型常量时，resolve的过程如果发现<code>StringTable</code>已经有了内容匹配的<code>java.lang.String</code>的引用，则直接返回这个引用，反之，如果<code>StringTable</code>里尚未有内容匹配的<code>String</code>实例的引用，则会在<code>Java</code>堆里创建一个对应内容的<code>String</code>对象，然后在StringTable记录下这个引用，并返回这个引用出去。</p><p>可见，ldc指令是否需要创建新的<code>String</code>实例，全看在第一次执行这一条ldc指令时，StringTable是否已经记录了一个对应内容的<code>String</code>的引用。</p><h3 id="字符串常量池中有哪些字符串的引用"><a href="#字符串常量池中有哪些字符串的引用" class="headerlink" title="字符串常量池中有哪些字符串的引用"></a>字符串常量池中有哪些字符串的引用</h3><ul><li>由字面量创建的String在字符串常量池中都有一份引用</li><li>被<code>new</code>出来的对象调用intern()方法后再字符串常量池中才有一份引用</li></ul><h3 id="获得String对象"><a href="#获得String对象" class="headerlink" title="获得String对象"></a>获得String对象</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str1 = <span class="string">"abcd"</span>;</span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(str1==str2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><ul><li><p>直接使用双引号声明出来的 String 对象会直接存储在常量池中。使用双引号声明时会调用ldc命令，所以其检查的是字符串常量池。</p></li><li><p>对于<code>new String()</code>则会在堆中创建一个String对象，并返回该对象的引用。</p><blockquote><p>Initializes a newly created String object so that it represents the same sequence of characters as the argument; in other words, the newly created string is a copy of the argument string. Unless an explicit copy of original is needed, use of this constructor is unnecessary since Strings are immutable.</p></blockquote></li></ul><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="1"><a href="#1" class="headerlink" title="1"></a>1</h3><ul><li><p>Q：<code>String s = new String(&quot;123&quot;);</code>定义了几个对象。</p></li><li><p>A：若常量池中已经存在”123”，则直接引用，也就是此时只会创建一个对象，如果常量池中不存”123”，则先创建后将在堆中创建”123”的一份拷贝，并把这个拷贝的引用返回。此时字符串常量池中有”123“的引用。</p></li></ul><h3 id="2"><a href="#2" class="headerlink" title="2"></a>2</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Hollis"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"Hollis"</span>);</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"Hollis"</span>).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><div align="center"><img src="/2019/常量池和String/例2.jpg" style="width:80%"></div><h3 id="3"><a href="#3" class="headerlink" title="3"></a>3</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line">String s2 = <span class="string">"1"</span>;</span><br><span class="line">s.intern();</span><br><span class="line">System.out.println(s == s2);<span class="comment">//false</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"2"</span>);</span><br><span class="line">s3.intern();</span><br><span class="line">String s4 = <span class="string">"12"</span>;</span><br><span class="line">System.out.println(s3 == s4);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1：常量池中有&quot;1&quot;，堆中有字符串&quot;1&quot;，字符串常量池中是常量池中&quot;1&quot;的引用，s是堆中的引用</span><br><span class="line">2：在字符串常量池中检索，有&quot;1&quot;，则得到常量池中&quot;1&quot;的引用</span><br><span class="line">5：常量池中有&quot;1&quot;，&quot;2&quot;。new String(&quot;1&quot;) + new String(&quot;2&quot;);的底层是使用StringBuffer的append方法将&quot;2&quot;和&quot;2&quot;拼接在一块，然后调用toString方法new出“22”；所以此时的“22”字符串是创建在堆区的；</span><br><span class="line">6：在字符串常量池中检索，没有&quot;22&quot;，把堆中该对象的引用放在字符串常量池中</span><br><span class="line">7：检查字符串常量池，有&quot;2&quot;的引用，指向堆</span><br></pre></td></tr></table></figure><h3 id="4"><a href="#4" class="headerlink" title="4"></a>4</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;  </span><br><span class="line">String s2=s1.intern();  </span><br><span class="line">System.out.println(s1==s1.intern());    <span class="comment">//true </span></span><br><span class="line">System.out.println(s2==s1.intern());</span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：堆中有&quot;xyz&quot;，常量池中有&quot;xy&quot;，&quot;z&quot;</span><br><span class="line">2：把堆中的&quot;xyz&quot;的引用存在字符串常量池中。</span><br><span class="line">3：都指向堆中</span><br><span class="line">4：都指向堆中</span><br></pre></td></tr></table></figure><h3 id="5"><a href="#5" class="headerlink" title="5"></a>5</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">"xyz"</span>) ;  </span><br><span class="line">String s2=s1.intern();  </span><br><span class="line">System.out.println(s1==s1.intern());  <span class="comment">//false</span></span><br><span class="line">System.out.println(s2==s1.intern());  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：常量池中有&quot;xyz&quot;，堆中有&quot;xyz&quot;</span><br><span class="line">2：s2指向常量池中的&quot;xyz&quot;</span><br><span class="line">3：s1.intern()指向常量池，s1指向堆</span><br><span class="line">4：s2指向堆</span><br></pre></td></tr></table></figure><h3 id="6"><a href="#6" class="headerlink" title="6"></a>6</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"xy"</span> + <span class="string">"z"</span>;</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println( s1==s1.intern() );  <span class="comment">//true</span></span><br><span class="line">System.out.println( s2==s1.intern() );  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1：编译期可以确定s1是&quot;xyz&quot;，所以编译器会优化。在常量池中有&quot;xyz&quot;</span><br><span class="line">2：s2指向常量池中的&quot;xyz&quot;</span><br><span class="line">3：都指向常量池中的&quot;xyz&quot;</span><br><span class="line">4：都指向常量池中的&quot;xyz&quot;</span><br></pre></td></tr></table></figure><h3 id="7"><a href="#7" class="headerlink" title="7"></a>7</h3><p>Q：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String s1=<span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;  </span><br><span class="line">String s3 = <span class="string">"xyz"</span>;</span><br><span class="line">String s2=s1.intern();  </span><br><span class="line">System.out.println(s1 == s3);<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false</span></span><br><span class="line">System.out.println(s2 == s3);<span class="comment">//true</span></span><br><span class="line">System.out.println(s1==s1.intern());<span class="comment">//false</span></span><br><span class="line">System.out.println(s2==s1.intern()); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>A：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1：堆中有&quot;xyz&quot;，常量池中有&quot;xy&quot;和&quot;z&quot;，s1指向堆中的&quot;xyz&quot;</span><br><span class="line">2：检索字符串常量池，没有&quot;xyz&quot;，在常量池中创建&quot;xyz&quot;，s3指向常量池中的&quot;xyz&quot;</span><br><span class="line">3：字符串常量池有&quot;xyz&quot;的引用，且指向常量池，s2指向常量池中&quot;xyz&quot;</span><br><span class="line">4：s1指向堆中的&quot;xyz&quot;，s2指向常量池中&quot;xyz&quot;</span><br><span class="line">5：s1指向堆中的&quot;xyz&quot;，s3指向常量池中的&quot;xyz&quot;</span><br><span class="line">6：都指向常量池中&quot;xyz&quot;</span><br><span class="line">7：s1指向堆中的&quot;xyz&quot;，s1==s1.intern指向常量池中的&quot;xyz&quot;</span><br><span class="line">8：s2指向常量池中&quot;xyz&quot;，s1==s1.intern指向常量池中的&quot;xyz&quot;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/wangbiao007/article/details/78545189" target="_blank" rel="noopener">https://blog.csdn.net/wangbiao007/article/details/78545189</a></li><li><a href="https://blog.csdn.net/Mypromise_TFS/article/details/81504137" target="_blank" rel="noopener">https://blog.csdn.net/Mypromise_TFS/article/details/81504137</a></li><li><a href="https://www.zhihu.com/question/55994121" target="_blank" rel="noopener">https://www.zhihu.com/question/55994121</a></li><li>深入理解JVM第二版</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;声明&quot;&gt;&lt;a href=&quot;#声明&quot; class=&quot;headerlink&quot; title=&quot;声明&quot;&gt;&lt;/a&gt;声明&lt;/h2&gt;&lt;p&gt;常量池及S
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="https://isjinhao.github.io/2019/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://isjinhao.github.io/2019/Java内存模型/</id>
    <published>2019-03-30T07:48:32.000Z</published>
    <updated>2019-03-31T12:10:36.472Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM则是JRE中的核心组成部分，承担分析和执行Java字节码的工作。在Java历史上有很多发行的Java虚拟机，但目前一般都是<code>HotSpot</code>。查看本机JVM：<code>java -version</code></p><div align="center"><img src="/2019/Java内存模型/查看JVM.jpg" style="width:80%"></div><h3 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h3><p>Java虚拟机在执行Java程序的时候会把它所管理的内存区域划分为若干个不同的数据区域。根据JVM规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。</p><h2 id="运行时数据区划分"><a href="#运行时数据区划分" class="headerlink" title="运行时数据区划分"></a>运行时数据区划分</h2><h3 id="JDK6"><a href="#JDK6" class="headerlink" title="JDK6"></a>JDK6</h3><div align="center"><img src="/2019/Java内存模型/1.6内存模型.jpg" style="width:60%"></div><h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><div align="center"><img src="/2019/Java内存模型/1.8内存模型.jpg" style="width:60%"></div><h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p><strong>注意：程序计数器是唯一一个不会出现OutOfMemoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p><strong>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息）</p><p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向一条字节码指令的地址）。</p><p><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong></p><ul><li><p><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</p></li><li><p><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</p></li></ul><p>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><p><strong>扩展：那么方法/函数如何调用？</strong></p><p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>Java方法有两种返回方式：</p><ul><li><p>return 语句。</p></li><li><p>抛出异常。</p></li></ul><p>不管哪种返回方式都会导致栈帧被弹出。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p><h3 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h3><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代。再细致一点有：<code>Eden空间</code>、<code>From Survivor</code>、<code>To Survivor</code>空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/iaIdQfEric9TwVibBF785ic5RU2iafKlnVEsC7XwTj6XECpS7ibPzdgmc3pqrvwf99HymgMU9xJnAMfsicDsuY1XxVlug/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img"></p><p>上图所示的eden区、s0区、s1区都属于新生代，tentired区属于老年代。大部分情况，对象都会首先在Eden区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入s0或者s1，并且对象的年龄还会加 1（<code>Eden区-&gt;Survivor</code> 区后对象的初始年龄变为1），当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p><strong>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</strong></p><p>HotSpot 虚拟机中方法区也常被称为 <strong>“永久代”</strong>，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p><p><strong>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</strong></p><p>JDK 1.8 的时候，方法区被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p>我们可以使用参数： <code>-XX:MetaspaceSize</code> 来指定元数据区的大小。与永久区很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p><ul><li>字面量就是指这个量本身，比如字面量3。也就是指3. 再比如 string类型的字面量”ABC”, 这个”ABC” 通过字来描述。 可以理解成一眼就能知道的量。</li></ul><p>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><p><strong>JDK1.8及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。</strong></p><p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h4 id="元空间"><a href="#元空间" class="headerlink" title="元空间"></a>元空间</h4><p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</p><h4 id="为什么永久代向元空间的转换"><a href="#为什么永久代向元空间的转换" class="headerlink" title="为什么永久代向元空间的转换"></a>为什么永久代向元空间的转换</h4><ul><li><p>字符串存在永久代中，容易出现性能问题和内存溢出。</p></li><li><p>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p></li><li><p>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p></li></ul><h2 id="类的各个部分分别在哪个位置"><a href="#类的各个部分分别在哪个位置" class="headerlink" title="类的各个部分分别在哪个位置"></a>类的各个部分分别在哪个位置</h2><ul><li>字节码：方法区</li><li>字节码对象：堆</li><li>普通对象：大部分存在于堆。更多参考：<a href="https://blog.csdn.net/rickiyeat/article/details/76802085" target="_blank" rel="noopener">https://blog.csdn.net/rickiyeat/article/details/76802085</a></li><li>对象的属性：大部分存在于堆</li><li>static属性：常量池</li><li>方法：方法区</li><li>方法中的局部变量：Java虚拟机栈</li><li>String对象：堆或常量池</li><li>final属性：常量池</li></ul><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><div align="center"><img src="/2019/Java内存模型/对象的创建.jpg" style="width:80%"></div><ul><li><p><strong>类加载检查：</strong> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p></li><li><p><strong>分配内存：</strong> 在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p></li></ul><h3 id="内存分配的两种方式"><a href="#内存分配的两种方式" class="headerlink" title="内存分配的两种方式"></a><strong>内存分配的两种方式</strong></h3><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的。详细可参考：深入理解Java虚拟机第二版第三章。</p><ul><li>指针碰撞：假设JAVA堆中的内存时绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式成为“指针碰撞”。</li><li>空闲链表：如果JAVA堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式成为“空闲列表”。</li><li><strong>初始化零值：</strong> 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li><strong>设置对象头：</strong> 初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</li><li><strong>执行 init 方法：</strong> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</li></ul><h3 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a><strong>内存分配并发问题</strong></h3><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，否则比如当虚拟机正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存就会引发严重的问题。通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在Eden区分配一块儿内存，称为本地线程分配缓存（Thread Local Allocation Buffer，TLAB），JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。</li></ul><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为3块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的自身运行时数据</strong>（哈希码、GC分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种：</p><ul><li><strong>句柄：</strong> 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li></ul><div align="center"><img src="/2019/Java内存模型/句柄.jpg" style="width:80%"></div><ul><li><strong>直接指针</strong>：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</li></ul><div align="center"><img src="/2019/Java内存模型/指针.jpg" style="width:80%"></div><p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485068&amp;idx=1&amp;sn=c37267fe59978dbfcd6a9a54eee1c502&amp;chksm=cea24947f9d5c051008233a6a938e802b710ccf919f4215f84dcc0bf1fdad7d0101d37497d33&amp;xtrack=1&amp;scene=0&amp;subscene=131&amp;clicktime=1553930626&amp;ascene=7&amp;devicetype=android-27&amp;version=2700033c&amp;nettype=cmnet&amp;abtest_cookie=BQABAAgACgALABIAEwAGAJ%2BGHgAjlx4AVpkeAM%2BZHgDamR4A3JkeAAAA&amp;lang=zh_CN&amp;pass_ticket=G969oFWgvfNjcImZ43XVMVLnTmWNWI4qDunqFFIS7NA%3D&amp;wx_header=1" target="_blank" rel="noopener">JavaGuide</a></p></li><li><p>深入理解Java虚拟机</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h2&gt;&lt;p&gt;J
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>html和css基础</title>
    <link href="https://isjinhao.github.io/2019/html%E5%92%8Ccss%E5%9F%BA%E7%A1%80/"/>
    <id>https://isjinhao.github.io/2019/html和css基础/</id>
    <published>2019-03-30T03:17:38.000Z</published>
    <updated>2019-03-31T12:10:36.468Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">target</span>=<span class="string">"_self"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="target的属性值"><a href="#target的属性值" class="headerlink" title="target的属性值"></a>target的属性值</h3><ul><li><code>_self</code>：在本窗口中打开目标页面。默认属性值。</li><li><code>_blank</code>：在新的浏览器窗口打开目标页面。</li><li><code>_parent</code>：这个目标使得文档载入父窗口或者包含来超链接引用的框架的框架集。如果这个引用是在窗口或者在顶级框架中，那么它与目标<code>_self</code>等效，即如果不使用<code>frameset</code>，就和<code>_self</code>等效。</li><li><code>_top</code>：这个目标使得文档载入包含这个超链接的窗口，用<code>_top</code>目标将会清除所有被包含的框架并将文档载入整个浏览器窗口。</li><li><code>其他值</code>：给一堆超链接以相同的target值，这种方式可以使得一组超链接在同一窗口打开，即<strong>通过单击一个窗口中的不同链接控制另一窗口内容变化</strong>。首先，浏览器会找与target值相符的框架或者窗口中的文档，有则在其中显示文档。如果不存在，浏览器打开一个新窗口，给其指定一个标识为target值，之后只要该窗口不关闭，其它超链接就可以指向这个新窗口。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.google.com.hk"</span> <span class="attr">target</span>=<span class="string">"HelloWorld"</span>&gt;</span>google<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://cn.bing.com"</span> <span class="attr">target</span>=<span class="string">"HelloWorld"</span>&gt;</span>必应<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span> <span class="attr">target</span>=<span class="string">"HelloWorld"</span>&gt;</span>百度<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.soso.com"</span> <span class="attr">target</span>=<span class="string">"HelloWorld"</span>&gt;</span>搜搜<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="锚链接"><a href="#锚链接" class="headerlink" title="锚链接"></a>锚链接</h3><p>跳转至网页的指定部分。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">"tar"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1000行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#tar"</span>&gt;</span>锚链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="链接邮件"><a href="#链接邮件" class="headerlink" title="链接邮件"></a>链接邮件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"mailto:xxx@yyy.zzz"</span>&gt;</span>发送邮件<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="水平线标签"><a href="#水平线标签" class="headerlink" title="水平线标签"></a>水平线标签</h2><p><code>&lt;hr /&gt;</code></p><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> <span class="attr">border</span>=<span class="string">"xxx"</span> <span class="attr">alt</span>=<span class="string">"yyy"</span> <span class="attr">title</span>=<span class="string">"zzz"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h3 id="图片分类"><a href="#图片分类" class="headerlink" title="图片分类"></a>图片分类</h3><ul><li><code>bmp</code>：<code>windows</code>系统下的标准位图（像素点构成的图）格式。文件较大，不建议大量使用。</li><li><code>gif</code>：动图。但是只支持256种色彩，不适合保存图片。</li><li><code>jpeg</code>：又称<code>jpg</code>，有损压缩的图片。<ul><li>有损压缩：只对图像或声波中的某些频率成分不敏感的特性，允许压缩过程中损失一定的信息；虽然不能完全恢复原始数据，但是所损失的部分对理解原始图像的影响缩小，却换来了大得多的压缩比。</li></ul></li><li><code>png</code>：无损压缩图片。</li></ul><h3 id="alt"><a href="#alt" class="headerlink" title="alt"></a><code>alt</code></h3><p>图片无法加载时，用于替换图片内容的文字。</p><h3 id="title"><a href="#title" class="headerlink" title="title"></a><code>title</code></h3><p>鼠标悬停时显示的文字。</p><h3 id="图片热点"><a href="#图片热点" class="headerlink" title="图片热点"></a>图片热点</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span> =<span class="string">"planets.gif"</span> <span class="attr">alt</span>=<span class="string">"Planets"</span> <span class="attr">usemap</span> =<span class="string">"#planetmap"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">"planetmap"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"rect"</span> <span class="attr">coords</span>=<span class="string">"0,0,110,260"</span> <span class="attr">href</span>=<span class="string">"sun.htm"</span> <span class="attr">alt</span>=<span class="string">"Sun"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">"129,161,10"</span> <span class="attr">href</span>=<span class="string">"mercur.htm"</span> <span class="attr">alt</span>=<span class="string">"Mercury"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">"circle"</span> <span class="attr">coords</span>=<span class="string">"180,139,14"</span> <span class="attr">href</span>=<span class="string">"venus.htm"</span> <span class="attr">alt</span>=<span class="string">"Venus"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>参考：<a href="http://www.w3school.com.cn/tags/att_area_coords.asp" target="_blank" rel="noopener">http://www.w3school.com.cn/tags/att_area_coords.asp</a></p><h2 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h2><div align="center"><img src="/2019/html和css基础/tab.png" style="width:80%"></div><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;超链接&quot;&gt;&lt;a href=&quot;#超链接&quot; class=&quot;headerlink&quot; title=&quot;超链接&quot;&gt;&lt;/a&gt;超链接&lt;/h2&gt;&lt;fig
      
    
    </summary>
    
      <category term="前端" scheme="https://isjinhao.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="前端" scheme="https://isjinhao.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="HTML" scheme="https://isjinhao.github.io/tags/HTML/"/>
    
      <category term="CSS" scheme="https://isjinhao.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>基于winpcap的cpp控制台网络协议分析</title>
    <link href="https://isjinhao.github.io/2019/%E5%9F%BA%E4%BA%8Ewinpcap%E7%9A%84cpp%E6%8E%A7%E5%88%B6%E5%8F%B0%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%88%86%E6%9E%90/"/>
    <id>https://isjinhao.github.io/2019/基于winpcap的cpp控制台网络协议分析/</id>
    <published>2019-03-28T06:59:27.000Z</published>
    <updated>2019-03-30T01:31:08.780Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><h3 id="软件版本"><a href="#软件版本" class="headerlink" title="软件版本"></a>软件版本</h3><ul><li>winpcap4.1.3</li><li>vs2015</li></ul><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><ul><li><code>新建项目-&gt;Visual C++项目-&gt;Win32控制台项目</code>，在<code>Win32应用程序向导</code>窗口中的<code>应用程序设置-&gt;附加选项</code>选中<code>空项目</code>。</li><li>将<code>WinPcap</code>开发包中的Include和Lib两个文件夹复制到新建项目所在文件夹下。</li><li>点击项目，右击，然后点击属性<ul><li><code>C/C++-&gt;常规-&gt;附加包含目录</code>：如 ..\include</li><li><code>链接器-&gt;常规-&gt;附加库目录</code>：如 ..\lib</li><li><code>链接器-&gt;输入-&gt;附加依赖项</code>：wpcap.lib（winpcap的包），ws2_32.lib（windows的socket）</li></ul></li></ul><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pcap.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">eth_address</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_char byte1;</span><br><span class="line">u_char byte2;</span><br><span class="line">u_char byte3;</span><br><span class="line">u_char byte4;</span><br><span class="line">u_char byte5;</span><br><span class="line">u_char byte6;</span><br><span class="line">&#125;eth_address;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 4 bytes IP address */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_address</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_char byte1;</span><br><span class="line">u_char byte2;</span><br><span class="line">u_char byte3;</span><br><span class="line">u_char byte4;</span><br><span class="line">&#125;ip_address;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* IPv4 header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ip_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_charver_ihl;<span class="comment">// Version (4 bits) + Internet header length (4 bits)</span></span><br><span class="line">u_chartos;<span class="comment">// Type of service </span></span><br><span class="line">u_short tlen;<span class="comment">// Total length </span></span><br><span class="line">u_short identification; <span class="comment">// Identification</span></span><br><span class="line">u_short flags_fo;<span class="comment">// Flags (3 bits) + Fragment offset (13 bits)</span></span><br><span class="line">u_charttl;<span class="comment">// Time to live</span></span><br><span class="line">u_charproto;<span class="comment">// Protocol</span></span><br><span class="line">u_short crc;<span class="comment">// Header checksum</span></span><br><span class="line">ip_addresssaddr;<span class="comment">// Source address</span></span><br><span class="line">ip_addressdaddr;<span class="comment">// Destination address</span></span><br><span class="line">u_intop_pad;<span class="comment">// Option + Padding</span></span><br><span class="line">&#125;ip_header;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* UDP header*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">udp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_short sport;<span class="comment">// Source port</span></span><br><span class="line">u_short dport;<span class="comment">// Destination port</span></span><br><span class="line">u_short len;<span class="comment">// Datagram length</span></span><br><span class="line">u_short crc;<span class="comment">// Checksum</span></span><br><span class="line">&#125;udp_header;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* MAC header*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">eth_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">eth_address daddr;</span><br><span class="line">eth_address saddr;</span><br><span class="line">u_short type;</span><br><span class="line">&#125;eth_header;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">arp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_short hardtype;<span class="comment">//硬件类型字段</span></span><br><span class="line">u_short prototype;<span class="comment">//协议类型字段</span></span><br><span class="line">u_char htlen;<span class="comment">//硬件地址的长度,以字节为单位.对于以太网上IP地址的ARP请求或应答来说,它们的值为6</span></span><br><span class="line">u_char ptlen;<span class="comment">//协议地址的长度,以字节为单位.对于以太网上IP地址的ARP请求或应答来说,它们的值为4</span></span><br><span class="line">u_short op;<span class="comment">//操作字段</span></span><br><span class="line">eth_address arp_esa;<span class="comment">//发送端MAC地址</span></span><br><span class="line">ip_address arp_isa;<span class="comment">//发送端IP地址</span></span><br><span class="line">eth_address arp_eda;<span class="comment">//目的端MAC地址</span></span><br><span class="line">ip_address arp_ida;<span class="comment">//目的端IP地址</span></span><br><span class="line">&#125;arp_header;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">icmp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_char type;<span class="comment">//ICMP报文类型</span></span><br><span class="line">u_char code;<span class="comment">//代码</span></span><br><span class="line">u_short checksum;<span class="comment">//校验和</span></span><br><span class="line">u_short identifier;<span class="comment">//标识符</span></span><br><span class="line">u_short sequence_number;<span class="comment">//序列号</span></span><br><span class="line">&#125;icmp_header;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* TCP header */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcp_header</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">u_shortsport;<span class="comment">//源端口</span></span><br><span class="line">u_short dport;<span class="comment">//目的端口</span></span><br><span class="line">u_long  sequence_number;<span class="comment">//序号（4字节ntohl）  </span></span><br><span class="line">u_long  acknowlegement_number;<span class="comment">//确认号</span></span><br><span class="line">u_short hlen_bl_flags;<span class="comment">//数据偏移+保留+控制位</span></span><br><span class="line">u_short window_size;<span class="comment">//窗口（发送方自己的接收窗口）</span></span><br><span class="line">u_short checksum;<span class="comment">//检验和（首部+数据）</span></span><br><span class="line">u_short urg;<span class="comment">//紧急指针</span></span><br><span class="line">u_long  option;<span class="comment">//可选+填充</span></span><br><span class="line">&#125;tcp_header;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dns_packet</span> //报文<span class="title">head</span>+<span class="title">data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    u_short id;<span class="comment">//每一个占2个字节，共12个字节</span></span><br><span class="line">    u_short flags;<span class="comment">//标志第一个为0代表查询报文</span></span><br><span class="line">    u_short ques;</span><br><span class="line">    u_short answer;</span><br><span class="line">    u_short author;</span><br><span class="line">    u_short addition;</span><br><span class="line">    u_char dns_data;<span class="comment">//查询问题部分</span></span><br><span class="line">&#125;dns_packet;</span><br></pre></td></tr></table></figure><h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _MSC_VER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"pcap.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"headers.c"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DNSPORT 53</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//输出基本信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintBaseInfo</span><span class="params">(<span class="keyword">const</span> struct pcap_pkthdr *header)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> *<span class="title">ltime</span>;</span></span><br><span class="line"><span class="keyword">char</span> timestr[<span class="number">16</span>];</span><br><span class="line"><span class="keyword">time_t</span> local_tv_sec;</span><br><span class="line"></span><br><span class="line">local_tv_sec = header-&gt;ts.tv_sec;</span><br><span class="line">ltime=localtime(&amp;local_tv_sec);</span><br><span class="line">strftime(timestr, <span class="keyword">sizeof</span> timestr, <span class="string">"%H:%M:%S"</span>, ltime);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n\n\n监听到Mac帧的时间：%s   MAC帧长度:%d Byte(s)\n"</span>, timestr, header-&gt;len * <span class="number">4</span>);  <span class="comment">/* 以四字节为单位 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出硬件地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintEthAddress</span><span class="params">(eth_address eth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%02X:%02X:%02X:%02X:%02X:%02X"</span>, </span><br><span class="line">eth.byte1,</span><br><span class="line">eth.byte2,</span><br><span class="line">eth.byte3,</span><br><span class="line">eth.byte4,</span><br><span class="line">eth.byte5,</span><br><span class="line">eth.byte6</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出IP地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintIPAddress</span><span class="params">(ip_address ia)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d.%d.%d.%d"</span>, </span><br><span class="line">ia.byte1,</span><br><span class="line">ia.byte2,</span><br><span class="line">ia.byte3,</span><br><span class="line">ia.byte4</span><br><span class="line">);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出网络层协议类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintNetType</span><span class="params">(u_short type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"网络层协议： "</span>);</span><br><span class="line"><span class="keyword">if</span>(type==<span class="number">0x0800</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"IP协议"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">0x0806</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ARP协议"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">0x8035</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"RARP协议"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"接收到非本程序能处理的网络层协议类型！"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">分析Mac帧：</span></span><br><span class="line"><span class="comment">输出：</span></span><br><span class="line"><span class="comment">网络层协议类型：源MAC -&gt; 目的MAC</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">返回：</span></span><br><span class="line"><span class="comment">网络层协议类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function">u_short <span class="title">handleMac</span><span class="params">(eth_header *eth)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short type=ntohs(eth-&gt;type);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Mac地址： "</span>);</span><br><span class="line">myPrintEthAddress(eth-&gt;saddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"-&gt;"</span>);</span><br><span class="line">myPrintEthAddress(eth-&gt;daddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n\n"</span>);</span><br><span class="line"><span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleARPAndRARP</span><span class="params">(arp_header *ah)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short arp_ht;<span class="comment">//硬件地址的类型.它的值为1即表示以太网地址</span></span><br><span class="line">u_short arp_pt;<span class="comment">//要映射的协议地址类型.它的值为0x0800，即表示IP地址</span></span><br><span class="line">u_short arp_op;<span class="comment">//四种操作类型,它们是ARP请求(值为1)、ARP应答(值为2)、RARP请求(值为3)和RARP应答(值为4)</span></span><br><span class="line">arp_ht=ntohs(ah-&gt;hardtype);<span class="comment">//硬件地址的类型.它的值为1即表示以太网地址</span></span><br><span class="line">arp_pt=ntohs(ah-&gt;prototype);<span class="comment">//要映射的协议地址类型.它的值为0x0800，即表示IP地址</span></span><br><span class="line">arp_op=ntohs(ah-&gt;op);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"硬件地址类型为：%d\t\t\t"</span>,arp_ht);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"协议地址类型为：0x%04X\n"</span>,arp_pt);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"硬件地址长度为：%d\t\t\t"</span>,ah-&gt;htlen);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"协议地址长度为：%d\n"</span>,ah-&gt;ptlen);</span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：ARP请求报文。\n本机Mac地址："</span>);</span><br><span class="line">myPrintEthAddress(ah-&gt;arp_esa);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t正在请求"</span>);</span><br><span class="line">myPrintIPAddress(ah-&gt;arp_ida);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"的Mac地址\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">2</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：ARP应答报文。\n应答方的Mac地址："</span>);</span><br><span class="line">myPrintEthAddress(ah-&gt;arp_eda);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\t应答方的IP地址"</span>);</span><br><span class="line">myPrintIPAddress(ah-&gt;arp_ida);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">3</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：RARP请求报文\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (arp_op == <span class="number">4</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"操作类型为：RARP应答报文\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> all_ip_len = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">u_short <span class="title">handleIP</span><span class="params">(ip_header *ih)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_int ip_ver;<span class="comment">//版本</span></span><br><span class="line">u_int ip_len;<span class="comment">//首部长度</span></span><br><span class="line">u_short ip_tlen;    <span class="comment">//总长度</span></span><br><span class="line">u_short ip_ident;<span class="comment">//标识</span></span><br><span class="line">u_short ip_flag_fo; <span class="comment">//标志和片偏移</span></span><br><span class="line">u_int ip_flag;<span class="comment">//标志（3位，值为2还有分片且允许分片,1不能分片,0没有分片且允许分片）</span></span><br><span class="line">u_int ip_fo;<span class="comment">//片偏移</span></span><br><span class="line">u_short ip_type;<span class="comment">//协议</span></span><br><span class="line">u_short ip_crc;<span class="comment">//首部检验和</span></span><br><span class="line">u_long ip_op_pad;<span class="comment">//可选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* retireve the position of the ip header */</span><span class="comment">//检索IP首部的位置</span></span><br><span class="line">ip_ver = (ih-&gt;ver_ihl &gt;&gt; <span class="number">4</span>);<span class="comment">//版本</span></span><br><span class="line">ip_len = (ih-&gt;ver_ihl &amp; <span class="number">0xf</span>) * <span class="number">4</span>;<span class="comment">//首部长度，与运算，可以只取ip头部的版本长度字段的后4位</span></span><br><span class="line">ip_tlen=ntohs(ih-&gt;tlen);<span class="comment">//总长度</span></span><br><span class="line">ip_ident=ntohs(ih-&gt;identification);<span class="comment">//标识</span></span><br><span class="line">ip_flag_fo = ntohs(ih-&gt;flags_fo);<span class="comment">//2字节存放，会有字节序问题</span></span><br><span class="line">ip_flag = (ip_flag_fo &gt;&gt; <span class="number">13</span>);<span class="comment">//标志</span></span><br><span class="line">ip_fo = (ip_flag_fo &amp; <span class="number">0x1fff</span>);<span class="comment">//片偏移</span></span><br><span class="line">ip_type = ih-&gt;proto;<span class="comment">//上层协议类型</span></span><br><span class="line">ip_crc = ntohs(ih-&gt;crc);<span class="comment">//首部校验和</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印IP数据报首部*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"版本：%d\t\t\t"</span>,ip_ver);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部长度：%d\n"</span>,ip_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"区分服务：%d\t\t"</span>, ih-&gt;tos);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"总长度：%d\n"</span>, ip_tlen);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标识：%d\t\t"</span>, ip_ident);</span><br><span class="line"><span class="keyword">if</span> (ip_flag == <span class="number">2</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：DF=1（不能分片），MF=0（没有后续分片）\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (ip_flag == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：DF=0（允许分片），MF=1（还有后续分片）\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (ip_flag == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：DF=0（允许分片），MF=0（没有后续分片）\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"片偏移：%d\t\t"</span>,ip_fo*<span class="number">8</span>);<span class="comment">//片偏移以8字节为单位</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"生存时间：%d\n"</span>,ih-&gt;ttl);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"协议：%d\t\t\t"</span>,ih-&gt;proto);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部校验和：%d\n"</span>,ip_crc);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"IP地址：  "</span>);</span><br><span class="line"></span><br><span class="line">myPrintIPAddress(ih-&gt;saddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" -&gt; "</span>);</span><br><span class="line">myPrintIPAddress(ih-&gt;daddr);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (ip_len == <span class="number">20</span>)<span class="comment">//IP首部长度&gt;20时才有</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部长度为20，IP报文首部没有可选字段。\n"</span>);</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">ip_op_pad = ntohl(ih-&gt;op_pad);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"可选自段内容为：%u\n"</span>, ip_op_pad);</span><br><span class="line">&#125;</span><br><span class="line">all_ip_len = ip_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> ip_type;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleICMP</span><span class="params">(icmp_header *ich)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short icmp_checksum;<span class="comment">//校验和</span></span><br><span class="line">u_short icmp_ident;<span class="comment">//标识符</span></span><br><span class="line">u_short icmp_seqnum;<span class="comment">//序列号</span></span><br><span class="line"></span><br><span class="line">icmp_checksum = ntohs(ich-&gt;checksum);<span class="comment">//校验和</span></span><br><span class="line">icmp_ident = ntohs(ich-&gt;identifier);<span class="comment">//标识符</span></span><br><span class="line">icmp_seqnum = ntohs(ich-&gt;sequence_number);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n运输层协议：  ICMP协议\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印ICMP报文首部*/</span></span><br><span class="line"><span class="keyword">if</span> (ich-&gt;type == <span class="number">0</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ICMP类型：回显应答\n"</span>);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ich-&gt;type == <span class="number">8</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ICMP类型：回显请求\n"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"ICMP类型：其他\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"代码：%d\t\t"</span>,ich-&gt;code);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"校验和：%d\n"</span>,icmp_checksum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标识符：%d\t\t"</span>,icmp_ident);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"序列号：%d\n"</span>,icmp_seqnum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u_int udp_len;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handleUDP</span><span class="params">(udp_header *uh)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_short sport, dport;<span class="comment">//端口</span></span><br><span class="line">u_short uh_len; <span class="comment">//长度</span></span><br><span class="line">u_short uh_crc; <span class="comment">//校验和</span></span><br><span class="line"></span><br><span class="line">sport = ntohs( uh-&gt;sport );<span class="comment">//源端口</span></span><br><span class="line">dport = ntohs( uh-&gt;dport );<span class="comment">//目的端口</span></span><br><span class="line">uh_len = ntohs(uh-&gt;len);<span class="comment">//长度</span></span><br><span class="line">uh_crc = ntohs(uh-&gt;crc);<span class="comment">//校验和</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n运输层协议：  UDP协议\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"端口号：%d -&gt; %d\n"</span>, sport, dport);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"长度：%d\t\t"</span>, uh_len);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"校验和：%d\n"</span>, uh_crc);</span><br><span class="line"></span><br><span class="line">udp_len = uh_len;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(sport == DNSPORT || dport == DNSPORT)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleTCP</span><span class="params">(tcp_header *th)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u_shorttcp_sport;<span class="comment">//源端口</span></span><br><span class="line">u_short tcp_dport;<span class="comment">//目的端口</span></span><br><span class="line">u_long  tcp_seqnum;<span class="comment">//序号（4字节ntohl）  </span></span><br><span class="line">u_long  tcp_acknum;<span class="comment">//确认号</span></span><br><span class="line">u_short tcp_hlen_bl_flags;<span class="comment">//数据偏移+保留+控制位</span></span><br><span class="line">u_short  tcp_hlen;</span><br><span class="line">u_short  tcp_bl;</span><br><span class="line">u_short  tcp_flags_urg;<span class="comment">//紧急1有效 </span></span><br><span class="line">u_short  tcp_flags_ack;<span class="comment">//确认=1时，确认号有效</span></span><br><span class="line">u_short  tcp_flags_psh;<span class="comment">//推送1有效，可以不用填满缓存就发报</span></span><br><span class="line">u_short  tcp_flags_rst;<span class="comment">//复位1有效，重新建立连接</span></span><br><span class="line">u_short  tcp_flags_syn;<span class="comment">//同步syn=1,ack=0时，表明这是一个连接请求报文；syn=1,ack=1,接受连接请求</span></span><br><span class="line">u_short  tcp_flags_fin;<span class="comment">//释放连接=1时，表示数据报</span></span><br><span class="line">u_short tcp_window_size;<span class="comment">//窗口（发送方自己的接收窗口）</span></span><br><span class="line">u_short tcp_checksum;<span class="comment">//检验和（首部+数据）</span></span><br><span class="line">u_short tcp_urg;<span class="comment">//紧急指针</span></span><br><span class="line">u_long tcp_option;</span><br><span class="line"></span><br><span class="line">tcp_sport=ntohs(th-&gt;sport);<span class="comment">//源端口</span></span><br><span class="line">tcp_dport=ntohs(th-&gt;dport);<span class="comment">//目的端口</span></span><br><span class="line">tcp_seqnum=ntohl(th-&gt;sequence_number);<span class="comment">//序号（4字节ntohl）  </span></span><br><span class="line">tcp_acknum=ntohl(th-&gt;acknowlegement_number);<span class="comment">//确认号</span></span><br><span class="line">tcp_hlen_bl_flags=ntohs(th-&gt;hlen_bl_flags);<span class="comment">//数据偏移4+保留6+控制位6</span></span><br><span class="line">tcp_hlen=(tcp_hlen_bl_flags &gt;&gt; <span class="number">12</span>)*<span class="number">4</span>;<span class="comment">//以4字节为单位</span></span><br><span class="line">tcp_bl=(tcp_hlen_bl_flags &amp; <span class="number">0x0fc0</span>);<span class="comment">//保留</span></span><br><span class="line">tcp_flags_urg=(tcp_hlen_bl_flags &amp; <span class="number">0x0020</span>);<span class="comment">//紧急1有效                                                    ----- </span></span><br><span class="line">tcp_flags_ack=(tcp_hlen_bl_flags &amp; <span class="number">0x0010</span>);<span class="comment">//确认=1时，确认号有效</span></span><br><span class="line">tcp_flags_psh=(tcp_hlen_bl_flags &amp; <span class="number">0x0008</span>);<span class="comment">//推送1有效，可以不用填满缓存就发报</span></span><br><span class="line">tcp_flags_rst=(tcp_hlen_bl_flags &amp; <span class="number">0x0004</span>);<span class="comment">//复位1有效，重新建立连接</span></span><br><span class="line">tcp_flags_syn=(tcp_hlen_bl_flags &amp; <span class="number">0x0002</span>);<span class="comment">//同步syn=1,ack=0时，表明这是一个连接请求报文；syn=1,ack=1,接受连接请求</span></span><br><span class="line">tcp_flags_fin=(tcp_hlen_bl_flags &amp; <span class="number">0x0001</span>);<span class="comment">//释放连接=1时，表示数据报</span></span><br><span class="line">tcp_window_size=ntohs(th-&gt;window_size);<span class="comment">//窗口（发送方自己的接收窗口）</span></span><br><span class="line">tcp_checksum=ntohs(th-&gt;checksum);<span class="comment">//检验和（首部+数据）</span></span><br><span class="line">tcp_urg=ntohs(th-&gt;urg);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\n运输层协议：  TCP协议\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*打印TCP数据报首部*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"端口号：%d -&gt; %d\n"</span>,tcp_sport,tcp_dport);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"序号：%u\t"</span>,tcp_seqnum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"确认号：%u\n"</span>,tcp_acknum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"数据偏移：%d\t\t"</span>,tcp_hlen);<span class="comment">//首部长度</span></span><br><span class="line"><span class="comment">//printf("保留：%d\n",tcp_bl);</span></span><br><span class="line"><span class="comment">/*控制字段,标志位*/</span></span><br><span class="line"><span class="keyword">if</span> (tcp_flags_urg == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：URG\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_ack == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：ACK\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_psh == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：PSH\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_rst == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：RST\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_syn == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：SYN\n"</span>);</span><br><span class="line"><span class="keyword">if</span> (tcp_flags_fin == <span class="number">1</span>)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"标志：FIN\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"窗口：%d\t\t"</span>,tcp_window_size);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"检验和：%d\n"</span>,tcp_checksum);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"紧急指针：%d\t\t"</span>,tcp_urg);<span class="comment">//URG=1时才有用，窗口大小为0也能发送</span></span><br><span class="line"><span class="keyword">if</span>(tcp_hlen == <span class="number">20</span>)<span class="comment">//数据偏移(TCP首部长度)&gt;20时才有</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"首部长度为20字节，没有填充字段。\n"</span>);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tcp_option = ntohl(th-&gt;option);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"填充字段:%u\n"</span>, tcp_option);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Callback function invoked by libpcap for every incoming packet */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_handler</span><span class="params">(u_char *param, <span class="keyword">const</span> struct pcap_pkthdr *header, <span class="keyword">const</span> u_char *pkt_data)</span>   <span class="comment">//param 无用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">eth_header *eth;</span><br><span class="line">u_short macType;</span><br><span class="line"></span><br><span class="line">myPrintBaseInfo(header);</span><br><span class="line"></span><br><span class="line">eth=(eth_header *) (pkt_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//过滤以太网头部</span></span><br><span class="line">pkt_data += <span class="number">14</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HandleMac</span></span><br><span class="line">macType=handleMac(eth);</span><br><span class="line">myPrintNetType(macType);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理ARP 和 RARP</span></span><br><span class="line"><span class="keyword">if</span>(macType==<span class="number">0x0806</span> || macType==<span class="number">0x8035</span>)</span><br><span class="line">&#123;</span><br><span class="line">arp_header *ap;</span><br><span class="line">ap = (arp_header *)(pkt_data);</span><br><span class="line">handleARPAndRARP(ap);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 处理IP</span></span><br><span class="line"><span class="keyword">if</span>(macType==<span class="number">0x0800</span>)</span><br><span class="line">&#123;</span><br><span class="line">u_short ip_type;</span><br><span class="line">ip_header *ih;</span><br><span class="line">ih = (ip_header *) (pkt_data);</span><br><span class="line">ip_type = handleIP(ih);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ip_type == <span class="number">1</span>) &#123;</span><br><span class="line">icmp_header *ich;</span><br><span class="line">ich = (icmp_header *)((u_char*)ih + all_ip_len);</span><br><span class="line">handleICMP(ich);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">17</span>)&#123;</span><br><span class="line">udp_header *uh;</span><br><span class="line">uh = (udp_header *) ((u_char*)ih + all_ip_len);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(handleUDP(uh))</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct dns_packet *pdns;</span></span><br><span class="line"><span class="comment">pdns = (struct dns_packet *)(pkt_data + all_ip_len + udp_len); // sport+dport+length+checksum,DNS头指针</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">u_char *query=&amp;(pdns-&gt;dns_data);//定位到查询部分头部</span></span><br><span class="line"><span class="comment">printf("QueryDomain=");</span></span><br><span class="line"><span class="comment">u_char domainname[100]=&#123;0&#125;;</span></span><br><span class="line"><span class="comment"> </span></span><br><span class="line"><span class="comment">u_int i=0;</span></span><br><span class="line"><span class="comment">//query++;//把点去了</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">while(*query)</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf("%d", *query);</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">if(*query &lt; 0x10)//48以后出现数字和英文字母</span></span><br><span class="line"><span class="comment">printf(".");</span></span><br><span class="line"><span class="comment">else</span></span><br><span class="line"><span class="comment">printf("%c", *query);</span></span><br><span class="line"><span class="comment">query++;</span></span><br><span class="line"><span class="comment">i++;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">printf("\n"); */</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(ip_type == <span class="number">6</span>)&#123;</span><br><span class="line">tcp_header *th;</span><br><span class="line">th=(tcp_header *) ((u_char*)ih + all_ip_len);</span><br><span class="line">handleTCP(th);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pcap_if_t</span> *alldevs;</span><br><span class="line"><span class="keyword">pcap_if_t</span> *d;</span><br><span class="line"><span class="keyword">int</span> inum;</span><br><span class="line"><span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">pcap_t</span> *adhandle;</span><br><span class="line"><span class="keyword">char</span> errbuf[PCAP_ERRBUF_SIZE];</span><br><span class="line">u_int netmask;</span><br><span class="line"><span class="keyword">char</span> packet_filter[<span class="number">100</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;i);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析IP数据报输入：\t1\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析ARP数据报输入：\t2\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析TCP数据报输入：\t3\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析UDP数据报输入：\t4\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析ICMP数据报输入：\t5\n"</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"分析MAC、IP、ARP、TCP、UDP、IMCP输入\t6\n"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">1</span>)</span><br><span class="line">packet_filter = <span class="string">"ip"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">2</span>)</span><br><span class="line">packet_filter = <span class="string">"arp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">packet_filter = <span class="string">"ip and tcp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">4</span>)</span><br><span class="line">packet_filter = <span class="string">"ip and udp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">5</span>)</span><br><span class="line">packet_filter = <span class="string">"ip and icmp"</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">6</span>)</span><br><span class="line">packet_filter = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"InputError : check the number you input! exit(1)"</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bpf_program</span> <span class="title">fcode</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(pcap_findalldevs(&amp;alldevs, errbuf) == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"Error in pcap_findalldevs: %s\n"</span>, errbuf);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(d=alldevs; d; d=d-&gt;next)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d. %s"</span>, ++i, d-&gt;name);</span><br><span class="line"><span class="keyword">if</span> (d-&gt;description)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" (%s)\n"</span>, d-&gt;description);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">" (No description available)\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nNo interfaces found! Make sure WinPcap is installed.\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Enter the interface number (1-%d):"</span>,i);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;inum);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check if the user specified a valid adapter */</span></span><br><span class="line"><span class="keyword">if</span>(inum &lt; <span class="number">1</span> || inum &gt; i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nAdapter number out of range.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Jump to the selected adapter */</span></span><br><span class="line"><span class="keyword">for</span>(d=alldevs, i=<span class="number">0</span>; i&lt; inum<span class="number">-1</span> ;d=d-&gt;next, i++);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Open the adapter */</span></span><br><span class="line"><span class="keyword">if</span> ((adhandle= pcap_open_live(d-&gt;name,<span class="comment">// name of the device</span></span><br><span class="line"> <span class="number">65536</span>,<span class="comment">// portion of the packet to capture. </span></span><br><span class="line"><span class="comment">// 65536 grants that the whole packet will be captured on all the MACs.</span></span><br><span class="line"> <span class="number">1</span>,<span class="comment">// promiscuous mode (nonzero means promiscuous)</span></span><br><span class="line"> <span class="number">1000</span>,<span class="comment">// read timeout</span></span><br><span class="line"> errbuf<span class="comment">// error buffer</span></span><br><span class="line"> )) == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nUnable to open the adapter. %s is not supported by WinPcap\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Check the link layer. We support only Ethernet for simplicity. */</span></span><br><span class="line"><span class="keyword">if</span>(pcap_datalink(adhandle) != DLT_EN10MB)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nThis program works only on Ethernet networks.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(d-&gt;addresses != <span class="literal">NULL</span>)</span><br><span class="line"><span class="comment">/* Retrieve the mask of the first address of the interface */</span></span><br><span class="line">netmask=((struct sockaddr_in *)(d-&gt;addresses-&gt;netmask))-&gt;sin_addr.S_un.S_addr;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">/* If the interface is without addresses we suppose to be in a C class network */</span></span><br><span class="line">netmask=<span class="number">0xffffff</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//compile the filter</span></span><br><span class="line"><span class="keyword">if</span> (pcap_compile(adhandle, &amp;fcode, packet_filter, <span class="number">1</span>, netmask) &lt;<span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nUnable to compile the packet filter. Check the syntax.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//set the filter</span></span><br><span class="line"><span class="keyword">if</span> (pcap_setfilter(adhandle, &amp;fcode)&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"\nError setting the filter.\n"</span>);</span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"\nlistening on %s...\n"</span>, d-&gt;description);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* At this point, we don't need any more the device list. Free it */</span></span><br><span class="line">pcap_freealldevs(alldevs);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* start the capture */</span></span><br><span class="line">pcap_loop(adhandle, <span class="number">0</span>, packet_handler, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><ul><li><p>听到网卡上Mac帧时的回调函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">packet_handler</span><span class="params">(u_char *param, </span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">const</span> struct pcap_pkthdr *header, <span class="keyword">const</span> u_char *pkt_data)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出基本信息：包括监听到帧的时间，帧的长度</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintBaseInfo</span><span class="params">(<span class="keyword">const</span> struct pcap_pkthdr *header)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出硬件地址，格式：<code>xx:xx:xx:xx:xx:xx</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintEthAddress</span><span class="params">(eth_address eth)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出IP地址，格式：<code>xx.xx.xx.xx</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintIPAddress</span><span class="params">(ip_address ia)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>输出网络层协议类型，格式：<code>网络层协议：xxxx</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrintNetType</span><span class="params">(u_short type)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析Mac帧：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u_short <span class="title">handleMac</span><span class="params">(eth_header *eth)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析ARP和RARP帧</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleARPAndRARP</span><span class="params">(arp_header *ah)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析IP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">u_short <span class="title">handleIP</span><span class="params">(ip_header *ih)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析ICMP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleICMP</span><span class="params">(icmp_header *ich)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析UDP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handleUDP</span><span class="params">(udp_header *uh)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>分析TCP数据报</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handleTCP</span><span class="params">(tcp_header *th)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建&lt;/h2&gt;
      
    
    </summary>
    
      <category term="网络编程" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机网络" scheme="https://isjinhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="winpcap" scheme="https://isjinhao.github.io/tags/winpcap/"/>
    
  </entry>
  
  <entry>
    <title>11-关系数据库理论</title>
    <link href="https://isjinhao.github.io/2019/11-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%90%86%E8%AE%BA/"/>
    <id>https://isjinhao.github.io/2019/11-关系数据库理论/</id>
    <published>2019-03-27T14:58:59.000Z</published>
    <updated>2019-03-30T01:31:08.777Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><h2 id="关系-amp-关系模式"><a href="#关系-amp-关系模式" class="headerlink" title="关系 &amp; 关系模式"></a>关系 &amp; 关系模式</h2><p>关系模式相当于一张二维表的框架，在这个框架下填入数据，称为关系模式的一个实例，或者叫关系R。关系模式的形式化定义是：$R(U,D,DOM,F)​$</p><ul><li>R：关系名</li><li>U：组成该关系的属性名集合</li><li>D：U中属性所来自的域<ul><li>域：一组具有相同数据类型的值的集合</li></ul></li><li>DOM：属性向域的映像集合</li><li>F：属性间数据的依赖关系集合</li></ul><p>由于D和DOM域与关系模式的设计无关，因此在讨论关系数据库理论时可以把关系模式看做：$R(U,F)​$</p><p>关系的形式化定义：当且仅当$U$上的一个关系$r$满足$F$时，r称为关系模式$R(U,F)$上的一个关系。</p><h2 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h2><p>关系模式的设计直接影响着后续增删查改等的操作。如果设计的不合理就会发生各种各样的问题：</p><ul><li>数据冗余太大</li><li>更新异常</li><li>插入异常</li><li>删除异常</li></ul><p>比如对于一个描述学校在校生信息数据库：$Student&lt;U,F&gt;$，$U=\lbrace Sno,Sdept,Mname,Cname,Grade\rbrace$会发生的问题：</p><ul><li>冗余问题：每个系的系主任姓名重复出现，重复次数与该系所有学生的所有课程成绩次数相同</li><li>更新问题：如果某系的系主任更换后，该数据库该系中所有的元组都要更新</li><li>插入异常：如果一个系刚成立，尚无学生，则无法把该系的系主任存入数据库</li><li>删除异常：如果某个系的学生都毕业了，在删除该系学生的同时，该系系主任的信息也会被删除</li></ul><p>一个好的模式不能发生插入异常、删除异常和更新异常，数据冗余应该尽可能少。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>范式指的是规范化的关系模式，而规范也就是条件，满足不同的条件可以分别解除上述所说的不同问题。</p><h3 id="问题发生的原因"><a href="#问题发生的原因" class="headerlink" title="问题发生的原因"></a>问题发生的原因</h3><p>之所以会发生上诉的问题其实就是由于数据依赖。而数据依赖可以分为两种：函数依赖和多值依赖。但这两种依赖关系不是平级，而是递进的关系，所以我们先介绍函数依赖。</p><h3 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h3><p>设$R(U)$是一个属性集$U$上的关系模式，$X$和$Y$是$U$的子集。若对于$R(U)$的任意两个可能的关系$r_1$、$r_2$，若$r_1[x]=r_2[x]$，则$r_1[y]=r_2[y]$，则称$X$决定$Y$，或者$Y$依赖$X$。记作$X \rightarrow Y$。</p><p>对于$X​$、$Y​$范围的不同，可以再次分为：</p><ul><li>非平凡函数依赖：如果$X \rightarrow Y​$但$Y \nsubseteq X​$，则称$X \rightarrow Y​$是非平凡函数依赖</li><li>平凡函数依赖：如果$X \rightarrow Y$但$Y \subseteq X$，则称$X \rightarrow Y$是非平凡函数依赖。<ul><li>例：$(Sno,Sname) \rightarrow Sname$</li></ul></li></ul><p>所以，在关系模式中，平凡函数依赖是一定是可以被满足的，所以我们在以后的讨论中不再关注平凡函数依赖，只关注非平凡函数依赖。而我们对于非平凡函数依赖又可以分为以下几类：</p><ul><li>完全函数依赖：如果$X \rightarrow Y​$，并且对于任意的真子集$X_i​$，都无法做到$X_i \rightarrow Y​$，则称$Y​$对$X​$是完全函数依赖。</li><li>部分函数依赖：如果$X \rightarrow Y​$，存在真子集$X_i​$，可以做到$X_i \rightarrow Y​$，则称$Y​$对$X​$是部分函数依赖。</li><li>传递函数依赖：如果$X \rightarrow Y$，$Y \rightarrow Z$且$Y \nrightarrow X$，则称$X$对$X$有传递函数依赖。</li></ul><h3 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h3><p>在关系模型中的每一个具体关系$R$中，如果每个属性都是不可再分的，则称$R$属于第一范式，记作$R \in 1NF$。</p><h3 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h3><p>$R \in 1NF​$且每一个非主属性完全函数依赖于码，则$R \in 2NF​$。依赖有直接依赖和传递依赖。</p><h3 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h3><p>$R \in 2NF$且$R$中的每个非主属性不传递依赖于主码，则关系$R$是第三范式，$R \in 3NF$。</p><h3 id="模式分解"><a href="#模式分解" class="headerlink" title="模式分解"></a>模式分解</h3><p>从低级范式到高级范式的方法是模式分解。</p><p>举例：对于一个关系$R(SNO,SNA,CNO,GRADE,CNA,TNA,TAGE)$（学号、姓名、课号、成绩、课程名称、教师姓名、教师年龄）。</p><p>现实语义：如果假设一个教师可以交多门课且一门课仅由一个教师讲授，可得R的函数依赖集：</p><ul><li>$SNO \rightarrow SNM$</li><li>$(SNO,CNO) \rightarrow GRADE​$</li><li>$CNO \rightarrow CNA$</li><li>$CNO \rightarrow TNA$</li><li>$TNA \rightarrow TAGE​$</li></ul><p>函数依赖图如下：</p><div align="center"><img src="/2019/11-关系数据库理论/函数依赖图.jpg" style="width:50%"></div><p>分解为第二范式：</p><ul><li><p>$R1&lt;(SNO,SNA),SNO \rightarrow SNA&gt;​$</p></li><li><p>$R2&lt;(SNO,CNO,GRADE), (SNO,CNO) \rightarrow GRADE&gt;​$</p></li><li><p>$R3&lt;(CNO,CNA,TNA,TAGE),CNO \rightarrow CNA, CNO \rightarrow TNA, TNA \rightarrow TAGE&gt;​$</p></li></ul><p>分解为第三范式：</p><ul><li><p>$R1&lt;(SNO,SNA),SNO \rightarrow SNA&gt;$</p></li><li><p>$R2&lt;(SNO,CNO,GRADE), (SNO,CNO) \rightarrow GRADE&gt;$</p></li><li><p>$R3&lt;(CNO,CNA,TNA),CNO \rightarrow CNA, CNO \rightarrow TNA&gt;​$</p></li><li>$R3&lt;(CNO,TAGE),CNO \rightarrow TAGE&gt;$</li></ul><h3 id="第三范式的问题"><a href="#第三范式的问题" class="headerlink" title="第三范式的问题"></a>第三范式的问题</h3><p>仓库保管$WPE(W#,P#,E#,QNT)$，（ 仓库号，器件号，职工号，数量）。</p><p>一个职工只能管理一个仓库的某类型器件，一个仓库的某类型器件数量是确定的，一个员工管理的某类型器件数量是一定的。</p><p>函数依赖：</p><ol><li>$(W#, P#) \rightarrow QNT$</li><li>$(E#,P#) \rightarrow QNT$</li><li>$(W#,P#) \rightarrow E#​$</li><li>$E# \rightarrow W#$</li></ol><p>函数依赖图：</p><div align="center"><img src="/2019/11-关系数据库理论/函数依赖图2.jpg" style="width:50%"></div><p>此时关系模式$WPE​$有两个侯选码，$(W#,P#)​$ ，$(E#,P#)​$，假设确定$(E#,P#)​$为主码，那么某新职工分配来仓库，处于学习阶段，但没有独立承但任务，即有$E#​$但无$P#​$，缺少码的组成部分，无法插入到该关系，即插入异常。这是由于<strong>主属性$W#​$对另一个侯选码$(E#,P#)​$的部分函数依赖</strong>。</p><h3 id="BC范式"><a href="#BC范式" class="headerlink" title="BC范式"></a>BC范式</h3><p>BC范式的定义：每个决定因素都包含码，则$R \in BCNF​$。</p><p>而既然每个决定因素都要包含码，则此时意味着必须放弃某些函数依赖，即失去某些现实语义。如例子中若选择$(E#,P#)$，则只能保存函数依赖中的2和4。</p><h3 id="多值依赖"><a href="#多值依赖" class="headerlink" title="多值依赖"></a>多值依赖</h3><p>设$R(U)$是属性集U上的一个关系模式。$X$，$Y$，$Z$是的$U$的子集，并且$Z=U-X-Y$。关系模式$R(U)$中多值依赖（记做，$X \rightarrow \rightarrow Y$）成立，当且仅当对$R(U)$的任一关系$r$，给定的一对$(x,z)$值有一组$Y$的值，这组值仅仅决定于$x$值而与$z$值无关。</p><p>若$X \rightarrow \rightarrow Y$，$Z$为空，则称$X \rightarrow \rightarrow Y$为平凡的多值依赖。 所以我们以下只讨论非平凡的函数依赖。</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>比如对于关系模型$Teaching(C,T,B)$便是存在多值依赖（码为全属性）：</p><div align="center"><img src="/2019/11-关系数据库理论/teaching.jpg" style="width:80%"></div><h3 id="第四范式"><a href="#第四范式" class="headerlink" title="第四范式"></a>第四范式</h3><p>如果对于$R$的每个非平凡多值依赖$X \rightarrow \rightarrow Y$，$X$都含有码，则$R$都含有码。</p><p>多值依赖的解决依然是分解。如上例中分解为：</p><ul><li>$R(C,T)$</li><li>$R(C,B)$</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;关系-amp-关系模式&quot;&gt;&lt;a href=&quot;#关系-amp-关系模式&quot; class=&quot;headerlink&quot; title=&quot;关系 &amp;a
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>CPP中的字节序</title>
    <link href="https://isjinhao.github.io/2019/CPP%E4%B8%AD%E7%9A%84%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    <id>https://isjinhao.github.io/2019/CPP中的字节序/</id>
    <published>2019-03-27T13:26:28.000Z</published>
    <updated>2019-03-27T14:12:15.059Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><h2 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h2><p>计算机硬件有两种储存数据的方式：大端字节序（big endian）和小端字节序（little endian）。</p><ul><li><p>大端字节序：高位字节在前，低位字节在后。</p></li><li><p>小端字节序：低位字节在前，高位字节在后。</p></li></ul><p>假如我们要存储<code>0x01234567</code>，大端法和小端法如下：</p><div align="center"><img src="/2019/CPP中的字节序/大端.gif" style="width:70%"></div><h2 id="为什么会有小端字节序"><a href="#为什么会有小端字节序" class="headerlink" title="为什么会有小端字节序"></a>为什么会有小端字节序</h2><p>人类能接受的字节序肯定是大端存储，所以很多人会不理解为什么还要有小端字节序呢？其实计算机处理字节序的时候，不知道什么是高位字节，什么是低位字节。它只知道按顺序读取字节，先读第一个字节，再读第二个字节。如果是大端字节序，先读到的就是高位字节，后读到的就是低位字节。小端字节序正好相反。</p><p>个人觉得之所以会存在小端字节序是由于计算机电路在计算时先处理低位字节，存储单元里的数据按小端字节序存储方便计算。</p><h2 id="字节序的处理"><a href="#字节序的处理" class="headerlink" title="字节序的处理"></a>字节序的处理</h2><ul><li><p>其实只有读取的时候，才必须区分字节序，其他情况都不用考虑。</p></li><li><p>数据长度大于1字节（8bits）时才需要区分字节序。</p></li></ul><p>虽然在计算机中存储和具体的平台相关，但是规定在网络中传输的数据采用大端传输，即如果有一串网络流为：<code>010101000100110101010</code>，实际发送时越左边的越先发送到网络中。</p><h3 id="C语言中处理字节序"><a href="#C语言中处理字节序" class="headerlink" title="C语言中处理字节序"></a>C语言中处理字节序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为16位主机字节序的值，返回值是16位网络字节序的值</span></span><br><span class="line"><span class="keyword">uing16_t</span> htons(<span class="keyword">uint16_t</span> host16bitvalue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为32位主机字节序的值，返回值是32位网络字节序的值</span></span><br><span class="line"><span class="keyword">uint32_t</span> htonl(<span class="keyword">uint32_t</span> host32bitvalue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为16位网络字节序的值，返回值是16位主机字节序的值</span></span><br><span class="line"><span class="keyword">uint16_t</span> ntohs(<span class="keyword">uint16_t</span> net16bitvalue);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数为16位网络字节序的值，返回值是16位主机字节序的值</span></span><br><span class="line"><span class="keyword">uint32_t</span> ntohl(<span class="keyword">uint32_t</span> net32bitvalue);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;字节序&quot;&gt;&lt;a href=&quot;#字节序&quot; class=&quot;headerlink&quot; title=&quot;字节序&quot;&gt;&lt;/a&gt;字节序&lt;/h2&gt;&lt;p&gt;计
      
    
    </summary>
    
      <category term="计算机组成原理" scheme="https://isjinhao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="字节序" scheme="https://isjinhao.github.io/tags/%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    
      <category term="计算机组成原理" scheme="https://isjinhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>物理层</title>
    <link href="https://isjinhao.github.io/2019/%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <id>https://isjinhao.github.io/2019/物理层/</id>
    <published>2019-03-27T05:15:14.000Z</published>
    <updated>2019-03-27T13:11:04.558Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><h3 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h3><p>数字通信中对数字信号的计量单位。在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>假如基带信号是<code>101011000110111010...</code>，如果直接发送，则每个码元携带一个比特的信息（每个码元只有2种状态），但是如果将信号中的三个比特编为一组，即101，011，000，110，111，010…，三个比特共有8种不同的排列，我们可以用不同的调制方法来表示这种信，如8种不同的振幅，频率，相位等，如果采用相位调制，相位$\phi_0$表示000，$\phi_1$表示001，以此类推，那么接收端如果收到相位是$\phi_0$的信号就知道表示的是000，以此类推，这样一个码元就不知不觉的传输了三个比特位的信号，此时每个码元有8种状态。一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难。</p><h3 id="编码级别"><a href="#编码级别" class="headerlink" title="编码级别"></a>编码级别</h3><p>如果把n个比特编码成一个码元，则此时编码状态$M=2^n$，其表示当前传输时有多少不同的状态，如8级编码，会有：<code>000、001、010 …</code></p><h2 id="奈斯准则"><a href="#奈斯准则" class="headerlink" title="奈斯准则"></a>奈斯准则</h2><h3 id="码间串扰"><a href="#码间串扰" class="headerlink" title="码间串扰"></a>码间串扰</h3><p>码元的传输速率是有限制的，超过某上限就会出现码间串扰问题。这是由于在真正传输中，信号在传输时都不是理想化的，如下图就是理想化的高低电平和真实传输时的高低电平。</p><div align="center"><img src="/2019/物理层/真实和理想.jpg" style="width:50%"></div><p>假如此时速度太快，就可能把低电平和高电平弄混。而最高的码元传输速率被奈斯准则限制。</p><h3 id="奈斯准则内容"><a href="#奈斯准则内容" class="headerlink" title="奈斯准则内容"></a>奈斯准则内容</h3><ul><li>理想低通信道（能通过信号频率在某值之下）的最高码元传输速率为：$2W Baud$。</li></ul><div align="center"><img src="/2019/物理层/低通信道.png" style="width:80%"></div><ul><li>理想带通信道（能通过信号频率在某范围之内）的最高码元传输速率为：$1W Baud$。</li></ul><div align="center"><img src="/2019/物理层/带通信道.png" style="width:80%"></div><p>W是理想低通信道的带宽，单位为赫(Hz)。Baud 是波特，是码元传输速率的单位，1 波特为每秒传送 1 个码元。</p><h3 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h3><p>单位时间内数据通信系统所传输的码元个数（信号个数），单位是波特（Baud）。</p><h3 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h3><p>表示单位时间内数据通信系统传输的比特数，单位是比特/秒（b/s或bps）。$比特率 = 波特率 * log_2M$</p><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><h3 id="编码级数限制"><a href="#编码级数限制" class="headerlink" title="编码级数限制"></a>编码级数限制</h3><p>虽然码元传输速率有限制，但是如果我们能尽可能提高编码级数不就能提升信息传输速率了吗？但事实上信号传输速率不受限于调制技术，而是受限于信噪比。举个例子，如果我们是在天气晴朗的一天出门，我们穿任意颜色衣服都能被分辨出来，但是如果我们在沙尘暴天气出门，穿<code>橘黄</code>和<code>橙黄</code>两种颜色的衣服别人自然就认不出来了。在这个比喻中衣服的颜色代表码元，确定衣服的颜色代表信息，沙尘暴就是噪声。</p><h3 id="香农公式内容"><a href="#香农公式内容" class="headerlink" title="香农公式内容"></a>香农公式内容</h3><p>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率$C=W \ast log_2(1+PS/PN)（b/s）​$。</p><ul><li>其中$W$是信道的带宽。$PS$是信号的能量。$PN$是噪声的能量。</li><li>信噪比：$S/N=10lg{PS/PN}$。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>设带宽是<code>1MHz</code>，信噪比是<code>24dB</code>，则信道的最高信息传输速率为：$C=1M \ast log_2{(1+(10^{2.4}))}=7.98Mbps$。</p><h2 id="奈氏准则vs香农公式"><a href="#奈氏准则vs香农公式" class="headerlink" title="奈氏准则vs香农公式"></a>奈氏准则vs香农公式</h2><div align="center"><img src="/2019/物理层/香农公式和奈斯准则.png" style="width:80%"></div><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>电路交换中独占电路资源，并不是指用户线和中继线都被此次交换所独占，而是说在两个用户建立连接之后，除非连接中断，否则他们当前所拥有的资源不会被释放，即使他们之间不传输信息。而如何在中继线上实现多组用户通信就是多路复用技术。</p><p>产生多路复用的物理基础是：传输媒体的带宽或容量往往会大于传输单一信号的需求，使用多路复用，为了有效地利用通信线路，希望一个信道同时传输多路信号。</p><p>这种技术会将链路/网络资源（如带宽）划分为“资源片”，将资源片分配给各路“呼叫”（calls），每路呼叫独占分配到的资源片进行通信，资源片可能“闲置”</p><p>常见的复用技术有：频分多路复用、时分多路复用、波分多路复用、码分多路复用。</p><div align="center"><img src="/2019/物理层/多路复用.png" style="width:80%"></div><h3 id="频分多路复用"><a href="#频分多路复用" class="headerlink" title="频分多路复用"></a>频分多路复用</h3><p>FMD：Frequency-division multiplexing，是指载波带宽被划分为多种不同频带的子信道，每个子信道可以并行传送一路信号的一种多路复用技术。也就是说信道的可用频带被分成若干个互不交叠的频段，每路信号用其中一个频段传输，因而可以用滤波器将它们分别滤出来，然后分别解调接收。</p><div align="center"><img src="/2019/物理层/频分多路复用.png" style="width:40%"></div><h3 id="时分多路复用"><a href="#时分多路复用" class="headerlink" title="时分多路复用"></a>时分多路复用</h3><p>TDM：time division multiplexing，它使不同的信号在不同的时间内传送，将整个传输时间分为许多时间间隔（Time Slot，TS，又称为时隙），每个时间片被一路信号占用。TDM就是通过在时间上交叉发送每一路信号的一部分来实现一条电路传送多路信号的。电路上的每一短暂时刻只有一路信号存在。因数字信号是有限个离散值，所以TDM多应用于数字通信系统。</p><div align="center"><img src="/2019/物理层/时分多路复用.png" style="width:70%"></div><h3 id="波分多路复用"><a href="#波分多路复用" class="headerlink" title="波分多路复用"></a>波分多路复用</h3><p>将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器（亦称合波器，Multiplexer）汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；在接收端，经解复用器（亦称分波器或称去复用器，Demultiplexer）将各种波长的光载波分离，然后由光接收机作进一步处理以恢复原信号。</p><div align="center"><img src="/2019/物理层/波分多路复用.png" style="width:70%"></div><h3 id="码分多路复用"><a href="#码分多路复用" class="headerlink" title="码分多路复用"></a>码分多路复用</h3><p>为每个用户分配一个唯一的mbit的码片序列（chipping sequence），二进制下的0用-1表示，二进制下的1用+1表示。在信道上传输的信号 = 原始数据 <em>码片序列，比如码片序列是：(-1, 1, 1)，需要传一个0，应该是 -1 </em>(-1, 1, 1)，所以传输的就是(1, -1, -1)。</p><p>同时为了保证数据之间不相互影响，被共享的用户所占有的码片应该相互正交的。即：$\frac{1}{m}S_i \cdot S_j = 0 (i \neq j)​$。而信道上真正传输的数据是各用户发送数据的叠加值。</p><div align="center"><img src="/2019/物理层/码分多路复用.png" style="width:80%"></div><h3 id="数字信号在模拟信道传输"><a href="#数字信号在模拟信道传输" class="headerlink" title="数字信号在模拟信道传输"></a>数字信号在模拟信道传输</h3><p>数字信号需要编码后才能传输。常见的三种编码：</p><ol><li>NRZ编码：进制数字0、1分别用两种电平来表示。常用-5V表示1，+5V表示0。</li><li>曼切斯特编码：用电压的变化表示0和1：高→低 &lt;=&gt; 0，低→高 &lt;=&gt; 1。</li><li>差分曼切斯特编码：在码元开始处有无跳变来表示0和1：有 &lt;=&gt; 0，无 &lt;=&gt; 1。</li></ol><div align="center"><img src="/2019/物理层/数字信号编码.png" style="width:80%"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;码元&quot;&gt;&lt;a href=&quot;#码元&quot; class=&quot;headerlink&quot; title=&quot;码元&quot;&gt;&lt;/a&gt;码元&lt;/h2&gt;&lt;h3 id=&quot;
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://isjinhao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://isjinhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络基础</title>
    <link href="https://isjinhao.github.io/2019/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    <id>https://isjinhao.github.io/2019/计算机网络基础/</id>
    <published>2019-03-26T13:43:16.000Z</published>
    <updated>2019-03-27T13:11:04.558Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><p>本人是非通信专业学生，加上本身水平有限，对于物理层和计算机网络基础错误会较多，敬请指出。</p><h2 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h2><p>信道是数据交换的载体。狭义上说人和人之间交流所承载信息的空气就是信道。广义上说它还可以包括有关的变换装置，这样的话信道往往被分成信道编码器、信道本身和信道译码器。</p><p>简易通信系统模型如下：</p><div align="center"><img src="/2019/计算机网络基础/信道.png"></div><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>计算机网络就是互联的、自治的计算机集合。自治指的是所有的计算机直接没有主从关系；互联指的是互联互通，能进行数据交换。</p><p>计算机网络的本质是一种通信网络，只不过信源和信宿都是主机。它是计算机技术和通信技术的结合。</p><h2 id="主机（host）"><a href="#主机（host）" class="headerlink" title="主机（host）"></a>主机（host）</h2><p>诸如手机、电脑、服务器等端系统（end systems）。</p><h2 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h2><p>如果想实现多个计算机之间的互联，按照之前的想法是每两台计算机进行连接，但这样太麻烦，一个好的做法是把这个计算机连接在某一中心上，这个中心把所有连接上来的计算机进行互联，在链路层这个中心叫做交换机。</p><div align="center"><img src="/2019/计算机网络基础/交换机.png" style="width:25%"></div><h2 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h2><p>分组是带有地址信息的信息小片，可以理解成是计算机把一个文件切片后打成的包裹，由两部分构成：地址信息和真正传输的东西。</p><div align="center"><img src="/2019/计算机网络基础/分组.jpg"></div><h2 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h2><p>是计算机网络的一种专用计算机，它只有一个功能，就是转发分组。可以简单的理解为路由器是电子化的邮局，全国所有的邮局之间互联，是包裹能够传递，路由器之间互联，是分组能够正确转发。</p><p>路由器和交换机的区别是：交换机将计算机连在一起，构成局域网；路由器将局域网连在一起，形成互联网。</p><h2 id="计算机网络基本原理"><a href="#计算机网络基本原理" class="headerlink" title="计算机网络基本原理"></a>计算机网络基本原理</h2><p>分组交换技术，也就是拆分分组、传输分组、合并分组的技术。</p><p>这个技术的优点就是便宜，因为把数据打包成分组和分组拆分都在计算机中进行，网络上只进行分组的转发，就使得网络的结构很简单，路由器设计也很简单。这一中原则被叫做“端到端的原则”，即能在端系统做的事情不在网络上实现。</p><div align="center"><img src="/2019/计算机网络基础/计算机网络基本原则.jpg" style="width:60%"></div><h2 id="分组交换技术"><a href="#分组交换技术" class="headerlink" title="分组交换技术"></a>分组交换技术</h2><ol><li>一个主机至少连接一个路由器：数据最终是通过路由器进行转发的，所以一个主机至少得连接一个路由器。</li><li>分组存储转发：分组完全进入路由器后，路由器按照地址信息检索转发表。注意不是第一个bit或Byte进入时就开始转发，是全部进入才转发。</li><li>分组独立选择路径：一个文件被分成多个分组，但这些分组之间是独立的，路由器给他们看成相互独立的数据。分组的组装是通过接收方进行的，和网络无关。</li></ol><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><h3 id="组成细节角度"><a href="#组成细节角度" class="headerlink" title="组成细节角度"></a>组成细节角度</h3><p>ISP网络互联形成的网络之网络。由运行各种网路应用的计算设备，光纤、铜缆、无线电等通信链路、路由器和交换机等组成的分组交换设备组成。</p><h3 id="服务角度"><a href="#服务角度" class="headerlink" title="服务角度"></a>服务角度</h3><p>是为网络应用提供通信服务的通信基础设施和为网络应用提供的应用编程接口。</p><h2 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h2><p>ISP，全称为Internet Service Provider，因特网服务提供商，即指提供互联网服务的公司。能提供拨号上网服务、网上浏览、下载文件、收发电子邮件等服务。</p><h2 id="网络的结构"><a href="#网络的结构" class="headerlink" title="网络的结构"></a>网络的结构</h2><ul><li>网络边缘：位于“网络边缘”运行网络应用程序的端系统。</li></ul><ul><li>接入网络、物理介质：有线或无线的通信链路。</li></ul><ul><li>网络核心：互联的路由器（或分组转发设备）。构成“网络之网络”的关键。</li></ul><div align="center"><img src="/2019/计算机网络基础/计算机网络结构.png" style="width:30%"></div><h2 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h2><p>客户/服务器应用模型：依赖于专用服务器，如Web应用。</p><p>对等应用模型：不依赖专用服务器，通信在对等实体之间进行，如P2P应用。</p><h2 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h2><p>接入网络是一种用户网络，它连接用户到特定的服务提供商并通过承载网络到达其他网络。两个被用户关心的特征：带宽（数据传输速率，bps）、独占/共享（独占是带宽为某用户独用，共享是多个用户分用同一带宽）。</p><div align="center"><img src="/2019/计算机网络基础/接入网络.jpg" style="width:50%"></div><h2 id="数字用户线路：DSL"><a href="#数字用户线路：DSL" class="headerlink" title="数字用户线路：DSL"></a>数字用户线路：DSL</h2><p>是以电话线为传输介质的传输技术组合。DSL技术在传递公用电话网络的用户环路上支持对称和非对称传输ADSL：上行速度较慢，下行速度较快）模式。</p><p>用DSL接入Internet时用户一方会有DSL调制解调器，被接入方会有DSL接入多路复用器与多个用户进行接入。</p><div align="center"><img src="/2019/计算机网络基础/DSL.png" style="width:60%"></div><h2 id="电缆网络"><a href="#电缆网络" class="headerlink" title="电缆网络"></a>电缆网络</h2><p>又被称为混合光纤同轴电缆网络。也是一种非对称式的接入网络。但它是共享网络，多个用户共同接入一个解调器。</p><div align="center"><img src="/2019/计算机网络基础/电缆网络.png" style="width:80%"></div><h2 id="常见网络接入"><a href="#常见网络接入" class="headerlink" title="常见网络接入"></a>常见网络接入</h2><h3 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h3><h3 id="家庭接入-1"><a href="#家庭接入-1" class="headerlink" title="家庭接入"></a>家庭接入</h3><div align="center"><img src="/2019/计算机网络基础/家庭接入.png" style="width:75%"></div><h3 id="机构（企业）接入"><a href="#机构（企业）接入" class="headerlink" title="机构（企业）接入"></a>机构（企业）接入</h3><div align="center"><img src="/2019/计算机网络基础/企业接入.png" style="width:70%"></div><h3 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h3><div align="center"><img src="/2019/计算机网络基础/无线局域网.png"></div><h3 id="广域局域网"><a href="#广域局域网" class="headerlink" title="广域局域网"></a>广域局域网</h3><div align="center"><img src="/2019/计算机网络基础/广域局域网.png" style="width:40%"></div><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心的功能是：路由（routing）：确定分组从源到目的传输路径；转发（forwarding）：将分组从路由器的输入端口交换至正确的输出端口。</p><div align="center"><img src="/2019/计算机网络基础/网络核心.png" style="width:70%"></div><h2 id="Internet结构"><a href="#Internet结构" class="headerlink" title="Internet结构"></a>Internet结构</h2><div align="center"><img src="/2019/计算机网络基础/Internet结构.png" style="width:70%"></div><ul><li><p><code>一级ISP包含</code>：网通、电信等商业ISP，还包含谷歌、微软等内容提供商网络。</p></li><li><p><code>IXP</code>：全称：Internet eXchange Point，即互联网交换中心。互联网Internet是由众多的网络互相连接而形成的全球性网络，互联网交换中心负责这些不同的网络之间互相通信的交换点，是互联网的关键基础设施。</p></li></ul><h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>包含三个阶段：建立连接、通信、释放连接。最显著的特点是独占电路资源。最典型的是电话网络。（下图的中继线上可以存在多组用户通信，详见复用技术）</p><div align="center"><img src="/2019/计算机网络基础/电路交换.png" style="width:80%"></div><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>报文交换是指把信息整个打包，然后经过存储转发送到目的地。</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>分组交换是把信息拆分成不同的分组，然后把所有的分组相继发送给路由器，路由器通过路由&amp;转发把数据传输到目的地。</p><ul><li>和报文交换的区别是：报文交换不拆分信息。</li></ul><ul><li>和电路交换的区别是：如果把每个分组看成原子单位，区别就是各分组走不同的路径，不需要独占资源。</li></ul><h3 id="图解三种交换"><a href="#图解三种交换" class="headerlink" title="图解三种交换"></a>图解三种交换</h3><div align="center"><img src="/2019/计算机网络基础/图解三种交换.png" style="width:80%"></div><h3 id="分组交换的优势"><a href="#分组交换的优势" class="headerlink" title="分组交换的优势"></a>分组交换的优势</h3><ul><li>和报文交换相比：速度快，因为在报文交换时，同一时间只有一个路由器在工作，其他路由器在等待。路由器的存储空间小，最低存储空间和分组大小差不多。</li></ul><ul><li>和电路交换相比：分组交换允许更多用户同时使用网络，让网络资源充分共享。</li></ul><h3 id="分组交换的劣势"><a href="#分组交换的劣势" class="headerlink" title="分组交换的劣势"></a>分组交换的劣势</h3><p>可能产生拥塞（congestion）：分组延迟和丢失。需要协议处理可靠数据传输和拥塞控制。</p><h2 id="RFC文档"><a href="#RFC文档" class="headerlink" title="RFC文档"></a>RFC文档</h2><p>Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。目前RFC文件是由Internet Society（ISOC）赞助发行。基本的互联网通信协议都有在RFC文件内详细说明。RFC文件还额外加入许多的论题在标准内，例如对于互联网新开发的协议及发展中所有的记录。因此几乎所有的互联网标准都有收录在RFC文件之中。</p><h2 id="IETF"><a href="#IETF" class="headerlink" title="IETF"></a>IETF</h2><p>全称：The Internet Engineering Task Force，国际互联网工程任务组。全球互联网最具权威的技术标准化组织，主要任务是负责互联网相关技术规范的研发和制定，是一个由为互联网技术工程及发展做出贡献的专家自发参与和管理的国际民间机构。主要任务是负责互联网相关技术标准的研发和制定，是国际互联网业界具有一定权威的网络相关技术研究团体。绝大多数国际互联网技术标准出自IETF。</p><h2 id="时延和网络利用率"><a href="#时延和网络利用率" class="headerlink" title="时延和网络利用率"></a>时延和网络利用率</h2><p>若令D0表示网络空闲时的时延，D表示网络当前的时延，则在适当的假定条件下，可以用下面的简单公式表示D和D0之间的关系：$D=\frac{D_0}{1-U}$。</p><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>network protocol。为进行网络中的数据交换而建立的规则、标准或约定。其中规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到的消息或发生的事件而产生的动作。也可以说网络协议规定了网络中所有信息的发送和接受过程。</p><h3 id="协议三要素"><a href="#协议三要素" class="headerlink" title="协议三要素"></a>协议三要素</h3><ul><li>语义：语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。</li></ul><ul><li>语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。</li></ul><ul><li>时序：时序是对事件发生顺序的详细说明。（也可称为“同步”）。</li></ul><p>总结：语义表示要做什么，语法表示要怎么做，时序表示做的顺序。</p><h2 id="速率-amp-带宽"><a href="#速率-amp-带宽" class="headerlink" title="速率 &amp; 带宽"></a>速率 &amp; 带宽</h2><ul><li><p>速率：又称数据率，数据传输速率或比特率。单位bps、kbps、Mbps、Gbps。</p></li><li><p>带宽：数字信道所能传输的最大数据率。单位bps等。</p></li></ul><h2 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h2><p>如果路由器的缓存满了，再到达的分组会被路由器丢弃，即造成丢包现象。丢包率 = 丢包数 / 已发分组数。</p><h2 id="分组延迟"><a href="#分组延迟" class="headerlink" title="分组延迟"></a>分组延迟</h2><ul><li>结点处理延迟：差错检测、确定输出链路；</li></ul><ul><li>排队延迟：等待输出链路可用、取决于路由器拥塞程度；</li></ul><ul><li>传输延迟：分组长度/链路带宽；</li></ul><ul><li>传播延迟：物理链路长度/信号传输速度。</li></ul><div align="center"><img src="/2019/计算机网络基础/分组延迟.jpg" style="width:60%"></div><h2 id="流量强度"><a href="#流量强度" class="headerlink" title="流量强度"></a>流量强度</h2><p>设链路带宽为R(bps)，分组长度为L(bits)，平均每组到达速率为v。则：</p><ul><li>$L \ast v / R \longrightarrow 0 ​$时：平均排队延迟很小；</li></ul><ul><li>$L \ast v / R \longrightarrow 1$时：平均排队延迟很大；</li></ul><ul><li>$L \ast v / R &gt; 1​$时：超出服务能力，延迟 趋向于 无限大。</li></ul><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>$时延带宽积 = 传播时延 \ast 带宽$，单位：bit。实际意义是：从我们向某一信道上发送第一个bit，到这个bit被接收方接受这个时间里，发送方总共向信道上发送了多少bit。也可以称为以比特为单位的链路长度，比如某段链路长度为n比特。</p><h2 id="吞吐率-量（Throughput）"><a href="#吞吐率-量（Throughput）" class="headerlink" title="吞吐率/量（Throughput）"></a>吞吐率/量（Throughput）</h2><p>发送端与接收端之间的传送数据率（b/s）。端到端的吞吐量取决于瓶颈链路。</p><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><p>指通信系统的整体设计，它为网络硬件、软件、协议、存取控制和拓扑提供标准。</p><p>计算机网络是一个非常复杂的系统，需要解决的问题很多并且性质各不相同。所以，在设计时，就使用了“分层”的思想，即将庞大而复杂的问题分为若干较小的易于处理的局部问题。各层之间是按照功能进行分层的，同时每层遵循相应的网络协议完成本层功能。</p><h2 id="OSI参考模型的通信过程"><a href="#OSI参考模型的通信过程" class="headerlink" title="OSI参考模型的通信过程"></a>OSI参考模型的通信过程</h2><p>七层结构：物理层、数据链路层、网络层、传输层、对话层、表示层和应用层。</p><ul><li>端系统需要完成七层的功能，中间系统完成三层功能。</li></ul><ul><li><p>协议之间是对等的，比如应用层的协议对发送方来说是如何把信息传输到表示层，而对接收方来说，是如何把从表示层传来的信息还原到应用层。</p></li><li><p>对于后四层，从逻辑上说不需要经过中间系统，所以被称为“端-端层”。</p></li></ul><div align="center"><img src="/2019/计算机网络基础/osi.png" style="width:70%"></div><h3 id="OSI参考模型的数据封装"><a href="#OSI参考模型的数据封装" class="headerlink" title="OSI参考模型的数据封装"></a>OSI参考模型的数据封装</h3><ul><li><p>后六层每层在把数据向下一层传输时都会加上控制信息。而物理层不再封装，因为到达它的数据已经时二进制数据，直接传输就行。</p></li><li><p>数据链路层传送给物理层时一般加头加尾，其他层只加头。头是首部，尾是循环冗余校验。</p></li></ul><div align="center"><img src="/2019/计算机网络基础/osi数据.png" style="width:80%"></div><h3 id="PDU"><a href="#PDU" class="headerlink" title="PDU"></a>PDU</h3><p>协议数据单元。可能包括地址：标识发送端/接收端等；差错检测编码：用于差错检测或纠正；协议控制：一些如优先级、服务质量、安全控制等信息。</p><h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p>四层结构：应用层、运输层、网际层和网络接口层。</p><p>所有的应用都架构在IP上，在网络接口层只要能构建IP，能进行分组就可以算是网络的一部分，这是互联网发展迅速的一大原因。</p><div align="center"><img src="/2019/计算机网络基础/TCPIP模型.png" style="width:70%"></div><h2 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h2><p>五层结构：物理层、链路层、网络层、传输层和应用层。此模型结合了OSI概念清晰，分工明确的优点和TCP/IP简单实用的优点。</p><h3 id="五层传输模型的数据封装"><a href="#五层传输模型的数据封装" class="headerlink" title="五层传输模型的数据封装"></a>五层传输模型的数据封装</h3><div align="center"><img src="/2019/计算机网络基础/五层模型.png" style="width:70%"></div><h3 id="三种模型对应"><a href="#三种模型对应" class="headerlink" title="三种模型对应"></a>三种模型对应</h3><div align="center"><img src="/2019/计算机网络基础/三种模型对应.png" style="width:70%"></div><h2 id="物理层实现的功能概述"><a href="#物理层实现的功能概述" class="headerlink" title="物理层实现的功能概述"></a>物理层实现的功能概述</h2><p>核心功能：<strong>透明地传送比特流</strong>。解决的问题一般如下：</p><ul><li><p>接口特性：</p><ul><li>机械特性：接口的几何形状，位置等等；</li><li>电气特性：使用电压的高低等等；</li><li>功能特性：各个引脚的作用等等；</li><li>规程特性：工作的过程是什么样的，如哪个引脚先发送数据，哪个后发送等。</li></ul></li><li><p>比特编码：用信号的什么特征表示信息，如什么时候用0，什么时候用1。</p></li><li><p>数据率：在物理层上传输数据的速率。</p></li><li><p>比特同步：解决时钟同步问题，发送端何时发送数据，接收端何时接受数据。</p></li><li><p>传输模式：</p><ul><li>单工通信：一个为确定的发送端、一个为确定的接收端，不能互换。</li><li>半双工：发送端和接收端可以互换，但是随时间交替的。</li><li>双工：两端可以同时发送和接受数据。</li></ul></li></ul><h2 id="数据链路层功能概述"><a href="#数据链路层功能概述" class="headerlink" title="数据链路层功能概述"></a>数据链路层功能概述</h2><p>核心功能：<strong>在两个相邻结点之间的链路上“透明”地传送数据</strong>。解决的问题如下：</p><ul><li><p>组帧：来自网络层的数据被加头加尾后形成的数据叫做帧。组帧问题包含：头和尾里包含什么信息等。</p></li><li><p>物理寻址：物理层只进行比特流的传输，其他的都不做。物理寻址是在数据链路层做的，也就是数据链路层传输层给物理层的数据包含处理好的地址。</p></li><li><p>流量控制：使数据的发送和数据的接收尽可能平衡，防止数据太多造成丢失等。</p></li><li><p>差错处理：检测并重传损坏或丢失帧，并避免重复帧。</p></li><li><p>访问（接入）控制：在任一时刻觉得哪个设备拥有链路使用权。</p></li></ul><div align="center"><img src="/2019/计算机网络基础/链路层.png" style="width:80%"></div><h2 id="网络层功能概述"><a href="#网络层功能概述" class="headerlink" title="网络层功能概述"></a>网络层功能概述</h2><p>核心功能：</p><ol><li>负责为分组交换网上的不同主机提供通信服务。</li><li>选择合适的路由，是源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</li></ol><p>解决的问题：</p><ul><li><p>逻辑寻址：全局唯一逻辑地址，确保数据分组被送达的主机，如IP地址。</p></li><li><p>路由和分组转发：确保在网络中数据能从源主机到目的主机</p><div align="center"><img src="/2019/计算机网络基础/网络层.png" style="width:70%"></div></li></ul><h2 id="传输层功能"><a href="#传输层功能" class="headerlink" title="传输层功能"></a>传输层功能</h2><p>核心功能：负责向两个主机中进程之间的通信提供服务。</p><p>解决的问题：</p><ul><li><p>分段与重组：网络层传输的分组大小是有限制的。应用层的</p></li><li><p>SAP寻址：确保将完整报文提交给正确进程，如端口号</p><ul><li>SAP：Service Access Point，在同一系统中相邻两层的实体进行交互的地方。</li></ul></li><li>连接控制：有两种协议，面向连接的TCP和无连接的UDP。</li><li>流量控制：匹配发送方和接收方的速度。</li><li>差错控制：如发送的报文接收方没有接受到或者接收方缓冲区由于满把报文丢弃该怎么处理。</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>核心功能：直接为用户的应用进程提供服务。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;本人是非通信专业学生，加上本身水平有限，对于物理层和计算机网络基础错误会较多，敬请指出。&lt;/p&gt;&lt;h2 id=&quot;信道&quot;&gt;&lt;a href=&quot;#信道
      
    
    </summary>
    
      <category term="计算机网络" scheme="https://isjinhao.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="https://isjinhao.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>10-索引</title>
    <link href="https://isjinhao.github.io/2019/10-%E7%B4%A2%E5%BC%95/"/>
    <id>https://isjinhao.github.io/2019/10-索引/</id>
    <published>2019-03-26T07:29:37.000Z</published>
    <updated>2019-03-26T12:48:34.366Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><h2 id="索引基础"><a href="#索引基础" class="headerlink" title="索引基础"></a>索引基础</h2><p>使用索引是因为索引是查询性能优化最有效的手段。Mysql中的索引分为两种：<code>B+树</code>和<code>Hash表</code>，但是我们在这里只介绍基于<code>B+树</code>的索引。INNODB引擎也只支持<code>B+树</code>索引。</p><p>Mysql的索引是在存储引擎级别设置的。</p><h2 id="索引匹配原则"><a href="#索引匹配原则" class="headerlink" title="索引匹配原则"></a>索引匹配原则</h2><p>假如有如下表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> People(</span><br><span class="line">last_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">first_name <span class="built_in">varchar</span>(<span class="number">50</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">dob <span class="built_in">date</span> <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line">gender enum(<span class="string">'m'</span>, <span class="string">'f'</span>) <span class="keyword">not</span> <span class="literal">null</span>,</span><br><span class="line"><span class="keyword">key</span>(last_name, first_name, dob)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>对应的<code>B+树</code>如下：</p><div align="center"><img src="/2019/10-索引/举例B树.jpg"></div><p>建立的索引对如下类型的查询有效：</p><h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p>和索引中定义的所有列进行匹配，如查找姓名为<code>Cuba Allen</code>，出生于<code>1996-01-01</code>的人。</p><h3 id="匹配最左前缀"><a href="#匹配最左前缀" class="headerlink" title="匹配最左前缀"></a>匹配最左前缀</h3><p>前面提到的索引可用于查找所有姓为<code>Allen</code>的人，即只使用索引的第一列。</p><h3 id="匹配列前缀"><a href="#匹配列前缀" class="headerlink" title="匹配列前缀"></a>匹配列前缀</h3><p>也可以只匹配某一列的值的开头部分，例如前面提到的索引可用于查找所有以<code>J</code>开头的姓的人。这里使用了索引的第一列。</p><h3 id="匹配范围值"><a href="#匹配范围值" class="headerlink" title="匹配范围值"></a>匹配范围值</h3><p>例如前面提到的索引可用于查找姓在<code>Allen</code>和<code>Barrymore</code>之间的人。这里也只用了索引的第一列。</p><h3 id="精确匹配某一列并范围匹配另外一列"><a href="#精确匹配某一列并范围匹配另外一列" class="headerlink" title="精确匹配某一列并范围匹配另外一列"></a>精确匹配某一列并范围匹配另外一列</h3><p>前面提到的索引也可用于查找所有姓为<code>Allen</code>，并且名字是<code>K</code>开头的人。</p><h2 id="索引分类和创建"><a href="#索引分类和创建" class="headerlink" title="索引分类和创建"></a>索引分类和创建</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="普通索引"><a href="#普通索引" class="headerlink" title="普通索引"></a>普通索引</h4><p>MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值，纯粹为了查询数据更快一点。</p><h4 id="唯一索引"><a href="#唯一索引" class="headerlink" title="唯一索引"></a>唯一索引</h4><p>索引列中的值必须是唯一的，但是允许为空值，</p><h4 id="主键索引"><a href="#主键索引" class="headerlink" title="主键索引"></a>主键索引</h4><p>是一种特殊的唯一索引，不允许有空值。后面会有介绍，在INNODB中，主键索引是聚簇索引。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><h4 id="建表时创建"><a href="#建表时创建" class="headerlink" title="建表时创建"></a>建表时创建</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name </span><br><span class="line">(</span><br><span class="line">    [col_name data_type],</span><br><span class="line">    ...,</span><br><span class="line">[<span class="keyword">UNIQUE</span>] [<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>] [index_name] (col_name[<span class="keyword">length</span>], ...) [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="后期添加"><a href="#后期添加" class="headerlink" title="后期添加"></a>后期添加</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> table_name <span class="keyword">ADD</span> [<span class="keyword">UNIQUE</span>] [<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>] [index_name]</span><br><span class="line">(col_name[<span class="keyword">length</span>], ...) [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] [<span class="keyword">INDEX</span> | <span class="keyword">KEY</span>] index_name <span class="keyword">ON</span> table_name</span><br><span class="line">(col_name[<span class="keyword">length</span>], ...) [<span class="keyword">ASC</span> | <span class="keyword">DESC</span>]</span><br></pre></td></tr></table></figure><p><code>INDEX</code>和<code>KEY</code>具有相同的效果。<code>length</code>是指该列在<code>B+树</code>中的关键字所占的长度。</p><h2 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h2><h3 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h3><p>聚簇的意思是键值和数据行紧凑地存储在一起，因为无法把数据行放在两个不同的地方，所以一个表只有一个聚簇索引。而主键会被默认添加上聚簇索引，如果没有主键，<code>INNODB</code>会选择一个非空索引来替代，如果没有这样的索引，<code>INNODB</code>会隐式定义一个主键来作为聚簇索引。</p><div align="center"><img src="/2019/10-索引/聚簇索引.jpg"></div><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p>非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。又被称为二级索引。INNODB的二级索引其叶子结点上保存的是<code>KEY+PRIMARY COL</code>。</p><h3 id="INNODB索引"><a href="#INNODB索引" class="headerlink" title="INNODB索引"></a>INNODB索引</h3><div align="center"><img src="/2019/10-索引/聚簇索引INNODB.jpg"></div><p>注意：INNODB中主键索引就是聚簇索引。</p><h3 id="MyISAM索引"><a href="#MyISAM索引" class="headerlink" title="MyISAM索引"></a>MyISAM索引</h3><div align="center"><img src="/2019/10-索引/非聚簇索引MYISAM.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;索引基础&quot;&gt;&lt;a href=&quot;#索引基础&quot; class=&quot;headerlink&quot; title=&quot;索引基础&quot;&gt;&lt;/a&gt;索引基础&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>B树</title>
    <link href="https://isjinhao.github.io/2019/B%E6%A0%91/"/>
    <id>https://isjinhao.github.io/2019/B树/</id>
    <published>2019-03-25T07:39:51.000Z</published>
    <updated>2019-03-26T12:48:34.366Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><h2 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h2><h3 id="磁盘构造"><a href="#磁盘构造" class="headerlink" title="磁盘构造"></a>磁盘构造</h3><div align="center"><img src="/2019/B树/磁盘.jpg"></div><p>当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头（又叫磁头）下通过，就可以进行数据的读/写了。</p><p>一般磁盘分为固定头盘（磁头固定）和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。</p><p>活动头盘 （如上图）的磁头是可移动的。每一个盘面上只有一个磁头（磁头是双向的，因此正反盘面都能读写）。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的（行动整齐划一）。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。</p><h3 id="访问时间"><a href="#访问时间" class="headerlink" title="访问时间"></a>访问时间</h3><p>典型的磁盘访问时间包括以下三个部分：</p><ol><li>寻道时间$T_s$：$T_s = s$</li><li>旋转延迟时间$T_τ$：$T_t = \frac{1}{2r}$</li><li>磁盘访问时间 ：$T_t=\frac{b}{rN}$</li></ol><p>$s$是指磁头从当前位置定位到开始点的时间，$b$是传输的字节数，$r$是每秒的转数，$N$是一条磁道上的字节数。$总时间 = T_s + \frac{1}{2r} + \frac{b}{rN}$</p><p>这其中，时间开销最大的是$s$，台式机的旋转速度一般是7200转/分钟（RPM），即旋转一周需要8.33ms，所以式子中的$s$平均为4.165ms，而且磁臂的移动也需要时间，通常磁盘的平均存储时间是$8-11ms$。而硅存储的常见存取时间是50ns，即$s$约为一次存取时间200000倍。通常一页的长度为$2^{11}-2^{14}$，即使磁盘一般是一次读取连续的几个页面，定位到信息的时间也比存取信息的时间多。所以当大量数据存储在外存磁盘中时，需要一种合理高效的数据结构来降低访问外存的时间：B树。需要说一下，B树的英文名是<code>B-tree</code>，所以有时候有人会把<code>B树</code>叫做<code>B-树</code>，这两个名词是同一个意思。</p><p>B树的典型执行过程中，B树算法的运行时间取决于<code>DISK-READ</code>和<code>DISK-WRITE</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = a pointer to some object</span><br><span class="line">DISK-READ(x)</span><br><span class="line">operations of x</span><br><span class="line">DISK-WRITE(x)</span><br></pre></td></tr></table></figure><p>通常一个B树的结点和磁盘的一页一样大，这样一次读写操作能获取更多的信息。而每页能存储多少个数据和关键字大小有关。下图中的B树每个结点有1000个数据（B树中结点的度数为结点数据个数+1，见后面的定义），高度为2。所以它可以存储超过十亿个关键字，查找某个关键字至多进行两次磁盘访问。</p><div align="center"><img src="/2019/B树/B树举例.jpg"></div><h2 id="B树的定义"><a href="#B树的定义" class="headerlink" title="B树的定义"></a>B树的定义</h2><h3 id="B树的定义-1"><a href="#B树的定义-1" class="headerlink" title="B树的定义"></a>B树的定义</h3><ul><li><p>每个结点有如下属性：</p><ol><li>$x.n$：表示当前存储在结点$x$中的关键字个数。</li><li>每个结点中的关键字以非降序方式存放：$x.key_1 \leq x.key_2 \leq \cdots \leq x.key_n$。</li><li>$x.leaf$：一个布尔值，如果$x$是叶结点，则为$true$，否则为$false$。</li></ol></li><li><p>每个内部结点还包含包含$x.n+1$个指向其孩子的指针：$x.c_1, x.c_2, \cdots , x.c_n $，叶结点的$c_i$属性没有定义。</p></li><li><p>关键字$x.key_i​$对存储在各子树中的关键字范围加以分割：如果$k_i​$为任意一个存储在以$x.c_i​$为根的子树中的关键字，满足：$k_i \leq x.key_1 \leq k_2 \leq x.key_2 \leq \cdots \leq x.key_{x.n} \leq k_{x.n+1}​$。</p></li><li>每个叶结点具有相同的深度，即树的高度h。</li><li>每个结点关键字所包含的关键字个数有上界和下界。用一个被称为B树的最小度数的固定整数$t​$来表示这些界，$t \geq 2​$。<ol><li>除了根结点外的每个结点都至少有$t-1​$个关键字，因此，除了根结点以外的每个内部结点至少有$t​$个孩子。如果树非空，根结点至少有一个关键字。</li><li>每个结点至多可包含$2t-1$个关键字，因此一个内部结点至多可有$2t$个孩子，当一个结点恰好有$2t-1$个关键字时，该结点是满的。</li><li>$t=2​$的树是最简单的，每个内部结点有2个、3个或4个孩子。</li></ol></li></ul><p>那么为什么最小度数不能取1呢？因为最小度数取1之后，内部结点（设指向其的指针为p）可以包含0个关键字，此时包含0个关键字的结点只有一个孩子（设为c），这个结点就被浪费了，我们其实可以直接让p指向c。</p><h3 id="B树的高度"><a href="#B树的高度" class="headerlink" title="B树的高度"></a>B树的高度</h3><p>对任意一棵包含n（$n \geq 1​$）个关键字、最小度数为t的B树来说，有：$h \leq log_t{\frac{n+1}{2}}​$。证明：</p><p>假设根所在的层深度为0，则高度为h的B树在深度为1的层至少包含2个结点，在深度为2的层至少包含$2t$个结点，在深度为3的层至少包含$2t^2$个结点…直到深度为h的层至少包含$2t^{h-1}$个结点。可得关于关键字个数n的关键字：$n \geq 1+(t-1)\sum_{i=1}^h2t^i-1 = 1+2(t-1)(\frac{t^h-1}{t-1})=2t^h-1$</p><p>$\Longrightarrow t^h \leq (n+1)/2$</p><p>$\Longrightarrow h \leq log_t{\frac{n+1}{2}}$</p><h3 id="B树的阶"><a href="#B树的阶" class="headerlink" title="B树的阶"></a>B树的阶</h3><p>我们经常会遇到一个B数的术语：阶，假如树中的结点最多含有m个孩子，此B树的阶为m。当阶为偶数的时候，我们可以把定义中的$t$替换成$m/2$，但是当阶为奇数的时候就要考虑一个问题了，除根结点外的每个内部结点至少含有<code>ceil(m/2)</code>个结点还是<code>floor(m/2)</code>个结点？应该是<code>ceil(m/2)</code>，因为除了根结点每个结点的孩子个数满足：$t \leq keyNum \leq 2t$，如果取<code>floor(m/2)</code>会发现无法满足上式，所以<strong>一棵含有n个总关键字数的m阶的B树的最大高度是</strong>：$log_{ceil(m/2)}(n+1)/2$。</p><h2 id="B树的操作"><a href="#B树的操作" class="headerlink" title="B树的操作"></a>B树的操作</h2><p>以下的操作都遵循两个规定：</p><ul><li>B树的根结点始终在主存中，这样就不用对根做<code>DISK-READ</code>操作。然而，当根结点被改变后需要对根结点做一次<code>DISK-WRITE</code>操作。</li><li>任何被当做参数的结点在被传递之前，都要对它们先做一次<code>DISK-READ</code>操作。</li></ul><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>设$x$是根结点，被搜索的关键字是$k$。</p><div align="left"><img src="/2019/B树/搜索.jpg"></div><p>需要说明一下，伪代码中$key$和$c​$的起始下标都为1。NIL代表空。</p><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入的时候会遇到两种情况：</p><ol><li>将新的关键字插在一个已经存在但<strong>未满</strong>的结点上：直接插入；</li><li>将新的关键字插在一个已经存在但<strong>已满</strong>的结点上：分裂后插入；</li></ol><h4 id="分裂"><a href="#分裂" class="headerlink" title="分裂"></a>分裂</h4><p>将一个满的结点$y$（有$2t-1$个关键字）按照中间关键字分裂成两个各含有$t-1$个关键字的结点，中间关键字被升到$y$的父结点。如果$y​$的父结点也是满的，也需要分裂，最终满结点的分裂会向上传播。如果向上传播时全程都是满结点会把根结点分裂，使B树的高度增1。分裂是使B树增高的唯一办法。</p><p>但是在实际操作中不是等到找出插入过程中实际要分裂的结点才做分裂，而是在沿着树向下查找时分裂所有遇到的满结点，这样就能保证在插入的时候节点一定非满。</p><div align="left"><img src="/2019/B树/分裂.jpg"></div><p>$x$是被分裂的结点的父节点，$y$是$x$的第$i​$个孩子。</p><div align="center"><img src="/2019/B树/分裂举例.jpg"></div><h4 id="非满结点插入"><a href="#非满结点插入" class="headerlink" title="非满结点插入"></a>非满结点插入</h4><div align="left"><img src="/2019/B树/非满结点插入.jpg"></div><p>$x$是被插入的节点，$k$是插入的键。解释几行代码：</p><ul><li>12行：被操作的节点从磁盘中读入到内存中，然后在内存中进行操作。</li><li>7行+17行：每次插入的都是叶节点。</li></ul><h4 id="完整插入过程"><a href="#完整插入过程" class="headerlink" title="完整插入过程"></a>完整插入过程</h4><div align="left"><img src="/2019/B树/完整插入过程.jpg"></div><p>此时对根的分裂需要创建两个节点，而且对根的分裂是B树长高的唯一办法。而且在分裂之后我们会发现根节点必然会有一个关键字，这也对应了定义中的B树的根至少有两个孩子。</p><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><p>分配空节点：</p><div align="left"><img src="/2019/B树/创建.jpg"></div><p>分配之后循环调用插入即可。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>在删除时需要注意两个部分：</p><ol><li>除根节点外，被删除关键字的节点在删除后仍然要满足$keyNum \geq t-1$。</li><li>删除后需要重新安排这个结点的孩子。</li></ol><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ol><li>如果关键字$k$在结点$x$中，并且$x$是叶节点，从$x$中删除$k$</li><li>如果关键字$k$在结点$x$中，但$x$是内部非根节点：上移孩子结点中的某相近元素（“左孩子最右边的节点”或“右孩子最左边的节点”）到父节点中，并且递归被上移的孩子。删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于$ceil(m/2)-1$，则需要看其某相邻兄弟结点是否贫困（结点中元素个数等于$ceil(m/2)-1$）如果非贫困，则父节点下降一个元素来此节点，兄弟结点上升一个元素。如果其相邻兄弟都贫困，则该结点与其相邻的某一兄弟结点进行“合并“成一个结点。</li></ol><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><div align="center"><img src="/2019/B树/B树删除.jpg"></div><ul><li>刪除H：直接删除</li><li>删除T：W上升到T的位置，4上升到W的位置</li><li>删除R：删除导致只有1个元素，已经小于最小元素数目$ceil(5/2)-1=2$，由于右相邻兄弟结点不贫困，所以先向父节点借一个元素T下移到该叶子结点中，代替原来S的位置，S前移；然后W上移到父结点中，X、Y、Z依次前移。</li></ul><div align="center"><img src="/2019/B树/删除2.jpg"></div><ul><li>删除E：因为E所在的结点和相邻的兄弟结点的关键字都刚好达标，删除后不能再向父节点借元素，所以需要该节点与某相邻兄弟结点进行合并操作；首先移动父结点中的元素（该元素在两个需要合并的两个结点元素之间）下移到其子结点中，然后将这两个结点进行合并成一个结点。所以在该实例中，咱们首先将父节点中的元素D下移到已经删除E而只有F的结点中，然后将含有D和F的结点与含有A和C的相邻兄弟结点进行合并成一个结点。但是此时还没有结束，此时的情况如下图第一幅，此时父节点只包含一个元素G，没达标。如果这个问题结点的相邻兄弟比较丰满，则可以向父结点借一个元素。假设这时右兄弟结点（含有Q,X）含有的元素个数大于2，咱们可以将M下移到元素很少的子结点中，将Q上移到M的位置，但此时咱们没有办法去借一个元素，只能与兄弟结点进行合并成一个结点，而根结点中的唯一元素M下移到子结点，即树的高度减少一层。</li></ul><div align="center"><img src="/2019/B树/删除3.jpg"></div><div align="center"><img src="/2019/B树/删除4.jpg"></div><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>在B树中，我们做操作的时候都默认了关键字和其对应的数据都存在一个页面中，但是实际上可以只存储关键字，而且仅存关键字可以让每页能存储更多的数据。基于此点和为了更好的在文件系统中存取数据，诞生了B+树。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><code>B+树</code>可以被视为每个节点仅包含键（不是键值对），并且链接了各叶节点叶的B树。和B树的区别如下：</p><ul><li>所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接。 （而B树的叶子节点并没有包括全部需要查找的信息）。</li><li>所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 （而B树的非终节点也包含需要查找的有效信息）</li></ul><div align="center"><img src="/2019/B树/B+树.jpg"></div><h3 id="为什么数据库使用B-树作为索引"><a href="#为什么数据库使用B-树作为索引" class="headerlink" title="为什么数据库使用B+树作为索引"></a>为什么数据库使用B+树作为索引</h3><ul><li>B+树的磁盘读写代价更低。B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</li></ul><ul><li>B树在提高了磁盘IO性能的同时并没有解决元素遍历的效率低下的问题。而B+树只要遍历叶子节点就可以实现整棵树的遍历。</li><li><code>B+树</code>对<code>range-query</code>的支持很强大。比如要查<code>5-10</code>之间的，<code>B+树</code>一把到5这个标记，再一把到10，然后串起来就行了，B树就非常麻烦。</li></ul><h3 id="分裂-1"><a href="#分裂-1" class="headerlink" title="分裂"></a>分裂</h3><p>B+树的分裂和B树没有太大区别，只是分裂后注意叶子结点需要有链接到下个结点的指针。</p><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>B*树是B+树的变体，在B+树的基础上（所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针）:</p><ul><li>B*树中非根和非叶子结点再增加指向兄弟的指针；</li><li>B*树定义了非叶子结点关键字个数至少为$ceil((2/3) \ast m)$，即块的最低使用率为2/3（代替B+树的1/2）。</li></ul><div align="center"><img src="/2019/B树/Bast.jpg"></div><h3 id="分裂-2"><a href="#分裂-2" class="headerlink" title="分裂"></a>分裂</h3><p>当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字（因为兄弟结点的关键字范围改变了）；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>B树及其变形可以非常好的处理一维空间存储的问题。它的思想就是把一维直线分为若干段线段，当我们查找满足某个要求的点的时候，只要去查找它所属的线段即可。也可以说要查找某一满足条件的点，先去找到满足条件的线段，然后遍历所在线段上的点，即可找到答案。</p><div align="center"><img src="/2019/B树/B树.jpg"></div><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li><p><code>B树</code>：有序数组+平衡多叉树；</p></li><li><p><code>B+树</code>：有序数组链表+平衡多叉树；</p></li><li><p><code>B*树</code>：一棵丰满的B+树。</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/v_JULY_v/article/details/6530142" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/details/6530142</a></li><li><a href="https://en.wikipedia.org/wiki/B%2B_tree#Overview" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/B%2B_tree#Overview</a></li><li><a href="https://en.wikipedia.org/wiki/B-tree" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/B-tree</a></li><li>算法导论</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;磁盘访问时间&quot;&gt;&lt;a href=&quot;#磁盘访问时间&quot; class=&quot;headerlink&quot; title=&quot;磁盘访问时间&quot;&gt;&lt;/a&gt;磁盘访
      
    
    </summary>
    
      <category term="DSA" scheme="https://isjinhao.github.io/categories/DSA/"/>
    
    
      <category term="DSA" scheme="https://isjinhao.github.io/tags/DSA/"/>
    
      <category term="树" scheme="https://isjinhao.github.io/tags/%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>09-Mysql结构和存储引擎</title>
    <link href="https://isjinhao.github.io/2019/09-Mysql%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/"/>
    <id>https://isjinhao.github.io/2019/09-Mysql结构和存储引擎/</id>
    <published>2019-03-24T13:27:56.000Z</published>
    <updated>2019-03-25T07:39:25.800Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><h2 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h2><div align="center"><img src="/2019/09-Mysql结构和存储引擎/Mysql体系结构.jpg"></div><p>Mysql大致可以被分为四层：</p><h3 id="第一层"><a href="#第一层" class="headerlink" title="第一层"></a>第一层</h3><ul><li>Connectors指的是不同语言中与SQL的交互</li></ul><h3 id="第二层"><a href="#第二层" class="headerlink" title="第二层"></a>第二层</h3><ul><li>Management Serveices &amp; Utilities：系统管理和控制工具，例如备份恢复、Mysql复制、集群等</li><li>Connection Pool: 连接池，管理缓冲用户连接、用户名、密码、权限校验、线程处理等需要缓存的需求</li><li>SQL Interface: SQL接口，接受用户的SQL命令，并且返回用户需要查询的结果。比如<code>select * from</code>就是调用SQL Interface。</li><li>Parser: 解析器，SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本， 主要功能：<ol><li>将SQL语句分解成数据结构，并将这个结构传递到后续步骤，以后SQL语句的传递和处理就是基于这个结构的</li><li>如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的</li></ol></li><li><p>Optimizer：查询优化器，SQL语句在查询之前会使用查询优化器对查询进行优化。他使用的是“选取-投影-联接”策略进行查询。 用一个例子就可以理解：<code>select uid,name from user where gender = 1;</code></p><ul><li>先根据where语句进行选取，而不是先将表全部查询出来以后再进行gender过滤</li><li>再根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤</li><li>再将这两个查询条件联接起来生成最终查询结果</li></ul></li><li><p>Cache和Buffer（高速缓存区）：查询缓存，如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。 通过LRU算法将数据的冷端溢出，未来得及时刷新到磁盘的数据页，叫脏页。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等。</p></li></ul><h3 id="第三级"><a href="#第三级" class="headerlink" title="第三级"></a>第三级</h3><ul><li>Engine：存储引擎。存储引擎是MySql中具体的与文件打交道的子系统。现在有很多种存储引擎，各个存储引擎的优势各不一样，最常用的<code>MyISAM</code>，<code>InnoDB</code>，<code>BDB</code>。默认下<code>MySql</code>是使用InnoDB引擎。</li></ul><h3 id="第四级"><a href="#第四级" class="headerlink" title="第四级"></a>第四级</h3><p>外存中真正存储数据的物理空间。</p><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><p>Mysql中真正和外存打交道的是存储引擎。一般有两种最常见的引擎：</p><h3 id="INNODB"><a href="#INNODB" class="headerlink" title="INNODB"></a>INNODB</h3><div align="center"><img src="/2019/09-Mysql结构和存储引擎/INNODB.jpg"></div><ul><li><p>是缓存层，由一个大的innodb buffer pool和很多个其他小的内存组件组成，用来缓冲数据的，innodb的数据读取写入不是直接操作文件，而是从文件加载到缓存，在缓冲里做操作，再flush到磁盘文件。所以INNODE可以支持事务。</p></li><li><p>是各种后台线程，例如IO线程、日志线程、监控线程等；</p></li><li><p>是各种数据文件层，例如INNODB的数据文件、redo log等；</p></li></ul><h3 id="MYISAM"><a href="#MYISAM" class="headerlink" title="MYISAM"></a>MYISAM</h3><ul><li>MYISAM存储引擎的数据组织形式是一种堆表，和索引组织表相区别（INNODB的数据组织形式是索引组织表）。 例如插入一条数据id=2（d为主键，表里已经存在id=1和id=3数据）。<ul><li>MYISAM存储引擎：如果插入id=2，数据的插入位置和id=1 id=3无关系，也就是无序的； 堆表的插入特性是无序的。</li><li>INNODB存储引擎：如果插入id=2，会插入到id=1和id=3之间，因为INNODB是索引组织表是有有序的；索引组织表的最大特点是根据主键去查询效率非常快。</li></ul></li><li>MYISAM存储引擎不支持事务；</li><li>INNODB存储引擎的缓存不缓存数据，只缓存索引。数据缓存是交给操作系统的内存来缓存的。这种会有问题：如果查询一个大表，会消耗大量操作系统内存，如果表中碎片很大可能会浪费大量操作系统内存。</li><li>锁粒度较大：使用的是读写锁（读的时候不允许写，写的时候不允许读，只有读的时候允许读）</li></ul><p>参考：<a href="https://www.cnblogs.com/zhoubaojian/articles/7866231.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhoubaojian/articles/7866231.html</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;MySQL体系结构&quot;&gt;&lt;a href=&quot;#MySQL体系结构&quot; class=&quot;headerlink&quot; title=&quot;MySQL体系结构
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>08-Mysql的锁</title>
    <link href="https://isjinhao.github.io/2019/08-Mysql%E7%9A%84%E9%94%81/"/>
    <id>https://isjinhao.github.io/2019/08-Mysql的锁/</id>
    <published>2019-03-24T12:31:10.000Z</published>
    <updated>2019-03-25T00:45:05.850Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><p>数据库的锁按照不同的分类可以分成很多类，常见的分类如下：</p><h2 id="悲观锁-amp-乐观锁"><a href="#悲观锁-amp-乐观锁" class="headerlink" title="悲观锁 &amp; 乐观锁"></a>悲观锁 &amp; 乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁就是在操作数据时，总是认为操作会出现数据冲突，所以在进行每次操作时都要通过获取锁才能进行对相同数据的操作，这点跟<code>java</code>中的<code>synchronized</code>很相似，所以悲观锁需要耗费较多的时间。悲观锁是由数据库自己实现了的，要用的时候，我们直接调用数据库的相关语句就可以了。不用考虑悲观锁，它对于应用程序员是透明的。</p><p>说到这里，由悲观锁涉及到的另外两个锁概念就出来了，它们就是共享锁与排它锁。<strong>共享锁和排它锁是悲观锁的不同的实现</strong>，它俩都属于悲观锁的范畴。参考：<a href="https://isjinhao.github.io/2019/06-%E4%BA%8B%E5%8A%A1/#more">https://isjinhao.github.io/2019/06-%E4%BA%8B%E5%8A%A1/#more</a></p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>首先先说一下，乐观锁不是锁，只是人们都习惯这样叫。对于乐观锁来说在操作数据时，总是认为操作不会出现数据冲突，所以不会上锁。那么如何控制并发问题呢？这其实是在应用程序级完成的功能，一般来说可以用数据版本（<code>Version</code>）记录机制实现。何谓数据版本？即为数据增加一个版本标识，一般是通过为数据库表增加一个数字类型的<code>version</code>字段来实现。当读取数据时，将<code>version</code>字段的值一同读出，数据每更新一次，对此<code>version</code>值加1。当我们提交更新的时候，判断数据库表对应记录的当前版本信息与第一次取出来的<code>version</code>值进行比对，如果数据库表当前版本号与第一次取出来的<code>version</code>值相等，则予以更新，否则认为是过期数据。</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><p>数据库表设计，三个字段，分别是<code>id</code>，<code>value</code>，<code>version</code>。</p><p>每次更新表中的value字段时，为了防止发生冲突，需要这样两步操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="keyword">id</span>,<span class="keyword">value</span>,<span class="keyword">version</span> <span class="keyword">from</span> <span class="keyword">TABLE</span> <span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="keyword">TABLE</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">value</span>=<span class="number">2</span>,<span class="keyword">version</span>=<span class="keyword">version</span>+<span class="number">1</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">id</span>=<span class="comment">#&#123;id&#125; and version=#&#123;version&#125;;</span></span><br></pre></td></tr></table></figure><h2 id="按加锁的粒度分"><a href="#按加锁的粒度分" class="headerlink" title="按加锁的粒度分"></a>按加锁的粒度分</h2><h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>是Mysql中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分ySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。特点是开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。</p><h3 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h3><p>行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。分为共享锁和排他锁。特点是开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。</p><h3 id="页级锁"><a href="#页级锁" class="headerlink" title="页级锁"></a>页级锁</h3><p>表级锁是Mysql中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。BDB支持页级锁。特点是开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</p><p>存储引擎参考：<a href="https://isjinhao.github.io/2019/09-Mysql%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/#more">https://isjinhao.github.io/2019/09-Mysql%E7%BB%93%E6%9E%84%E5%92%8C%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/#more</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;数据库的锁按照不同的分类可以分成很多类，常见的分类如下：&lt;/p&gt;&lt;h2 id=&quot;悲观锁-amp-乐观锁&quot;&gt;&lt;a href=&quot;#悲观锁-amp-乐
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="MySQL" scheme="https://isjinhao.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>09-磁盘存储器的管理</title>
    <link href="https://isjinhao.github.io/2019/09-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86/"/>
    <id>https://isjinhao.github.io/2019/09-磁盘存储器的管理/</id>
    <published>2019-03-21T03:33:26.000Z</published>
    <updated>2019-03-23T13:05:30.596Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><p>文件管理的目标是管理文件的组织方式，管理文件的访问权等。而磁盘存储器的管理是管理存储器的使用，如何高效利用存储器。他俩是棋与棋盘的关系。</p><h2 id="连续组织方式"><a href="#连续组织方式" class="headerlink" title="连续组织方式"></a>连续组织方式</h2><p>文件的信息存放在若干连续的物理块中。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/连续组织方式.jpg" style="width:70%"></div><ul><li>优点<ul><li>简单</li><li>支持顺序存取和随机存取</li><li>顺序存取速度快，所需的磁盘寻道次数和寻道时间最少</li></ul></li><li>缺点<ul><li>文件不能动态增长（预留空间：浪费、重新分配和移动）</li><li>不利于文件插入和删除</li><li>外部碎片问题</li></ul></li></ul><h2 id="链接组织方式"><a href="#链接组织方式" class="headerlink" title="链接组织方式"></a>链接组织方式</h2><h3 id="隐式链接"><a href="#隐式链接" class="headerlink" title="隐式链接"></a>隐式链接</h3><p>在文件的目录中记录该文件的第一和最后一个盘块的指针，每一个盘块的指针指向文件的下一物理块号。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/隐式链接.jpg"></div><ul><li>优点<ul><li>文件可动态增长</li><li>有利于文件的插入和删除</li><li>提高了磁盘空间利用率,不存在外部碎片问题</li></ul></li><li>缺点<ul><li>存取速度慢，不适于随机存取</li><li>可靠性问题，如指针出错</li><li>更多的寻道次数和寻道时间</li><li>链接指针占用一定的空间</li></ul></li></ul><h3 id="显示链接"><a href="#显示链接" class="headerlink" title="显示链接"></a>显示链接</h3><p>将链接文件各物理块的指针显示地放在内存的一张链接表（文件分配表，File Allocation Table）中。在FCB的物理地址中填写其首指针所对应的盘块号。由于文件分配表示存储在内存中的，可以大大减少访问磁盘的次数。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/显示链接.jpg" style="width:70%"></div><h3 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h3><p>微软公司早、中期推出的操作系统一直都是采用的FAT技术，即利用文件分配表FAT来记录每个文件中所有盘块之间的链接。FAT中引入了“卷”的概念，支持将一个物理磁盘分成四个逻辑磁盘，每个逻辑磁盘就是一个卷（也称为分区），每个卷都可以被单独格式化和使用。把盘块作为基本分配单位，同时每个分区中都配有两张相同的文件分配表FAT1和FAT2。</p><p>FAT技术的发展有三个阶段：FAT12、FAT16和FAT32</p><h4 id="FAT12"><a href="#FAT12" class="headerlink" title="FAT12"></a>FAT12</h4><p>FAT表的每个表项占用12个bit。所以最多有$2^{12}$个表项，每个盘块的大小是512B，则每个磁盘分区的容量是2MB，能处理的磁盘最大容量是8MB。</p><p>为了增大FAT能管理的最大容量，引入了“簇”的概念，每个簇是一组相邻的扇区，这样如果分配时以簇为单位进行分配就能管理更大的磁盘容量，但是相应的簇内零头也会更大，降低磁盘的利用率。</p><h4 id="FAT16"><a href="#FAT16" class="headerlink" title="FAT16"></a>FAT16</h4><p>FAT表的每个表项占用16个bit。最多有$2^{16}$个表项。</p><h4 id="FAT32"><a href="#FAT32" class="headerlink" title="FAT32"></a>FAT32</h4><p>FAT表的每个表项占用16个bit。最多有$2^{32}$个表项。同时每个簇固定为4KB。所以最大可管理$4 \ast 2^{10} \ast 2^{32} = 2TB$大小的空间。</p><h3 id="NTFS"><a href="#NTFS" class="headerlink" title="NTFS"></a>NTFS</h3><h2 id="索引组织方式"><a href="#索引组织方式" class="headerlink" title="索引组织方式"></a>索引组织方式</h2><h3 id="单级索引组织方式"><a href="#单级索引组织方式" class="headerlink" title="单级索引组织方式"></a>单级索引组织方式</h3><p>一个文件的信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构索引表，并将这些块的块号存放在一个索引表中。一个索引表就是磁盘块地址数组，其中第i个条目指向文件的第i块。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/索引组织方式.jpg" style="width:60%"></div>·<br><br>### 多级索引组织方式<br><br><div align="center"><img src="/2019/09-磁盘存储器的管理/多级索引组织方式.jpg"></div><h3 id="增量式索引组织方式"><a href="#增量式索引组织方式" class="headerlink" title="增量式索引组织方式"></a>增量式索引组织方式</h3><p>可以更好的满足大、中、小文件的组织。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/增量组织方式.jpg"></div><h2 id="文件存储空间的管理"><a href="#文件存储空间的管理" class="headerlink" title="文件存储空间的管理"></a>文件存储空间的管理</h2><p>文件存储空间的管理包括空闲块的组织分配和回收。</p><h3 id="空闲表法"><a href="#空闲表法" class="headerlink" title="空闲表法"></a>空闲表法</h3><p>把一个连续未分配区域称为“空闲文件”，系统为所有空闲文件单独建立一个目录。表目内容：序号，第一个空白块号，空白块个数。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/空闲链表.jpg"></div><ul><li><p>分配算法：内存管理中的首次适应算法、循环首次适应算法。</p></li><li><p>合并：空闲区邻接合并</p></li></ul><h3 id="空闲链表法"><a href="#空闲链表法" class="headerlink" title="空闲链表法"></a>空闲链表法</h3><p>空闲盘块链：所有空闲盘块拉成一条链，分配时从头分配，回收时链接在尾部。</p><p>空闲盘区链：每个连续的盘块组成一个盘区，每个盘区包含本盘区的大小和下一个盘区的地址。</p><h3 id="位示图法"><a href="#位示图法" class="headerlink" title="位示图法"></a>位示图法</h3><p>用一串二进制位反映磁盘空间中分配使用情况，每个物理块对应一位，分配物理块为1，否则为0。申请物理块时，可以在位示图中查找为0的位，返回对应物理块号；归还时；将对应位转置0。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/位示图法.jpg"></div><h3 id="成组链接法（重点）"><a href="#成组链接法（重点）" class="headerlink" title="成组链接法（重点）"></a>成组链接法（重点）</h3><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接法.jpg"></div><ul><li>把所有的空闲盘块按每n个一组分成m个组。</li><li>最后一个组放在内存的空闲盘块号栈中，其他组存在外存上。空闲盘块号栈是一个临界资源，只允许一个进程同时访问。</li><li><p>数据结构，一个size为n+1的栈。图上是一个倒着的的栈（栈底在上方，栈顶在下方）</p></li><li><p>一个n+1的栈实际可用盘块只有n（图上只有99个可用盘块），因为栈底是一个计数器，指示当前有多少个可用盘块，但是可用盘块中有一个是指向下一个组，即stack[1]指向下一个组。如果stack[1]==0表示此时是最后一组。</p></li><li>分配时从栈顶开始向下分配，直至分配出n-1个盘块，此时如果再想分配一个块就需要把下一个组调入空闲盘块号栈。调入后新组覆盖旧组。<strong>然后把新组在外存中占用的盘块分配出去。</strong></li><li>回收时从栈底向上回收，如果计数器==100时还有空闲盘块（设这个盘块编号为p）要回收，就把空闲盘块号栈内的组取出来存在p中，在空闲盘块号栈内新开辟一个组，新组的stack[1]指向p。</li></ul><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>此题题目及来源：<a href="https://blog.csdn.net/ajay666/article/details/73569654" target="_blank" rel="noopener">https://blog.csdn.net/ajay666/article/details/73569654</a></p><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接例.jpg"></div><p>分配3个盘块后，回收它所占的5个盘块，回收的盘块号依次为700、711、703、788、701，画出分配回收过程。</p><h4 id="第一次分配"><a href="#第一次分配" class="headerlink" title="第一次分配"></a>第一次分配</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接例1.jpg"></div><h4 id="第二次分配"><a href="#第二次分配" class="headerlink" title="第二次分配"></a>第二次分配</h4><p>注意：300号盘块中存储的组信息调入空闲盘块号栈之后其自己也可以被分配。</p><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接例2.jpg"></div><h4 id="第三次分配"><a href="#第三次分配" class="headerlink" title="第三次分配"></a>第三次分配</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/成组链接例3.jpg"></div><h4 id="第一次回收"><a href="#第一次回收" class="headerlink" title="第一次回收"></a>第一次回收</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/第一次回收.jpg"></div><h4 id="第二次回收"><a href="#第二次回收" class="headerlink" title="第二次回收"></a>第二次回收</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/第二次回收.jpg"></div><h4 id="第三次-amp-第四次-amp-第五次回收"><a href="#第三次-amp-第四次-amp-第五次回收" class="headerlink" title="第三次&amp;第四次&amp;第五次回收"></a>第三次&amp;第四次&amp;第五次回收</h4><div align="center"><img src="/2019/09-磁盘存储器的管理/第三四五次回收.jpg"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;文件管理的目标是管理文件的组织方式，管理文件的访问权等。而磁盘存储器的管理是管理存储器的使用，如何高效利用存储器。他俩是棋与棋盘的关系。&lt;/p&gt;
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>为什么硬链接不能作用于目录</title>
    <link href="https://isjinhao.github.io/2019/%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%B8%8D%E8%83%BD%E4%BD%9C%E7%94%A8%E4%BA%8E%E7%9B%AE%E5%BD%95/"/>
    <id>https://isjinhao.github.io/2019/为什么硬链接不能作用于目录/</id>
    <published>2019-03-21T01:36:08.000Z</published>
    <updated>2019-03-23T03:23:08.203Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><p>笔者最初遇见这个问题的时候是因为知道了在Linux系统中，目录其实也是一种文件，只不过是一种比较特殊的文件，既然都是文件，那为什么不能对它做硬链接呢？想弄明白这个，就需要知道两个知识，目录和文件共享。因为链接的目的就是要实现文件共享。</p><p>通常可以定义为文件控制块（FCB）的有序集合。但是并不是说目录中的每一个目录项都是一个FCB，只能是每一个目录项都能唯一确定一个FCB。这是由于如果每个目录项都是FCB会引起文件共享问题。比如下图：对于文件<code>F8</code>，<code>D5:p</code>、<code>D6:e</code>、<code>D3:p</code>都保存了<code>F8</code>的物理地址，即从某个盘块开始，总长度多少等。此时如果<code>D6:e</code>对<code>F8</code>进行了删除操作，<code>D5:p</code>和<code>D3:P</code>都无法察觉，仍然会认为在它们存储的位置上有文件，即一个目录项对文件的操作对其他目录项来说是不可见的。</p><div align="center"><img src="/2019/为什么硬链接不能作用于目录/有向无环图.jpg" width="80%;"></div><p>为了解决这个问题，引入索引节点。将文件的物理地址和其他的属性放在索引结点中，只在目录项中存放文件名和指向索引结点的指针。任何用户对文件进行操作，引起相应索引结点内容的改变。此种方法即Linux中的硬链接。</p><div align="center"><img src="/2019/为什么硬链接不能作用于目录/利用索引节点.jpg" width="60%;"></div><p>所以如果我们对文件做硬链接，比如对<code>Test r</code>做硬链接生成<code>thirdHardLink</code>，那么就是<code>thirdHardLink</code>的指针指向索引节点，索引节点的<code>count</code>修改为3。</p><p>Linux限制了对目录做硬链接，那么假如我们是设计者，想对一个目录做硬链接可以怎么做呢？</p><ul><li><p>第一种方法是把对目录生成的硬链接单独作为一种文件类型，如果我们想使用目录中的某个文件时，操作系统的处理步骤是<code>HardLinkDir-&gt;Dir-&gt;指向索引节点的指针指针-&gt;索引节点</code>。可以看出此种方法的代价很大。</p><div align="center"><img src="/2019/为什么硬链接不能作用于目录/设计1.jpg"></div></li><li><p>第二种方法是把目录的每个目录项拷贝一份，但这样不就是拷贝<code>cp</code>了吗，没有必要再实现对目录的硬链接了。</p></li><li><p>第三种方法是把每个目录项的文件名拷贝一份，<code>HardLink</code>的指针指向原目录项的指针位置。但是这种方法也需要把对目录生成的硬链接单独作为一种文件类型，代价很大。</p><div align="center"><img src="/2019/为什么硬链接不能作用于目录/设计3.jpg"></div></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;笔者最初遇见这个问题的时候是因为知道了在Linux系统中，目录其实也是一种文件，只不过是一种比较特殊的文件，既然都是文件，那为什么不能对它做硬链
      
    
    </summary>
    
      <category term="Linux" scheme="https://isjinhao.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://isjinhao.github.io/tags/Linux/"/>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>08-文件管理</title>
    <link href="https://isjinhao.github.io/2019/08-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/"/>
    <id>https://isjinhao.github.io/2019/08-文件管理/</id>
    <published>2019-03-20T11:14:43.000Z</published>
    <updated>2019-03-23T03:23:08.206Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><h2 id="文件管理概述"><a href="#文件管理概述" class="headerlink" title="文件管理概述"></a>文件管理概述</h2><p>计算机中有很多的程序和数据都是保存在外存中，在需要使用的时候才调入内存中。而如何保存这些信息是很重要的问题，因为不同类型的文件存储的数据格式不同，但这些格式却必须“迎合”硬件只能存储二进制数据的硬性条件。所以操作系统提供了文件管理的功能，让使用者能在不了解文件特性和外存特性的情况下完成文件的存储和查找等功能。同时还提供了文件共享和安全管理等功能。</p><h3 id="文件系统-amp-文件"><a href="#文件系统-amp-文件" class="headerlink" title="文件系统 &amp; 文件"></a>文件系统 &amp; 文件</h3><p>操作系统中负责管理和存储文件信息的软件称为文件管理系统，简称文件系统。包含：文件系统的接口，对对象操纵和管理的软件集合，对象及属性三部分。它负责对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。包含创建文件、删除文件等功能。</p><p>文件是指具有文件名的若干相关元素的集合，可以分成有结构文件和无结构文件，无结构文件可以看成一个字符流。有结构文件是由一组记录的集合，记录又是一组数据项的集合。</p><ul><li><p>数据项：用来描述一个对象的某种属性的字符集。例如学生的学号、姓名等。</p></li><li><p>记录：一组数据项的集合，用来描述一个对象在某方面的属性，例如学生的成绩。能唯一标识一个记录的一个或多个数据项叫做关键字。</p></li></ul><h3 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h3><p>不同的文件类型由于本身存储的信息具有不同的结构，在管理的时候也是不同。所以文件会被分成很多类型，下面是常用的文件分类方法：</p><ul><li><p>按用途分类：系统文件、库文件、用户文件。</p></li><li><p>按文件中数据的形式分类：源文件、目标文件、可执行文件。</p></li><li><p>按存储控制属性分类：可读、可写、可执行文件。</p></li><li><p>按组织形式和处理方法分类：普通文件、目录文件、特殊文件。</p></li></ul><h3 id="剖析文件和目录"><a href="#剖析文件和目录" class="headerlink" title="剖析文件和目录"></a>剖析文件和目录</h3><p>我们刚才在定义中说道，文件是指具有文件名的若干相关元素的集合，在有结构文件中这些元素是数据项集合的集合，在无结构文件指的是字符流。所以文件的概念中本身是：</p><div align="center"><img src="/2019/08-文件管理/文件.png"></div><h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p>文件系统从底层到高层可分成三部分：对象及其属性、对对象操纵和管理的软件集合、文件系统接口：</p><ul><li><p>对象及其属性：文件管理系统管理的文件如下：</p><ul><li><p>文件：在文件管理系统中有着各种不同类型的文件，它们都作为文件管理的直接对象。</p></li><li><p>目录：用于对文件的存储和检索，目录的每个目录项包含了一个文件或目录的信息。</p></li><li><p>磁盘存储空间：文件和目录必定占用存储空间，对这部分空间的有效管理不仅能提高外存的利用率，而且能提高对文件的存取速度。</p></li></ul></li><li><p>对对象操纵和管理的软件集合：该层是文件管理系统的核心部分。文件系统的功能大多是在这一层实现的。如：文件存储的管理、文件目录的管理、将文件的逻辑地址转换为物理地址的机制、文件读写控制的管理、文件的共享和保护等功能。这些功能被可分为四层：</p><ul><li><p>I/O控制层：文件系统的最底层、主要由磁盘驱动程序等组成。</p></li><li><p>基本文件系统层：主要用于处理内存和磁盘之间数据块的交换。</p></li><li><p>基本I/O管理程序：完成与磁盘I/O有关的事务，如将文件的逻辑块号转换为物理块号、管理磁盘中的空闲盘块、I/O缓冲的指定等。</p></li><li><p>逻辑文件系统：管控对文件的操作，如控制用户或应用程序对文件的读写等。</p></li></ul></li><li><p>文件系统的接口：操作系统提供给用户或应用程序用来使用文件系统的接口：</p><ul><li>命令接口：用户与文件系统直接交互的接口，如Shell命令。</li><li>程序接口：应用程序可以通过一系列命令调用文件系统的服务。</li></ul></li></ul><h2 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h2><p>当用户要求对一个文件实施多次读/写操作时，如果每次都检索目录效率较低，所以为了避免多次重复的检索目录，OS提供了“打开（Open）”操作，当此操作被执行时，OS会把被打开文件的信息存为“打开文件表”的一个条目，然后把这个条目编号返回用户，这样用户就可以通过这个编号和文件之间建立一个连接，也就可以进行文件的读写等操作。当用户再次向系统发出请求时，把这个编号提交给OS，OS通过这个编号在打开文件表中查找文件信息就可以减少检索时间。而关闭就是OS从“打开文件表”上删除此条目，这样断开了用户和文件之间的连接。</p><h2 id="文件的逻辑结构和物理结构"><a href="#文件的逻辑结构和物理结构" class="headerlink" title="文件的逻辑结构和物理结构"></a>文件的逻辑结构和物理结构</h2><ul><li><p>逻辑结构：从用户的角度来看，文件是能被存取的基本单位。</p></li><li><p>物理结构：文件在磁盘上存储时的组织形式。</p></li></ul><h3 id="逻辑文件按结构分类"><a href="#逻辑文件按结构分类" class="headerlink" title="逻辑文件按结构分类"></a>逻辑文件按结构分类</h3><ul><li><p>有结构文件：每个文件用于描述实体集中的一个实体。每个记录的长度对OS来说都是可知的。但记录之间可以分为定长和变长两种。</p><ul><li><p>定长记录：所有记录的长度都是相同的、所有记录中的各数据项都处在记录中相同的位置具有相同的顺序和长度。</p></li><li><p>变长记录：各记录的长度不相同。比如论文的摘要可能长度差距很大，不能在存储之前估计出所需要的空间。</p></li></ul></li><li><p>无结构文件：系统中运行的大量的源程序、可执行文件、文本文件等都是无结构文件，即流式文件。其文件长度是以字节为单位的。</p></li></ul><h3 id="逻辑文件按组织方式分类"><a href="#逻辑文件按组织方式分类" class="headerlink" title="逻辑文件按组织方式分类"></a>逻辑文件按组织方式分类</h3><p>组织方式指的是文件中记录的组织方式。只对有结构文件有效。可以分成：顺序文件、索引文件、索引顺序文件。</p><h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><p>指由一系列记录按某种顺序排列所形成的的文件。</p><ul><li><p>串结构：按存入时间的先后顺序排列。所以检索时必须从头挨个查找，效率低。</p></li><li><p>顺序结构：用户指定一个字段作为关键字，他可以是任意类型的变量。如sql文件。</p></li></ul><h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>为变长记录文件创建一张索引表，索引表是定长记录文件，检索时，先查找索引表，再根据指针所指的地址读取记录。可以解决变长文件记录较难直接存取的问题。</p><div align="center"><img src="/2019/08-文件管理/索引文件.jpg"></div><h3 id="索引顺序文件"><a href="#索引顺序文件" class="headerlink" title="索引顺序文件"></a>索引顺序文件</h3><p>将顺序文件的所有记录分成若干组，为顺序文件建立一张索引表，索引表中为每组的第一个记录建立一个索引项。检索时，先检索索引表，找到记录所在记录组的第一个记录的表项，再顺序查找主文件，得到要求的记录。</p><div align="center"><img src="/2019/08-文件管理/索引顺序文件.jpg"></div><h2 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h2><h3 id="文件控制块"><a href="#文件控制块" class="headerlink" title="文件控制块"></a>文件控制块</h3><p>包含三类信息：</p><ul><li><p>基本信息类：文件名、文件物理位置、文件逻辑结构、文件物理结构</p></li><li><p>控制信息类：各类用户的读、写、可执行文件等。</p></li><li><p>使用信息类：文件的建立时间，当前的使用信息，上一次修改的时间，是否被进程锁住等。</p></li></ul><h3 id="索引节点"><a href="#索引节点" class="headerlink" title="索引节点"></a>索引节点</h3><p>为了唯一确定外存中的一个文件，必须要把文件的FCB加载进内存，而每次加载的数据大小是一定的，所以为了一次能多加载进内存一个文件标识。将FCB分成两部分：</p><h4 id="磁盘索引节点"><a href="#磁盘索引节点" class="headerlink" title="磁盘索引节点"></a>磁盘索引节点</h4><ul><li>文件主标识符</li><li>文件类型</li><li>文件存取权限</li><li>文件物理地址</li><li>文件长度</li><li>文件连接计数：本人理解为硬链接计数</li><li>文件存取时间</li></ul><h4 id="内存索引节点。"><a href="#内存索引节点。" class="headerlink" title="内存索引节点。"></a>内存索引节点。</h4><ul><li>索引节点编号</li><li>状态</li><li>访问计数</li><li>文件所属文件系统的逻辑设备号：不明白</li><li>链接指针：不明白</li></ul><h3 id="树形结构目录"><a href="#树形结构目录" class="headerlink" title="树形结构目录"></a>树形结构目录</h3><p>在树形结构目录中，目录应该保存文件的信息。</p><div align="center"><img src="/2019/08-文件管理/文件目录.jpg"></div><p>同时目录的目录项要能既作为目录文件的FCB，又作为数据文件的FCB。</p><div align="center"><img src="/2019/08-文件管理/树形文件目录.jpg"></div><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><h3 id="基于有向无循环图实现文件共享"><a href="#基于有向无循环图实现文件共享" class="headerlink" title="基于有向无循环图实现文件共享"></a>基于有向无循环图实现文件共享</h3><div align="center"><img src="/2019/08-文件管理/有向无环图.jpg" style="width:80%"></div><p>此种方法存在问题：</p><p>比如对于文件<code>F8</code>，<code>D5:p</code>、<code>D6:e</code>、<code>D3:p</code>都保存了<code>F8</code>的物理地址，即从某个盘块开始，总长度多少等。此时如果<code>D6:e</code>对<code>F8</code>进行了删除操作，<code>D5:p</code>和<code>D3:P</code>都无法察觉，仍然会认为在它们存储的位置上有文件，即一个目录项对文件的操作对其他目录项来说是不可见的。</p><h3 id="利用索引节点"><a href="#利用索引节点" class="headerlink" title="利用索引节点"></a>利用索引节点</h3><div align="center"><img src="/2019/08-文件管理/利用索引节点.jpg" style="width:60%"></div><p>引入索引结点，将文件的物理地址和其他的属性放在索引结点中，只在目录项中存放文件名和指向索引结点的指针。由任何用户对文件进行Append操作或修改，引起相应索引结点内容的改变。此种方法即Linux中的硬链接。</p><h3 id="利用符号链接实现文件共享"><a href="#利用符号链接实现文件共享" class="headerlink" title="利用符号链接实现文件共享"></a>利用符号链接实现文件共享</h3><p>建立符号链接文件，它是一种特殊类型的文件，其内容是被链接文件的路径名。建立符号链接文件，并不影响原文件，实际上它们各是一个文件。可以建立任意的别名关系，甚至原文件是在其他计算机上。只有文件主才有指向索引结点的指针，而其他共享用户只有该文件的路径名。</p><div align="center"><img src="/2019/08-文件管理/利用符号链接.jpg"></div><h2 id="文件保护"><a href="#文件保护" class="headerlink" title="文件保护"></a>文件保护</h2><h3 id="访问权-amp-保护域"><a href="#访问权-amp-保护域" class="headerlink" title="访问权&amp;保护域"></a>访问权&amp;保护域</h3><ul><li>访问权：一个进程能对某对象执行操作的权利，用&lt;对象名，权集&gt;表示，如<code>&lt;F1, {R/W}&gt;</code>表示进程对F1有读和写的权利。</li><li>保护域：进程对一组对象访问权的集合，进程只能在域内进行操作。</li></ul><h3 id="进程和域的联系方式"><a href="#进程和域的联系方式" class="headerlink" title="进程和域的联系方式"></a>进程和域的联系方式</h3><p>进程和域之间是一对多的关系，即一个进程可以联系多个域。此时进程的运行分为多个阶段，每个阶段联系一个域，这样就可以根据运行的实际需要规定进程每个阶段所能访问的对象。</p><h3 id="访问矩阵"><a href="#访问矩阵" class="headerlink" title="访问矩阵"></a>访问矩阵</h3><div align="center"><img src="/2019/08-文件管理/访问矩阵.jpg"></div><ul><li>R：在域内运行的进程对文件具有读权限</li><li>W：在域内运行的进程对文件具有写权限</li><li>$R^\ast$：在域内运行的进程能把其对文件的读权限扩展到其他域中，但在其他域中是R权限，不再是$R^\ast$。</li><li><p>$W^\ast$：在域内运行的进程能把其对文件的写权限扩展到其他域中，但在其他域中是W权限，不再是$W^\ast$。</p></li><li><p>S：在域Di中运行的进程能转移到域Dj中运行，如图中在域D3运行的进程能转移到域D2中运行。</p></li><li>O：在域中运行的进程能增加或删除对某文件的访问权。</li><li>Control：在域Di中运行的进程能删除在域Dj中运行进程对各对象的访问权。如图中在D2中运行的进程能删除在D3中运行进程的访问权。</li></ul><h3 id="访问矩阵的实现"><a href="#访问矩阵的实现" class="headerlink" title="访问矩阵的实现"></a>访问矩阵的实现</h3><h4 id="访问控制表"><a href="#访问控制表" class="headerlink" title="访问控制表"></a>访问控制表</h4><p>将访问对象按列划分，为每一列建立一张访问控制表，在该表中把属于对象的所有空项都删除。此时表中的每一项都是一个有序对<code>&lt;域，权集&gt;</code>构成。</p><h4 id="访问权限表"><a href="#访问权限表" class="headerlink" title="访问权限表"></a>访问权限表</h4><p>将访问矩阵按行划分，每一行是一个访问权限表，表中的每一项表示该域对某对象的访问权限。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;文件管理概述&quot;&gt;&lt;a href=&quot;#文件管理概述&quot; class=&quot;headerlink&quot; title=&quot;文件管理概述&quot;&gt;&lt;/a&gt;文件管
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>07-输入输出系统</title>
    <link href="https://isjinhao.github.io/2019/07-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://isjinhao.github.io/2019/07-输入输出系统/</id>
    <published>2019-03-20T09:41:00.000Z</published>
    <updated>2019-03-25T08:28:00.952Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><p>输入输出系统和OS中的其他部分有很大区别，因为其他部分都是在说计算机接受任务后该怎么运行能又快又可靠的完成任务并把结果输出。而输入输出系统是怎么快速稳定的将任务的需求输入和任务的结果输出。</p><p>又由于输入输出设备种类繁多，比如输入设备中的键盘、鼠标、网卡、摄像头，输出设备中的打印机、音频等。所以输入输出系统被划分很多层次来尽可能屏蔽物理细节。</p><h2 id="IO系统的基本功能"><a href="#IO系统的基本功能" class="headerlink" title="IO系统的基本功能"></a>IO系统的基本功能</h2><ul><li><p>隐藏物理设备的细节：只需要使用简单的命令就能操作各种具有不同实现的硬件完成相应需求。</p></li><li><p>与设备的无关性：用户不需要指定哪些设备完成功能，只需要描述需求，OS会选择一个设备完成功能。</p></li><li><p>提高处理机和IO设备的利用率：IO设备之间一般是相互独立的，因此设备之间能够并行操作，所以OS应让处理机和设备之间能并行操作。</p></li><li><p>对IO设备进行控制：</p><ul><li>轮询的可编程IO方式。</li><li>采用中断你的可编程IO方式。</li><li>直接存储器访问方式。</li><li>IO通道方式。</li></ul></li><li><p>确保对设备的正确共享。</p></li><li><p>错误处理。</p></li></ul><h2 id="IO软件的层次结构"><a href="#IO软件的层次结构" class="headerlink" title="IO软件的层次结构"></a>IO软件的层次结构</h2><div align="center"><img src="/2019/07-输入输出系统/IO软件层次.jpg"></div><ul><li>用户层软件：提供设备与用户交互的接口，用户可以使用该层提供的功能直接控制设备。</li><li>设备独立性软件：设备分配，设备保护，设备分配，设备回收，数据缓存等。</li><li>设备驱动软件：发出控制设备的命令。</li><li>中断处理程序：保存被中断的进程的CPU环境，转入相应的中断处理程序仅需处理，处理完毕后再恢复被中断进程的现场，返回到被中断的进程。</li></ul><h2 id="IO系统各模块层次视图"><a href="#IO系统各模块层次视图" class="headerlink" title="IO系统各模块层次视图"></a>IO系统各模块层次视图</h2><div align="center"><img src="/2019/07-输入输出系统/IO各模块层次视图.jpg"></div><ul><li>块设备：输入输出以数据块为单位的设备。如磁盘。</li><li>流设备：字符设备的输入输出，如键盘。</li><li>网络通信接口：网卡。</li></ul><h2 id="IO设备和设备控制器"><a href="#IO设备和设备控制器" class="headerlink" title="IO设备和设备控制器"></a>IO设备和设备控制器</h2><p>直接和IO设备对接的是设备控制器。</p><div align="center"><img src="/2019/07-输入输出系统/IO设备和设备控制器.jpg"></div><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>接收和识别命令（控制寄存器、命令译码器）：设备控制器将CPU送来的命令写入控制器寄存器中，并进行译码。</li><li>数据交换（数据寄存器）。</li><li>设备状态的了解和报告（状态寄存器）。</li><li>地址识别（地址译码器）：系统中的每个设备都有自己的地址段，设备接口电路中有多个寄存器，一个寄存器有唯一的一个地址，每个地址为I/O端口，该地址称为I/O端口地址。设备控制器必须能识别每个设备的地址。</li><li>数据缓冲：缓冲器。</li><li>差错控制：差错检测码。</li></ol><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li><p>设备控制器和处理机的接口：用于实现CPU与设备控制器之间的通信。</p></li><li><p>设备控制器和设备的接口。</p></li><li><p>IO逻辑：在一个设备控制器上，可以连一个或多个设备。相应的，在控制器中就有一个或多个设备接口，一个接口连一台设备，控制器中的I/O逻辑根据处理机发来的地址信号，去选择一个设备接口。控制器中的I/O逻辑用来实现对设备的控制。通过接收CPU 发来的命令和地址信息，对所选设备进行控制</p></li></ul><h3 id="CPU如何控制设备控制器"><a href="#CPU如何控制设备控制器" class="headerlink" title="CPU如何控制设备控制器"></a>CPU如何控制设备控制器</h3><p>CPU控制内存时需要指定指令地址、数据地址等。控制设备控制器亦如此，一般有两种控制方式：</p><ul><li>利用特定IO指令：利用特殊的IO指令控制设备控制器。</li><li>内存映像IO：不再区分内存和控制器中的寄存器地址。假如有一个地址K，当0&lt;=K&lt;N时被认为是内存地址，K&gt;=N时被认为是寄存器地址。</li></ul><h3 id="IO通道"><a href="#IO通道" class="headerlink" title="IO通道"></a>IO通道</h3><p>有了设备控制器之后，CPU便可以操作控制器完成对IO设备的控制，但是此时数据交换仍然需要CPU的全程参与，所以引入IO通道来使数据传送、IO设备的组织管理等都独立于CPU。</p><p>通道是独立于CPU的专门负责数据输入/输出传输工作的处理机，对外部设备实现统一管理，代替CPU对输入/输出操作进行控制，从而使输入，输出操作可与CPU并行操作。通道执行通道程序来控制IO操作。与CPU的区别：</p><ul><li>通道程序指令类型单一</li><li>通道没有自己的内存，通道程序在主机的内存中，即通道与CPU共享内存。</li></ul><h4 id="字节多路通道"><a href="#字节多路通道" class="headerlink" title="字节多路通道"></a>字节多路通道</h4><p>主要连接以字节为单位的低速IO设备。如打印机，终端。</p><ul><li><p>按字节交叉方式工作的通道。通常含有许多非分配型子通道，其数量从几十个到数百个，每一个子通道连接一台I/O设备。这些子通道按时间片轮转方式共享主通道。</p></li><li><p>字节多路通道以字节为单位传输信息，它可以分时地执行多个通道程序。当一个通道程序控制某台设备传送一个字节后，通道硬件就控制转去执行另一个通道程序，控制另一台设备传送信息。</p></li></ul><div align="center"><img src="/2019/07-输入输出系统/字节多路通道.jpg"></div><h4 id="数组选择通道"><a href="#数组选择通道" class="headerlink" title="数组选择通道"></a>数组选择通道</h4><p>主要连接磁盘，磁带等高速I/O设备</p><p>选择通道是按数组方式进行数据传送，每次传送一批数据，故传送速度很高。</p><p>选择通道在一段时间内只能执行一个通道程序，只允许一台设备进行数据传输。当这台设备数据传输完成后，再选择与通道连接的另一台设备，执行它的相应的通道程序。这种独占性又使得通道利用率很低。</p><div align="center"><img src="/2019/07-输入输出系统/数组选择通道.jpg"></div><h4 id="数组多路通道"><a href="#数组多路通道" class="headerlink" title="数组多路通道"></a>数组多路通道</h4><p>主要连接高速设备。</p><ul><li><p>结合了数组选择通道传送速度高和字节多路通道能进行分时并行操作的优点。它先为一台设备执行一条通道指令，然后自动转接，为另一台设备执行一条通道指令。它含有多个非分配型的子通道，既有很高的数据传输率，又能获得令人满意的通道利用率</p></li><li><p>对通道程序采用多道程序设计的硬件实现</p></li><li><p>可以连接多台高速设备，数据传输按数组方式，一段时间内可以执行多道通道程序</p></li></ul><h4 id="解决瓶颈"><a href="#解决瓶颈" class="headerlink" title="解决瓶颈"></a>解决瓶颈</h4><p>通道执行通道程序，向控制器发出命令，并具有向CPU发中断信号的功能。一旦CPU发出指令，启动通道，则通道独立于CPU工作。但是，由于通道价格贵，通道数量少，往往使之成为IO的“瓶颈”。解决办法是在不增加通道的前提下，增加设备到主机间的通路，一个通道可连接多个控制器，一个控制器可连接多个设备，形成树形交叉连接。</p><div align="center"><img src="/2019/07-输入输出系统/解决瓶颈.jpg"></div><h2 id="中断机构和中断处理程序"><a href="#中断机构和中断处理程序" class="headerlink" title="中断机构和中断处理程序"></a>中断机构和中断处理程序</h2><p><a href="https://isjinhao.github.io/2019/%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD/#more">https://isjinhao.github.io/2019/%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD/#more</a></p><h2 id="设备驱动程序"><a href="#设备驱动程序" class="headerlink" title="设备驱动程序"></a>设备驱动程序</h2><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ol><li>接受设备独立性软件发来的命令和参数，将接收到的抽象要求转换为具体要求</li><li>检查用户IO请求的合法性，了解IO设备的状态，传递有关参数，设置设备的工作方式</li><li>发出IO命令，如果设备空闲，启动IO设备完成指定的IO操作；如果设备忙碌，则将请求挂在设备队列上等待</li><li>及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。</li><li>对于设置有通道的计算机系统，驱动程序还应能够根据用户的IO请求，自动地构成通道程序。</li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>驱动程序主要是在设备无关性软件和设备控制器之间的一个通信程序</li><li>驱动程序与IO设备特性密切相关：通常由硬件厂商提供</li><li>驱动程序与I/O控制方式密切相关:中断驱动和DMA方式</li><li>驱动程序与硬件相关,部分代码需用汇编语言编写</li><li>驱动程序应允许可重入</li></ol><h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a>处理过程</h3><ol><li>将抽象要求转换为具体要求<ol><li>通常设备控制器中都有若干个寄存器，分别用于暂存命令、数据和参数等；</li><li>用户及上层软件对设备控制器的具体情况毫无了解，因而只能向它们发出抽象的要求(命令)，但不能直接传送给设备控制器。需要将抽象要求转换为具体要求(命令码，数据，参数)。例如，将抽象要求中的盘块号转换为磁盘的盘面、磁道号及扇区。这一转换工作只能由驱动程序来完成；</li><li>在OS中只有驱动程序才同时了解抽象要求和设备控制器中的寄存器情况；也只有它才知道命令、数据和参数应分别送往哪个寄存器。</li></ol></li><li>检查IO请求的合法性</li><li>读出和检查设备的状态</li><li>传送必要的参数，设置工作方式</li><li>启动I/O设备<ol><li>在完成上述准备工作后，驱动程序可以向控制器中的命令寄存器传送相应的控制命令</li><li>对于字符设备，若发出的是写命令，驱动程序将把一个数据传送给控制器；若发出的是读命令，则驱动程序等待接收数据，并通过从控制器中的状态寄存器读入状态字的方法，来确定数据是否到达。</li><li>驱动程序发出IO命令后，基本的IO是在设备控制器的控制下进行的，通常IO操作所要完成的工作较多，需要一定的时间，如读/写一个盘块中的数据，此时，驱动程序进程把自己阻塞起来，直至中断到来时才将它唤醒。</li></ol></li></ol><h3 id="对IO设备的控制方式"><a href="#对IO设备的控制方式" class="headerlink" title="对IO设备的控制方式"></a>对IO设备的控制方式</h3><h4 id="使用轮询的可编程I-O方式"><a href="#使用轮询的可编程I-O方式" class="headerlink" title="使用轮询的可编程I/O方式"></a>使用轮询的可编程I/O方式</h4><p>CPU发出启动外设的I/O指令，同时将忙/闲标志置为1。如果外设的工作没有完成，则标志一直为1，CPU不断循环检测该标志，直到标志为不忙为止。</p><div align="center"><img src="/2019/07-输入输出系统/轮询可编程.jpg"></div><h4 id="使用中断的可编程I-O方式"><a href="#使用中断的可编程I-O方式" class="headerlink" title="使用中断的可编程I/O方式"></a>使用中断的可编程I/O方式</h4><p>CPU设定I/O设备的初始值，然后不再忙等待，运行其他进程，当前进程阻塞；I/O设备完成对当前数据的处理后，向CPU发出中断，I/O中断处理程序将负责传送剩余数据。</p><div align="center"><img src="/2019/07-输入输出系统/中断可编程.jpg"></div><h4 id="直接存储器访问-DMA-方式"><a href="#直接存储器访问-DMA-方式" class="headerlink" title="直接存储器访问(DMA)方式"></a>直接存储器访问(DMA)方式</h4><p>采用中断驱动IO方式时的CPU，是以字为单位进行干预的。如果将这种方式用于块设备的I／O，是极其低效的。如：为了从磁盘中读出1KB的数据块；需要中断1K次CPU。而DMA方式使用独立的DMA控制器代替CPU的工作，I/O设备与DMA通信，DMA在传输完成一个数据缓冲区之后再向CPU发中断。</p><ul><li>数据传输的基本单位是数据块，即CPU与IO设备之间，每次传送至少是一个数据块，主要用在块设备的IO操作中。</li><li>在DMA方式中，利用总线直接连接外设和内存，由DMA控制机构窃取总线占有权，完成外设与内存间的成批数据交换。所传送的数据是从设备直接送入内存的，或者相反。</li><li>仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的，不再需要CPU进行干预。</li></ul><h4 id="I-O通道控制方式"><a href="#I-O通道控制方式" class="headerlink" title="I/O通道控制方式"></a>I/O通道控制方式</h4><p>使用DMA方式，CPU每发出一条I/O指令，只能读写一个连续的数据块。如果需要一次去读多个离散的数据块且将它们分别送到不同的内存区域，则需要CPU分别发出多条I/O指令及进行多次中断处理，才能完成。</p><p>而IO通道可实现CPU、通道和I/O设备三者的并行操作，进一步提高CPU与外设之间的并行工作能力，使I/O操作形成独立于CPU的体系，减少CPU的负担，使外设与内存的数据交换更加灵活，从而更有效地提高整个系统的资源利用率。</p><p>参见4.4。</p><h2 id="与设备无关的I-O软件"><a href="#与设备无关的I-O软件" class="headerlink" title="与设备无关的I/O软件"></a>与设备无关的I/O软件</h2><p>为了便于对外设进行管理，系统对每台进入计算机系统中的设备都给定一个对应的编号，作为调用时识别和区分设备用。这种编号无任何重复，一般被称为设备的绝对号（或物理设备名）。早期操作系统，应用程序直接使用物理设备名称，非常不灵活。所以引入逻辑设备名，规定用户申请外设时，只需要向系统说明所需用的某类设备真正在实际中使用哪台设备，由系统根据这类设备的应用情况作出分配。</p><h3 id="设备分配"><a href="#设备分配" class="headerlink" title="设备分配"></a>设备分配</h3><p>在多道程序环境下，设备不允许用户自行使用，而必须由系统分配。对于进程的IO请求，只要是安全（无死锁），设备分配程序便按照一定的策略进行设备分配。数据结构：</p><ul><li><p>系统设备表SDT：System Device Table。</p><ul><li>整个系统中只有一张，全面反映了系统中的外设资源的类型、数量、占用情况等。</li><li>在SDT表中，每个接入系统中的外围设备都占有一个表目项。登录了该设备的名称、标识、设备控制表DCT的入口地址、设备驱动程序的入口地址及占用设备的进程名称等相关信息。</li></ul><div align="center"><img src="/2019/07-输入输出系统/SDT.jpg"></div></li><li><p>设备控制表DCT ：Device Control Table。每台设备都有一张设备控制表DCT，用于记录本设备的情况。</p><ul><li>Type：设备类型</li><li>Deviceid:设备标识符</li><li>设备队列队首指针</li><li>设备状态：标识设备忙或者空闲；</li><li>与设备连接的控制器表指针。</li><li>重复执行次数</li></ul><div align="center"><img src="/2019/07-输入输出系统/DCT.jpg"></div></li><li><p>控制器控制表COCT：Controller Control Table。每个控制器都有一张，用于记录某控制器的使用分配情况及与该控制器相连的通道的情况。</p><ul><li>控制器号：控制器的内部标识符。</li><li>控制器状态：控制器忙/闲，好/坏的状态标志。</li><li>通道指针：指向与该控制器相联的通道控制表CHCT，当控制器与若干通道连接时该项内含多个指针。</li><li>等待队列指针：指向等待该控制器的I/O进程队列</li></ul><div align="center"><img src="/2019/07-输入输出系统/COCT.jpg"></div></li><li><p>通道控制表CHCT：Channel Control Table。反映了通道的情况，系统中的每个通道一张CHCT。</p><ul><li>通道号：通道内部标识符</li><li>通道状态：通道的各种状态（好/坏，已分/未分等）的反映</li><li>等待队列指针：等待该通道的I/O进程队列的首位置</li></ul><div align="center"><img src="/2019/07-输入输出系统/CHCT.jpg"></div></li></ul><h3 id="设备分配算法"><a href="#设备分配算法" class="headerlink" title="设备分配算法"></a>设备分配算法</h3><div align="center"><img src="/2019/07-输入输出系统/设备分配算法.jpg"></div><h2 id="用户层的I-O软件"><a href="#用户层的I-O软件" class="headerlink" title="用户层的I/O软件"></a>用户层的I/O软件</h2><h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>用户层软件必须使用一组系统调用来取得操作系统服务，在高级语言中都提供了相应的库函数来完成此功能。</p><h3 id="SPOOLing程序"><a href="#SPOOLing程序" class="headerlink" title="SPOOLing程序"></a>SPOOLing程序</h3><p>多道程序技术将一台CPU虚拟为多台CPU，从而可以提高CPU的利用率。而SPOOLing系统是模拟脱机输入输出系统来实现多个用户共享一台物理IO设备。</p><ul><li>脱机输入输出系统的IO处理机 对应 SPOOLing程序。</li><li>脱机输入输出系统的高速缓冲 对应 内存。</li></ul><div align="center"><img src="/2019/07-输入输出系统/SPOOLing.jpg"></div><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><h3 id="单缓冲区"><a href="#单缓冲区" class="headerlink" title="单缓冲区"></a>单缓冲区</h3><div align="center"><img src="/2019/07-输入输出系统/单缓冲区.jpg"></div><h3 id="双缓冲区"><a href="#双缓冲区" class="headerlink" title="双缓冲区"></a>双缓冲区</h3><p>为输入或输出分配两个缓冲区，让两个缓冲区交替工作，形成并行操作的方式。</p><div align="center"><img src="/2019/07-输入输出系统/双缓冲.jpg"></div><h3 id="环形缓冲区"><a href="#环形缓冲区" class="headerlink" title="环形缓冲区"></a>环形缓冲区</h3><ul><li>空缓冲区R：用于存放数据（指针：Nexti）</li><li>已装满数据的缓冲区G：其中的数据提供给进程使用。（指针：Nextg）</li><li>现行工作缓冲区C：当前进程使用的缓冲区。（指针：Current）</li></ul><div align="center"><img src="/2019/07-输入输出系统/环形缓冲.jpg"></div><h2 id="磁盘存储器的性能和调度"><a href="#磁盘存储器的性能和调度" class="headerlink" title="磁盘存储器的性能和调度"></a>磁盘存储器的性能和调度</h2><div align="center"><img src="/2019/07-输入输出系统/磁盘.jpg"></div><p>当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头（又叫磁头）下通过，就可以进行数据的读/写了。</p><p>一般磁盘分为固定头盘（磁头固定）和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。</p><p>活动头盘 （如上图）的磁头是可移动的。每一个盘面上只有一个磁头（磁头是双向的，因此正反盘面都能读写）。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的（行动整齐划一）。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。</p><h3 id="磁盘访问时间"><a href="#磁盘访问时间" class="headerlink" title="磁盘访问时间"></a>磁盘访问时间</h3><ol><li>寻道时间$T_s$：$T_s = s$</li><li>旋转延迟时间$T_τ​$：$T_t = \frac{1}{2r}​$</li><li>磁盘访问时间 ：$T_t=\frac{b}{rN}$</li></ol><p>$s$是指磁头从当前位置定位到开始点的时间，$b$是传输的字节数，$r$是每秒的转数，$N$是一条磁道上的字节数。$总时间 = T_s + \frac{1}{2r} + \frac{b}{rN}$</p><h3 id="磁盘调度算法"><a href="#磁盘调度算法" class="headerlink" title="磁盘调度算法"></a>磁盘调度算法</h3><p>假设磁盘访问序列：98，183，37，122，14，124，65，67，读写头起始位置：53。</p><h4 id="先来先服务"><a href="#先来先服务" class="headerlink" title="先来先服务"></a>先来先服务</h4><p>按访问请求到达的先后次序服务。</p><div align="center"><img src="/2019/07-输入输出系统/先来先服务.jpg"></div><h4 id="最短寻道时间优先"><a href="#最短寻道时间优先" class="headerlink" title="最短寻道时间优先"></a>最短寻道时间优先</h4><div align="center"><img src="/2019/07-输入输出系统/最短寻道.jpg"></div><h4 id="扫描算法"><a href="#扫描算法" class="headerlink" title="扫描算法"></a>扫描算法</h4><p>当设备无访问请求时，磁头不动；当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复。</p><div align="center"><img src="/2019/07-输入输出系统/扫描算法.jpg"></div><h4 id="循环扫描算法"><a href="#循环扫描算法" class="headerlink" title="循环扫描算法"></a>循环扫描算法</h4><p>CSCAN算法规定磁头单向移动，例如由里向外移动，当磁头移到最外的磁道并访问后磁头立即返回到最里的欲访<br>问磁道，即最小磁道号紧接最大磁道号构成循环，进行循环扫描。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;输入输出系统和OS中的其他部分有很大区别，因为其他部分都是在说计算机接受任务后该怎么运行能又快又可靠的完成任务并把结果输出。而输入输出系统是怎么
      
    
    </summary>
    
      <category term="操作系统" scheme="https://isjinhao.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="操作系统" scheme="https://isjinhao.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>07-Mysql高级操作</title>
    <link href="https://isjinhao.github.io/2019/07-Mysql%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C/"/>
    <id>https://isjinhao.github.io/2019/07-Mysql高级操作/</id>
    <published>2019-03-20T08:27:31.000Z</published>
    <updated>2019-03-24T12:30:36.506Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><h2 id="数据"><a href="#数据" class="headerlink" title="数据"></a>数据</h2><div align="center"><img src="/2019/07-Mysql高级操作/表结构.jpg"></div><p>这个是本人数据库课程设计中的表结构，数据库课程设计写的是学院成绩管理系统，就是可以通过excel把学生的绩点、竞赛情况、大创项目情况导入到系统中，然后学生、班长、辅导员三个级别的用户可以从三个层次看到成绩。表结构：</p><ul><li>studentinfos：学号、密码、姓名、专业、班级、绩点、级别（学生是第一级）</li><li>courses：课号、姓名、类型（必修课、公共选修课、专业选修课等）、重要系数（理学院套餐、专业核心课程一般是1.2，选修课等一般是1.0）、学分、年度。</li><li>scores：唯一标识（没吊用…）、学号、课号、成绩、年度、学期</li><li><p>classdamins：班号、密码、班级名称、级别（班长是第二级别）</p></li><li><p>candp：唯一标识、项目或比赛的名称、年度、级别、是否是负责人、学号、状态</p></li></ul><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">OR</span> <span class="keyword">REPLACE</span>] [ALGORITHM = &#123;UNDEFINED | <span class="keyword">MERGE</span> | TEMPTABLE&#125;]</span><br><span class="line"><span class="keyword">VIEW</span> view_name [(column_list)]</span><br><span class="line"><span class="keyword">AS</span> SELECT_statement</span><br><span class="line">[<span class="keyword">WITH</span> [<span class="keyword">CASCADED</span> | <span class="keyword">LOCAL</span>] <span class="keyword">CHECK</span> <span class="keyword">OPTION</span>]</span><br></pre></td></tr></table></figure><p>把每个班学生的绩点、学分、通过率创建一个视图：<code>classstudentscores</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">VIEW</span> classstudentscores <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="string">`scores`</span>.<span class="string">`stu_id`</span> <span class="keyword">AS</span> <span class="string">`id`</span>,</span><br><span class="line"><span class="string">`studentinfos`</span>.<span class="string">`name`</span> <span class="keyword">AS</span> <span class="string">`name`</span>,</span><br><span class="line"><span class="string">`studentinfos`</span>.<span class="string">`pwd`</span> <span class="keyword">AS</span> <span class="string">`pwd`</span>,</span><br><span class="line"><span class="string">`studentinfos`</span>.<span class="string">`cclass`</span> <span class="keyword">AS</span> <span class="string">`cclass`</span>,</span><br><span class="line"><span class="string">`studentinfos`</span>.<span class="string">`gpa`</span> <span class="keyword">AS</span> <span class="string">`gpa`</span>,</span><br><span class="line"><span class="keyword">sum</span>(<span class="string">`courses`</span>.<span class="string">`credit`</span>) <span class="keyword">AS</span> <span class="string">`allcre`</span>,</span><br><span class="line"><span class="string">`getStudentPassRate`</span> (<span class="string">`scores`</span>.<span class="string">`stu_id`</span>) <span class="keyword">AS</span> <span class="string">`passrate`</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line"><span class="string">`studentinfos`</span>,</span><br><span class="line"><span class="string">`scores`</span>,</span><br><span class="line"><span class="string">`courses`</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line"><span class="string">`studentinfos`</span>.<span class="string">`id`</span> = <span class="string">`scores`</span>.<span class="string">`stu_id`</span></span><br><span class="line"><span class="keyword">AND</span> <span class="string">`scores`</span>.<span class="string">`cou_id`</span> = <span class="string">`courses`</span>.<span class="string">`id`</span></span><br><span class="line"><span class="keyword">AND</span> <span class="string">`scores`</span>.<span class="string">`score`</span> &gt; <span class="number">59</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="string">`scores`</span>.<span class="string">`stu_id`</span></span><br></pre></td></tr></table></figure><h3 id="更新视图"><a href="#更新视图" class="headerlink" title="更新视图"></a>更新视图</h3><p>视图是可以更新的，对视图的更新最终会反应到基本表上，但是并非所有的视图都是可更新的。如果视图包含下述结构中的任何一种，那么它就是不可更新的：</p><ol><li>聚合函数（SUM(), MIN(), MAX(), COUNT()等）。</li><li>DISTINCT</li><li>GROUP BY</li><li>HAVING</li><li>UNION或UNION ALL</li><li>位于选择列表中的子查询</li><li>Join</li><li>FROM子句中的不可更新视图</li><li>WHERE子句中的子查询，引用FROM子句中的表。</li><li>ALGORITHM = TEMPTABLE（使用临时表总会使视图成为不可更新的）。</li></ol><h3 id="WITH-CHECK-OPTION"><a href="#WITH-CHECK-OPTION" class="headerlink" title="WITH CHECK OPTION"></a><code>WITH CHECK OPTION</code></h3><ul><li><p>LOCAL参数表示更新视图时只要满足该视图本身定义的条件即可。</p></li><li><p>CASCADED参数表示更新视图时需要满足所有相关视图和表的条件。没有指明时，该参数为默认值。</p></li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用<code>with check option</code>之后，通过视图进行的修改，必须也能通过该视图看到修改后的结果。总结如下：</p><ol><li>视图只操作它可以查询出来的数据，对于它查询不出的数据，即使基表有，也不可以通过视图来操作。</li><li>对于update，有with check option，要保证update后，数据要被视图查询出来</li><li>对于delete，有无with check option都一样</li><li>对于insert，有with check option，要保证insert后，数据要被视图查询出来</li><li>对于没有where子句的视图，使用with check option是多余的</li></ol><h3 id="视图创建算法"><a href="#视图创建算法" class="headerlink" title="视图创建算法"></a>视图创建算法</h3><ul><li><code>MERGE</code>算法：MySQL首先将输入查询与定义视图的SELECT语句组合成单个查询。 然后MySQL执行组合查询返回结果集。 如果SELECT语句包含集合函数、DISTINCT、GROUP BY、HAVING、LIMIT、UNION、UNION ALL、子查询，则不允许使用<code>MERGE</code>算法。如果SELECT语句无引用表，则也不允许使用<code>MERGE</code>算法。 如果不允许<code>MERGE</code>算法，MySQL将算法更改为<code>UNDEFINED</code>。</li><li>使用<code>TEMPTABLE</code>算法，MySQL首先根据定义视图的SELECT语句创建一个临时表，然后针对该临时表执行输入查询。因为MySQL必须创建临时表来存储结果集并将数据从基表移动到临时表，所以<code>TEMPTABLE</code>算法的效率比<code>MERGE</code>算法效率低。 另外，使用<code>TEMPTABLE</code>算法的视图是不可更新的。</li></ul><p>原文链接：<a href="https://www.yiibai.com/mysql/create-sql-views-mysql.html" target="_blank" rel="noopener">https://www.yiibai.com/mysql/create-sql-views-mysql.html</a></p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>教程链接：<a href="https://www.yiibai.com/mysql/stored-procedure.html" target="_blank" rel="noopener">https://www.yiibai.com/mysql/stored-procedure.html</a></p><p><strong>一定要注意，Mysql的游标只能用于存储过程和函数。</strong></p><p>例：获得班级的平均绩点</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">procedure</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> getClassGpa;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">procedure</span> getClassGpa(<span class="keyword">IN</span> <span class="string">`classID`</span> <span class="built_in">varchar</span>(<span class="number">20</span>), <span class="keyword">OUT</span> <span class="string">`avgpa`</span> <span class="keyword">double</span>)</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> cgpa <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">sum</span> <span class="keyword">DOUBLE</span> <span class="keyword">DEFAULT</span> <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> done <span class="built_in">int</span> <span class="keyword">DEFAULT</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">num</span> <span class="built_in">int</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> cur <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">select</span> gpa <span class="keyword">from</span> studentinfos <span class="keyword">where</span> cclass = classID;</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">for</span> <span class="keyword">not</span> <span class="keyword">found</span> <span class="keyword">set</span> done = <span class="literal">TRUE</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">sum</span>=<span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">num</span>=<span class="number">0</span>;</span><br><span class="line">open cur;</span><br><span class="line">read_loop:LOOP</span><br><span class="line">FETCH CUR INTO cgpa;</span><br><span class="line">if done then</span><br><span class="line">leave read_loop;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">sum</span> = <span class="keyword">sum</span> + cgpa;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">num</span> = <span class="keyword">num</span>+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">close cur;</span><br><span class="line"><span class="keyword">set</span> avgpa = <span class="keyword">sum</span>/<span class="keyword">num</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sum</span>,avgpa;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>本质上和存储过程没区别。只是函数只能返回一个变量的限制。而存储过程可以返回多个。而且函数是可以嵌入在sql中使用，可以在select中调用，而存储过程不行。通常如果返回值只有一个使用函数，其他情况使用存储过程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`getClassNotPassRate`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> <span class="string">`getClassNotPassRate`</span> (<span class="string">`classID`</span> <span class="built_in">VARCHAR</span>(<span class="number">20</span>)) <span class="keyword">RETURNS</span> <span class="keyword">DOUBLE</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span><span class="keyword">sum</span> <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span>notPassSum <span class="keyword">DOUBLE</span>;</span><br><span class="line">  <span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> <span class="keyword">sum</span> <span class="keyword">FROM</span>scores,studentinfos</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">scores.stu_id = studentinfos.id</span><br><span class="line"><span class="keyword">AND</span> studentinfos.cclass = classID;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">INTO</span> notPassSum <span class="keyword">FROM</span> scores, studentinfos</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">scores.stu_id = studentinfos.id</span><br><span class="line"><span class="keyword">AND</span> studentinfos.cclass = classID</span><br><span class="line"><span class="keyword">AND</span> scores.score &lt; <span class="number">60</span>;</span><br><span class="line">IF (sum = 0) </span><br><span class="line">THEN RETURN 0; </span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">RETURN notPassSum / sum;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>教程：<a href="https://www.yiibai.com/mysql/triggers.html" target="_blank" rel="noopener">https://www.yiibai.com/mysql/triggers.html</a></p><p>例：在录入学生成绩时，触发器根据新录入的学生成绩的系统中已有的学生选课成绩计算出录入之后的学生GPA。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`changeGpa`</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> <span class="string">`changeGpa`</span> <span class="keyword">AFTER</span> <span class="keyword">INSERT</span> <span class="keyword">ON</span> <span class="string">`scores`</span> <span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line"><span class="keyword">DECLARE</span> myavg <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> allcre <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> temp <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> <span class="keyword">sum</span> <span class="keyword">DOUBLE</span> <span class="keyword">DEFAULT</span> <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> t <span class="built_in">INTEGER</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> t1 <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> t2 <span class="keyword">DOUBLE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> done <span class="built_in">INT</span> <span class="keyword">DEFAULT</span> <span class="literal">FALSE</span>;</span><br><span class="line"><span class="keyword">DECLARE</span> cur <span class="keyword">cursor</span> <span class="keyword">for</span> <span class="keyword">SELECT</span> scores.score, courses.coefficient, courses.credit <span class="keyword">from</span> studentinfos, scores, courses </span><br><span class="line">       <span class="keyword">where</span> studentinfos.id = scores.stu_id <span class="keyword">and</span> scores.cou_id = courses.id <span class="keyword">and</span> stu_id = new.stu_id;</span><br><span class="line"><span class="keyword">DECLARE</span> CONTINUE <span class="keyword">HANDLER</span> <span class="keyword">for</span> <span class="keyword">not</span> <span class="keyword">found</span> <span class="keyword">set</span> done = <span class="literal">TRUE</span>;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">SUM</span>(courses.credit) <span class="keyword">into</span> allcre <span class="keyword">from</span> studentinfos, scores, courses </span><br><span class="line">       <span class="keyword">where</span> studentinfos.id = scores.stu_id <span class="keyword">and</span> scores.cou_id = courses.id <span class="keyword">and</span> stu_id = new.stu_id <span class="keyword">and</span> score&gt;=<span class="number">60</span>;</span><br><span class="line">open cur;</span><br><span class="line">read_loop:loop</span><br><span class="line">FETCH cur into t, t1, t2;</span><br><span class="line">IF done THEN LEAVE read_loop; <span class="keyword">END</span> <span class="keyword">IF</span>;</span><br><span class="line">if(t &lt; 60) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">0.0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 60) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 64) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">1.6</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 66) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">1.7</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 68) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">2.0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 72) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">2.3</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 75) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">2.7</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 78) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">3.0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 82) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">3.3</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 85) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">3.7</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line">if(t &gt;= 90) THEN</span><br><span class="line"><span class="keyword">set</span> temp = <span class="number">4.0</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">if</span>;</span><br><span class="line"><span class="keyword">set</span> <span class="keyword">sum</span>=temp*t1*t2+<span class="keyword">sum</span>;</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">loop</span>;</span><br><span class="line">close cur;</span><br><span class="line"><span class="keyword">set</span> myavg = <span class="keyword">sum</span>/allcre;</span><br><span class="line"><span class="keyword">UPDATE</span> studentinfos <span class="keyword">SET</span> gpa = myavg <span class="keyword">where</span> <span class="keyword">id</span> = new.stu_id;</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;数据&quot;&gt;&lt;a href=&quot;#数据&quot; class=&quot;headerlink&quot; title=&quot;数据&quot;&gt;&lt;/a&gt;数据&lt;/h2&gt;&lt;div ali
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>06-事务</title>
    <link href="https://isjinhao.github.io/2019/06-%E4%BA%8B%E5%8A%A1/"/>
    <id>https://isjinhao.github.io/2019/06-事务/</id>
    <published>2019-03-20T07:20:54.000Z</published>
    <updated>2019-03-24T07:29:36.457Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --><h2 id="ACID"><a href="#ACID" class="headerlink" title="ACID"></a>ACID</h2><h3 id="A"><a href="#A" class="headerlink" title="A"></a>A</h3><p>原子性（Atomicity）：事务是数据库的逻辑工作单位事务中包括的诸操作要么都做，要么都不做。</p><h3 id="C"><a href="#C" class="headerlink" title="C"></a>C</h3><p>一致性（Consistency）：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。</p><ul><li><p>一致性状态：数据库中只包含成功事务提交的结果。</p></li><li><p>不一致状态：数据库中包含失败事务的结果。</p></li></ul><h3 id="I"><a href="#I" class="headerlink" title="I"></a>I</h3><p>隔离性（Isolation）：一个事务内部的操作及使用的数据对其他并发事务是隔离的。也就是说一个事务在执行的时候不知道是否有其他事务和它一起在对相同的数据做操作，事务之间是相对不可见的。</p><h3 id="D"><a href="#D" class="headerlink" title="D"></a>D</h3><p>持续性（Durability）：持续性也称永久性。一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。</p><h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><p>由于事务的隔离性，不同事务若同时相同的数据做操作，可能会引发问题，即事务的并发问题。按照问题解决的难度由低至高可分为四类。</p><h3 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h3><p>一个事务对数据对象的修改被另一个事务的修改所覆盖。分为两类：</p><ul><li>第一类：事务T1、T2同时读取A为10，T1将A减1后提交，T2将A也减1后<strong>提交</strong>，此时数据库中数据为9。T1的修改被T2覆盖。</li><li>第一类：事务T1、T2同时读取A为10，T1将A减1后提交，T2将A也减1后<strong>回滚</strong>，此时数据库中数据为10。T1的修改被T2覆盖。</li></ul><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p>由于一个事物的回滚，使得另一个事务读到的数据无效。事务T1中读A为100，修改A未300，还未提交时事务T2读C为300，但由于T1因某原因进行事务回滚。A又被重置为100。T2读取到的是脏数据。</p><h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p>在一个事务的两次“读”同一数据之间，有另一个事务的“updata”发生。如在事务T1中第一次读A为100，读B为200，A+B为300，在事务T2中把A修改为200，事务T2第二次读A为200，读B为200，A+B为400。同一事务两次读取的数据不一致。</p><h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p>在一个事务的两次“读”同一数据之间，有另一个事务的“insert”发生。如在事务T1中第一次读<code>count(*)</code>为100，事务T2插入一条数据，事务T1中第二次读<code>count(*)</code>为101，同一事务两次读取的数据不一致。</p><h2 id="封锁类型"><a href="#封锁类型" class="headerlink" title="封锁类型"></a>封锁类型</h2><p>加锁是解决事务并发问题的常见手段。数据库中的锁从读写的角度可分为两类：共享锁和排它锁。</p><ul><li>排它锁（X锁）：只允许当前事务T对数据进行“读”、“写”，其它事务对数据R的任何锁请求被拒绝直到T释放R上的X锁。</li><li>共享锁（S锁）：允许当前事务T对数据R进行“读”，不允许“写“，而其它事务对R的S申请被允许，X请求拒绝。</li></ul><p>带来的效果是：</p><ul><li>X锁：数据对象当前只能由一个事务操作。</li><li>S锁：多个事务允许同时“读”一个数据。</li></ul><h2 id="封锁协议"><a href="#封锁协议" class="headerlink" title="封锁协议"></a>封锁协议</h2><p>在运用X锁和S锁对数据对象加锁时，还需要约定一些规则 ，例如何时申请X锁或S锁、持锁时间、何时释放等。称这些规则为封锁协议。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。</p><h3 id="一级封锁协议"><a href="#一级封锁协议" class="headerlink" title="一级封锁协议"></a>一级封锁协议</h3><p>对T要“写”的R加X锁，直到T结束。此时可以解决丢失更新。此时仍然会发生：</p><ul><li>脏读：事务T2可以绕过X锁读取数据，且读取到的是T1回滚的数据。</li><li>不可重复读：事务T2的两次读之间可以发生T1的”update“。</li><li>幻读：事务T2的两次读之间可以发生T1的”insert“。</li></ul><h3 id="二级封锁协议"><a href="#二级封锁协议" class="headerlink" title="二级封锁协议"></a>二级封锁协议</h3><ul><li><p>T发生“写”加X锁，直到T结束；（一级封锁协议）</p></li><li><p>T发生“读”R加S锁，读完即释放。</p></li></ul><p>此时可以解决丢失修改和脏读。</p><ul><li>事务T1先对R进行写（加X锁），则事务T2在读时没法加S锁，直至T1结束。</li><li>事务T2先对R进行读（加S锁），则事务T1在写时需要等待读结束（T1不一定结束）。</li></ul><p>此时仍然会发生：</p><ul><li>不可重复读：事务T1在第一次读之后（释放S锁），事务T2进行了”update”操作，事务T1再读得到的数据和上次不一致。</li><li>幻读：事务T1在第一次读之后（释放S锁），事务T2进行了”insert”操作，事务T1再读得到的数据和上次不一致。</li></ul><h3 id="三级封锁协议"><a href="#三级封锁协议" class="headerlink" title="三级封锁协议"></a>三级封锁协议</h3><ul><li><p>T发生“写”加X锁，直到T结束。</p></li><li><p>T发生“读”加S锁，直到T结束。</p></li></ul><p>此时可以解决任何并发问题，因为无论对数据进行读还是写都要加锁：</p><ul><li>写：先加X锁，之后任何读写都被禁止。</li><li>读：先加S锁，之后任何写操作都被被禁止。</li></ul><p>三级封锁协议仅允许不同的事务同时发生读操作。</p><h3 id="两段锁协议"><a href="#两段锁协议" class="headerlink" title="两段锁协议"></a>两段锁协议</h3><ul><li><p>在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁。</p></li><li><p>在释放一个封锁之后，事务不再获得任何其他封锁。</p></li></ul><p>满足所有遵守两段锁协议的事务，其并行执行的结果一定是正确的：</p><ul><li>先加X锁：X锁结束前（在两段锁协议中，不一定要事务结束才能释放X锁）任何锁都不能加上去，X锁结束后此事务不能再进行任何读写操作。</li><li>先加S锁：S锁结束前，只能对其加S锁，即只允许多个事务同时读。一旦释放一个S锁，便任何锁都加不上去，只能完成为完成的读，不能再进行新的读写操作。</li></ul><p>满足三级封锁协议的一定满足两段锁协议：</p><ul><li>先加X锁，两种协议下事务结束之前任何读写都会被禁止。</li><li>先加S锁，在两段锁协议中，若第一个锁的释放之后紧跟的事件就是事务的结束，此时就是三级封锁协议，即三级封锁协议是两段锁协议的一部分。</li></ul><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><p>READ UNCOMMITTED。对应一级封锁协议。</p><h3 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h3><p>READ COMMITTED。对应二级封锁协议。</p><h3 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h3><p>REPEATABLE READ。二级封锁协议加上不允许事务读取在该事务开始后新提交的数据。即防止了不可重复读的发生。</p><h3 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h3><p>SERIALIZABLE。对应三级封锁协议。</p><h2 id="MySql特点"><a href="#MySql特点" class="headerlink" title="MySql特点"></a>MySql特点</h2><ol><li>MySql默认的事务隔离级别是读已提交</li><li>MySql的事务是自动提交，即即使未事务，MySql也会把每个SQL语句放在一个事务中运行，这个事务是MySql自动添加上去的。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Sun Mar 31 2019 20:14:26 GMT+0800 (GMT+08:00) --&gt;&lt;h2 id=&quot;ACID&quot;&gt;&lt;a href=&quot;#ACID&quot; class=&quot;headerlink&quot; title=&quot;ACID&quot;&gt;&lt;/a&gt;ACID&lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据库" scheme="https://isjinhao.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="数据库" scheme="https://isjinhao.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
