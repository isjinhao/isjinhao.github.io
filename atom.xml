<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ISJINHAO</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://isjinhao.github.io/"/>
  <updated>2019-12-30T13:20:35.721Z</updated>
  <id>https://isjinhao.github.io/</id>
  
  <author>
    <name>ISJINHAO</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>03.02-JVM-字节码</title>
    <link href="https://isjinhao.github.io/posts/20964.html/"/>
    <id>https://isjinhao.github.io/posts/20964.html/</id>
    <published>2019-12-30T13:20:19.000Z</published>
    <updated>2019-12-30T13:20:35.721Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="字节码文件结构"><a href="#字节码文件结构" class="headerlink" title="字节码文件结构"></a>字节码文件结构</h2><p>使用<code>javap-verbose</code>命令分析一个字节码文件时将会分析该字节码文件的魔数、版本号、常量池、类信息、类的构造方法、类中的方法信息、类变量与成员变量等信息。我们先来编写一个非常简单的类。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyInterface1</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>反编译指令：<code>javap</code>，参数：<code>-p</code>、<code>-verbose</code>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> <span class="keyword">implements</span> <span class="title">MyInterface1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str = <span class="string">"1000"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStr</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> str;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStr</span><span class="params">(String str)</span> </span>&#123;<span class="keyword">this</span>.str = str; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/workspace/java/project-workspace/backend-development-summary/codes/target/classes/two/jvm/bytecodes/MyTest1.class</span><br><span class="line">  Last modified 2019-11-26; size 587 bytes</span><br><span class="line">  MD5 checksum a6fe9bd13568b3724178d222e01b213c</span><br><span class="line">  Compiled from &quot;MyTest1.java&quot;</span><br><span class="line">public class two.jvm.bytecodes.MyTest1 implements two.jvm.bytecodes.MyInterface1</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #5.#22         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = String             #23            // 1000</span><br><span class="line">   #3 = Fieldref           #4.#24         // two/jvm/bytecodes/MyTest1.str:Ljava/lang/String;</span><br><span class="line">   #4 = Class              #25            // two/jvm/bytecodes/MyTest1</span><br><span class="line">   #5 = Class              #26            // java/lang/Object</span><br><span class="line">   #6 = Class              #27            // two/jvm/bytecodes/MyInterface1</span><br><span class="line">   #7 = Utf8               str</span><br><span class="line">   #8 = Utf8               Ljava/lang/String;</span><br><span class="line">   #9 = Utf8               &lt;init&gt;</span><br><span class="line">  #10 = Utf8               ()V</span><br><span class="line">  #11 = Utf8               Code</span><br><span class="line">  #12 = Utf8               LineNumberTable</span><br><span class="line">  #13 = Utf8               LocalVariableTable</span><br><span class="line">  #14 = Utf8               this</span><br><span class="line">  #15 = Utf8               Ltwo/jvm/bytecodes/MyTest1;</span><br><span class="line">  #16 = Utf8               getStr</span><br><span class="line">  #17 = Utf8               ()Ljava/lang/String;</span><br><span class="line">  #18 = Utf8               setStr</span><br><span class="line">  #19 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #20 = Utf8               SourceFile</span><br><span class="line">  #21 = Utf8               MyTest1.java</span><br><span class="line">  #22 = NameAndType        #9:#10         // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #23 = Utf8               1000</span><br><span class="line">  #24 = NameAndType        #7:#8          // str:Ljava/lang/String;</span><br><span class="line">  #25 = Utf8               two/jvm/bytecodes/MyTest1</span><br><span class="line">  #26 = Utf8               java/lang/Object</span><br><span class="line">  #27 = Utf8               two/jvm/bytecodes/MyInterface1</span><br><span class="line">&#123;</span><br><span class="line">  public two.jvm.bytecodes.MyTest1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: ldc           #2                  // String 1000</span><br><span class="line">         7: putfield      #3                  // Field str:Ljava/lang/String;</span><br><span class="line">        10: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 5: 4</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      11     0  this   Ltwo/jvm/bytecodes/MyTest1;</span><br><span class="line">  public java.lang.String getStr();</span><br><span class="line">    descriptor: ()Ljava/lang/String;</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #3                  // Field str:Ljava/lang/String;</span><br><span class="line">         4: areturn</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 8: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Ltwo/jvm/bytecodes/MyTest1;</span><br><span class="line">  public void setStr(java.lang.String);</span><br><span class="line">    descriptor: (Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=2, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: aload_1</span><br><span class="line">         2: putfield      #3                  // Field str:Ljava/lang/String;</span><br><span class="line">         5: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 12: 0</span><br><span class="line">        line 13: 5</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       6     0  this   Ltwo/jvm/bytecodes/MyTest1;</span><br><span class="line">            0       6     1   str   Ljava/lang/String;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;MyTest1.java&quot;</span><br></pre></td></tr></table></figure><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/ccc5f00c-1a6d-44a8-adf5-12031c0a6ffe"></div><p><br></p><h3 id="字节码文件解析"><a href="#字节码文件解析" class="headerlink" title="字节码文件解析"></a>字节码文件解析</h3><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/09d5eba7-9f22-44d0-9540-5724a2fa2d73"></div><h4 id="魔数-amp-版本号"><a href="#魔数-amp-版本号" class="headerlink" title="魔数 &amp; 版本号"></a><strong>魔数</strong> &amp; 版本号</h4><p><strong>魔数</strong></p><p>所有的class字节码文件的前4个字节都是魔数，魔数值为固定值：0xCAFEBABE。翻译为“咖啡宝贝”，emmm，和Java的图标有异曲同工之妙。</p><p><strong>版本号</strong></p><p>魔数之后的4个字节为版本信息，前两个字节表示<code>minor version（次版本号）</code>，后两个字节表示<code>major version（主版本号）</code>。这里的版本号为00000034，换算成十进制，表示次版本号为0，主版本号为52。所以，该文件的版本号为：1.8.0。可以通过<code>java-version</code>命令来查看当前JDK的版本。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// JDK版本号与字节码文件版本号对应表</span><br><span class="line">J2SE 8 = 52</span><br><span class="line">J2SE 7 = 51</span><br><span class="line">J2SE 6.0 = 50</span><br><span class="line">J2SE 5.0 = 49</span><br><span class="line">JDK 1.4 = 48</span><br><span class="line">JDK 1.3 = 47</span><br><span class="line">JDK 1.2 = 46</span><br><span class="line">JDK 1.1 = 45</span><br></pre></td></tr></table></figure><p></p><h4 id="常量池（constant-pool）"><a href="#常量池（constant-pool）" class="headerlink" title="常量池（constant pool）"></a><strong>常量池（constant pool）</strong></h4><p>紧接着主版本号之后的就是常量池入口。一个Java类中定义的很多信息都是由常量池来维护和描述的，可以将常量池看作是class文件的资源仓库，比如说Java类中定义的方法与变量信息，都是存储在常量池中。常量池中主要存储两类常量：字面量与符号引用。字面量如文本字符串，Java中声明为final的常量值等，而符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等。</p><h5 id="常量池的总体结构"><a href="#常量池的总体结构" class="headerlink" title="常量池的总体结构"></a><strong>常量池的总体结构</strong></h5><p>Java类所对应的常量池主要由常量池数量与常量池数组（常量表）这两部分共同构成。常量池数量紧跟在主版本号后面，占据2个字节。常量池数组则紧跟在常量池数量之后。值得注意的是：<code>常量池数组中元素的个数=常量池数-1</code>，目的是满足某些常量池索引值的数据在特定情况下需要表达不引用任何一个常量池的含义，也就是说索引为0的位置也是一个常量（保留常量），只不过它不位于常量表中，这个常量就对应null值。如我们上面的示例中，001C表示有28个常量，常量池中有27个常量，加上一个null，正好是28个。<br>常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型、结构都是不同的，长度当然也就不同；但是，每一种元素的第一个数据都是一个u1类型，该字节是个标志位，占据1个字节。JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。</p><div align="center"><img width="95%" src="http://blogfileqiniu.isjinhao.site/9184d919-94e9-49ce-935d-2c1d9742510d"></div><p>在JVM规范中，每个变量/字段都有描述信息，描述信息主要的作用是描述字段的数据类型、方法的参数列表（包括数量、类型与顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的void类型都用一个<code>大写字符</code>来表示，对象类型则使用<code>字符L加对象的全限定名称</code>来表示。目的是压缩字节码文件的体积，如下：<code>B-byte</code>、<code>C-char</code>、<code>D-double</code>、<code>F-float</code>、<code>I-int</code>、<code>J-long</code>、<code>S-short</code>、<code>Z-boolean</code>、<code>V-void</code>、<code>L-对象类型</code>，如<br><code>Ljava/lang/String;</code>。<br>对于数组类型来说，每一个维度使用一个前置的<code>[</code>来表示，如<code>int[</code>被记录为<code>[</code>，<code>String[[</code>被记录为<code>[Ljava/lang/string</code>。</p><p><strong>描述方法</strong></p><p>用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组<code>()</code>内，如方法 <code>String getRealNameByIdAndNickNName(int id, String name);</code>的描述符为：<code>(I, Ljava/lang/String;)Ljava/lang/String;</code>。</p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/9bb27ad2-7978-4dbf-ad79-b4832a7c4a31"></div><p><strong>描述属性</strong></p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/d0c46382-591d-4099-bf3c-72bb8ed42e40"></div><h4 id="类访问标志-amp-父类-amp-接口"><a href="#类访问标志-amp-父类-amp-接口" class="headerlink" title="类访问标志&amp;父类&amp;接口"></a>类访问标志&amp;父类&amp;接口</h4><p><strong>access flags</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/515a0b61-cb5a-4026-8bb0-af01a74a54b7"></div><p>access flags中一共有16个标志位可以使用，当前只定义了其中8个，没有使用到的标志位要求一律为0。我们的代码是一个普通Java类，不是接口、枚举或者注解，被public关键字修饰但没有被声明为final和abstract，并且它使用了JDK1.2之后的编译器进行编译，因此它的ACC_PUBLIC、 ACC_SUPER标志应当为真，而ACC_FINAL、ACC_INTERFACE、ACC_ABSTRACT、ACC_SYNTHETIC、ACC_ANNOTATION、ACC_ENUM这6个标志应当为假，因此它的access flags的值应为:0x0001 &amp; 0x0020 = 0x0021。16进制显示也确实如此。</p><p><strong>当前类名 &amp; 父类名</strong></p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/5982fb78-f848-4628-963a-003dbd3c120e"></div><p><strong>接口个数 &amp; 接口名</strong></p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/4ba25311-a2fc-4c8c-ba6a-708323eb7476"></div><h4 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h4><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/e677e76c-daf2-4dbd-9da7-bbca7ba0a59b"></div><p><strong>字段访问标志</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/d4060b33-d570-42f0-aa71-0611fb3d5792"></div><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/ef8b649d-c035-40a2-97e3-7d8e7cf9a405"></div><h4 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h4><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/52748985-025f-47c0-ba60-6f42c284497c"></div><p><strong>方法访问标志</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/64435e52-d4da-4444-8719-3458df27a56a"></div><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/d51a8538-d479-4a09-b1f4-1eb26badea21"></div><h4 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h4><p>属性表（attribute_info）在前面的讲解之中已经出现过数次，在Class、字段表方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些。不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息。下面是属性表名称及其对应的位置。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/5e250661-f22f-4405-9955-106157dc7a70"></div><p><strong>Code属性</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/832f4c6f-7807-44b8-8829-c63678f1f383"></div><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/44069c3d-6a1c-4c5b-8508-b3ca86c1e7e1"></div><p><strong>LineNumberTable属性</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/9a440455-7d7e-4bbf-beaf-ec44b25fc1ea"></div><p>line_number_table是一个数量为 line_number_table_length、类型为 line_number_info的集合，line_number_info表包括了 start_pc 和 line_number两个u2类型的数据项，前者是字节码行号，后者是Java源码行号。</p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/34e0c3c5-359f-4f23-87f1-fd1796fefc56"></div><p><strong>LocalVariableTable</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/b348cec4-abbe-49a0-adb5-ea230d55ea27"></div><p>其中，local_variable_info项目代表了一个栈帧与源码中的局部变量的关联。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/b3d30433-e5e6-4a0a-b32c-53ccf40c17f3"></div><p>start_pc和 length属性分别代表这个局部变量的生命周期开始的字节码偏移量及其作用范围覆盖的长度，两者结合起来就是这个局部变量在字节码之中的作用域范围。name_index和 descriptor_index都是指向常量池中 CONSTANT_Utf8_info型常量的索引，分别代表了局部变量的名称以及这个局部变量的描述符。index是这个局部变量在栈帧局部变量表中slot的位置。当这个变量数据类型是64位类型时（double和long），它占用的Slot为 index 和 index+1两个。</p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/35f73683-b82b-46ef-b0b8-0d19499c9487"></div><p><strong>ConstantValue属性</strong></p><p>Constant Value属性的作用是通知虚拟机自动为静态变量赋值。只有被 static 关键字修饰的变量（类变量）才可以使用这项属性。类似“int x=123”和“static int=123”这样的变量定义在Java程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对手非 static 类型的变量（也就是实例变量）的赋值是在实例构造器<code>&lt;init&gt;</code>方法中进行的；而对于类变量则有两种方式可以选择：在类构造器<code>&lt;clini&gt;</code>方法中或者使用 Constant Value属性。目前 Sun Java 编译器的选择是：如果同时使用 fina l和 static 来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者 java.lang.String的话，就生成 Constant Value 属性来进行初始化，如果这个变量没有被 final 修饰，或者非基本类型及字符串，则将会选择在<code>&lt;ckinit&gt;</code>方法中进行初始化。<br>虽然有 final 关键字才更符合“Constant Value”的语义，但虚拟机规范中并没有强制要求字段必须设置了 ACC_FINAL标志只要求了有 Constant Value 属性的字段必须设置 ACC_STATIC 标志而已，对 final 关键字的要求是 Javac编译器自己加入的限制。而对 Constant Value 的属性值只能限于基本类型和 String，不过其实这不是什么限制，因为此属性的属性值只是一个常量池的索引号，由于 Class 文件格式的常量类型中只有与基本属性和字符串相对应的字面量，所以就算 Constant Value 属性想支持别的类型也无能为力。<br>从数据结构中可以看出， Constant Value 属性是一个定长属性，它的 attribute_length 数据项值必须固定为2。 constantvalue_index 数据项代表了常量池中一个字面量常量的引用，根据字段类型的不同，字面量可以是 CONSTANT_Long_info、 CONSTANT_Float_info、CONSTANT_Double_info、 CONSTANT_Integer_info、CONSTANT_ String_info常量中的一种。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/440d82bb-e622-4911-bcf4-6e76b6a10e94"></div><h4 id="SourceFile属性"><a href="#SourceFile属性" class="headerlink" title="SourceFile属性"></a>SourceFile属性</h4><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/c683dbdc-c969-45d4-98ec-a495587a8b21"></div><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/a8cb668e-54ff-48c1-9ab0-dd6b1aefd1eb"></div><p><br></p><h2 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h2><h3 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h3><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/6627201a-3244-42cf-bdf4-095c4630e0dd"></div><p>静态属性的初始化和静态代码块的执行都是在JDK自动生成的<code>cinit</code>方法中完成的。其实是指令重排序的体现。</p><p><br></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/8d998e66-d9c6-41ca-96e3-debc61f7a69a"></div><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/d9acc670-6c4f-4854-ac1b-8f16f3136a4c"></div><p>实例变量的赋值本质上都是在构造方法里进行的。</p><p><br></p><h3 id="分析异常"><a href="#分析异常" class="headerlink" title="分析异常"></a>分析异常</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ArrayIndexOutOfBoundsException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">"test.txt"</span>);</span><br><span class="line">        ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">9999</span>);</span><br><span class="line">        serverSocket.accept();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (FileNotFoundException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ex;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"finally"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br></pre></td><td class="code"><pre><span class="line">Classfile /D:/workspace/java/project-workspace/backend-development-summary/codes/target/classes/two/jvm/bytecodes/MyTest4.class</span><br><span class="line">  Last modified 2019-11-28; size 1347 bytes</span><br><span class="line">  MD5 checksum d2e6f4cb6a617878f8c9757b8cc2c6e6</span><br><span class="line">  Compiled from &quot;MyTest4.java&quot;</span><br><span class="line">public class two.jvm.bytecodes.MyTest4</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #16.#45        // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #46            // java/io/FileInputStream</span><br><span class="line">   #3 = String             #47            // test.txt</span><br><span class="line">   #4 = Methodref          #2.#48         // java/io/FileInputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">   #5 = Class              #49            // java/net/ServerSocket</span><br><span class="line">   #6 = Methodref          #5.#50         // java/net/ServerSocket.&quot;&lt;init&gt;&quot;:(I)V</span><br><span class="line">   #7 = Methodref          #5.#51         // java/net/ServerSocket.accept:()Ljava/net/Socket;</span><br><span class="line">   #8 = Fieldref           #52.#53        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #9 = String             #54            // finally</span><br><span class="line">  #10 = Methodref          #55.#56        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #11 = Class              #57            // java/io/FileNotFoundException</span><br><span class="line">  #12 = Class              #58            // java/lang/NullPointerException</span><br><span class="line">  #13 = Methodref          #15.#59        // two/jvm/bytecodes/MyTest4.test:()V</span><br><span class="line">  #14 = Class              #60            // java/io/IOException</span><br><span class="line">  #15 = Class              #61            // two/jvm/bytecodes/MyTest4</span><br><span class="line">  #16 = Class              #62            // java/lang/Object</span><br><span class="line">  #17 = Utf8               &lt;init&gt;</span><br><span class="line">  #18 = Utf8               ()V</span><br><span class="line">  #19 = Utf8               Code</span><br><span class="line">  #20 = Utf8               LineNumberTable</span><br><span class="line">  #21 = Utf8               LocalVariableTable</span><br><span class="line">  #22 = Utf8               this</span><br><span class="line">  #23 = Utf8               Ltwo/jvm/bytecodes/MyTest4;</span><br><span class="line">  #24 = Utf8               test</span><br><span class="line">  #25 = Utf8               inputStream</span><br><span class="line">  #26 = Utf8               Ljava/io/InputStream;</span><br><span class="line">  #27 = Utf8               serverSocket</span><br><span class="line">  #28 = Utf8               Ljava/net/ServerSocket;</span><br><span class="line">  #29 = Utf8               ex</span><br><span class="line">  #30 = Utf8               Ljava/io/FileNotFoundException;</span><br><span class="line">  #31 = Utf8               Ljava/lang/NullPointerException;</span><br><span class="line">  #32 = Utf8               StackMapTable</span><br><span class="line">  #33 = Class              #57            // java/io/FileNotFoundException</span><br><span class="line">  #34 = Class              #58            // java/lang/NullPointerException</span><br><span class="line">  #35 = Class              #63            // java/lang/Throwable</span><br><span class="line">  #36 = Utf8               Exceptions</span><br><span class="line">  #37 = Class              #64            // java/lang/ArrayIndexOutOfBoundsException</span><br><span class="line">  #38 = Utf8               main</span><br><span class="line">  #39 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #40 = Utf8               args</span><br><span class="line">  #41 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #42 = Class              #60            // java/io/IOException</span><br><span class="line">  #43 = Utf8               SourceFile</span><br><span class="line">  #44 = Utf8               MyTest4.java</span><br><span class="line">  #45 = NameAndType        #17:#18        // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #46 = Utf8               java/io/FileInputStream</span><br><span class="line">  #47 = Utf8               test.txt</span><br><span class="line">  #48 = NameAndType        #17:#65        // &quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">  #49 = Utf8               java/net/ServerSocket</span><br><span class="line">  #50 = NameAndType        #17:#66        // &quot;&lt;init&gt;&quot;:(I)V</span><br><span class="line">  #51 = NameAndType        #67:#68        // accept:()Ljava/net/Socket;</span><br><span class="line">  #52 = Class              #69            // java/lang/System</span><br><span class="line">  #53 = NameAndType        #70:#71        // out:Ljava/io/PrintStream;</span><br><span class="line">  #54 = Utf8               finally</span><br><span class="line">  #55 = Class              #72            // java/io/PrintStream</span><br><span class="line">  #56 = NameAndType        #73:#65        // println:(Ljava/lang/String;)V</span><br><span class="line">  #57 = Utf8               java/io/FileNotFoundException</span><br><span class="line">  #58 = Utf8               java/lang/NullPointerException</span><br><span class="line">  #59 = NameAndType        #24:#18        // test:()V</span><br><span class="line">  #60 = Utf8               java/io/IOException</span><br><span class="line">  #61 = Utf8               two/jvm/bytecodes/MyTest4</span><br><span class="line">  #62 = Utf8               java/lang/Object</span><br><span class="line">  #63 = Utf8               java/lang/Throwable</span><br><span class="line">  #64 = Utf8               java/lang/ArrayIndexOutOfBoundsException</span><br><span class="line">  #65 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #66 = Utf8               (I)V</span><br><span class="line">  #67 = Utf8               accept</span><br><span class="line">  #68 = Utf8               ()Ljava/net/Socket;</span><br><span class="line">  #69 = Utf8               java/lang/System</span><br><span class="line">  #70 = Utf8               out</span><br><span class="line">  #71 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #72 = Utf8               java/io/PrintStream</span><br><span class="line">  #73 = Utf8               println</span><br><span class="line">&#123;</span><br><span class="line">  public two.jvm.bytecodes.MyTest4();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Ltwo/jvm/bytecodes/MyTest4;</span><br><span class="line">  public static void test() throws java.io.IOException, java.lang.ArrayIndexOutOfBoundsException;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=3, args_size=0</span><br><span class="line">         0: new           #2                  // class java/io/FileInputStream</span><br><span class="line">         3: dup</span><br><span class="line">         4: ldc           #3                  // String test.txt</span><br><span class="line">         6: invokespecial #4                  // Method java/io/FileInputStream.&quot;&lt;init&gt;&quot;:(Ljava/lang/String;)V</span><br><span class="line">         9: astore_0</span><br><span class="line">        10: new           #5                  // class java/net/ServerSocket</span><br><span class="line">        13: dup</span><br><span class="line">        14: sipush        9999</span><br><span class="line">        17: invokespecial #6                  // Method java/net/ServerSocket.&quot;&lt;init&gt;&quot;:(I)V</span><br><span class="line">        20: astore_1</span><br><span class="line">        21: aload_1</span><br><span class="line">        22: invokevirtual #7                  // Method java/net/ServerSocket.accept:()Ljava/net/Socket;</span><br><span class="line">        25: pop</span><br><span class="line">        26: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        29: ldc           #9                  // String finally</span><br><span class="line">        31: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        34: goto          54</span><br><span class="line">        37: astore_0</span><br><span class="line">        38: aload_0</span><br><span class="line">        39: athrow</span><br><span class="line">        40: astore_0</span><br><span class="line">        41: aload_0</span><br><span class="line">        42: athrow</span><br><span class="line">        43: astore_2</span><br><span class="line">        44: getstatic     #8                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        47: ldc           #9                  // String finally</span><br><span class="line">        49: invokevirtual #10                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">        52: aload_2</span><br><span class="line">        53: athrow</span><br><span class="line">        54: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             0    26    37   Class java/io/FileNotFoundException</span><br><span class="line">             0    26    40   Class java/lang/NullPointerException</span><br><span class="line">             0    26    43   any</span><br><span class="line">            37    44    43   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 13: 0</span><br><span class="line">        line 14: 10</span><br><span class="line">        line 15: 21</span><br><span class="line">        line 21: 26</span><br><span class="line">        line 22: 34</span><br><span class="line">        line 16: 37</span><br><span class="line">        line 17: 38</span><br><span class="line">        line 18: 40</span><br><span class="line">        line 19: 41</span><br><span class="line">        line 21: 43</span><br><span class="line">        line 22: 52</span><br><span class="line">        line 23: 54</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">           10      16     0 inputStream   Ljava/io/InputStream;</span><br><span class="line">           21       5     1 serverSocket   Ljava/net/ServerSocket;</span><br><span class="line">           38       2     0    ex   Ljava/io/FileNotFoundException;</span><br><span class="line">           41       2     0    ex   Ljava/lang/NullPointerException;</span><br><span class="line">      StackMapTable: number_of_entries = 4</span><br><span class="line">        frame_type = 101 /* same_locals_1_stack_item */</span><br><span class="line">          stack = [ class java/io/FileNotFoundException ]</span><br><span class="line">        frame_type = 66 /* same_locals_1_stack_item */</span><br><span class="line">          stack = [ class java/lang/NullPointerException ]</span><br><span class="line">        frame_type = 66 /* same_locals_1_stack_item */</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = 10 /* same */</span><br><span class="line">    Exceptions:</span><br><span class="line">      throws java.io.IOException, java.lang.ArrayIndexOutOfBoundsException</span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=2, args_size=1</span><br><span class="line">         0: invokestatic  #13                 // Method test:()V</span><br><span class="line">         3: goto          7</span><br><span class="line">         6: astore_1</span><br><span class="line">         7: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             0     3     6   Class java/io/IOException</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 27: 0</span><br><span class="line">        line 30: 3</span><br><span class="line">        line 28: 6</span><br><span class="line">        line 31: 7</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       8     0  args   [Ljava/lang/String;</span><br><span class="line">      StackMapTable: number_of_entries = 2</span><br><span class="line">        frame_type = 70 /* same_locals_1_stack_item */</span><br><span class="line">          stack = [ class java/io/IOException ]</span><br><span class="line">        frame_type = 0 /* same */</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;MyTest4.java&quot;</span><br></pre></td></tr></table></figure><p>从字节码的角度是不区分受查异常和非受查异常的，但是区分try-catch异常处理和throws的异常处理。而对于<code>throw new Exception()</code>语法来说，仅仅是抛出了一个异常，需要调用者接收。</p><p><strong>Exceptions属性</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/fecffe8f-0131-4258-a2e9-8d56b8cc91ba"></div><p>Exceptions属性是在方法表中与Code属性平级的一项属性，作用是列举出方法中可能抛出的受查异常（Checked Excepitons），也就是方法描述时在 throws 关键字后面列举的异常。结构如上表。</p><p><strong>exception_index_table</strong></p><p>Exceptions属性中的 number_of_exceptions项表示方法可能抛出 number_of_exceptions 种受查异常，每一种受查异常使用一个exception_index_table项表示，exception_index_table是一个指向常量池中 CONSTANT_Class_info 型常量的索引，代表了该受查异常的类型。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/3bc00f7f-2c11-4150-a52b-5c3494833723"></div><p><strong>exception_table</strong></p><p>exception_table是存在Code属性中的，也是try_catch在字节码层次的体现。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/e572d50e-f212-4ab5-8587-812cfa6be59a"></div><p>如果当字节码在第 start_pc 行到第 end_pc 行之间（不含第 end 行出现了类型为 catch_type或者其子类的异常（catch_type）为指向一个 CONSTANF_Classinfo 型常量的索引，则转到第 handler_pc 行继续处理。当 catch_type的值为0时，代表任意异常情况都需要转向到 handler_pc 处进行处理。<br>使用jclasslib分析上面的异常：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> 0 new #2 &lt;java/io/FileInputStream&gt;</span><br><span class="line"> 3 dup</span><br><span class="line"> 4 ldc #3 &lt;test.txt&gt;</span><br><span class="line"> 6 invokespecial #4 &lt;java/io/FileInputStream.&lt;init&gt;&gt;</span><br><span class="line"> 9 astore_0</span><br><span class="line">10 new #5 &lt;java/net/ServerSocket&gt;</span><br><span class="line">13 dup</span><br><span class="line">14 sipush 9999</span><br><span class="line">17 invokespecial #6 &lt;java/net/ServerSocket.&lt;init&gt;&gt;</span><br><span class="line">20 astore_1</span><br><span class="line">21 aload_1</span><br><span class="line">22 invokevirtual #7 &lt;java/net/ServerSocket.accept&gt;</span><br><span class="line">25 pop</span><br><span class="line">26 getstatic #8 &lt;java/lang/System.out&gt;</span><br><span class="line">29 ldc #9 &lt;finally&gt;</span><br><span class="line">31 invokevirtual #10 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">34 goto 54 (+20)</span><br><span class="line">37 astore_0</span><br><span class="line">38 aload_0</span><br><span class="line">39 athrow</span><br><span class="line">40 astore_0</span><br><span class="line">41 aload_0</span><br><span class="line">42 athrow</span><br><span class="line">43 astore_2</span><br><span class="line">44 getstatic #8 &lt;java/lang/System.out&gt;</span><br><span class="line">47 ldc #9 &lt;finally&gt;</span><br><span class="line">49 invokevirtual #10 &lt;java/io/PrintStream.println&gt;</span><br><span class="line">52 aload_2</span><br><span class="line">53 athrow</span><br><span class="line">54 return</span><br></pre></td></tr></table></figure><p></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/237f2320-1c29-4304-b319-dfc689047f15"></div><p>从上面反编译的助记符可以知道，finally的处理是在每个 catch 后面复制一份finally里面的指令来完成的。</p><p><br></p><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (o)&#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags:</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: aload_0</span><br><span class="line">         1: getfield      #3     // Field o:Ljava/lang/Object;</span><br><span class="line">         <span class="number">4</span>: dup</span><br><span class="line">         <span class="number">5</span>: astore_1</span><br><span class="line">         <span class="number">6</span>: monitorenter<span class="comment">// 加锁</span></span><br><span class="line">         7: getstatic     #4     // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        <span class="number">10</span>: aload_0</span><br><span class="line">        11: getfield      #3     // Field o:Ljava/lang/Object;</span><br><span class="line">        14: invokevirtual #5     // Method java/io/PrintStream.println:(Ljava/lang/Object;)V</span><br><span class="line">        <span class="number">17</span>: aload_1</span><br><span class="line">        <span class="number">18</span>: monitorexit<span class="comment">// 正常解锁</span></span><br><span class="line">        <span class="number">19</span>: goto          <span class="number">27</span><span class="comment">// 正常解锁之后return</span></span><br><span class="line">        <span class="number">22</span>: astore_2</span><br><span class="line">        <span class="number">23</span>: aload_1</span><br><span class="line">        <span class="number">24</span>: monitorexit<span class="comment">// 保证在athrow之前锁被释放</span></span><br><span class="line">        <span class="number">25</span>: aload_2</span><br><span class="line">        <span class="number">26</span>: athrow</span><br><span class="line">        <span class="number">27</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">7</span>    <span class="number">19</span>    <span class="number">22</span>   any</span><br><span class="line">            <span class="number">22</span>    <span class="number">25</span>    <span class="number">22</span>   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line <span class="number">16</span>: <span class="number">0</span></span><br><span class="line">        line <span class="number">17</span>: <span class="number">7</span></span><br><span class="line">        line <span class="number">18</span>: <span class="number">17</span></span><br><span class="line">        line <span class="number">19</span>: <span class="number">27</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">28</span>     <span class="number">0</span>  <span class="keyword">this</span>   Ltwo/jvm/bytecodes/MyTest2;</span><br><span class="line">      StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">        frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">          offset_delta = <span class="number">22</span></span><br><span class="line">          locals = [ class two/jvm/bytecodes/MyTest2, class java/lang/Object ]</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">          offset_delta = <span class="number">4</span></span><br></pre></td></tr></table></figure><p><strong>异常时退出的处理</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/ca28d1cf-c96f-4ec5-960d-91582a5561e1"></div><p>如果[7, 19)行的任何异常转到22行，[22, 25)行的任何异常转到22行。</p><p><strong>monitorenter</strong></p><p>The <em>objectref</em> must be of type <code>reference</code>.<br>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes <em>monitorenter</em> attempts to gain ownership of the monitor associated with <em>objectref</em>, as follows:</p><ul><li>If the entry count of the monitor associated with <em>objectref</em> is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.</li><li>If the thread already owns the monitor associated with <em>objectref</em>, it reenters the monitor, incrementing its entry count.</li><li>If another thread already owns the monitor associated with <em>objectref</em>, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership.<br>Run-time Exceptions</li><li>If <em>objectref</em> is <code>null</code>, monitorenter throws a <code>NullPointerException</code><strong>.</strong></li></ul><p><strong>monitorexit</strong></p><ul><li>The <em>objectref</em> must be of type <code>reference</code>.</li><li>The thread that executes <em>monitorexit</em> must be the owner of the monitor associated with the instance referenced by <em>objectref</em>.</li><li>The thread decrements the entry count of the monitor associated with <em>objectref</em>. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so.<br>Run-time Exceptions</li><li>If <em>objectref</em> is <code>null</code>, <em>monitorexit</em> throws a <code>NullPointerException</code>.</li><li>Otherwise, if the thread that executes <em>monitorexit</em> is not the owner of the monitor associated with the instance referenced by <em>objectref</em>, <em>monitorexit</em> throws an <code>IllegalMonitorStateException</code>.</li><li>Otherwise, if the Java Virtual Machine implementation enforces the rules on structured locking described in <a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10">§2.11.10</a> and if the second of those rules is violated by the execution of this <em>monitorexit</em> instruction, then <em>monitorexit</em> throws an <code>IllegalMonitorStateException</code>.</li></ul><p><br></p><h3 id="分析this"><a href="#分析this" class="headerlink" title="分析this"></a>分析this</h3><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/254a4352-87c0-483f-8221-0aa44e45520f"></div><p>对于Java类中的每一个实例方法（非static方法），其在编译后所生成的字节码当中，方法参数的数量总是会比源代码中方法参数的数量多一个，即参数this，它位于方法的第一个参数位置处；这样，我们就可以在Java的实例方法中使用this来去访问当前对象的属性以及其他方法。<br>这个操作是在编译期间完成的，即由 javac 编译器在编译的时候将对this的访问转化为对一个普通实例方法参数的访问;接下来在运行期间。由JVM在调用实例方法时，自动向实例方法传入该this。所以在实例方法的局部变量表中，至少会有一个指向当前对象的局部变量。</p><p><strong>上图的4个局部变量</strong></p><ul><li>this</li><li>inputStream</li><li>serverSocket</li><li>第四个局部变量是两个catch中的某一个异常。因为两个异常最多只能有一个生效，所以局部变量最多是4个。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;字节码文件结构&quot;&gt;&lt;a href=&quot;#字节码文件结构&quot; class=&quot;headerlink&quot; title=&quot;字节
      
    
    </summary>
    
      <category term="JVM" scheme="https://isjinhao.github.io/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>03.03-JVM-解释执行</title>
    <link href="https://isjinhao.github.io/posts/11515.html/"/>
    <id>https://isjinhao.github.io/posts/11515.html/</id>
    <published>2019-12-30T13:20:19.000Z</published>
    <updated>2019-12-30T13:20:35.726Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="运行时的栈帧结构"><a href="#运行时的栈帧结构" class="headerlink" title="运行时的栈帧结构"></a>运行时的栈帧结构</h2><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。也就是说虚拟机每调用一个方法都会在当前调用栈上压入一个栈帧，调用完了删除调用栈栈顶的栈帧。<br>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关联的方法称为当前方法（Current Method）。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作，在概念模型上，典型的栈帧结构如图。</p><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/7db50cc5-8d27-4f47-b789-bfdb44c82a5d"></div><p><br></p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表（Local Variable Table）是一组变量值存储空间，用于存放<strong>方法参数</strong>和<strong>方法内部定义的局部变量</strong>。在Java程序编译为 Class 文件时，就在方法的Code属性的 max locals 数据项中确定了该方法所需要分配的局部变量表的最大容量。局部变量表的容量以变量槽（Variable Slot， 下称Slot）为最小单位，同时每个 Slot 都应该能存放一个boolean、byte、char、 short、int、float、 reference 或 returnAddress 类型的数据（这8种数据类型，都可以使用32位或更小的物理内存来存放），但它不是指每个Slot占用32位长度的内存空间，实际上Slot的长度可以随着处理器、操作系统或虚拟机的不同而发生变化。比如64位虚拟机中完全可以用64位的物理空间去实现一个Slot，只要在后期使用对齐和补白的手段让Slot在外观上看起来与32位虚拟机中的一致就可以了。<br>一个Slot可以存放一个32位以内的数据类型，Java中占用32位以内的数据类型有 boolean、byte、char、short、int、float、reference 和 returnAddress 8种类型。对于64位的数据类型，虚拟机会以高位对其的方式为其分配两个连续的Slot空间。Java语言中明确的（reference类型则可能是32位也可能是64位）64位的数据类型只有long 和 double两种。<br>其中 reference 类型表示对一个对象实例的引用，它具有两个功能。一是从此引用中直接或间接地查找到对象在Java堆中的数据存放的起始地址索引，二是此引用中直接或间接地查找到对象所属数据类型在方法区中的存储的类型信息。returnAddress 类型目前已经很少见了，它是为很古老的Java虚拟机实现异常处理服务的。<br>虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表最大的Slot数量如果访问的是32位数据类型的变量,索引n就代表了使用第n个Slot 如果是64位数据类型的变量，则说明会同时使用n和n+1两个Slot。对于两个相邻的共同存放一个64位数据的两个Slot，不允许采用任何方式单独访问其中的某一个，Java虚拟机规范中明确要求了如果遇到进行这种操作的字节码序列，虚拟机应该在类加载的校验阶段出异常。</p><h4 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h4><p>在方法执行时，虚拟机是使用局部变量表完成参数值到参数变量列表的传递过程的，如果执行的是实例方法（非static的方法），那局部变量表中第0位索引的Slot默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用从1开始的局部变量Slot，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的Slot。为了尽可能节省栈帧空间，局部变量表中的Slot是可以重用的，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的Slot就可以交给其他变量使用。不过，这样的设计除了节省栈帧空间以外，还会伴随一些额外的副作用，例如，在某些情况下，Slot的复用会直接影响到系统的垃圾收集行为。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] placeHolder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> *<span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[GC (System.gc())  68403K-&gt;66336K(110080K), 0.0012697 secs]</span></span><br><span class="line"><span class="comment">[Full GC (System.gc())  66336K-&gt;66160K(110080K), 0.0054959 secs]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] placeHolder = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> *<span class="number">1024</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">[GC (System.gc())  68403K-&gt;66336K(110080K), 0.0010283 secs]</span></span><br><span class="line"><span class="comment">[Full GC (System.gc())  66336K-&gt;624K(110080K), 0.0059838 secs]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>placeHolder能否被回收的根本原因是：局部变量表中的Slot是否还存有关于 placeholder 数组对象的引用。第一次修改中，代码虽然已经离开了 placeholder 的作用域，但在此之后，没有任何对局部变量表的读写操作，placeholder 原本所占用的Slot还没有被其他变量所复用，所以作为 GC Roots 一部分的局部变量表仍然保持着对它的关联。这种关联没有被及时打断，在绝大部分情况下影响都很轻微。但如果遇到一个方法，其后面的代码有一些耗时很长的操作，而前面又定义了占用了大量内存、实际上已经不会再使用的变量，手动将其设置为null值（用来代替那句int a=0，把变量对应的局部变量表Slot清空）便不见得是一个绝对无意义的操作，这种操作可以作为一种在极特殊情形（对象占用内存大、此方法的栈帧长时间不能被回收、方法调用次数达不到JIT的编译条件）下的“奇技”来使用。</p><h4 id="局部变量需要初始化"><a href="#局部变量需要初始化" class="headerlink" title="局部变量需要初始化"></a>局部变量需要初始化</h4><p>关于局部变量表，还有一点可能会对实际开发产生影响，就是局部变量不像前面介绍的类变量那样存在“准备阶段”。类变量有两次赋初始值的过程，一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值。因此，即使在初始化阶段程序员没有为类变量赋值也没有关系，类变量仍然具有一个确定的初始值。但局部变量就不一样如果一个局部变量定义了但没有赋初始值是不能使用的，而且这个错误会在被编译期间就被发现。</p><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/b8fcb7e8-5a04-45ce-9a94-51a09066614b"></div><p><br></p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的 max_stacks 数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括 long 和 double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的深度都不会超过在 max stacks 数据项中设定的最大值。当一个方法刚刚开始执行的时候，这个方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是出栈/入栈操作。例如，在做算术运算的时候是通过操作数栈来进行的，又或者在调用其他方法的时候是通过操作数栈来进行参数传递的。<br>举个例子，整数加法的字节码指令iadd在运行的时候操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会将这两个int值出栈并相加，然后将相加的结果入栈。操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，在编译程序代码的时候，编译器要严格保证这一点，在类校验阶段的数据流分析中还要再次验证这一点。再以上面的iadd指令为例，这个指令用于整型数加法，它在执行时，最接近栈顶的两个元素的数据类型必须为int型，不能出现一个long和一个float使用iadd命令相加的情况。</p><p><br></p><h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。我们知道 Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接<br>引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。这一部分在后面的方法调用详细解释。</p><p><br></p><h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行后，只有两种方式可以退出这个方法。第一种方式是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者（调用当前方法的方法称为调用者），是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为正常完成出口（Normal Method Invocation Completion），另外一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是Java虚拟机内部产生的异常，还是代码中使用athrow字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，这种退出方法的方式称为异常完成出口（Abrupt Method Invocation Completion）。一个方法使用异常完成出口的方式退出，是不会给它的上层调用者产生任何返回值的。<br>无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。<br>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p><p><br></p><h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。在程序运行时，进行方法调用是最普遍、最频繁的操作，但前面提到，Class文件的编译过程中不包含传统编译中的连接步骤，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的人口地址（相当于之前说的直接引用），这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p><p><br></p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用中的目标方法在 Class 文件里面都是一个常量池中的符号引用，在连接时期的解析阶段，会将其中的一部分符号引用转化为直接引用。这种解析能成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution），在Java语言中符合“编译期可知，运行期不可变”这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写其他版本，因此它们都适合在类加载阶段进行解析。<br>在Java虚拟机里面提供了5条方法调用字节码指令：</p><ul><li>invokestatic：调用静态方法。</li><li>invokespecial：调用实例构造器<code>&lt;init&gt;</code>方法、私有方法和父类方法。</li><li>invokevirtual：调用所有的虚方法。</li><li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象。</li><li>invokedynamic：支持动态语言而存在的，本篇不做分析。<br>只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法4类，它们在类加载的时候就会把符号引用解析为该方法的直接引用。这些方法可以称为非虚方法，与之相反，其他方法称为虚方法。而final方法虽然也是通过 invokevirtual 调用的，但是实际上在编译期间就可以被确定，所以也是非虚方法。</li></ul><p><br></p><h3 id="静态分派（重载）"><a href="#静态分派（重载）" class="headerlink" title="静态分派（重载）"></a>静态分派（重载）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Human human)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"human"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Men men)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"men"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(Women women)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"women"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyTest2 myTest2 = <span class="keyword">new</span> MyTest2();</span><br><span class="line">        Human human1 = <span class="keyword">new</span> Women();</span><br><span class="line">        Human human2 = <span class="keyword">new</span> Men();</span><br><span class="line">        myTest2.test(human1);</span><br><span class="line">        myTest2.test(human2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Women</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;  &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Men</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">human</span></span><br><span class="line"><span class="comment">human</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>我们把上面代码中的“Human”称为变量的静态类型（Static Type），或者叫做的外观类型（Apparent Type），后面的“Man”则称为变量的实际类型（Actual Type），静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。例如下<br>面的代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实际类型变化</span></span><br><span class="line">Human human = <span class="keyword">new</span> Man();</span><br><span class="line">human = <span class="keyword">new</span> Women();</span><br><span class="line"><span class="comment">// 静态类型变化</span></span><br><span class="line">test((Men) human);</span><br><span class="line">test((Women) human);</span><br></pre></td></tr></table></figure><p></p><p>使用哪个重载版本完全取决于传入参数的数量和数据类型。代码中刻意地定义了两个静态类型相同但实际类型不同的变量，但编译器在重载时是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译期可知的，因此，在编译阶段，Javac编译器会根据参数的静态类型决定使用哪个重载版本。<br>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。另外，编译器虽然能确定出方法的重载版本，但在很多情况下这个重载版本并不是“唯一的”，往往只能确定一个“更加合适的”版本。这种模糊的结论在由0和1构成的计算机世界中算是比较“稀罕”的事情，这种模糊结论的主要原因是字面量不需要定义，所以字面量没有显式的静态类型，它的静态类型只能通过语言上的规则去理解和推断。</p><h5 id="重载方法匹配优先级测试"><a href="#重载方法匹配优先级测试" class="headerlink" title="重载方法匹配优先级测试"></a>重载方法匹配优先级测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Object arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"object"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"int"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"long"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Character arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Character"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"char"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"可变参数"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(Serializable arg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Serializable"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test(<span class="string">'a'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>保留全部方法，运行后输出：char。</li><li>注释参数类型为char的方法，运行后输出：int。</li><li>再注释参数类型为int的方法，运行后输出：long。</li><li>再注释参数类型为Character的方法，运行后输出：Serializable。</li><li>再注释参数类型为Serializable的方法，运行后输出：object。</li><li>再注释参数类型为Object的方法，运行后输出：可变参数。</li></ul><p><br></p><h3 id="动态分配（重写）"><a href="#动态分配（重写）" class="headerlink" title="动态分配（重写）"></a>动态分配（重写）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"man"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Women</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"women"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Human human1 = <span class="keyword">new</span> Man();</span><br><span class="line">    Human human2 = <span class="keyword">new</span> Women();</span><br><span class="line">    human1.sayHello();</span><br><span class="line">    human2.sayHello();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">man</span></span><br><span class="line"><span class="comment">women</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/e1124e8a-62f4-466b-89a7-0d04792f2589"></div><p>0~15行的字节码是准备动作，作用是建立 human1 和 human2 的内存空间，调用Man和 Woman类型的实例构造器，将这两个实例的引用存放在第1、2个局部变量表Slot之中，这个动作也就对应了代码中的这两句：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Human human1 = <span class="keyword">new</span> Man()</span><br><span class="line"><span class="function">Human human2 new <span class="title">Woman</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p></p><p>接下来的16~21句是关键部分，16、20两句分别把刚刚创建的两个对象的引用压到栈顶，这两个对象是将要执行的 sayHello 方法的所有者，称为接收者（Receiver）；17和21句是方法调用指令，这两条调用指令单从字节码角度来看是完全一样的，但是这两句指令最终执行的目标方法并不相同。原因就需要从 invokevirtual 指令的多态查找过程开始说起，invokevirtual指令的运行时解析过程大致分为以下几个步骤：</p><ol><li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li><li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常。</li><li>否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程。</li><li>如果始终没有找到合适的方法，则抛出java.ang.AbstractMethodError异常。<br>由于 invokevirtual 指令执行的第一步就是在运行期确定接收者的实际类型，所以两次调用中的 invokevirtual 指令把常量池中的类方法符号引用解析到了不同的直接引用上，这个过程就是Java语言中方法重写的本质。我们把这种在运行期根据实际类型确定方法执行版本的分派过程称为动态分派。</li></ol><p><br></p><h3 id="单分派和多分派"><a href="#单分派和多分派" class="headerlink" title="单分派和多分派"></a>单分派和多分派</h3><p>方法的接收者与方法的参数统称为方法的宗量，这个定义最早应该来源于《Java与模式》一书。根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">_360</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"father choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose qq"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(_360 arg)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"son choose 360"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         Father father = <span class="keyword">new</span> Father();</span><br><span class="line">         Father son = <span class="keyword">new</span> Son();</span><br><span class="line">         father.hardChoice(<span class="keyword">new</span> _360());</span><br><span class="line">         son.hardChoice(<span class="keyword">new</span> QQ());</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">father choose 360</span></span><br><span class="line"><span class="comment">son choose qq</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>我们来看看编译阶段编译器的选择过程，也就是静态分派的过程。这时选择目标方法的依据有两点：一是静态类型是 <code>Father</code> 还是 <code>Son</code> ，二是方法参数是<code>QQ</code>还是<code>_360</code>。这次选择结果的最终产物是产生了两条 <code>invokevirtual</code> 指令，两条指令的参数分别为常量池中指向 <code>Father.hardChoice(_360)</code>及 <code>Father.hardChoice(QQ)</code>方法的符号引用。因为是根据两个宗量进行选择，所以Java语言的静态分派属于多分派类型。<br>看看运行阶段虚拟机的选择，也就是动态分派的过程。在执行<code>son.hardChoice(new QQ())</code>这句代码时，更准确地说，是在执行这句代码所对应的 <code>invokevirtual</code> 指令时，由于编译期已经决定目标方法的签名必须为<code>hardChoice(QQ)</code>，虚拟机此时不会关心传递过来的参数<code>QQ</code>到底是“腾讯QQ”还是“奇瑞QQ”，因为这时参数的静态类型、实际类型都对方法的选择不会构成任何影响，唯一可以影响虚拟机选择的因素只有此方法的接受者的实际类型是 <code>Father</code> 还是 <code>Son</code> 。因为只有一个宗量作为选择依据，所以Java语言的动态分派属于单分派类型。</p><p><br></p><h3 id="虚方法表"><a href="#虚方法表" class="headerlink" title="虚方法表"></a>虚方法表</h3><p>由于动态分派是非常频繁的动作，而且动态分派的方法版本选择过程需要运行时在类的方法元数据中搜索合适的目标方法，因此在虚拟机的实际实现中基于性能的考虑，大部分实现都不会真正地进行如此频繁的搜索面对这种情况，最常用的“稳定优化”手段就是为类在方法区中建立一个虚方法表（Virtual Methed Table，也称为 vtable，与此对应的，在 invokeinterface 执行时也会用到接方法表 Inteface Method Table，称 itable），使用虚方法表索引来代替元数据查找以提高性能。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/456cc571-b4e5-4d9b-8b48-92e7392beb85"></div><p>虚方法表中存放着各个方法的实际入口地址，如果某个方法在类中没有被重写，那子类的虚方法表里面的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址。</p><p><br></p><h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><p>Java编译器输出的指令流，基本上是一种基于栈的指令集架构（Instruction Set Architecture，ISA），指令流中的指令大部分都是零地址指令，它们依赖操作数栈进行工作。与之相对的另外一套常用的指令集架构是基于寄存器的指令集。最典型的就是x86的二地址指令集，说得通俗一些，就是现在我们主流PC机中直接支持的指令集架构，这些指令依赖寄存器进行工作。前者的可移植性好，后者的性能高。</p><p><br></p><h3 id="一个例子"><a href="#一个例子" class="headerlink" title="一个例子"></a>一个例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">calc</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line"><span class="keyword">return</span> (a + b) * c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/715bfa04-6d93-482f-b1ba-4ba52f24cee3"></div><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/125fe7e2-85c2-48be-bfa2-da481d506512"></div><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/f1153e3c-5572-4639-ae51-cee3f9587920"></div><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/7903e7af-723c-43c0-94e1-ac5b06110546"></div><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/6a114b15-b47e-45fc-b99d-b08790d8c5cb"></div><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/beef1f48-f201-4a97-a146-dbcdfcb8dbad"></div><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/764d9e06-89cc-4187-a335-7c0afd91464c"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;运行时的栈帧结构&quot;&gt;&lt;a href=&quot;#运行时的栈帧结构&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="JVM" scheme="https://isjinhao.github.io/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>03.04-JVM-运行时数据区域&amp;JDK监控工具</title>
    <link href="https://isjinhao.github.io/posts/7589.html/"/>
    <id>https://isjinhao.github.io/posts/7589.html/</id>
    <published>2019-12-30T13:20:19.000Z</published>
    <updated>2019-12-30T13:20:35.731Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>JVM则是JRE中的核心组成部分，承担分析和执行Java字节码的工作。在Java历史上有很多发行的Java虚拟机，但目前一般学习使用的都是<code>HotSpot</code>。查看本机JVM：<code>java -version</code></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/f4ef67b6-c40f-4f57-a5e0-6108da3a9c85" style="width:80%"></div><p><strong>运行时数据区</strong></p><p>Java虚拟机在执行Java程序的时候会把它所管理的内存区域划分为若干个不同的数据区域。根据JVM规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。</p><p><strong>HotSpot 虚拟机</strong></p><p>HotSpot虚拟机把本地方法栈和虚拟机栈合并在了一起。所以只有虚拟机栈、堆、方法区、程序计数器四个部分。</p><p><br></p><h2 id="运行时数据区划分"><a href="#运行时数据区划分" class="headerlink" title="运行时数据区划分"></a>运行时数据区划分</h2><div align="center"><img src="http://blogfileqiniu.isjinhao.site/ac670268-0509-4a50-ae34-06706b6bf87c" style="width:50%"></div><p><br></p><h3 id="线程私有"><a href="#线程私有" class="headerlink" title="线程私有"></a>线程私有</h3><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。<br>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，所以其是线程私有的。</strong><br>从上面的介绍中我们知道程序计数器主要有两个作用：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><p><strong>注意</strong>：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</p><h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。<br>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。（实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息）<br>局部变量表主要存放了编译器可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（在古老的虚拟机中用于异常处理）。<br>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</p><ul><li><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li><li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。<br>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</li></ul><p><strong>扩展：那么方法/函数如何调用？</strong></p><p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。<br>Java方法有两种返回方式：</p><ul><li>return 语句。</li><li>抛出异常。<br>不管哪种返回方式都会导致栈帧被弹出。</li></ul><p><br></p><h3 id="线程共享"><a href="#线程共享" class="headerlink" title="线程共享"></a>线程共享</h3><h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。<br>HotSpot 虚拟机中方法区在JDK8之前被称为 <strong>“永久代”</strong>，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。<br>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。因为虽然JVM规范中表示不强制在此区域进行垃圾回收，但是目前主流的商业虚拟机，如HotSpot都实现了方法区的垃圾回收。<br>JDK8 的时候，方法区被移动到了元空间，元空间使用的是直接内存。<br>我们可以使用参数： <code>-XX:MetaspaceSize</code> 来指定元数据区的大小。与永久区很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p><ul><li>字面量就是指这个量本身，比如字面量3。也就是指3。再比如 string类型的字面量”ABC”， 这个”ABC” 通过字来描述。 可以理解成一眼就能知道的量。</li><li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。例如，在Class文件中它以CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info等类型的常量出现。<br>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。<br>JDK8及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</li></ul><p><br></p><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><div align="center"><img src="http://blogfileqiniu.isjinhao.site/b3252c77-0466-41a1-8ab7-b98cf1f4a92d" style="width:80%"></div><p><strong>类加载检查</strong></p><p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p><strong>分配内存</strong></p><p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p><strong>初始化零值</strong></p><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><p><strong>设置对象头</strong></p><p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><p><strong>执行 init 方法</strong></p><p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><p><br></p><h3 id="内存分配的两种方式"><a href="#内存分配的两种方式" class="headerlink" title="内存分配的两种方式"></a><strong>内存分配的两种方式</strong></h3><p><strong>指针碰撞</strong></p><p>假设Java堆中的内存时绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式成为“指针碰撞”。</p><p><strong>空闲链表</strong></p><p>如果JAVA堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式成为“空闲列表”。</p><p><br></p><h3 id="内存分配并发问题"><a href="#内存分配并发问题" class="headerlink" title="内存分配并发问题"></a>内存分配并发问题</h3><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，否则比如当虚拟机正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存就会引发严重的问题。通常来讲，虚拟机采用两种方式来保证线程安全：</p><p><strong>CAS+失败重试</strong></p><p>CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</p><p><strong>TLAB</strong></p><p>为每一个线程预先在Eden区分配一块儿内存，称为本地线程分配缓存（Thread Local Allocation Buffer，TLAB），JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配。</p><p><br></p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>使用句柄</strong>和<strong>直接指针</strong>两种（HotSpot虚拟机使用直接指针方式）：</p><ul><li><strong>句柄：</strong> 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/76b1fdaa-1749-4064-85da-d7eff45862d2" style="width:80%"></div><ul><li><strong>直接指针</strong>：如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e8566da3-5d49-48a2-8d34-747d1677b7be" style="width:80%"></div><p>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><p><br></p><h2 id="错误演示"><a href="#错误演示" class="headerlink" title="错误演示"></a>错误演示</h2><h3 id="OutOfMemoryError"><a href="#OutOfMemoryError" class="headerlink" title="OutOfMemoryError"></a>OutOfMemoryError</h3><blockquote><p>Thrown when the Java Virtual Machine cannot allocate an object because it is out of memory, and no more memory could be made available by the garbage collector. OutOfMemoryError objects may be constructed by the virtual machine as if suppression were disabled and/or the stack trace was not writable.<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// VMOptions: -Xms5m -Xmx5m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment">// 设置最小堆空间、设置最大堆空间、发生OutOfMemoryError时Dump堆</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;MyTest1&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        list.add(<span class="keyword">new</span> MyTest1());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">Dumping heap to java_pid21184.hprof ...</span></span><br><span class="line"><span class="comment">Heap dump file created [9351863 bytes in 0.098 secs]</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.OutOfMemoryError: Java heap space</span></span><br><span class="line"><span class="comment">at java.util.Arrays.copyOf(Arrays.java:3210)</span></span><br><span class="line"><span class="comment">at java.util.Arrays.copyOf(Arrays.java:3181)</span></span><br><span class="line"><span class="comment">at java.util.ArrayList.grow(ArrayList.java:265)</span></span><br><span class="line"><span class="comment">at java.util.ArrayList.ensureExplicitCapacity(ArrayList.java:239)</span></span><br><span class="line"><span class="comment">at java.util.ArrayList.ensureCapacityInternal(ArrayList.java:231)</span></span><br><span class="line"><span class="comment">at java.util.ArrayList.add(ArrayList.java:462)</span></span><br><span class="line"><span class="comment">at two.jvm.runtimememory.MyTest1.main(MyTest1.java:11)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p></blockquote><p><br></p><h3 id="线程栈溢出"><a href="#线程栈溢出" class="headerlink" title="线程栈溢出"></a>线程栈溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置线程栈的大小：-Xss160k</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            test();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        length++;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(length);</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/3563316d-3f94-4c1e-9fe2-9f3a4dabf5dd"></div><p><br></p><h3 id="元空间溢出"><a href="#元空间溢出" class="headerlink" title="元空间溢出"></a>元空间溢出</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CGLIB测试</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123;</span><br><span class="line">    <span class="comment">// -XX:MaxMetaspaceSize=10m</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(MyTest3.class);</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback((MethodInterceptor) (obj, method, args1, proxy) -&gt; proxy.invoke(obj, args1));</span><br><span class="line">            System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/fba7083a-058c-4ef6-abb1-e968512a542c"></div><p><br></p><h2 id="JDK监控工具"><a href="#JDK监控工具" class="headerlink" title="JDK监控工具"></a>JDK监控工具</h2><h3 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h3><h4 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jps [options] [hostid]</span><br></pre></td></tr></table></figure><p>如果不指定hostid就默认为当前主机或服务器。命令行参数选项说明如下：</p><ul><li><code>-q</code>：不输出类名、Jar名和传入main方法的参数</li><li><code>-l</code>：·输出main类或Jar的全限名</li><li><code>-m</code>：输出传入main方法的参数</li><li><code>-v</code>：输出传入JVM的参数</li></ul><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/4de6d879-2198-486d-8782-bf1f339600a4"></div><h4 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br></pre></td></tr></table></figure><p>选项option可以由以下值构成：</p><ul><li>class：显示 ClassLoader的相关信息。</li><li>compiler：显示JT编译的相关信息。</li><li>gc：显示与GC相关的堆信息。</li><li>gccapacity：显示各个代的容量及使用情况。</li><li>gccause：显示垃圾收集相关信息（同gcutil），同时显示最后一次或当前正在发生的垃圾收集的诱发原因。</li><li>gcnew：显示新生代信息。</li><li>gcnewcapacity：显示新生代大小与使用情况。</li><li>gcold：显示老年代和永久代的信息。</li><li>gcoldcapacity：显示老年代的大小。</li><li>gcmetacapacity：显示元空间的大小。</li><li>gcutil：显示垃圾收集信息。</li><li>printcompilation：输出JIT编译的方法信息。<br><code>-t</code>参数可以在输出信息前加上一个 Timestamp列，显示程序的运行时间。<br><code>-h</code>参数可以在周期性数据输出时，输出多少行数据后，跟着输出一个表头信息。<br><code>interval</code>参数用于指定输出统计数据的周期，单位为毫秒。<br><code>count</code>用于指定一共输出多少次数据</li></ul><p><strong>class</strong></p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/81fea933-ede0-4782-9218-52dd5a5d86e6"></div><p>在class的输出中，Loaded表示载入了类的数量，Bytes表示载入类的合计大小，Unloaded表示卸载类的数量，第2个Bytes表示卸载类的大小，Time表示在加载和卸载类上所花的时间。</p><p><strong>compiler</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/31b011c9-8c29-4239-80c2-4590914d7337"></div><p>Compiled表示编译任务执行的次数，Failed表示编译失败的次数，Invalid表示编译不可用的次数，Time表示编译的总耗时，FailedType表示最后一次编译失败的类型，FailedMethod表示最后一次编译失败的类名和方法名。</p><p><strong>gcnewcapacity</strong></p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/da450e02-ff07-4fab-8405-52105ee4417c"></div><ul><li>NGCMN：新生代最小值</li><li>NGCMX：新生代最大值</li><li>NGC：新生代当前大小</li><li>S0MAX：S0区最大容量</li><li>S0C：S0区当前容量</li><li>S1CMX：S1区最大容量</li><li>S1C：S1区当前容量</li><li>ECMX：Eden区最大值</li><li>EC：Eden区当前容量</li><li>YGC：新生代GC的次数</li><li>FGC：Full GC次数</li></ul><p><strong>gcoldcapacity</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/da263c7b-5303-4169-b397-7e408e4fe1da"></div><ul><li>OGCMN：老年代最小容量</li><li>OGCMX：老年代最大容量</li><li>OGC：老年代当前容量</li><li>OC：老年代当前容量</li><li>FGCT：Full GC总耗时</li><li>GCT：GC总耗时</li></ul><p><strong>gcmetacapcaity</strong></p><div align="center"><img width="90%" src="http://blogfileqiniu.isjinhao.site/cfd51f1c-83b1-4b30-9147-b413e348567c"></div><ul><li>MCMN：最小元数据容量</li><li>MCMX：最大元数据容量</li><li>MC：当前元数据空间大小</li><li>CCSMN：最小压缩类空间大小</li><li>CCSMX：最大压缩类空间大小</li><li>CCSC：当前压缩类空间大小</li></ul><p><strong>gcutil</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/2a556c4c-5998-4998-b6cb-d6cc875ed815"></div><ul><li>S0：S0已使用的占当前容量百分比</li><li>S1：S1已使用的占当前容量百分比</li><li>E：Eden区已使用的占当前容量百分比</li><li>O：老年代已使用的占当前容量百分比</li><li>M：元空间已使用的占当前容量百分比</li><li>CCS：压缩类使用的空间<br>更详细参考：<a href="https://www.jianshu.com/p/213710fb9e40">https://www.jianshu.com/p/213710fb9e40</a></li></ul><h4 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo &lt;option&gt; &lt;pid&gt;</span><br></pre></td></tr></table></figure><p>选项option可以由以下值构成：</p><ul><li><code>-flag&lt;name&gt;</code>：打印指定的参数值</li><li><code>-flag [+|-]&lt;name&gt;</code>：设置布尔类型的参数值</li><li><code>-flag &lt;name&gt;=&lt;value&gt;</code>：设置虚拟机参数值<br>修改只对少数虚拟机参数有效。</li></ul><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/cdb6d8dd-b4de-43c4-9769-7df97f7039bc"></div><h4 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h4><p>jmap命令用于生产堆转存快照。打印出某个java进程（使用pid）内存内的，所有对象的情况（如：产生那些对象，及其数量）。<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jmap [option] pid</span><br><span class="line">jmap [option] executable core</span><br><span class="line">jmap [option] [server-id@]remote-hostname-or-IP</span><br></pre></td></tr></table></figure><p></p><p>选项option可以由以下值构成：</p><ul><li><code>-dump:[live,]format=b,file=&lt;filename&gt;</code>：使用hprof二进制形式，输出jvm的heap内容到文件。live子选项是可选的，假如指定live选项，那么只输出活的对象到文件。</li><li><code>-histo[:live]</code>：打印每个Class的实例数目，内存占用，类全名信息。如果live子参数加上后，只统计活的对象数量。</li><li><code>-clstats</code> ：打印类加载器的统计信息</li></ul><p><strong>dump</strong></p><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/eb4df7a5-ccaf-47ba-a0fe-fad038a62bb5"></div><p><strong>histo</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/0afb2fbb-e583-49af-be87-43fc4777c383"></div><p><strong>clstats</strong></p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/aa2e9d60-318e-4c2a-9316-e09b8d73308a"></div><h4 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jstack [option] pid</span><br><span class="line">jstack [option] executable core</span><br><span class="line">jstack [option] [server-id@]remote-hostname-or-IP</span><br></pre></td></tr></table></figure><ul><li><code>-l</code>：长列表。打印关于锁的附加信息。</li><li><code>-F</code>：当<code>jstack [-l] pid</code>没有相应的时候强制打印栈信息。</li><li><code>-m</code>：打印java和native c/c++框架的所有栈信息。</li></ul><p><br></p><h3 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h3><p><strong>jvisualvm</strong></p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/f783a362-39df-47d4-b4a6-5c41dc3b969e"></div><p><strong>jconsole</strong></p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/0b9a9d73-eee4-4aca-bdc8-1e1e8d2cbe17"></div><p>更详细：<a href="https://juejin.im/post/59e6c1f26fb9a0451c397a8c#heading-9">https://juejin.im/post/59e6c1f26fb9a0451c397a8c#heading-9</a></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;J
      
    
    </summary>
    
      <category term="JVM" scheme="https://isjinhao.github.io/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>03.05-JVM-垃圾回收1</title>
    <link href="https://isjinhao.github.io/posts/55250.html/"/>
    <id>https://isjinhao.github.io/posts/55250.html/</id>
    <published>2019-12-30T13:20:19.000Z</published>
    <updated>2019-12-30T13:20:35.738Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><div align="center"><img width="80%" src="https://user-gold-cdn.xitu.io/2016/11/29/c56dd0d8df13a23ce4a698e244f2a7fb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"></div><p><strong>强引用</strong></p><p>Java中默认声明的就是强引用，比如：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object(); <span class="comment">// 只要obj还指向Object对象，Object对象就不会被回收</span></span><br><span class="line">obj = <span class="keyword">null</span>;  <span class="comment">// 手动置null</span></span><br></pre></td></tr></table></figure><p></p><p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，也不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了。</p><p><strong>软引用</strong></p><p>软引用是用来描述一些非必需但仍有用的对象。<strong>在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常</strong>。表示软引用的类是java.lang.ref.SoftReference。下面以一个例子来进一步说明强引用和软引用的区别：<br>首先先来测试一下强引用，在限制了 JVM 内存的前提下，下面的代码运行正常：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  -Xms2M -Xmx3M，将 JVM 的初始内存设为2M，最大可用内存为 3M。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOOM</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         testStrongReference();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStrongReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当 new byte为 1M 时，程序运行正常</span></span><br><span class="line">        <span class="comment">// 当 new byte为 1M 时，程序报异常 OutOfMemoryError</span></span><br><span class="line">        <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">3</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>接着来看一下软引用会有什么不一样，在下面的示例中连续创建了 10 个大小为 1M 的字节数组，并赋值给了软引用，然后循环遍历将这些对象打印出来。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testSoftReference();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSoftReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            SoftReference&lt;<span class="keyword">byte</span>[]&gt; sr = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line">            list.add(sr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            Object obj = ((SoftReference) list.get(i)).get();</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    [B@12a3a380</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>我们发现无论循环创建多少个软引用对象，打印结果总是只有最后一个对象被保留，其他的obj全都被置空回收了。这里就说明了在内存不足的情况下，软引用将会被自动回收。</p><p><strong>弱引用</strong></p><p>弱引用的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeakReference</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        WeakReference&lt;<span class="keyword">byte</span>[]&gt; sr = <span class="keyword">new</span> WeakReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>]);</span><br><span class="line">        list.add(sr);</span><br><span class="line">    &#125;</span><br><span class="line">    System.gc(); <span class="comment">//主动通知垃圾回收</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">        Object obj = ((WeakReference) list.get(i)).get();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">    null</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>可以发现所有被弱引用关联的对象都被垃圾回收了。</p><p><strong>虚引用</strong></p><p>虚引用并不会影响对象的生命周期。虚引用的作用为：跟踪垃圾回收器收集对象这一活动的情况。当GC一旦发现了虚引用对象，则会将PhantomReference对象插入ReferenceQueue队列，而此时PhantomReference对象并没有被垃圾回收器回收，而是要等到ReferenceQueue被你真正的处理后才会被回收。<br>注意：PhantomReference必须要和ReferenceQueue联合使用，SoftReference和WeakReference可以选择和ReferenceQueue联合使用也可以不选择。</p><p><br></p><h3 id="ReferenceQueue"><a href="#ReferenceQueue" class="headerlink" title="ReferenceQueue"></a>ReferenceQueue</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; rq = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Object value = <span class="keyword">new</span> Object();</span><br><span class="line">        Map&lt;Object, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">                PhantomReference&lt;<span class="keyword">byte</span>[]&gt; k;</span><br><span class="line">                <span class="comment">// Removes the next reference object in this queue</span></span><br><span class="line">                <span class="comment">// blocking until one becomes available.</span></span><br><span class="line">                <span class="keyword">while</span> ((k = (PhantomReference&lt;<span class="keyword">byte</span>[]&gt;) rq.remove()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    System.out.println((cnt++) + <span class="string">"回收了: "</span> + k);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//结束循环</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.setDaemon(<span class="keyword">true</span>);</span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[_1M];</span><br><span class="line">            PhantomReference&lt;<span class="keyword">byte</span>[]&gt; weakReference = <span class="keyword">new</span> PhantomReference&lt;&gt;(bytes, rq);</span><br><span class="line">            map.put(weakReference, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"gc........"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先输出6次表示在加入第6个加入后触发了GC操作，然后在停住的5秒里没有任何操作表示没有触发GC，所以不会加入到队列中，然后我们手动触发一次GC，对象都被加入到队列中了。</p><p><br></p><h3 id="System-gc"><a href="#System-gc" class="headerlink" title="System.gc()"></a>System.gc()</h3><blockquote><p>Runs the garbage collector. Calling this method suggests that the Java virtual machine expend effort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse. When control returns from the method call, the virtual machine has made its best effort to recycle all discarded objects.<br>The name gc stands for “garbage collector”. The virtual machine performs this recycling process automatically as needed, in a separate thread, even if the gc method is not invoked explicitly.<br>The method System.gc() is the conventional and convenient means of invoking this method.</p></blockquote><p><br></p><h2 id="对象已死吗"><a href="#对象已死吗" class="headerlink" title="对象已死吗"></a>对象已死吗</h2><h3 id="对象判死算法"><a href="#对象判死算法" class="headerlink" title="对象判死算法"></a>对象判死算法</h3><p><strong>引用计数器</strong></p><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。但这种计数法无法解决循环引用的问题，即若A对象中有属性B，B对象中有属性A，则A、B永远都有计数。</p><p><strong>可达性分析算法</strong></p><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/beb26a0b-591a-4948-a999-ba5f3fac2abe" style="width:80%"></div><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul><p><br></p><h3 id="生存还是死亡"><a href="#生存还是死亡" class="headerlink" title="生存还是死亡"></a>生存还是死亡</h3><p>即使是不可达对象，也并非是非死不可的，这时候它们暂时处于”缓刑“阶段，真正宣告一个对象死亡，至少要经过<strong>两次标记过程</strong>：<br>如果对象在进行根搜索后发现跟root不同根，就被标记一次，同时进行筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法，”没有必要执行”的原因如下：当对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>已经被JVM调用过（说明一个对象的<code>finalize()</code>方法只能执行一次）。如果这个对象有必要执行<code>finalize()</code>方法，JVM就会把它放在<code>F-Queue</code>中，稍后<code>JVM</code>会触发一个低优先级的线程去执行。但是去执行并不承诺会等待它运行结束，因为如果一个对象在finalize()方法中执行缓慢，甚至发生了死循环，就会导致F-Queue其他对象永久处于等待状态，更严重的话可能会拖垮整个内存回收系统。<code>finalize()</code>是对象逃脱死亡命运的最后一次机会，稍后<code>GC</code>将会对<code>F-Queue</code>进行第二次小规模的标记，如果在<code>finalize()</code>中将自己和root挂在一个根上（比如把自己赋值给某个类变量或者对象的成员变量），那么在这第二次标记将会被移除出“即将回收的集合”：如果对象还没有逃脱，那么就基本上真的被回收了。<br>不过非常不推荐使用finalize()方法自救对象，因为这是Java刚诞生为了使C/C++程序员更容易接受它作的一个妥协。它的运行带价高昂，不确定性大，无法保证各个对象的调用顺序。有些教材中提到它使用“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方法都可以做的更好、更及时，Java程序员完全可以忘掉Java有finalize()。<br><code>finalize()</code>测试：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"haha, i'm still alive!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line">        <span class="comment">//对象第一次拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"5555, i'm dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对象第二次拯救自己，但是却跪了。因为finalize只能执行一次呀，亲！！</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"5555, i'm dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*output:</span></span><br><span class="line"><span class="comment">    finalize method executed!</span></span><br><span class="line"><span class="comment">    haha, i'm still alive!</span></span><br><span class="line"><span class="comment">    5555, i'm dead!</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>永久代的垃圾收集主要回收两部分内容：</p><ul><li>废弃常量：以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</li><li>无用的类：判断一个类是无用的类的条件比废弃变量要苛刻的多，要同时满足3个条件才能算是“无用的类”：<ol><li>该类所有的实例都已经被回收，意思是堆上没有该对象的实例了</li><li>加载该类的ClassLoader已经被回收。</li><li>该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法（因为通过反射，就一定要加载该类）<br>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</li></ol></li></ul><p><br></p><h2 id="基本垃圾收集算法"><a href="#基本垃圾收集算法" class="headerlink" title="基本垃圾收集算法"></a>基本垃圾收集算法</h2><p><strong>标记-清除算法</strong></p><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。有两个问题：一是效率不高，因为当对象数量比较多的时候一一进行标记和清除较复杂；二是会产生内存碎片，当需要大的连续内存空间时，即使碎片内存总和远大于需求，也会触发垃圾回收操作。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/afb85c53-8df7-4dc6-b0bf-fd1f5c49390e" style="width:60%"></div><p><strong>复制算法</strong></p><p>将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。实现简单，运行高效，但是空间缩小为原来的一半了。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/ca3dd6f1-6e7b-4109-80d6-bf5532ddaaaa"></div><p><strong>标记整理算法</strong></p><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/44deb98c-fc46-4385-b972-2a65b5212def"></div><p><strong>分代收集算法</strong></p><p>当前商业虚拟机的垃圾回收都采用分代收集算法，这种算法没有啥特别的，就是根据对象的存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，这样就可以根据每个代不同的特点采用最适当的回收算法。<br>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记一清理”或者“标记一整理”算法来进行回收。<br>同时IBM经过调研发现，新生代的对象98%都是朝生夕死的，所有并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。当回收时，将Eden和Survivor还存活着的对象一次性拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。<strong>HotSpot虚拟机默认Eden和Survivor的大小比例是8：1</strong>，也就是每次新生代中可用内存空间为整个内存空间的9/10，只有10%的内存是用来浪费的。当然了，我们无法保证每次回收只有少于10%的对象存活，当存活对象大于10%，就会借用老年代进行分配担保。</p><p><br></p><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><p><strong>Minor GC 和 Full GC</strong></p><ul><li>Minor GC：发生在新生代的GC。触发条件：当Eden区满时。</li><li>Full GC（也叫Major GC）：发生在老年代的GC，通常会触发Minor GC。Major GC的速度一般会比Minor GC慢10倍以上。触发条件：<ul><li>调用System.gc()时，系统建议执行Full GC，但是不必然执行</li><li>老年代空间不足</li><li>方法区空间不足</li><li>通过Minor GC后进入老年代的平均大小大于老年代的可用内存</li><li>由Eden区、From Survivor区向To Survivor区复制时，对象大小大于To Survivor可用内存，则把该对象转存到老年代，且老年代的可用内存小于该对象大小</li></ul></li></ul><p><strong>对象优先在Eden分配</strong></p><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><p><strong>大对象直接进入老年代</strong></p><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。<br>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制。注意PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效。</p><p><strong>长期存活的对象将进入老年代</strong></p><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。</p><p><strong>动态对象年龄判定</strong></p><p>虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p><p><strong>空间分配担保</strong></p><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于就尝试进程一次Minor GC（尽管此次GC是有风险的），如果小于或者不允许冒险，需要进行一次Full GC。<br>在JDK 6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p><p><br></p><h2 id="可达性算法的实现"><a href="#可达性算法的实现" class="headerlink" title="可达性算法的实现"></a>可达性算法的实现</h2><p><strong>枚举根节点</strong></p><p><br></p><h3 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h3><p>在 GC Roots节点找引用链这个操作的过程中，可作为 GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。<br>另外，可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行。这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，否则分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因，即使是在号称（几乎）不会发生停顿的CMS收集器中。枚举根节点时也是必须要停顿的。</p><p><strong>OopMap</strong></p><p>垃圾收集时，收集线程会对栈上的内存进行扫描，看看哪些位置存储了 Reference 类型。如果发现某个位置确实存的是 Reference 类型，就意味着它所引用的对象这一次不能被回收。但问题是，栈上的本地变量表里面只有一部分数据是 Reference 类型的（它们是我们所需要的），那些非 Reference 类型的数据对我们而言毫无用处，但我们还是不得不对整个栈全部扫描一遍，这是对时间和资源的一种浪费。<br>一个很自然的想法是，能不能用空间换时间，在某个时候把栈上代表引用的位置全部记录下来，这样到真正 GC 的时候就可以直接读取，而不用再一点一点的扫描了。事实上，大部分主流的虚拟机也正是这么做的，比如 HotSpot ，它使用一种叫做 OopMap 的数据结构来记录这类信息。</p><p><strong>安全点</strong></p><p>我们知道，一个线程意味着一个栈，一个栈由多个栈帧组成，一个栈帧对应着一个方法，一个方法里面有多个指令。但是HotSpot没有为每条指令都生成OopMap，那样占用空间太多，而只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint）。引入安全点之后，程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。<br>GC 发生时，程序首先运行到最近的一个安全点停下来，然后更新自己的 OopMap ，记下栈上哪些位置代表着引用。枚举根节点时，递归遍历每个栈帧的 OopMap ，通过栈中记录的被引用对象的内存地址，即可找到这些对象（GC Roots）。<br>另一个问题是如何让所有线程都跑到最近的安全点停顿。这里有两种方案可供选择：<strong>抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）</strong>，其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</p><p><strong>安全区域</strong></p><p>如果线程没有在执行呢，比如线程处于Sleep状态或者Blocked状态，就需要安全区域解决了。安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。<br>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p><p><br></p><h2 id="基本垃圾收集器"><a href="#基本垃圾收集器" class="headerlink" title="基本垃圾收集器"></a>基本垃圾收集器</h2><p>在JDK8中默认的垃圾收集算法仍然是分代的算法。同时上文中的提到的垃圾收集算法会应用在不同的业务场景中。不过在JDK9以至于后续的JDK版本，G1是默认的垃圾收集器，这个会在下一篇文章中单独解释。<br>下图中的CMS垃圾收集器使用的不是简单的使用我们上面介绍的垃圾收集算法。关于它会在本文的后续介绍。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/5ffa2bc8-c126-46b2-a9e3-88e1ffa37a0d" style="width:60%"></div><p><br></p><h3 id="Serial-Serial-Old"><a href="#Serial-Serial-Old" class="headerlink" title="Serial / Serial Old"></a>Serial / Serial Old</h3><p>Serial 收集器是一个使用“复制”算法的新生代单线程收集器。它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。不过在Client端，新生代的内存一般只有几十M或者一两百M的样子，完成一次收集工作完全可以控制在几十毫秒或者一百毫秒左右，不会有很大的停顿感。所以其主要的运行在Client端。<br>Serial Old 收集器是 Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记一整理”算法。这个收集器的主要意义也是在于给 Client 模式下的虚拟机使用。<br>下图是Serial / Serial Old 配合工作时的图。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/29dab41d-2290-41bb-b8c0-3f36f91e3bd1" style="width:80%"></div><p><br></p><h3 id="ParNew"><a href="#ParNew" class="headerlink" title="ParNew"></a>ParNew</h3><p>ParNew 本质上就是Serial收集器的多线程版本，所以单CPU的话一般会考虑用Serial，多CPU的话一般考虑用ParNew，它默认开启的收集器线程数和CPU核数相同，当你想控制的时候，可以使用<code>-XX:ParallelGCThreads</code>参数来限制收集器的线程数。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/05dacdd7-3318-4c92-8f35-9d24b0cbabb9"></div><p><br></p><h3 id="Parallel-Scavenge-Parallel-Old"><a href="#Parallel-Scavenge-Parallel-Old" class="headerlink" title="Parallel Scavenge / Parallel Old"></a>Parallel Scavenge / Parallel Old</h3><p>Parallel Scavenge也是一个新生代收集器，它也是使用复制算法的收集器，同时也是并行的多线程收集器。它的目标是达到可控制的CPU吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间 /（运行用户代码时间+垃圾回收时间）。比如虚拟机运行了100分钟，垃圾回收使用了1分钟，那么吞吐量就是99%。<br>这就说说一下应用场景了。</p><ul><li>停顿时间（垃圾回收时间）： 停顿时间越短越适合于用户交互的程序，良好的响应速度能提升用户体验</li><li>高吞吐量： 可以最高效率的利用CPU时间，尽快的完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务<br>为了这两个目的，Parallel Scavenge收集器提供了2个参数：</li><li><code>-XX:MaxGCPauseMillis</code>：大于0的毫秒数，收集器将尽力保证内存回收时间不超过这个值。不过不要异想天开认为把这个值设的特别小，就能使系统垃圾收集速度更快，GC停顿时间缩短肯定是有代价的，它会牺牲吞吐量和新生代空间来实现。</li><li><code>-XX:GCTimeRatio</code>：大于0小于100的整数。假如设为N，那么垃圾收集时间占总时间的比率就是1/(1+N)，比如设置为19，占比就是1/(1+19)=5%，默认值是99，即1%。</li><li><code>-XX:+UseAdaptiveSizePolicy</code>：这是一个很有用的参数。它是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小（<code>-Xmn</code>）、Eden、Survivor区的比例（<code>-XX:SurvivorRatio</code>）、晋升老年代对象年龄（<code>-XX:PretenureSizeThreshold</code>）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以一同最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（<code>GC Ergonomics</code>）。自适应调节策略也是Parallel Scavenge收集器和ParNew收集器的一个重要区别。<br>Parallel Scavenge 收集器架构中本身有 PS MarkSweep 收集器来进行老年代收集，并非直接使用了Serial Old收集器，但是这个 PS MarkSweep 收集器与 Serial Old 的实现非常接近，所以我们可以认为Parallel Scavenge默认搭配Serial Old运行。<br>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。是在JDK6之后才提供的。由于Parallel Scavenge收集器采用了独立的架构，无法和CMS配合使用。那么，在JDK6以前，Parallel Scavenge只能和Serial Old配合使用。因为Serial Old是单线程的，所以在多CPU情况下无法发挥性能，所以根本实现不了高吞吐量的需求，直到 JDK6 推出了Parallel Old之后，Parallel Scavenge收集器和Parallel Old搭配，才真正实现了对吞吐量优先的控制。所以，<strong>在注重吞吐量及CPU资源敏感的场合，都可以考虑Parallel Scavenge和Parallel Old组合</strong>。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/350ae90f-6b11-4855-af56-8d11ff726239" style="width:80%"></div><p><br></p><h2 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h2><p><strong>查看当前虚拟机信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+PrintCommandLineFlags -version</span><br><span class="line">-XX:InitialHeapSize=116435136 -XX:MaxHeapSize=1862962176 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:-UseLargePagesIndividualAllocation -XX:+UseParallelGC</span><br><span class="line">java version &quot;1.8.0_221&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_221-b11)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.221-b11, mixed mode)</span><br></pre></td></tr></table></figure><ul><li>-XX:InitialHeapSize：初始化的堆大小</li><li>-XX:MaxHeapSize：最大的堆大小</li><li>-XX:+UseParallelGC：使用ParNew和Par</li><li>-XX:+PrintCommandLineFlags：打印虚拟机启动参数</li><li>剩下的三个参数和GC无关。</li></ul><p><strong>Minor GC</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  -verbose:gc 输出冗余的gc信息</span></span><br><span class="line"><span class="comment">  -Xms20M 堆初始化大最小容量</span></span><br><span class="line"><span class="comment">  -Xmx20M 堆初始化最大容量</span></span><br><span class="line"><span class="comment">  -Xmn10M 新生代容量</span></span><br><span class="line"><span class="comment">  -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">  -XX:SurvivorRatio=8 配置新生代和survivor的大小比例为8：1：1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</span><br><span class="line">    <span class="keyword">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</span><br><span class="line">    System.out.println(<span class="string">"============"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span> * _1M];<span class="comment">// 此时发送Minor GC</span></span><br><span class="line">    System.out.println(<span class="string">"============"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1M];</span><br><span class="line">    System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">============</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 5758K-&gt;792K(9216K)] 5758K-&gt;4896K(19456K), 0.0027827 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</span><br><span class="line">============</span><br><span class="line">hello world</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 8283K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 8192K, 91% used [0x00000000ff600000,0x00000000ffd50da8,0x00000000ffe00000)</span><br><span class="line">  from space 1024K, 77% used [0x00000000ffe00000,0x00000000ffec6030,0x00000000fff00000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 10240K, used 4104K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  object space 10240K, 40% used [0x00000000fec00000,0x00000000ff002020,0x00000000ff600000)</span><br><span class="line"> Metaspace       used 3101K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 335K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p><code>GC (Allocation Failure)</code>：本次GC是Minor GC，GC的原因是分配失败。<br><code>[PSYoungGen: 5758K-&gt;792K(9216K)]</code>：新生代使用的是Parallel Scavenge收集器。9216K表示新生代可用空间是9216K，也就是9M，因为新生代的Eden空间是9M，From Survior是1M。To Survior是被浪费的。这部分空间的减少包含晋升到老年代的和真正被清除的。<br><code>5758K-&gt;4896K(19456K)</code>：19456K表示总的可用的空间是19M，还是由于To Survior是被浪费的。这部分空间的减少是真正被清除的垃圾。<br><code>0.0027827 secs</code>：本次GC的时间，单位秒。<br><code>ParOldGen total 10240K, used 4104K</code>：(5758K-792K)-(5758K-4896K)=4014K。老年代使用Serial Old。</p><p><strong>Full GC</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  -verbose:gc 输出冗余的gc信息</span></span><br><span class="line"><span class="comment">  -Xms20M 堆初始化大最小容量</span></span><br><span class="line"><span class="comment">  -Xmx20M 堆初始化最大容量</span></span><br><span class="line"><span class="comment">  -Xmn10M 新生代容量</span></span><br><span class="line"><span class="comment">  -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">  -XX:SurvivorRatio=8 配置新生代和survivor的大小比例为8：1：1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</span><br><span class="line">    <span class="keyword">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span> * _1M];</span><br><span class="line">    System.out.println(<span class="string">"============"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">3</span> * _1M];<span class="comment">// Minor GC 和 Full GC</span></span><br><span class="line">    System.out.println(<span class="string">"============"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1M];</span><br><span class="line">    System.out.println(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">============</span><br><span class="line">[GC (Allocation Failure) [PSYoungGen: 6946K-&gt;792K(9216K)] 6946K-&gt;5920K(19456K), 0.0031393 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Ergonomics) [PSYoungGen: 792K-&gt;0K(9216K)] [ParOldGen: 5128K-&gt;5739K(10240K)] 5920K-&gt;5739K(19456K), [Metaspace: 3117K-&gt;3117K(1056768K)], 0.0064401 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] </span><br><span class="line">============</span><br><span class="line">hello world</span><br><span class="line">Heap</span><br><span class="line"> PSYoungGen      total 9216K, used 7492K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">  eden space 8192K, 91% used [0x00000000ff600000,0x00000000ffd510d8,0x00000000ffe00000)</span><br><span class="line">  from space 1024K, 0% used [0x00000000ffe00000,0x00000000ffe00000,0x00000000fff00000)</span><br><span class="line">  to   space 1024K, 0% used [0x00000000fff00000,0x00000000fff00000,0x0000000100000000)</span><br><span class="line"> ParOldGen       total 10240K, used 5739K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  object space 10240K, 56% used [0x00000000fec00000,0x00000000ff19ae28,0x00000000ff600000)</span><br><span class="line"> Metaspace       used 3133K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 341K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p><code>[ParOldGen: 5128K-&gt;5739K(10240K)]</code>：老年代使用的是Serial Old收集器。</p><p><strong>大对象直接在老年代分配</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> -verbose:gc 输出冗余的gc信息</span></span><br><span class="line"><span class="comment"> -Xms20M 堆初始化大最小容量</span></span><br><span class="line"><span class="comment"> -Xmx20M 堆初始化最大容量</span></span><br><span class="line"><span class="comment"> -Xmn10M 新生代容量</span></span><br><span class="line"><span class="comment"> -XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment"> -XX:SurvivorRatio=8 配置新生代和survivor的大小比例为8：1：1</span></span><br><span class="line"><span class="comment"> -XX:PretenureSizeThreshold=4194304 设置对象超过多大时直接分配到老年代，单位B。</span></span><br><span class="line"><span class="comment"> 需要和UseSerialGC一起使用</span></span><br><span class="line"><span class="comment"> -XX:+UseSerialGC 表示指定垃圾收集器为SerialGC</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">7</span> * _1M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1990K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  24% used [0x00000000fec00000, 0x00000000fedf1b58, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,   0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> tenured generation   total 10240K, used 7168K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line">   the space 10240K,  70% used [0x00000000ff600000, 0x00000000ffd00010, 0x00000000ffd00200, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3164K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 342K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p><code>def new generation</code>：新生代使用的是Serial收集器<br><code>tenured generation</code>：老年代使用的是Serial old收集器<br>没有发生GC，说明大对象直接在老年代分配了</p><p><strong>晋升到老年代的对象年龄管理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-verbose:gc</span></span><br><span class="line"><span class="comment">//-Xmx200M</span></span><br><span class="line"><span class="comment">//-Xms200M</span></span><br><span class="line"><span class="comment">//-Xmn50M</span></span><br><span class="line"><span class="comment">//-XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">//-XX:TargetSurvivorRatio=60</span></span><br><span class="line"><span class="comment">//-XX:+PrintTenuringDistribution</span></span><br><span class="line"><span class="comment">//-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">//-XX:+PrintGCDateStamps</span></span><br><span class="line"><span class="comment">//-XX:+UseConcMarkSweepGC</span></span><br><span class="line"><span class="comment">//-XX:+UseParNewGC      TargetSurvivorRatio参数需要配合ParNew收集器使用</span></span><br><span class="line"><span class="comment">//-XX:MaxTenuringThreshold=3</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">512</span> * <span class="number">1024</span>];</span><br><span class="line">    allocation();</span><br><span class="line">    System.out.println(<span class="string">"11111111"</span>);</span><br><span class="line">    allocation();</span><br><span class="line">    System.out.println(<span class="string">"22222222"</span>);</span><br><span class="line">    allocation();</span><br><span class="line">    System.out.println(<span class="string">"33333333"</span>);</span><br><span class="line">    allocation();</span><br><span class="line">    System.out.println(<span class="string">"44444444"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">byte</span>[] bytes4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">byte</span>[] bytes5 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    allocation();</span><br><span class="line">    System.out.println(<span class="string">"55555555"</span>);</span><br><span class="line">    allocation();</span><br><span class="line">    System.out.println(<span class="string">"66666666"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">allocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">40</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">2019-12-30T11:22:31.926+0800: [GC (Allocation Failure) 2019-12-30T11:22:31.926+0800: [ParNew</span><br><span class="line">Desired survivor size 3145728 bytes, new threshold 3 (max 3)</span><br><span class="line">- age   1:    1716192 bytes,    1716192 total</span><br><span class="line">: 40355K-&gt;1713K(46080K), 0.0011085 secs] 40355K-&gt;1713K(199680K), 0.0011876 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">11111111</span><br><span class="line">2019-12-30T11:22:31.930+0800: [GC (Allocation Failure) 2019-12-30T11:22:31.930+0800: [ParNew</span><br><span class="line">Desired survivor size 3145728 bytes, new threshold 3 (max 3)</span><br><span class="line">- age   1:        232 bytes,        232 total</span><br><span class="line">- age   2:    1701976 bytes,    1702208 total</span><br><span class="line">: 42452K-&gt;1923K(46080K), 0.0010934 secs] 42452K-&gt;1923K(199680K), 0.0011384 secs] [Times: user=0.06 sys=0.03, real=0.00 secs] </span><br><span class="line">22222222</span><br><span class="line">2019-12-30T11:22:31.933+0800: [GC (Allocation Failure) 2019-12-30T11:22:31.934+0800: [ParNew</span><br><span class="line">Desired survivor size 3145728 bytes, new threshold 3 (max 3)</span><br><span class="line">- age   1:         56 bytes,         56 total</span><br><span class="line">- age   2:        232 bytes,        288 total</span><br><span class="line">- age   3:    1701000 bytes,    1701288 total</span><br><span class="line">: 42454K-&gt;1900K(46080K), 0.0006981 secs] 42454K-&gt;1900K(199680K), 0.0007424 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">33333333</span><br><span class="line">2019-12-30T11:22:31.936+0800: [GC (Allocation Failure) 2019-12-30T11:22:31.936+0800: [ParNew</span><br><span class="line">Desired survivor size 3145728 bytes, new threshold 3 (max 3)</span><br><span class="line">- age   1:         56 bytes,         56 total</span><br><span class="line">- age   2:         56 bytes,        112 total</span><br><span class="line">- age   3:        232 bytes,        344 total</span><br><span class="line">: 42632K-&gt;279K(46080K), 0.0023449 secs] 42632K-&gt;1960K(199680K), 0.0023807 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">44444444</span><br><span class="line">2019-12-30T11:22:31.942+0800: [GC (Allocation Failure) 2019-12-30T11:22:31.942+0800: [ParNew</span><br><span class="line">Desired survivor size 3145728 bytes, new threshold 1 (max 3)</span><br><span class="line">- age   1:    3145832 bytes,    3145832 total</span><br><span class="line">- age   2:         56 bytes,    3145888 total</span><br><span class="line">- age   3:         56 bytes,    3145944 total</span><br><span class="line">: 41013K-&gt;3124K(46080K), 0.0014786 secs] 42695K-&gt;4806K(199680K), 0.0015408 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">55555555</span><br><span class="line">2019-12-30T11:22:31.946+0800: [GC (Allocation Failure) 2019-12-30T11:22:31.946+0800: [ParNew</span><br><span class="line">Desired survivor size 3145728 bytes, new threshold 3 (max 3)</span><br><span class="line">- age   1:         56 bytes,         56 total</span><br><span class="line">: 43860K-&gt;8K(46080K), 0.0021793 secs] 45542K-&gt;4762K(199680K), 0.0022246 secs] [Times: user=0.05 sys=0.01, real=0.00 secs] </span><br><span class="line">66666666</span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 46080K, used 14941K [0x00000000f3800000, 0x00000000f6a00000, 0x00000000f6a00000)</span><br><span class="line">  eden space 40960K,  36% used [0x00000000f3800000, 0x00000000f46952a8, 0x00000000f6000000)</span><br><span class="line">  from space 5120K,   0% used [0x00000000f6000000, 0x00000000f60022e0, 0x00000000f6500000)</span><br><span class="line">  to   space 5120K,   0% used [0x00000000f6500000, 0x00000000f6500000, 0x00000000f6a00000)</span><br><span class="line"> concurrent mark-sweep generation total 153600K, used 4754K [0x00000000f6a00000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3219K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 348K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p><code>Desired survivor size 3145728 bytes</code>：当Survivor的已空间小于大于时，重新计算<code>MaxTenuringThreshold</code>。<br><code>33333333</code>：这行输出之前，我们可以看见Survivor空间里面有对象年龄在增长。<br><code>44444444</code>：这行输出之前的GC，将部分的Survior里的对象晋升到老年代了<br><code>55555555</code>：这行输出之前的GC，三个年龄的对象大小加一起已经超过3145728了，所以，此时重新计算<code>MaxTenuringThreshold</code>。由于计算得到的是1，所以全部的Survivor里的对象都会晋升到老年代。<br><code>66666666</code>：可以发现现在的Survivor里只有1岁的对象了。</p><p><br></p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><p>Comcurrent Mark Sweep。CMS收集器是以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用都集中在互联网站或者B/S系统上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，给用户最佳的用户体验。而CMS收集器就非常符合这类应用的需求。<br>从名字上可以看出，”Mark Sweep“是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤：</p><ol><li>初始标记：初始标记仅仅只是标记一下 GC roots 能直接关联到的对象，速度很快，需要stop the world。</li><li>并发标记：并发标记就是进行GC Roots Tracing（可达性算法）的过程。</li><li>重新标记：重新标记则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变化的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍微长一些，但远比并发标记的时间短，需要stop the world。</li><li>并发清除：垃圾清除。</li></ol><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a504f382-d97e-496b-aeae-247c962d2081" style="width:80%"></div><p>由于整个过程中，并发标记和并发清除时间最长，收集器线程可以和用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。<br>从CMS收集器执行的过程来看。初始标记只标记能被直接关联到的对象，在并发标记的时候才使用可达性算法去寻找全部的存活的对象。而后在重新标记阶段去修改将并发过程中新出现的引用或者失效的引用。如果在并发标记过程中，有大量的引用状态发生改变，重新标记阶段就会导致长时间的STW。所以CMS用于老年代。<br>CMS收集器的优点在于并发收集、低停顿，但是也不是完美的，主要有3个显著的缺点：</p><ol><li>CMS收集器对CPU资源非常敏感。默认情况下，CMS的收集线程数=(CPU数目+3)/4，当CPU个数大于4的时候，CMS的收集线程不会超过整个CPU占用率的25%。但是在CPU个数比较小的情况下，CPU占用就会突然增大，这样对于初始标记和并发标记这样”Stop The World”的过程来说，用户就会明显感觉到停顿。</li><li>CMS收集器无法处理浮动垃圾（Float Garbage），可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。也是由于在垃圾收集阶段用户线程还需要运行，那也就还需要预留有足够的内存空间给用户线程使用，因此CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，需要预留一部分空间提供并发收集时的程序运作使用。参数-XX:CMSInitiatingOccupancyFraction的值可以控制这个空间的大小。值越大，内存回收次数越少，从而性能更高。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old<br>收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。所以说此参数若设置得太高很容易导致大量“Concurrent Mode Failure“，性能反而降低。</li><li>CMS是基于标记-清除算法实现的收集器，所以会产生内存碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦：老年代还有空间但是没有连续的足够大的空间，于是不得不触发一次Full GC。为了解决这个问题，有一个开关叫做-XX:+UseCMSCompactAtFullCollection，用于在Full GC时开启内存碎片的合并整理过程。当然，这个内存整理没法并发，只有STW了。同时虚拟机还有参数-XX:CMSFullGCsBeforeCompaction，用于指定在多少次不压缩的Full GC后，跟着来一次带压缩的。</li></ol><p><br></p><h3 id="CMS运行过程详细划分"><a href="#CMS运行过程详细划分" class="headerlink" title="CMS运行过程详细划分"></a>CMS运行过程详细划分</h3><h4 id="标记过程"><a href="#标记过程" class="headerlink" title="标记过程"></a>标记过程</h4><p><strong>Initial Mark</strong></p><p>标记那些直接被GC roots引用或者被年轻代存活对象所引用的所有对象。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/ecc16ffc-a82d-4f44-a417-3bfc97d5fece"></div><p><strong>Concurrent Mark</strong></p><p>在这个阶段 Garbage Collector 会遍历老年代，然后标记所有存活的对象，它会根据上个阶段找到的 GC Roots 遍历查找。并发标记阶段，它会与用户的应用程序并发运行。并不是Initial Mark阶段的老年代的所有存活对象都会被标记，因为在标记期间用户的程序可能会改变一些引用。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/8c714b9a-7e02-42b0-9492-5beb30160ef0"></div><p><strong>Concurrent Preclean</strong></p><p>这也是一个并发阶段，与应用的线程并发运行，并不会stop应用的线程。在并发运行的过程中，一些对象的引用可能会发生变化，但是这种情况发生时，JVM会将包含这个对象的区域（Card）标记为 Dirty ，被称为 Card Marking。<br>在pre -clean-阶段，那些能够从 Dirty 对象到达的对象也会被标记，这个标记做完之后，Dirty Card标记就会被清除了。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/dd07b39c-81d8-4a62-b078-58f6be5ae04c"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/0931dd94-52d7-4c2b-ac07-0e0120d7a143"></div><p><strong>Concurrent Abortable Preclean</strong></p><p>又一个并发阶段不会停止应用程序线程。这个阶段尝试着去承担 STW 的 Final Remark 阶段足够多的工作。这个阶段持续的时间依赖好多的因素，由于这个阶段是重复的做相同的事情直到发生 aboart 的条件（比如：重复的次数、多少量的工作、持续的时间等等）之一才会停止。</p><p><strong>Final Remark</strong></p><p>这个阶段是CMS中第二个并且是最后一个STW的阶段。该阶段的任务是完成标记整个年老代的所有的存活对象。由于之前的预处理是并发的，它可能跟不上应用程序改变的速度，这个时候，STW是非常需要的来完成这个严酷考验的阶段。<br>通常CMS尽量运行Final Remark阶段在年轻代是足够干净的时候，目的是消除紧接着的连续的几个 STW 阶段。因为年轻代存活对象过多的话，Minor GC会引发Full GC。</p><p><strong>Concurrent Sweep</strong></p><p>和应用线程同时进行，不需要STW。这个阶段的目的就是移除那些不用的对象，回收他们占用的空间并且为将来使用。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/ccd6905d-eb71-496d-a306-b1fff1b5fd8a"></div><p><strong>Concurrent Reset</strong></p><p>这个阶段并发执行，重新设置CMS算法内部的数据结构，准备下一个CMS生命周期的使用。</p><p><br></p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-verbose:gc</span></span><br><span class="line"><span class="comment">//-Xms20M</span></span><br><span class="line"><span class="comment">//-Xmx20M</span></span><br><span class="line"><span class="comment">//-Xmn10M</span></span><br><span class="line"><span class="comment">//-XX:+PrintGCDetails</span></span><br><span class="line"><span class="comment">//-XX:SurvivorRatio=8</span></span><br><span class="line"><span class="comment">//-XX:+UseConcMarkSweepGC</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> _1M = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">byte</span>[] bytes1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1M];</span><br><span class="line">    System.out.println(<span class="string">"----------------111111----------------"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1M];</span><br><span class="line">    System.out.println(<span class="string">"----------------222222----------------"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1M];</span><br><span class="line">    System.out.println(<span class="string">"----------------333333----------------"</span>);</span><br><span class="line">    <span class="keyword">byte</span>[] bytes4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1M];</span><br><span class="line">    System.out.println(<span class="string">"----------------444444----------------"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">----------------111111----------------</span><br><span class="line">[GC (Allocation Failure) [ParNew: 5922K-&gt;682K(9216K), 0.0026537 secs] 5922K-&gt;4780K(19456K), 0.0027242 secs] [Times: user=0.11 sys=0.02, real=0.00 secs] </span><br><span class="line">----------------222222----------------</span><br><span class="line">[GC (Allocation Failure) [ParNew: 5019K-&gt;186K(9216K), 0.0041525 secs] 9117K-&gt;9008K(19456K), 0.0042047 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (CMS Initial Mark) [1 CMS-initial-mark: 8821K(10240K)] 13159K(19456K), 0.0002459 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[CMS-concurrent-mark-start]</span><br><span class="line">----------------333333----------------</span><br><span class="line">----------------444444----------------</span><br><span class="line">[CMS-concurrent-mark: 0.001/0.001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[CMS-concurrent-preclean-start]</span><br><span class="line">[CMS-concurrent-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[CMS-concurrent-abortable-preclean-start]</span><br><span class="line">[CMS-concurrent-abortable-preclean: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (CMS Final Remark) [YG occupancy: 7648 K (9216 K)][Rescan (parallel) , 0.0006080 secs][weak refs processing, 0.0000306 secs][class unloading, 0.0004074 secs][scrub symbol table, 0.0006653 secs][scrub string table, 0.0001587 secs][1 CMS-remark: 8821K(10240K)] 16470K(19456K), 0.0019851 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[CMS-concurrent-sweep-start]</span><br><span class="line">[CMS-concurrent-sweep: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[CMS-concurrent-reset-start]</span><br><span class="line">[CMS-concurrent-reset: 0.000/0.000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> par new generation   total 9216K, used 7812K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">  eden space 8192K,  93% used [0x00000000fec00000, 0x00000000ff3729b8, 0x00000000ff400000)</span><br><span class="line">  from space 1024K,  18% used [0x00000000ff400000, 0x00000000ff42e950, 0x00000000ff500000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line"> concurrent mark-sweep generation total 10240K, used 8820K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000)</span><br><span class="line"> Metaspace       used 3193K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 343K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p><code>222222</code>：分配第二个4M空间时进行Minor GC。<br><code>333333</code>：分配第三个4M空间时会进行Minor GC。然后跟着CMS GC。我们可以发现CMS在工作的时候出现的不是Full GC。可能是由于Oracle认为GC只会STW很短的一段时间，所以不算为Full GC。<br>我们从上面的GC日志可以看到七个阶段。其中<code>CMS Initial Mark</code>和<code>CMS Final Remark</code>会出现在GC阶段，说明他们需要STW，而其他的五个阶段是和用户线程并行的。</p><p><br></p><h2 id="常用的参数"><a href="#常用的参数" class="headerlink" title="常用的参数"></a>常用的参数</h2><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td style="text-align:center">UseSerialGC</td><td style="text-align:center">虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收</td></tr><tr><td style="text-align:center">UseParNewGC</td><td style="text-align:center">打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收</td></tr><tr><td style="text-align:center">UseConcMarkSweepGC</td><td style="text-align:center">打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后壁收集器使用</td></tr><tr><td style="text-align:center">UseParallelGC</td><td style="text-align:center">虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old（PS MarkSweep）的收集器组合进行内存回收</td></tr><tr><td style="text-align:center">UseParallelOldGC</td><td style="text-align:center">打开此开关后，使用Parallel Scavenge+Parallel Old的收集器组合进行内存回收</td></tr><tr><td style="text-align:center">SurvivorRatio</td><td style="text-align:center">新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survivor:Survivor=8:1:1</td></tr><tr><td style="text-align:center">PretenureSizeThreshold</td><td style="text-align:center">直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配（只对串行回收器和ParNew有效）</td></tr><tr><td style="text-align:center">MaxTenuringThreshold</td><td style="text-align:center">晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄加1，当超过这个参数值时就进入老年代（只对串行回收器和ParNew有效）</td></tr><tr><td style="text-align:center">UseAdaptiveSizePolicy</td><td style="text-align:center">动态调整Java堆中各个区域的大小以及进入老年代的年龄</td></tr><tr><td style="text-align:center">HandlePromotionFailure</td><td style="text-align:center">是否允许分配担保失败，即老年代的剩余空间不足以应对新生代的整个Eden和Survivor区的所有对象都存活的极端情况</td></tr><tr><td style="text-align:center">ParallelGCThreads</td><td style="text-align:center">设置并行GC时进行内存回收的线程数</td></tr><tr><td style="text-align:center">GCTimeRatio</td><td style="text-align:center">GC时间占总时间的比率，默认值为99，即允许1%的GC时间（仅在使用Parallel Scavenge收集器时生效）</td></tr><tr><td style="text-align:center">MaxGCPauseMillis</td><td style="text-align:center">设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效</td></tr><tr><td style="text-align:center">CMSinitiatingOccupancyFraction</td><td style="text-align:center">设置CMS收集器在老年代空间被使用多少后出发垃圾收集。默认值为68%，仅在使用CMS收集器时生效</td></tr><tr><td style="text-align:center">UseCMSCompactAtFullCollection</td><td style="text-align:center">设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效</td></tr><tr><td style="text-align:center">CMSFullGCsBeforeCompaction</td><td style="text-align:center">设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;Reference&quot;&gt;&lt;a href=&quot;#Reference&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="JVM" scheme="https://isjinhao.github.io/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>03.01-JVM-类加载机制</title>
    <link href="https://isjinhao.github.io/posts/35597.html/"/>
    <id>https://isjinhao.github.io/posts/35597.html/</id>
    <published>2019-12-30T13:20:19.000Z</published>
    <updated>2019-12-30T13:20:35.714Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="类型的生命周期"><a href="#类型的生命周期" class="headerlink" title="类型的生命周期"></a>类型的生命周期</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li>加载：查找并加载类的二进制数据到JVM中（从外存到内存的过程）</li><li>连接：<ul><li>验证 : 确保被加载的类的正确性</li><li>准备：为类的<strong>静态变量</strong>分配内存，并将其<strong>初始化为默认值</strong>，但是到达初始化之前类变量都没有初始化为真正的初始值</li><li>解析：把类中的符号引用转换为直接引用，就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程</li></ul></li><li>初始化：为类的静态变量赋予正确的初始值</li></ul><p><br></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Java程序对类的使用方式可分为<strong>主动使用</strong>和<strong>被动使用</strong>两种。当且仅当主动使用时才会触发初始化过程。</p><h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><ul><li>创建类的实例（助记符：<code>new</code>）</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值（助记符：<code>getstatic</code>、<code>putstatic</code>）</li><li>调用类的静态方法（助记符：<code>invokestatic</code>）</li><li>反射（<code>Class.forName(xxx)</code>）</li><li>初始化一个类的子类时其父类需要现行初始化</li><li>Java虚拟机启动时被标明启动类的类</li><li>JDK1.7开始提供的动态语言支持（了解）</li></ul><h4 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h4><p>除了上面七种情况外，其他使用Java类的方式都被看做是对类的被动使用，都不会导致类的初始化。比如：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader().loadClass(<span class="string">"xxx"</span>);<span class="comment">// 不会初始化</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        对于静态字段来说，只有直接定义了该字段的类才会被初始化</span></span><br><span class="line"><span class="comment">        当一个类在初始化时，要求父类全部都已经初始化完毕</span></span><br><span class="line"><span class="comment">        -XX:+TraceClassLoading，用于追踪类的加载信息并打印出来</span></span><br><span class="line"><span class="comment">        -XX:+&lt;option&gt;，表示开启option选项</span></span><br><span class="line"><span class="comment">        -XX:-&lt;option&gt;，表示关闭option选项</span></span><br><span class="line"><span class="comment">        -XX:&lt;option&gt;=&lt;value&gt;，表示将option的值设置为value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(MyChild.str);    </span><br><span class="line">        <span class="comment">// 输出：MyParent static block、 hello world   （因为对MyChild不是主动使用）</span></span><br><span class="line">        System.out.println(MyChild.str2);   </span><br><span class="line">        <span class="comment">// 输出：MyParent static block、MyChild static block、welcome</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyParent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChild</span> <span class="keyword">extends</span> <span class="title">MyParent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str2 = <span class="string">"welcome"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyChild static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中。所以本质上，调用类并没有直接调用到定义常量的</span></span><br><span class="line"><span class="comment">        类，因此并不会触发定义常量的类的初始化。注意：这里指的是将常量存到MyTest2的常量池中，之后MyTest2和</span></span><br><span class="line"><span class="comment">        MyParent就没有任何关系了。甚至我们可以将MyParent2的class文件删除</span></span><br><span class="line"><span class="comment">        助记符 ldc：        表示将int、float或者String类型的常量值从常量池中推送至栈顶</span></span><br><span class="line"><span class="comment">        助记符 bipush：     表示将单字节[128-127]的常量值推送到栈顶，byte int push</span></span><br><span class="line"><span class="comment">        助记符 sipush：     表示将一个短整型值[-32768-32369]推送至栈顶，short int push</span></span><br><span class="line"><span class="comment">        助记符 iconst_1：   表示将int型的1推送至栈顶（iconst_m1到iconst_5）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyParent2.str);    <span class="comment">//输出 hello world</span></span><br><span class="line">        System.out.println(MyParent2.s);</span><br><span class="line">        System.out.println(MyParent2.i);</span><br><span class="line">        System.out.println(MyParent2.j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParent2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span> s = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">129</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyParent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当一个常量的值并非编译期间可以确定的，那么其值就不会放到调用类的常量池中</span></span><br><span class="line"><span class="comment"> * 这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyParent3.str);  </span><br><span class="line">        <span class="comment">// 输出MyParent static block、kjqhdun-baoje21w-jxqioj1-2jwejc9029</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParent3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyParent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用接口中的变量的时候不需要初始化其父接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyChild2.thread);</span><br><span class="line">        <span class="comment">// thread 初始化了</span></span><br><span class="line"><span class="comment">// Thread[Thread-0,5,main]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Student6</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread 初始化了"</span>);  <span class="comment">//如果父接口初始化了这句应该输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyChild2</span> <span class="keyword">extends</span> <span class="title">Student6</span> </span>&#123;</span><br><span class="line">    <span class="comment">// thread2是final变量，但是不会在编译期被放在ClassLoadTest5的常量池中</span></span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread2 初始化了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类-接口"><a href="#类-接口" class="headerlink" title="类+接口"></a>类+接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类初始化的时候不需要其接口完成初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyChild8.t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyGrandpa</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyGrandpa init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyParent1</span> <span class="keyword">extends</span> <span class="title">MyGrandpa</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyParent1 init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChild8</span> <span class="keyword">implements</span> <span class="title">MyParent1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyChild8 init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MyChild8 init</span></span><br><span class="line"><span class="comment">// Thread[Thread-0,5,main]</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyChild8.t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyGrandpa</span> </span>&#123;</span><br><span class="line">    Runnable t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyGrandpa init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParent1</span> <span class="keyword">implements</span> <span class="title">MyGrandpa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runnable t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyParent1 init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChild8</span> <span class="keyword">extends</span> <span class="title">MyParent1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runnable t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyChild8 init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">MyParent1 init</span></span><br><span class="line"><span class="comment">    MyChild8 init</span></span><br><span class="line"><span class="comment">    Thread[Thread-1,5,main]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="准备阶段和初始化的顺序"><a href="#准备阶段和初始化的顺序" class="headerlink" title="准备阶段和初始化的顺序"></a>准备阶段和初始化的顺序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 准备阶段会把静态变量附上默认值</span></span><br><span class="line"><span class="comment"> * 初始化的时候按从上到下的顺序把变量附上初始值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(Singleton.counter1);     <span class="comment">// 1</span></span><br><span class="line">        System.out.println(Singleton.counter2);     <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter2 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为 `[L数组元素全限定名` 这种形式。</span></span><br><span class="line"><span class="comment"> * 对于数组来说，JavaDoc将构成数据的元素称为Component，实际上是将数组降低一个维度后的类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 助记符：anewarray：表示创建一个引用类型（如类、接口）的数组，并将其引用值压入栈顶</span></span><br><span class="line"><span class="comment"> * 助记符：newarray：表示创建一个指定原始类型（int boolean float double）d的数组，并将其引用值压入栈顶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        MyParent4 myParent4 = new MyParent4();        // 创建类的实例，属于主动使用，会导致类的初始化</span></span><br><span class="line">        MyParent4[] myParent4s = <span class="keyword">new</span> MyParent4[<span class="number">1</span>];      <span class="comment">// 不是主动使用，不会导致类的初始化</span></span><br><span class="line">        System.out.println(myParent4s.getClass());   <span class="comment">// 输出 [[Ltwo.jvm.classloader.MyParent4;</span></span><br><span class="line">        System.out.println(myParent4s.getClass().getSuperclass());    <span class="comment">// 输出Object</span></span><br><span class="line">        <span class="keyword">int</span>[] i = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        System.out.println(i.getClass());          <span class="comment">// 输出 [I</span></span><br><span class="line">        System.out.println(i.getClass().getSuperclass());    <span class="comment">// 输出Object</span></span><br><span class="line">        <span class="comment">// 实际上数组类型是运行期动态加载的，也就是说数组类型是JVM在运行过程中创建的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParent4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyParent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类的实例化过程"><a href="#类的实例化过程" class="headerlink" title="类的实例化过程"></a>类的实例化过程</h4><ul><li>为新的对象分配内存</li><li>为实例变量赋默认值</li><li>为实例变量赋正确的初始值</li><li>执行构造方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTest7</span><span class="params">()</span> </span>&#123;    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">100</span>;</span><br><span class="line">    &#125;<span class="comment">// 这种代码块会在每次创建一个实例的时候都执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> MyTest7().i); <span class="comment">// 100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="生命周期的几个时机"><a href="#生命周期的几个时机" class="headerlink" title="生命周期的几个时机"></a>生命周期的几个时机</h3><p><strong>类加载</strong></p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它。JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器不会立即报告错误，而是在程序首次主动使用该类才报告错误（LinkageError错误），如果这个类没有被程序主动使用，那么类加载器就不会报告错误。在使用loadClass的时候只进行类加载过程，不会进行连接。</p><p><strong>连接</strong></p><p>连接的前两个过程笔者没有找到进行的依据，但是第三个过程解析的触发条件是遇到如下字节码：anewarray、checkcast、getfiled、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_c、multianewarray、new、putfield、putstatic。</p><p><strong>初始化时机</strong></p><p>主动使用</p><p><strong>生命周期的顺序</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/c0e21dca-6e8a-4abc-ad89-ce78d41e5c3f"></div><p>规范规定，加载、验证、准备、初始化、卸载这五个阶段的是要按顺序进行，但是解析阶段是遇到如上字节码指令才会进行。比如解析可能再初始化之后。</p><p><br></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>Java虚拟机自带的加载器<ul><li>根类加载器（Bootstrap）：该加载器没有父加载器，它负责加载虚拟机中的核心类库。根类加载器从系统属性<code>sun.boot.class.path</code>所指定的目录中加载类库。类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有继承<code>java.lang.ClassLoader</code>类。</li><li>扩展类加载器（Extension）：它的父加载器为根类加载器。它从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或者从JDK的安装目录的<code>jre\lib\ext</code>子目录（扩展目录）下加载类库，如果把用户创建的jar文件放在这个目录下，也会自动由扩展类加载器加载，扩展类加载器是纯<code>java</code>类，是<code>java.lang.ClassLoader</code>的子类。</li><li>系统应用类加载器（System）：也称为应用类加载器，它的父加载器为扩展类加载器，它从环境变量<code>classpath</code>或者系统属性<code>java.class.path</code>所指定的目录中加载类，他是用户自定义的类加载器的默认父加载器。系统类加载器时纯Java类，是<code>java.lang.ClassLoader</code>的子类。</li></ul></li><li>用户自定义的类加载器<ul><li><code>java.lang.ClassLoader</code>的子类</li><li>用户可以定制类的加载方式<br>根类加载器–&gt;扩展类加载器–&gt;系统应用类加载器–&gt;自定义类加载器</li></ul></li></ul><p><strong>路径</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));  <span class="comment">// 根加载器路径</span></span><br><span class="line">System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));        <span class="comment">// 扩展类加载器路径</span></span><br><span class="line">System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));      <span class="comment">// 应用类加载器路径</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><blockquote><p>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a “class file” of that name from a file system.<br>Every Class object contains a reference to the ClassLoader that defined it.<br><strong>Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime.</strong> The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.<br>Applications implement subclasses of ClassLoader in order to extend the manner in which the Java virtual machine dynamically loads classes.<br>Class loaders may typically be used by security managers to indicate security domains.<br>The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine’s built-in class loader, called the “bootstrap class loader”, does not itself have a parent but may serve as the parent of a ClassLoader instance.<br>Class loaders that support concurrent loading of classes are known as parallel capable class loaders and are required to register themselves at their class initialization time by invoking the ClassLoader.registerAsParallelCapable method. Note that the ClassLoader class is registered as parallel capable by default. However, its subclasses still need to register themselves if they are parallel capable. In environments in which the delegation model is not strictly hierarchical, class loaders need to be parallel capable, otherwise class loading can lead to deadlocks because the loader lock is held for the duration of the class loading process (see loadClass methods).<br>Normally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the CLASSPATH environment variable.<br>However, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. The method defineClass converts an array of bytes into an instance of class Class. Instances of this newly defined class can be created using Class.newInstance.<br>The methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the loadClass method of the class loader that originally created the class.<br>For example, an application could create a network class loader to download class files from a server. Sample code might look like:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader loader = <span class="keyword">new</span> NetworkClassLoader(host, port);</span><br><span class="line">Object main = loader.loadClass(<span class="string">"Main"</span>, <span class="keyword">true</span>).newInstance();</span><br><span class="line"><span class="comment">// . . .</span></span><br></pre></td></tr></table></figure><p></p></blockquote><p>The network class loader subclass must define the methods findClass and loadClassData to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method defineClass to create a class instance. A sample implementation is:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    String host;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        <span class="comment">// load the class data from the connection</span></span><br><span class="line">        <span class="comment">// . . .</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>Binary names</strong></p><p>Any class name provided as a String parameter to methods in ClassLoader must be a binary name as defined by The Java™ Language Specification. Examples of valid class names include:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"java.lang.String"</span></span><br><span class="line"><span class="string">"javax.swing.JSpinner$DefaultEditor"</span></span><br><span class="line"><span class="string">"java.security.KeyStore$Builder$FileBuilder$1"</span></span><br><span class="line"><span class="string">"java.net.URLClassLoader$3$1"</span></span><br></pre></td></tr></table></figure><p></p><h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] strings = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">    System.out.println(strings.getClass().getClassLoader());</span><br><span class="line">    <span class="comment">// 输出null，因为String是BootStrap类加载器加载的</span></span><br><span class="line">    <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    System.out.println(ints.getClass().getClassLoader());</span><br><span class="line">    <span class="comment">// 输出null，因为int是原生类型，没有类加载器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就加载后返回，否则交给子类加载器完成。（扩展类加载器只会加载jar包）</p><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/8dfa5630-d565-410f-b279-3edbb89666b7"></div><p>若有一个类能够成功加载Test类，那么这个类加载器被称为<strong>定义类加载器</strong>，所有能成功返回Class对象引用的类加载器（包括定义类加载器）称为<strong>初始类加载器</strong>。</p><p><br></p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><h4 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 如果没有被记载</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 有爹就找他爹去加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 没爹就找BootStrap加载器去加载</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 父亲不能加载的情况下自己加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 一个满足双亲委派原则的自定义类加载器需要覆盖此方法</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h4><blockquote><p>Finds the class with the specified binary name. This method should be overridden by class loader implementations that follow the delegation model for loading classes, and will be invoked by the loadClass method after checking the parent class loader for the requested class. The default implementation throws a ClassNotFoundException.<br>这个方法是上面第29行被调用的方法。如果想保持双亲委派机制（实际推荐），在自定义类加载器的时候不去覆盖loadClass，去覆盖findClass就可以了。</p></blockquote><h4 id="自定义一个类加载器"><a href="#自定义一个类加载器" class="headerlink" title="自定义一个类加载器"></a>自定义一个类加载器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建自定义加载器，继承ClassLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileExtension = <span class="string">".class"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();        <span class="comment">// 将系统类当做该类的父加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String className) &#123;</span><br><span class="line">        System.out.println(<span class="string">"className="</span> + className);</span><br><span class="line">        <span class="keyword">byte</span>[] data = loadClassData(className);</span><br><span class="line">        <span class="keyword">return</span> defineClass(className, data, <span class="number">0</span>, data.length);  <span class="comment">// define方法为父类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.path +  name.replace(<span class="string">"."</span>, <span class="string">"\\"</span>) + <span class="keyword">this</span>.fileExtension);</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> ch;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (ch = is.read())) &#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"two.jvm.classloader.MyTest"</span>);</span><br><span class="line">        <span class="comment">//loadClass是父类方法，在方法内部调用findClass</span></span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 父亲是系统类加载器，根据父类委托机制，MyTest1由AppClassLoader加载了</span></span><br><span class="line"><span class="comment">//        MyClassLoader loader1 = new MyClassLoader("loader1");</span></span><br><span class="line"><span class="comment">//        test(loader1);</span></span><br><span class="line">        <span class="comment">// 仍然是系统类加载器进行加载的，因为路径正好是classpath</span></span><br><span class="line"><span class="comment">//        MyClassLoader loader2 = new MyClassLoader("loader2");</span></span><br><span class="line"><span class="comment">//        loader2.path = "D:\\workspace\\java\\project-workspace\\backend-development-summary\\backend-development-summary\\target\\classes\\";</span></span><br><span class="line"><span class="comment">//        test(loader2);</span></span><br><span class="line">        <span class="comment">// 自定义的类加载器被执行，findClass方法下的输出被打印。前提是当前classpath下不存在MyTest1.class，MyTest16的父加载器-系统类加载器会尝试从classpath中寻找MyTest1。</span></span><br><span class="line">        MyClassLoader loader3 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader3"</span>);</span><br><span class="line">        loader3.path = <span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>;</span><br><span class="line">        test(loader3);</span><br><span class="line">        <span class="comment">// 与3同时存在，输出两个class的hash不同，findClass方法下的输出均被打印，因为类加载器的命名空间不同</span></span><br><span class="line">        MyClassLoader loader4 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader4"</span>);</span><br><span class="line">        loader4.path = <span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>;</span><br><span class="line">        test(loader4);</span><br><span class="line">        <span class="comment">// 将loader3作为父加载器，此次输出的字节码和loader3的一致</span></span><br><span class="line">        MyClassLoader loader5 = <span class="keyword">new</span> MyClassLoader(loader3, <span class="string">"loader3"</span>);</span><br><span class="line">        loader3.path = <span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>;</span><br><span class="line">        test(loader5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    className=two.jvm.classloader.MyTest</span></span><br><span class="line"><span class="comment">    C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyTest.class</span></span><br><span class="line"><span class="comment">    1554874502</span></span><br><span class="line"><span class="comment">    two.jvm.classloader.MyTest@6e0be858</span></span><br><span class="line"><span class="comment">    className=two.jvm.classloader.MyTest</span></span><br><span class="line"><span class="comment">    C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyTest.class</span></span><br><span class="line"><span class="comment">    1360875712</span></span><br><span class="line"><span class="comment">    two.jvm.classloader.MyTest@60e53b93</span></span><br><span class="line"><span class="comment">    1554874502</span></span><br><span class="line"><span class="comment">    two.jvm.classloader.MyTest@5e2de80c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>命名空间</strong></p><ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类构成；</li><li>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；</li><li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类；</li><li>同一命名空间内的类是互相可见的，非同一命名空间内的类是不可见的；</li><li>子加载器可以见到父加载器加载的类，父加载器也能见到子加载器加载的类。</li></ul><p><br></p><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><ul><li>当一个类被加载、连接和初始化之后，它的生命周期就开始了。当此类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，类在方法区内的数据也会被卸载。</li><li>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</li><li>由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机本身会始终引用这些加载器，而这些类加载器则会始终引用他们所加载的类的Class对象，因此这些Class对象是可触及的。</li><li>由用户自定义的类加载器所加载的类是可以被卸载的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    自定义类加载器加载类的卸载</span></span><br><span class="line"><span class="comment">    -XX:+TraceClassUnloading</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    jvisualvm 可以查看Java进程的信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MyClassLoader loader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader2"</span>);</span><br><span class="line">    loader2.path = <span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>;</span><br><span class="line">    test(loader2);</span><br><span class="line">    loader2 = <span class="keyword">null</span>;</span><br><span class="line">    System.gc();   <span class="comment">// 让系统去显式执行垃圾回收</span></span><br><span class="line">    <span class="comment">// 输出的两个对象hashcode值不同，因为前面加载的已经被卸载了</span></span><br><span class="line">    loader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader6"</span>);</span><br><span class="line">    loader2.path = <span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>;</span><br><span class="line">    test(loader2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    className=two.jvm.classloader.MyTest</span></span><br><span class="line"><span class="comment">    C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyTest.class</span></span><br><span class="line"><span class="comment">    1554874502</span></span><br><span class="line"><span class="comment">    two.jvm.classloader.MyTest@6e0be858</span></span><br><span class="line"><span class="comment">    [Unloading class two.jvm.classloader.MyTest 0x0000000100061028]</span></span><br><span class="line"><span class="comment">    className=two.jvm.classloader.MyTest</span></span><br><span class="line"><span class="comment">    C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyTest.class</span></span><br><span class="line"><span class="comment">    1360875712</span></span><br><span class="line"><span class="comment">    two.jvm.classloader.MyTest@60e53b93</span></span><br><span class="line"><span class="comment">    [Unloading class two.jvm.classloader.MyTest 0x0000000100061028]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="命名空间解析"><a href="#命名空间解析" class="headerlink" title="命名空间解析"></a>命名空间解析</h3><p><strong>定于两个辅助类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySample is loaded... "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">new</span> MyCat();</span><br><span class="line">        System.out.println(<span class="string">"from MySample: "</span> + MyCat.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat is loaded... "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line"><span class="comment">//        System.out.println("from MyCat: " + MySample.class);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>操作1：</strong></p><ol><li>外部文件有MySample和MyCat字节码</li><li>classpath下只有MySample字节码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建自定义加载器，继承ClassLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileExtension = <span class="string">".class"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();        <span class="comment">//将系统类当做该类的父加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String className) &#123;</span><br><span class="line">        System.out.println(<span class="string">"className="</span> + className);</span><br><span class="line">        <span class="keyword">byte</span>[] data = loadClassData(className);</span><br><span class="line">        <span class="keyword">return</span> defineClass(className, data, <span class="number">0</span>, data.length); <span class="comment">//define方法为父类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.path + name.replace(<span class="string">"."</span>, <span class="string">"\\"</span>) + <span class="keyword">this</span>.fileExtension);</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> ch;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (ch = is.read())) &#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"two.jvm.classloader.MyTest"</span>);</span><br><span class="line">        <span class="comment">//loadClass是父类方法，在方法内部调用findClass</span></span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader1"</span>);</span><br><span class="line">        loader1.setPath(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader1.loadClass(<span class="string">"two.jvm.classloader.MySample"</span>);</span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">312714112</span></span><br><span class="line"><span class="comment">MySample is loaded... sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.NoClassDefFoundError: two/jvm/classloader/MyCat</span></span><br><span class="line"><span class="comment">at two.jvm.classloader.MySample.&lt;init&gt;(MySample.java:6)</span></span><br><span class="line"><span class="comment">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span></span><br><span class="line"><span class="comment">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span></span><br><span class="line"><span class="comment">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span></span><br><span class="line"><span class="comment">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span></span><br><span class="line"><span class="comment">at java.lang.Class.newInstance(Class.java:442)</span></span><br><span class="line"><span class="comment">at two.jvm.classloader.MyClassLoader.main(MyClassLoader.java:83)</span></span><br><span class="line"><span class="comment">Caused by: java.lang.ClassNotFoundException: two.jvm.classloader.MyCat</span></span><br><span class="line"><span class="comment">at java.net.URLClassLoader.findClass(URLClassLoader.java:382)</span></span><br><span class="line"><span class="comment">at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span></span><br><span class="line"><span class="comment">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)</span></span><br><span class="line"><span class="comment">at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span></span><br><span class="line"><span class="comment">... 7 more</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">由于MySample是由AppClassLoader加载的，所以new MyCat()使用的是MySample的的类加载器，但是AppClassLoader的命名空间下无法加载MyCat，所以报错。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>操作2：</strong></p><ol><li>外部文件有MySample和MyCat字节码</li><li>classpath下只有MyCat字节码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">className=two.jvm.classloader.MySample</span></span><br><span class="line"><span class="comment">C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MySample.class</span></span><br><span class="line"><span class="comment">1554874502</span></span><br><span class="line"><span class="comment">MySample is loaded... two.jvm.classloader.MyClassLoader@12a3a380</span></span><br><span class="line"><span class="comment">MyCat is loaded... sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">from MySample: class two.jvm.classloader.MyCat</span></span><br><span class="line"><span class="comment">由于MySample是由MyClassLoader加载的，所以new MyCat()使用的是MySample的的类加载器，但是MyClassLoader的父加载器是可以加载MyCat的，所以MyCat是由AppClassLoader加载的。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>操作3</strong></p><ol><li>外部文件有MySample和MyCat字节码</li><li>classpath下只有MyCat字节码</li><li>修改MyCat为<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat is loaded... "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"from MyCat: "</span> + MySample.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">className=two.jvm.classloader.MySample</span></span><br><span class="line"><span class="comment">C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MySample.class</span></span><br><span class="line"><span class="comment">1554874502</span></span><br><span class="line"><span class="comment">MySample is loaded... two.jvm.classloader.MyClassLoader@12a3a380</span></span><br><span class="line"><span class="comment">MyCat is loaded... sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.NoClassDefFoundError: two/jvm/classloader/MySample</span></span><br><span class="line"><span class="comment">at two.jvm.classloader.MyCat.&lt;init&gt;(MyCat.java:6)</span></span><br><span class="line"><span class="comment">at two.jvm.classloader.MySample.&lt;init&gt;(MySample.java:6)</span></span><br><span class="line"><span class="comment">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span></span><br><span class="line"><span class="comment">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span></span><br><span class="line"><span class="comment">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span></span><br><span class="line"><span class="comment">at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span></span><br><span class="line"><span class="comment">at java.lang.Class.newInstance(Class.java:442)</span></span><br><span class="line"><span class="comment">at two.jvm.classloader.MyClassLoader.main(MyClassLoader.java:83)</span></span><br><span class="line"><span class="comment">Caused by: java.lang.ClassNotFoundException: two.jvm.classloader.MySample</span></span><br><span class="line"><span class="comment">at java.net.URLClassLoader.findClass(URLClassLoader.java:382)</span></span><br><span class="line"><span class="comment">at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span></span><br><span class="line"><span class="comment">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)</span></span><br><span class="line"><span class="comment">at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span></span><br><span class="line"><span class="comment">... 8 more</span></span><br><span class="line"><span class="comment">MySample是由MyClassLoader加载的，MyCat是由AppClassLoader加载的，在AppClassLoader中不能访问子加载器加载的类。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>操作4</strong></p><p>MySample和MyCat如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySample is loaded... "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">new</span> MyCat();</span><br><span class="line">        System.out.println(<span class="string">"from MySample: "</span> + MyCat.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat is loaded... "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line"><span class="comment">//        System.out.println("from MyCat: " + MySample.class);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">className=two.jvm.classloader.MySample</span><br><span class="line">C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MySample.class</span><br><span class="line"><span class="number">1554874502</span></span><br><span class="line">MySample is loaded... two.jvm.classloader.MyClassLoader@<span class="number">12</span>a3a380</span><br><span class="line">MyCat is loaded... sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">from MySample: <span class="class"><span class="keyword">class</span> <span class="title">two</span>.<span class="title">jvm</span>.<span class="title">classloader</span>.<span class="title">MyCat</span></span></span><br></pre></td></tr></table></figure><p>正常。因为MySample是由MyClassLoader加载的，MyCat是由AppClassLoader加载的，在MyClassLoader中可以访问父加载器加载的类。</p><p><strong>命名空间与强转问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPerson</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyPerson person;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyPerson</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = (MyPerson) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest21</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader1"</span>);</span><br><span class="line">        MyClassLoader loader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader2"</span>);</span><br><span class="line">        loader1.setPath(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>);</span><br><span class="line">        loader2.setPath(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>);</span><br><span class="line">        <span class="comment">// 删掉classpath下的MyPerson类</span></span><br><span class="line">        Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"two.jvm.classloader.MyPerson"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"two.jvm.classloader.MyPerson"</span>);</span><br><span class="line">        <span class="comment">// clazz1和clazz2由loader1和loader2加载，结果为false</span></span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line">        Object object1 = clazz1.newInstance();</span><br><span class="line">        Object object2 = clazz2.newInstance();</span><br><span class="line">        Method method = clazz1.getMethod(<span class="string">"setMyPerson"</span>, Object.class);</span><br><span class="line">        <span class="comment">// 此处报错，如图所示，loader1和loader2所处不用的命名空间</span></span><br><span class="line">        method.invoke(object1, object2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">className=two.jvm.classloader.MyPerson</span></span><br><span class="line"><span class="comment">C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyPerson.class</span></span><br><span class="line"><span class="comment">className=two.jvm.classloader.MyPerson</span></span><br><span class="line"><span class="comment">C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyPerson.class</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.reflect.InvocationTargetException</span></span><br><span class="line"><span class="comment">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span></span><br><span class="line"><span class="comment">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span></span><br><span class="line"><span class="comment">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span></span><br><span class="line"><span class="comment">at java.lang.reflect.Method.invoke(Method.java:498)</span></span><br><span class="line"><span class="comment">at two.jvm.classloader.MyTest21.main(MyTest21.java:22)</span></span><br><span class="line"><span class="comment">Caused by: java.lang.ClassCastException: two.jvm.classloader.MyPerson cannot be cast to two.jvm.classloader.MyPerson</span></span><br><span class="line"><span class="comment">at two.jvm.classloader.MyPerson.setMyPerson(MyPerson.java:7)</span></span><br><span class="line"><span class="comment">... 5 more</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><div align="center"><img width="40%" src="http://blogfileqiniu.isjinhao.site/24a9845e-bf60-4cdd-b956-156cedb97dcf"></div><h4 id="双亲委托机制的好处"><a href="#双亲委托机制的好处" class="headerlink" title="双亲委托机制的好处"></a>双亲委托机制的好处</h4><ul><li>可以确保Java和核心库的安全：所有的Java应用都会引用java.lang中的类，也就是说在运行期java.lang中的类会被加载到虚拟机中，如果这个加载过程如果是由自己的类加载器所加载，那么很可能就会在JVM中存在多个版本的java.lang中的类，而且这些类是相互不可见的（命名空间的作用）。借助于双亲委托机制，Java核心类库中的类的加载工作都是由启动根加载器去加载，从而确保了Java应用所使用的的都是同一个版本的Java核心类库，他们之间是相互兼容的；</li><li>确保Java核心类库中的类不会被自定义的类所替代；</li><li>不同的类加载器可以为相同名称的类（binary name）创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器去加载即可。相当于在Java虚拟机内部建立了一个又一个相互隔离的Java类空间。</li></ul><p><br></p><h3 id="getSystemClassLoader"><a href="#getSystemClassLoader" class="headerlink" title="getSystemClassLoader()"></a>getSystemClassLoader()</h3><blockquote><p>Returns the system class loader for delegation. This is the default delegation parent for new ClassLoader instances, and is typically the class loader used to start the application.<br><strong>This method is first invoked early in the runtime’s startup sequence, at which point it creates the system class loader and sets it as the context class loader of the invoking Thread.</strong><br>The default system class loader is an implementation-dependent instance of this class.<br>If the system property “java.system.class.loader” is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type ClassLoader which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader.<br>自定义类加载器的双亲默认是<code>getSystemClassLoader()返回的实例</code>，启动应用（运行main方法）的类加载器亦是。从文档可以看出此方法会很早就被JVM调用一次，此次调用的时候初始化<code>AppClasLoader</code>。实际上，拓展类加载器也是在这个阶段。</p></blockquote><p><br></p><h3 id="指定SystemClassLoader"><a href="#指定SystemClassLoader" class="headerlink" title="指定SystemClassLoader"></a>指定SystemClassLoader</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在classes文件夹下运行，指定系统类加载器</span><br><span class="line">java -Djava.system.class.loader=two.jvm.classloader.MyClassLoader two.jvm.cla</span><br><span class="line">ssloader.MyTest23</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在运行期，一个Java类是由该类的完全限定名（binary name）和用于加载该类的定义类加载器所共同决定的。如果同样名字（完全相同限定名）是由两个不同的加载器所加载，那么这些类就是不同的，即便.class文件字节码相同，并且从相同的位置加载亦如此。</span></span><br><span class="line"><span class="comment">    在oracle的hotspot，系统属性sun.boot.class.path如果修改错了，则运行会出错：</span></span><br><span class="line"><span class="comment">    Error occurred during initialization of VM</span></span><br><span class="line"><span class="comment">    java/lang/NoClassDeFoundError: java/lang/Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest23</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        System.out.println(ClassLoader.class.getClassLoader());</span><br><span class="line">        System.out.println(Launcher.class.getClassLoader());</span><br><span class="line">        <span class="comment">// 下面的系统属性指定系统类加载器，默认是AppClassLoader</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.system.class.loader"</span>));</span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line"><span class="comment">// 上面官方文档的解释，会将AppClassLoader设置为指定系统类加载器的父亲</span></span><br><span class="line">        System.out.println(systemClassLoader.getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要加入一个新的构造方法：</span></span><br><span class="line"><span class="comment">    public MyClassLoader(ClassLoader parent) &#123;</span></span><br><span class="line"><span class="comment">        super(parent);      //显式指定该类的父加载器</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">从终端启动：&gt;java -Djava.system.class.loader=two.jvm.classloader.MyClassLoader two.jvm.cla</span></span><br><span class="line"><span class="comment">ssloader.MyTest23</span></span><br><span class="line"><span class="comment">D:\Java\jdk\jre\lib\resources.jar;D:\Java\jdk\jre\lib\rt.jar;D:\Java\jdk\jre\lib\sunrsasign.jar;D:\Java\jdk\jre\lib\jsse.jar;D:\Java\jdk\jre\lib\jce.jar;D:\Java\jdk\jre\lib\charsets.ja</span></span><br><span class="line"><span class="comment">r;D:\Java\jdk\jre\lib\jfr.jar;D:\Java\jdk\jre\classes</span></span><br><span class="line"><span class="comment">D:\Java\jdk\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</span></span><br><span class="line"><span class="comment">.</span></span><br><span class="line"><span class="comment">-----------</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">two.jvm.classloader.MyClassLoader</span></span><br><span class="line"><span class="comment">sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="三个自带的类加载器初始化流程分析"><a href="#三个自带的类加载器初始化流程分析" class="headerlink" title="三个自带的类加载器初始化流程分析"></a>三个自带的类加载器初始化流程分析</h4><p>由于三个自带的类加载器初始化涉及的代码较多，所以下面只是按照方法的执行顺序来进行分析。而方法的起始便是我们之前提过的<code>getSystemClassLoader()</code>，这个方法在JVM后很早期就会被调用。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The class loader for the system</span></span><br><span class="line"><span class="comment">// @GuardedBy("ClassLoader.class")</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader scl;</span><br><span class="line"><span class="comment">// 如果没有初始化，初始化，否则返回SystemClassLoader，默认是AppClassLoader</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initSystemClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (scl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkClassLoaderPermission(scl, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set to true once the system class loader has been set</span></span><br><span class="line"><span class="comment">// @GuardedBy("ClassLoader.class")</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sclSet;</span><br><span class="line"><span class="comment">// 初始化系统类加载器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有被初始化过</span></span><br><span class="line">    <span class="keyword">if</span> (!sclSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (scl != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recursive invocation"</span>);</span><br><span class="line">        <span class="comment">// 获得Launcher，在Launcher的构造方法中初始化拓展类加载器和AppClassLoader</span></span><br><span class="line">        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Throwable oops = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获得AppClassLoader</span></span><br><span class="line">            scl = l.getClassLoader();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果类加载器是被-Djava.system.class.loader指定的，通过这一步设置给scl</span></span><br><span class="line">                scl = AccessController.doPrivileged(<span class="keyword">new</span> SystemClassLoaderAction(scl));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                oops = pae.getCause();</span><br><span class="line">                <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> InvocationTargetException) &#123;</span><br><span class="line">                    oops = oops.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oops != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Error) oops;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// wrap the exception</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(oops);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sclSet = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> launcher; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Launcher.ExtClassLoader var1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var1 = Launcher.ExtClassLoader.getExtClassLoader();  <span class="comment">// 获得拓展类加载器</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 设置线程上下文类加载器</span></span><br><span class="line">    Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br><span class="line">    String var2 = System.getProperty(<span class="string">"java.security.manager"</span>);</span><br><span class="line">    <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        SecurityManager var3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">""</span>.equals(var2) &amp;&amp; !<span class="string">"default"</span>.equals(var2)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var3 = (SecurityManager)<span class="keyword">this</span>.loader.loadClass(var2).newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception xxx) &#123;            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;   var3 = <span class="keyword">new</span> SecurityManager();       &#125;</span><br><span class="line">        <span class="keyword">if</span> (var3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create SecurityManager: "</span> + var2);</span><br><span class="line">        &#125;</span><br><span class="line">        System.setSecurityManager(var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Class var0 = Launcher.ExtClassLoader.class;</span><br><span class="line">        <span class="keyword">synchronized</span>(Launcher.ExtClassLoader.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; instance = createExtClassLoader(); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建一个拓展类加载器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">createExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Launcher.ExtClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Launcher.ExtClassLoader&gt;() &#123;</span><br><span class="line">            <span class="comment">// 获得ExtDirs并且构建 拓展类加载器</span></span><br><span class="line">            <span class="comment">// 由于拓展类加载器继承了URLClassLoader，给定File便可以进行加载</span></span><br><span class="line">            <span class="keyword">public</span> Launcher.<span class="function">ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                File[] var1 = Launcher.ExtClassLoader.getExtDirs();</span><br><span class="line">                <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                    MetaIndex.registerDirectory(var1[var3]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Launcher.ExtClassLoader(var1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PrivilegedActionException var1) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException)var1.getException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获得java.ext.dirs属性对应的jar包</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">    String var0 = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">    File[] var1;</span><br><span class="line">    <span class="keyword">if</span> (var0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        StringTokenizer var2 = <span class="keyword">new</span> StringTokenizer(var0, File.pathSeparator);</span><br><span class="line">        <span class="keyword">int</span> var3 = var2.countTokens();</span><br><span class="line">        var1 = <span class="keyword">new</span> File[var3];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123; var1[var4] = <span class="keyword">new</span> File(var2.nextToken()); &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; var1 = <span class="keyword">new</span> File[<span class="number">0</span>];  &#125;</span><br><span class="line">    <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取AppClassLoader</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// jars由java.class.path属性指定</span></span><br><span class="line">    <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">    <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> File[<span class="number">0</span>] : Launcher.getClassPath(var1);</span><br><span class="line">    <span class="keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            URL[] var1x = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> URL[<span class="number">0</span>] : Launcher.pathToURLs(var2);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemClassLoaderAction</span> <span class="keyword">implements</span> <span class="title">PrivilegedExceptionAction</span>&lt;<span class="title">ClassLoader</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader parent;</span><br><span class="line">    SystemClassLoaderAction(ClassLoader parent) &#123;  <span class="keyword">this</span>.parent = parent;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String cls = System.getProperty(<span class="string">"java.system.class.loader"</span>);</span><br><span class="line">        <span class="comment">// 如果没有设置java.system.class.loader，返回parent</span></span><br><span class="line">        <span class="keyword">if</span> (cls == <span class="keyword">null</span>) &#123;   <span class="keyword">return</span> parent;   &#125;</span><br><span class="line">        <span class="comment">// 调用自定义类加载器中能接受一个 parentClassLoader 的构造方法</span></span><br><span class="line">        Constructor&lt;?&gt; ctor = Class.forName(cls, <span class="keyword">true</span>, parent)</span><br><span class="line">            .getDeclaredConstructor(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; ClassLoader.class &#125;);</span><br><span class="line">        ClassLoader sys = (ClassLoader) ctor.newInstance(</span><br><span class="line">            <span class="keyword">new</span> Object[] &#123; parent &#125;);</span><br><span class="line">        <span class="comment">// 更新线程上下文类加载器</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(sys);</span><br><span class="line">        <span class="keyword">return</span> sys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">name：class name</span></span><br><span class="line"><span class="comment">initialize: 是否初始化</span></span><br><span class="line"><span class="comment">loader: 类加载器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize, ClassLoader loader)</span><br></pre></td></tr></table></figure><blockquote><p>Returns the Class object associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by getName) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameter loader is null, the class is loaded through the bootstrap class loader. The class is initialized only if the initialize parameter is true and if it has not been initialized earlier.<br>If name denotes a primitive type or void, an attempt will be made to locate a user-defined class in the unnamed package whose name is name. Therefore, this method cannot be used to obtain any of the Class objects representing primitive types or void.<br>If name denotes an array class, the component type of the array class is loaded but not initialized.<br>For example, in an instance method the expression:<br>Class.forName(“Foo”)<br>is equivalent to:<br>Class.forName(“Foo”, true, this.getClass().getClassLoader())<br>Note that this method throws errors related to loading, linking or initializing as specified in Sections 12.2, 12.3 and 12.4 of The Java Language Specification. Note that this method does not check whether the requested class is accessible to its caller.<br>If the loader is null, and a security manager is present, and the caller’s class loader is not null, then this method calls the security manager’s checkPermission method with a RuntimePermission(“getClassLoader”) permission to ensure it’s ok to access the bootstrap class loader.<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始化</span></span><br><span class="line"><span class="comment">// 默认的类加载器是调用者的类加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><p><br></p><h3 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h3><h4 id="当前类加载器"><a href="#当前类加载器" class="headerlink" title="当前类加载器"></a><strong>当前类加载器</strong></h4><p>每个类都会使用自己的类加载器（即加载自身的类加载器）来去加载其他类（指的是所依赖的类），如果classX引用了classY，那么加载classX的类加载器就会去加载classY。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest24</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"myclassloader"</span>);</span><br><span class="line">        myClassLoader.setPath(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>);</span><br><span class="line">        Class.forName(<span class="string">"two.jvm.classloader.Test1"</span>, <span class="keyword">true</span>, myClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// Test2是由MyClassLoader加载的</span></span><br><span class="line">        System.out.println(test2.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;   &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从外部加载class文件：</span></span><br><span class="line"><span class="comment">    className=two.jvm.classloader.Test1</span></span><br><span class="line"><span class="comment">    C:\Users\ISJINHAO\Desktop\two\jvm\classloader\Test1.class</span></span><br><span class="line"><span class="comment">    className=two.jvm.classloader.Test2</span></span><br><span class="line"><span class="comment">    C:\Users\ISJINHAO\Desktop\two\jvm\classloader\Test2.class</span></span><br><span class="line"><span class="comment">    two.jvm.classloader.MyClassLoader@4554617c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>这时候我们有一个问题，就是如果有一个类加载器委托模型如图：</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/e5d0c474-d9c1-41d9-9206-e4d57c18659a"></div><p>如果我们用loader1加载classX，loader1的父加载器是AppClassLoader，在classX中有一个classY成员变量。JVM是使用AppClassLoader加载classY，还是使用loader1加载classY，再委托给AppClassLoader？测试如下<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest26</span> </span>&#123;</span><br><span class="line">    MyTest27 myTest27 = <span class="keyword">new</span> MyTest27();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest27</span> </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest25</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader1"</span>);</span><br><span class="line">        loader1.setPath(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>);</span><br><span class="line">        Class&lt;?&gt; aClass = loader1.loadClass(<span class="string">"two.jvm.classloader.MyTest26"</span>);</span><br><span class="line">        aClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建自定义加载器，继承ClassLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> String path = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileExtension = <span class="string">".class"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();        <span class="comment">// 将系统类当做该类的父加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123; <span class="keyword">this</span>.path = path; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String className) &#123;</span><br><span class="line">        System.out.println(<span class="string">"className="</span> + className);</span><br><span class="line">        System.out.println(<span class="string">"classLoaderName="</span> + classLoaderName);</span><br><span class="line">        <span class="keyword">byte</span>[] data = loadClassData(className);</span><br><span class="line">        <span class="keyword">return</span> defineClass(className, data, <span class="number">0</span>, data.length); <span class="comment">//define方法为父类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.path + <span class="string">"\\"</span> + name.replace(<span class="string">"."</span>, <span class="string">"\\"</span>) + <span class="keyword">this</span>.fileExtension);</span><br><span class="line">            System.out.println(file.exists() + <span class="string">" "</span> + file.getAbsolutePath());</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> ch;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (ch = is.read())) &#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (is != <span class="keyword">null</span>)</span><br><span class="line">                    is.close();</span><br><span class="line">                <span class="keyword">if</span> (baos != <span class="keyword">null</span>)</span><br><span class="line">                    baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>操作步骤1</strong></p><ol><li>删除当前类路径下的MyTest27</li><li>“C:\Users\ISJINHAO\Desktop\“路径下有MyTest26和MyTest27</li></ol><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NoClassDefFoundError: two/jvm/classloader/MyTest27</span><br><span class="line">at two.jvm.classloader.MyTest26.&lt;init&gt;(MyTest26.java:<span class="number">5</span>)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:<span class="number">45</span>)</span><br><span class="line">at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">423</span>)</span><br><span class="line">at java.lang.Class.newInstance(Class.java:<span class="number">442</span>)</span><br><span class="line">at two.jvm.classloader.MyTest25.main(MyTest25.java:<span class="number">10</span>)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: two.jvm.classloader.MyTest27</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">382</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">349</span>)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">... <span class="number">7</span> more</span><br></pre></td></tr></table></figure><p><strong>操作步骤2</strong></p><ol><li>删除当前类路径下的MyTest27和MyTest26</li><li>“C:\Users\ISJINHAO\Desktop\“路径下有MyTest26和MyTest27</li></ol><p><strong>结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">className=two.jvm.classloader.MyTest26</span><br><span class="line">classLoaderName=loader1</span><br><span class="line">true C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyTest26.class</span><br><span class="line">className=two.jvm.classloader.MyTest27</span><br><span class="line">classLoaderName=loader1</span><br><span class="line">true C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyTest27.class</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>操作1里面loader1加载MyTest26，loader1委托给AppClassLoader，所以MyTest26是被AppClassLoader加载的，如果MyTest27是由被loader1加载，再委托给AppClassLoader的，AppClassLoader无法加载，再交由loader1，如此一来，MyTest27可以顺利加载。实际上无法顺利加载，说明MyTest27是直接被交给AppClassLoader的，AppClassLoader无法加载，所以有ClassNotFoundException。<br>操作2里面loader1加载MyTest26，loader1委托给AppClassLoader，AppClassLoader无法加载，再交给loader1，loader1从“C:\Users\ISJINHAO\Desktop\”路径下加载MyTest26，加载MyTest27的时候也是从外部路径加载的。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>每个类都会使用自己的类加载器（即加载自身的类加载器）来去加载其他类（指的是所依赖的类），如果classX引用了classY，那么classX的定义类加载器就会去加载classY。</p><h4 id="线程上下文类加载器-1"><a href="#线程上下文类加载器-1" class="headerlink" title="线程上下文类加载器"></a><strong>线程上下文类加载器</strong></h4><p>线程上下文类加载器是从JDK1.2开始引入的类，Thread类中的<code>getContextClassLoader()</code>与<code>setContextClassLoader(ClassLoader cl)</code>分别用来获取和设置上下文类加载器。如果没有通过set方法进行设置的话，线程将继承其父线程的上下文类加载器。Java应用运行时的初始线程的上下文类加载器是AppClassLoader。在线程中运行的代码可以通过该类加载器来加载类与资源。<br>线程上下文类加载器的重要性：在SPI（Service Provider Interface）机制下，ServiceLoader是由Bootstrap类加载器加载的，但是外包部导入的包是由AppClassLoader加载的。按照我们刚才的验证知道，这样其实是不可能的，因为在Bootstrap类加载器中根本无法看见当前类路径下的jar包。解决这个问题的就是线程上下文类加载器。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest28</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Driver&gt; loader = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = loader.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Driver next = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"driver: "</span> + next + <span class="string">", loader"</span> </span><br><span class="line">                               + next.getClass().getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"ServiceLoader类加载器: "</span> + ServiceLoader.class.getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"当前类加载器："</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">driver: com.mysql.jdbc.Driver@5e481248, loadersun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">driver: com.mysql.fabric.jdbc.FabricMySQLDriver@66d3c617, loadersun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">ServiceLoader类加载器: null</span></span><br><span class="line"><span class="comment">当前类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p><strong>跟踪分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="comment">// 传入当前线程类加载器</span></span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The class loader used to locate, load, and instantiate providers</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">    service = Objects.requireNonNull(svc, <span class="string">"Service interface cannot be null"</span>);</span><br><span class="line">    loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">    acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">    reload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasNext的源码省略…其目的是确定<code>META-INF/services</code>中的文件的全限定名。下面是next代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextService();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;S&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    String cn = nextName;</span><br><span class="line">    nextName = <span class="keyword">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里便是使用之前从线程获得类加载器进行类的加载</span></span><br><span class="line">        c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service, <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service, <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        S p = service.cast(c.newInstance());</span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service, <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;类型的生命周期&quot;&gt;&lt;a href=&quot;#类型的生命周期&quot; class=&quot;headerlink&quot; title=&quot;类型
      
    
    </summary>
    
      <category term="JVM" scheme="https://isjinhao.github.io/categories/JVM/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
      <category term="JVM" scheme="https://isjinhao.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>01.01-JavaSE-基础-1</title>
    <link href="https://isjinhao.github.io/posts/46326.html/"/>
    <id>https://isjinhao.github.io/posts/46326.html/</id>
    <published>2019-12-24T12:30:05.000Z</published>
    <updated>2019-12-30T13:20:35.605Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:00 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="JVM-amp-JDK-amp-JRE"><a href="#JVM-amp-JDK-amp-JRE" class="headerlink" title="JVM &amp; JDK &amp; JRE"></a>JVM &amp; JDK &amp; JRE</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><p><strong>什么是字节码?采用字节码的好处是什么?</strong></p><blockquote><p>在 Java 中，JVM可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote><p><strong>Java 程序从源代码到运行一般有下面3步：</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/009ba5ad-77cf-43f4-abed-80bb6a5f1437"></div><p>我们需要格外注意的是<code>.class-&gt;机器码</code>这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了 JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。</p><blockquote><p>HotSpot采用了惰性评估（Lazy Evaluation）的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9引入了一种新的编译模式AOT（Ahead of Time Compilation），它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是 ，AOT编译器的编译质量是肯定比不上JIT编译器的。</p></blockquote><p><strong>总结：</strong></p><p>Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows、Linux、macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是Java语言”一次编译，随处可以运行“的关键所在。</p><p><br></p><h3 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h3><p>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。<br>JRE是Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括Java虚拟机（JVM），Java类库，Java命令和其他的一些基础构件。但是，它不能用于创建新程序。<br>如果只是为了运行一下Java程序的话，那么只需要安装JRE。但如果需要进行一些Java编程方面的工作，那么就需要安装JDK了。但是，这不是绝对的。有时，即使不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要部署JSP-Web应用程序，需要JDK来将JSP编译成为Servlet。</p><p><br></p><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>异常是程序在运行时出现的会导致程序运行终止的错误。这种错误是不能通过编译系统检查出来的。常见的异常的发生原因为系统资源错误和用户操所错误两种。<br>Java把异常信息封装成一个类。当发生某种异常时将某种对应的类作为异常信息抛出。异常的根类时Throwable，其有两个直接子类 Error和Exception。Error是描述系统资源错误的类。Exception是描述用户操作错误的类。<br>发生了Error就是必须修改代码或调整外部环境问题，程序肯定会终止。比如需要开辟一个内存大小为99999999个int的数组。所以一般来说Error很少发生。发生了Exception就要进行处理，使程序运行下去，如数组越界异常，文件不存在异常等。而Exception又可以分为两种，一种是程序本身存在的问题引发的异常（健壮性不够），即：RuntimeException；一种是程序本身可能没有问题，但遇到诸如文件不存在所导致的错误，Excption中除了RuntimeException外都是此种异常，此种异常被称为受查异常（受查异常在写代码的时候会提示抛出还是处理）。<code>Error+RuntimeException</code>构成了非受查异常。</p><div align="center"><img width="65%" src="http://blogfileqiniu.isjinhao.site/3bdd4fc9-2ed9-4daa-b1fd-bed4e7004347"></div><p><strong>受查异常、非受查异常</strong></p><p>Java语言规范规定派生于Error类或RuntimeException类的异常都称为非受查异常，其余异常都被成为受查异常。受查异常就是必须告诉它的调用者可能会出现异常，让其调用者抛出或者捕获处理，这类异常如果没有在程序中进行异常处理，编译不通过。非受查异常则不需要。</p><p><strong>声明受查异常（throws）</strong></p><p>除了Error和RuntimeException的异常都是受查异常，这些异常如：IOException、SQLException等，在可能发生的方法中需要被声明。同时非受查异常最好不要被声明。需要使用throws声明异常后的情况如下：</p><ul><li>调用一个抛出受查异常的方法：<code>public int read() throws IOException</code></li><li>方法中使用throw语句抛出了受查异常。</li></ul><p><strong>抛出异常（throw）</strong></p><p>throw可以用于抛出异常对象。格式如下例：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;    </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"出现异常"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="常见的运行时异常"><a href="#常见的运行时异常" class="headerlink" title="常见的运行时异常"></a>常见的运行时异常</h3><ul><li><code>java.lang.NullPointerException</code> ：空指针异常；<ul><li>出现原因：调用了未经初始化的对象或者是不存在的对象。</li></ul></li><li><code>java.lang.ClassNotFoundException</code>：指定的类找不到；<ul><li>出现原因：类的名称和路径加载错误；通常都是程序试图通过字符串来加载某个类时可能引发异常。</li></ul></li><li><code>java.lang.NumberFormatException</code>：字符串转换为数字异常；<ul><li>出现原因：字符型数据中包含非数字型字符。</li></ul></li><li><code>java.lang.IndexOutOfBoundsException</code>：数组角标越界异常，常见于操作数组对象时发生。</li><li><code>java.lang.ClassCastException</code>：数据类型转换异常</li><li><code>SQLException</code>：SQL 异常，常见于操作数据库时的 SQL 语句错误。</li></ul><p><br></p><h3 id="finally和return的执行顺序"><a href="#finally和return的执行顺序" class="headerlink" title="finally和return的执行顺序"></a>finally和return的执行顺序</h3><p>finally在return语句执行后，return语句返回前执行。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> j = query();</span><br><span class="line">       System.out.println(j);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           System.out.print(<span class="string">"try\n"</span>);</span><br><span class="line">           <span class="keyword">return</span> i += <span class="number">10</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           System.out.print(<span class="string">"catch\n"</span>);</span><br><span class="line">           i += <span class="number">20</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           System.out.print(<span class="string">"finally-i:"</span>+i + <span class="string">"\n"</span>);</span><br><span class="line">           i += <span class="number">10</span>;</span><br><span class="line">           System.out.print(<span class="string">"finally\n"</span>);</span><br><span class="line">           <span class="comment">//return i;</span></span><br><span class="line">       &#125;</span><br><span class="line">       System.out.print(<span class="string">"finish"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">200</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">try</span></span><br><span class="line"><span class="comment">    finally-i:10</span></span><br><span class="line"><span class="comment">    finally</span></span><br><span class="line"><span class="comment">    10</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>代码中try语句块中，return i+=10; 这个时候i已经是10了，这个可以从输出的打印结果看出来，因为进入到finally语句的时候，有一个打印语句，打印结果中i就是10，就说明了return语句中的i+=10是已经执行了。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> j = query();</span><br><span class="line">       System.out.println(j);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           System.out.print(<span class="string">"try\n"</span>);</span><br><span class="line">           <span class="keyword">return</span> i += <span class="number">10</span>;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           System.out.print(<span class="string">"catch\n"</span>);</span><br><span class="line">           i += <span class="number">20</span>;</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           System.out.print(<span class="string">"finally-i:"</span>+i + <span class="string">"\n"</span>);</span><br><span class="line">           System.out.print(<span class="string">"finally\n"</span>);</span><br><span class="line">           <span class="keyword">return</span> i += <span class="number">10</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">try</span></span><br><span class="line"><span class="comment">    finally-i:10</span></span><br><span class="line"><span class="comment">    finally</span></span><br><span class="line"><span class="comment">    20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>try里<code>return i+=10</code>的<code>i+=10</code>被执行之后，return语句还没有返回，因为return语句返回代表该方法执行结束。在finally里<code>return i+=10</code>的<code>i+=10</code>被执行之后，i变成了20，此时的return会覆盖之前的return。</p><h4 id="由字节码执行顺序深入理解"><a href="#由字节码执行顺序深入理解" class="headerlink" title="由字节码执行顺序深入理解"></a>由字节码执行顺序深入理解</h4><p><strong>正常情况下指令</strong></p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/72922b73-75e0-4f3e-b693-823d2b6fdb0a"></div><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/e31ff637-674d-4915-96c2-844ce959b76a"></div><p><strong>异常情况下的处理</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Exception table:</span><br><span class="line">from    to  target type</span><br><span class="line">2    15    58   Class java/lang/Exception</span><br><span class="line">2    15   113   any</span><br><span class="line">58    70   113   any</span><br></pre></td></tr></table></figure><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/286a6feb-ccb0-4f28-bad2-e69b9372624b"></div><p>如果2到15行指令出现了异常，会进入我们的catch中。</p><p><br></p><h2 id="final"><a href="#final" class="headerlink" title="final"></a>final</h2><p><strong>修饰类</strong></p><p>当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p><p><strong>修饰方法</strong></p><p>只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。即父类的final方法是不能被子类所覆盖的。<br>重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义方法签名相同的方法，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。（注：类的private方法会隐式地被指定为final方法。）</p><p><strong>修饰变量</strong></p><p>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。</p><ul><li>当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；</li><li>如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。<br>final修饰一个成员变量，必须要显示初始化。这里有两种初始化方式，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。</li></ul><p><strong>finalize</strong></p><p>Object 类的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。该方法更像是一个对象生命周期的临终方法，当该方法被系统调用则代表该对象即将“死亡”，但是需要注意的是，我们主动行为上去调用该方法并不会导致该对象“死亡”，这是一个被动的方法（其实就是回调方法），不需要我们调用。</p><p><strong>effective final</strong></p><p>A variable is considered effective final if it is not modified after initialization in the local block. This means you can now use the local variable without final keyword inside an anonymous class or lambda expression, provided they must be effectively final.</p><p><br></p><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><p><strong>静态方法不可以覆盖，但是可以被重新定义</strong>（注意，静态方法可以被继承）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bks01</span> <span class="keyword">extends</span> <span class="title">Dad</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test();             <span class="comment">// son</span></span><br><span class="line">        Dad.test();         <span class="comment">// dad</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static方法可以被重新定义</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"son"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dad</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"dad"</span>);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>static执行顺序</strong></p><ul><li>静态先于普通</li><li>父类先于子类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bsk02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;System.out.println(<span class="string">"Bsk02 static"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bsk02</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"Bsk02 constructor"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Son();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    Bsk02 bsk02 = <span class="keyword">new</span> Bsk02();</span><br><span class="line">    <span class="keyword">static</span> &#123;System.out.println(<span class="string">"Son static"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"Son constructor"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;System.out.println(<span class="string">"Father static"</span>);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;System.out.println(<span class="string">"Father constructor"</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    Bsk02 static</span></span><br><span class="line"><span class="comment">    Father static</span></span><br><span class="line"><span class="comment">    Son static</span></span><br><span class="line"><span class="comment">    Father constructor</span></span><br><span class="line"><span class="comment">    Bsk02 constructor</span></span><br><span class="line"><span class="comment">    Son constructor</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure></li></ul><ol><li>加载Bsk02类，执行静态代码块，执行main方法里的<code>new Son()</code></li><li>初始化子类之前先初始化父类Father，执行静态代码块</li><li>初始化父类的静态变量/属性/代码块之后再执行子类Son的静态代码块</li><li>再构建父类对象</li><li>再初始化子类成员变量</li><li>再构建子类对象</li></ol><p><br></p><h2 id="重载和重写"><a href="#重载和重写" class="headerlink" title="重载和重写"></a>重载和重写</h2><h3 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h3><ul><li>参数列表必须完全与被重写方法的相同（方法签名一致）</li><li>返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类</li><li>访问权限不能比父类中被重写的方法的访问权限更低</li><li>父类的成员方法只能被它的子类重写</li><li>声明为final的方法不能被重写</li><li>声明为static的方法<strong>不能被重写</strong>，但是能够被再次声明</li><li>子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。</li><li>子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。</li><li>重写的方法（子类）不能抛出新的受查异常，或者比被重写方法（父类）声明的更广泛的受查异常。非受查异常没有约束。</li><li>构造方法不能被重写。</li><li>如果不能继承一个方法，则不能重写这个方法。</li></ul><p><br></p><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul><li>被重载的方法必须改变参数列表（参数个数或类型或顺序不一样）；</li><li>被重载的方法可以改变返回类型；</li><li>被重载的方法可以改变访问修饰符；</li><li>被重载的方法可以声明新的或更广的受查异常；</li><li>方法能够在同一个类中或者在一个子类中被重载。</li><li>无法以返回值类型作为重载函数的区分标准。</li></ul><p><br></p><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><table><thead><tr><th style="text-align:center">区别点</th><th style="text-align:center">重载方法</th><th style="text-align:center">重写方法</th></tr></thead><tbody><tr><td style="text-align:center">参数列表</td><td style="text-align:center">区分标准</td><td style="text-align:center">一定不能修改</td></tr><tr><td style="text-align:center">返回类型</td><td style="text-align:center">不是区分标准</td><td style="text-align:center">相同或者派生类</td></tr><tr><td style="text-align:center">受查异常</td><td style="text-align:center">不是区分标准</td><td style="text-align:center">可以缩小范围或删除，一定不能抛出新的或者更广的异常</td></tr><tr><td style="text-align:center">访问</td><td style="text-align:center">不是区分标准</td><td style="text-align:center">一定不能做更严格的限制（可以降低限制）</td></tr></tbody></table><p><br></p><h2 id="抽象类-amp-接口"><a href="#抽象类-amp-接口" class="headerlink" title="抽象类 &amp; 接口"></a>抽象类 &amp; 接口</h2><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><ul><li>抽象类中可以定义构造器</li><li>可以有抽象方法和具体方法</li><li>抽象类中可以定义成员变量</li><li>有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法</li><li>一个抽象类只能继承一个抽象类（和普通类一致）</li><li>抽象类可以包含静态方法</li></ul><h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><ul><li>抽象方法<strong>不能同时是静态的</strong>：抽象方法需要子类重写，而静态的方法是无法被重写的（只能被重新定义），因此二者是矛盾的。</li><li>抽象方法<strong>不能同时是本地的</strong>：本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。</li><li>抽象方法<strong>不能同时被synchronized修饰</strong>：synchronized加载普通方法上，拿的是对象的锁。但是抽象方法必须属于抽象类，抽象类本身不能存在实例。</li></ul><p><br></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul><li>接口中不能定义构造器</li><li>方法全部都是抽象方法</li><li>抽象类中的成员可以是private、默认、protected、public</li><li>接口中定义的成员变量实际上都是常量</li><li>接口中不能有静态方法</li><li>一个类可以实现多个接口</li></ul><p><br></p><h3 id="接口和抽象类的区别是什么"><a href="#接口和抽象类的区别是什么" class="headerlink" title="接口和抽象类的区别是什么"></a>接口和抽象类的区别是什么</h3><ol><li>接口的方法默认是 public，接口中的方法不能有实现（Java 8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li><li>接口中除了<code>static final</code>变量，不能有其他变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。</li><li>接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。<br>备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。</li></ol><p><br></p><h2 id="对象克隆"><a href="#对象克隆" class="headerlink" title="对象克隆"></a>对象克隆</h2><h3 id="多层浅拷贝"><a href="#多层浅拷贝" class="headerlink" title="多层浅拷贝"></a>多层浅拷贝</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">Body body = <span class="keyword">new</span> Body(<span class="keyword">new</span> Head(<span class="keyword">new</span> Face(<span class="keyword">new</span> String(<span class="string">"丑"</span>))));</span><br><span class="line">Body body1 = (Body) body.clone();</span><br><span class="line">System.out.println(<span class="string">"body == body1 : "</span> + (body == body1));</span><br><span class="line">System.out.println(<span class="string">"body.head == body1.head : "</span> + (body.head == body1.head));</span><br><span class="line">System.out.println(body.head.face == body1.head.face);</span><br><span class="line">System.out.println(body.head.face.name == body1.head.face.name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> Head head;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Body</span><span class="params">(Head head)</span> </span>&#123; <span class="keyword">this</span>.head = head; &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">Body newBody = (Body) <span class="keyword">super</span>.clone();</span><br><span class="line">newBody.head = (Head) head.clone();</span><br><span class="line"><span class="keyword">return</span> newBody;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Head</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> Face face;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Head</span><span class="params">(Face face)</span> </span>&#123; <span class="keyword">this</span>.face = face; &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">Head newHead = (Head)<span class="keyword">super</span>.clone();</span><br><span class="line">newHead.face = (Face) face.clone();</span><br><span class="line"><span class="keyword">return</span> newHead;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Face</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Face</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"><span class="keyword">public</span> String name;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">Face newFace = (Face)<span class="keyword">super</span>.clone();</span><br><span class="line">newFace.name = <span class="keyword">new</span> String(<span class="keyword">this</span>.name);</span><br><span class="line"><span class="keyword">return</span> newFace;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"Hao LUO"</span>, <span class="number">33</span>, <span class="keyword">new</span> Car(<span class="string">"Benz"</span>, <span class="number">300</span>));</span><br><span class="line">Person p2 = CloneUtils.clone(p1); <span class="comment">// 深度克隆</span></span><br><span class="line">p2.getCar().setBrand(<span class="string">"BYD"</span>);</span><br><span class="line">System.out.println(p1);</span><br><span class="line">System.out.println(p2);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneUtils</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">CloneUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">oos.writeObject(obj);</span><br><span class="line">ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray());</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line"><span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">9102017020286042305L</span>;</span><br><span class="line"><span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line"><span class="keyword">private</span> Car car; <span class="comment">// 座驾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Car car)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.car = car;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// ... getter方法和setter方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", car="</span> + car + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5713945027627603702L</span>;</span><br><span class="line"><span class="keyword">private</span> String brand; <span class="comment">// 品牌</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxSpeed; <span class="comment">// 最高时速</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand, <span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.brand = brand;</span><br><span class="line"><span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ... getter和setter方法</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Car [brand="</span> + brand + <span class="string">", maxSpeed="</span> + maxSpeed + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="基本类型和包装类型"><a href="#基本类型和包装类型" class="headerlink" title="基本类型和包装类型"></a>基本类型和包装类型</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Integer a = <span class="keyword">new</span> Integer(<span class="number">200</span>);</span><br><span class="line">    Integer b = <span class="keyword">new</span> Integer(<span class="number">200</span>);</span><br><span class="line">    Integer c = <span class="number">200</span>;</span><br><span class="line">    Integer e = <span class="number">200</span>;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">200</span>;</span><br><span class="line">    Object o = <span class="number">200</span>;</span><br><span class="line">    System.out.println(<span class="string">"object和包装类型                 "</span> + (o == c));</span><br><span class="line">    System.out.println(<span class="string">"两个new出来的对象                 "</span> + (a == b));</span><br><span class="line">    System.out.println(<span class="string">"new出的对象和用int赋值的Integer   "</span> + (a == c));</span><br><span class="line">    System.out.println(<span class="string">"两个用int赋值的Integer            "</span> + (c == e));</span><br><span class="line">    System.out.println(<span class="string">"基本类型和new出的对象             "</span> + (d == a));</span><br><span class="line">    System.out.println(<span class="string">"基本类型和自动装箱的对象           "</span> + (d == c));</span><br><span class="line">    Integer f = <span class="number">100</span>;</span><br><span class="line">    Integer g = <span class="number">100</span>;</span><br><span class="line">    System.out.println(<span class="string">"-128到127之间                    "</span> + (f == g));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    object和包装类型                 false</span></span><br><span class="line"><span class="comment">    两个new出来的对象                 false</span></span><br><span class="line"><span class="comment">    new出的对象和用int赋值的Integer   false</span></span><br><span class="line"><span class="comment">    两个用int赋值的Integer            false</span></span><br><span class="line"><span class="comment">    基本类型和new出的对象             true</span></span><br><span class="line"><span class="comment">    基本类型和自动装箱的对象           true</span></span><br><span class="line"><span class="comment">    -128到127之间                    true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>自动装箱发生的过程是：基本类型转换为包装类型。自动拆箱发生的过程是：包装类型转换为基本类型。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line">System.out.println(<span class="string">"i1 = i2   "</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">"i1 = i2+i3   "</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">"i1 = i4   "</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">"i4 = i5   "</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">"i4 == i5+i6   "</span> + (i4 == i5 + i6));   </span><br><span class="line">System.out.println(<span class="string">"40 == i5+i6   "</span> + (<span class="number">40</span> == i5 + i6));  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i1 == i2   true</span></span><br><span class="line"><span class="comment">    i1 == i2+i3   true</span></span><br><span class="line"><span class="comment">    i1 == i4   false</span></span><br><span class="line"><span class="comment">    i4 == i5   false</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数</span></span><br><span class="line"><span class="comment">    值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终</span></span><br><span class="line"><span class="comment">    这条语句转为40 == 40进行数值比较。</span></span><br><span class="line"><span class="comment">    i4 == i5+i6   true</span></span><br><span class="line"><span class="comment">    40 == i5+i6   true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>Java基本类型的包装类中：Byte，Short，Integer，Long，Character，Boolean实现了常量池技术；Float，Double 并没有实现常量池技术。<br>Character缓存了[0,127]之间的数据，Boolean缓存了true和false，其他4种包装类默认创建了数值[-128,127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。</p><p><br></p><h3 id="int的范围"><a href="#int的范围" class="headerlink" title="int的范围"></a>int的范围</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 补码会进行循环</span></span><br><span class="line">System.out.println(Integer.MAX_VALUE);<span class="comment">// 2147483647</span></span><br><span class="line">System.out.println(Integer.MAX_VALUE + <span class="number">1</span>);<span class="comment">// -2147483648</span></span><br><span class="line">System.out.println(Integer.MAX_VALUE + <span class="number">2</span>);<span class="comment">// -2147483647</span></span><br><span class="line">System.out.println(Integer.MIN_VALUE);<span class="comment">// -2147483648</span></span><br><span class="line">System.out.println(Integer.MIN_VALUE - <span class="number">1</span>);<span class="comment">// 2147483647</span></span><br><span class="line">System.out.println(Integer.MIN_VALUE - <span class="number">2</span>);<span class="comment">// 2147483646</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="基本类型之间的转换"><a href="#基本类型之间的转换" class="headerlink" title="基本类型之间的转换"></a>基本类型之间的转换</h3><ul><li>byte、short、int、long：小范围向大范围的可以自动转，大范围向小范围需要强制转。</li><li>char可以自动转换为int、long，可以强制转换为short、byte。byte、short、int、long都需要强制转换才能转为char。</li><li>float自动转换为double，double强制转换为float。</li><li>byte、short、int、long可以自动float和double。反之需要强制转换。</li><li><code>+=</code>和<code>-=</code>包含自动转换，即<code>short s1 = 1; s1 += 1;</code>不会报错。</li></ul><p><br></p><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><h3 id="三个关于池子的名词"><a href="#三个关于池子的名词" class="headerlink" title="三个关于池子的名词"></a>三个关于池子的名词</h3><h4 id="全局字符串池（string-pool也有叫做string-literal-pool）"><a href="#全局字符串池（string-pool也有叫做string-literal-pool）" class="headerlink" title="全局字符串池（string pool也有叫做string literal pool）"></a>全局字符串池（string pool也有叫做string literal pool）</h4><p>全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（<strong>记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。</strong>）。<br>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串（也就是我们常说的用双引号括起来的）的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。（字符串常量池本身也是存在堆中的）</p><h4 id="class文件常量池（class-constant-pool）"><a href="#class文件常量池（class-constant-pool）" class="headerlink" title="class文件常量池（class constant pool）"></a>class文件常量池（class constant pool）</h4><p>我们都知道，class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池（constant pool table），用于存放编译器生成的<strong>各种字面量（Literal）和符号引用（Symbolic References）</strong>。字面量就是我们所说的常量概念，如文本字符串、被声明为final且编译期能被确定的常量值等。符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：</p><ul><li>类和接口的全限定名</li><li>字段的名称和描述符</li><li>方法的名称和描述符<br>常量池的每一项常量都是一个表，一共有如下表所示的11种各不相同的表结构数据，这每个表开始的第一位都是一个字节的标志位（取值1-12），代表当前这个常量属于哪种常量类型。</li></ul><h4 id="运行时常量池（runtime-constant-pool）"><a href="#运行时常量池（runtime-constant-pool）" class="headerlink" title="运行时常量池（runtime constant pool）"></a>运行时常量池（runtime constant pool）</h4><p>当java文件被编译成class文件之后，也就是会生成class常量池。jvm在执行某个类的时候，必须经过<strong>加载、连接、初始化</strong>，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。JDK8的运行时常量池存放在堆中。</p><p><br></p><h3 id="String和字符串常量池"><a href="#String和字符串常量池" class="headerlink" title="String和字符串常量池"></a>String和字符串常量池</h3><h4 id="String对象的两种创建方式"><a href="#String对象的两种创建方式" class="headerlink" title="String对象的两种创建方式"></a>String对象的两种创建方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用双引号声明出来的 String 对象会直接存储在常量池中。</span></span><br><span class="line"><span class="comment">// 使用双引号声明时会调用ldc命令，所以其检查的是字符串常量池。</span></span><br><span class="line">String str1 = <span class="string">"abcd"</span>;</span><br><span class="line"><span class="comment">// 对于new String()则会在堆中创建一个String对象，并返回该对象的引用。</span></span><br><span class="line"><span class="comment">// Initializes a newly created String object so that it represents the same sequence </span></span><br><span class="line"><span class="comment">// of characters as the argument; in other words, the newly created string is a copy </span></span><br><span class="line"><span class="comment">// of the argument string. Unless an explicit copy of original is needed, use of this </span></span><br><span class="line"><span class="comment">// constructor is unnecessary since Strings are immutable.</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//false</span></span><br></pre></td></tr></table></figure><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/cf985854-486b-48b2-b22a-d0f9542a4756"></div><p><em>上图中的常量池指的是运行时常量池。</em></p><h4 id="intern"><a href="#intern" class="headerlink" title="intern()"></a>intern()</h4><p>String.intern() 是一个 Native 方法，JDK对它的解释是：</p><blockquote><p>A pool of strings, initially empty, is maintained privately by the class String. When the intern method is invoked, if the <strong>string</strong> pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the <strong>string</strong> pool and a reference to this String object is returned.（笔者注：这里的添加到字符串常量池实际上是在<strong>首次解析</strong>发现字符串常量池中没有才会添加到字符串常量池中）<br>It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.<br><strong>All literal strings and string-valued constant expressions are interned</strong>.<br>深入理解java虚拟机里面有一点解释的不是很规范，书里的解释字符串常量池里存的是“某个字符串实例首次出现的引用”，实际上应该说是“某个字符串实例首次被解析时的引用”，因为在类型的生命周期中，解析阶段需要将符号引用转为直接引用，这个阶段所使用到的字符串才符合书里说的“首次出现”这个概念，但问题是解析这个过程的发生只保证在new，invokespecial等12个指令出现之前。所以在面试题中，我一般将首次使用所为首次解析。</p></blockquote><h4 id="题"><a href="#题" class="headerlink" title="题"></a>题</h4><p><strong>1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"计算机"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">"计算机"</span>;</span><br><span class="line">System.out.println(s2);</span><br><span class="line">System.out.println(s1 == s2);<span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><div align="center"><img width="90%" src="http://blogfileqiniu.isjinhao.site/2dc48da6-9627-4e34-af33-47080e1b9ea3"></div><p><strong>2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"计算机"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"计算机"</span>);</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"计算机"</span>).intern();</span><br><span class="line">System.out.println(s1 == s2); <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><div align="center"><img width="90%" src="http://blogfileqiniu.isjinhao.site/07bbbec7-4f23-440a-b261-ef0ecdb6ca41"></div><p><strong>3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"2"</span>);</span><br><span class="line">System.out.println(s3 == s3.intern());<span class="comment">// true</span></span><br></pre></td></tr></table></figure><div align="center"><img width="90%" src="http://blogfileqiniu.isjinhao.site/2df8478d-173b-432c-96e7-64c255cf3fdd"></div><p><strong>4</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"12"</span>;<span class="comment">// 首次解析 12</span></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"2"</span>);</span><br><span class="line">System.out.println(s3 == s3.intern());<span class="comment">// false</span></span><br></pre></td></tr></table></figure><div align="center"><img width="90%" src="http://blogfileqiniu.isjinhao.site/c5c7356d-e5e3-4439-8d91-1df7c09c8bd9"></div><p><strong>5</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;</span><br><span class="line">String s2 = s1.intern();<span class="comment">// 首次解析xyz</span></span><br><span class="line">System.out.println(s1 == s1.intern());    <span class="comment">// true </span></span><br><span class="line">System.out.println(s2 == s1.intern()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><div align="center"><img width="90%" src="http://blogfileqiniu.isjinhao.site/f3a7ec71-a668-42fb-bfdc-e60636bacb7a"></div><p><strong>6</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"xyz"</span>);<span class="comment">// 首次解析xyz</span></span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">System.out.println(s2 == s3);<span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s1.intern());    <span class="comment">// false</span></span><br><span class="line">System.out.println(s2 == s1.intern());  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><div align="center"><img width="90%" src="http://blogfileqiniu.isjinhao.site/cdd18456-b1c4-4325-a2da-a3d1c3c72554"></div><p><strong>7</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"xyz"</span>);</span><br><span class="line">System.out.println(s2 == s3);<span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s1.intern());    <span class="comment">// true</span></span><br><span class="line">System.out.println(s2 == s1.intern());<span class="comment">// true</span></span><br></pre></td></tr></table></figure><div align="center"><img width="90%" src="http://blogfileqiniu.isjinhao.site/5e8eeffa-c9f8-46cf-b5dc-9fec4a6e5106"></div><p><strong>8</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s0 = <span class="string">"xyz"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(s0);</span><br><span class="line">System.out.println(s2 == s3);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s2);  <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s3);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s0 == s1);  <span class="comment">// true</span></span><br><span class="line">System.out.println(s2 == s3);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure><div align="center"><img width="90%" src="http://blogfileqiniu.isjinhao.site/9edb0838-a0ea-4e00-a1c6-e4cfbeee6c18"></div><h4 id="深入分析运行时常量池"><a href="#深入分析运行时常量池" class="headerlink" title="深入分析运行时常量池"></a>深入分析运行时常量池</h4><p>深入理解Java虚拟机第二版又这么一句话：JDK1.7（以及部分其他虚拟机，例如JRockit）的 intern 实现不会再复制实例，只是在常量池中记录首次出现的实例引用。<br>刚开始看到这句话其实是有点迷的，因为笔者之前理解的常量池中存放的应该是对象，为何引用也能被放进去？不过分析一下之后发现其实在运行时常量池里面应该也是使用键值对形式来保存数据的。否则诸如ldc等指令从常量池中拿数据时就只能采用遍历的方式，这个时间复杂度是不能忍受的，所以笔者暂且将运行时常量池保存数据的结果画作下图。</p><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/0e33c618-286b-46d7-a240-479f91d3c7f1"></div><p><br></p><h2 id="文件的表示"><a href="#文件的表示" class="headerlink" title="文件的表示"></a>文件的表示</h2><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3><p><strong>构造</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public File(String filepath);</span></span><br><span class="line"><span class="comment">// 绝对路径:以盘符开头的路径</span></span><br><span class="line"><span class="comment">// 相对路径:相对当前项目的根目录</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parent, String child)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(File parent,String child)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(URI uri)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">File aFile;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    aFile = <span class="keyword">new</span> File(<span class="keyword">new</span> URI(<span class="string">"file:///https://isjinhao.github.io/images/avatar.gif"</span>));</span><br><span class="line">    System.out.println(aFile.getName());</span><br><span class="line">&#125; <span class="keyword">catch</span> (URISyntaxException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAbsolutePath</span><span class="params">()</span></span>;  <span class="comment">// 获取绝对路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>;  <span class="comment">// 获取当前File对象的名字</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span></span>;  <span class="comment">// 获取创建File对象时 传递的路径</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 获取表示文件的File对象的占用的字节数</span></span><br><span class="line"><span class="comment">// 如果是文件夹的File对象,返回目录本身的大小,不是目录及其所有孩子的大小</span></span><br></pre></td></tr></table></figure><p><strong>创建文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span></span>; <span class="comment">// 创建一个新的文件（只能是文件，不能是文件夹），返回是否创建成功</span></span><br></pre></td></tr></table></figure><p><strong>创建文件夹</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span></span>;  <span class="comment">// 创建一个新的文件夹，返回是否创建成功</span></span><br></pre></td></tr></table></figure><p><strong>判断File对象所表示的文件在OS中是否存在</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;   <span class="comment">// 返回该File对象是否存在</span></span><br></pre></td></tr></table></figure><p><strong>判断是否是文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span></span>;   <span class="comment">// 返回是否是文件</span></span><br></pre></td></tr></table></figure><p><strong>判断是否是文件夹</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span></span>;  <span class="comment">// 返回是否是文件夹</span></span><br></pre></td></tr></table></figure><p><strong>删除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span></span>;  <span class="comment">//  删除文件或者文件夹。可以删除的是单个文件，或者空文件夹</span></span><br></pre></td></tr></table></figure><p><strong>list和listFiles</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] list();</span><br><span class="line"><span class="keyword">public</span> File[] listFiles(); <span class="comment">// 只能列出当前文件夹下的一级子文件或者子文件夹</span></span><br></pre></td></tr></table></figure><p><strong>文件过滤</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">File fileDir = <span class="keyword">new</span> File(<span class="string">"D:\\blog\\isjinhao\\source\\_posts\\04-进程管理"</span>);</span><br><span class="line"><span class="comment">// 列出file下所有file对象</span></span><br><span class="line">MyFileFilter ff = <span class="keyword">new</span> MyFileFilter();</span><br><span class="line">File[] files = fileDir.listFiles(ff);</span><br><span class="line"><span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">System.out.println(file);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyFileFilter</span> <span class="keyword">implements</span> <span class="title">FileFilter</span></span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">String name = pathname.getName();</span><br><span class="line"><span class="keyword">if</span>(name.endsWith(<span class="string">".png"</span>) || name.endsWith(<span class="string">".PNG"</span>))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h3><p>Path是JDK7中表达路径的一个新方式，在Path中，它把文件的路径看做几个<strong>部件</strong>组成的，比如<code>/usr/develop/tomcat</code>可以被看出两个部件组成：<code>/usr</code>和<code>/develop/tomcat</code>，当然也可以看做三个部件<code>/usr</code>、<code>/develop</code>和<code>/tomcat</code>组成的。以根部件开始的是绝对路径，在类Unix系统中是<code>\</code>，在Windows系统中是<code>C:\</code>等。</p><p><strong>获得Path</strong></p><p>通过Paths的静态方法：</p><ol><li><code>static Path get(String first, String ... more);</code></li><li><code>public static Path get(URI uri);</code><br>通过连接给定的字符串创建一个路径。</li></ol><p><strong>按当前路径解析路径</strong></p><ol><li><code>Path resolve(Path other);</code></li><li><code>Path resolve(String other);</code><br>如果other是绝对路径，那么返回other；否则，返回通过连接this和other获得路径。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path path1 = Paths.get(<span class="string">"D:\\"</span>, <span class="string">"data.csv"</span>);</span><br><span class="line">Path path2 = Paths.get(<span class="string">"test\\test"</span>, <span class="string">"选修课数据修改.csv"</span>);</span><br><span class="line">Path path3 = path1.resolve(path2);</span><br><span class="line">Path path4 = path2.resolve(path1);</span><br><span class="line">System.out.println(path3);<span class="comment">// D:\data.csv\test\test\选修课数据修改.csv</span></span><br><span class="line">System.out.println(path4);<span class="comment">// D:\data.csv</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>按当前路径解析路径</strong></p><ol><li><code>Path resolveSibling(Path other);</code></li><li><code>Path resolveSibling(String other);</code><br>如果other是绝对路径，那么返回other；否则，返回通过连接this的父路径和other获得路径。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//define the fixed path</span></span><br><span class="line"> Path base = Paths.get(<span class="string">"C:/rafaelnadal/tournaments/2009/BNP.txt"</span>);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//resolve sibling AEGON.txt file</span></span><br><span class="line"> Path path = base.resolveSibling(<span class="string">"AEGON.txt"</span>);</span><br><span class="line"> <span class="comment">//output: C:\rafaelnadal\tournaments\2009\AEGON.txt</span></span><br><span class="line"> System.out.println(path.toString());</span><br></pre></td></tr></table></figure></li></ol><p><strong>按相对路径进行解析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Path path01 = Paths.get(<span class="string">"BNP.txt"</span>);</span><br><span class="line">Path path02 = Paths.get(<span class="string">"AEGON.txt"</span>);</span><br><span class="line">System.out.println(path01);     <span class="comment">// BNP.txt</span></span><br><span class="line">Path path01_to_path02 = path01.relativize(path02);      <span class="comment">// ..\AEGON.txt</span></span><br><span class="line">System.out.println(path01_to_path02);</span><br><span class="line">System.out.println(path02);     <span class="comment">// AEGON.txt</span></span><br><span class="line">Path path02_to_path01 = path02.relativize(path01);      <span class="comment">// ..\BNP.txt</span></span><br><span class="line">System.out.println(path02_to_path01);</span><br></pre></td></tr></table></figure><p><strong>其他API</strong></p><ol><li>移除诸如.和..等的冗余元素：<code>Path normalize();</code></li><li>返回和当前路径相等价的绝对路径：<code>Path toAbsolutePath();</code></li><li>返回父路径（没有时返回null）：<code>Path getParent();</code></li><li>返回该路径的最后一个部件：<code>Path getFileName();</code></li><li>返回该路径的根部件（没有时返回null）：<code>Path getRoot();</code></li><li>由Path创建一个File对象：<code>File toFile();</code></li></ol><p><br></p><h3 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h3><p><strong>处理小型文本文件</strong></p><ul><li><p><code>public static byte[] readAllBytes(Path path) throws IOException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">byte</span>[] bytes = Files.readAllBytes(Paths.get(<span class="string">"filestest"</span>));</span><br><span class="line">String string = <span class="keyword">new</span> String(bytes, <span class="string">"UTF-8"</span>);</span><br><span class="line">System.out.println(string);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>public static List&lt;String&gt; readAllLines(Path path) throws IOException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">List&lt;String&gt; lines = Files.readAllLines(Paths.get(<span class="string">"filestest"</span>));</span><br><span class="line">Iterator&lt;String&gt; iterator = lines.iterator();</span><br><span class="line"><span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>public static Path write(Path path, byte[] bytes, OpenOption... options) throws IOException</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Files.write(Paths.get(<span class="string">"filestest"</span>), <span class="string">"深陷琪中，钰罢不能"</span>.getBytes(), </span><br><span class="line">                StandardOpenOption.APPEND);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得IO流</p><ul><li><code>public static InputStream newInputStream(Path path, OpenOption... options)</code></li><li><code>public static OutputStream newOutputStream(Path path, OpenOption... options)</code></li><li><code>public static BufferedReader newBufferedReader(Path path, Charset cs)</code></li><li><code>public static BufferedReader newBufferedReader(Path path)</code></li></ul></li></ul><p><strong>Files.exists()</strong></p><p><code>Files.exists()</code>方法检查给定的<code>Path</code>在文件系统中是否存在。<br>可以创建在文件系统中不存在的<code>Path</code>实例。例如，如果您计划创建一个新目录，您首先要创建相应的<code>Path</code>实例，然后创建目录。<br>由于<code>Path</code>实例可能指向，也可能没有指向文件系统中存在的路径，你可以使用<code>Files.exists()</code>方法来确定它们是否存在（如果需要检查的话）。<br>这里是一个<code>Files.exists()</code>的例子：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/logging.properties"</span>);</span><br><span class="line"><span class="keyword">boolean</span> pathExists = Files.exists(path, <span class="keyword">new</span> LinkOption[]&#123; LinkOption.NOFOLLOW_LINKS &#125;);</span><br></pre></td></tr></table></figure><p></p><p>这个例子首先创建一个<code>Path</code>实例指向一个路径，我们想要检查这个路径是否存在。然后，这个例子调用<code>Files.exists()</code>方法，然后将<code>Path</code>实例作为第一个参数。<br>注意<code>Files.exists()</code>方法的第二个参数。这个参数是一个选项数组，它影响<code>Files.exists()</code>如何确定路径是否存在。在上面的例子中的数组包含<code>LinkOption.NOFOLLOW_LINKS</code>，这意味着<code>Files.exists()</code>方法不应该在文件系统中跟踪符号链接，以确定文件是否存在。</p><p><strong>Files.createDirectory()</strong></p><p><code>Files.createDirectory()</code>方法，用于根据<code>Path</code>实例创建一个新目录：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/subdir"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Path newDir = Files.createDirectory(path);</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileAlreadyExistsException e)&#123;</span><br><span class="line">    <span class="comment">// 目录已经存在</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 其他发生的异常</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>第一行创建表示要创建的目录的<code>Path</code>实例。在<code>try-catch</code>块中，用路径作为参数调用<code>Files.createDirectory()</code>方法。如果创建目录成功，将返回一个<code>Path</code>实例，该实例指向新创建的路径。<br>如果该目录已经存在，则是抛出一个<code>java.nio.file.FileAlreadyExistsException</code>。如果出现其他错误，可能会抛出<code>IOException</code>。例如，如果想要的新目录的父目录不存在，则可能会抛出<code>IOException</code>。父目录是您想要创建新目录的目录。因此，它表示新目录的父目录。</p><p><strong>Files.copy()</strong></p><p><code>Files.copy()</code>方法从一个路径拷贝一个文件到另外一个目录，这里是一个Java <code>Files.copy()</code>例子：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath      = Paths.get(<span class="string">"data/logging.properties"</span>);</span><br><span class="line">Path destinationPath = Paths.get(<span class="string">"data/logging-copy.properties"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.copy(sourcePath, destinationPath);</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileAlreadyExistsException e) &#123;</span><br><span class="line">    <span class="comment">// 目录已经存在</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 其他发生的异常</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>首先，该示例创建一个源和目标<code>Path</code>实例。然后，这个例子调用<code>Files.copy()</code>，将两个<code>Path</code>实例作为参数传递。这可以让源路径引用的文件被复制到目标路径引用的文件中。<br>如果目标文件已经存在，则抛出一个<code>java.nio.file.FileAlreadyExistsException</code>异常。如果有其他错误，则会抛出一个<code>IOException</code>。例如，如果将该文件复制到不存在的目录，则会抛出<code>IOException</code>。</p><p><strong>重写已存在的文件</strong></p><p>可以强制<code>Files.copy()</code>覆盖现有的文件。这里有一个示例，演示如何使用<code>Files.copy()</code>覆盖现有文件。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath      = Paths.get(<span class="string">"data/logging.properties"</span>);</span><br><span class="line">Path destinationPath = Paths.get(<span class="string">"data/logging-copy.properties"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">&#125; <span class="keyword">catch</span>(FileAlreadyExistsException e) &#123;</span><br><span class="line">    <span class="comment">// 目标文件已存在</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 其他发生的异常</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>请注意<code>Files.copy()</code>方法的第三个参数。如果目标文件已经存在，这个参数指示<code>copy()</code>方法覆盖现有的文件。</p><p><strong>Files.move()</strong></p><p><code>Files</code>还包含一个函数，用于将文件从一个路径移动到另一个路径。移动文件与重命名相同，但是移动文件既可以移动到不同的目录，也可以在相同的操作中更改它的名称。是的，<code>java.io.File</code>类也可以使用它的<code>renameTo()</code>方法来完成这个操作，但是现在已经在<code>java.nio.file.Files</code>中有了文件移动功能。<br>这里有一个<code>Files.move()</code>例子：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Path sourcePath      = Paths.get(<span class="string">"data/logging-copy.properties"</span>);</span><br><span class="line">Path destinationPath = Paths.get(<span class="string">"data/subdir/logging-moved.properties"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.move(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 移动文件失败</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> StandardCopyOption implements CopyOption &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Replace an existing file if it exists.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    REPLACE_EXISTING,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Copy attributes to the new file.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    COPY_ATTRIBUTES,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Move the file as an atomic file system operation.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ATOMIC_MOVE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>首先创建源路径和目标路径。源路径指向要移动的文件，而目标路径指向文件应该移动到的位置。然后调用<code>Files.move()</code>方法。这会导致文件被移动。<br>请注意传递给<code>Files.move()</code>的第三个参数。这个参数告诉<code>Files.move()</code>方法来覆盖目标路径上的任何现有文件。这个参数实际上是可选的。<br>如果移动文件失败，<code>Files.move()</code>方法可能抛出一个<code>IOException</code>。例如，如果一个文件已经存在于目标路径中，并且您已经排除了<code>StandardCopyOption.REPLACE_EXISTING</code>选项，或者被移动的文件不存在等等。</p><p><strong>Files.delete()</strong></p><p><code>Files.delete()</code>方法可以删除一个文件或者目录。下面是一个Java <code>Files.delete()</code>例子：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Path path = Paths.get(<span class="string">"data/subdir/logging-moved.properties"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.delete(path);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="comment">// 删除文件失败</span></span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>首先，创建指向要删除的文件的<code>Path</code>。然后调用<code>Files.delete()</code>方法。如果<code>Files.delete()</code>由于某种原因不能删除文件（例如，文件或目录不存在），会抛出一个<code>IOException</code>。</p><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><p><strong>Files.walkFileTree()</strong></p><p><code>Files.walkFileTree()</code>方法包含递归遍历目录树的功能。<code>walkFileTree()</code>方法将<code>Path</code>实例和<code>FileVisitor</code>作为参数。<code>Path</code>实例指向您想要遍历的目录。<code>FileVisitor</code>在遍历期间被调用。<br>在我解释遍历是如何工作之前，这里我们先了解<code>FileVisitor</code>接口:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FileVisitor</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(T dir, BasicFileAttributes attrs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function">FileVisitResult <span class="title">visitFile</span><span class="params">(T file, BasicFileAttributes attrs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function">FileVisitResult <span class="title">visitFileFailed</span><span class="params">(T file, IOException exc)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">    <span class="function">FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(T dir, IOException exc)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>您必须自己实现<code>FileVisitor</code>接口，并将实现的实例传递给<code>walkFileTree()</code>方法。在目录遍历过程中，您的<code>FileVisitor</code>实现的每个方法都将被调用。如果不需要实现所有这些方法，那么可以扩展<code>SimpleFileVisitor</code>类，它包含<code>FileVisitor</code>接口中所有方法的默认实现。<br>这里是一个<code>walkFileTree()</code>的例子：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Files.walkFileTree(path, <span class="keyword">new</span> FileVisitor&lt;Path&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"pre visit dir:"</span> + dir);</span><br><span class="line">        <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"visit file: "</span> + file);</span><br><span class="line">        <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFileFailed</span><span class="params">(Path file, IOException exc)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"visit file failed: "</span> + file);</span><br><span class="line">        <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"post visit directory: "</span> + dir);</span><br><span class="line">        <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p><code>FileVisitor</code>实现中的每个方法在遍历过程中的不同时间都被调用:<br>在访问任何目录之前调用<code>preVisitDirectory()</code>方法。在访问一个目录之后调用<code>postVisitDirectory()</code>方法。<br>调用<code>visitFile()</code>在文件遍历过程中访问的每一个文件。它不会访问目录-只会访问文件。在访问文件失败时调用<code>visitFileFailed()</code>方法。例如，如果您没有正确的权限，或者其他什么地方出错了。<br>这四个方法中的每个都返回一个<code>FileVisitResult</code>枚举实例。<code>FileVisitResult</code>枚举包含以下四个选项:</p><ul><li>CONTINUE：继续，意味着文件的执行应该像正常一样继续。</li><li>TERMINATE：终止，意味着文件遍历现在应该终止。</li><li>SKIP_SIBLING：跳过同级，意味着文件遍历应该继续，但不需要访问该文件或目录的任何同级。</li><li>SKIP_SUBTREE：意味着文件遍历应该继续，但是不需要访问这个目录中的子目录。这个值只有从<code>preVisitDirectory()</code>返回时才是一个函数。如果从任何其他方法返回，它将被解释为一个<code>CONTINUE</code>继续。<br>通过返回其中一个值，调用方法可以决定如何继续执行文件。</li></ul><p><strong>文件搜索</strong></p><p>这里是一个用于扩展<code>SimpleFileVisitor</code>的<code>walkFileTree()</code>，以查找一个名为<code>README.txt</code>的文件:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Path rootPath = Paths.get(<span class="string">"data"</span>);</span><br><span class="line">String fileToFind = File.separator + <span class="string">"README.txt"</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.walkFileTree(rootPath, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            String fileString = file.toAbsolutePath().toString();</span><br><span class="line">            <span class="comment">// System.out.println("pathString = " + fileString);</span></span><br><span class="line">            <span class="keyword">if</span>(fileString.endsWith(fileToFind))&#123;</span><br><span class="line">                System.out.println(<span class="string">"file found at path: "</span> + file.toAbsolutePath());</span><br><span class="line">                <span class="keyword">return</span> FileVisitResult.TERMINATE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>递归删除目录</strong></p><p><code>Files.walkFileTree()</code>也可以用来删除包含所有文件和子目录的目录。<code>Files.delete()</code>方法只会删除一个目录，如果它是空的。通过遍历所有目录并删除每个目录中的所有文件(在<code>visitFile()</code>)中，然后删除目录本身(在<code>postVisitDirectory()</code>中)，您可以删除包含所有子目录和文件的目录。下面是一个递归目录删除示例:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Path rootPath = Paths.get(<span class="string">"data/to-delete"</span>);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Files.walkFileTree(rootPath, <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"delete file: "</span> + file.toString());</span><br><span class="line">            Files.delete(file);</span><br><span class="line">            <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> </span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Files.delete(dir);</span><br><span class="line">            System.out.println(<span class="string">"delete dir: "</span> + dir.toString());</span><br><span class="line">            <span class="keyword">return</span> FileVisitResult.CONTINUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125; <span class="keyword">catch</span>(IOException e)&#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:00 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;JVM-amp-JDK-amp-JRE&quot;&gt;&lt;a href=&quot;#JVM-amp-JDK-amp-JRE&quot; clas
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>01.03-JavaSE-基础-3</title>
    <link href="https://isjinhao.github.io/posts/5590.html/"/>
    <id>https://isjinhao.github.io/posts/5590.html/</id>
    <published>2019-12-24T12:30:05.000Z</published>
    <updated>2019-12-30T13:20:35.638Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:00 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">// 在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// key这个成员变量的类型为T，T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    <span class="comment">// 泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="keyword">this</span>.key = key; &#125;</span><br><span class="line">    <span class="comment">// 泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line">    <span class="comment">// 传入的实参类型需与泛型的类型参数类型相同，即为Integer</span></span><br><span class="line">    Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line">    <span class="comment">// 传入的实参类型需与泛型的类型参数类型相同，即为String</span></span><br><span class="line">    Generic&lt;String&gt; genericString = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"key_vlaue"</span>);</span><br><span class="line">    System.out.println(<span class="string">"key is "</span> + genericInteger.getKey().getClass());</span><br><span class="line">    System.out.println(<span class="string">"key is "</span> + genericString.getKey().getClass());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="泛型接口的实现"><a href="#泛型接口的实现" class="headerlink" title="泛型接口的实现"></a>泛型接口的实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当实现泛型接口的类，未传入泛型实参时：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，会报错："Unknown class"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>当实现泛型接口的类，传入泛型实参时：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口，虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next(); 中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><p>泛型类，是在实例化类的时候指明泛型的具体类型；<strong>泛型方法，是在调用方法的时候指明泛型的具体类型</strong> 。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *   1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *   2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *   3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *   4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> * 5）如果泛型类也声明了一个T，泛型方法的T会覆盖泛型类的T</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InstantiationException, IllegalAccessException</span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="泛型”方法”的详细举例"><a href="#泛型”方法”的详细举例" class="headerlink" title="泛型”方法”的详细举例"></a>泛型”方法”的详细举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="keyword">this</span>.key = key; &#125;</span><br><span class="line">        <span class="comment">// 我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">// 这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">// 所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">            public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">                 this.key = keu</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">// 当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">        public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container) &#123;</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类中的泛型方法"><a href="#类中的泛型方法" class="headerlink" title="类中的泛型方法"></a>类中的泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"fruit"</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"apple"</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Person"</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 方法中的T和类上声明的T一致</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 泛型类中声明了一个泛型方法，使用泛型E，泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">        <span class="comment">// 由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识</span></span><br><span class="line">        <span class="comment">// 别泛型方法中识别的泛型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span> </span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 泛型类中声明了一个泛型方法，使用泛型T，这个T是一种全新的类型，即泛型方法的T覆盖了泛型类的T</span></span><br><span class="line">        <span class="comment">// 编译器会报警告：The type parameter T is hiding the type T</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Generic().new Apple();</span><br><span class="line">        Person person = <span class="keyword">new</span> Generic().new Person();</span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = <span class="keyword">new</span> Generic().new GenerateTest&lt;Fruit&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// apple是Fruit的子类，所以这里可以，此时实际上是多态的性质</span></span><br><span class="line">        generateTest.show_1(apple);</span><br><span class="line">        <span class="comment">// 编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span></span><br><span class="line">        <span class="comment">// generateTest.show_1(person);</span></span><br><span class="line">        <span class="comment">// 使用这两个方法都可以成功</span></span><br><span class="line">        generateTest.show_2(apple);</span><br><span class="line">        generateTest.show_2(person);</span><br><span class="line">        <span class="comment">// 使用这两个方法也都可以成功</span></span><br><span class="line">        generateTest.show_3(apple);</span><br><span class="line">        generateTest.show_3(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h3><p>类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">     *    "StaticGenerator cannot be refrenced from static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>为什么要有这样的限定呢？其实是因为Java中的泛型是在编译期实现的，也就是说如果我们有一个泛型类，如<code>Stream&lt;T&gt;</code>，它里面有一个静态方法<code>of(T ... t)</code>，我们不能使用<code>Stream&lt;String&gt;.of(...)</code>，因为压根就没有<code>Stream&lt;String&gt;</code>这个类型，只能使用<code>Stream.of()</code>，这样一来我们就无法给参数T实例化一个类型。也就是说类中的静态属性和静态方法中的T没有办法被实例化的。</p><p><br></p><h3 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h3><p>泛型类和泛型方法都是定义了一个类或者方法的模板。能构造不同类型的属性或不同参数类型的方法。我们假设：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getNumber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shopping</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">payMoney</span><span class="params">(Goods&lt;Fruit&gt; fruitGoods)</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Shopping shopping = <span class="keyword">new</span> Shopping();</span><br><span class="line">        shopping.payMoney(<span class="keyword">new</span> Goods&lt;Apple&gt;());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>上面代码的33行会出错。本来我们的想法是计算应该付多少钱，所以使用了抽象类<code>Fruit</code>。但是虽然<code>Apple</code>是<code>Fruit</code>的子类，但是<code>Goods&lt;Apple&gt;</code>却不是<code>Goods&lt;Fruit&gt;</code>的子类，所以这里会报错。怎么解决呢？便是使用通配符<code>?</code>，将上面代码的30行换为<code>void payMoney(Goods&lt;?&gt; fruitGoods){ }</code>便不会报错。<br>通配符是一种类型，一种可以代表多种类型的类型。它和<code>T</code>不一样，<code>T</code>是为了声明此类有一个类型参数需要去实例化，而<code>?</code>是一种实例化<code>T</code>的类型。</p><h4 id="上下界通配符"><a href="#上下界通配符" class="headerlink" title="上下界通配符"></a>上下界通配符</h4><p>下面代码就是“上界通配符（Upper Bounds Wildcards）”：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Goods&lt;? extends Fruit&gt;</span><br></pre></td></tr></table></figure><p></p><p>上界通配符表示传入的只能是Fruit的子类及自己。<br>相对应的，“下界通配符（Lower Bounds Wildcards）”：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? <span class="keyword">super</span> Fruit&gt;</span><br></pre></td></tr></table></figure><p></p><p>下界通配符表示传入的只能是Fruit的父类及自己。</p><h4 id="通配符在实例T时的限制"><a href="#通配符在实例T时的限制" class="headerlink" title="通配符在实例T时的限制"></a>通配符在实例T时的限制</h4><p>假如我们有两个方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Goods&lt;? extends Fruit&gt; fruitGoods = <span class="keyword">new</span> Goods&lt;&gt;();</span><br><span class="line">        fruitGoods.set(<span class="keyword">new</span> Orange());<span class="comment">// 这段代码会出错</span></span><br><span class="line">        Fruit fruit = fruitGoods.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们分析一下，第7行代码中<code>? extends Fruit</code>替换了<code>T</code>，这个时候编译器知道<code>T</code>是<code>Fruit</code>或者其子类，但是它却不知道具体是哪一个，假如它编译器设置为了<code>Apple</code>，那么传入<code>Orange</code>对象在编译期是不会出错的，因为<code>Orange</code>是符合<code>? extends Fruit</code>的，但是我们知道<code>Apple</code>的引用根本无法引用<code>Orange</code>的对象，就会出错。所以编译器就拒绝传递它不确定的类型（null 除外，因为任何对象都能引用null）。<br>第9行不会出错，因为返回的类型是<code>Fruit</code>或者其子类，这样我们在接收的时候使用<code>Fruit</code>接收就行了。<br>这里有人会问，那为什么不会将<code>private T t</code>的<code>T</code>设置为<code>Fruit</code>呢，其实这是由于在第9行中的<code>Fruit</code>是我们认为确定的，对于编译器来说这是不可变得，而<code>private T t</code>不是我们能确定的，它是一个不确定的值，编译器为了防止出现我们刚才的问题拒绝传递不确定的值。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Goods</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T t;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T t)</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Goods&lt;? <span class="keyword">super</span> Fruit&gt; fruitGoods = <span class="keyword">new</span> Goods&lt;&gt;();</span><br><span class="line">        fruitGoods.set(<span class="keyword">new</span> Orange());</span><br><span class="line">        Object fruit = fruitGoods.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果使用了下界通配符，我们就可以传入<code>Orange</code>对象，因为<code>T</code>会被实例化为<code>Fruit</code>或其父类，而无论是<code>Fruit</code>还是其父类都能接收<code>Orange</code>对象，但是不能接受<code>Fruit</code>的父类。<br>而在返回的时候只能用<code>Object</code>接收，因为在<code>super</code>定义的类型区间内只有<code>Object</code>可以接收所有的类型。</p><p><br></p><h3 id="泛型的缺陷"><a href="#泛型的缺陷" class="headerlink" title="泛型的缺陷"></a>泛型的缺陷</h3><h4 id="运行时类型查询只适用于原始类型"><a href="#运行时类型查询只适用于原始类型" class="headerlink" title="运行时类型查询只适用于原始类型"></a>运行时类型查询只适用于原始类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(a <span class="keyword">instanceof</span> Pair&lt;String&gt;); <span class="comment">// error</span></span><br><span class="line">Pair&lt;String&gt; p = (Pair&lt;String&gt;) a;<span class="comment">// error</span></span><br><span class="line">ArrayList&lt;String&gt;.class == ArrayList&lt;Integer&gt; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h4 id="不能创建一个确切的泛型类型的数组"><a href="#不能创建一个确切的泛型类型的数组" class="headerlink" title="不能创建一个确切的泛型类型的数组"></a><strong>不能创建一个确切的泛型类型的数组</strong></h4><p>也就是说下面的这个例子是不可以的：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p></p><p>而使用通配符创建泛型数组是可以的，如下面这个例子：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p></p><p>这样也是可以的：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><p></p><p>下面使用<a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html">Sun</a><a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html">的一篇文档</a>的一个例子来说明这个问题：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.    </span></span><br><span class="line">Object o = lsa;</span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check    </span></span><br><span class="line">String s = lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error: ClassCastException.</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>下面采用通配符的方式是被允许的:<strong>数组的类型不可以是类型变量，除非是采用通配符的方式</strong>，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.    </span></span><br><span class="line">Object o = lsa;</span><br><span class="line">Object[] oa = (Object[]) o;</span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));</span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.</span></span><br><span class="line">Integer i = (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><p></p><h4 id="可变参参数警告"><a href="#可变参参数警告" class="headerlink" title="可变参参数警告"></a>可变参参数警告</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(Collection&lt;T&gt; coll, T... ts)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (T : ts)</span><br><span class="line">coll. add(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该记得，实际上参数ts是一个数组，包含提供的所有实参，现在考虑一下调用：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;Pair&lt;String&gt;&gt; table ...;</span><br><span class="line">Pair&lt;String&gt; pairl = ...;</span><br><span class="line">Pair&lt;String&gt; pair2 = ...;</span><br><span class="line">addAll(table, pairl, pair2);</span><br></pre></td></tr></table></figure><p></p><p>为了调用这个方法，Java虚拟机必须建立一个<code>Pair &lt;String&gt;</code>数组,这就违反了前面的规则。不过，对于这种情况,规则有所放松，你只会得到一个警告，而不是错误。可以采用两种方法来抑制这个警告。一种方法是为包含addA1调用的方法增加注解<code>@Suppress Warnings(&quot;unchecked&quot;)</code>或者在Java SE7中，还可以用<code>@Safe Varargs</code>直接标注<code>addAll</code>方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SafeVarargs</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAl1</span> <span class="params">(Collection&lt;T&gt; coll, T... ts)</span></span></span><br></pre></td></tr></table></figure><p></p><p>现在就可以提供泛型类型来调用这个方法了。对于只需要读取参数数组元素的所有方法，都可以使用这个注解。</p><h4 id="不能实例化类型变量"><a href="#不能实例化类型变量" class="headerlink" title="不能实例化类型变量"></a>不能实例化类型变量</h4><p>不能使用像<code>new T(...)</code>，<code>new T[...]</code>或<code>T.class</code>这样的表达式中的类型变量。例如，下面的<code>Pair&lt;T&gt;</code>构造器就是非法的：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Pair &#123; first= <span class="keyword">new</span> T(); second = <span class="keyword">new</span> T();&#125;<span class="comment">// Error</span></span><br></pre></td></tr></table></figure><p></p><h5 id="反射解决"><a href="#反射解决" class="headerlink" title="反射解决"></a>反射解决</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T first;</span><br><span class="line">    <span class="keyword">public</span> T second;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T first, T second)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.first = first;</span><br><span class="line">        <span class="keyword">this</span>.second = second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(Class&lt;T&gt; cla)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;(cla.newInstance(), cla.newInstance());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不能实例化类型数组"><a href="#不能实例化类型数组" class="headerlink" title="不能实例化类型数组"></a>不能实例化类型数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//    T [] ts = new T[100];     error</span></span><br></pre></td></tr></table></figure><h5 id="反射解决-1"><a href="#反射解决-1" class="headerlink" title="反射解决"></a>反射解决</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pair</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    T[] ts;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pair</span><span class="params">(T[] ts)</span> </span>&#123;<span class="keyword">this</span>.ts = ts;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Pair&lt;T&gt; <span class="title">makePair</span><span class="params">(T... a)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Pair&lt;&gt;((T[]) Array.newInstance(a.getClass().getComponentType(), <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pair&lt;String&gt; p = Pair.makePair(value -&gt; <span class="keyword">new</span> String[value]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组作为类的私有实例域"><a href="#数组作为类的私有实例域" class="headerlink" title="数组作为类的私有实例域"></a>数组作为类的私有实例域</h4><p>如果数组仅仅作为一个类的私有实例域，就可以将这个数组声明为<code>Object []</code>，并且在取元素时进行类型转换。 例如ArrayList类这样实现：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="不能抛出或捕获泛型类的实例"><a href="#不能抛出或捕获泛型类的实例" class="headerlink" title="不能抛出或捕获泛型类的实例"></a>不能抛出或捕获泛型类的实例</h4><p>既不能抛出也不能捕获泛型类对象。 实际上，甚至泛型类扩展<code>Throwable</code>都是不合法的。例如，以下定义就不能正常编译：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Problem</span> &lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Exception</span> </span>&#123; <span class="comment">/*...*/</span> &#125; <span class="comment">// Error can't extend Throwable</span></span><br></pre></td></tr></table></figure><p></p><p>catch 子句中不能使用类型变量。 例如，以下方法将不能编译：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Class&lt;T&gt; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// do work</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (T e) &#123; <span class="comment">// Error can't catch type variable</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>不过，在异常规范中使用类型变量是允许的。以下方法是合法的：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(T t)</span> <span class="keyword">throws</span> T </span>&#123; <span class="comment">// OK</span></span><br><span class="line"><span class="keyword">try</span> &#123; </span><br><span class="line"><span class="comment">// do work</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable realCause) &#123;</span><br><span class="line"><span class="keyword">throw</span> t ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="可以消除对受查异常的检查"><a href="#可以消除对受查异常的检查" class="headerlink" title="可以消除对受查异常的检查"></a>可以消除对受查异常的检查</h4><p>Java 异常处理的一个基本原则是，必须为所有受查异常提供一个处理器。不过可以利用泛型消除这个限制。关键在于以下方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWamings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> (T) e ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>假设这个方法包含在类<code>Block</code>中 ， 如果调用<code>Block.&lt;RuntimeException&gt; throwAs(t);</code>，编译器就会认为t是一个非受查异常。以下代码会把所有异常都转换为编译器所认为的非受查异常：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// do work</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">Block.&lt;RuntimeException&gt; throwAs(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>下面把这个代码包装在一个抽象类中。用户可以覆盖body方法来提供一个具体的动作。调用toThread时，会得到<code>Thread</code>类的一个对象，它的<code>run</code>方法不会介意受查异常。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Block</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Thread <span class="title">toThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    body();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    Block.&lt;RuntimeException&gt; throwAs(t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@SuppressWamings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Throwable&gt; <span class="function"><span class="keyword">void</span> <span class="title">throwAs</span><span class="params">(Throwable e)</span> <span class="keyword">throws</span> T </span>&#123;</span><br><span class="line"><span class="keyword">throw</span> (T) e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>例如，以下程序运行了一个线程，它会拋出一个受查异常。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">new</span> Block() &#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">body</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Scanner in = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> File(<span class="string">"ququx"</span>), <span class="string">"UTF-8"</span>);</span><br><span class="line"><span class="keyword">while</span>(in.hasNext())</span><br><span class="line">System.out.println(in.next());</span><br><span class="line">&#125;</span><br><span class="line">&#125;.toThread().start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行这个程序时，会得到一个栈轨迹，其中包含一个<code>FileNotFoundException</code>。这有什么意义呢？正常情况下，你必须捕获线程run方法中的所有受查异常 ， 把它们“包装”到非受查异常中，因为<code>run</code>方法声明为不抛出任何受查异常。<br>不过在这里并没有做这种“包装”。我们只是抛出异常，并“哄骗”编译器，让它认为这不是一个受查异常。通过使用泛型类、 擦除和<code>@SuppressWamings</code>注解，就能消除 Java 类型系统的部分基本限制。</p><p><br></p><h3 id="lt-T-extends-Comparable-lt-super-T-gt-gt"><a href="#lt-T-extends-Comparable-lt-super-T-gt-gt" class="headerlink" title="&lt;T extends Comparable&lt;? super T&gt;&gt;"></a>&lt;T extends Comparable&lt;? super T&gt;&gt;</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="comment">//第一种声明：简单，灵活性低</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">mySort1</span><span class="params">(List&lt;T&gt; list)</span></span>&#123;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//第二种声明：复杂，灵活性高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt; <span class="function"><span class="keyword">void</span> <span class="title">mySort2</span><span class="params">(List&lt;T&gt; list)</span> </span>&#123;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//主函数中将分别创建Animal和Dog两个序列，然后调用排序方法对其进行测试</span></span><br><span class="line">　　  <span class="comment">//main函数中具体的两个版本代码将在下面具体展示</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Animal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Animal</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 使用年龄与另一实例比较大小</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Animal other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - other.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dog</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对mySort1()进行测试，main方法代码如下所示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Animal List</span></span><br><span class="line">List&lt;Animal&gt; animals = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line">animals.add(<span class="keyword">new</span> Animal(<span class="number">25</span>));</span><br><span class="line">animals.add(<span class="keyword">new</span> Dog(<span class="number">35</span>));</span><br><span class="line"><span class="comment">// 创建一个 Dog List</span></span><br><span class="line">List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line">dogs.add(<span class="keyword">new</span> Dog(<span class="number">5</span>));</span><br><span class="line">dogs.add(<span class="keyword">new</span> Dog(<span class="number">18</span>));</span><br><span class="line"><span class="comment">// 测试 mySort1() 方法</span></span><br><span class="line">mySort1(animals);</span><br><span class="line">mySort1(dogs);<span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>结果编译出错，报错信息为：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">The method <span class="title">mySort1</span><span class="params">(List&lt;T&gt;)</span> in the type TypeParameterTest is not applicable <span class="keyword">for</span> the <span class="title">arguments</span> <span class="params">(List&lt;Dog&gt;)</span></span></span><br></pre></td></tr></table></figure><p></p><p>如果传入的是<code>List&lt;Animal&gt;</code>程序将正常执行，因为<code>Animal</code>实现了接口<code>Comparable&lt;Animal&gt;</code>。但是，如果传入的参数是<code>List&lt;Dog&gt;</code>程序将报错，因为<code>Dog</code>类中没有实现接口<code>Comparable&lt;Dog&gt;</code>，它只从<code>Animal</code>继承了一个<code>Comparable&lt;Animal&gt;</code>接口。</p><p><strong>对mySort12()进行测试，main方法代码如下所示</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个 Animal List</span></span><br><span class="line">List&lt;Animal&gt; animals = <span class="keyword">new</span> ArrayList&lt;Animal&gt;();</span><br><span class="line">animals.add(<span class="keyword">new</span> Animal(<span class="number">25</span>));</span><br><span class="line">animals.add(<span class="keyword">new</span> Dog(<span class="number">35</span>));</span><br><span class="line"><span class="comment">// 创建一个 Dog List</span></span><br><span class="line">List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;Dog&gt;();</span><br><span class="line">dogs.add(<span class="keyword">new</span> Dog(<span class="number">5</span>));</span><br><span class="line">dogs.add(<span class="keyword">new</span> Dog(<span class="number">18</span>));</span><br><span class="line"><span class="comment">// 测试  mySort2() 方法</span></span><br><span class="line">mySort2(animals);</span><br><span class="line">mySort2(dogs);</span><br></pre></td></tr></table></figure><p>这时候我们发现该程序可以正常运行。它不但能够接受<code>Animal implements Comparable&lt;Animal&gt;</code>这样的参数，也可以接收<code>Dog implements Comparable&lt;Animal&gt;</code>这样的参数。</p><ul><li>在添加animals时，T是Animal，Comparable的泛型是Animal，<code>Animal super Animal</code>成立。</li><li>在添加dogs时，T是Dog，Comparable的泛型是Animal，<code>Animal super Dog</code>成立。</li></ul><p><br></p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="ThreadLocal使用"><a href="#ThreadLocal使用" class="headerlink" title="ThreadLocal使用"></a>ThreadLocal使用</h3><p>ThreadLocal是一个线程局部变量，我们都知道全局变量和局部变量的区别，拿Java举例就是定义在类中的是全局的变量，各个方法中都能访问得到（静态方法不能获得实例属性），而局部变量定义在方法中，只能在方法内访问。那线程局部变量（ThreadLocal）就是每个线程都会有一个局部变量，独立于变量的初始化副本，而各个副本是通过线程唯一标识相关联的。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> UniqueThreadIdGenerator t;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TaskThread</span><span class="params">(String threadName, UniqueThreadIdGenerator t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.setName(threadName);</span><br><span class="line"><span class="keyword">this</span>.t = t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">int</span> value = t.getUniqueId();</span><br><span class="line">System.out.println(<span class="string">"thread[ "</span> + Thread.currentThread().getName() + </span><br><span class="line">                <span class="string">" ] --&gt; uniqueId[ "</span> + value + <span class="string">" ]"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">UniqueThreadIdGenerator uniqueThreadId = <span class="keyword">new</span> UniqueThreadIdGenerator();</span><br><span class="line"><span class="comment">// 为每个线程生成一个唯一的局部标识</span></span><br><span class="line">TaskThread t1 = <span class="keyword">new</span> TaskThread(<span class="string">"custom-thread-1"</span>, uniqueThreadId);</span><br><span class="line">TaskThread t2 = <span class="keyword">new</span> TaskThread(<span class="string">"custom-thread-2"</span>, uniqueThreadId);</span><br><span class="line">TaskThread t3 = <span class="keyword">new</span> TaskThread(<span class="string">"custom-thread-3"</span>, uniqueThreadId);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br><span class="line">t3.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniqueThreadIdGenerator</span> </span>&#123;</span><br><span class="line"><span class="comment">// 线程局部整型变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; uniqueNum = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 变量值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUniqueId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">uniqueNum.set(uniqueNum.get() + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> uniqueNum.get();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// thread[ custom-thread-2 ] --&gt; uniqueId[ 1 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-1 ] --&gt; uniqueId[ 1 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-3 ] --&gt; uniqueId[ 1 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-1 ] --&gt; uniqueId[ 2 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-2 ] --&gt; uniqueId[ 2 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-1 ] --&gt; uniqueId[ 3 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-3 ] --&gt; uniqueId[ 2 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-1 ] --&gt; uniqueId[ 4 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-2 ] --&gt; uniqueId[ 3 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-3 ] --&gt; uniqueId[ 3 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-2 ] --&gt; uniqueId[ 4 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-3 ] --&gt; uniqueId[ 4 ]</span></span><br><span class="line"><span class="comment">// 每个线程之间的uniqueId是互不干扰的</span></span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="ThreadLocal源码分析"></a>ThreadLocal源码分析</h3><p>每个线程内部有一个<code>ThreadLocalMap</code>，<code>get()</code>的时候就是获得当前线程的<code>ThreadLocalMap</code>，并且将当前<code>ThreadLocal</code>对象传入<code>map.getEntry(this);</code></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/be8d7461-5ec5-41c7-be7f-4b7c30f454a1"></div><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 拿到每个线程内部的ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// this指的是这个ThreadLocal对象，每个ThreadLocalMap可以有多个ThreadLocal对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 默认初始化为null</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ThreadLocalMap.java</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从当前线程的ThreadLocalMap中删除当前的ThreadLocal</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/ad6080da-3850-463c-94a3-00f13be71c3d"></div><p>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象，这点被Entry的构造方法已经限定死了。<br>Entry继承自WeakReference（弱引用，生命周期只能存活到下次GC前），但只有Key是弱引用类型的，Value并非弱引用。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entry.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h4 id="Hash冲突怎么解决"><a href="#Hash冲突怎么解决" class="headerlink" title="Hash冲突怎么解决"></a>Hash冲突怎么解决</h4><p>和HashMap的最大的不同在于，ThreadLocalMap结构非常简单，没有next引用，也就是说ThreadLocalMap中解决Hash冲突的方式并非链表的方式，而是采用线性探测的方式，所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。<br>ThreadLocalMap解决Hash冲突的方式就是简单的步长加1或减1，寻找下一个相邻的位置。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increment i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decrement i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>显然ThreadLocalMap采用线性探测的方式解决Hash冲突的效率很低，如果有大量不同的ThreadLocal对象放入map中时发送冲突，或者发生二次冲突，则效率很低。<strong>所以这里引出的良好建议是：每个线程只存一个变量，需要多个变量 这个时候需要把这些对象封装成变量对象</strong>。</p><p><br></p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>ThreadLocal在ThreadLocalMap中是以一个弱引用身份被Entry中的Key引用的，因此如果ThreadLocal没有外部强引用来引用它，那么ThreadLocal会在下次JVM垃圾收集时被回收。这个时候就会出现Entry中Key已经被回收，出现一个null Key的情况，外部读取ThreadLocalMap中的元素是无法通过null Key来找到Value的。因此如果当前线程的生命周期很长（比如线程池中的线程），一直存在，那么其内部的ThreadLocalMap对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：Thread –&gt; ThreadLocalMap–&gt;Entry–&gt;Value，这条强引用链会导致Entry不会回收，Value也不会回收，但Entry中的Key却已经被回收的情况，造成内存泄漏。<br>但是JVM团队已经考虑到这样的情况，并做了一些措施来保证ThreadLocal尽量不会内存泄漏：在ThreadLocal的get()、set()、remove()方法调用的时候会清除掉线程ThreadLocalMap中所有Entry中Key为null的Value，并将整个Entry设置为null，利于下次内存回收。<br>ThreadLocal的get()方法在调用map.getEntry(this)时，内部会判断key是否为null<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);<span class="comment">// 清除空结点的方法</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">// expunge entry at staleSlot（意思是，删除value，设置为null便于下次回收）</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    <span class="comment">// 将当前Entry删除后，会继续循环往下检查是否有key为null的节点，如果有则一并删除，防止内存泄漏。</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>但这样也并不能保证ThreadLocal不会发生内存泄漏，例如：</p><ul><li>使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏。</li><li>分配使用了ThreadLocal又不再调用get()、set()、remove()方法，那么就会导致内存泄漏</li></ul><h4 id="为什么使用弱引用？"><a href="#为什么使用弱引用？" class="headerlink" title="为什么使用弱引用？"></a>为什么使用弱引用？</h4><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/5ea4a817-8e0f-4ee0-9602-4fdd20fac2bf"></div><p>有一些文章说内存泄漏是因为key的弱引用，但是实际上key使用弱引用不仅不是内存泄漏的原因，反而可以减少内存泄漏的发生。官方文档的说法：</p><blockquote><p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了处理非常大和生命周期非常长的线程，哈希表使用弱引用作为 key。<br>下面我们分两种情况讨论：</p><ul><li>key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</li><li>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set，get，remove的时候会被清除。<br>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set，get，remove的时候会被清除。<br>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key的value就会导致内存泄漏，而不是因为弱引用。<br>所以：<strong>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</strong>尤其是在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</li></ul></blockquote><p><br></p><h2 id="匿名内部类不能修改外部变量"><a href="#匿名内部类不能修改外部变量" class="headerlink" title="匿名内部类不能修改外部变量"></a>匿名内部类不能修改外部变量</h2><p>想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outer <span class="title">test</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Outer() &#123;</span><br><span class="line">            <span class="keyword">int</span> z = y;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/2ab13184-1697-4430-a45a-2ca7b1044fff"></div><p>从反编译的结果来看，我们会创建一个内部类，并且执行构造方法。我们再反编译一个<code>Outer$1.class</code></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/448f0e22-4474-438e-a487-d5ac9b613a12"></div><p>从构造方法我们可以看出了这个构造方法有两个参数，一个是外部类的引用，一个是一个int。</p><div align="center"><img width="40%" src="http://blogfileqiniu.isjinhao.site/981c3249-77bf-402a-aade-cc5c3814ed9a"></div><p>从字段结果中可以看到，有三个字段：z、final y和Outer。也就是说我们虽然没有把y声明为final的，在传递到内部类中的时候也会是final的，这时候就知道为什么在内部类中不能修改y了，因为内部类中的y实际上是外部类数据的一份拷贝，这份拷贝在传递到内部类后会变成一个final的值。而且即使不是final的，我们把内部类的值进行修改实际上对外部类也没有任何影响。</p><p><br></p><h2 id="深入分析JDK动态代理"><a href="#深入分析JDK动态代理" class="headerlink" title="深入分析JDK动态代理"></a>深入分析JDK动态代理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"request is called"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicSubject</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object object;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicSubject</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.object = object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before calling: "</span>+ method);</span><br><span class="line">        method.invoke(<span class="keyword">this</span>.object, args);</span><br><span class="line">        System.out.println(<span class="string">"after calling: "</span> + method);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RealSubject rs = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        InvocationHandler ds = <span class="keyword">new</span> DynamicSubject(rs);</span><br><span class="line">        Class&lt;? extends RealSubject&gt; aClass = rs.getClass();</span><br><span class="line">        Subject subject = (Subject)Proxy.newProxyInstance(</span><br><span class="line">            aClass.getClassLoader(), aClass.getInterfaces(), ds);</span><br><span class="line">        subject.request();</span><br><span class="line">        System.out.println(subject.getClass());</span><br><span class="line">        System.out.println(subject.getClass().getSuperclass());</span><br><span class="line">        System.out.println(subject.getClass().getSuperclass().getSuperclass());</span><br><span class="line">        System.out.println(Arrays.toString(subject.getClass().getInterfaces()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    before calling: public abstract void two.jvm.bytecodes.Subject.request()</span></span><br><span class="line"><span class="comment">    request is called</span></span><br><span class="line"><span class="comment">    after calling: public abstract void two.jvm.bytecodes.Subject.request()</span></span><br><span class="line"><span class="comment">    class com.sun.proxy.$Proxy0</span></span><br><span class="line"><span class="comment">    class java.lang.reflect.Proxy</span></span><br><span class="line"><span class="comment">    class java.lang.Object</span></span><br><span class="line"><span class="comment">    [interface two.jvm.bytecodes.Subject]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>从上面的输我们可以看到<code>subject</code>的类型是运行期动态生成的字节码对象。<br>返回字节码对象的方法是Client的第7行，所以我们进入此方法。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">InvocationHandler h)</span><span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">    <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在此方法中，我们会发现，获得生成Class对象的是滴14行。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                       Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="comment">// 限制接口数量不能多于65535，因为在字节码中使用两个字节表示接口数量</span></span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">    <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">    <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>进入<code>WeakCache.get()</code>方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(parameter);</span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">    Object cacheKey = CacheKey.valueOf(key, refQueue);</span><br><span class="line">    <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span><br><span class="line">    ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">    <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap</span><br><span class="line">            = map.putIfAbsent(cacheKey,</span><br><span class="line">                              valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">        <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">            valuesMap = oldValuesMap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span><br><span class="line">    <span class="comment">// subKey from valuesMap</span></span><br><span class="line">    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">    Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">    Factory factory = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span><br><span class="line">            V value = supplier.get();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else no supplier in cache</span></span><br><span class="line">        <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span><br><span class="line">        <span class="comment">// or a Factory that wasn't successful in installing the CacheValue)</span></span><br><span class="line">        <span class="comment">// lazily construct a Factory</span></span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// successfully installed Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else retry with winning supplier</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                <span class="comment">// successfully replaced</span></span><br><span class="line">                <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span><br><span class="line">                <span class="comment">// with our Factory</span></span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// retry with current supplier</span></span><br><span class="line">                supplier = valuesMap.get(subKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这个方法中，我们可以发现最终返回<code>value</code>的是第30行。但<code>value</code>的值是通过函数式接口<code>Supplier</code>获得的，而<code>supplier</code>的赋值是在第46行完成的而<code>factory</code>对象是在第39行被构建的。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;K, P, V&gt; valueFactory;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">WeakCache</span><span class="params">(BiFunction&lt;K, P, ?&gt; subKeyFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                 BiFunction&lt;K, P, V&gt; valueFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subKeyFactory = Objects.requireNonNull(subKeyFactory);</span><br><span class="line">    <span class="keyword">this</span>.valueFactory = Objects.requireNonNull(valueFactory);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Factory是WeakCache的一个内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> P parameter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object subKey;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap;</span><br><span class="line">    Factory(K key, P parameter, Object subKey,</span><br><span class="line">            ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) &#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.parameter = parameter;</span><br><span class="line">        <span class="keyword">this</span>.subKey = subKey;</span><br><span class="line">        <span class="keyword">this</span>.valuesMap = valuesMap;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// serialize access</span></span><br><span class="line">        <span class="comment">// re-check</span></span><br><span class="line">        Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="comment">// something changed while we were waiting:</span></span><br><span class="line">            <span class="comment">// might be that we were replaced by a CacheValue</span></span><br><span class="line">            <span class="comment">// or were removed because of failure -&gt;</span></span><br><span class="line">            <span class="comment">// return null to signal WeakCache.get() to retry</span></span><br><span class="line">            <span class="comment">// the loop</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else still us (supplier == this)</span></span><br><span class="line">        <span class="comment">// create new value</span></span><br><span class="line">        V value = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// remove us on failure</span></span><br><span class="line">                valuesMap.remove(subKey, <span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// the only path to reach here is with non-null value</span></span><br><span class="line">        <span class="keyword">assert</span> value != <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// wrap value with CacheValue (WeakReference)</span></span><br><span class="line">        CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> CacheValue&lt;&gt;(value);</span><br><span class="line">        <span class="comment">// put into reverseMap</span></span><br><span class="line">        reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line">        <span class="comment">// try replacing us with CacheValue (this should always succeed)</span></span><br><span class="line">        <span class="keyword">if</span> (!valuesMap.replace(subKey, <span class="keyword">this</span>, cacheValue)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// successfully replaced us with new CacheValue -&gt; return the value</span></span><br><span class="line">        <span class="comment">// wrapped by it</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>而<code>Factory</code>是<code>Supplier</code>的一个实现类，对于Factory的<code>key</code>和<code>parameter</code>，我们传入的是<code>ClassLoader loader</code>和<code>Class&lt;?&gt;... interfaces</code>。在<code>get()</code>方法中给<code>value</code>赋值的是第33行的<code>apply()</code>方法，而<code>valueFactory</code>是一个函数式接口<code>BiFunction</code>，此接口传入两个参数，获得一个结果。现在我们传入的就是<code>loader</code>和<code>interfaces</code>，而<code>apply</code>的具体实现是在构建<code>WeakCache</code>传入的。所以我们再回到<code>Proxy</code>类。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">    proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A factory function that generates, defines and returns the proxy class given</span></span><br><span class="line"><span class="comment"> * the ClassLoader and array of interfaces.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">    implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123;</span><br><span class="line">    <span class="comment">// prefix for all proxy class names</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line">    <span class="comment">// next number to use for generation of unique proxy class names</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that the class loader resolves the name of this</span></span><br><span class="line"><span class="comment">             * interface to the same Class object.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that the Class object actually represents an</span></span><br><span class="line"><span class="comment">             * interface.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that this interface is not a duplicate.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Record the package of a non-public proxy interface so that the</span></span><br><span class="line"><span class="comment">         * proxy class will be defined in the same package.  Verify that</span></span><br><span class="line"><span class="comment">         * all non-public proxy interfaces are in the same package.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                String name = intf.getName();</span><br><span class="line">                <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">            proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                                proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">             * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">             * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">             * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">             * exceeded).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>再第90行是真正的生成字节码对象的字节数组的地方。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> saveGeneratedFiles = (Boolean)AccessController.doPrivileged(<span class="keyword">new</span> GetBooleanAction(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>));</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String var0, Class&lt;?&gt;[] var1, <span class="keyword">int</span> var2) &#123;</span><br><span class="line">    ProxyGenerator var3 = <span class="keyword">new</span> ProxyGenerator(var0, var1, var2);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] var4 = var3.generateClassFile();</span><br><span class="line">    <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">        AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> var1 = var0.lastIndexOf(<span class="number">46</span>);</span><br><span class="line">                    Path var2;</span><br><span class="line">                    <span class="keyword">if</span> (var1 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        Path var3 = Paths.get(var0.substring(<span class="number">0</span>, var1).replace(<span class="string">'.'</span>, File.separatorChar));</span><br><span class="line">                        Files.createDirectories(var3);</span><br><span class="line">                        var2 = var3.resolve(var0.substring(var1 + <span class="number">1</span>, var0.length()) + <span class="string">".class"</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        var2 = Paths.get(var0 + <span class="string">".class"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    Files.write(var2, var4, <span class="keyword">new</span> OpenOption[<span class="number">0</span>]);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException var4x) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"I/O exception saving generated file: "</span> + var4x);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>可以看见在第6行有个开关，这个开关为<code>true</code>会将字节数组写入文件中。所以我们<code>Client</code>的<code>main</code>方法中加入：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.getProperties().put(<span class="string">"sun.misc.ProxyGenerator.saveGeneratedFiles"</span>, <span class="string">"true"</span>);</span><br></pre></td></tr></table></figure><p></p><p>这样在根目录的<code>com/sun/proxy</code>文件下就会生成一个class文件，在IDEA中双击点开：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m3 = Class.forName(<span class="string">"two.jvm.bytecodes.Subject"</span>).getMethod(<span class="string">"request"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我们会发现这个类继承了<code>Proxy</code>类，实现了<code>Subject</code>。然后从第33行便可以发现代理对象的<code>request</code>执行的便是<code>InvocationHandler</code>的<code>invoke</code>方法。传入的方法是<code>two.jvm.bytecodes.Subject</code>类中的<code>request</code>方法，也就是最终执行到了<code>DynamicSubject</code>中的invoke方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"before calling: "</span>+ method);</span><br><span class="line">    method.invoke(<span class="keyword">this</span>.object, args);</span><br><span class="line">    System.out.println(<span class="string">"after calling: "</span> + method);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:00 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛型&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>01.02-JavaSE-基础-2</title>
    <link href="https://isjinhao.github.io/posts/17734.html/"/>
    <id>https://isjinhao.github.io/posts/17734.html/</id>
    <published>2019-12-24T12:30:05.000Z</published>
    <updated>2019-12-30T13:20:35.618Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:00 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123; <span class="keyword">this</span>.radius = radius; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">// 内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"drawshape"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> test = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">// 内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> test = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">// 外部类的private成员</span></span><br><span class="line">            System.out.println(count);   <span class="comment">// 外部类的静态成员</span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.test);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Draw draw = <span class="keyword">new</span> Outer(<span class="number">20</span>).new Draw();</span><br><span class="line">    draw.drawSahpe();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.this.成员变量</span><br><span class="line">外部类.this.成员方法</span><br></pre></td></tr></table></figure><p></p><p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        getDrawInstance().drawSahpe();   <span class="comment">// 必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> Draw <span class="title">getDrawInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Draw();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">// 内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">// 外部类的private成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 第一种方式：</span></span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        Outter.Inner inner = outter.new Inner();  <span class="comment">// 必须通过Outter对象来创建</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 第二种方式：</span></span><br><span class="line">        Outter.Inner inner1 = outter.getInnerInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="keyword">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如上面的例子：</p><ul><li>private：则只能在外部类的内部访问；</li><li>public：则任何地方都能访问；</li><li>protected：只能在同一个包下或者继承外部类的情况下访问；</li><li>默认访问权限：则只能在同一个包下访问。<br>这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</li></ul><p><br></p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">// 局部内部类</span></span><br><span class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。匿名内部类的语法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ClassName()&#123;</span><br><span class="line"><span class="comment">// 匿名内部类的body</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>下面这段代码是一段线程代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(Thread.currentThread());</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="string">"匿名内部类"</span>)&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"匿名内部类的body"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>匿名内部类是<strong>唯一一种没有构造器的类</strong>。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$数字.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。但是匿名内部类也是可以书写其他方法的，因为本质上他就是继承或实现。</p><p><br></p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">// 静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。</span></span><br><span class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="枚举和switch"><a href="#枚举和switch" class="headerlink" title="枚举和switch"></a>枚举和switch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(TestEnum.FRI.getClass()); <span class="comment">// class TestEnum</span></span><br><span class="line">System.out.println(TestEnum.FRI);<span class="comment">// FRI</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">enum</span> TestEnum &#123;</span><br><span class="line"> MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>switch中可以跟的类型有byte、short、char、int、String、枚举。<strong>没有long</strong>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"200"</span>;</span><br><span class="line"><span class="keyword">switch</span> (str) &#123;</span><br><span class="line"><span class="keyword">default</span>:<span class="comment">// default 只能定义一次</span></span><br><span class="line">System.out.println(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="string">"100"</span>:</span><br><span class="line">System.out.println(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">case</span> <span class="string">"1000"</span>:</span><br><span class="line">System.out.println(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//str = 200;</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//100</span></span><br><span class="line"><span class="comment">//1000</span></span><br><span class="line"><span class="comment">//1000</span></span><br><span class="line"><span class="comment">//因为不能匹配100或1000，所以从defalut口进入。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//str = 100;</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//1000</span></span><br><span class="line"><span class="comment">//1000</span></span><br><span class="line"><span class="comment">//因为可以匹配100，从第二个口进入。</span></span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="随机数和round"><a href="#随机数和round" class="headerlink" title="随机数和round"></a>随机数和round</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得随机数：greater than or equal to 0.0 and less than 1.0</span></span><br><span class="line"><span class="keyword">double</span> iRandom = Math.random();</span><br><span class="line">System.out.println(iRandom);</span><br><span class="line"><span class="comment">// 获得区间在[0, n)之间的随机整数</span></span><br><span class="line">Random random2 = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> nextInt = random2.nextInt(<span class="number">10</span>);</span><br><span class="line">System.out.println(nextInt);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负数：加0.5之后向小的取整</span></span><br><span class="line">System.out.println(Math.round(-<span class="number">11.6</span>));</span><br><span class="line">System.out.println(Math.round(-<span class="number">11.5</span>));</span><br><span class="line"><span class="comment">// 正数：加0.5之后向大的取整</span></span><br><span class="line">System.out.println(Math.round(<span class="number">11.6</span>));</span><br><span class="line">System.out.println(Math.round(<span class="number">11.5</span>));</span><br></pre></td></tr></table></figure><p><br></p><h2 id="String、StringBuilder-amp-StringBuffer"><a href="#String、StringBuilder-amp-StringBuffer" class="headerlink" title="String、StringBuilder &amp; StringBuffer"></a>String、StringBuilder &amp; StringBuffer</h2><h3 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a><strong>可变性</strong></h3><p>简单的来说：String类中使用final关键字修饰字符数组来保存字符串，<code>private　final　char　value[]</code>，所以String对象是不可变的。而<code>StringBuilder</code>与<code>StringBuffer</code>都继承自<code>AbstractStringBuilder</code>类，在 <code>AbstractStringBuilder</code>中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用final关键字修饰，所以这两种对象都是可变的。<br><code>StringBuilde</code>r与<code>StringBuffer</code>的构造方法都是调用父类构造方法也就是<code>AbstractStringBuilder</code>实现的。<br><code>AbstractStringBuilder.java</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p><code>String</code>中的对象是不可变的，也就可以理解为常量，线程安全。<code>AbstractStringBuilder</code>是<code>StringBuilder</code>与<code>StringBuffer</code>的公共父类，定义了一些字符串的基本操作，如<code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code>等公共方法。<code>StringBuffer</code>对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。<code>StringBuilder</code>并没有对方法进行加同步锁，所以是非线程安全的。</p><p><br></p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a><strong>性能</strong></h3><p>每次对<code>String</code>类型进行改变的时候，都会生成一个新的<code>String</code>对象，然后将指针指向新的<code>String</code>对象。<code>StringBuffer</code>每次都会对<code>StringBuffer</code>对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用<code>StringBuilder</code>相比使用<code>StringBuffer</code>仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p><p><br></p><h3 id="对于三者使用的总结："><a href="#对于三者使用的总结：" class="headerlink" title="对于三者使用的总结："></a><strong>对于三者使用的总结：</strong></h3><ol><li>操作少量的数据: 适用String</li><li>单线程操作字符串缓冲区下操作大量数据: 适用<code>StringBuilder</code></li><li>多线程操作字符串缓冲区下操作大量数据: 适用<code>StringBuffer</code><br><code>Java</code>中字符串相加，编译的时候会创建<code>StringBuilder</code>类，然后利用<code>StringBuilder</code>的<code>append()</code>方法相加。所以不能在循环里使用<code>+</code>，需要在循环外面使用创建<code>StringBuilder</code>的对象，在循环内进行<code>append()</code>操作。</li></ol><p><br></p><h2 id="日期类"><a href="#日期类" class="headerlink" title="日期类"></a>日期类</h2><h3 id="LocalDate"><a href="#LocalDate" class="headerlink" title="LocalDate"></a>LocalDate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前日期</span></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">"Current Date="</span> + today);</span><br><span class="line"><span class="comment">// 根据年、月、日创建日期</span></span><br><span class="line">LocalDate firstDay_2014 = LocalDate.of(<span class="number">2014</span>, Month.JANUARY, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"Specific Date="</span> + firstDay_2014);</span><br><span class="line"><span class="comment">// 不合法的参数会报 java.time.DateTimeException</span></span><br><span class="line"><span class="comment">// LocalDate feb29_2014 = LocalDate.of(2014, Month.FEBRUARY, 29);</span></span><br><span class="line"><span class="comment">// Current date in "Asia/Kolkata", you can get it from ZoneId javadoc</span></span><br><span class="line">LocalDate todayKolkata = LocalDate.now(ZoneId.of(<span class="string">"Asia/Kolkata"</span>));</span><br><span class="line">System.out.println(<span class="string">"Current Date in IST="</span> + todayKolkata);</span><br><span class="line"><span class="comment">// java.time.zone.ZoneRulesException: Unknown time-zone ID: IST</span></span><br><span class="line"><span class="comment">// LocalDate todayIST = LocalDate.now(ZoneId.of("IST"));</span></span><br><span class="line"><span class="comment">// Getting date from the base date: 01/01/1970</span></span><br><span class="line">LocalDate dateFromBase = LocalDate.ofEpochDay(<span class="number">365</span>);</span><br><span class="line">System.out.println(<span class="string">"365th day from base date= "</span> + dateFromBase);</span><br><span class="line"><span class="comment">// 得到某年的多少天</span></span><br><span class="line">LocalDate hundredDay2014 = LocalDate.ofYearDay(<span class="number">2014</span>, <span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">"100th day of 2014="</span> + hundredDay2014);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="LocalTime"><a href="#LocalTime" class="headerlink" title="LocalTime"></a>LocalTime</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Current Time</span></span><br><span class="line">LocalTime time = LocalTime.now();</span><br><span class="line">System.out.println(<span class="string">"Current Time = "</span> + time);</span><br><span class="line"><span class="comment">// Creating LocalTime by providing input arguments</span></span><br><span class="line">LocalTime specificTime = LocalTime.of(<span class="number">12</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">40</span>);</span><br><span class="line">System.out.println(<span class="string">"Specific Time of Day = "</span> + specificTime);</span><br><span class="line"><span class="comment">// Try creating time by providing invalid inputs</span></span><br><span class="line"><span class="comment">// LocalTime invalidTime = LocalTime.of(25,20);</span></span><br><span class="line"><span class="comment">// Exception in thread "main" java.time.DateTimeException:</span></span><br><span class="line"><span class="comment">// Invalid value for HourOfDay (valid values 0 - 23): 25</span></span><br><span class="line"><span class="comment">// Current date in "Asia/Kolkata", you can get it from ZoneId javadoc</span></span><br><span class="line">LocalTime timeKolkata = LocalTime.now(ZoneId.of(<span class="string">"Asia/Kolkata"</span>));</span><br><span class="line">System.out.println(<span class="string">"Current Time in IST = "</span> + timeKolkata);</span><br><span class="line"><span class="comment">// java.time.zone.ZoneRulesException: Unknown time-zone ID: IST</span></span><br><span class="line"><span class="comment">// LocalTime todayIST = LocalTime.now(ZoneId.of("IST"));</span></span><br><span class="line"><span class="comment">// Getting time from the base date: 00:00:00</span></span><br><span class="line">LocalTime specificSecondTime = LocalTime.ofSecondOfDay(<span class="number">10000</span>);</span><br><span class="line">System.out.println(<span class="string">"10000th second time = "</span> + specificSecondTime);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="LocalDateTime"><a href="#LocalDateTime" class="headerlink" title="LocalDateTime"></a>LocalDateTime</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Current Date</span></span><br><span class="line">LocalDateTime today = LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">"Current DateTime1 = "</span> + today);</span><br><span class="line"><span class="comment">// Current Date using LocalDate and LocalTime</span></span><br><span class="line">today = LocalDateTime.of(LocalDate.now(), LocalTime.now());</span><br><span class="line">System.out.println(<span class="string">"Current DateTime2 = "</span> + today);</span><br><span class="line"><span class="comment">// Creating LocalDateTime by providing input arguments</span></span><br><span class="line">LocalDateTime specificDate = LocalDateTime.of(<span class="number">2014</span>, Month.JANUARY, <span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(<span class="string">"Specific Date = "</span> + specificDate);</span><br><span class="line"><span class="comment">// Try creating date by providing invalid inputs</span></span><br><span class="line"><span class="comment">// LocalDateTime feb29_2014 = LocalDateTime.of(2014, Month.FEBRUARY, 28, 25, 1, 1);</span></span><br><span class="line"><span class="comment">// Exception in thread "main" java.time.DateTimeException:</span></span><br><span class="line"><span class="comment">// Invalid value for HourOfDay (valid values 0 - 23): 25</span></span><br><span class="line"><span class="comment">// Current date in "Asia/Kolkata", you can get it from ZoneId javadoc</span></span><br><span class="line">LocalDateTime todayKolkata = LocalDateTime.now(ZoneId.of(<span class="string">"Asia/Kolkata"</span>));</span><br><span class="line">System.out.println(<span class="string">"Current Date in IST = "</span> + todayKolkata);</span><br><span class="line"><span class="comment">// java.time.zone.ZoneRulesException: Unknown time-zone ID: IST</span></span><br><span class="line"><span class="comment">// LocalDateTime todayIST = LocalDateTime.now(ZoneId.of("IST"));</span></span><br><span class="line"><span class="comment">// Getting date from the base date: 01/01/1970</span></span><br><span class="line">LocalDateTime dateFromBase = LocalDateTime.ofEpochSecond(<span class="number">10000</span>, <span class="number">0</span>, ZoneOffset.UTC);</span><br><span class="line">System.out.println(<span class="string">"10000th second time from 01/01/1970= "</span> + dateFromBase);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Instant"><a href="#Instant" class="headerlink" title="Instant"></a>Instant</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Current timestamp</span></span><br><span class="line">Instant timestamp = Instant.now();</span><br><span class="line">System.out.println(<span class="string">"Current Timestamp = "</span> + timestamp);</span><br><span class="line"><span class="comment">// 转换为 milliseconds from 01/01/1970</span></span><br><span class="line"><span class="keyword">long</span> epochMilli = timestamp.toEpochMilli();</span><br><span class="line">System.out.println(epochMilli);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Date-amp-SimpleDateFormat"><a href="#Date-amp-SimpleDateFormat" class="headerlink" title="Date &amp; SimpleDateFormat"></a>Date &amp; SimpleDateFormat</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat oldFormatter = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy/MM/dd"</span>);</span><br><span class="line">Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(oldFormatter.format(date1));</span><br></pre></td></tr></table></figure><p><br></p><h3 id="相互转换"><a href="#相互转换" class="headerlink" title="相互转换"></a>相互转换</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Date now = <span class="keyword">new</span> Date();</span><br><span class="line">LocalDateTime localDateTime = now.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br><span class="line">LocalTime localTime = now.toInstant().atZone(ZoneId.systemDefault()).toLocalTime();</span><br><span class="line">LocalDate localDate = now.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();</span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(localTime);</span><br><span class="line">System.out.println(localDate);</span><br><span class="line"><span class="comment">// LocalTime 和 LocalDate 没有atZone方法</span></span><br><span class="line">Date oldLocalDateTime = </span><br><span class="line">Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());</span><br><span class="line">System.out.println(oldLocalDateTime);</span><br><span class="line"><span class="keyword">long</span> millis = </span><br><span class="line">localDateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();</span><br><span class="line"><span class="keyword">long</span> time = now.getTime();</span><br><span class="line">System.out.println(millis);</span><br><span class="line">System.out.println(time);</span><br><span class="line">LocalDateTime parseLocalDateTime = </span><br><span class="line">Instant.ofEpochMilli(millis).atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br><span class="line">LocalDate parseLocalDate = </span><br><span class="line">Instant.ofEpochMilli(millis).atZone(ZoneId.systemDefault()).toLocalDate();</span><br><span class="line">System.out.println(parseLocalDateTime);</span><br><span class="line">System.out.println(parseLocalDate);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="获取年月日时钟秒"><a href="#获取年月日时钟秒" class="headerlink" title="获取年月日时钟秒"></a>获取年月日时钟秒</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime dt = LocalDateTime.now();</span><br><span class="line">System.out.println(dt.getYear());</span><br><span class="line">System.out.println(dt.getMonthValue()); <span class="comment">// 1 - 12</span></span><br><span class="line">System.out.println(dt.getDayOfMonth());</span><br><span class="line">System.out.println(dt.getHour());</span><br><span class="line">System.out.println(dt.getMinute());</span><br><span class="line">System.out.println(dt.getSecond());</span><br></pre></td></tr></table></figure><p><br></p><h3 id="获得某月第一天-最后一天"><a href="#获得某月第一天-最后一天" class="headerlink" title="获得某月第一天/最后一天"></a>获得某月第一天/最后一天</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"><span class="comment">//本月的第一天</span></span><br><span class="line">LocalDate firstday = LocalDate.of(today.getYear(), today.getMonth(), <span class="number">1</span>);</span><br><span class="line"><span class="comment">//本月的最后一天</span></span><br><span class="line">LocalDate lastDay =today.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">System.out.println(<span class="string">"本月的第一天       "</span> + firstday);</span><br><span class="line">System.out.println(<span class="string">"本月的最后一天   "</span> + lastDay);</span><br></pre></td></tr></table></figure><p><br></p><h3 id="格式化日期"><a href="#格式化日期" class="headerlink" title="格式化日期"></a>格式化日期</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dtf1 = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd  HH:mm:ss"</span>);</span><br><span class="line">DateTimeFormatter dtf2 = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd"</span>);</span><br><span class="line">LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">LocalDate ld = LocalDate.now();</span><br><span class="line">System.out.println(ldt);</span><br><span class="line">System.out.println(ld);</span><br><span class="line">String format1 = ldt.format(dtf1);<span class="comment">// 日期格式化为字符串</span></span><br><span class="line">String format2 = ld.format(dtf2);<span class="comment">// 日期格式化为字符串</span></span><br><span class="line">System.out.println(format1);</span><br><span class="line">System.out.println(format2);</span><br><span class="line">LocalDateTime parse1 = LocalDateTime.parse(format1, dtf1);</span><br><span class="line">LocalDate parse2 = LocalDate.parse(format2, dtf2);</span><br><span class="line">System.out.println(parse1);<span class="comment">// 字符串转化为日期</span></span><br><span class="line">System.out.println(parse2);<span class="comment">// 字符串转化为日期</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="BigInteger-amp-BigDecimal"><a href="#BigInteger-amp-BigDecimal" class="headerlink" title="BigInteger&amp;BigDecimal"></a>BigInteger&amp;BigDecimal</h2><h3 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h3><p>理论上可以表示无限大的数字。常用方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BigInteger <span class="title">abs</span><span class="params">()</span>  返回大整数的绝对值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger val)</span> 返回两个大整数的和</span></span><br><span class="line"><span class="function">BigInteger <span class="title">and</span><span class="params">(BigInteger val)</span>  返回两个大整数的按位与的结果</span></span><br><span class="line"><span class="function">BigInteger <span class="title">andNot</span><span class="params">(BigInteger val)</span> 返回两个大整数与非的结果</span></span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger val)</span>  返回两个大整数的商</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span>   返回大整数的<span class="keyword">double</span>类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span>   返回大整数的<span class="keyword">float</span>类型的值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">gcd</span><span class="params">(BigInteger val)</span>  返回大整数的最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> 返回大整数的整型值</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span> 返回大整数的<span class="keyword">long</span>型值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">max</span><span class="params">(BigInteger val)</span> 返回两个大整数的最大者</span></span><br><span class="line"><span class="function">BigInteger <span class="title">min</span><span class="params">(BigInteger val)</span> 返回两个大整数的最小者</span></span><br><span class="line"><span class="function">BigInteger <span class="title">mod</span><span class="params">(BigInteger val)</span> 用当前大整数对val求模</span></span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger val)</span> 返回两个大整数的积</span></span><br><span class="line"><span class="function">BigInteger <span class="title">negate</span><span class="params">()</span> 返回当前大整数的相反数</span></span><br><span class="line"><span class="function">BigInteger <span class="title">not</span><span class="params">()</span> 返回当前大整数的非</span></span><br><span class="line"><span class="function">BigInteger <span class="title">or</span><span class="params">(BigInteger val)</span> 返回两个大整数的按位或</span></span><br><span class="line"><span class="function">BigInteger <span class="title">pow</span><span class="params">(<span class="keyword">int</span> exponent)</span> 返回当前大整数的exponent次方</span></span><br><span class="line"><span class="function">BigInteger <span class="title">remainder</span><span class="params">(BigInteger val)</span> 返回当前大整数除以val的余数</span></span><br><span class="line"><span class="function">BigInteger <span class="title">leftShift</span><span class="params">(<span class="keyword">int</span> n)</span> 将当前大整数左移n位后返回</span></span><br><span class="line"><span class="function">BigInteger <span class="title">rightShift</span><span class="params">(<span class="keyword">int</span> n)</span> 将当前大整数右移n位后返回</span></span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger val)</span>返回两个大整数相减的结果</span></span><br><span class="line"><span class="function"><span class="keyword">byte</span>[] <span class="title">toByteArray</span><span class="params">(BigInteger val)</span>将大整数转换成二进制反码保存在<span class="keyword">byte</span>数组中</span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> 将当前大整数转换成十进制的字符串形式</span></span><br><span class="line"><span class="function">BigInteger <span class="title">xor</span><span class="params">(BigInteger val)</span> 返回两个大整数的异或</span></span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。具体原理和浮点数的编码方式有关。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999964</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p></p><p>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">"0.9"</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">"0.8"</span>);</span><br><span class="line">BigDecimal x = a.subtract(b);<span class="comment">// 0.1</span></span><br><span class="line">BigDecimal y = b.subtract(c);<span class="comment">// 0.1</span></span><br><span class="line">System.out.println(x.equals(y));<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p></p><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal(<span class="keyword">int</span>)       创建一个具有参数所指定整数值的对象。      </span><br><span class="line">BigDecimal(<span class="keyword">double</span>)    创建一个具有参数所指定双精度值的对象。     </span><br><span class="line">BigDecimal(<span class="keyword">long</span>)      创建一个具有参数所指定长整数值的对象。     </span><br><span class="line">BigDecimal(String)    创建一个具有参数所指定以字符串表示的数值的对象。</span><br><span class="line">add(BigDecimal)       BigDecimal对象中的值相加，然后返回这个对象。</span><br><span class="line">subtract(BigDecimal)  BigDecimal对象中的值相减，然后返回这个对象。</span><br><span class="line">multiply(BigDecimal)  BigDecimal对象中的值相乘，然后返回这个对象。</span><br><span class="line">divide(BigDecimal)    BigDecimal对象中的值相除，然后返回这个对象。</span><br><span class="line">toString()            将BigDecimal对象的数值转换成字符串。    </span><br><span class="line">doubleValue()         将BigDecimal对象中的值以双精度数返回。   </span><br><span class="line">floatValue()          将BigDecimal对象中的值以单精度数返回。   </span><br><span class="line">longValue()           将BigDecimal对象中的值以长整数返回。    </span><br><span class="line">intValue()            将BigDecimal对象中的值以整数返回。</span><br></pre></td></tr></table></figure><p>我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="number">1.01</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="number">1.02</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">"1.01"</span>);</span><br><span class="line">BigDecimal d = <span class="keyword">new</span> BigDecimal(<span class="string">"1.02"</span>);</span><br><span class="line">System.out.println(a.add(b));</span><br><span class="line">System.out.println(c.add(d));</span><br><span class="line">输出：</span><br><span class="line"><span class="number">2.0300000000000000266453525910037569701671600341796875</span></span><br><span class="line"><span class="number">2.03</span></span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="整型包装类值的比较"><a href="#整型包装类值的比较" class="headerlink" title="整型包装类值的比较"></a>整型包装类值的比较</h3><p>所有整形包装类对象值得比较必须使用equals方法。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">3</span>;</span><br><span class="line">Integer y = <span class="number">3</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true</span></span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>把变量从内存中变成可存储或传输的过程称之为序列化，把字节序列恢复为Java对象的过程称为对象的反序列化。对象的序列化主要有两种用途：</p><ol><li>把对象的字节序列永久的保存到硬盘上，通常存放在一个文件中。</li><li>在网络上传送对象的字节序列。</li></ol><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/137588ce-f62f-4bb9-9298-2c27daa4b0ef"></div><p><br></p><h3 id="默认序列化"><a href="#默认序列化" class="headerlink" title="默认序列化"></a>默认序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Path path = Paths.get(<span class="string">"test"</span>);</span><br><span class="line">Person temp = <span class="keyword">new</span> Person(<span class="string">"陈钰琪"</span>, <span class="number">19</span>, <span class="string">"411x2x19xx1x2x6x1x"</span>, <span class="number">20000</span>d);</span><br><span class="line"></span><br><span class="line">ObjectOutputStream out = </span><br><span class="line"><span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(path.toFile()));</span><br><span class="line">out.writeObject(temp);</span><br><span class="line"></span><br><span class="line">ObjectInputStream in = </span><br><span class="line"><span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(path.toFile()));</span><br><span class="line">Person readObject = (Person)in.readObject();</span><br><span class="line">System.out.println(readObject);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">485348963313276072L</span>;</span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="keyword">private</span> String id;</span><br><span class="line"><span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age, String id, Double money)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.id = id;</span><br><span class="line"><span class="keyword">this</span>.money = money;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// getter和setter</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", </span></span><br><span class="line"><span class="string">age="</span> + age + <span class="string">", id="</span> + id + <span class="string">", money="</span> + money + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>版本号是为了控制对象的版本而存在的，版本号一致才可认为可以进行对应的序列化和反序列化。比如我们使用上面的代码把一个Person写入temp文件了，然后修改<code>serialVersionUID = 485348963313276072L;</code>，会发现爆出<code>java.io.InvalidClassException</code>。</p><p><br></p><h3 id="单例的处理"><a href="#单例的处理" class="headerlink" title="单例的处理"></a>单例的处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">MySingleton</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MySingleton INSTANCE = <span class="keyword">new</span> MySingleton(); </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE; &#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123; </span><br><span class="line">    <span class="comment">// instead of the object we're on, return the class variable INSTANCE </span></span><br><span class="line"><span class="keyword">return</span> INSTANCE; </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化”组装”一个新对象时，就会自动调用这个<code>readResolve</code>方法来返回我们指定好的对象了，单例规则也就得到了保证。</p><p><br></p><h3 id="序列化与类加载器"><a href="#序列化与类加载器" class="headerlink" title="序列化与类加载器"></a>序列化与类加载器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</span><br><span class="line">    <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    String name = desc.getName();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Class.forName(name, <span class="keyword">false</span>, latestUserDefinedLoader();());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException ex) &#123;</span><br><span class="line">        Class&lt;?&gt; cl = primClasses.get(name);</span><br><span class="line">        <span class="keyword">if</span> (cl != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cl;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">latestUserDefinedLoader();</span></span><br><span class="line"><span class="comment">Returns first non-privileged class loader on the stack (excluding reflection generated frames) or the extension class loader if only class loaded by the boot class loader and extension class loader are found on the stack. This method is also called via reflection by the following RMI-IIOP class: com.sun.corba.se.internal.util.JDKClassLoader This method should not be removed or its signature changed without corresponding modifications to the above class.</span></span><br><span class="line"><span class="comment">返回堆栈上的第一个非特权类加载器（不包括反射生成的帧）或扩展类加载器（如果堆栈上只找到引导类加载器和扩展类加载器加载的类）。此方法也由以下RMI-IIOP类通过反射调用：com.sun.corba.se.internal.util.JDKClassLoader在没有对上述类进行相应修改的情况下，不应删除此方法或更改其签名。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure><p>默认序列化的时候采用的是一个XXX类加载器。这个类加载器是笔者并不知道是什么。不过可以确定它使用的不是当前类的加载器（本人踩过坑）。如果需要采用自定义的类加载器，比如当前类的类加载器，可以继承<code>ObjectInputStream</code>来覆盖<code>resolveClass(ObjectStreamClass desc)</code>方法。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentThreadLoaderObjectInputStream</span> <span class="keyword">extends</span> <span class="title">ObjectInputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentThreadLoaderObjectInputStream</span><span class="params">(InputStream in)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(in);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">CurrentThreadLoaderObjectInputStream</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IOException, SecurityException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 覆盖原有的加载类的机制，从当前线程的loader进行加载</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; resolveClass(ObjectStreamClass desc)</span><br><span class="line">            <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">        String name = desc.getName();</span><br><span class="line">        <span class="keyword">return</span> Thread.currentThread().getContextClassLoader().loadClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>通常能够分析类能力的程序称为反射（reflective）。程序员通过反射库（包括Class类，Constructor类等）完成业务功能，便是使用到了反射技术。反射的主要功能是在程序运行时分析类。<br>运用反射技术来实现功能一般分为四步：获得Class对象、获得构造器、获得类的实例、运行。反射技术甚至可以获得私有信息。</p><p><br></p><h3 id="获得Class对象"><a href="#获得Class对象" class="headerlink" title="获得Class对象"></a>获得Class对象</h3><p>Class对象是在类加载时由Java虚拟机创建的封装某类型信息的对象。有三种获得方式：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line"><span class="comment">// 1、通过Object类的getClass()方法</span></span><br><span class="line">TestClazz tc = <span class="keyword">new</span> TestClazz();</span><br><span class="line">Class clazz1 = tc.getClass();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、通过类的静态class属性。</span></span><br><span class="line">Class clazz2 = TestClazz.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、通过Class类中的方法构造。这种可拓展性更强，根本不需要知道类型，通过字符串就能获得。</span></span><br><span class="line"><span class="comment">// 但是也正是这个原因，可能发生ClassNotFoundException（main函数的此异常与前两者无关）</span></span><br><span class="line">Class clazz3 = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="获得构造器"><a href="#获得构造器" class="headerlink" title="获得构造器"></a>获得构造器</h3><ul><li><p>获得所有公共权限的构造方法（包括继承的）：<code>clazz.getConstructors();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClazz</span><span class="params">(String msg)</span> </span>&#123; System.out.println(msg); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClazz</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TestClazz</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; System.out.println(i); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line"></span><br><span class="line">Constructor[] constructors = clazz.getConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor e:constructors)</span><br><span class="line">System.out.println(e);</span><br><span class="line"><span class="comment">/*Console：</span></span><br><span class="line"><span class="comment"> public com.first.TestClazz(java.lang.String)</span></span><br><span class="line"><span class="comment">public com.first.TestClazz() */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得指定参数的公共构造器（可以获得继承的）：<code>clazz.getConstructor(Class... parameterTypes);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClazz</span><span class="params">(String msg)</span> </span>&#123; System.out.println(msg); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClazz</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TestClazz</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; System.out.println(i); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line"></span><br><span class="line">Constructor con1 = clazz.getConstructor();</span><br><span class="line">Constructor con2 = clazz.getConstructor(String.class);</span><br><span class="line">System.out.println(con1);</span><br><span class="line">System.out.println(con2);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">  public com.first.TestClazz()</span></span><br><span class="line"><span class="comment">public com.first.TestClazz(java.lang.String)*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得所有的构造器（不包括继承的）：<code>clazz.getDeclaredConstructors();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TestClazz</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; System.out.println(i); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClazz</span><span class="params">(String msg)</span> </span>&#123; System.out.println(msg); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClazz</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">Constructor []cons = clazz.getDeclaredConstructors();</span><br><span class="line"><span class="keyword">for</span>(Constructor e : cons)</span><br><span class="line">System.out.println(e);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">  public com.first.TestClazz()</span></span><br><span class="line"><span class="comment">public com.first.TestClazz(java.lang.String)</span></span><br><span class="line"><span class="comment">private com.first.TestClazz(int)*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得指定的构造器（不包括继承的）：<code>clazz.getDeclaredConstructor((Class... parameterTypes);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TestClazz</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; System.out.println(i); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClazz</span><span class="params">(String msg)</span> </span>&#123; System.out.println(msg); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClazz</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line"></span><br><span class="line">Constructor con = clazz.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line">System.out.println(con);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">  private com.first.TestClazz(int)*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul><li><p>通过公共构造器创建对象：<code>constructor.newInstance(Class... parameterTypes)</code>方法。传入的参数类型和构造器的参数类型一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TestClazz</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; System.out.println(i); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClazz</span><span class="params">(String msg)</span> </span>&#123; System.out.println(msg); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClazz</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">Constructor con1 = clazz.getConstructor(String.class);</span><br><span class="line">Object obj1 = con1.newInstance(<span class="string">"HelloWorld!"</span>);</span><br><span class="line">System.out.println(obj1);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"-----------------------"</span>);</span><br><span class="line">Constructor con2 = clazz.getConstructor();</span><br><span class="line">Object obj2 = con2.newInstance();</span><br><span class="line">System.out.println(obj2);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment"> HelloWorld!</span></span><br><span class="line"><span class="comment">com.first.TestClazz@7852e922</span></span><br><span class="line"><span class="comment">-----------------------</span></span><br><span class="line"><span class="comment">com.first.TestClazz@4e25154f */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过当前类不可访问的构造器创建对象：<code>constructor.setAccessible(true);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TestClazz</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; System.out.println(i); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClazz</span><span class="params">(String msg)</span> </span>&#123; System.out.println(msg); &#125;</span><br><span class="line">TestClazz() &#123; &#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">Constructor constructor = clazz.getDeclaredConstructor(<span class="keyword">int</span>.class);</span><br><span class="line"><span class="comment">//在本例中不写这句也能执行，因为被反射的类和当前类是同一个类，private的构造方法是可以被访问的</span></span><br><span class="line"><span class="comment">//如果某个构造器是当前类不可访问的，此方法可以使其变成可访问的类型</span></span><br><span class="line">constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">Object object = constructor.newInstance(<span class="number">1</span>);</span><br><span class="line">System.out.println(object);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment"> 1</span></span><br><span class="line"><span class="comment"> com.first.TestClazz@7852e922 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="快速获得对象"><a href="#快速获得对象" class="headerlink" title="快速获得对象"></a>快速获得对象</h4><p>如果被反射的类有被当前类可访问的无参构造函数，可以直接使用<code>clazz.newInstance();</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">TestClazz</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; System.out.println(i); &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">TestClazz</span><span class="params">(String msg)</span> </span>&#123; System.out.println(msg); &#125;</span><br><span class="line">TestClazz() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line"></span><br><span class="line">Object object = clazz.newInstance();</span><br><span class="line">System.out.println(object);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment"> com.first.TestClazz@7852e922 */</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="获得成员变量"><a href="#获得成员变量" class="headerlink" title="获得成员变量"></a>获得成员变量</h3><ul><li><p>获得所有公共类型的属性（包括继承的）：<code>clazz.getFields();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String msg;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">Field[] fields = clazz.getFields();</span><br><span class="line"><span class="keyword">for</span>(Field f : fields)</span><br><span class="line">System.out.println(f);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">  public java.lang.String com.first.TestClazz.msg*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得指定公共类型的属性（包括继承的）：<code>clazz.getField(String name);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String msg;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">Field field = clazz.getField(<span class="string">"msg"</span>);</span><br><span class="line">System.out.println(field);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">  public java.lang.String com.first.TestClazz.msg*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得所有的属性（不包括继承的）：<code>clazz.getDeclaredFields();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String msg;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">Field []fields = clazz.getDeclaredFields();</span><br><span class="line"><span class="keyword">for</span>(Field f : fields)</span><br><span class="line">System.out.println(f);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">  public java.lang.String com.first.TestClazz.msg</span></span><br><span class="line"><span class="comment">private int com.first.TestClazz.i*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得指定的属性（不包括继承的）：<code>clazz.getDeclaredField(String name);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String msg;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">Field field = clazz.getDeclaredField(<span class="string">"i"</span>);</span><br><span class="line">System.out.println(field);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">private int com.first.TestClazz.i*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="设置成员变量的值"><a href="#设置成员变量的值" class="headerlink" title="设置成员变量的值"></a>设置成员变量的值</h4><ul><li><p>设置可访问的变量的值：<code>field.set(Object obj, Object value);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String msg;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">TestClazz() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">TestClazz object = (TestClazz)clazz.newInstance();</span><br><span class="line">Field field = clazz.getDeclaredField(<span class="string">"msg"</span>);</span><br><span class="line">field.set(object, <span class="string">"HelloWorld!"</span>);</span><br><span class="line">System.out.println(object.msg);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">HelloWorld!*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>设置不可访问的变量的值：<code>field.setAccessible(true);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> String msg;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> i;</span><br><span class="line">TestClazz() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">TestClazz object = (TestClazz)clazz.newInstance();</span><br><span class="line">Field field = clazz.getDeclaredField(<span class="string">"i"</span>);</span><br><span class="line"><span class="comment">// 在本例中不写这句也能执行，因为被反射的类和当前类是同一个类，private的属性是可以被访问的</span></span><br><span class="line"><span class="comment">// 如果某个属性是当前类不可访问的，此方法可以使其变成可访问的类型</span></span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">field.set(object, <span class="number">65535</span>);</span><br><span class="line">System.out.println(object.i);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">65535*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="获得成员方法"><a href="#获得成员方法" class="headerlink" title="获得成员方法"></a>获得成员方法</h3><ul><li><p>获得所有公共的方法（包括继承的和构造器）：<code>clazz.getMethods();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">TestClazz() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">Method[] methods = clazz.getMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m : methods)</span><br><span class="line">System.out.println(m);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">public static void com.first.TestClazz.main(java.lang.String[]) throws java.lang.Exception</span></span><br><span class="line"><span class="comment">public final void java.lang.Object.wait() throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException</span></span><br><span class="line"><span class="comment">public boolean java.lang.Object.equals(java.lang.Object)</span></span><br><span class="line"><span class="comment">public java.lang.String java.lang.Object.toString()</span></span><br><span class="line"><span class="comment">public native int java.lang.Object.hashCode()</span></span><br><span class="line"><span class="comment">public final native java.lang.Class java.lang.Object.getClass()</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.notify()</span></span><br><span class="line"><span class="comment">public final native void java.lang.Object.notifyAll()*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得指定的公共方法（包括继承的，不包括构造器）：<code>clazz.getMethod(String name, Class&lt;?&gt;... parameterTypes);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String msg)</span> </span>&#123; System.out.println(msg); &#125;</span><br><span class="line">TestClazz() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">Method m = clazz.getMethod(<span class="string">"show"</span>, String.class);</span><br><span class="line">System.out.println(m);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">public void com.first.TestClazz.show(java.lang.String)*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得所有的方法（不包括继承的，不包括构造器）：<code>clazz.getDeclaredMethods();</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getI</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> i; &#125;</span><br><span class="line">TestClazz() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">Method[] methods = clazz.getDeclaredMethods();</span><br><span class="line"><span class="keyword">for</span>(Method m : methods)</span><br><span class="line">System.out.println(m);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">public static void com.first.TestClazz.main(java.lang.String[]) throws java.lang.Exception</span></span><br><span class="line"><span class="comment">private int com.first.TestClazz.getI()*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>获得指定的方法（不包括继承的，不包括构造器）：<code>clazz.getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String msg)</span> </span>&#123; System.out.println(msg); &#125;</span><br><span class="line">TestClazz() &#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">Method m = clazz.getDeclaredMethod(<span class="string">"show"</span>, String.class);</span><br><span class="line">System.out.println(m);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">public void com.first.TestClazz.show(java.lang.String)*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="执行方法"><a href="#执行方法" class="headerlink" title="执行方法"></a>执行方法</h4><ul><li><p>执行公共方法：<code>method.invoke(Object obj, Object... args);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String msg)</span> </span>&#123; System.out.println(msg); &#125;</span><br><span class="line">TestClazz() &#123; &#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">Object object = clazz.newInstance();</span><br><span class="line">Method m = clazz.getDeclaredMethod(<span class="string">"show"</span>, String.class);</span><br><span class="line">m.invoke(object, <span class="string">"HelloWorld!"</span>);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">HelloWorld*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行私有方法：<code>method.invoke(Object obj, Object... args);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClazz</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(String msg)</span> </span>&#123; System.out.println(msg); &#125;</span><br><span class="line">TestClazz() &#123; &#125;</span><br><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class clazz = Class.forName(<span class="string">"com.first.TestClazz"</span>);</span><br><span class="line">Object object = clazz.newInstance();</span><br><span class="line">Method m = clazz.getDeclaredMethod(<span class="string">"show"</span>, String.class);</span><br><span class="line">m.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">m.invoke(object, <span class="string">"HelloWorld!"</span>);</span><br><span class="line"><span class="comment">/*Console:</span></span><br><span class="line"><span class="comment">HelloWorld*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式（regular expression）描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。但是上面的叙述，对于之前没有接触过正则表达式的人还是很迷，我们打个比方，有一串字符：<code>123xyz234</code>和一个模式：<code>*^*</code>，我们假设<code>*</code>表示任意长度的由数字组成的字符串，<code>^</code>表示任意长度的由英文字符表示的字符串，那么我们就可以说这个字符串能匹配上这个模式。因为<code>123</code>可以匹配上<code>*</code>，<code>xyz</code>可以匹配上<code>^</code>，<code>234</code>可以匹配上<code>*</code>。同样的，假如我们再有一个模式：<code>*^</code>，我们用这个模式在字符串中提取，可以提取出来：<code>123</code>、<code>123x</code>、<code>123xyz</code>、<code>234</code> 等等，但是不能提取出来<code>z234</code>、<code>123xyz234</code>。因为我们能提取出来的都是符合这个模式的，这个模式就是正则表达式。<br>不同的语言在正则表达式上的语法是有差距的，但是相同点远远大于不同点。我们在这使用Java语言中正则表达式。不过正则表达式的语法非常难记，在这也是举例出一些常用的语法，具体使用还是得查API文档。</p><p><strong>最简单的正则表达式</strong></p><p>在我们刚才的举例中可以看出正则表达式其实就是一种匹配规则，那么每个字符串也都是一种匹配规则。比如下面的<code>split()</code>方法是按照正则表达式把字符串分割，我们传入的一个字符串就是一个正则表达式。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String testStr = <span class="string">"1234567890"</span>;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Splits this string around matches of the given regular expression. </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">String[] split = testStr.split(<span class="string">"67"</span>);</span><br><span class="line">System.out.println(Arrays.deepToString(split));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>和正则表达式有关的类</strong></p><p>虽然上个例子我们并没有使用到正则表达式相关的类，但这并不表明正则表达式就是一个字符串这么简单，在<code>split()</code>方法的内部还是调用了正则表达式相关的方法。</p><ul><li><code>Pattern</code>类：Pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。</li><li><code>Matcher</code>类：Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。</li><li><code>PatternSyntaxException</code>：PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。<br>现在我们使用正则表达式有关的类来完成上面的例子：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String testStr = <span class="string">"1234567890"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">"67"</span>);</span><br><span class="line">String[] split = pattern.split(testStr);</span><br><span class="line">System.out.println(Arrays.deepToString(split));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>PatternSyntaxException 式一个异常类，但是不强制处理正则表达式的异常，所以这里可加可不加。Matcher的用法请继续看下去。</p><p><strong>匹配</strong></p><p>在上面我们测试的是正则表达式的分割作用，但是这并不是一个很好的学习正则表达式的例子。所以下面我们将采用<code>匹配方法</code>来学习正则表达式，先给一个小例子。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String testStr = <span class="string">"1234567890"</span>;</span><br><span class="line"><span class="keyword">boolean</span> matches = Pattern.matches(<span class="string">"67"</span>, testStr);</span><br><span class="line">System.out.println(matches);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这里的输出结果肯定是<code>false</code>了，因为<code>12345</code>和<code>890</code>都无法在模式中被匹配。</p><p><strong>字符类</strong></p><ul><li><code>[abc]</code> ：a、b 或 c（简单类）</li><li><code>[^abc]</code> ：任何字符，除了 a、b 或 c（否定）</li><li><code>[a-zA-Z]</code> ：a 到 z 或 A 到 Z，两头的字母包括在内（范围）</li><li><code>[a-d[m-p]]</code> ：a 到 d 或 m 到 p：[a-dm-p]（并集）</li><li><code>[a-z&amp;&amp;[def]]</code> ：d、e 或 f（交集）</li><li><code>[a-z&amp;&amp;[^bc]]</code> ：a 到 z，除了 b 和 c：[ad-z]（减去）</li><li><code>[a-z&amp;&amp;[^m-p]]</code> ：a 到 z，而非 m 到 p：[a-lq-z]（减去）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String testStr = <span class="string">"123"</span>;</span><br><span class="line">Pattern.matches(<span class="string">"[123][123][123]"</span>, testStr); <span class="comment">//true</span></span><br><span class="line">Pattern.matches(<span class="string">"[^123][123][123]"</span>, testStr); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>预定义字符类</strong></p><ul><li><code>.</code> ：任何字符（与行结束符可能匹配也可能不匹配）</li><li><code>\d</code> ：数字：[0-9]</li><li><code>\D</code> ：非数字： [^0-9]</li><li><code>\s</code> ：空白字符：[ \t\n\x0B\f\r]</li><li><code>\S</code> ：非空白字符：[^\s]</li><li><code>\w</code> ：单词字符：[a-zA-Z_0-9]</li><li><code>\W</code> ：非单词字符：[^\w]<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String testStr = <span class="string">"123"</span>;</span><br><span class="line">System.out.println(Pattern.matches(<span class="string">"\\d\\d\\d"</span>, testStr)); <span class="comment">//true</span></span><br><span class="line">System.out.println(Pattern.matches(<span class="string">"\\w\\w\\w"</span>, testStr));<span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>数量词</strong></p><ul><li><code>X?</code>： X存在一次或一次也没有</li><li><code>X*</code> ：X存在零次或多次</li><li><code>X+</code> ：X存在一次或多次</li><li><code>X{n}</code> ：X存在恰好 n 次</li><li><code>X{n,}</code> ：X存在至少 n 次</li><li><code>X{n,m}</code> ：X存在至少 n 次，但是不超过 m 次<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String testStr = <span class="string">"123"</span>;</span><br><span class="line"><span class="keyword">boolean</span> matches = Pattern.matches(<span class="string">"[123]&#123;3&#125;"</span>, testStr); <span class="comment">//true</span></span><br><span class="line">System.out.println(matches);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>查找子串</strong></p><p>查找子串需要使用到Pattern和Mather<br><code>[flid=1415279, ffid=BK-2898-20180922-A, frtt=20180922210700, frlt=20180923000300][flid=1417032, ffid=OD-689-20180923-D, fatt=2401, stat=BOR, ista=BOR]</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String FFID = <span class="string">"((ffid=)&#123;1&#125;)\\w&#123;2&#125;-\\w&#123;3,6&#125;-\\d&#123;8&#125;-\\w"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">String str = <span class="string">"[flid=1415279, ffid=BK-2898-20180922-A, frtt=20180922210700, frlt=20180923000300][flid=1417032, ffid=OD-689-20180923-D, fatt=2401, stat=BOR, ista=BOR]"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(FFID);</span><br><span class="line">Matcher matcher = pattern.matcher(str);</span><br><span class="line"><span class="comment">//循环找出全部的匹配子串</span></span><br><span class="line"><span class="keyword">while</span>(matcher.find()) &#123;</span><br><span class="line">System.out.println(matcher.group(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>group方法</strong></p><p>group是针对正则表达式中的<code>()</code>来说的，<code>group(0)</code>就是指的整个串，<code>group(1)</code>指的是第一个括号里的东西，<code>group(2)</code>指的第二个括号里的东西。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    String regEx = <span class="string">"count(\\d+)(df)"</span>;</span><br><span class="line">    String s = <span class="string">"count000dfdfsdffaaaa1"</span>;</span><br><span class="line">    Pattern pat = Pattern.compile(regEx);</span><br><span class="line">    Matcher mat = pat.matcher(s);</span><br><span class="line">    <span class="keyword">if</span> (mat.find()) &#123;</span><br><span class="line">        System.out.println(mat.group());</span><br><span class="line">        System.out.println(mat.group(<span class="number">0</span>));</span><br><span class="line">        System.out.println(mat.group(<span class="number">1</span>));</span><br><span class="line">        System.out.println(mat.group(<span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    count000df</span></span><br><span class="line"><span class="comment">    count000df</span></span><br><span class="line"><span class="comment">    000</span></span><br><span class="line"><span class="comment">    df</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:00 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;内部类&quot;&gt;&lt;a href=&quot;#内部类&quot; class=&quot;headerlink&quot; title=&quot;内部类&quot;&gt;&lt;/a&gt;内
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>01.04-JavaSE-Java8-1</title>
    <link href="https://isjinhao.github.io/posts/24220.html/"/>
    <id>https://isjinhao.github.io/posts/24220.html/</id>
    <published>2019-12-24T12:30:05.000Z</published>
    <updated>2019-12-30T13:20:35.654Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:00 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="初识Lambda"><a href="#初识Lambda" class="headerlink" title="初识Lambda"></a>初识Lambda</h2><p>在Java中，我们只能传递和返回值，而无法将函数作为参数传递给一个方法，也无法声明返回一个函数的方法。所以在代码中，我们不能传递一个行为，只能将行为包装成为一个对象来进行传递。比如下面的Swing：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JFrame jFrame = <span class="keyword">new</span> JFrame(<span class="string">"My JFrame"</span>);</span><br><span class="line">    JButton jButton = <span class="keyword">new</span> JButton(<span class="string">"JButton"</span>);</span><br><span class="line">    jButton.addActionListener(<span class="keyword">new</span> ActionListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">actionPerformed</span><span class="params">(ActionEvent e)</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Button Pressed! "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    jFrame.add(jButton);</span><br><span class="line">    jFrame.pack();</span><br><span class="line">    jFrame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于上面的代码，我们实际上不需要<code>new ActionListener()</code>、<code>actionPerformed</code>等等，我们只需要sout这个行为。传统的匿名内部类却必须需要构建一个对象传入。而Lambda表达式便可以直接的传递一个行为进去。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    JFrame jFrame = <span class="keyword">new</span> JFrame(<span class="string">"My JFrame"</span>);</span><br><span class="line">    JButton jButton = <span class="keyword">new</span> JButton(<span class="string">"JButton"</span>);</span><br><span class="line">    <span class="comment">// 单行直接写，多行使用花括号&#123;&#125;括起来</span></span><br><span class="line">    <span class="comment">// event 全写是 ActionEvent envent，即全写：(ActionEvent event) -&gt; sout</span></span><br><span class="line">    <span class="comment">// 这里只写event是因为Java的编译系统能推断出来这个地方的event就是Action Event</span></span><br><span class="line">    jButton.addActionListener(event -&gt; System.out.println(<span class="string">"Button Pressed! "</span>));</span><br><span class="line">    jFrame.add(jButton);</span><br><span class="line">    jFrame.pack();</span><br><span class="line">    jFrame.setVisible(<span class="keyword">true</span>);</span><br><span class="line">    jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3><blockquote><p>一个接口中只有一个抽象方法就被叫做抽象接口。</p><ul><li>如果一个接口只有一个抽象方法，他就是一个函数式接口。</li><li>如果我们在接口上声明了<code>@FunctionalInterface</code>，编译期会按函数式接口的定义来要求他，如果不满足函数式接口的定义，编译期会报错。</li><li>如果某个接口只有一个函数式接口，即使没有加<code>@FunctionalInterface</code>，编译器也将其看成函数式接口。</li><li>如果某个接口覆盖了<code>Object</code>中的方法，那么此接口的抽象方法不会加一，如以下代码：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 不会报错，</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><p>注意：在函数作为一等公民的语言中，函数被看做类型，而在Java中，Lambda表达式是对象，他们必须依附一类特别的对象类型 - 函数式接口。</p><p><br></p><h3 id="Lambda的一个小例子"><a href="#Lambda的一个小例子" class="headerlink" title="Lambda的一个小例子"></a>Lambda的一个小例子</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Lambda完成集合的遍历</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"abc"</span>, <span class="string">"test"</span>, <span class="string">"hello"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 匿名内部类完成遍历</span></span><br><span class="line">        list.forEach(<span class="keyword">new</span> Consumer&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String string)</span> </span>&#123;</span><br><span class="line">                System.out.println(string);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// lambda expressions</span></span><br><span class="line">        list.forEach(item -&gt; System.out.println(item));</span><br><span class="line">        <span class="comment">// method references</span></span><br><span class="line">        list.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="Lambda基本语法"><a href="#Lambda基本语法" class="headerlink" title="Lambda基本语法"></a>Lambda基本语法</h2><p>Lambda 表达式的语法格式如下：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parameters) -&gt; expression</span><br><span class="line">或</span><br><span class="line">(parameters) -&gt;&#123; statements; &#125;</span><br></pre></td></tr></table></figure><p></p><p>以下是lambda表达式的重要特征：</p><ul><li>可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。</li><li>可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。</li><li>可选的大括号：如果主体包含了一个语句，就不需要使用大括号。</li><li>可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，如果使用了大括号需要指定表达式返回了一个数值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">    Java8Tester tester = <span class="keyword">new</span> Java8Tester();</span><br><span class="line">    <span class="comment">// 类型声明</span></span><br><span class="line">    MathOperation addition = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a + b;</span><br><span class="line">    <span class="comment">// 不用类型声明</span></span><br><span class="line">    MathOperation subtraction = (a, b) -&gt; a - b;</span><br><span class="line">    <span class="comment">// 大括号中的返回语句</span></span><br><span class="line">    MathOperation multiplication = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 没有大括号及返回语句</span></span><br><span class="line">    MathOperation division = (<span class="keyword">int</span> a, <span class="keyword">int</span> b) -&gt; a / b;</span><br><span class="line">    System.out.println(<span class="string">"10 + 5 = "</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, addition));</span><br><span class="line">    System.out.println(<span class="string">"10 - 5 = "</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, subtraction));</span><br><span class="line">    System.out.println(<span class="string">"10 x 5 = "</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, multiplication));</span><br><span class="line">    System.out.println(<span class="string">"10 / 5 = "</span> + tester.operate(<span class="number">10</span>, <span class="number">5</span>, division));</span><br><span class="line">    <span class="comment">// 不用括号</span></span><br><span class="line">    GreetingService greetService1 = message -&gt; System.out.println(<span class="string">"Hello "</span> + message);</span><br><span class="line">    <span class="comment">// 用括号</span></span><br><span class="line">    GreetingService greetService2 = (message) -&gt; System.out.println(<span class="string">"Hello "</span> + message);</span><br><span class="line">    greetService1.sayMessage(<span class="string">"Runoob"</span>);</span><br><span class="line">    greetService2.sayMessage(<span class="string">"Google"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MathOperation</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operation</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">operate</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, MathOperation mathOperation)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mathOperation.operation(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><p>Lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 Lambda 内部修改定义在域外的局部变量，否则会编译错误。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Java8Tester</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> String salutation = <span class="string">"Hello! "</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        GreetingService greetService1 = </span><br><span class="line">            message -&gt; System.out.println(salutation + message);</span><br><span class="line">        greetService1.sayMessage(<span class="string">"Runoob"</span>);</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        Converter&lt;Integer, String&gt; s = (param) -&gt; String.valueOf(param + num);</span><br><span class="line">        System.out.println(s.convert(<span class="number">2</span>));</span><br><span class="line"><span class="comment">//        num = 5;   </span></span><br><span class="line"><span class="comment">//        此行导致上面的Lambda表达式报错，因为Lambda表达式引用的外面的变量必须是effective final的</span></span><br><span class="line"><span class="comment">//     在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量</span></span><br><span class="line">        String first = <span class="string">""</span>;</span><br><span class="line"><span class="comment">//        Comparator&lt;String&gt; comparator = (first, second) -&gt; </span></span><br><span class="line"><span class="comment">//        Integer.compare(first.length(), second.length());  // 编译会出错</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">GreetingService</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">T1</span>, <span class="title">T2</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">String <span class="title">convert</span><span class="params">(<span class="keyword">int</span> i)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="四个重要的函数式接口"><a href="#四个重要的函数式接口" class="headerlink" title="四个重要的函数式接口"></a>四个重要的函数式接口</h2><p>JDK8提供了四个重要的函数式接口：<code>函数型接口</code>、<code>断言型接口</code>、<code>消费型接口</code>、<code>提供型接口</code>。</p><p><br></p><h3 id="Function-lt-T-R-gt"><a href="#Function-lt-T-R-gt" class="headerlink" title="Function&lt;T, R&gt;"></a>Function&lt;T, R&gt;</h3><blockquote><p>Represents a function that accepts one argument and produces a result. This is a functional interface whose functional method is <code>R apply(T t)</code>.</p></blockquote><p><strong>apply(Object)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> FunctionTest functionTest = <span class="keyword">new</span> FunctionTest();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入的是一个行为，这个行为就是一个映射，从输入参数到返回值的映射</span></span><br><span class="line">        System.out.println(functionTest.compute(<span class="number">1</span>, integer -&gt; integer + <span class="number">1</span>));</span><br><span class="line">        System.out.println(functionTest.convert(<span class="number">1</span>, integer -&gt; String.valueOf(integer)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compute</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function.apply(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">convert</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, String&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function.apply(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>compose &amp; andThen</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(before);</span><br><span class="line">    <span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Returns a composed function that first applies the before function to its input, and then applies this function to the result. If evaluation of either function throws an exception, it is relayed to the caller of the composed function.<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;T, V&gt; <span class="title">andThen</span><span class="params">(Function&lt;? <span class="keyword">super</span> R, ? extends V&gt; after)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(after);</span><br><span class="line">    <span class="keyword">return</span> (T t) -&gt; after.apply(apply(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>Returns a composed function that first applies this function to its input, and then applies the after function to the result. If evaluation of either function throws an exception, it is relayed to the caller of the composed function.<br>测试代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionTest2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> FunctionTest2 functionTest2 = <span class="keyword">new</span> FunctionTest2();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(functionTest2.compute1</span><br><span class="line">                           (<span class="number">2</span>, value -&gt; value * <span class="number">3</span>, value -&gt; value * value));<span class="comment">// 12</span></span><br><span class="line">        System.out.println(functionTest2.compute2</span><br><span class="line">                           (<span class="number">2</span>, value -&gt; value * <span class="number">3</span>, value -&gt; value * value));<span class="comment">// 36</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compute1</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; f1, Function&lt;Integer, Integer&gt; f2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.compose(f2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">compute2</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; f1, Function&lt;Integer, Integer&gt; f2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f1.andThen(f2).apply(a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>compose分析：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们先把这个扩充一下compose方法扩充一下</span></span><br><span class="line"><span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(before);</span><br><span class="line">    <span class="comment">// 我们先把这个扩充一下，这样便可以清楚的看见，先调用before的apply，再调用自身的apply</span></span><br><span class="line">    <span class="keyword">return</span> (V v) -&gt; Function.<span class="keyword">this</span>.apply(before.apply(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们再改写一下调用方</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    System.out.println(functionTest2.compute1</span><br><span class="line">                       (<span class="number">2</span>, value -&gt; value * <span class="number">3</span>, value -&gt; value * value));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compute1</span><span class="params">(<span class="keyword">int</span> a, Function&lt;Integer, Integer&gt; f1, Function&lt;Integer, Integer&gt; f2)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"f1: "</span> + f1);</span><br><span class="line">    System.out.println(<span class="string">"f2: "</span> + f2);</span><br><span class="line">    Function&lt;Integer, Integer&gt; compose = f1.compose(f2);</span><br><span class="line">    System.out.println(<span class="string">"compose: "</span> + compose);</span><br><span class="line">    <span class="keyword">return</span> compose.apply(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// f1: jdk8.FunctionTest2$$Lambda$1/471910020@816f27d</span></span><br><span class="line"><span class="comment">// f2: jdk8.FunctionTest2$$Lambda$2/303563356@87aac27</span></span><br><span class="line"><span class="comment">// compose: jdk8.Function$1@3e3abc88</span></span><br><span class="line"><span class="comment">// 我们最终应用的是apply是compose里面的apply方法</span></span><br><span class="line"><span class="comment">// 而apply方法是由compose方法获得的：return (V v) -&gt; Function.this.apply(before.apply(v));</span></span><br><span class="line"><span class="comment">// 这个before很明显就是f2，但是Function.this是什么？compose还是f1？</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们改写一个Function</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">    <span class="keyword">default</span> &lt;V&gt; <span class="function">Function&lt;V, R&gt; <span class="title">compose</span><span class="params">(Function&lt;? <span class="keyword">super</span> V, ? extends T&gt; before)</span> </span>&#123;</span><br><span class="line">        Objects.requireNonNull(before);</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// Lambda表达式可以由内部类替换</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Function&lt;V, R&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> R <span class="title">apply</span><span class="params">(V v)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>);</span><br><span class="line">                System.out.println(Function.<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span> Function.<span class="keyword">this</span>.apply(before.apply(v));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// jdk8.FunctionTest2$$Lambda$1/471910020@816f27d</span></span><br><span class="line"><span class="comment">// jdk8.Function$1@3e3abc88</span></span><br><span class="line"><span class="comment">// jdk8.FunctionTest2$$Lambda$1/471910020@816f27d</span></span><br><span class="line"><span class="comment">// 从输出中可以看到Function.this是我们的f1</span></span><br><span class="line"><span class="comment">// new Function的时候创建的是一个内部类，而Function.this是一个外部类对象</span></span><br><span class="line"><span class="comment">// 实际上，new Function的外部类对象就是第8行的this，也就是f1</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> (V v) -&gt; apply(before.apply(v));</span><br><span class="line"><span class="comment">// 如果上面的expression形式的Lambda表达式太绕，换成下面statements形式的的就好理解了。</span></span><br><span class="line"><span class="keyword">return</span> (V v) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> apply(before.apply(v));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>andThen</code>方法的分析和<code>compose</code>一致。</p><h4 id="BiFunction-lt-T-U-R"><a href="#BiFunction-lt-T-U-R" class="headerlink" title="BiFunction\&lt;T, U, R>"></a>BiFunction\&lt;T, U, R></h4><blockquote><p>Represents a function that accepts two arguments and produces a result. <code>R apply(T t, U u);</code><br>T表示第一个输入的参数的类型，U表示第二个输入的参数的类型。R表示返回类型。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiFunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(compute1(<span class="number">2</span>, <span class="number">1</span>, (a, b) -&gt; a + b)); <span class="comment">// 3</span></span><br><span class="line">        System.out.println(compute1(<span class="number">2</span>, <span class="number">1</span>, (a, b) -&gt; a - b)); <span class="comment">// 1</span></span><br><span class="line">        System.out.println(compute1(<span class="number">2</span>, <span class="number">1</span>, (a, b) -&gt; a * b)); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(compute1(<span class="number">2</span>, <span class="number">1</span>, (a, b) -&gt; a / b)); <span class="comment">// 2</span></span><br><span class="line">        System.out.println(compute2(<span class="number">2</span>, <span class="number">3</span>, (a, b) -&gt; a + b, a -&gt; a * a)); <span class="comment">// 25</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compute1</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, BiFunction&lt;Integer, Integer, Integer&gt; bf)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bf.apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compute2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, </span></span></span><br><span class="line"><span class="function"><span class="params">    BiFunction&lt;Integer, Integer, Integer&gt; bf, Function&lt;Integer, Integer&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f.apply(bf.apply(a, b));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiFunctionTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>, <span class="number">12</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"lisi"</span>, <span class="number">13</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">"wangwu"</span>, <span class="number">14</span>);</span><br><span class="line">        List&lt;Person&gt; list = Arrays.asList(p1, p2, p3);</span><br><span class="line">        <span class="comment">// 过滤年龄等于13的</span></span><br><span class="line">        System.out.println(getPersonList(<span class="number">13</span>, list,</span><br><span class="line">                (age, persons) -&gt; persons.stream().filter(</span><br><span class="line">                        person -&gt; age == person.getAge()).collect(Collectors.toList())));</span><br><span class="line">    <span class="comment">// 过滤年龄大于13的</span></span><br><span class="line">        System.out.println(getPersonList(<span class="number">13</span>, list,</span><br><span class="line">                (age, persons) -&gt; persons.stream().filter(</span><br><span class="line">                        person -&gt; age &lt; person.getAge()).collect(Collectors.toList())));</span><br><span class="line">        <span class="comment">// 过滤年龄小于13的</span></span><br><span class="line">        System.out.println(getPersonList(<span class="number">13</span>, list,</span><br><span class="line">                (age, persons) -&gt; persons.stream().filter(</span><br><span class="line">                        person -&gt; age &gt; person.getAge()).collect(Collectors.toList())));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> List&lt;Person&gt; <span class="title">getPersonList</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span> age, List&lt;Person&gt; persons, BiFunction&lt;Integer, List&lt;Person&gt;, List&lt;Person&gt;&gt; bf)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bf.apply(age, persons);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;   <span class="keyword">return</span> name;    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  <span class="keyword">this</span>.name = name;   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;   <span class="keyword">return</span> age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;   <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// person = Person&#123;name='wangwu', age=34&#125;</span></span><br><span class="line"><span class="comment">// [Person&#123;name='lisi', age=13&#125;, Person&#123;name='wangwu', age=14&#125;]</span></span><br><span class="line"><span class="comment">// [Person&#123;name='lisi', age=13&#125;]</span></span><br><span class="line"><span class="comment">// [Person&#123;name='wangwu', age=14&#125;]</span></span><br><span class="line"><span class="comment">// [Person&#123;name='zhangsan', age=12&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="BinaryOperator-lt-T-extends-BiFunction-lt-T-T-T"><a href="#BinaryOperator-lt-T-extends-BiFunction-lt-T-T-T" class="headerlink" title="BinaryOperator\&lt;T> extends BiFunction\&lt;T,T,T>"></a>BinaryOperator\&lt;T> extends BiFunction\&lt;T,T,T></h4><blockquote><p>Represents an operation upon two operands of the same type, producing a result of the same type as the operands. This is a specialization of BiFunction for the case where the operands and the result are all of the same type.</p><ul><li><code>&lt;T&gt; BinaryOperator&lt;T&gt; minBy(Comparator&lt;? super T&gt; comparator)</code>：Returns a BinaryOperator which returns the lesser of two elements according to the specified Comparator.</li><li><code>&lt;T&gt; BinaryOperator&lt;T&gt; maxBy(Comparator&lt;? super T&gt; comparator)</code>：Returns a BinaryOperator which returns the greater of two elements according to the specified Comparator.<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryOperatorTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(getShort(<span class="string">"hello123"</span>, <span class="string">"world"</span>, </span><br><span class="line">        (a, b) -&gt; a.length() - b.length()));</span><br><span class="line">        System.out.println(getShort(<span class="string">"hello123"</span>, <span class="string">"world"</span>, </span><br><span class="line">        (a, b) -&gt; a.charAt(<span class="number">0</span>) - b.charAt(<span class="number">0</span>)));</span><br><span class="line">        System.out.println(<span class="string">"--------------------"</span>);</span><br><span class="line">        System.out.println(getBig(<span class="string">"hello123"</span>, <span class="string">"world"</span>, </span><br><span class="line">        (a, b) -&gt; a.length() - b.length()));</span><br><span class="line">        System.out.println(getBig(<span class="string">"hello123"</span>, <span class="string">"world"</span>, </span><br><span class="line">        (a, b) -&gt; a.charAt(<span class="number">0</span>) - b.charAt(<span class="number">0</span>)));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getShort</span><span class="params">(String a, String b, Comparator&lt;String&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="comment">// c的结果小于0返回a，否则返回b</span></span><br><span class="line">        <span class="keyword">return</span> BinaryOperator.minBy(c).apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getBig</span><span class="params">(String a, String b, Comparator&lt;String&gt; c)</span></span>&#123;</span><br><span class="line">        <span class="comment">// c的结果大于0返回a，否则返回b</span></span><br><span class="line">        <span class="keyword">return</span> BinaryOperator.maxBy(c).apply(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// world</span></span><br><span class="line"><span class="comment">// hello123</span></span><br><span class="line"><span class="comment">// --------------------</span></span><br><span class="line"><span class="comment">// hello123</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><p><br></p><h3 id="Predicate-lt-T"><a href="#Predicate-lt-T" class="headerlink" title="Predicate\&lt;T>"></a>Predicate\&lt;T></h3><blockquote><p>Represents a predicate (boolean-valued function) of one argument. <code>boolean test(T t);</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">        conditionFilter(list, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        conditionFilter(list, item -&gt; item % <span class="number">2</span> != <span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        conditionFilter(list, item -&gt; item &gt; <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        conditionFilter(list, item -&gt; <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conditionFilter</span><span class="params">(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; pd)</span> </span>&#123;</span><br><span class="line">        list.forEach(integer -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (pd.test(integer))</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2 4 6 8</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 1 3 5 7 9</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 6 7 8 9</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure><p></p></blockquote><p><strong>与或非</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredicateTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>);</span><br><span class="line">        conditionFilterAnd(list, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>, item -&gt; item &gt; <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line">        conditionFilterOr(list, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>, item -&gt; item &gt; <span class="number">5</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------------"</span>);</span><br><span class="line">        conditionFilterNegate(list, item -&gt; item % <span class="number">2</span> == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conditionFilterAnd</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;Integer&gt; list, Predicate&lt;Integer&gt; pd1, Predicate&lt;Integer&gt; pd2)</span> </span>&#123;</span><br><span class="line">        list.forEach(integer -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (pd1.and(pd2).test(integer))</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conditionFilterOr</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;Integer&gt; list, Predicate&lt;Integer&gt; pd1, Predicate&lt;Integer&gt; pd2)</span> </span>&#123;</span><br><span class="line">        list.forEach(integer -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (pd1.or(pd2).test(integer))</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">conditionFilterNegate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        List&lt;Integer&gt; list, Predicate&lt;Integer&gt; pd1)</span> </span>&#123;</span><br><span class="line">        list.forEach(integer -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (pd1.negate().test(integer))</span><br><span class="line">                System.out.println(integer);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 6 8</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">// 2 4 6 7 8 9</span></span><br><span class="line"><span class="comment">// -------------</span></span><br><span class="line"><span class="comment">// 1 3 5 7 9</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="Consumer-lt-T"><a href="#Consumer-lt-T" class="headerlink" title="Consumer\&lt;T>"></a>Consumer\&lt;T></h3><blockquote><p>Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects. <code>void accept(T t);</code></p></blockquote><p><strong>andThen</strong></p><blockquote><p>Returns a composed Consumer that performs, in sequence, this operation followed by the after operation. If performing either operation throws an exception, it is relayed to the caller of the composed operation. If performing this operation throws an exception, the after operation will not be performed.<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testConsumer();</span><br><span class="line">        testAndThen();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testConsumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Consumer&lt;Integer&gt; square = x -&gt; System.out.println(<span class="string">"print square : "</span> + x * x);</span><br><span class="line">        square.accept(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testAndThen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Consumer&lt;Integer&gt; consumer1 = x -&gt; System.out.println(<span class="string">"first x : "</span> + x);</span><br><span class="line">        Consumer&lt;Integer&gt; consumer2 = x -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"second x : "</span> + x);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"throw exception test"</span>);</span><br><span class="line">        &#125;;</span><br><span class="line">        Consumer&lt;Integer&gt; consumer3 = x -&gt; System.out.println(<span class="string">"third x : "</span> + x);</span><br><span class="line">        consumer1.andThen(consumer2).andThen(consumer3).accept(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">print square : 4</span></span><br><span class="line"><span class="comment">first x : 1</span></span><br><span class="line"><span class="comment">second x : 1</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.NullPointerException: throw exception test</span></span><br><span class="line"><span class="comment">at jdk8.ConsumerTest.lambda$testAndThen$2(ConsumerTest.java:21)</span></span><br><span class="line"><span class="comment">at java.util.function.Consumer.lambda$andThen$0(Consumer.java:65)</span></span><br><span class="line"><span class="comment">at java.util.function.Consumer.lambda$andThen$0(Consumer.java:65)</span></span><br><span class="line"><span class="comment">at jdk8.ConsumerTest.testAndThen(ConsumerTest.java:25)</span></span><br><span class="line"><span class="comment">at jdk8.ConsumerTest.main(ConsumerTest.java:9)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p></blockquote><p><strong>Consumer的应用</strong></p><p>Consumer在经典应用是<code>java.lang.Iterable</code>里面的<code>forEach</code>方法。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">for</span> (T t : <span class="keyword">this</span>) &#123;</span><br><span class="line">        action.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="string">"zhangsan"</span>, <span class="number">12</span>);</span><br><span class="line">Person p2 = <span class="keyword">new</span> Person(<span class="string">"lisi"</span>, <span class="number">13</span>);</span><br><span class="line">Person p3 = <span class="keyword">new</span> Person(<span class="string">"wangwu"</span>, <span class="number">14</span>);</span><br><span class="line">List&lt;Person&gt; list = Arrays.asList(p1, p2, p3);</span><br><span class="line">List&lt;Person&gt; list2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.forEach(person -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(person.getAge() &gt; <span class="number">12</span>)</span><br><span class="line">        list2.add(person);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// [Person&#123;name='lisi', age=13&#125;, Person&#123;name='wangwu', age=14&#125;]</span></span><br></pre></td></tr></table></figure><h4 id="BiConsumer-lt-T-U"><a href="#BiConsumer-lt-T-U" class="headerlink" title="BiConsumer\&lt;T, U>"></a>BiConsumer\&lt;T, U></h4><blockquote><p>Represents an operation that accepts two input arguments and returns no result. This is the two-arity specialization of Consumer. Unlike most other functional interfaces, BiConsumer is expected to operate via side-effects. <code>void accept(T t, U u);</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(k + <span class="string">"="</span> + v));</span><br><span class="line"><span class="comment">// 1=one</span></span><br><span class="line"><span class="comment">// 2=two</span></span><br><span class="line"><span class="comment">// 3=three</span></span><br></pre></td></tr></table></figure><p></p></blockquote><p><br></p><h3 id="Supplier-lt-T"><a href="#Supplier-lt-T" class="headerlink" title="Supplier\&lt;T>"></a>Supplier\&lt;T></h3><blockquote><p>Represents a supplier of results. There is no requirement that a new or distinct result be returned each time the supplier is invoked. <code>T get();</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testConsumerToSupplier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Consumer&lt;Person&gt; consumer = person -&gt; &#123;</span><br><span class="line">        person.setName(<span class="string">"wangwu"</span>);</span><br><span class="line">        person.setAge(<span class="number">34</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"lisi"</span>, <span class="number">40</span>);</span><br><span class="line">    consumer.accept(person);</span><br><span class="line">    System.out.println(<span class="string">"person = "</span> + person);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// person = Person&#123;name='wangwu', age=34&#125;</span></span><br></pre></td></tr></table></figure><p></p></blockquote><p><br></p><h2 id="Lambda不是语法糖"><a href="#Lambda不是语法糖" class="headerlink" title="Lambda不是语法糖"></a>Lambda不是语法糖</h2><p>Lambda表达式看上去就是匿名内部类的一个语法糖，但是实际上其它的实现方式不和匿名内部类一致，匿名内部类在编译后会生成两个字节码文件，而Lambda只是在原有的类中增加一个私有的方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainLambda</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"Lambda Thread run()"</span>)).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>this引用的意义</strong></p><p>既然Lambda表达式不是内部类的简写，那么Lambda内部的<code>this</code>引用也就跟内部类对象没什么关系了。在Lambda表达式中<code>this</code>的意义跟在表达式外部完全一样。因此下列代码将输出四遍<code>Hello</code>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Runnable r1 = () -&gt; System.out.println(<span class="keyword">this</span>);</span><br><span class="line">    Runnable r2 = () -&gt; System.out.println(toString());</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Hello().r1.run();</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        <span class="keyword">new</span> Hello().r2.run();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// -----------</span></span><br><span class="line"><span class="comment">// Hello</span></span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h2><blockquote><p>A container object which may or may not contain a non-null value. If a value is present, isPresent() will return true and get() will return the value.<br>Additional methods that depend on the presence or absence of a contained value are provided, such as orElse() (return a default value if value not present) and ifPresent() (execute a block of code if the value is present).<br>This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of Optional may have unpredictable results and should be avoided.</p></blockquote><p><strong>Value-based Classes</strong></p><blockquote><p>Some classes, such as <code>java.util.Optional</code> and <code>java.time.LocalDateTime</code>, are <em>value-based</em>. Instances of a value-based class:</p><ul><li>are final and immutable (though may contain references to mutable objects);</li><li>have implementations of <code>equals</code>, <code>hashCode</code>, and <code>toString</code> which are computed solely from the instance’s state and not from its identity or the state of any other object or variable;</li><li>make no use of identity-sensitive operations such as reference equality (<code>==</code>) between instances, identity hash code of instances, or synchronization on an instances’s intrinsic lock;</li><li>are considered equal solely based on <code>equals()</code>, not based on reference equality (<code>==</code>);</li><li>do not have accessible constructors, but are instead instantiated through factory methods which make no commitment as to the identity of returned instances;</li><li>are <em>freely substitutable</em> when equal, meaning that interchanging any two instances <code>x</code> and <code>y</code> that are equal according to <code>equals()</code> in any computation or method invocation should produce no visible change in behavior.</li></ul><p>A program may produce unpredictable results if it attempts to distinguish two references to equal values of a value-based class, whether directly via reference equality or indirectly via an appeal to synchronization, identity hashing, serialization, or any other identity-sensitive mechanism. Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects and should be avoided.<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(String name)</span> </span>&#123;  <span class="keyword">this</span>.name = name;   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  <span class="keyword">this</span>.name = name;   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;   <span class="keyword">return</span> name;    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; employees;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Company</span><span class="params">(String name)</span> </span>&#123;   <span class="keyword">this</span>.name = name;   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Employee&gt; <span class="title">getEmployees</span><span class="params">()</span> </span>&#123;  <span class="keyword">return</span> employees;   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmployees</span><span class="params">(List&lt;Employee&gt; employees)</span> </span>&#123;    <span class="keyword">this</span>.employees = employees; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Employee e1 = <span class="keyword">new</span> Employee(<span class="string">"zhangsan"</span>);</span><br><span class="line">Employee e2 = <span class="keyword">new</span> Employee(<span class="string">"lisi"</span>);</span><br><span class="line">Company company = <span class="keyword">new</span> Company(<span class="string">"test"</span>);</span><br><span class="line">List&lt;Employee&gt; employees = Arrays.asList(e1, e2);</span><br><span class="line">company.setEmployees(employees);<span class="comment">// 注释掉此句，最终输出的是[]。不是null</span></span><br><span class="line">Optional&lt;Company&gt; optional = Optional.ofNullable(company);</span><br><span class="line">System.out.println(</span><br><span class="line">    optional.map(comp -&gt; comp.getEmployees()).orElse(Collections.emptyList()));</span><br><span class="line"><span class="comment">// [jdk8.Employee@53d8d10a, jdk8.Employee@e9e54c2]</span></span><br></pre></td></tr></table></figure><p>需要注意，<code>Optional</code>是一个未实现序列化的类，不应当将其作为函数的参数或者类的属性。</p><p><br></p><h2 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h2><p>方法引用是Lambda的一个语法糖。我们可以将其看作是一个函数指针。方法引用有四种：</p><ul><li>类名::静态方法名</li><li>对象::实例方法名</li><li>类名::实例方法名</li><li>构造方法引用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;   <span class="keyword">return</span> name;    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  <span class="keyword">this</span>.name = name;   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> score;   &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;   <span class="keyword">this</span>.score = score; &#125;</span><br><span class="line">    <span class="comment">// 此方法违背了面向对象的设计原则，实际使用中不推荐</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compareByScore1</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.score - s2.score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 此方法违背了面向对象的设计原则，实际使用中不推荐</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareByName2</span><span class="params">(Student s1, Student s2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.name.compareTo(s2.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareByScore3</span><span class="params">(Student s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.score - s.score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", score="</span> + score +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodReferenceTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s1 = <span class="keyword">new</span> Student(<span class="string">"zhangsan"</span>, <span class="number">10</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">"lisi"</span>, <span class="number">20</span>);</span><br><span class="line">        Student s3 = <span class="keyword">new</span> Student(<span class="string">"wangwu"</span>, <span class="number">30</span>);</span><br><span class="line">        Student s4 = <span class="keyword">new</span> Student(<span class="string">"zhaoliu"</span>, <span class="number">40</span>);</span><br><span class="line">        List&lt;Student&gt; students = Arrays.asList(s1, s2, s4, s3);</span><br><span class="line">        <span class="comment">// sort方法需要一个Comparator，Comparator的抽象方法是：int compare(T o1, T o2);</span></span><br><span class="line">        <span class="comment">// 我们传入的参数是两个Student类型的对象，返回的是一个int型数据</span></span><br><span class="line"><span class="comment">//        students.sort((s1p, s2p) -&gt; Student.compareByScore(s1p, s2p));</span></span><br><span class="line">        <span class="comment">// compareByScore这个方法接收两个Student类型的对象，</span></span><br><span class="line">        <span class="comment">// 返回一个int型数据，可以满足我们的需要，所以编译器能识别成功</span></span><br><span class="line">        students.sort(Student::compareByScore1);</span><br><span class="line">        <span class="comment">// forEach方法需要一个Consumer，Consumer的抽象方法是：void accept(T t);</span></span><br><span class="line">        <span class="comment">// System.out.println(...) 满足一个参数，没有返回值的要求，所以可以被编译器识别</span></span><br><span class="line">        students.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">        students.sort(s1::compareByName2);</span><br><span class="line">        students.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">        <span class="comment">// Comparator的抽象方法是：int compare(T o1, T o2);</span></span><br><span class="line">        <span class="comment">// 在这种写法中，第一个参数会去调用compareByScore3，将第二个参数传入</span></span><br><span class="line">        <span class="comment">// 如果函数式接口的抽象方法有三个以上的参数，第一个参数用于调用方法，后面的参数都会用于传入</span></span><br><span class="line">        students.sort(Student::compareByScore3);</span><br><span class="line">        students.forEach(System.out::println);</span><br><span class="line">        System.out.println(<span class="string">"----------------"</span>);</span><br><span class="line">        <span class="comment">// 调用String的无参构造方法，返回一个String对象</span></span><br><span class="line">        System.out.println(getString(String::<span class="keyword">new</span>));</span><br><span class="line">        <span class="comment">// 调用public String(String original) 构造方法</span></span><br><span class="line">        System.out.println(getString(<span class="string">"123"</span>, String::<span class="keyword">new</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.get() + <span class="string">"abc"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> String <span class="title">getString</span><span class="params">(String str, Function&lt;String, String&gt; f)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> f.apply(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Student&#123;name='zhangsan', score=10&#125;</span></span><br><span class="line"><span class="comment">// Student&#123;name='lisi', score=20&#125;</span></span><br><span class="line"><span class="comment">// Student&#123;name='wangwu', score=30&#125;</span></span><br><span class="line"><span class="comment">// Student&#123;name='zhaoliu', score=40&#125;</span></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">// Student&#123;name='lisi', score=20&#125;</span></span><br><span class="line"><span class="comment">// Student&#123;name='wangwu', score=30&#125;</span></span><br><span class="line"><span class="comment">// Student&#123;name='zhangsan', score=10&#125;</span></span><br><span class="line"><span class="comment">// Student&#123;name='zhaoliu', score=40&#125;</span></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">// Student&#123;name='zhangsan', score=10&#125;</span></span><br><span class="line"><span class="comment">// Student&#123;name='lisi', score=20&#125;</span></span><br><span class="line"><span class="comment">// Student&#123;name='wangwu', score=30&#125;</span></span><br><span class="line"><span class="comment">// Student&#123;name='zhaoliu', score=40&#125;</span></span><br><span class="line"><span class="comment">// ----------------</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// 123</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="Lambda-and-Collections"><a href="#Lambda-and-Collections" class="headerlink" title="Lambda and Collections"></a>Lambda and Collections</h2><p>由于引入了 Lambda 表达式，Java8新增了<code>java.util.funcion</code>包，里面包含常用的<strong>函数接口</strong>，这是Lambda表达式的基础，Java集合框架也新增部分接口，以便与Lambda表达式对接。我们等下也会介绍其中的一部分方法。</p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/f78851ae-08f9-4920-b093-dd5115c4a413"></div><p><br></p><h3 id="List中的新方法"><a href="#List中的新方法" class="headerlink" title="List中的新方法"></a>List中的新方法</h3><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>该方法的签名为<code>void forEach(Consumer action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作，其中<code>Consumer</code>是个函数接口，里面只有一个待实现方法<code>void accept(T t)</code>（后面我们会看到，这个方法叫什么根本不重要，你甚至不需要记忆它的名字）。<br>需求：<em>假设有一个字符串列表，需要打印出其中所有长度大于3的字符串.</em><br>Java7及以前我们可以用增强的for循环实现：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用曾强for循环迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line"><span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在使用<code>forEach()</code>方法结合匿名内部类，可以这样实现：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合匿名内部类迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.forEach(<span class="keyword">new</span> Consumer&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>Comsumer</code>接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用 Lambda 表达式实现如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.forEach( str -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            System.out.println(str);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure><p></p><p>上述代码给<code>forEach()</code>方法传入一个 Lambda 表达式，我们不需要知道<code>accept()</code>方法，也不需要知道<code>Consumer</code>接口，类型推导帮我们做了一切。</p><h4 id="removeIf"><a href="#removeIf" class="headerlink" title="removeIf()"></a>removeIf()</h4><p>该方法签名为<code>boolean removeIf(Predicate filter)</code>，作用是<strong>删除容器中所有满足<code>filter</code>指定条件的元素</strong>，其中<code>Predicate</code>是一个函数接口，里面只有一个待实现方法<code>boolean test(T t)</code>，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。<br>需求：<em>假设有一个字符串列表，需要删除其中所有长度大于3的字符串。</em><br>我们知道如果需要在迭代过程冲对容器进行删除操作必须使用迭代器，否则会抛出<code>ConcurrentModificationException</code>，所以上述任务传统的写法是：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用迭代器删除列表元素</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">Iterator&lt;String&gt; it = list.iterator();</span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(it.next().length()&gt;<span class="number">3</span>) <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line">        it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>现在使用<code>removeIf()</code>方法结合匿名内部类，我们可是这样实现：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用removeIf()结合匿名名内部类实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.removeIf(<span class="keyword">new</span> Predicate&lt;String&gt;()&#123; <span class="comment">// 删除长度大于3的元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">test</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str.length()&gt;<span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>上述代码使用<code>removeIf()</code>方法，并使用匿名内部类实现<code>Precicate</code>接口。相信你已经想到用Lambda表达式该怎么写了：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用removeIf()结合Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.removeIf(str -&gt; str.length()&gt;<span class="number">3</span>); <span class="comment">// 删除长度大于3的元素</span></span><br></pre></td></tr></table></figure><p></p><p>使用Lambda表达式不需要记忆<code>Predicate</code>接口名，也不需要记忆<code>test()</code>方法名，只需要知道此处需要一个返回布尔类型的Lambda表达式就行了。</p><h4 id="replaceAll"><a href="#replaceAll" class="headerlink" title="replaceAll()"></a>replaceAll()</h4><p>该方法签名为<code>void replaceAll(UnaryOperator operator)</code>，作用是<strong>对每个元素执行<code>operator</code>指定的操作，并用操作结果来替换原来的元素</strong>。其中<code>UnaryOperator</code>是一个函数接口，里面只有一个待实现函数<code>T apply(T t)</code>。<br>需求：<em>假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。</em><br>Java7及之前似乎没有优雅的办法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用下标实现元素替换</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;list.size(); i++)&#123;</span><br><span class="line">    String str = list.get(i);</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        list.set(i, str.toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用<code>replaceAll()</code>方法结合匿名内部类可以实现如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用匿名内部类实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.replaceAll(<span class="keyword">new</span> UnaryOperator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(String str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>UnaryOperator</code>接口。我们知道可以用更为简洁的Lambda表达式实现：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Lambda表达式实现</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.replaceAll(str -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span>(str.length()&gt;<span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> str.toUpperCase();</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><h4 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h4><p>该方法定义在<code>List</code>接口中，方法签名为<code>void sort(Comparator c)</code>，该方法<strong>根据<code>c</code>指定的比较规则对容器元素进行排序</strong>。<code>Comparator</code>接口我们并不陌生，其中有一个方法<code>int compare(T o1, T o2)</code>需要实现，显然该接口是个函数接口。<br>需求：<em>假设有一个字符串列表，按照字符串长度增序对元素排序。</em><br>由于Java7以及之前<code>sort()</code>方法在<code>Collections</code>工具类中，所以代码要这样写：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Collections.sort()方法</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String str1, String str2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> str1.length()-str2.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>现在可以直接使用<code>List.sort()方法</code>，结合Lambda表达式，可以这样写：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// List.sort()方法结合Lambda表达式</span></span><br><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>));</span><br><span class="line">list.sort((str1, str2) -&gt; str1.length()-str2.length());</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="Map中的新方法"><a href="#Map中的新方法" class="headerlink" title="Map中的新方法"></a>Map中的新方法</h3><h4 id="forEach-1"><a href="#forEach-1" class="headerlink" title="forEach()"></a>forEach()</h4><p>该方法签名为<code>void forEach(BiConsumer action)</code>，作用是<strong>对<code>Map</code>中的每个映射执行<code>action</code>指定的操作</strong>，其中<code>BiConsumer</code>是一个函数接口，里面有一个待实现方法<code>void accept(T t, U u)</code>。<code>BinConsumer</code>接口名字和<code>accept()</code>方法名字都不重要，请不要记忆他们。<br>需求：<em>假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系．</em><br>Java7以及之前经典的代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java7以及之前迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.println(entry.getKey() + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用<code>Map.forEach()</code>方法，结合匿名内部类，代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合匿名内部类迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">map.forEach(<span class="keyword">new</span> BiConsumer&lt;Integer, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Integer k, String v)</span></span>&#123;</span><br><span class="line">        System.out.println(k + <span class="string">"="</span> + v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>上述代码调用<code>forEach()</code>方法，并使用匿名内部类实现<code>BiConsumer</code>接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用forEach()结合Lambda表达式迭代Map</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">map.forEach((k, v) -&gt; System.out.println(k + <span class="string">"="</span> + v));</span><br></pre></td></tr></table></figure><p></p><h4 id="replaceAll-1"><a href="#replaceAll-1" class="headerlink" title="replaceAll()"></a>replaceAll()</h4><p>该方法签名为<code>replaceAll(BiFunction function)</code>，作用是对<code>Map</code>中的每个映射执行<code>function</code>指定的操作，并用<code>function</code>的执行结果替换原来的<code>value</code>，其中<code>BiFunction</code>是一个函数接口，里面有一个待实现方法<code>R apply(T t, U u)</code>．不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字．<br>需求：<em>假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写．</em><br>Java7以及之前经典的代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Java7以及之前替换所有Map中所有映射关系</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line"><span class="keyword">for</span>(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    entry.setValue(entry.getValue().toUpperCase());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>使用<code>replaceAll()</code>方法结合匿名内部类，实现如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用replaceAll()结合匿名内部类实现</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">map.replaceAll(<span class="keyword">new</span> BiFunction&lt;Integer, String, String&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apply</span><span class="params">(Integer k, String v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v.toUpperCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>上述代码调用<code>replaceAll()</code>方法，并使用匿名内部类实现<code>BiFunction</code>接口。更进一步的，使用Lambda表达式实现如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用replaceAll()结合Lambda表达式实现</span></span><br><span class="line">HashMap&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">map.put(<span class="number">3</span>, <span class="string">"three"</span>);</span><br><span class="line">map.replaceAll((k, v) -&gt; v.toUpperCase());</span><br></pre></td></tr></table></figure><p></p><p>简洁到让人难以置信．</p><h4 id="merge"><a href="#merge" class="headerlink" title="merge()"></a>merge()</h4><p>该方法签名为<code>merge(K key, V value, BiFunction remappingFunction)</code>，作用是：</p><ol><li>如果<code>Map</code>中<code>key</code>对应的映射不存在或者为<code>null</code>，则将<code>value</code>（不能是<code>null</code>）关联到<code>key</code>上；</li><li>否则执行<code>remappingFunction</code>，如果执行结果非<code>null</code>则用该结果跟<code>key</code>关联，否则在<code>Map</code>中删除<code>key</code>的映射．<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">merge</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    K key, V value, BiFunction&lt;? <span class="keyword">super</span> V, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(remappingFunction);</span><br><span class="line">    Objects.requireNonNull(value);</span><br><span class="line">    V oldValue = get(key);</span><br><span class="line">    V newValue = (oldValue == <span class="keyword">null</span>) ? value :</span><br><span class="line">    remappingFunction.apply(oldValue, value);</span><br><span class="line">    <span class="keyword">if</span>(newValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        remove(key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        put(key, newValue);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p><code>merge()</code>方法虽然语义有些复杂，但该方法的用方式很明确，让我们从最基本的例子开始：计算唯一的单词出现次数。在Java8之前的时候，代码非常混乱，实际的实现其实已经失去了本质层面的设计意义。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">words.forEach(word -&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> prev = map.get(word);</span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        map.put(word, <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        map.put(word, prev + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p></p><p>在Java8中实现就优雅很多了<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map map = <span class="keyword">new</span> HashMap&lt;String, Integer&gt;();</span><br><span class="line">words.forEach(word -&gt;</span><br><span class="line">        map.merge(word, <span class="number">1</span>, (prev, one) -&gt; prev + one)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p></p><p>实际上如果给定的<code>key</code>不存在，它就变成了<code>put(key, value)</code>。如果key已经存在，我们 remappingFunction 可以选择合并的方式。这个功能是完美契机上面的场景：</p><ul><li>只需返回新值即可覆盖旧值： <code>(old, new) -&gt; new</code></li><li>只需返回旧值即可保留旧值：<code>(old, new) -&gt; old</code></li><li>以某种方式合并两者，例如：<code>(old, new) -&gt; old + new</code></li><li>甚至删除旧值：<code>(old, new) -&gt; null</code></li></ul><h4 id="computeIfAbsent"><a href="#computeIfAbsent" class="headerlink" title="computeIfAbsent()"></a>computeIfAbsent()</h4><p>该方法签名为<code>V computeIfAbsent(K key, Function mappingFunction)</code>，作用是：只有在当前<code>Map</code>中<strong>不存在<code>key</code>值的映射或映射值为<code>null</code>时</strong>，才调用<code>mappingFunction</code>，并在<code>mappingFunction</code>执行结果非<code>null</code>时，将结果跟<code>key</code>关联。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">computeIfAbsent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    K key, Function&lt;? <span class="keyword">super</span> K, ? extends V&gt; mappingFunction)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mappingFunction);</span><br><span class="line">    V v;</span><br><span class="line">    <span class="keyword">if</span> ((v = get(key)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        V newValue;</span><br><span class="line">        <span class="keyword">if</span> ((newValue = mappingFunction.apply(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            put(key, newValue);</span><br><span class="line">            <span class="keyword">return</span> newValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>示例代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String ret;</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">ret = map.putIfAbsent(<span class="string">"a"</span>, <span class="string">"aaa"</span>); <span class="comment">//ret 为"aaa", map 为 &#123;"a":"aaa"&#125;</span></span><br><span class="line">ret = map.putIfAbsent(<span class="string">"a"</span>, <span class="string">"bbb"</span>); <span class="comment">//ret 为 "aaa", map 还是 &#123;"a":"aaa"&#125;</span></span><br><span class="line">map.put(<span class="string">"b"</span>, <span class="keyword">null</span>);</span><br><span class="line">ret = map.putIfAbsent(<span class="string">"b"</span>, <span class="string">"bbb"</span>); <span class="comment">//ret 为 "bbb", map 为 &#123;"a":"aaa","b":"bbb"&#125;</span></span><br></pre></td></tr></table></figure><p></p><h4 id="computeIfPresent"><a href="#computeIfPresent" class="headerlink" title="computeIfPresent()"></a>computeIfPresent()</h4><p>该方法签名为<code>V computeIfPresent(K key, BiFunction remappingFunction)</code>，作用跟<code>computeIfAbsent()</code>相反，即，只有在当前<code>Map</code>中<strong>存在<code>key</code>值的映射且非<code>null</code>时</strong>，才调用<code>remappingFunction</code>，如果<code>remappingFunction</code>执行结果为<code>null</code>，则删除<code>key</code>的映射，否则使用该结果替换<code>key</code>原来的映射．<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">computeIfPresent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(remappingFunction);</span><br><span class="line">    V oldValue;</span><br><span class="line">    <span class="keyword">if</span> ((oldValue = get(key)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        V newValue = remappingFunction.apply(key, oldValue);</span><br><span class="line">        <span class="keyword">if</span> (newValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            put(key, newValue);</span><br><span class="line">            <span class="keyword">return</span> newValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            remove(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>示例代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String ret;</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">ret = map.computeIfPresent(<span class="string">"a"</span>, (key, value) -&gt; key + value); <span class="comment">// ret null, map 为 &#123;&#125;</span></span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="keyword">null</span>); <span class="comment">// map 为 ["a":null]</span></span><br><span class="line">ret = map.computeIfPresent(<span class="string">"a"</span>, (key, value) -&gt; key + value); <span class="comment">// ret null, map为 &#123;"a":null&#125;</span></span><br><span class="line">map.put(<span class="string">"a"</span>, <span class="string">"+aaa"</span>);</span><br><span class="line"><span class="comment">// ret "a+aaa", map 为 &#123;"a":"a+aaa"&#125;</span></span><br><span class="line">ret = map.computeIfPresent(<span class="string">"a"</span>, (key, value) -&gt; key + value); </span><br><span class="line"><span class="comment">// ret 为 null, map 为 &#123;&#125;，计算出的 null 把 key 删除了</span></span><br><span class="line">ret = map.computeIfPresent(<span class="string">"a"</span>, (key, value) -&gt; <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><p></p><h4 id="compute"><a href="#compute" class="headerlink" title="compute()"></a>compute()</h4><p>该方法签名为<code>compute(K key, BiFunction remappingFunction)</code>，作用是把<code>remappingFunction</code>的计算结果关联到<code>key</code>上，如果计算结果为<code>null</code>，则在<code>Map</code>中删除<code>key</code>的映射．<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> V <span class="title">compute</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    K key, BiFunction&lt;? <span class="keyword">super</span> K, ? <span class="keyword">super</span> V, ? extends V&gt; remappingFunction)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(remappingFunction);</span><br><span class="line">    V oldValue = get(key);</span><br><span class="line">    V newValue = remappingFunction.apply(key, oldValue);</span><br><span class="line">    <span class="keyword">if</span> (newValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// delete mapping</span></span><br><span class="line">        <span class="keyword">if</span> (oldValue != <span class="keyword">null</span> || containsKey(key)) &#123;</span><br><span class="line">            <span class="comment">// something to remove</span></span><br><span class="line">            remove(key);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// nothing to do. Leave things as they were.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// add or replace old mapping</span></span><br><span class="line">        put(key, newValue);</span><br><span class="line">        <span class="keyword">return</span> newValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>示例如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String ret;</span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;() ;</span><br><span class="line">ret = map.compute(<span class="string">"a"</span>, (key, value) -&gt; <span class="string">"a"</span> + value); <span class="comment">// ret="anull", map=&#123;"a":"anull"&#125;</span></span><br><span class="line">ret = map.compute(<span class="string">"a"</span>, (key, value) -&gt; <span class="string">"a"</span> + value); <span class="comment">// ret="aanull", map=&#123;"a":"aanull"&#125;</span></span><br><span class="line">ret = map.compute(<span class="string">"a"</span>, (key, value) -&gt; <span class="keyword">null</span>); <span class="comment">// ret=null, map=&#123;&#125;</span></span><br></pre></td></tr></table></figure><p></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:00 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;初识Lambda&quot;&gt;&lt;a href=&quot;#初识Lambda&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>01.05-JavaSE-Java8-2</title>
    <link href="https://isjinhao.github.io/posts/53021.html/"/>
    <id>https://isjinhao.github.io/posts/53021.html/</id>
    <published>2019-12-24T12:30:05.000Z</published>
    <updated>2019-12-30T13:20:35.663Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="初识Stream"><a href="#初识Stream" class="headerlink" title="初识Stream"></a>初识Stream</h2><p>在最开始接触到这个名词的时候，我们应该都是有一个问题，此流和IO流有什么关系？实际上它俩一点关系都没有，IO流描述的是对IO的操作如同流水线操作一样，比如我们读一个字节处理一个字节或者读一行处理一行。而Stream这个流也是这个意思，它将对数据源的处理也描述的向流水线操作一样。<br>一个Stream包含一个源、0个或多个中间操作和一个终止操作。由于Stream遵循惰性求值的规范，所以中间操作不会产生任何结果，只有遇到终止操作才会产生结果。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"hello world"</span>);</span><br><span class="line">    Stream&lt;String&gt; stream1 = Arrays.stream(<span class="keyword">new</span> String[]&#123;<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"hello world"</span>&#125;);</span><br><span class="line">    Stream&lt;String&gt; stream2 = Arrays.asList(<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"hello world"</span>).stream();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构建源</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    IntStream intStream = IntStream.of(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>&#125;);</span><br><span class="line">    intStream.forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">    <span class="comment">// 输出 [3,8)返回的数据</span></span><br><span class="line">    IntStream.range(<span class="number">3</span>, <span class="number">8</span>).forEach(System.out::println);</span><br><span class="line">    System.out.println(<span class="string">"-------------------"</span>);</span><br><span class="line">    <span class="comment">// 输出 [3,8]返回的数据</span></span><br><span class="line">    IntStream.rangeClosed(<span class="number">3</span>, <span class="number">8</span>).forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Integer&gt; list = Arays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>);</span><br><span class="line">    <span class="comment">//        System.out.println(list.stream().map(new Function&lt;Integer, Integer&gt;() &#123;</span></span><br><span class="line">    <span class="comment">//            @Override</span></span><br><span class="line">    <span class="comment">//            public Integer apply(Integer integer) &#123;</span></span><br><span class="line">    <span class="comment">//                return integer * 2;</span></span><br><span class="line">    <span class="comment">//            &#125;</span></span><br><span class="line">    <span class="comment">//        &#125;).reduce(0, new BinaryOperator&lt;Integer&gt;() &#123;</span></span><br><span class="line">    <span class="comment">//            @Override</span></span><br><span class="line">    <span class="comment">//            public Integer apply(Integer integer, Integer integer2) &#123;</span></span><br><span class="line">    <span class="comment">//                return integer + integer2;</span></span><br><span class="line">    <span class="comment">//            &#125;</span></span><br><span class="line">    <span class="comment">//        &#125;));</span></span><br><span class="line">    System.out.println(list.stream().map(i -&gt; i * <span class="number">2</span>).reduce(<span class="number">0</span>, Integer::sum));</span><br><span class="line">    <span class="comment">// map是中间过程，reduce是终止操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过源构建数组和集合</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream&lt;String&gt; stream = Stream.of(<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"hello world"</span>);</span><br><span class="line">    <span class="comment">// Returns an array containing the elements of this stream,</span></span><br><span class="line">    <span class="comment">// using the provided generator function to allocate the returned array,</span></span><br><span class="line">    <span class="comment">// as well as any additional arrays that might be required for a partitioned </span></span><br><span class="line">    <span class="comment">// execution or for resizing. This is a terminal operation.s</span></span><br><span class="line">    String[] strings = stream.toArray(length -&gt; <span class="keyword">new</span> String[length]);</span><br><span class="line">    System.out.println(Arrays.deepToString(strings));</span><br><span class="line">    </span><br><span class="line"><span class="comment">//    相同的效果，但是不能在这里和上面的的代码同时出现，因为toArray是一个终止操作，stream已经终止了</span></span><br><span class="line"><span class="comment">//  这里就像一个IO流被关闭了就不能再使用一样</span></span><br><span class="line"><span class="comment">//    List&lt;String&gt; collect = stream.collect(Collectors.toList());</span></span><br><span class="line"><span class="comment">//    System.out.println(collect);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Returns an infinite sequential unordered stream where each element is generated </span></span><br><span class="line"><span class="comment">// by the provided Supplier. This is suitable for generating constant streams, </span></span><br><span class="line"><span class="comment">// streams of random elements, etc.</span></span><br><span class="line">Stream&lt;String&gt; generate = Stream.generate(UUID.randomUUID()::toString);</span><br><span class="line">Stream&lt;String&gt; limit = generate.limit(<span class="number">3</span>);</span><br><span class="line">List&lt;String&gt; collect = limit.collect(Collectors.toList());</span><br><span class="line">System.out.println(collect);</span><br><span class="line"><span class="comment">// Returns an infinite sequential ordered Stream produced by iterative application of a </span></span><br><span class="line"><span class="comment">// function f to an initial element seed, producing a Stream consisting of seed, f(seed), </span></span><br><span class="line"><span class="comment">// f(f(seed)), etc. The first element (position 0) in the Stream will be the provided seed. </span></span><br><span class="line"><span class="comment">// For n &gt; 0, the element at position n, will be the result of applying the function f to </span></span><br><span class="line"><span class="comment">// the element at position n - 1.</span></span><br><span class="line">Stream&lt;Integer&gt; iterate = Stream.iterate(<span class="number">5</span>, (item) -&gt; item + item);</span><br><span class="line">Stream&lt;Integer&gt; limit1 = iterate.limit(<span class="number">10</span>);</span><br><span class="line">List&lt;Integer&gt; collect1 = limit1.collect(Collectors.toList());</span><br><span class="line">System.out.println(collect1);</span><br><span class="line"><span class="comment">// [70e641b3-75d7-4561-ad54-fefe77fa6d63, 70e641b3-75d7-4561-ad54-fefe77fa6d63, 70e641b3-75d7-4561-ad54-fefe77fa6d63]</span></span><br><span class="line"><span class="comment">// [5, 10, 20, 40, 80, 160, 320, 640, 1280, 2560]</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h2><p>流具有如下特点：</p><ol><li>不存储数据。流是基于数据源的对象，它本身不存储数据元素，而是通过管道将数据源的元素传递给操作。</li><li>函数式编程。流的操作不会修改数据源，例如<code>filter</code>不会将数据源中的数据删除。</li><li>延迟操作。流的很多操作如filter，map等中间操作是延迟执行的，只有到终点操作才会将操作顺序执行。</li><li>可以解绑。对于无限数量的流，有些操作是可以在有限的时间完成的，比如<code>limit(n)</code> 或 <code>findFirst()</code>，这些操作可是实现”短路”（Short-circuiting），访问到有限的元素后就可以返回。</li><li>纯消费。流的元素只能访问一次，类似Iterator，操作没有回头路，如果你想从头重新访问流的元素，对不起，你得重新生成一个新的流。</li></ol><p><strong>forEach()</strong></p><p>方法签名为<code>void forEach(Consumer action)</code>，作用是对容器中的每个元素执行<code>action</code>指定的动作。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Stream.forEach()迭代</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><p></p><p><strong>filter()</strong></p><p>函数原型为<code>Stream filter(Predicate predicate)</code>，作用是返回一个只包含满足<code>predicate</code>条件元素的<code>Stream</code>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保留长度等于3的字符串</span></span><br><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.filter(str -&gt; str.length()==<span class="number">3</span>).forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><p></p><p><strong>distinct()</strong></p><p>函数原型为<code>Stream distinct()</code>，作用是返回一个去除重复元素之后的<code>Stream</code>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去掉一个too之后的其余字符串</span></span><br><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.distinct().forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><p></p><p><strong>sorted()</strong></p><p>排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为<code>Stream　sorted()</code>和<code>Stream　sorted(Comparator comparator)</code>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出按照长度升序排序后的字符串</span></span><br><span class="line">Stream&lt;String&gt; stream= Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.sorted((str1, str2) -&gt; str1.length()-str2.length()).forEach(System.out::println);</span><br></pre></td></tr></table></figure><p></p><p><strong>map()</strong></p><p>函数原型为<code>Stream map(Function mapper)</code>，作用是返回一个对当前所有元素执行执行<code>mapper</code>之后的结果组成的<code>Stream</code>。直观的说，就是对每个元素按照某种操作进行转换，转换前后<code>Stream</code>中元素的个数不会改变，但元素的类型取决于转换之后的类型。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出原字符串的大写形式</span></span><br><span class="line">Stream&lt;String&gt; stream　= Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">stream.map(str -&gt; str.toUpperCase()).forEach(str -&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><p></p><p><strong>flatMap()</strong></p><p>函数原型为<code>Stream flatMap(Function&gt; mapper)</code>，作用是对每个元素执行<code>mapper</code>指定的操作，并用所有<code>mapper</code>返回的<code>Stream</code>中的元素组成一个新的<code>Stream</code>作为最终返回结果。说起来太拗口，通俗的讲<code>flatMap()</code>的作用就相当于把原<code>stream</code>中的所有元素都”摊平”之后组成的<code>Stream</code>，转换前后元素的个数和类型都可能会改变。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原来的stream中有两个元素，分别是两个List，执行flatMap()之后，将每个List都“摊平”成了一个个的数字，</span></span><br><span class="line"><span class="comment">// 所以会新产生一个由5个数字组成的Stream。所以最终将输出1~5这5个数字</span></span><br><span class="line">Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>), Arrays.asList(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">stream.flatMap(list -&gt; list.stream()).forEach(i -&gt; System.out.println(i));</span><br></pre></td></tr></table></figure><p></p><p><strong>peek</strong></p><p><code>peek</code> 操作接收的是一个 <code>Consumer</code> 函数。会按照 <code>Consumer</code> 函数提供的逻辑去消费流中的每一个元素，但是返回的流还是包含原来的流中的元素。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// peek操作一般用于不想改变流中元素本身的类型或者只想操作元素的内部状态时；而map则用于改变流中元素本身</span></span><br><span class="line"><span class="comment">// 类型，即从元素中派生出另一种类型的操作。这是他们之间的最大区别。 </span></span><br><span class="line">String[] arr = <span class="keyword">new</span> String[]&#123;<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>&#125;;</span><br><span class="line">Arrays.stream(arr)</span><br><span class="line">        .peek(System.out::println) <span class="comment">// a,b,c,d</span></span><br><span class="line">        .count();</span><br></pre></td></tr></table></figure><p></p><p><strong>匹配</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br></pre></td></tr></table></figure><ul><li><code>allMatch</code>只有在所有的元素都满足断言时才返回true，否则false，流为空时总是返回true</li><li><code>anyMatch</code>只有在任意一个元素满足断言时就返回true，否则false</li><li><code>noneMatch</code>只有在所有的元素都不满足断言时才返回true，否则false<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).allMatch( i -&gt; i &gt; <span class="number">0</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).anyMatch( i -&gt; i &gt; <span class="number">0</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).noneMatch( i -&gt; i &gt; <span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(Stream.&lt;Integer&gt;empty().allMatch( i -&gt; i &gt; <span class="number">0</span>)); <span class="comment">// true</span></span><br><span class="line">System.out.println(Stream.&lt;Integer&gt;empty().anyMatch( i -&gt; i &gt; <span class="number">0</span>)); <span class="comment">// false</span></span><br><span class="line">System.out.println(Stream.&lt;Integer&gt;empty().noneMatch( i -&gt; i &gt; <span class="number">0</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h2><p>reduce操作符是及早求值操作符，接受一个元素序列为输入，反复使用某个合并操作，把序列中的元素合并成一个汇总的结果，其生成的值不是随意的，而是根据指定的计算模型。reduce方法有三个override的方法。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity, </span></span></span><br><span class="line"><span class="function"><span class="params">             BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator, </span></span></span><br><span class="line"><span class="function"><span class="params">             BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p><strong>第一种形式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an Optional describing the reduced value, if any. This is equivalent to:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="keyword">boolean</span> foundAny = <span class="keyword">false</span>;</span><br><span class="line">&gt;  T result = <span class="keyword">null</span>;</span><br><span class="line">&gt;  <span class="keyword">for</span> (T element : <span class="keyword">this</span> stream) &#123;</span><br><span class="line">&gt;      <span class="keyword">if</span> (!foundAny) &#123;</span><br><span class="line">&gt;          foundAny = <span class="keyword">true</span>;</span><br><span class="line">&gt;          result = element;</span><br><span class="line">&gt;      &#125;</span><br><span class="line">&gt;      <span class="keyword">else</span></span><br><span class="line">&gt;          result = accumulator.apply(result, element);</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;  <span class="keyword">return</span> foundAny ? Optional.of(result) : Optional.empty();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>but is not constrained to execute sequentially. The accumulator function must be an associative function. This is a terminal operation.<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>).reduce((sum, item) -&gt; &#123;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="keyword">return</span> sum - item;</span><br><span class="line">    &#125;).ifPresent(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 -1 -4 -8 -13 -19 -26 -34 -43 -53</span></span><br><span class="line"><span class="comment">// 第一轮的sum是索引为0位置的数据，item是索引为1位置的数据。</span></span><br><span class="line"><span class="comment">// 后面轮次的sum是上一轮次计算的结果。item的索引依次加一。</span></span><br></pre></td></tr></table></figure><p></p></blockquote><p><strong>第二种形式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value. This is equivalent to:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;  T result = identity;</span><br><span class="line">&gt;  <span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">&gt;      result = accumulator.apply(result, element)</span><br><span class="line">&gt;  <span class="keyword">return</span> result;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>but is not constrained to execute sequentially. The identity value must be an identity for the accumulator function. This means that for all t, accumulator.apply(identity, t) is equal to t. The accumulator function must be an associative function. This is a terminal operation.<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Integer reduce = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>).reduce(<span class="number">1</span>, (sum, item) -&gt; &#123;</span><br><span class="line">        System.out.println(sum);</span><br><span class="line">        <span class="keyword">return</span> sum - item;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(reduce);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 0 -2 -5 -9 -14 -20 -27 -35 -44 -54</span></span><br><span class="line"><span class="comment">// 第一轮的sum是identity，item是索引为0位置的数据。</span></span><br><span class="line"><span class="comment">// 后面轮次的sum是上一轮次计算的结果。item的索引依次加一。</span></span><br></pre></td></tr></table></figure><p></p></blockquote><p><strong>第三种形式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity, </span></span></span><br><span class="line"><span class="function"><span class="params">             BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">             BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure><blockquote><p>Performs a reduction on the elements of this stream, using the provided identity, accumulation and combining functions. This is equivalent to:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;  U result = identity;</span><br><span class="line">&gt;  <span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">&gt;      result = accumulator.apply(result, element)</span><br><span class="line">&gt;  <span class="keyword">return</span> result;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>but is not constrained to execute sequentially. The identity value must be an identity for the combiner function. This means that for all u, combiner(identity, u) is equal to u. Additionally, the combiner function must be compatible with the accumulator function; for all u and t, the following must hold:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;  combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>This is a terminal operation.<br>第三种形式相对于第二种形式多了一个参数，这个参数是<code>BinaryOperator</code>接收两个参数，返回一个值，这三个数据是相同类型的。实际上这个参数是用于支持并发操作的。</p></blockquote><p><br></p><h2 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h2><p><strong>API介绍</strong></p><p><code>reduce()</code>擅长的是生成一个值，如果想要从Stream生成一个集合或者Map等复杂的对象该怎么办呢？就需要用到<code>collect()</code>了，也就是说它可以把Stream中的要有元素收集到一个结果容器中。其有两种重载的方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                  BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">                  BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>Performs a mutable reduction operation on the elements of this stream. A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList, and elements are incorporated（合并） by updating the state of the result rather than by replacing the result. This produces a result equivalent to:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;  R result = supplier.get();</span><br><span class="line">&gt;  <span class="keyword">for</span> (T element : <span class="keyword">this</span> stream)</span><br><span class="line">&gt;      accumulator.accept(result, element);</span><br><span class="line">&gt;  <span class="keyword">return</span> result;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>Like reduce(Object, BinaryOperator), collect operations can be parallelized without requiring additional synchronization. This is a terminal operation.<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>Performs a mutable reduction operation on the elements of this stream using a Collector. A Collector encapsulates the functions used as arguments to collect(Supplier, BiConsumer, BiConsumer), allowing for reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning.<br>在不使用API之前我们先考虑一下将一个<code>Stream</code>转换成一个容器（或者<code>Map</code>）需要做哪些工作？至少需要两样东西吧：</p><ol><li>目标容器是什么？是<code>ArrayList</code>还是<code>HashSet</code>，或者是个<code>TreeMap</code>。</li><li>新元素如何添加到容器中？是<code>List.add()</code>还是<code>Map.put()</code>。</li><li>如果并行的进行规约，还需要告诉<code>collect()</code>多个部分结果如何合并成一个。<br>结合以上分析，<code>collect()</code>方法定义为<code>R collect(Supplier supplier, BiConsumer accumulator, BiConsumer combiner)</code>，三个参数依次对应上述三条分析。不过每次调用<code>collect()</code>都要传入这三个参数太麻烦，收集器<code>Collector</code>就是对这三个参数的简单封装，所以<code>collect()</code>的另一定义为<code>R collect(Collector collector)</code>。<code>Collectors</code>工具类可通过静态方法生成各种常用的<code>Collector</code>。举例来说，如果要将<code>Stream</code>规约成<code>List</code>可以通过如下两种方式实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//　将Stream规约成List</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">List&lt;String&gt; list = </span><br><span class="line">    stream.collect(ArrayList::<span class="keyword">new</span>, ArrayList::add, ArrayList::addAll);  <span class="comment">// 方式１</span></span><br><span class="line"><span class="comment">// List&lt;String&gt; list = stream.collect(Collectors.toList());  // 方式2</span></span><br><span class="line">System.out.println(list);</span><br></pre></td></tr></table></figure></li></ol></blockquote><p>通常情况下我们不需要手动指定<code>collect()</code>的三个参数，而是调用<code>collect(Collector collector)</code>方法，并且参数中的<code>Collector</code>对象大都是直接通过<code>Collectors</code>工具类获得。实际上传入的收集器的行为决定了<code>collect()</code>的行为。</p><p><strong>使用collect()生成Collection</strong></p><p>前面已经提到通过<code>collect()</code>方法将<code>Stream</code>转换成容器的方法，这里再汇总一下。将<code>Stream</code>转换成<code>List</code>或<code>Set</code>是比较常见的操作，所以<code>Collectors</code>工具已经为我们提供了对应的收集器，通过如下代码即可完成：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将Stream转换成List或Set</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>, <span class="string">"too"</span>);</span><br><span class="line">List&lt;String&gt; list = stream.collect(Collectors.toList()); <span class="comment">// 1</span></span><br><span class="line">Set&lt;String&gt; set = stream.collect(Collectors.toSet()); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><p></p><p>上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过<code>Collectors.toCollection(Supplier collectionFactory)</code>方法完成。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用toCollection()指定规约容器的类型</span></span><br><span class="line">ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::<span class="keyword">new</span>)); <span class="comment">// 3</span></span><br><span class="line">HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::<span class="keyword">new</span>)); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p></p><p>上述代码第2行处指定规约结果是<code>ArrayList</code>，而第三行处指定规约结果为<code>HashSet</code>。一切如你所愿。<br>我们下面看一个笛卡尔积的例子。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; list1 = Arrays.asList(<span class="string">"Hi"</span>, <span class="string">"Hello"</span>);</span><br><span class="line">    List&lt;String&gt; list2 = Arrays.asList(<span class="string">"zhangsan"</span>, <span class="string">"lisi"</span>, <span class="string">"wangwu"</span>);</span><br><span class="line">    List&lt;String&gt; result =</span><br><span class="line">        list1.stream()</span><br><span class="line">        .flatMap(item -&gt; list2.stream().map(item2 -&gt; item + <span class="string">" "</span> + item2))</span><br><span class="line">        .collect(Collectors.toList());</span><br><span class="line">    result.forEach(System.out::println);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Hi zhangsan</span></span><br><span class="line"><span class="comment">// Hi lisi</span></span><br><span class="line"><span class="comment">// Hi wangwu</span></span><br><span class="line"><span class="comment">// Hello zhangsan</span></span><br><span class="line"><span class="comment">// Hello lisi</span></span><br><span class="line"><span class="comment">// Hello wangwu</span></span><br></pre></td></tr></table></figure><p></p><p>分析这个例子我们先看<code>map</code>和<code>flatMap</code>的区别：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Stream&lt;String&gt;&gt; streamStream = </span><br><span class="line">list1.stream().map(item -&gt; list2.stream().map(item2 -&gt; item + <span class="string">" "</span> + item2));</span><br><span class="line">Stream&lt;String&gt; stream = </span><br><span class="line">list1.stream().flatMap(item -&gt; list2.stream().map(item2 -&gt; item + <span class="string">" "</span> + item2));</span><br></pre></td></tr></table></figure><p></p><p>我们会发现，<code>flatMap()</code>的作用就是我们刚才说的将多个<code>Stream</code>摊平。然后我们再分析就会发现，其实这就是一个双层循环，我们再内层循环中，返回了一个<code>Stream</code>，在外层循环中将多个<code>Stream</code>合在一起。<br>我们类比着，做一个三层循环：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; result =</span><br><span class="line">    list1.stream()</span><br><span class="line">    .flatMap(item1 -&gt; list2.stream()</span><br><span class="line">             .flatMap(item2 -&gt; list3.stream()</span><br><span class="line">                      .map(item3 -&gt; item1 + <span class="string">""</span> + item2 + <span class="string">" "</span> + item3)))</span><br><span class="line">    .collect(Collectors.toList());</span><br><span class="line">result.forEach(System.out::println);</span><br><span class="line"><span class="comment">//    Hizhangsan a</span></span><br><span class="line"><span class="comment">//    Hizhangsan b</span></span><br><span class="line"><span class="comment">//    Hilisi a</span></span><br><span class="line"><span class="comment">//    Hilisi b</span></span><br><span class="line"><span class="comment">//    Hiwangwu a</span></span><br><span class="line"><span class="comment">//    Hiwangwu b</span></span><br><span class="line"><span class="comment">//    Hellozhangsan a</span></span><br><span class="line"><span class="comment">//    Hellozhangsan b</span></span><br><span class="line"><span class="comment">//    Hellolisi a</span></span><br><span class="line"><span class="comment">//    Hellolisi b</span></span><br><span class="line"><span class="comment">//    Hellowangwu a</span></span><br><span class="line"><span class="comment">//    Hellowangwu b</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用collect()生成Map</strong></p><p>前面已经说过<code>Stream</code>背后依赖于某种数据源，数据源可以是数组、容器等，但不能是<code>Map</code>。反过来从<code>Stream</code>生成<code>Map</code>是可以的，但我们要想清楚<code>Map</code>的<code>key</code>和<code>value</code>分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下<code>collect()</code>的结果会是<code>Map</code>：</p><ol><li>使用<code>Collectors.toMap()</code>生成的收集器，用户需要指定如何生成<code>Map</code>的<code>key</code>和<code>value</code>。</li><li>使用<code>Collectors.partitioningBy()</code>生成的收集器，对元素进行二分区操作时用到。</li><li>使用<code>Collectors.groupingBy()</code>生成的收集器，对元素做<code>group</code>操作时用到。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", score="</span> + score +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>情况1：使用<code>toMap()</code>生成的收集器，这种情况是最直接的，这是和<code>Collectors.toCollection()</code>并列的方法。如下代码展示将学生列表转换成由<code>&lt;学生，分数&gt;</code>组成的<code>Map</code>。非常直观，无需多言。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用toMap()统计学生成绩</span></span><br><span class="line">Map&lt;Student, Integer&gt; studentToScore =</span><br><span class="line">    students.stream().collect(Collectors.toMap(Function.identity(),     <span class="comment">// 如何生成key</span></span><br><span class="line">                                     student -&gt; student.getScore()));   <span class="comment">// 如何生成value</span></span><br></pre></td></tr></table></figure><p></p><p>情况2：使用<code>partitioningBy()</code>生成的收集器，这种情况适用于将<code>Stream</code>中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Student student1 = <span class="keyword">new</span> Student(<span class="string">"zhangsan"</span>, <span class="number">80</span>);</span><br><span class="line">Student student2 = <span class="keyword">new</span> Student(<span class="string">"lisi"</span>, <span class="number">90</span>);</span><br><span class="line">Student student3 = <span class="keyword">new</span> Student(<span class="string">"wangwu"</span>, <span class="number">100</span>);</span><br><span class="line">Student student4 = <span class="keyword">new</span> Student(<span class="string">"zhaoliu"</span>, <span class="number">90</span>);</span><br><span class="line">Student student5 = <span class="keyword">new</span> Student(<span class="string">"zhaoliu"</span>, <span class="number">90</span>);</span><br><span class="line">List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);</span><br><span class="line">Map&lt;Boolean, List&lt;Student&gt;&gt; map = students.stream().</span><br><span class="line">    collect(Collectors.partitioningBy(student -&gt; student.getScore() &gt;= <span class="number">90</span>));</span><br><span class="line"><span class="comment">// 对于结果为真部分的数据再次进行分区</span></span><br><span class="line">Map&lt;Boolean, Map&lt;Boolean, List&lt;Student&gt;&gt;&gt; map3 = </span><br><span class="line">    students.stream().collect(partitioningBy(student -&gt; student.getScore() &gt; <span class="number">80</span>, </span><br><span class="line">                              partitioningBy(student -&gt; student.getScore() &gt; <span class="number">90</span>)));</span><br><span class="line"><span class="comment">// &#123;false=&#123;false=[Student&#123;name='zhangsan', score=80, age=0&#125;], </span></span><br><span class="line"><span class="comment">//         true=[]&#125;, </span></span><br><span class="line"><span class="comment">// true=&#123;false=[Student&#123;name='lisi', score=90, age=0&#125;, Student&#123;name='zhaoliu', score=90, age=0&#125;, Student&#123;name='zhaoliu', score=90, age=0&#125;], </span></span><br><span class="line"><span class="comment">//       true=[Student&#123;name='wangwu', score=100, age=0&#125;]&#125;&#125;</span></span><br></pre></td></tr></table></figure><p></p><p>情况3：使用<code>groupingBy()</code>生成的收集器，这是比较灵活的一种情况。跟SQL中的<code>group by</code>语句类似，这里的<code>groupingBy()</code>也是按照某个属性对数据进行分组，属性相同的元素会被对应到<code>Map</code>的同一个<code>key</code>上。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, List&lt;Student&gt;&gt; map = students.stream().</span><br><span class="line">collect(Collectors.groupingBy(Student::getName));</span><br><span class="line">Map&lt;Integer, List&lt;Student&gt;&gt; map = students.stream().</span><br><span class="line">collect(Collectors.groupingBy(Student::getScore));</span><br></pre></td></tr></table></figure><p></p><p>以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用<code>group by</code>是为了协助其他查询，比如</p><ol><li>先将员工按照部门分组</li><li>然后统计每个部门员工的人数<br>Java类库设计者也考虑到了这种情况，增强版的<code>groupingBy()</code>能够满足这种需求。增强版的<code>groupingBy()</code>允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做<strong>上游收集器</strong>，之后执行其他运算的收集器叫做<strong>下游收集器</strong>(<em>downstream Collector</em>)。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; map = students.stream().</span><br><span class="line">collect(Collectors.groupingBy(Student::getName, </span><br><span class="line">                                          Collectors.counting())); <span class="comment">// 下游收集器</span></span><br><span class="line">Map&lt;String, Double&gt; map = students.stream().collect(Collectors.groupingBy(</span><br><span class="line">    Student::getName, </span><br><span class="line">    Collectors.averagingDouble(Student::getScore)));   <span class="comment">// 下游收集器</span></span><br></pre></td></tr></table></figure></li></ol><p>上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Integer, Map&lt;String, List&lt;Student&gt;&gt;&gt; map = students.stream().</span><br><span class="line">    collect(groupingBy(Student::getScore, groupingBy(Student::getName)));</span><br><span class="line"><span class="comment">//&#123;80=&#123;zhangsan=[Student&#123;name='zhangsan', score=80, age=0&#125;]&#125;, </span></span><br><span class="line"><span class="comment">// 100=&#123;wangwu=[Student&#123;name='wangwu', score=100, age=0&#125;]&#125;, </span></span><br><span class="line"><span class="comment">//   90=&#123;lisi=[Student&#123;name='lisi', score=90, age=0&#125;], </span></span><br><span class="line"><span class="comment">//      zhaoliu=[Student&#123;name='zhaoliu', score=90, age=0&#125;, Student&#123;name='zhaoliu', score=90, </span></span><br><span class="line"><span class="comment">//age=0&#125;]&#125;&#125;</span></span><br></pre></td></tr></table></figure><p></p><p><strong>使用collect()做字符串join</strong></p><p>这个肯定是大家喜闻乐见的功能，字符串拼接时使用<code>Collectors.joining()</code>生成的收集器，从此告别<em>for</em>循环。<code>Collectors.joining()</code>方法有三种重写形式，分别对应三种不同的拼接方式。无需多言，代码过目难忘。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Collectors.joining()拼接字符串</span></span><br><span class="line">Stream&lt;String&gt; stream = Stream.of(<span class="string">"I"</span>, <span class="string">"love"</span>, <span class="string">"you"</span>);</span><br><span class="line"><span class="comment">//String joined = stream.collect(Collectors.joining());  // "Iloveyou"</span></span><br><span class="line"><span class="comment">//String joined = stream.collect(Collectors.joining(","));  // "I,love,you"</span></span><br><span class="line">String joined = stream.collect(Collectors.joining(<span class="string">","</span>, <span class="string">"&#123;"</span>, <span class="string">"&#125;"</span>));  <span class="comment">// "&#123;I,love,you&#125;"</span></span><br></pre></td></tr></table></figure><p></p><p><strong>collectingAndThen</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得每个姓名下的最低分，返回的是Optional，但实际上此时的最低分一定不为空</span></span><br><span class="line">Map&lt;String, Optional&lt;Student&gt;&gt; collect = students.stream().collect(groupingBy(</span><br><span class="line">    Student::getName, minBy(Comparator.comparingInt(Student::getScore))));</span><br><span class="line"><span class="comment">// 所以可以只用collectingAndThen，传入一个 Function</span></span><br><span class="line">Map&lt;String, Student&gt; map5 = students.stream().collect(groupingBy(Student::getName,             collectingAndThen(minBy(Comparator.comparingInt(Student::getScore)), Optional::get)));</span><br><span class="line"><span class="comment">// &#123;lisi=Student&#123;name='lisi', score=90, age=0&#125;, </span></span><br><span class="line"><span class="comment">//  zhaoliu=Student&#123;name='zhaoliu', score=90, age=0&#125;, </span></span><br><span class="line"><span class="comment">//  zhangsan=Student&#123;name='zhangsan', score=80, age=0&#125;, </span></span><br><span class="line"><span class="comment">//  wangwu=Student&#123;name='wangwu', score=100, age=0&#125;&#125;</span></span><br></pre></td></tr></table></figure><p><br></p><h2 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h2><blockquote><p>A mutable reduction operation that accumulates input elements into a mutable result container, optionally transforming the accumulated result into a final representation after all input elements have been processed. Reduction operations can be performed either sequentially or in parallel.</p><p>Examples of mutable reduction operations include: accumulating elements into a Collection; concatenating strings using a StringBuilder; computing summary information about elements such as sum, min, max, or average; computing “pivot table” summaries such as “maximum valued transaction by seller”, etc. The class Collectors provides implementations of many common mutable reductions.</p><p>A reduction operation (also called a fold) takes a sequence of input elements and combines them into a single summary result by repeated application of a combining operation, such as finding the sum or maximum of a set of numbers, or accumulating elements into a list.</p><p>A mutable reduction operation accumulates input elements into a mutable result container, such as a Collection or StringBuilder, as it processes the elements in the stream.</p><p>A Collector is specified by four functions that work together to accumulate entries into a mutable result container, and optionally perform a final transform on the result. They are:</p><ul><li>creation of a new result container (supplier())</li><li>incorporating a new data element into a result container (accumulator())</li><li>combining two result containers into one (combiner())</li><li>performing an optional final transform on the container (finisher())<br>对于函数<code>combiner()</code>，JDK对其注释如下：<br>A function that accepts two partial results and merges them. The combiner function may fold state from one argument into the other and return that, or may return a new result container.<br>我们举个例子来看这个函数：<br>假如有四个线程同时执行一次聚合，此次聚合的结果是生成一个集合，那么四个线程就会产生四个结果集合。此时这个函数便要发挥作用，他需要将四个结果集合合并成为一个，那么此时可以有两种做法，一是再生成一个新的集合，将四个结果集合都加入这个集合，再返回。二是将第二个结果集合加入第一个结果集合，然后返回第一个集合再去，然后再去和第三个集合合并，此时我们就说第二个结果集合被fold了。<br>这个方法会在线程安全的情况下被调用，即使开发者没有执行并发安全操作。它的核心用处就是在并行流的环境中将多个部分结果合成一个结果返回。<br>Collectors also have a set of characteristics, such as Collector.Characteristics.CONCURRENT, that provide hints that can be used by a reduction implementation to provide better performance.</li></ul><p>A sequential implementation of a reduction using a collector would create a single result container using the supplier function, and invoke the accumulator function once for each input element. A parallel implementation would partition the input, create a result container for each partition, accumulate the contents of each partition into a subresult for that partition, and then use the combiner function to merge the subresults into a combined result.</p><p>To ensure that sequential and parallel executions produce equivalent results, the collector functions must satisfy an identity and an associativity constraints.</p><p>The identity constraint says that for any partially accumulated result, combining it with an empty result container must produce an equivalent result. That is, for a partially accumulated result a that is the result of any series of accumulator and combiner invocations, a must be equivalent to combiner.apply(a, supplier.get()).<br>identity可以翻译为”同一性“，这个性质就是说对于任何一个中间结果，当<code>combiner.apply(a, supplier.get())</code>被调用后时必须等价于a（等价于可能是=，也可能是equal，需要根据业务来算）。<br>The associativity constraint says that splitting the computation must produce an equivalent result. That is, for any input elements t1 and t2, the results r1 and r2 in the computation below must be equivalent:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;  A a1 = supplier.get();</span><br><span class="line">&gt;  accumulator.accept(a1, t1);</span><br><span class="line">&gt;  accumulator.accept(a1, t2);</span><br><span class="line">&gt;  R r1 = finisher.apply(a1);  <span class="comment">// result without splitting</span></span><br><span class="line">&gt; </span><br><span class="line">&gt;  A a2 = supplier.get();</span><br><span class="line">&gt;  accumulator.accept(a2, t1);</span><br><span class="line">&gt;  A a3 = supplier.get();</span><br><span class="line">&gt;  accumulator.accept(a3, t2);</span><br><span class="line">&gt;  R r2 = finisher.apply(combiner.apply(a2, a3));  <span class="comment">// result with splitting</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>上面的代码就是在说将一系列的操作串行执行和将操作分割执行之后再合并应该保持一致。</p><blockquote><p>For collectors that do not have the UNORDERED characteristic, two accumulated results a1 and a2 are equivalent if finisher.apply(a1).equals(finisher.apply(a2)). For unordered collectors, equivalence is relaxed to allow for non-equality related to differences in order. (For example, an unordered collector that accumulated elements to a List would consider two lists equivalent if they contained the same elements, ignoring order.)<br>两个结果<code>a1</code>，<code>a2</code>是否等价的逻辑值应该和<code>finisher.apply(a1).equals(finisher.apply(a2))</code>一致。但是对于具有无序特征的情况下，不考虑容器中的元素顺序。<br>Libraries that implement reduction based on Collector, such as Stream.collect(Collector), must adhere to the following constraints:</p><ul><li>The first argument passed to the accumulator function, both arguments passed to the combiner function, and the argument passed to the finisher function must be the result of a previous invocation of the result supplier, accumulator, or combiner functions.<br>这个实际上是在说累加器的第一个参数是容器的类型，组合器参数的类型是容器的类型。</li><li>The implementation should not do anything with the result of any of the result supplier, accumulator, or combiner functions other than to pass them again to the accumulator, combiner, or finisher functions, or return them to the caller of the reduction operation.<br>这个实际上是在说在collect的执行过程中所有的操作都应该来自<code>supplier</code>、<code>accumulator</code>、<code>combiner</code>。</li><li>If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again.</li><li>Once a result is passed to the combiner or finisher function, it is never passed to the accumulator function again.<br>这个又有点fold的意思了，也就是旧的对象如果不作为返回值返回，他们的状态就会被折叠。</li><li>For non-concurrent collectors, any result returned from the result supplier, accumulator, or combiner functions must be serially thread-confined. This enables collection to occur in parallel without the Collector needing to implement any additional synchronization. The reduction implementation must manage that the input is properly partitioned, that partitions are processed in isolation, and combining happens only after accumulation is complete.</li><li>For concurrent collectors, an implementation is free to (but not required to) implement reduction concurrently. A concurrent reduction is one where the accumulator function is called concurrently from multiple threads, using the same concurrently-modifiable result container, rather than keeping the result isolated during accumulation. A concurrent reduction should only be applied if the collector has the Collector.Characteristics.UNORDERED characteristics or if the originating data is unordered.<br>这两条很绕，分析之后会发现。它是在说非并发的收集器需要保证收三个函数的结果不被其他线程调用，这样就可以在并发的条件下无须额外的同步就可以使用。对于并发的收集器，并发操作应该是使用线程安全的容器在调用累加操作的时候保证的，而不是在累加操作的内部实现中保证的。<br>In addition to the predefined implementations in Collectors, the static factory methods of(Supplier, BiConsumer, BinaryOperator, Characteristics…) can be used to construct collectors. For example, you could create a collector that accumulates widgets into a TreeSet with:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;  Collector&lt;Widget, ?, TreeSet&lt;Widget&gt;&gt; intoSet =</span><br><span class="line">&gt;      Collector.of(TreeSet::<span class="keyword">new</span>, TreeSet::add,</span><br><span class="line">&gt;                   (left, right) -&gt; &#123; left.addAll(right); <span class="keyword">return</span> left; &#125;);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>(This behavior is also implemented by the predefined collector Collectors.toCollection(Supplier)).<br>apiNote：<br>Performing a reduction operation with a Collector should produce a result equivalent to:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;  R container = collector.supplier().get();</span><br><span class="line">&gt;  <span class="keyword">for</span> (T t : data)</span><br><span class="line">&gt;      collector.accumulator().accept(container, t);</span><br><span class="line">&gt;  <span class="keyword">return</span> collector.finisher().apply(container);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>However, the library is free to partition the input, perform the reduction on the partitions, and then use the combiner function to combine the partial results to achieve a parallel reduction. (Depending on the specific reduction operation, this may perform better or worse, depending on the relative cost of the accumulator and combiner functions.)</p><p>Collectors are designed to be composed; many of the methods in Collectors are functions that take a collector and produce a new collector. For example, given the following collector that computes the sum of the salaries of a stream of employees:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;  Collector&lt;Employee, ?, Integer&gt; summingSalaries</span><br><span class="line">&gt;      = Collectors.summingInt(Employee::getSalary))</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>If we wanted to create a collector to tabulate the sum of salaries by department, we could reuse the “sum of salaries” logic using Collectors.groupingBy(Function, Collector):</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;  Collector&lt;Employee, ?, Map&lt;Department, Integer&gt;&gt; summingSalariesByDept</span><br><span class="line">&gt;      = Collectors.groupingBy(Employee::getDepartment, summingSalaries);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote></blockquote><p><br></p><h3 id="自定义收集器"><a href="#自定义收集器" class="headerlink" title="自定义收集器"></a>自定义收集器</h3><p>自定义一个收集器，我们需要实现Collector接口。Collector接口的三个泛型参数分别表示集合中元素的类型，集合的类型和返回值的类型。我们再看五个待实现的方法。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Supplier&lt;A&gt; <span class="title">supplier</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BiConsumer&lt;A, T&gt; <span class="title">accumulator</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">BinaryOperator&lt;A&gt; <span class="title">combiner</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Function&lt;A, R&gt; <span class="title">finisher</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p></p><p><code>supplier</code>、<code>accumulator</code>、<code>combiner</code>之前已经介绍的很详细了。<code>finisher</code>的作用是将中间容器的类型转为最终的结果类型。中间容器的类型也就是三个泛型中的集合的类型，结果类型也就是三个泛型中的返回值的类型。<br>而对于<code>characteristics</code>是标识这个收集器的特性。它是使用枚举来做的。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Characteristics &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates that this collector is &lt;em&gt;concurrent&lt;/em&gt;, meaning that</span></span><br><span class="line"><span class="comment">     * the result container can support the accumulator function being</span></span><br><span class="line"><span class="comment">     * called concurrently with the same result container from multiple</span></span><br><span class="line"><span class="comment">     * threads.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;If a &#123;<span class="doctag">@code</span> CONCURRENT&#125; collector is not also &#123;<span class="doctag">@code</span> UNORDERED&#125;,</span></span><br><span class="line"><span class="comment">     * then it should only be evaluated concurrently if applied to an</span></span><br><span class="line"><span class="comment">     * unordered data source.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CONCURRENT,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates that the collection operation does not commit to preserving</span></span><br><span class="line"><span class="comment">     * the encounter order of input elements.  (This might be true if the</span></span><br><span class="line"><span class="comment">     * result container has no intrinsic order, such as a &#123;<span class="doctag">@link</span> Set&#125;.)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    UNORDERED,</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Indicates that the finisher function is the identity function and</span></span><br><span class="line"><span class="comment">     * can be elided.  If set, it must be the case that an unchecked cast</span></span><br><span class="line"><span class="comment">     * from A to R will succeed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    IDENTITY_FINISH</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><ul><li><code>UNORDERED</code>：如果流中输入的元素和最终返回的元素顺序不一致，需要标志上这个特性。比如讲一个List转为一个Set，Set中元素的顺序不保证和List一致。</li><li><code>IDENTITY_FINISH</code>：如果中间结果的类型和最终返回的类型一致，标志上这个特性之<code>finisher</code>就不会被调用，而是使用强制转换的方式来将中间结果的容器转为最终结果。<br>下面是一个使用自定义收集器将List转为Set的案例，中间容器的类型和结果容器的类型一致。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetCollector</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">        System.out.println(<span class="string">"supplier invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> HashSet::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">        System.out.println(<span class="string">"accumulator invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> Set::add;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">        System.out.println(<span class="string">"combiner invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> (set1, set2) -&gt; &#123;</span><br><span class="line">            set1.addAll(set2);</span><br><span class="line">            <span class="keyword">return</span> set1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;Set&lt;T&gt;, Set&lt;T&gt;&gt; finisher() &#123;</span><br><span class="line"><span class="comment">//        System.out.println("finisher invoked!");</span></span><br><span class="line"><span class="comment">//        return Function.identity();</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"characteristics invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH, UNORDERED));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = Arrays.asList(<span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"welcome"</span>, <span class="string">"hello"</span>);</span><br><span class="line">        Set&lt;String&gt; set = list.stream().collect(<span class="keyword">new</span> MySetCollector&lt;&gt;());</span><br><span class="line">        System.out.println(set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>下面是一个中间容器和最终结果容器不一致的情况：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetCollector2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;, <span class="title">Map</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">        System.out.println(<span class="string">"supplier invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> HashSet&lt;T&gt;::<span class="keyword">new</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">        System.out.println(<span class="string">"accumulator invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> (set, item) -&gt; &#123;</span><br><span class="line">            set.add(item);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">        System.out.println(<span class="string">"combiner invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> (set1, set2) -&gt; &#123;</span><br><span class="line">            set1.addAll(set2);</span><br><span class="line">            <span class="keyword">return</span> set1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;Set&lt;T&gt;, Map&lt;T, T&gt;&gt; finisher() &#123;</span><br><span class="line">        System.out.println(<span class="string">"finisher invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> set -&gt; &#123;</span><br><span class="line">            Map&lt;T, T&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">            set.stream().forEach(item -&gt; map.put(item, item));</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"characteristics invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Runtime.getRuntime().availableProcessors());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            List&lt;String&gt; list = Arrays.asList(</span><br><span class="line">                <span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"welcome"</span>, <span class="string">"hello"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>);</span><br><span class="line">            Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            set.addAll(list);</span><br><span class="line">            System.out.println(<span class="string">"set: "</span> + set);</span><br><span class="line">            Map&lt;String, String&gt; map = </span><br><span class="line">                set.stream().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于<code>CONCURRENT</code>，是指在并行流的情况下多个结果会去操作一个容器。如果不加上这个特性，并行流的情况下是多个线程各自操作一个容器。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySetCollector2</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Collector</span>&lt;<span class="title">T</span>, <span class="title">Set</span>&lt;<span class="title">T</span>&gt;, <span class="title">Map</span>&lt;<span class="title">T</span>, <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123;</span><br><span class="line">        System.out.println(<span class="string">"supplier invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> () -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HashSet&lt;T&gt;();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123;</span><br><span class="line">        System.out.println(<span class="string">"accumulator invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> (set, item) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"accumulator: "</span> + </span><br><span class="line">            set  + <span class="string">", "</span> + Thread.currentThread().getName());</span><br><span class="line">            set.add(item);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123;</span><br><span class="line">        System.out.println(<span class="string">"combiner invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> (set1, set2) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"set1: "</span> + set1);</span><br><span class="line">            System.out.println(<span class="string">"set2: "</span> + set2);</span><br><span class="line">            set1.addAll(set2);</span><br><span class="line">            <span class="keyword">return</span> set1;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Function&lt;Set&lt;T&gt;, Map&lt;T, T&gt;&gt; finisher() &#123;</span><br><span class="line">        System.out.println(<span class="string">"finisher invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> set -&gt; &#123;</span><br><span class="line">            Map&lt;T, T&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">            set.stream().forEach(item -&gt; map.put(item, item));</span><br><span class="line">            <span class="keyword">return</span> map;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Characteristics&gt; <span class="title">characteristics</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"characteristics invoked!"</span>);</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableSet(</span><br><span class="line">        EnumSet.of(Characteristics.UNORDERED, Characteristics.CONCURRENT));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            List&lt;String&gt; list = Arrays.asList(</span><br><span class="line">            <span class="string">"hello"</span>, <span class="string">"world"</span>, <span class="string">"welcome"</span>, <span class="string">"hello"</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>, <span class="string">"f"</span>, <span class="string">"g"</span>);</span><br><span class="line">            Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">            set.addAll(list);</span><br><span class="line">            System.out.println(<span class="string">"set: "</span> + set);</span><br><span class="line">            Map&lt;String, String&gt; map = </span><br><span class="line">            set.parallelStream().collect(<span class="keyword">new</span> MySetCollector2&lt;&gt;());</span><br><span class="line">            System.out.println(map);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>所以在并行流的环境中如果加上了<code>CONCURRENT</code>，只会生成一个容器，而且此时后期不需要调用<code>combiner</code>，上面的代码在不抛出并行修改异常的时候会作如下输出：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">set: [a, b, world, c, d, e, f, g, hello, welcome]</span><br><span class="line">characteristics invoked!</span><br><span class="line">supplier invoked!</span><br><span class="line">-----------</span><br><span class="line">accumulator invoked!</span><br><span class="line">accumulator: [], main</span><br><span class="line">accumulator: [hello], main</span><br><span class="line">accumulator: [hello], ForkJoinPool.commonPool-worker-1</span><br><span class="line">accumulator: [hello, welcome], ForkJoinPool.commonPool-worker-4</span><br><span class="line">accumulator: [hello, welcome], ForkJoinPool.commonPool-worker-3</span><br><span class="line">accumulator: [hello, welcome], main</span><br><span class="line">accumulator: [a, b, d, f, hello, welcome], main</span><br><span class="line">accumulator: [a, b, d, hello, welcome], ForkJoinPool.commonPool-worker-3</span><br><span class="line">accumulator: [d, hello, welcome], ForkJoinPool.commonPool-worker-1</span><br><span class="line">accumulator: [a, b, world, d, f, g, hello, welcome], ForkJoinPool.commonPool-worker-3</span><br><span class="line">characteristics invoked!</span><br><span class="line">finisher invoked!</span><br><span class="line">&#123;a=a, b=b, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome, world=world&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果不加上<code>CONCURRENT</code>，由于操作的是多个容器，会调用多次<code>combiner</code>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span></span><br><span class="line">set: [a, b, world, c, d, e, f, g, hello, welcome]</span><br><span class="line">characteristics invoked!</span><br><span class="line">supplier invoked!</span><br><span class="line">accumulator invoked!</span><br><span class="line">combiner invoked!</span><br><span class="line">characteristics invoked!</span><br><span class="line">-----------</span><br><span class="line">-----------</span><br><span class="line">-----------</span><br><span class="line">-----------</span><br><span class="line">accumulator: [], main</span><br><span class="line">accumulator: [], ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">-----------</span><br><span class="line">accumulator: [], ForkJoinPool.commonPool-worker-<span class="number">4</span></span><br><span class="line">accumulator: [], ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">-----------</span><br><span class="line">-----------</span><br><span class="line">accumulator: [], ForkJoinPool.commonPool-worker-<span class="number">5</span></span><br><span class="line">accumulator: [b], ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">accumulator: [f], ForkJoinPool.commonPool-worker-<span class="number">5</span></span><br><span class="line">set1: []</span><br><span class="line">accumulator: [], ForkJoinPool.commonPool-worker-<span class="number">4</span></span><br><span class="line">-----------</span><br><span class="line">accumulator: [d], ForkJoinPool.commonPool-worker-<span class="number">1</span></span><br><span class="line">set1: [welcome]</span><br><span class="line">set2: []</span><br><span class="line">set2: [hello]</span><br><span class="line">accumulator: [b, world], ForkJoinPool.commonPool-worker-<span class="number">3</span></span><br><span class="line">set1: [hello]</span><br><span class="line">set1: [d, e]</span><br><span class="line">set2: [welcome]</span><br><span class="line">set1: [a]</span><br><span class="line">set2: [f, g]</span><br><span class="line">set2: [b, world, c]</span><br><span class="line">set1: [a, b, world, c]</span><br><span class="line">set2: [d, e, f, g]</span><br><span class="line">set1: [a, b, world, c, d, e, f, g]</span><br><span class="line">set2: [hello, welcome]</span><br><span class="line">characteristics invoked!</span><br><span class="line">finisher invoked!</span><br><span class="line">&#123;a=a, b=b, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome, world=world&#125;</span><br></pre></td></tr></table></figure><p></p><p>从结果中可以看出，生成了多个中间容器，执行了多次<code>combiner</code>。</p><p><br></p><h2 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h2><blockquote><p>A sequence of elements supporting sequential and parallel aggregate operations. The following example illustrates an aggregate operation using Stream and IntStream:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="keyword">int</span> sum = widgets.stream()</span><br><span class="line">&gt;                   .filter(w -&gt; w.getColor() == RED)</span><br><span class="line">&gt;                   .mapToInt(w -&gt; w.getWeight())</span><br><span class="line">&gt;                   .sum();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>In this example, widgets is a <code>Collection&lt;Widget&gt;</code>. We create a stream of Widget objects via Collection.stream(), filter it to produce a stream containing only the red widgets, and then transform it into a stream of int values representing the weight of each red widget. Then this stream is summed to produce a total weight.</p><p>In addition to Stream, which is a stream of object references, there are primitive specializations for IntStream, LongStream, and DoubleStream, all of which are referred to as “streams” and conform to the characteristics and restrictions described here.</p><p>To perform a computation, stream operations are compose d into a stream pipeline. A stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more intermediate operations (which transform a stream into another stream, such as filter(Predicate)), and a terminal operation (which produces a result or side-effect, such as count() or forEach(Consumer)). Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed.<br>side-effect指的是在流执行过程中可对源数据的状态做出修改。side-effect是不被推荐使用的。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;String&gt; results = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">stream.filter(s -&gt; pattern.matcher(s).matches())</span><br><span class="line">    .forEach(s -&gt; results.add(s));  <span class="comment">// Unnecessary use of side-effects!</span></span><br></pre></td></tr></table></figure><p></p></blockquote><blockquote><p>Collections and streams, while bearing some superficial similarities, have different goals. Collections are primarily concerned with the efficient management of, and access to, their elements. By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. However, if the provided stream operations do not offer the desired functionality, the iterator() and spliterator() operations can be used to perform a controlled traversal.<br>JDK8的Collection中多了一个方法：<code>Spliterator&lt;E&gt; spliterator()</code>。翻译为分割迭代器，顾名思义，这个方法是获得一个迭代器，而为什么不是返回<code>iterator</code>，而是要新创建一个类呢？这是为流的并行做准备，如果使用<code>iterator</code>，它是使用<code>hasNext</code>和<code>next</code>顺序遍历的，不方便我们将流直接分割成差不多的两部分。所以就引入了<code>Spliterator</code>。<br>A stream pipeline, like the “widgets” example above, can be viewed as a query on the stream source. Unless the source was explicitly designed for concurrent modification (such as a ConcurrentHashMap), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried.</p><p>Most stream operations accept parameters that describe user-specified behavior, such as the lambda expression w -&gt; w.getWeight() passed to mapToInt in the example above. To preserve correct behavior, these behavioral parameters:</p><ul><li>must be non-interfering (they do not modify the stream source); and</li><li>in most cases must be stateless (their result should not depend on any state that might change during execution of the stream pipeline).<br>如果源数据不是支持并发的容器，不要在流的执行期间修改源数据。否则会导致异常。但是在流执行之前修改是可以的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; l = <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="string">"one"</span>, <span class="string">"two"</span>));</span><br><span class="line">Stream&lt;String&gt; sl = l.stream();</span><br><span class="line">l.add(<span class="string">"three"</span>);</span><br><span class="line">String s = sl.collect(joining(<span class="string">" "</span>));</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>Such parameters are always instances of a functional interface such as Function, and are often lambda expressions or method references. Unless otherwise specified these parameters must be non-null.</p><p>A stream should be operated on (invoking an intermediate or terminal stream operation) only once. This rules out, for example, “forked” streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream. A stream implementation may throw IllegalStateException if it detects that the stream is being reused. However, since some stream operations may return their receiver rather than a new stream object, it may not be possible to detect reuse in all cases.</p><p>Streams have a close() method and implement AutoCloseable, but nearly all stream instances do not actually need to be closed after use. Generally, only streams whose source is an IO channel (such as those returned by Files.lines(Path, Charset)) will require closing. Most streams are backed by collections, arrays, or generating functions, which require no special resource management. (If a stream does require closing, it can be declared as a resource in a try-with-resources statement.)</p><p>Stream pipelines may execute either sequentially or in parallel. This execution mode is a property of the stream. Streams are created with an initial choice of sequential or parallel execution. (For example, Collection.stream() creates a sequential stream, and Collection.parallelStream() creates a parallel one.) This choice of execution mode may be modified by the sequential() or parallel() methods, and may be queried with the isParallel() method.</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;初识Stream&quot;&gt;&lt;a href=&quot;#初识Stream&quot; class=&quot;headerlink&quot; title=&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>01.06-JavaSE-Java8-3</title>
    <link href="https://isjinhao.github.io/posts/65180.html/"/>
    <id>https://isjinhao.github.io/posts/65180.html/</id>
    <published>2019-12-24T12:30:05.000Z</published>
    <updated>2019-12-30T13:20:35.670Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="分割迭代器"><a href="#分割迭代器" class="headerlink" title="分割迭代器"></a>分割迭代器</h2><blockquote><p>An object for traversing and partitioning elements of a source. The source of elements covered by a Spliterator could be, for example, an array, a Collection, an IO channel, or a generator function.<br>A Spliterator may traverse elements individually (tryAdvance()) or sequentially in bulk （散装的）(forEachRemaining()).</p></blockquote><p><strong><code>tryAdvance()</code></strong></p><p>If a remaining element exists, performs the given action on it, returning true; else returns false. If this Spliterator is ORDERED the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller. （为了更好的解释，我们顺便看一下<code>Collection</code>的实现，下同）<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;? extends T&gt; collection; <span class="comment">// null OK</span></span><br><span class="line"><span class="keyword">private</span> Iterator&lt;? extends T&gt; it;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="keyword">null</span>) &#123;</span><br><span class="line">        it = collection.iterator();</span><br><span class="line">        est = (<span class="keyword">long</span>) collection.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (it.hasNext()) &#123;</span><br><span class="line">        action.accept(it.next());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong><code>forEachRemaining()</code></strong></p><p>Performs the given action for each remaining element, sequentially in the current thread, until all elements have been processed or the action throws an exception. If this Spliterator is ORDERED, actions are performed in encounter order. Exceptions thrown by the action are relayed to the caller.<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;? extends T&gt; collection; <span class="comment">// null OK</span></span><br><span class="line"><span class="keyword">private</span> Iterator&lt;? extends T&gt; it;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> est;             <span class="comment">// size estimate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Iterator&lt;? extends T&gt; i;</span><br><span class="line">    <span class="keyword">if</span> ((i = it) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        i = it = collection.iterator();</span><br><span class="line">        est = (<span class="keyword">long</span>)collection.size();</span><br><span class="line">    &#125;</span><br><span class="line">    i.forEachRemaining(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><blockquote><p>A Spliterator may also partition off some of its elements (using trySplit) as another Spliterator, to be used in possibly-parallel operations. Operations using a Spliterator that cannot split, or does so in a highly imbalanced or inefficient manner, are unlikely to benefit from parallelism. Traversal and splitting exhaust elements; each Spliterator is useful for only a single bulk computation.</p></blockquote><p><strong><code>estimateSize()</code></strong></p><p>Returns an estimate of the number of elements that would be encountered by a forEachRemaining traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute.<br>If this Spliterator is SIZED and has not yet been partially traversed or split, or this Spliterator is SUBSIZED and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of trySplit.<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">estimateSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="keyword">null</span>) &#123;</span><br><span class="line">        it = collection.iterator();</span><br><span class="line">        <span class="keyword">return</span> est = (<span class="keyword">long</span>)collection.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> est;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong><code>trySplit()</code></strong></p><p>If this spliterator can be partitioned, returns a Spliterator covering elements, that will, upon return from this method, not be covered by this Spliterator.<br>If this Spliterator is ORDERED, the returned Spliterator must cover a strict prefix of the elements.<br>Unless this Spliterator covers an infinite number of elements, repeated calls to trySplit() must eventually return null. Upon non-null return:</p><ul><li>the value reported for estimateSize() before splitting, must, after splitting, be greater than or equal to estimateSize() for this and the returned Spliterator; and</li><li>if this Spliterator is SUBSIZED, then estimateSize() for this spliterator before splitting must be equal to the sum of estimateSize() for this and the returned Spliterator after splitting.<br>This method may return null for any reason, including emptiness, inability to split after traversal has commenced, data structure constraints, and efficiency considerations.<br>Returns: a Spliterator covering some portion of the elements, or null if this spliterator cannot be split<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> BATCH_UNIT = <span class="number">1</span> &lt;&lt; <span class="number">10</span>;  <span class="comment">// batch array size increment</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_BATCH = <span class="number">1</span> &lt;&lt; <span class="number">25</span>;  <span class="comment">// max batch array size;</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> est;             <span class="comment">// size estimate</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> batch;            <span class="comment">// batch size for splits</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Spliterator&lt;T&gt; <span class="title">trySplit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Iterator&lt;? extends T&gt; i;</span><br><span class="line">    <span class="keyword">long</span> s;<span class="comment">// collection 的 size</span></span><br><span class="line">    <span class="keyword">if</span> ((i = it) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        i = it = collection.iterator();</span><br><span class="line">        s = est = (<span class="keyword">long</span>) collection.size();</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        s = est;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">1</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">int</span> n = batch + BATCH_UNIT;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; s)</span><br><span class="line">            n = (<span class="keyword">int</span>) s;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; MAX_BATCH)</span><br><span class="line">            n = MAX_BATCH;</span><br><span class="line">        Object[] a = <span class="keyword">new</span> Object[n];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123; </span><br><span class="line">            a[j] = i.next(); </span><br><span class="line">        &#125; <span class="keyword">while</span> (++j &lt; n &amp;&amp; i.hasNext());</span><br><span class="line">        batch = j;</span><br><span class="line">        <span class="keyword">if</span> (est != Long.MAX_VALUE)</span><br><span class="line">            est -= j;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArraySpliterator&lt;&gt;(a, <span class="number">0</span>, j, characteristics);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>对于<code>Collection</code>里面<code>trySplit()</code>的实现，第一次调用返回的分割迭代器覆盖$2^{10}$个元素，第二次调用返回的覆盖$2^{11}$个元素，第三次调用返回的覆盖$2^{12}$个元素，第n次调用返回的覆盖$2^{9+n}$的元素。</p><p><br></p><h2 id="构建-amp-执行流"><a href="#构建-amp-执行流" class="headerlink" title="构建&amp;执行流"></a>构建&amp;执行流</h2><p>我们下面通过一个例子来剖析，JDK是怎么构建&amp;执行流的。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    strings.add(<span class="string">"A123"</span>);</span><br><span class="line">    strings.add(<span class="string">"A12345"</span>);</span><br><span class="line">    strings.add(<span class="string">"B123"</span>);</span><br><span class="line">    strings.add(<span class="string">"B1234"</span>);</span><br><span class="line">    strings.stream()</span><br><span class="line">        .filter(s -&gt; s.startsWith(<span class="string">"A"</span>))</span><br><span class="line">        .map(item -&gt; item.length())</span><br><span class="line">        .forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>对于这个例子，他是调用Collection的<code>stream()</code>生成一个流：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">default</span> Spliterator&lt;E&gt; <span class="title">spliterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Spliterators.spliterator(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">default</span> Stream&lt;E&gt; <span class="title">stream</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;T&gt; Stream&lt;T&gt; stream(Spliterator&lt;T&gt; spliterator, boolean parallel) &#123;</span></span><br><span class="line">    <span class="keyword">return</span> StreamSupport.stream(spliterator(), <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>分割迭代器方法负责将一个源的数据划分开来。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">stream</span><span class="params">(Spliterator&lt;T&gt; spliterator, <span class="keyword">boolean</span> parallel)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(spliterator);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReferencePipeline.Head&lt;&gt;(spliterator,</span><br><span class="line">                                        StreamOpFlag.fromCharacteristics(spliterator),</span><br><span class="line">                                        parallel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这段代码中我们会发现，最终我们获得的流是<code>ReferencePipeline</code>的内部类<code>Head</code>。再深入去看，我们会发现有一个这样的继承体系，<a href="https://www.cnblogs.com/Dorae/p/7779246.html">图片来自</a>。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/ec50f054-7296-433b-8bc3-c430be612f02"></div><p>这个继承体系不是很难，很多都是在使用流的时候会被使用的类。<br>我们之前说过，一个流由一个源，0个或多个中间操作，以及一个终止操作构成。这个体系里的<code>XXXPipeline</code>便是中间操作。他们构成了一个管道。在管道中，<code>Head</code>，<code>StatelssOp</code>，<code>StatefulOp</code>三个是真正的代表中间操作的类。其中我们刚才看到的<code>Head</code>便表示管道的第一个操作，因为在其他的中间操作中，都有前驱和后继，但是对于<code>Head</code>，是只有后继，没有前驱，所以被单独列出来。<br>我们常用的<code>Stream</code>中的方法实际上是在<code>XXXPipeline</code>中被实现的，由于我们的例子是使用<code>ReferencePipeline</code>，所以我们下面就去看看这个类中是如何实现<code>filter</code>、<code>map</code>和<code>forEach</code>的。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Stream&lt;P_OUT&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> P_OUT&gt; predicate)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(predicate);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, P_OUT&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                         StreamOpFlag.NOT_SIZED) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;P_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">(<span class="keyword">long</span> size)</span> </span>&#123;</span><br><span class="line">                    downstream.begin(-<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">if</span> (predicate.test(u))</span><br><span class="line">                        downstream.accept(u);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    downstream.accept(mapper.apply(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> P_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">    evaluate(ForEachOps.makeRef(action, <span class="keyword">false</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显可以看到，中间操作和终止操作的实现有很大的不同。至此，我们可以画一个图来表示这个过程。</p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/f841e7ca-5736-4105-b917-11cc2bc05feb"></div><p>但是我们现在还不知道这个流管道是怎么被串联起来的。所以我们接着分析。<br>我们进入<code>StatelessOp</code>的构造方法中，一路向下跟进：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">StatelessOp(AbstractPipeline&lt;?, E_IN, ?&gt; upstream,</span><br><span class="line">            StreamShape inputShape,</span><br><span class="line">            <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">    <span class="keyword">super</span>(upstream, opFlags);</span><br><span class="line">    <span class="keyword">assert</span> upstream.getOutputShape() == inputShape;</span><br><span class="line">&#125;</span><br><span class="line">ReferencePipeline(AbstractPipeline&lt;?, P_IN, ?&gt; upstream, <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">    <span class="keyword">super</span>(upstream, opFlags);</span><br><span class="line">&#125;</span><br><span class="line">AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, <span class="keyword">int</span> opFlags) &#123;</span><br><span class="line">    <span class="keyword">if</span> (previousStage.linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    previousStage.linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line">    previousStage.nextStage = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">this</span>.previousStage = previousStage;</span><br><span class="line">    <span class="keyword">this</span>.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK;</span><br><span class="line">    <span class="keyword">this</span>.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags);</span><br><span class="line">    <span class="keyword">this</span>.sourceStage = previousStage.sourceStage;</span><br><span class="line">    <span class="keyword">if</span> (opIsStateful())</span><br><span class="line">        sourceStage.sourceAnyStateful = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.depth = previousStage.depth + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>跟到了<code>AbstractPipeline</code>的构造方法中，我们才发现，<code>AbstractPipeline</code>中有三个属性：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbstractPipeline sourceStage;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The "upstream" pipeline, or null if this is the source stage.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AbstractPipeline previousStage;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * The next stage in the pipeline, or null if this is the last stage.</span></span><br><span class="line"><span class="comment">  * Effectively final at the point of linking to the next pipeline.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="keyword">private</span> AbstractPipeline nextStage;</span><br></pre></td></tr></table></figure><p></p><p>看到这里我们就会发现，管道和管道之间的链接是使用双向链表的方式进行的。同时，每个非<code>Head</code>管道，都有一个指向<code>Head</code>的引用。这样我们就可以将上面的图再具体一些：</p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/1d36c6a1-831c-4d1a-84fa-92a2117f3fcb"></div><p>看到这里我们就知道中间操作的流管道是怎么被串联起来的，但是终止操作是怎么和中间操作联系到一起的呢？所以我们需要看<code>forEach</code>方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> P_OUT&gt; action)</span> </span>&#123;</span><br><span class="line">    evaluate(ForEachOps.makeRef(action, <span class="keyword">false</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这个方法中，我们先看内部的方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">TerminalOp&lt;T, Void&gt; <span class="title">makeRef</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">boolean</span> ordered)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(action);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForEachOp.OfRef&lt;&gt;(action, ordered);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个方法是一个工厂方法，负责构建一个<code>TerminalOp</code>类的对象，这个类一看类名就知道他是一个终止操作。我们再向下跟进一层：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OfRef</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ForEachOp</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Consumer&lt;? <span class="keyword">super</span> T&gt; consumer;</span><br><span class="line">    OfRef(Consumer&lt;? <span class="keyword">super</span> T&gt; consumer, <span class="keyword">boolean</span> ordered) &#123;</span><br><span class="line">        <span class="keyword">super</span>(ordered);</span><br><span class="line">        <span class="keyword">this</span>.consumer = consumer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        consumer.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>我么会发现，<code>OfRef</code>这个类中保存我们传递给<code>forEach</code>的行为参数，也就是一个<code>Consumer</code>。<br>然后我们再看<code>evaluate()</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;R&gt; <span class="function">R <span class="title">evaluate</span><span class="params">(TerminalOp&lt;E_OUT, R&gt; terminalOp)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">assert</span> <span class="title">getOutputShape</span><span class="params">()</span> </span>== terminalOp.inputShape();</span><br><span class="line">    <span class="keyword">if</span> (linkedOrConsumed)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(MSG_STREAM_LINKED);</span><br><span class="line">    linkedOrConsumed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span> isParallel()</span><br><span class="line">        ? terminalOp.evaluateParallel(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()))</span><br><span class="line">        : terminalOp.evaluateSequential(<span class="keyword">this</span>, sourceSpliterator(terminalOp.getOpFlags()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这个方法接收一个<code>TerminalOp</code>。从他返回的结果来看，我们知道，这里是并行流和串行流执行的分叉的地方。并行流的分析很困难，作为理解<code>Stream</code>的原理，而不是真正从性能等角度考虑并行流和串行流的差异，我们便去看看串行流是怎么执行的，进而来理解<code>Stream</code>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;P_IN&gt; <span class="function">R <span class="title">evaluateSequential</span><span class="params">(PipelineHelper&lt;E_IN&gt; helper, Spliterator&lt;P_IN&gt; spliterator)</span></span>;</span><br></pre></td></tr></table></figure><p></p><p>这个方法是未被实现的方法，它需要<code>TerminalOp</code>的子类来决定它的行为到底是什么。同时可以看一下<code>evaluateParallel()</code>，这个方法被提供了一个默认实现，同时默认实现就是调用了一下串行的方法。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">default</span> &lt;P_IN&gt; <span class="function">R <span class="title">evaluateParallel</span><span class="params">(PipelineHelper&lt;E_IN&gt; helper,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Tripwire.ENABLED)</span><br><span class="line">        Tripwire.trip(getClass(), </span><br><span class="line">                      <span class="string">"&#123;0&#125; triggering TerminalOp.evaluateParallel serial default"</span>);</span><br><span class="line">    <span class="keyword">return</span> evaluateSequential(helper, spliterator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在找到<code>evaluateSequential()</code>的实现之前，我们先去看看<code>PipelineHelper</code>，这个类的注释如下：</p><blockquote><p>Helper class for executing stream pipelines, capturing all of the information about a stream pipeline (output shape, intermediate operations, stream flags, parallelism, etc) in one place.</p><p>A PipelineHelper describes the initial segment of a stream pipeline, including its source, intermediate operations, and may additionally incorporate information about the terminal (or stateful) operation which follows the last intermediate operation described by this PipelineHelper. The PipelineHelper is passed to the TerminalOp.evaluateParallel(PipelineHelper, Spliterator), TerminalOp.evaluateSequential(PipelineHelper, Spliterator), and AbstractPipeline.opEvaluateParallel(PipelineHelper, Spliterator, IntFunction), methods, which can use the PipelineHelper to access information about the pipeline such as head shape, stream flags, and size, and use the helper methods such as wrapAndCopyInto(Sink, Spliterator), copyInto(Sink, Spliterator), and wrapSink(Sink) to execute pipeline operations.<br>注释中说，这个类捕获中间操作、流的flags、是否并行等。但是仅仅看注释其实我们是看不懂的，不过从后面的我们的分析可以得到，它封装了关于求值的方法。同时<code>AbstractPipeline</code>继承了<code>PipelineHelper</code>。这个类的命名个人很难接受，因为感觉类的功能和类名完全没有联系，如果改为<code>computeHelper</code>反而更好理解。不过这已无关紧要。<br>我们下面来寻找<code>evaluateSequential()</code>的实现类。在上面的分析中，我们知道，传递给<code>evaluate()</code>方法的实际上是<code>OfRef</code>类，而<code>OfRef</code>又继承了<code>ForEachOp</code>，同时在其中有如下的实现：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;S&gt; <span class="function">Void <span class="title">evaluateSequential</span><span class="params">(PipelineHelper&lt;T&gt; helper, Spliterator&lt;S&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper.wrapAndCopyInto(<span class="keyword">this</span>, spliterator).get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><p>很显然，直接跟进去<code>wrapAndCopyInto()</code>又是一个待实现的方法。所以我们又要回溯，一致回溯到<code>evaluate()</code>，可以发现，我们传递进去的<code>helper</code>是<code>AbstractPipeline</code>的对象。在这个类中，我们找到了如下实现：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;P_IN, S extends Sink&lt;E_OUT&gt;&gt; <span class="function">S <span class="title">wrapAndCopyInto</span><span class="params">(S sink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator);</span><br><span class="line">    <span class="keyword">return</span> sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这里我们遇到了之前见过但是没有分析的接口<code>Sink</code>。在哪见得呢？在<code>filter()</code>和<code>map()</code>的实现中。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> P_OUT, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(mapper);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> StatelessOp&lt;P_OUT, R&gt;(<span class="keyword">this</span>, StreamShape.REFERENCE,</span><br><span class="line">                                     StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function">Sink&lt;P_OUT&gt; <span class="title">opWrapSink</span><span class="params">(<span class="keyword">int</span> flags, Sink&lt;R&gt; sink)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">                    downstream.accept(mapper.apply(u));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在创建<code>StatelessOp</code>的对象时，我们覆盖了<code>opWrapSink()</code>方法，这个方法返回一个<code>Sink</code>。什么是<code>Sink</code>？<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Sink</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt; </span>&#123;....&#125;</span><br></pre></td></tr></table></figure><p></p><p>从定义上来看，它是继承了<code>Consumer</code>的一个接口。我们一般管道的每一段称为一个<code>Stage</code>。从我们上一张图中可以看见，<code>Stage</code>之间是通过双向链表连接起来的，但是我们却没有说每一段的行为是怎么被保存的。而怎么保存以及后续怎么调用便是由<code>Sink</code>来完成。<br><code>Sink</code>它也是一个<code>Consumer</code>，但是比普通的<code>Comsumer</code>多了一些功能，JDK注释如下：</p><blockquote><p>An extension of Consumer used to conduct values through the stages of a stream pipeline, with additional methods to manage size information, control flow, etc. Before calling the accept() method on a Sink for the first time, you must first call the begin() method to inform it that data is coming (optionally informing the sink how much data is coming), and after all data has been sent, you must call the end() method. After calling end(), you should not call accept() without again calling begin(). Sink also offers a mechanism by which the sink can cooperatively signal that it does not wish to receive any more data (the cancellationRequested() method), which a source can poll before sending more data to the Sink.<br>A sink may be in one of two states: an initial state and an active state. It starts out in the initial state; the begin() method transitions it to the active state, and the end() method transitions it back into the initial state, where it can be re-used. Data-accepting methods (such as accept() are only valid in the active state.<br>看到这里，我们知道了<code>Sink</code>的作用是进行流中元素的控制的，比如将一个<code>Consumer</code>转为两个阶段：初始阶段和激活阶段。但是总感觉还是很迷，这种操作有什么用呢？直接使用<code>Consumer</code>不行吗？在我们继续分析之前，我们将上面的那张图再做一下更新。</p></blockquote><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/edbd1b1d-0050-426c-a1ce-1f3b86b53240"></div><p>在图中，向下的箭头表示包含的意思。<br>到了这里，我们便可以继续分析<code>wrapAndCopyInto()</code>。同时我们在<code>ForEachOp</code>中发现在调用这个方法的时候传的参数是<code>this</code>。这个<code>this</code>指的是<code>OfRef</code>的对象，也就是一个终止操作的对象。<br>再向下跟进，我们就进入了<code>wrapSink()</code><br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function">Sink&lt;P_IN&gt; <span class="title">wrapSink</span><span class="params">(Sink&lt;E_OUT&gt; sink)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(sink);</span><br><span class="line">    <span class="keyword">for</span> (AbstractPipeline p=AbstractPipeline.<span class="keyword">this</span>; p.depth &gt; <span class="number">0</span>; p=p.previousStage) &#123;</span><br><span class="line">        sink = p.opWrapSink(p.previousStage.combinedFlags, sink);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (Sink&lt;P_IN&gt;) sink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>其中的<code>AbstractPipeline.this</code>就是我们最后一个<code>ReferencePipeline</code>，这个对象有指针指向前面的<code>Stage</code>。<br>此时我们就可以分析一下<code>opWrapSink()</code>，它是每一个Stream里面供我们使用的操作都会去覆盖的方法，它返回一个<code>ChainedReference</code>，这个类里面有一个属性<code>Sink</code>，他是下游的<code>Sink</code>，也就是说在每个Sink里都会存在一个指向下游<code>Sink</code>的引用。<br>当我们第一次执行上面的代码的时候<code>sink</code>是终止操作，<code>p</code>是<code>MapSink</code>；当我们第而次执行上面的代码的时候<code>sink</code>是<code>MapSink</code>，<code>p</code>是<code>FileterSink</code>。所以当这段代码执行完成的时候我们上面的所以<code>Sink</code>对象会被关联起来，按照我们的例子，应该有下图：</p><div align="center"><img width="40%" src="http://blogfileqiniu.isjinhao.site/d7b67844-4874-4630-82e8-11afc0c402cd"></div><p>Sink组装好了之后便会调用<code>copyInto()</code>：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> &lt;P_IN&gt; <span class="function"><span class="keyword">void</span> <span class="title">copyInto</span><span class="params">(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(wrappedSink);</span><br><span class="line">    <span class="keyword">if</span> (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123;</span><br><span class="line">        wrappedSink.begin(spliterator.getExactSizeIfKnown());</span><br><span class="line">        spliterator.forEachRemaining(wrappedSink);</span><br><span class="line">        wrappedSink.end();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyIntoWithCancel(wrappedSink, spliterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>在这段代码中我们可以看到，如果不包含短路操作，便执行<code>spliterator.forEachRemaining(wrappedSink);</code>，我们以<code>Collection</code>的<code>spliterator</code>为例，看看最终是怎么执行的。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    Iterator&lt;? extends T&gt; i;</span><br><span class="line">    <span class="keyword">if</span> ((i = it) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        i = it = collection.iterator();</span><br><span class="line">        est = (<span class="keyword">long</span>)collection.size();</span><br><span class="line">    &#125;</span><br><span class="line">    i.forEachRemaining(action);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAdvance</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (action == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">if</span> (it == <span class="keyword">null</span>) &#123;</span><br><span class="line">        it = collection.iterator();</span><br><span class="line">        est = (<span class="keyword">long</span>) collection.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (it.hasNext()) &#123;</span><br><span class="line">        action.accept(it.next());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们有一个元素，设置item。item首先会进入<code>FilterSink</code>，在其中执行：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (predicate.test(u))</span><br><span class="line">        downstream.accept(u);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>如果<code>test</code>为真，调用下游的Sink；下游的Sink是<code>MapSink</code>，此时执行：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(P_OUT u)</span> </span>&#123;</span><br><span class="line">    downstream.accept(mapper.apply(u));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>这段代码中先执行<code>mapper.apply(u)</code>，然后执行<code>downstream.accept</code>，而此时的<code>downstream</code>是<code>ForEachSink</code>；然后就会执行<code>OfRef</code>的：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    consumer.accept(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>此时的<code>consumer</code>是<code>System.out.println</code>，最终输出结果。<br>至此，流的执行分解完成。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;分割迭代器&quot;&gt;&lt;a href=&quot;#分割迭代器&quot; class=&quot;headerlink&quot; title=&quot;分割迭代器&quot;
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>01.08-JavaSE-集合-2</title>
    <link href="https://isjinhao.github.io/posts/45270.html/"/>
    <id>https://isjinhao.github.io/posts/45270.html/</id>
    <published>2019-12-24T12:30:05.000Z</published>
    <updated>2019-12-30T13:20:35.694Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="HashMap分析"><a href="#HashMap分析" class="headerlink" title="HashMap分析"></a>HashMap分析</h2><p>HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。<br>JDK8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。</p><p><br></p><h3 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h3><h4 id="JDK8之前"><a href="#JDK8之前" class="headerlink" title="JDK8之前"></a>JDK8之前</h4><p>JDK8 之前 HashMap 底层是数组和链表结合在一起使用也就是链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p><strong>JDK 8 HashMap 的 hash 方法源码:</strong></p><p>JDK 8 的 hash方法 相比于 JDK 7 hash 方法更加简化，但是原理不变。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> h;</span><br><span class="line">      <span class="comment">// key.hashCode()：返回散列值也就是hashcode</span></span><br><span class="line">      <span class="comment">// ^ ：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p></p><p>对比一下 JDK7的 HashMap 的 hash 方法源码.<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// This function ensures that hashCodes that differ only by</span></span><br><span class="line">    <span class="comment">// constant multiples at each bit position have a bounded</span></span><br><span class="line">    <span class="comment">// number of collisions (approximately 8 at default load factor).</span></span><br><span class="line">    h ^= (h &gt;&gt;&gt; <span class="number">20</span>) ^ (h &gt;&gt;&gt; <span class="number">12</span>);</span><br><span class="line">    <span class="keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="number">7</span>) ^ (h &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>相比于 JDK8 的 hash 方法 ，JDK7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。<br>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><h4 id="JDK8之后"><a href="#JDK8之后" class="headerlink" title="JDK8之后"></a>JDK8之后</h4><p>相比于之前的版本，JDK8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/7ee8821a-5b6f-4dfa-b9d3-a1c7861a03b9"></div><p><strong>类的属性：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;    </span><br><span class="line">    <span class="comment">// 默认的初始容量是16</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;   </span><br><span class="line">    <span class="comment">// 最大容量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; </span><br><span class="line">    <span class="comment">// 默认的填充因子</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; </span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>; </span><br><span class="line">    <span class="comment">// 当桶(bucket)上的结点数小于这个值时树转链表</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>; </span><br><span class="line">    <span class="comment">// 桶中结构转化为红黑树对应的table的最小大小</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>; </span><br><span class="line">    <span class="comment">// 存储元素的数组，总是2的幂次倍</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;k,v&gt;[] table; </span><br><span class="line">    <span class="comment">// 存放具体元素的集</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">// 存放元素的个数，注意这个不等于数组的长度。</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">// 每次扩容和更改map结构的计数器</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;   </span><br><span class="line">    <span class="comment">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">// 加载因子</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>loadFactor加载因子</strong></p><p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于1，那么 数组中存放的数据（entry）也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于0，数组中存放的数据（entry）也就越少，也就越稀疏。<br>loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。<br>给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><p><strong>threshold</strong></p><p><strong>threshold = capacity * loadFactor</strong>，<strong>当Size&gt;=threshold</strong>的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 <strong>衡量数组是否需要扩增的一个标准</strong>。</p><p><strong>Node节点类源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 继承自 Map.Entry&lt;K,V&gt;</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span></span><br><span class="line">       <span class="keyword">final</span> K key;<span class="comment">//键</span></span><br><span class="line">       V value;<span class="comment">//值</span></span><br><span class="line">       <span class="comment">// 指向下一个节点</span></span><br><span class="line">       Node&lt;K,V&gt; next;</span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line">        <span class="comment">// 重写hashCode()方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 重写 equals() 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>树节点类源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    TreeNode&lt;K,V&gt; parent;  <span class="comment">// 父</span></span><br><span class="line">    TreeNode&lt;K,V&gt; left;    <span class="comment">// 左</span></span><br><span class="line">    TreeNode&lt;K,V&gt; right;   <span class="comment">// 右</span></span><br><span class="line">    TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">    <span class="keyword">boolean</span> red;           <span class="comment">// 判断颜色</span></span><br><span class="line">    TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回根节点</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> TreeNode&lt;K,V&gt; <span class="title">root</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TreeNode&lt;K,V&gt; r = <span class="keyword">this</span>, p;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((p = r.parent) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="HashMap源码分析"><a href="#HashMap源码分析" class="headerlink" title="HashMap源码分析"></a>HashMap源码分析</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认构造函数。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all   other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 包含另一个“Map”的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);<span class="comment">//下面会分析到这个方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定“容量大小”的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 指定“容量大小”和“加载因子”的构造函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> + initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> + loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>putMapEntries方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 判断table是否已经初始化</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="comment">// 未初始化，s为m的实际元素个数</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                    (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="comment">// 计算得到的t大于阈值，则初始化阈值</span></span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已初始化，并且m元素个数大于阈值，进行扩容处理</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">// 将m中的所有元素添加至HashMap中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p><p><strong>对putVal方法添加元素的分析如下：</strong></p><ul><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。</li></ul><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/54155875-a838-4535-bb55-3abc56d84b7a"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">// table未初始化或者长度为0，进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 桶中已经存在元素</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="comment">// 将第一个元素赋值给e，用e来记录</span></span><br><span class="line">                e = p;</span><br><span class="line">        <span class="comment">// hash值不相等，即key不相等；为红黑树结点</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">            <span class="comment">// 放入树中</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="comment">// 为链表结点</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 在链表最末插入结点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="comment">// 到达链表的尾部</span></span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 在尾部插入新结点</span></span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 结点数量达到阈值，转化为红黑树</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="comment">// 跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="comment">// 相等，跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span></span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; </span><br><span class="line">            <span class="comment">// 记录e的value</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">// onlyIfAbsent为false或者旧值为null</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//用新值替换旧值</span></span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">// 访问后回调</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="comment">// 返回旧值</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 结构性修改</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">// 实际大小大于阈值则扩容</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">// 插入后回调</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 数组元素相等</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">// 桶中不止一个节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 在树中get</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">// 在链表中get</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; </span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h4><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没超过最大值，就扩充为原来的2倍</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算新的resize上限</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ? (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 把每个bucket都移动到新的buckets中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; </span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="comment">// 原索引</span></span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">// 原索引+oldCap</span></span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="comment">// 原索引放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 原索引+oldCap放到bucket里</span></span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="HashMap常用方法测试"><a href="#HashMap常用方法测试" class="headerlink" title="HashMap常用方法测试"></a>HashMap常用方法测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMapDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="comment">// 键不能重复，值可以重复</span></span><br><span class="line">        map.put(<span class="string">"san"</span>, <span class="string">"张三"</span>);</span><br><span class="line">        map.put(<span class="string">"si"</span>, <span class="string">"李四"</span>);</span><br><span class="line">        map.put(<span class="string">"wu"</span>, <span class="string">"王五"</span>);</span><br><span class="line">        map.put(<span class="string">"wang"</span>, <span class="string">"老王"</span>);</span><br><span class="line">        map.put(<span class="string">"wang"</span>, <span class="string">"老王2"</span>);<span class="comment">// 老王被覆盖</span></span><br><span class="line">        map.put(<span class="string">"lao"</span>, <span class="string">"老王"</span>);</span><br><span class="line">        System.out.println(<span class="string">"-------直接输出hashmap:-------"</span>);</span><br><span class="line">        System.out.println(map);</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 遍历HashMap</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 1.获取Map中的所有键</span></span><br><span class="line">        System.out.println(<span class="string">"-------foreach获取Map中所有的键:------"</span>);</span><br><span class="line">        Set&lt;String&gt; keys = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys) &#123;</span><br><span class="line">            System.out.print(key+<span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 2.获取Map中所有值</span></span><br><span class="line">        System.out.println(<span class="string">"-------foreach获取Map中所有的值:------"</span>);</span><br><span class="line">        Collection&lt;String&gt; values = map.values();</span><br><span class="line">        <span class="keyword">for</span> (String value : values) &#123;</span><br><span class="line">            System.out.print(value+<span class="string">"  "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();<span class="comment">//换行</span></span><br><span class="line">        <span class="comment">// 3.得到key的值的同时得到key所对应的值</span></span><br><span class="line">        System.out.println(<span class="string">"-------得到key的值的同时得到key所对应的值:-------"</span>);</span><br><span class="line">        Set&lt;String&gt; keys2 = map.keySet();</span><br><span class="line">        <span class="keyword">for</span> (String key : keys2) &#123;</span><br><span class="line">            System.out.print(key + <span class="string">"："</span> + map.get(key)+<span class="string">"   "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 另外一种不常用的遍历方式</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 当我调用put(key,value)方法的时候，首先会把key和value封装到</span></span><br><span class="line">        <span class="comment">// Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取</span></span><br><span class="line">        <span class="comment">// map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来</span></span><br><span class="line">        <span class="comment">// 调用Entry对象中的getKey()和getValue()方法就能获取键值对了</span></span><br><span class="line">        Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">"--"</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * HashMap其他常用方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        System.out.println(<span class="string">"after map.size()："</span>+map.size());</span><br><span class="line">        System.out.println(<span class="string">"after map.isEmpty()："</span>+map.isEmpty());</span><br><span class="line">        System.out.println(map.remove(<span class="string">"san"</span>));</span><br><span class="line">        System.out.println(<span class="string">"after map.remove()："</span>+map);</span><br><span class="line">        System.out.println(<span class="string">"after map.get(si)："</span>+map.get(<span class="string">"si"</span>));</span><br><span class="line">        System.out.println(<span class="string">"after map.containsKey(si)："</span>+map.containsKey(<span class="string">"si"</span>));</span><br><span class="line">        System.out.println(<span class="string">"after containsValue(李四)："</span>+map.containsValue(<span class="string">"李四"</span>));</span><br><span class="line">        System.out.println(map.replace(<span class="string">"si"</span>, <span class="string">"李四2"</span>));</span><br><span class="line">        System.out.println(<span class="string">"after map.replace(si, 李四2):"</span>+map);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="equals-和hashCode"><a href="#equals-和hashCode" class="headerlink" title="equals()和hashCode()"></a>equals()和hashCode()</h2><p>Java 对于 eqauls 方法和 hashCode 方法是这样规定的：</p><ul><li>如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；</li><li>如果两个对象的 hashCode 相同，它们并不一定相同。</li></ul><p><br></p><h3 id="equals-需要满足的性质"><a href="#equals-需要满足的性质" class="headerlink" title="equals()需要满足的性质"></a>equals()需要满足的性质</h3><ul><li>自反性：x.equals(x)必须返回 true</li><li>对称性：x.equals(y)返回 true 时，y.equals(x)也必须返回 true</li><li>传递性：x.equals(y)和 y.equals(z)都返回 true 时，x.equals(z)也必须返回 true</li><li>一致性：当x 和 y 引用的对象信息没有被修改时，多次调用 x.equals(y)应该得到同样的返回值，</li><li>对于任何非 null 值的引用 x，x.equals(null)必须返回 false。</li></ul><p><br></p><h3 id="实现高质量的-equals"><a href="#实现高质量的-equals" class="headerlink" title="实现高质量的 equals ()"></a>实现高质量的 equals ()</h3><ul><li>使用==操作符检查”参数是否为这个对象的引用”；</li><li>使用 instanceof 操作符检查”参数是否为正确的类型”；</li><li>对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；</li><li>编写完 equals 方法后，问自己它是否满足对称性、传递性、一致性和空值返回false；</li><li>重写 equals 时总是要重写 hashCode；</li><li>不要将 equals 方法参数中的 Object 对象替换为其他的类型，在重写时不要忘掉@Override注解。</li></ul><p><br></p><h3 id="正确使用equals方法"><a href="#正确使用equals方法" class="headerlink" title="正确使用equals方法"></a>正确使用equals方法</h3><p>推荐使用：<code>Objects.equals(o1, o2)</code>，此方法的底层实现：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span></span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a>两者的关系</h3><p>在使用到哈希机制的集合时需要同时重写equles方法和hashCode方法。即重写对象的散列码是为了更好的支持基于哈希机制的Java集合类，例如 Hashtable, HashMap, HashSet 等，如果不重写hashCode()，在使用哈希机制的集合类时会出错。<br>当把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。但不同对象的hashCode可能重复，所以哈希机制的集合会在判断hashCode之后再判断一次equals。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"eee"</span>, <span class="number">100</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"eee"</span>, <span class="number">100</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">"aaa"</span>, <span class="number">200</span>);</span><br><span class="line">        Person p4 = <span class="keyword">new</span> Person(<span class="string">"EEE"</span>, <span class="number">100</span>);</span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line">        <span class="comment">// 打印set</span></span><br><span class="line">        System.out.printf(<span class="string">"set:%s\n"</span>, set);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> name.hashCode() ^ age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"Person [age="</span> + age + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;  </span><br><span class="line">            <span class="keyword">if</span>(obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;   <span class="comment">// 如果是同一个对象返回true，反之返回false  </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;  <span class="comment">// 判断是否类型相同  </span></span><br><span class="line">            Person person = (Person)obj;  </span><br><span class="line">            <span class="keyword">return</span> name.equals(person.name) &amp;&amp; age==person.age;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><br></p><h2 id="HashMap面试题"><a href="#HashMap面试题" class="headerlink" title="HashMap面试题"></a>HashMap面试题</h2><h3 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h3><p><strong>你看过HashMap源码嘛，知道原理嘛</strong></p><p>针对这个问题，嗯，当然是必须看过HashMap源码。至于原理：数组+链表+红黑树。<br>HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。</p><p><strong>为什么用数组+链表</strong></p><ul><li>数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到。</li><li>链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。</li></ul><p><strong>hash冲突你还知道哪些解决办法</strong></p><p>比较出名的有四种：开放定址法、链地址法、再哈希法、公共溢出区域法</p><p><strong>我用LinkedList代替数组结构可以吗</strong></p><p>这里我稍微说明一下，此题的意思是，源码中是这样的<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Entry[] table = <span class="keyword">new</span> Entry[capacity];</span><br></pre></td></tr></table></figure><p></p><p>那我用下面这样表示：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Entry&gt; table = <span class="keyword">new</span> LinkedList&lt;Entry&gt;();</span><br></pre></td></tr></table></figure><p></p><ol><li>是否可行？答案很明显，必须是可以的。</li><li>既然是可以的，为什么HashMap不用LinkedList，而选用数组？因为用数组效率最高！</li><li>在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。</li><li>那ArrayList，底层也是数组，查找也快啊，为啥不用ArrayList？因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。而ArrayList的扩容机制是1.5倍扩容，那ArrayList为什么是1.5倍扩容这就不在本文说明了。</li></ol><p><br></p><h3 id="HashMap在什么条件下扩容"><a href="#HashMap在什么条件下扩容" class="headerlink" title="HashMap在什么条件下扩容"></a>HashMap在什么条件下扩容</h3><p><strong>HashMap在什么条件下扩容</strong></p><p>如果bucket满了（超过load factor*current capacity），就要resize。默认load factor为0.75，为了最大程度避免哈希冲突。（current capacity为当前数组大小。</p><p><strong>为什么扩容是2的次幂</strong></p><blockquote><p>减少碰撞<br>HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；这个算法实际就是取模，<code>hash%length</code>。但是，大家都知道这种运算不如位移运算快。因此，源码中做了优化hash &amp; (length-1)。也就是说hash%length==hash&amp;(length-1)。那为什么是2的n次方呢？因为2的n次方实际就是1后面n个0，2的n次方-1，实际就是n个1。如果length不为2的幂，比如15。那么length-1的2进制就会变成1110。在h为随机数的情况下，和1110做&amp;操作。尾数永远为0。那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用。这样会造成浪费，不随机等问题。 length-1 二进制中为1的位数越多，那么分布就平均。<br>扩容时减少消耗<br>以下图为例，其中图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，n代表length。</p></blockquote><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/4a797c59-9e7a-467f-af2a-60d383ee0e4b"></div><p>元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：</p><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/cdf8d043-e999-41b4-a6f7-d3bcfae06455"></div><p>resize过程中不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap“。</p><p><strong>hash方法为什么为什么要先高16位异或低16位再取模运算</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hashmap这么做，只是为了降低hash冲突的几率。打个比方，当我们的length为16的时候，哈希码对<code>16-1</code>做与操作，对于多个key生成的hashCode，只要哈希码的后4位为0，不论高位怎么变化，最终的结果均为0。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/08846864-a215-49cd-a4d0-9fa49fcf807c"></div><p>而加上高16位异或低16位的“扰动函数”后，结果如下：</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/7aaae50b-2d46-4a7c-9078-93e9af3041c5"></div><p>可以看到: 扰动函数优化前：1954974080 % 16 = 1954974080 &amp; (16 - 1) = 0 扰动函数优化后：1955003654 % 16 = 1955003654 &amp; (16 - 1) = 6 很显然，减少了碰撞的几率。</p><p><br></p><h3 id="讲讲hashmap的get-put的过程"><a href="#讲讲hashmap的get-put的过程" class="headerlink" title="讲讲hashmap的get/put的过程"></a>讲讲hashmap的get/put的过程</h3><p><strong>知道hashmap中put元素的过程是什么样么</strong></p><ul><li>对key的hashCode()做hash运算，计算index</li><li>如果没碰撞直接放到bucket里；</li><li>如果碰撞了，以链表的形式存在buckets后；</li><li>如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树</li><li>如果节点已经存在就替换old value(保证key的唯一性)</li><li>如果bucket满了(超过load factor*current capacity)，就要resize。</li></ul><p><strong>知道hashmap中get元素的过程是什么样么</strong></p><ul><li>对key的hashCode()做hash运算，计算index;</li><li>如果在bucket里的第一个节点里直接命中，则直接返回；</li><li>如果有冲突，则通过key.equals(k)去查找对应的Entry;<ul><li>若为树，则在树中通过key.equals(k)查找，O(logn)；</li><li>若为链表，则在链表中通过key.equals(k)查找，O(n)。</li></ul></li></ul><p><strong>你还知道哪些hash算法</strong></p><p>先说一下hash算法干嘛的，Hash函数是指把一个大范围映射到一个小范围。把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。比较出名的有MurmurHash、MD4、MD5等等。</p><p><strong>说说String中hashcode的实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = hash;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="number">0</span> &amp;&amp; value.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">char</span> val[] = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; value.length; i++) &#123;</span><br><span class="line">            h = <span class="number">31</span> * h + val[i];</span><br><span class="line">        &#125;</span><br><span class="line">        hash = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是以31为权，每一位为字符的ASCII值进行运算。哈希计算公式可以计为<code>s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]</code>那为什么以31为质数呢？主要是因为31是一个奇质数，所以<code>31*i=32*i-i=(i&lt;&lt;5)-i</code>，这种位移与减法结合的计算相比一般的运算快很多。</p><p><br></p><h3 id="hashmap的在链表元素数量超过8时改为红黑树"><a href="#hashmap的在链表元素数量超过8时改为红黑树" class="headerlink" title="hashmap的在链表元素数量超过8时改为红黑树"></a>hashmap的在链表元素数量超过8时改为红黑树</h3><p><strong>知道jdk1.8中hashmap改了啥么</strong></p><ul><li>由<strong>数组+链表</strong>的结构改为<strong>数组+链表+红黑树</strong>。</li><li>优化了高位运算的hash算法：h ^ (h&gt;&gt;&gt;16)</li><li>扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。</li></ul><p><strong>为什么转红黑树的阈值是8</strong></p><p>红黑树和链表相比，红黑树在增加时的成本很高，但查询时的成本低，链表查询的成本高，增加的成本低，所以链表转红黑树最好的时机是当转为红黑树后基本不再发生增加操作。为了求在什么时候应当把链表转为红黑树，我们先把问题转换一下，原始的问题应当是：<strong>单位桶里插入多少个节点时应该由链表转为红黑树？</strong>转化后的问题是：<strong>单位桶里插入$k$个节点后再插入节点的概率是多少？</strong>进一步转化这个问题可得：<strong>单位桶里插入的节点的个数小于等于$k$时的概率是多少？</strong>而这个问题又可以转为：<strong>单位桶里插入$k$个节点的概率为多少（$q = 1, 2, 3 …$）？</strong><br>假设插入3个数据，<strong>每个桶</strong>的插入过程抽象为一根线段，把这段时间用$T$来表示：</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/e51962a1-76a5-4d31-86c4-6ae370a5a9ab"></div><p>我们把$T$分为4个时间段：</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/4b9d53c0-1a55-49d3-b156-856398575da9"></div><p>此时，在每一个时间段上，要不没有插入，要不有插入。这样$T$内插入3个数据的概率就符合二项分布。我们再假设每个时间段上发生插入的概率是$p$，可得：$C_{4}^{3}p^3(1-p)^1$。<br>我们把$T$划分的越来越细时（设为$n$），插入$k$个数据的概率为：$\lim\limits_{n \to \infty}C_{n}^{k}p^k(1-p)^{n-k}$。而$p$实际上等于发生插入的次数（$\mu$）除以总次数，即$p=\mu/n$。<br>$n$趋近于无穷大时可得：<br>$$<br>\begin{aligned} \lim _{n \rightarrow \infty}\left(\begin{array}{c}{n} \ {k}\end{array}\right)\left(\frac{\mu}{n}\right)^{k}\left(1-\frac{\mu}{n}\right)^{n-k} &amp;=\lim _{n \rightarrow \infty} \frac{n(n-1)(n-2) \cdots(n-k+1)}{k !} \frac{\mu^{k}}{n^{k}}\left(1-\frac{\mu}{n}\right)^{n-k} \ &amp;=\lim _{n \rightarrow \infty} \frac{\mu^{k}}{k !} \frac{n}{n} \cdot \frac{n-1}{n} \cdots \frac{n-k+1}{n}\left(1-\frac{\mu}{n}\right)^{-k}\left(1-\frac{\mu}{n}\right)^{n} \end{aligned}<br>$$<br>其中：<br>$$<br>\lim _{n \rightarrow \infty} \frac{n}{n} \cdot \frac{n-1}{n} \cdots \frac{n-k+1}{n}\left(1-\frac{\mu}{n}\right)^{-k}=1<br>$$<br>$$<br>\lim _{n \rightarrow \infty}\left(1-\frac{\mu}{n}\right)^{n}=e^{-\mu}<br>$$<br>所以：<br>$$<br>\lim _{n \rightarrow \infty}\left(\begin{array}{l}{n} \ {k}\end{array}\right)\left(\frac{\mu}{n}\right)^{k}\left(1-\frac{\mu}{n}\right)^{n-k}=\frac{\mu^{k}}{k !} e^{-\mu}<br>$$<br>上面就是泊松分布的概率密度函数，正好对应了JDK里的注释。即单位桶里插入$k$个元素的概率符合泊松分布。这个时候我们需要求得就的就是$\mu$了。而$\mu$就是发生插入的次数。<br>假设HashMap的大小为$x$，LOAD_FACTOR为$k$，容量的最小值约为$x/k$。 容量的最大值约为$2<em>x/k$（容量必须为2的幂，所以大约为2）。因此容量的平均值为$3x/2k$。 泊松分布的期望值为$x/(3x/2k)=2k/3$。当LOAD_FACTOR为DEFAULT_LOAD_FACTOR = 0.75时。 预期值为2 </em>0.75 / 3 = 0.5。所以每个桶里插入$k$个数据的概率符合参数为0.5的泊松分布。即可以得到如下的结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0:    0.60653066</span><br><span class="line">1:    0.30326533</span><br><span class="line">2:    0.07581633</span><br><span class="line">3:    0.01263606</span><br><span class="line">4:    0.00157952</span><br><span class="line">5:    0.00015795</span><br><span class="line">6:    0.00001316</span><br><span class="line">7:    0.00000094</span><br><span class="line">8:    0.00000006</span><br></pre></td></tr></table></figure><p></p><p>所以当插入8个数据后再插入到此桶的概率基本为0。符合转为红黑树后基本不再发生增加操作这个条件。</p><p><strong>当链表转为红黑树后，什么时候退化为链表</strong></p><p>为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。</p><p><br></p><h3 id="HashMap的key"><a href="#HashMap的key" class="headerlink" title="HashMap的key"></a>HashMap的key</h3><p><strong>键可以为null值么</strong></p><p>必须可以，key为null的时候，hash算法最后的值以0来计算，也就是放在数组的第一个位置。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>你一般用什么作为HashMap的key</strong></p><p>一般用Integer、String这种不可变类当HashMap当key，而且String最为常用。</p><ul><li>因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。</li><li>因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的覆写了hashCode()以及equals()方法。</li></ul><p><strong>我用可变类当HashMap的key有什么问题</strong></p><p>hashcode可能发生改变，导致put进去的值，无法get出，如下所示：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;List&lt;String&gt;, Object&gt; changeMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="string">"hello"</span>);</span><br><span class="line">Object objectValue = <span class="keyword">new</span> Object();</span><br><span class="line">changeMap.put(list, objectValue);</span><br><span class="line">System.out.println(changeMap.get(list));</span><br><span class="line">list.add(<span class="string">"hello world"</span>);<span class="comment">//hashcode发生了改变</span></span><br><span class="line">System.out.println(changeMap.get(list));</span><br></pre></td></tr></table></figure><p></p><p><strong>如果让你实现一个自定义的class作为HashMap的key该如何实现</strong></p><p>此题考察两个知识点</p><ul><li>重写hashcode和equals方法注意什么?</li><li>如何设计一个不变类<br>针对问题一，记住下面四个原则即可</li><li>两个对象相等，hashcode一定相等</li><li>两个对象不等，hashcode不一定不等</li><li>hashcode相等，两个对象不一定相等</li><li>hashcode不等，两个对象一定不等<br>针对问题二，记住如何写一个不可变类</li><li>类添加final修饰符，保证类不被继承。如果类可以被继承会破坏类的不可变性机制，只要继承类覆盖父类的方法并且继承类可以改变成员变量值，那么一旦子类以父类的形式出现时，不能保证当前类是否可变。</li><li>保证所有成员变量必须私有，并且加上final修饰。通过这种方式保证成员变量不可改变。但只做到这一步还不够，因为如果是对象成员变量有可能再外部改变其值。所以第4点弥补这个不足。</li><li>不提供改变成员变量的方法，包括setter避免通过其他接口改变成员变量的值，破坏不可变特性。</li><li><p>通过构造器初始化所有成员，进行深拷贝(deep copy)，如果构造器传入的对象直接赋值给成员变量，还是可以通过对传入对象的修改进而导致改变内部变量的值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ImmutableDemo</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] myArray;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ImmutableDemo</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.myArray = array; <span class="comment">// wrong  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式不能保证不可变性，myArray和array指向同一块内存地址，用户可以在ImmutableDemo之外通过修改array对象的值来改变myArray内部的值。为了保证内部的值不被修改，可以采用深度copy来创建一个新内存保存传入的值。正确做法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MyImmutableDemo</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span>[] myArray;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyImmutableDemo</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.myArray = array.clone();   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝，这种做法也是防止对象外泄，防止通过getter获得内部可变成员对象后对成员变量直接操作，导致成员变量发生改变。</p></li></ul><p><strong>LOAD_FACTORY为什么是0.75</strong></p><p>在源码中只说了0.75是空间和时间的一个折中，越低则空间利用率越低，比如我们把值设置为0.5，起始的时候有16个桶，使用到8个桶的时候就扩充为32个桶，当使用到16个桶的时候扩充到64个桶…</p><p><br></p><h3 id="JDK7-中put会发生死循环的问题"><a href="#JDK7-中put会发生死循环的问题" class="headerlink" title="JDK7 中put会发生死循环的问题"></a>JDK7 中put会发生死循环的问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Entry[] newTable)</span> </span>&#123;</span><br><span class="line">    Entry[] src = table;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = newTable.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; src.length; j++) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; e = src[j];</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            src[j] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                Entry&lt;K,V&gt; next = e.next;</span><br><span class="line">                <span class="keyword">int</span> i = indexFor(e.hash, newCapacity);<span class="comment">// 计算新的索引位置</span></span><br><span class="line">                e.next = newTable[i];</span><br><span class="line">                newTable[i] = e;</span><br><span class="line">                e = next;</span><br><span class="line">            &#125; <span class="keyword">while</span> (e != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码会将一个旧的哈希表映射到新的哈希表上，每个节点的key都会进行重新的Hash</span></span><br><span class="line"><span class="comment">// 但是在遍历的时候会从一个桶向后做next。即新插入的在resize的时候后插入到新桶中</span></span><br><span class="line"><span class="comment">// 这种转了个圈的方法在并发的时候会产生死循环</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;HashMap分析&quot;&gt;&lt;a href=&quot;#HashMap分析&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>01.09-JavaSE-集合-3</title>
    <link href="https://isjinhao.github.io/posts/57414.html/"/>
    <id>https://isjinhao.github.io/posts/57414.html/</id>
    <published>2019-12-24T12:30:05.000Z</published>
    <updated>2019-12-30T13:20:35.705Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h3><p>由于红黑树是二叉查找树的平衡模式，所以在了解红黑树之前，咱们先来看下二叉查找树。<br>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree），排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：</p><ul><li>若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>任意结点的左、右子树也分别为二叉查找树。</li><li>没有键值相等的结点（no duplicate nodes）。<br>因为，一棵由n个结点，随机构造的二叉查找树的高度为lgn，一般操作的执行时间为O（lgn）。但二叉树若退化成了一棵具有n个结点的线性链后，则此些操作最坏情况运行时间为O（n）。</li></ul><p><br></p><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>红黑树是一颗平衡二叉树，平衡二叉树的概念：每课树的左右子树高度差都不超过1。</p><ol><li>每个结点都有颜色，红色或者黑色</li><li>根结点是黑色的</li><li>每个叶结点是黑色的（设叶结点是NIL，但它不是一个空节点，是一个哨兵）</li><li>如果一个结点是红色的，则它的两个子结点都是黑色的</li><li>对每个结点，从该结点到其所有后代结点的简单路径上，均包含相同数目的黑色结点</li></ol><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/e0a29782-c0a9-4736-aada-c31acb92131f"></div><p>图中的NIL其实可以用一个哨兵（T.nil）替代，但在画图时往往其实不画NIL结点。</p><p><br></p><h3 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h3><p>对红黑树的增加和删除会破坏红黑树原本的性质，旋转是用来使其恢复到红黑树的手段。</p><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/69c29b47-b61e-47ae-ab11-e8a327ad3694"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LEFT-ROTATE(T, x)    设x是图中的pivot</span></span><br><span class="line">y = x.right</span><br><span class="line">x.right = y.left</span><br><span class="line"><span class="keyword">if</span> y.left != T.nil</span><br><span class="line">y.left.p = x</span><br><span class="line">y.p = x.p</span><br><span class="line"><span class="keyword">if</span> x.p == T.nil</span><br><span class="line">T.root = y</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> x == x.p.left<span class="comment">// 判断应该放在P的左子树还是右子树上</span></span><br><span class="line">x.p.left = y</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    x.p.right = y</span><br><span class="line">y.left = x</span><br><span class="line">x.p = y</span><br></pre></td></tr></table></figure><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/b2c71757-8b47-4b5f-8b88-c5d7fb2570a6"></div><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RIGHT-ROTATE(T, x)    设x是图中的pivot</span></span><br><span class="line">y = x.left</span><br><span class="line">x.left = y.right</span><br><span class="line"><span class="keyword">if</span> y.right != T.nil</span><br><span class="line">y.right.p = x</span><br><span class="line">y.p = x.p</span><br><span class="line"><span class="keyword">if</span> x.p == T.nil</span><br><span class="line">T.root = y</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> x == x.p.right<span class="comment">// 判断应该放在P的左子树还是右子树上</span></span><br><span class="line">x.p.right = y</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    x.p.lrft = y</span><br><span class="line">y.right = x</span><br><span class="line">x.p = y</span><br></pre></td></tr></table></figure><p><br></p><h3 id="二叉查找树的插入"><a href="#二叉查找树的插入" class="headerlink" title="二叉查找树的插入"></a>二叉查找树的插入</h3><p>如果要在二叉查找树中插入一个结点，首先要查找到结点插入的位置，然后进行插入，假设插入的结点为z的话，插入的伪代码如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TREE-INSERT(T, z)</span></span><br><span class="line">y = T.nil</span><br><span class="line">x = T.root</span><br><span class="line"><span class="keyword">while</span> x != NIL</span><br><span class="line">y = x</span><br><span class="line"><span class="keyword">if</span> z.key &lt; x.key</span><br><span class="line">x = x.left</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">        x = x.right</span><br><span class="line">z.p = y</span><br><span class="line"><span class="keyword">if</span> y == NIL</span><br><span class="line">T.root = z              <span class="comment">// Tree T was empty</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z.key &lt; y.key</span><br><span class="line">y.left = z</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y.right = z</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="红黑树的插入"><a href="#红黑树的插入" class="headerlink" title="红黑树的插入"></a>红黑树的插入</h3><p>如果我们插入的是黑色节点，会违反了性质五，需要进行大规模调整，如果我们插入的是红色节点，那就只有在要插入节点的父节点也是红色的时候违反性质四或者是当插入的节点是根节点时，违反性质二，所以，我们把要插入的节点的颜色变成红色。仍然设被插入结点是z：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RB-INSERT(T, z)</span></span><br><span class="line">y = T.nil</span><br><span class="line">x = T.root</span><br><span class="line"><span class="keyword">while</span> x != T.nil</span><br><span class="line">y = x</span><br><span class="line"><span class="keyword">if</span> z.key &lt; x.key</span><br><span class="line">x = x.left</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x = x.right</span><br><span class="line">z.p = y</span><br><span class="line"><span class="keyword">if</span> y == T.nil</span><br><span class="line">T.root = z</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z.key &lt; y.key</span><br><span class="line">y.left = z</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    y.right = z</span><br><span class="line">z.left = T.nil</span><br><span class="line">z.right = T.nil</span><br><span class="line">z.color = RED</span><br><span class="line">RB-INSERT-FIXUP(T, z)</span><br></pre></td></tr></table></figure><p></p><p>我们把上面这段红黑树的插入代码，跟我们之前看到的二叉查找树的插入代码，可以看出，RB-INSERT(T, z)前面的16行代码基本就是二叉查找树的插入代码，然后第17-18行代码把z的左孩子、右孩子都赋为叶结点nil，第19行再把z结点着为红色，最后为保证红黑性质在插入操作后依然保持，调用一个辅助程序RB-INSERT-FIXUP来对结点进行重新着色，并旋转。 <strong>换言之</strong>：</p><ul><li>如果插入的是根结点，因为原树是空树，此情况只会违反性质2，所以直接把此结点涂为黑色。</li><li>如果插入的结点的父结点是黑色，由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时也是什么也不做。<br>但当遇到下述3种情况时需要修复：</li><li>插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色</li><li>插入修复情况2：当前结点的父结点是红色，叔叔结点是黑色，当前结点是其父结点的右子</li><li>插入修复情况3：当前结点的父结点是红色，叔叔结点是黑色，当前结点是其父结点的左子</li></ul><h4 id="修复"><a href="#修复" class="headerlink" title="修复"></a>修复</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T, z)</span><br><span class="line"><span class="keyword">while</span> z.p.color == RED</span><br><span class="line"><span class="keyword">if</span> z.p == z.p.p.left</span><br><span class="line">y = z.p.p.right<span class="comment">// 指向叔叔结点</span></span><br><span class="line"><span class="keyword">if</span> y.color == RED</span><br><span class="line">z.p.color = BLACK</span><br><span class="line">y.color = BLACK</span><br><span class="line">z.p.p.color = RED</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z == z.p.right</span><br><span class="line">z = z.p</span><br><span class="line">LEFT-ROTATE(T, z)</span><br><span class="line">        z.p.color = BLACK</span><br><span class="line">        z.p.p.color = RED</span><br><span class="line">        RIGHT-ROTATE(T, z.p.p)</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 与 if 对称，等下只分析if，不分析else</span></span><br><span class="line">y = z.p.p.left</span><br><span class="line"><span class="keyword">if</span> y.color == RED</span><br><span class="line">z.p.color = BLACK</span><br><span class="line">z.p.p.color = RED</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z == z.p.left</span><br><span class="line">z = z.p</span><br><span class="line">RIGHT-ROTATE(T, z)</span><br><span class="line">        z.p.color = BLACK</span><br><span class="line">        z.p.p.color = RED</span><br><span class="line">        LEFT-ROTATE(T, z.p.p)</span><br><span class="line">T.root.color = BLACK</span><br></pre></td></tr></table></figure><p>下面，咱们来分别处理上述3种插入修复情况。</p><p><strong>插入修复情况1：当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色。</strong></p><p>上诉代码中第5行至第8行是处理这种情况：将父结点和叔叔结点涂黑，将爷爷结点涂红。</p><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/63d84e52-f4ca-4400-897a-1db3ae80e5ec"></div><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/a0275212-0d5d-4963-bddc-6b45b3bf3f5e"></div><p><strong>插入修复情况2：当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的右子</strong></p><p>上诉代码中第9行至第11行是处理这种情况：当前结点的父结点做为新的当前结点，以新当前结点为支点左旋。</p><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/6ae43f67-710e-4049-8a59-5eaf312d7e1c"></div><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/a4dd3504-6874-4770-8986-9af3d706b15f"></div><p><strong>插入修复情况3：当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的左子</strong></p><p>上述代码中的12-14行处理此种情况：父结点变为黑色，祖父结点变为红色，在祖父结点为支点右旋。</p><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/b6985972-466e-49d9-83fd-7e4de59d11c4"></div><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/84e1edc6-6bc1-4658-82c7-3d6dc78324b6"></div><p><br></p><h3 id="二叉查找树的后继"><a href="#二叉查找树的后继" class="headerlink" title="二叉查找树的后继"></a>二叉查找树的后继</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TREE-SUCCESSOR(x)</span></span><br><span class="line"><span class="keyword">if</span> x.right != T.nil</span><br><span class="line"><span class="keyword">return</span> TREE-MINIMUM(x.right)</span><br><span class="line">y = x.p</span><br><span class="line"><span class="keyword">while</span> y != T.nil and x == y.right</span><br><span class="line">x = y</span><br><span class="line">y = y.p</span><br><span class="line"><span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p>$x$是待查找结点，右子树不为空，右子树的最小值所在的节点是后继。解释第<code>4-8</code>行代码需要证明一个定理：</p><blockquote><p>对于一棵二叉搜索树T，其关键字各不相同，如果T中一个节点$x$的右子树为空，且$x$有一个后继$y$，那么$y$一定是$x$的最底层祖先，并且其左孩子也是$x$的祖先。（每个结点都是其自身的祖先）</p></blockquote><h4 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h4><p>对于给定结点$x$，若其后继$y$存在，则$y &gt; x$。</p><ol><li>考虑结点$x$，对于$x$的左子树，显然其中任意结点值都小于$x$，所以$y$必定不在其左子树中。</li><li>$x$的右子树，其中任意结点值都大于$x$,但是根据题设，其右子树为空。<br>所以，$y$必定为$x$的祖先或其祖先的右子树。<br>又因为$y$是其中大于$x$且最小的一个，则$y$不可能是其祖先的右子树，那么我们可以将范围缩小至$y$必定为$x$的某一祖先，又根据$y&gt;x$，则$x$必定在$y$的左子树中，即$y$的左孩子也是$x$的祖先（$x$也是$x$的祖先）<br>对于所有满足条件的，假设有$p_0,p_1 \dots p_n$共$n+1$个，且$p_0 &lt; p_1 &lt; p_2 &lt; \dots &lt; p_n$。显然，$x$的前驱结点$y$必定是其中的最小一个，即$y=p_0$。又因为$y$是$x$的祖先，则$y$必然是$x$的最底层祖先。</li></ol><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>这个定理实际的意义是，对于二叉搜索树中的一个节点（$x$），如果其不存在右子树且还有后继（$y$），则$y$是$x$祖先节点中有左子树的最底层祖先。如下图中13的后继是15。</p><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/15aa8eff-11ca-4da1-85bf-335305cd9ac3"></div><p><br></p><h3 id="二叉查找树的前驱"><a href="#二叉查找树的前驱" class="headerlink" title="二叉查找树的前驱"></a>二叉查找树的前驱</h3><p>前驱的代码和后继对应。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-PREDECESSOR(x)</span><br><span class="line"><span class="keyword">if</span> x.left != <span class="keyword">null</span></span><br><span class="line"><span class="keyword">return</span> TREE-MAXNUM(x.left);</span><br><span class="line">y = x.p</span><br><span class="line"><span class="keyword">while</span> y != <span class="keyword">null</span> and x == y.left</span><br><span class="line">x = y</span><br><span class="line">y = y.p</span><br><span class="line"><span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><p></p><p><code>3-7</code>行代码的意思是，对于二叉搜索树中的一个节点（$x$），如果其不存在左子树且还有前驱（$y$），则$y$是$x$祖先节点中有右子树的最底层祖先。如图中17的前驱是15。</p><p><br></p><h3 id="二叉查找树的删除"><a href="#二叉查找树的删除" class="headerlink" title="二叉查找树的删除"></a>二叉查找树的删除</h3><p>讨论删除之前需要证明一个定理：</p><blockquote><p>如果一个二叉搜索树中的一个节点有两个孩子，那么它的后继没有左孩子，它的前驱没有右孩子。</p></blockquote><p><strong>证明</strong></p><p>如果一棵二叉搜索树中的一个结点有两个孩子，那么它的后继为它的右子树中的最小值，所以它的后继没有左孩子，它的前驱为它的左子树中的最大值，所以它的前驱没有右孩子。</p><p><strong>删除时有三种情况：</strong></p><ol><li>如果被删除节点（$z$）没有孩子节点，直接删除，修改父节点相应指针指向空。</li><li>如果$z$只有一个孩子，把孩子提到树中$z$所在的位置，并修改$z$的父节点，用$z$的孩子来替换。</li><li>如果$z$有两个孩子，那么找$z$的后继$y$（一定在$z$的右子树中）。<ol><li>如果$y$是$z$的右孩子，用$y$替换$z$，同时留下$y$的右孩子。</li><li>如果$y$不是$z$的右孩子，有之上定理可知，$y$是没有左孩子的，此时用$y$的右孩子替换$y$，用$y$替换$z$，不留下$y$的右孩子。</li></ol></li></ol><h4 id="TRANSPLANT"><a href="#TRANSPLANT" class="headerlink" title="TRANSPLANT"></a>TRANSPLANT</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TRANSPLANT(T, u, v)</span></span><br><span class="line"><span class="keyword">if</span> u.p == T.nil</span><br><span class="line">T.root = v</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> u == u.p.left</span><br><span class="line">u.p.left = v</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">u.p.right = v</span><br><span class="line"><span class="keyword">if</span> v != T.nil</span><br><span class="line">v.p = u.p</span><br></pre></td></tr></table></figure><p><code>TRANSPLANT</code>的功能是在树$T$中用一棵以$v$为根的子树来替换一棵以$u$为根的子树。</p><ul><li><code>2-3</code>行：当$u$是树根的时候，直接让$T$的根指向$v$。</li><li><code>4-5</code>行：当$u$是一个左孩子的时候，将$v$放在$u$的左孩子的位置。</li><li><code>6</code>行：当$u$是一个右孩子的时候，将$v$放在$u$的右孩子的位置。</li><li><code>7-8</code>行：更新$v$的父节点。</li></ul><h4 id="TREE-DELETE"><a href="#TREE-DELETE" class="headerlink" title="TREE-DELETE"></a>TREE-DELETE</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TREE-DELETE(T, z)</span><br><span class="line"><span class="keyword">if</span> z.left == T.nil</span><br><span class="line">TRANSPLANT(T, z, z.right)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z.right == T.nil</span><br><span class="line">TRANSPLANT(T, z, z.left)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    y = TREE-MINIMUM(z.right)</span><br><span class="line"><span class="keyword">if</span> y.p != z</span><br><span class="line">TRANSPLANT(T, y, y.right)</span><br><span class="line">        y.right = z.right</span><br><span class="line">        y.right.p = y</span><br><span class="line">    TRANSPLANT(T, z, y)</span><br><span class="line">    y.left = z.left</span><br><span class="line">    y.left.p = y</span><br></pre></td></tr></table></figure><ol><li><code>2-5</code>行：如果$z$没有左孩子，那么用其右孩子替换$z$。如果$z$没有右孩子，那么用其左孩子替换$z$。</li><li><code>12-14</code>行：如果$y$是$z$的右孩子，用$y$替换$z$，同时留下$z$的左孩子。</li><li><code>7-11</code>行：如果如果$z$有两个孩子，且$y$不是$z$的右孩子，用$y$的右孩子替换$y$，用$y$替换$z$。</li></ol><div align="center"><img width="100%" src="http://blogfileqiniu.isjinhao.site/18039267-fd06-46a8-960b-3e969c28d4e7"></div><p><br></p><h3 id="红黑树的删除"><a href="#红黑树的删除" class="headerlink" title="红黑树的删除"></a>红黑树的删除</h3><p>红黑树的删除和二叉查找树的删除有类似的结构。</p><h4 id="RB-TRANSPLANT"><a href="#RB-TRANSPLANT" class="headerlink" title="RB-TRANSPLANT"></a>RB-TRANSPLANT</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RB-TRANSPLANT(T, u, v)</span></span><br><span class="line"><span class="keyword">if</span> u.p == T.nil</span><br><span class="line">T.root = v</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> u == u.p.left</span><br><span class="line">u.p.left = v</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">u.p.right = v</span><br><span class="line">v.p = u.p</span><br></pre></td></tr></table></figure><p>过程RB-TRANSPLANT与TRANSPLANT有一点不同，即第8行无条件赋值，因为红黑树中的哨兵不是空。</p><h4 id="RB-DELETE"><a href="#RB-DELETE" class="headerlink" title="RB-DELETE"></a>RB-DELETE</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RB-DELETE(T, z)</span></span><br><span class="line">y = z</span><br><span class="line">y-original-color = y.color<span class="comment">// 删除的结点的颜色</span></span><br><span class="line"><span class="keyword">if</span> z.left == T.nil<span class="comment">// 左子树为空，右子树直接上去</span></span><br><span class="line">x = z.right<span class="comment">// x指向被删除结点的右孩子</span></span><br><span class="line">RB-TRANSPLANT(T, z, z.right)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z.right == T.nil<span class="comment">// 右子树为空，右子树直接上去</span></span><br><span class="line">x = z.left</span><br><span class="line">RB-TRANSPLANT(T, z, z.left)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">y = TREE-MINIMUM(z.right)<span class="comment">// 右子树中最小的</span></span><br><span class="line">y-original-color = y.color<span class="comment">// 删除的节点的颜色</span></span><br><span class="line">x = y.right</span><br><span class="line"><span class="keyword">if</span> y.p == z</span><br><span class="line">x.p = y</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">RB-TRANSPLANT(T, y, y.right)<span class="comment">// 和二叉搜索树删除时第2、3点一致</span></span><br><span class="line">y.right = z.right</span><br><span class="line">y.right.p = y</span><br><span class="line">RB-TRANSPLANT(T, z, y)</span><br><span class="line">y.left = z.left</span><br><span class="line">y.left.p = y</span><br><span class="line">y.color = z.color</span><br><span class="line"><span class="keyword">if</span> y-original-color == BLACK<span class="comment">//当删除的是黑色时需要调整，红色不需要</span></span><br><span class="line">RB-DELETE-FIXUP(T, x)</span><br></pre></td></tr></table></figure><p>我们从被删结点后来顶替它的那个结点开始调整，并认为它有额外的一重黑色。这里额外一重黑色是什么意思呢，我们不是把红黑树的结点加上除红与黑的另一种颜色，这里只是一种假设，我们认为我们当前指向它，因此空有额外一种黑色，可以认为它的黑色是从它的父结点被删除后继承给它的，它现在可以容纳两种颜色，如果它原来是红色，那么现在是红+黑，如果原来是黑色，那么它现在的颜色是黑+黑。有了这重额外的黑色，原红黑树性质5就能保持不变。现在只要恢复其它性质就可以了，做法还是尽量向根移动和穷举所有可能性。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RB-DELETE-FIXUP(T, x)</span></span><br><span class="line"><span class="keyword">while</span> x != T.root and x.color == BLACK</span><br><span class="line"><span class="keyword">if</span> x == x.p.left</span><br><span class="line">w = x.p.right  <span class="comment">// 兄弟结点</span></span><br><span class="line"><span class="keyword">if</span> w.color == RED</span><br><span class="line">w.color = BLACK</span><br><span class="line">x.p.color = RED</span><br><span class="line">LEFT-ROTATE(T, x.p)</span><br><span class="line">            w = x.p.right</span><br><span class="line">        <span class="keyword">if</span> w.left.color == BLACK and w.right.color == BLACK</span><br><span class="line">        w.color = RED</span><br><span class="line">        x = x.p</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> w.right.color == BLACK</span><br><span class="line">        w.left.color = BLACK</span><br><span class="line">        w.color= RED</span><br><span class="line">        RIGHT-RATATE(T, w)</span><br><span class="line">            w = x.p.right</span><br><span class="line">        w.color = x.p.color</span><br><span class="line">        x.p.color = BLACK</span><br><span class="line">        w.right.color = BLACK</span><br><span class="line">        LEFT-ROTATE(T, x.p)</span><br><span class="line">        x = T.root</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">same as then clause with <span class="string">"right"</span> and <span class="string">"left"</span> exchanged</span><br><span class="line">x.color = BLACK</span><br></pre></td></tr></table></figure><p></p><p>（y是被删除的结点，x是怼上去的结点，即x占据了y的位置）<br>如果y的颜色是RED，则y不可能为红黑树的根，所以不管x的颜色是什么，都不会影响到红黑树的性质。所以只考虑y的颜色为BLACK的情况。<br>在y的颜色是BLACK的情况下，如果x的颜色为RED的话，删除y之后，结点y所在的分支的黑高就会减1，所以，只需要将x的颜色变为BLACK，则该分支的黑高会加1，则会保持住红黑树的颜色性质。</p><p><strong>所以最终要考虑的情况就是：</strong>y颜色为BLACK，x的颜色为BLACK的情况。因把y删除后，x顶替y的位置，y所在分支的黑高减1，所以，假设x节点的颜色为BLACK-BLACK，简称BB，也就是原来y的BLACK增加到x上了，这样就保证了该分支的黑高不变，接下来要做的就是调整x所在的分支，使红黑树的性质保持不变，又分为下面的几种情况（只考虑x为左孩子的情况，右孩子的情况是对称的）</p><p><strong>删除修复情况1：当前结点是黑+黑且兄弟结点为红色(此时父结点和兄弟结点的子结点为黑)。</strong></p><p>解法：把父结点染成红色，把兄弟结点染成黑色，左旋，之后重新进入算法。此变换后原红黑树性质5不变，而把问题转化为兄弟结点为黑色的情况(注：变化前，原本就未违反性质5，只是为了<strong>把问题转化为兄弟结点为黑色的情况</strong>)。 即第5行至第9行。</p><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/e10c53c8-d006-4b1b-9f40-7aca52707b66"></div><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/a668eb94-49be-4310-b64f-f0c663fe04e6"></div><p><strong>删除修复情况2：当前结点是黑加黑且兄弟是黑色且兄弟结点的两个子结点全为黑色。</strong></p><p>解法：把当前结点和兄弟结点中抽取一重黑色追加到父结点上，把父结点当成新的当前结点，重新进入算法。（此变换后性质5不变），即第10-12行代码操作。</p><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/2a6dd071-187e-468d-b83f-d46c584f6f30"></div><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/65b9b69a-53ae-46bc-8dae-d17b33ae3cfd"></div><p><strong>删除修复情况3：当前结点颜色是黑+黑，兄弟结点是黑色，兄弟的左子是红色，右子是黑色。</strong></p><p>解法：把兄弟结点染红，兄弟左子结点染黑，之后再以兄弟结点为支点解右旋，之后重新进入算法。此是把当前的情况转化为情况4，而性质5得以保持，即第13-17行代码：</p><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/67881a31-213e-4500-ba21-60edfba97d85"></div><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/487c48c9-f085-409e-b3df-5810d49123b1"></div><p><strong>删除修复情况4：当前结点颜色是黑-黑色，它的兄弟结点是黑色，但是兄弟结点的右子是红色，兄弟结点左子的颜色任意。</strong></p><p>解法：把兄弟结点染成当前结点父结点的颜色，把当前结点父结点染成黑色，兄弟结点右子染成黑色，之后以当前结点的父结点为支点进行左旋，此时算法结束，红黑树所有性质调整正确，即第18-22行代码，如下所示：</p><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/96a2ab00-d796-4cbf-9979-1710db3f287b"></div><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/330536ac-eeba-40e4-9fd1-ca230961671e"></div><p><br></p><h2 id="TreeMap分析"><a href="#TreeMap分析" class="headerlink" title="TreeMap分析"></a>TreeMap分析</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span></span><br><span class="line"><span class="class">    <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">NavigableMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure><p>在此分析一下Map的体系结构：</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/6ef892e1-3e35-47ff-8878-55d4e2c80266"></div><p>AbstractMap是一个实现Map接口的抽象类，它实现了一个Map的骨架，方便开发者来实现一个自己的Map。如果开发者需要实现一个自己的不可变的Map，只需要继承它再实现entrySet方法。如果开发者想需要实现一个自己的可变的Map，在不可变Map的基础上还需要实现put方法，并且在其的iterator上实现remove方法。<br>SortedMap是一个键有序的Map，存在Comparator时使用其规则，否则使用Comparable的规则。<br>NavigableMap是一个导航Map，它含有的方法可以帮助寻找一个键的上一个键，下一个键，或者按键值逆序等。</p><p><br></p><h3 id="旋转-1"><a href="#旋转-1" class="headerlink" title="旋转"></a>旋转</h3><h4 id="左旋-1"><a href="#左旋-1" class="headerlink" title="左旋"></a>左旋</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateLeft</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; r = p.right;</span><br><span class="line">        p.right = r.left;</span><br><span class="line">        <span class="keyword">if</span> (r.left != <span class="keyword">null</span>)</span><br><span class="line">            r.left.parent = p;</span><br><span class="line">        r.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = r;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.left == p)</span><br><span class="line">            p.parent.left = r;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = r;</span><br><span class="line">        r.left = p;</span><br><span class="line">        p.parent = r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="右旋-1"><a href="#右旋-1" class="headerlink" title="右旋"></a>右旋</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rotateRight</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; l = p.left;</span><br><span class="line">        p.left = l.right;</span><br><span class="line">        <span class="keyword">if</span> (l.right != <span class="keyword">null</span>) l.right.parent = p;</span><br><span class="line">        l.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = l;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.parent.right == p)</span><br><span class="line">            p.parent.right = l;</span><br><span class="line">        <span class="keyword">else</span> p.parent.left = l;</span><br><span class="line">        l.right = p;</span><br><span class="line">        p.parent = l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; t = root;</span><br><span class="line">    <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果实体不支持自然排序，有没有传入排序器，报异常。此行代码只做类型检查</span></span><br><span class="line">        compare(key, key); <span class="comment">// type (and possibly null) check</span></span><br><span class="line">        root = <span class="keyword">new</span> Entry&lt;&gt;(key, value, <span class="keyword">null</span>);</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cmp;</span><br><span class="line">    Entry&lt;K,V&gt; parent;</span><br><span class="line">    <span class="comment">// split comparator and comparable paths</span></span><br><span class="line">    Comparator&lt;? <span class="keyword">super</span> K&gt; cpr = comparator;</span><br><span class="line">    <span class="keyword">if</span> (cpr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = cpr.compare(key, t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)<span class="comment">// key &lt; t.key</span></span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)<span class="comment">// key &gt; t.key</span></span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);  <span class="comment">// key和t.key相等时覆盖</span></span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        Comparable&lt;? <span class="keyword">super</span> K&gt; k = (Comparable&lt;? <span class="keyword">super</span> K&gt;) key;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            parent = t;</span><br><span class="line">            cmp = k.compareTo(t.key);</span><br><span class="line">            <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">                t = t.left;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cmp &gt; <span class="number">0</span>)</span><br><span class="line">                t = t.right;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> t.setValue(value);</span><br><span class="line">        &#125; <span class="keyword">while</span> (t != <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// t为空时会走到此步，parent为最后一个经过的有数据的节点</span></span><br><span class="line">    Entry&lt;K,V&gt; e = <span class="keyword">new</span> Entry&lt;&gt;(key, value, parent);</span><br><span class="line">    <span class="keyword">if</span> (cmp &lt; <span class="number">0</span>)</span><br><span class="line">        parent.left = e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        parent.right = e;</span><br><span class="line">    fixAfterInsertion(e);</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;<span class="comment">// 返回的是旧的 value</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterInsertion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    x.color = RED;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="keyword">null</span> &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123;</span><br><span class="line">            <span class="comment">// y是x的叔叔结点</span></span><br><span class="line">            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色</span></span><br><span class="line">            <span class="comment">// 将父结点和叔叔结点涂黑，将爷爷结点涂红</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的右子</span></span><br><span class="line">            <span class="comment">// 当前结点的父结点做为新的当前结点，以新当前结点为支点左旋</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == rightOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateLeft(x);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当前结点的父结点是红色，叔叔结点是黑色，当前结点是其父结点的左子</span></span><br><span class="line">                <span class="comment">// 父结点变为黑色，祖父结点变为红色，在祖父结点为支点右旋</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateRight(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</span><br><span class="line">            <span class="comment">// 当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色</span></span><br><span class="line">            <span class="comment">// 将父结点和叔叔结点涂黑，将爷爷结点涂红</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(y) == RED) &#123;</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(y, BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                x = parentOf(parentOf(x));</span><br><span class="line">                </span><br><span class="line">            <span class="comment">// 当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的左子</span></span><br><span class="line">            <span class="comment">// 当前结点的父结点做为新的当前结点，以新当前结点为支点右旋</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">                    x = parentOf(x);</span><br><span class="line">                    rotateRight(x);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的左子</span></span><br><span class="line">                <span class="comment">// 父结点变为黑色，祖父结点变为红色，在祖父结点为支点左旋</span></span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(parentOf(parentOf(x)), RED);</span><br><span class="line">                rotateLeft(parentOf(parentOf(x)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root.color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Entry&lt;K,V&gt; p = getEntry(key);</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    V oldValue = p.value;</span><br><span class="line">    deleteEntry(p);</span><br><span class="line">    <span class="keyword">return</span> oldValue;<span class="comment">// 返回旧的value</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line">    <span class="comment">// If strictly internal, copy successor's element to p and then make p</span></span><br><span class="line">    <span class="comment">// point to successor.</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// s 是后继</span></span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// p 拷贝到 s</span></span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// p 现在指向需要被删除的结点</span></span><br><span class="line">        p = s;</span><br><span class="line">    &#125; <span class="comment">// p has 2 children</span></span><br><span class="line">    <span class="comment">// 到了这里，无论原始的p有无孩子，p都是被即将被删除的结点</span></span><br><span class="line">    <span class="comment">// Start fixup at replacement node, if it exists.</span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line">    <span class="comment">// replacement指向有数据的子树，设为R子树，此子树会替代原始的子树</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;<span class="comment">// 有孩子</span></span><br><span class="line">        <span class="comment">// Link replacement to parent</span></span><br><span class="line">        <span class="comment">// R子树的父亲指向即将被删除的结点的父亲</span></span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="comment">// 如果即将被删除的结点没有父亲（有孩子）</span></span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">       <span class="comment">// 把R子树挂上去</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">       <span class="comment">// 把R子树挂上去</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 到了这步，p已经被替换掉了。将其的连接结点都置空</span></span><br><span class="line">        <span class="comment">// Null out links so they are OK to use by fixAfterDeletion.</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// Fix replacement</span></span><br><span class="line">        <span class="comment">// R子树上去后，如果是删除的结点是黑色，需要调整</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    <span class="comment">// 和第39行的区别是：第39行的情况p是一个根结点，而此种情况就p这一个结点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">// return if we are the only node.</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 没有孩子，有父亲，是个叶结点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//  No children. Use self as phantom replacement and unlink.</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            <span class="comment">// 转下去分析修复</span></span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// x 是上一步的R子树</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 真正要修复的情况是：被删除的结点是黑色且升上去的结点也是黑色（此时黑高会减1）</span></span><br><span class="line">    <span class="comment">// 算法的目的是让x指向的那棵树是红结点且整棵树不违反红黑树的性质</span></span><br><span class="line">    <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 总共有四种违反红黑树性质的情况。</span></span><br><span class="line">        <span class="comment">// 若被删除的结点树红色，直接删除，无任何影响</span></span><br><span class="line">        <span class="comment">// 若被删除的结点是黑色，但是上来的结点是红色，直接将其染黑就行了</span></span><br><span class="line">        <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 当前结点是黑+黑且兄弟结点为红色（此时父结点和兄弟结点的子结点为黑）</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = rightOf(parentOf(x));</span><br><span class="line">            <span class="comment">// 把父结点染成红色，把兄弟结点染成黑色，左旋</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                <span class="comment">// 旋转不改变x的指向</span></span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                sib = rightOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// ---到了这步，x仍然指向这一轮迭代初的结点，sib会转为黑色</span></span><br><span class="line">            </span><br><span class="line"><span class="comment">// 兄弟结点的两个子结点全为黑色，兄弟结点染红</span></span><br><span class="line">            <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                <span class="comment">// 走到此步，退出循环，x此时为红色</span></span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 兄弟结点是黑色，兄弟的左子是红色，右子是黑色</span></span><br><span class="line">                <span class="comment">// 把兄弟结点染红，兄弟左子结点染黑，之后再以兄弟结点为支点解右旋</span></span><br><span class="line">                <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(leftOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateRight(sib);</span><br><span class="line">                    <span class="comment">// 调整兄弟结点的指向</span></span><br><span class="line">                    sib = rightOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 到了这步，兄弟结点是黑色，兄弟结点的右子是红色</span></span><br><span class="line">                <span class="comment">// 把兄弟结点染成当前结点父结点的颜色，把当前结点父结点染成黑色，</span></span><br><span class="line">                <span class="comment">// 兄弟结点右子染成黑色，之后以当前结点的父结点为支点进行左旋</span></span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(rightOf(sib), BLACK);</span><br><span class="line">                rotateLeft(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// symmetric</span></span><br><span class="line">            Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line">            <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                setColor(sib, BLACK);</span><br><span class="line">                setColor(parentOf(x), RED);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                sib = leftOf(parentOf(x));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                setColor(sib, RED);</span><br><span class="line">                x = parentOf(x);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                    setColor(rightOf(sib), BLACK);</span><br><span class="line">                    setColor(sib, RED);</span><br><span class="line">                    rotateLeft(sib);</span><br><span class="line">                    sib = leftOf(parentOf(x));</span><br><span class="line">                &#125;</span><br><span class="line">                setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                setColor(parentOf(x), BLACK);</span><br><span class="line">                setColor(leftOf(sib), BLACK);</span><br><span class="line">                rotateRight(parentOf(x));</span><br><span class="line">                x = root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    setColor(x, BLACK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="2-3树"><a href="#2-3树" class="headerlink" title="2-3树"></a>2-3树</h2><p>红黑树是目前在工程应用中被证实综合性能最好的平衡树，但是为什么它就是那么好的？实际上红黑树吸收了AVL树和2-3树的特点。对于AVL树，是历史上第一个被创造的平衡二叉树，也是一颗绝对符合平衡二叉树性质的树。红黑树吸收了它的旋转思想来调整红黑树的状态。对于2-3树，红黑树其实就等价于等价于2-3树。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/02fc799e-0209-4a6c-9e59-d22e20abfd70"></div><p>我们下面就分析2-3树。</p><p><br></p><h3 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a><strong>树的定义</strong></h3><p>2-3 树要么为空要么如下：</p><ul><li>对于 2- 节点，和普通的 BST 节点一样，有一个数据域和两个子节点指针，两个子节点要么为空，要么也是一个2-3树，当前节点的数据的值要大于左子树中所有节点的数据，要小于右子树中所有节点的数据。</li><li>对于 3- 节点，有两个数据域 a 和 b 和三个子节点指针，左子树中所有的节点数据要小于a，中子树中所有节点数据要大于 a 而小于 b ，右子树中所有节点数据要大于 b 。<br>性质：</li><li>对于每一个结点有 1 或者 2 个关键码。</li><li>当节点有一个关键码的时，节点有 2 个子树。</li><li>当节点有 2 个关键码时，节点有 3 个子树。</li><li>所有叶子点都在树的同一层。</li></ul><p><br></p><h3 id="2-3树查找"><a href="#2-3树查找" class="headerlink" title="2-3树查找"></a>2-3树查找</h3><p>2-3 树的查找类似二叉搜索树的查找过程，根据键值的比较来决定查找的方向。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/7a9975b2-b1e5-4e85-a3d8-373699586c8d"></div><p><br></p><h3 id="2-3树插入"><a href="#2-3树插入" class="headerlink" title="2-3树插入"></a>2-3树插入</h3><p>对于非空树插入主要分为 4 种情况：</p><ul><li>向2-节点中插入新节点</li><li>向一棵只含3-节点的树中插入新节点</li><li>向一个父节点为2-节点的3-节点中插入新节点</li><li>向一个父节点为3-节点的3-节点中插入新节点</li></ul><h4 id="向2-节点中插入新节点"><a href="#向2-节点中插入新节点" class="headerlink" title="向2-节点中插入新节点"></a>向2-节点中插入新节点</h4><p>操作步骤：如果未命中查找结束于一个2-节点，直接将2-节点替换为一个3-节点，并将要插入的键保存在其中。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/5dc4ca5b-97ff-4c4b-9ce7-65a8770fa19a"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/ce866562-a6c5-4760-acd1-d7881d6ddca6"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/8272d852-7b3c-43e9-a3f5-34201028cac7"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/1280f365-c4a0-4471-92f3-38f2b5b2c2b6"></div><h4 id="向一棵只含3-节点的树中插入新节点"><a href="#向一棵只含3-节点的树中插入新节点" class="headerlink" title="向一棵只含3-节点的树中插入新节点"></a>向一棵只含3-节点的树中插入新节点</h4><p>操作步骤：先临时将新键存入唯一的3-节点中，使其成为一个4-节点，再将它转化为一颗由3个2- 节点组成的2-3 树，分解后树高会增加1。</p><div align="center"><img width="35%" src="http://blogfileqiniu.isjinhao.site/46bb30b2-72c8-4561-8ab4-c0e02df8da4f"></div><h4 id="向一个父节点为2-节点的3-节点中插入新节点"><a href="#向一个父节点为2-节点的3-节点中插入新节点" class="headerlink" title="向一个父节点为2-节点的3-节点中插入新节点"></a>向一个父节点为2-节点的3-节点中插入新节点</h4><p>操作步骤：先构造一个临时的4-节点并将其分解，分解时将中键移动到父节点中（中键移动后，其父节点中的位置由键的大小确定）</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/62715daf-f79a-4d48-8a8d-b5b18a33a2a4"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/a2ac891e-2393-442e-aa26-baf4e11dcd45"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/6b339d72-ff4b-4fb4-8c8a-03a5fab7c8a5"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/d2c3c783-d561-429a-9403-760a5e980462"></div><h4 id="向一个父节点为3-节点的3-节点中插入新节点"><a href="#向一个父节点为3-节点的3-节点中插入新节点" class="headerlink" title="向一个父节点为3-节点的3-节点中插入新节点"></a>向一个父节点为3-节点的3-节点中插入新节点</h4><p>操作步骤：插入节点后一直向上分解构造的临时4-节点并将中键移动到更高层双亲节点，直到遇到一个2-节点并将其替换为一个不需要继续分解的3-节点，或是到达树根（3-节点）。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/54d169e0-f7b9-4f24-a91e-4f8dc47e4fc9"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/9e3c92ae-f6f3-4185-ac81-d5b4c5db196f"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/0830f682-8b41-4e99-ba94-bcf75bb977b8"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/d8909957-3511-4455-9d1d-583823f93eb2"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/d9479828-9eff-452c-989e-d6bf513c802a"></div><h4 id="分解根节点"><a href="#分解根节点" class="headerlink" title="分解根节点"></a>分解根节点</h4><p>操作步骤：如果从插入节点到根节点的路径上全是3-节点（包含根节点在内），根节点将最终被替换为一个临时的4-节点，将临时的4-节点分解为3个2-节点，分解后树高会增加1。</p><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/5f9b6cdd-7c80-4393-a1a7-95ee731442b6"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/be37d611-d780-422a-a4fd-27f090d424c7"></div><p><br></p><h3 id="2-3树删除"><a href="#2-3树删除" class="headerlink" title="2-3树删除"></a>2-3树删除</h3><p>删除之前，先要对2-3树进行一次命中的查找，查找成功才可以进行删除操作。删除节点大概分为3种情形</p><ul><li>删除非叶子节点。</li><li>删除不为2-节点的叶子节点。</li><li>删除为2-节点的叶子节点。</li></ul><h4 id="删除非叶子节点"><a href="#删除非叶子节点" class="headerlink" title="删除非叶子节点"></a>删除非叶子节点</h4><p>操作步骤：使用中序遍历下的直接后继节点key来覆盖当前待删除节点key，再删除用来覆盖的后继节点key。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/ee6d3217-afbf-4b0b-b8c9-ec7de920a6c7"></div><h4 id="删除不为2-节点的叶子节点"><a href="#删除不为2-节点的叶子节点" class="headerlink" title="删除不为2-节点的叶子节点"></a>删除不为2-节点的叶子节点</h4><p>操作步骤：删除不为2-节点的叶子节点，直接删除节点即可。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/c79107d2-9eb8-40e8-8d34-5eff0bb9e4ac"></div><h4 id="删除节点为2-节点，父节点为2-节点，兄弟节点为3-节点"><a href="#删除节点为2-节点，父节点为2-节点，兄弟节点为3-节点" class="headerlink" title="删除节点为2-节点，父节点为2-节点，兄弟节点为3-节点"></a>删除节点为2-节点，父节点为2-节点，兄弟节点为3-节点</h4><p>操作步骤：当前待删除节点的父节点是2-节点、兄弟节点是3-节点，将父节点移动到当前待删除节点位置，再将兄弟节点中最接近当前位置的key移动到父节点中。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/750377ce-94ff-4afb-9108-d7cfc23faabf"></div><h4 id="删除节点为2-节点，父节点为2-节点，兄弟节点为2-节点"><a href="#删除节点为2-节点，父节点为2-节点，兄弟节点为2-节点" class="headerlink" title="删除节点为2-节点，父节点为2-节点，兄弟节点为2-节点"></a>删除节点为2-节点，父节点为2-节点，兄弟节点为2-节点</h4><p>操作步骤：当前待删除节点的父节点是2-节点、兄弟节点也是2-节点，先通过移动兄弟节点的中序遍历直接后驱到兄弟节点，以使兄弟节点变为3-节点。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/109d04d5-7cca-4cd4-b7f5-36678cff9c2b"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/bf9bef8c-180a-439b-9912-b970209ecfbe"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/98055b64-8231-4e9c-a2bb-8a6032591433"></div><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/35273406-7c2b-4e28-a09c-67b891df51a2"></div><h4 id="删除节点为2-节点，父节点为3-节点"><a href="#删除节点为2-节点，父节点为3-节点" class="headerlink" title="删除节点为2-节点，父节点为3-节点"></a>删除节点为2-节点，父节点为3-节点</h4><p>操作步骤：当前待删除节点的父节点是3-节点，拆分父节点使其成为2-节点，再将再将父节点中最接近的一个拆分key与中孩子合并，将合并后的节点作为当前节点。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/b7c34935-b732-4d83-a4e9-fd1ad03840b1"></div><h4 id="2-3树为满二叉树，删除叶子节点"><a href="#2-3树为满二叉树，删除叶子节点" class="headerlink" title="2-3树为满二叉树，删除叶子节点"></a>2-3树为满二叉树，删除叶子节点</h4><p>操作步骤：若2-3树是一颗满二叉树，将2-3树层树减少，并将当前删除节点的兄弟节点合并到父节点中，同时将父节点的所有兄弟节点合并到父节点的父节点中，如果生成了4-节点，再分解4-节点。</p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/755f55bc-b118-4852-b7c2-79242eb51955"></div><p><br></p><h3 id="如何理解红黑树"><a href="#如何理解红黑树" class="headerlink" title="如何理解红黑树"></a>如何理解红黑树</h3><p>对红黑树的每个结点，从该结点到其所有后代结点的简单路径上，均包含相同数目的黑色结点。也就是说其黑节点是一个绝对平衡的二叉树。所以整个树是不是平衡其实是看红色节点是不是产生了倾斜，但是有规定红节点的子节点是黑节点，确保整棵树不会偏的最狠，即使是红黑节点交叉的情况，双方的最大高度差值也是2倍，不会降为线性。为什么红节点的子节点全都是黑节点呢，因为如果不是，会产生红节点的儿子是红节点，红儿子的节点还是红节点的情况，最终一路红到底，破坏了性质5。<br>分析我们前面的代码会发现红黑树在插入删除的时候不需要进行递归，所以对红黑树的插入删除操作可以在O(1)的复杂度内完成。而AVL树最差的情况是O(lgn)。</p><p><br></p><h2 id="部分转至"><a href="#部分转至" class="headerlink" title="部分转至"></a>部分转至</h2><ul><li><a href="https://www.itcodemonkey.com/article/13495.html">https://www.itcodemonkey.com/article/13495.html</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;红黑树&quot;&gt;&lt;a href=&quot;#红黑树&quot; class=&quot;headerlink&quot; title=&quot;红黑树&quot;&gt;&lt;/a&gt;红
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>01.07-JavaSE-集合-1</title>
    <link href="https://isjinhao.github.io/posts/17059.html/"/>
    <id>https://isjinhao.github.io/posts/17059.html/</id>
    <published>2019-12-24T12:30:05.000Z</published>
    <updated>2019-12-30T13:20:35.683Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="集合概览"><a href="#集合概览" class="headerlink" title="集合概览"></a>集合概览</h2><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/f6aa99af-bd85-4f36-a113-c999a4eac0d4"></div><p><br></p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><ul><li><strong>Arraylist：</strong> Object数组</li><li><strong>Vector：</strong> Object数组，线程安全。</li><li><strong>LinkedList：</strong> 双向链表</li></ul><p><br></p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><strong>HashMap：</strong> JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li><li><strong>LinkedHashMap：</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li><li><strong>TreeMap：</strong> 红黑树</li></ul><p><br></p><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><ul><li><strong>HashSet（无序，唯一）:</strong> 基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li><strong>LinkedHashSet：</strong> LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</li><li><strong>TreeSet（有序，唯一）：</strong> 红黑树（自平衡的排序二叉树)</li></ul><p><br></p><h2 id="ArrayList分析"><a href="#ArrayList分析" class="headerlink" title="ArrayList分析"></a>ArrayList分析</h2><p><strong>ArrayList有三种方式来初始化，构造方法源码如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认初始容量大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认构造函数，使用初始容量10构造一个空列表(无参数构造)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 带初始容量参数的构造函数。（用户自己指定容量）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;<span class="comment">// 初始容量大于0</span></span><br><span class="line">        <span class="comment">// 创建initialCapacity大小的数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;<span class="comment">// 初始容量等于0</span></span><br><span class="line">        <span class="comment">//创建空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">// 初始容量小于0，抛出异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+ initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回</span></span><br><span class="line"><span class="comment">* 如果指定的集合为null，throws NullPointerException。 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>细心的同学一定会发现 ：<strong>以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</strong> 下面在我们分析 ArrayList 扩容时会讲到这一点内容！</p><p><br></p><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将指定的元素追加到此列表的末尾。 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 添加元素之前，先调用ensureCapacityInternal方法</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// 这里看到ArrayList添加元素的实质就相当于为数组赋值</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="ensureCapacityInternal"><a href="#ensureCapacityInternal" class="headerlink" title="ensureCapacityInternal()"></a>ensureCapacityInternal()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当我们要 add 进第1个元素到 ArrayList 时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。elementData.length 为0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code>不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。<br>直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。</li></ul><p><br></p><h3 id="grow"><a href="#grow" class="headerlink" title="grow()"></a><code>grow()</code></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// oldCapacity为旧容量，newCapacity为新容量</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">// 将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span></span><br><span class="line">    <span class="comment">// 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">// 若新容量大于MAX_ARRAY_SIZE，执行hugeCapacity()方法来比较minCapacity和MAX_ARRAY_SIZE，</span></span><br><span class="line">    <span class="comment">// 若minCapacity大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 </span></span><br><span class="line">    <span class="comment">// MAX_ARRAY_SIZE 即为Integer.MAX_VALUE - 8。</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍！</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算，位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已，不去计算，这样提高了效率，节省了资源</p></blockquote><p><strong>我们再来通过例子探究一下grow() 方法 ：</strong></p><ul><li>当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为10，add方法中 return true,size增为1。</li><li>当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true，size增为11。</li><li>以此类推······<br>如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</li></ul><p><strong>这里补充一点比较重要，但是容易被忽视掉的知识点：</strong></p><ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><p><br></p><h3 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy()"></a>System.arraycopy()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在此列表中的指定位置插入指定的元素。 </span></span><br><span class="line"><span class="comment"> * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证</span></span><br><span class="line"><span class="comment"> * capacity足够大；再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">// arraycopy()方法实现数组自己复制自己</span></span><br><span class="line">    <span class="comment">// elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的</span></span><br><span class="line">    <span class="comment">// 起始位置； size - index：要复制的数组元素的数量；</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>, size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Arrays-copyOf"><a href="#Arrays-copyOf" class="headerlink" title="Arrays.copyOf()"></a>Arrays.copyOf()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">    <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    T[] copy = ((Object)newType == (Object)Object[].class)</span><br><span class="line">        ? (T[]) <span class="keyword">new</span> Object[newLength]</span><br><span class="line">        : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">    System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>, Math.min(original.length, newLength));</span><br><span class="line">    <span class="keyword">return</span> copy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人觉得使用 <code>Arrays.copyOf()</code>方法主要是为了给原有数组扩容。</p><p><br></p><h3 id="ensureCapacity"><a href="#ensureCapacity" class="headerlink" title="ensureCapacity"></a>ensureCapacity</h3><p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>   minCapacity   所需的最小容量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数</strong></p><p>我们通过下面的代码实际测试以下这个方法的效果：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnsureCapacityTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">ArrayList&lt;Object&gt; list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">10000000</span>;</span><br><span class="line"><span class="keyword">long</span> startTime = System.currentTimeMillis();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"使用ensureCapacity方法前："</span>+(endTime - startTime));</span><br><span class="line">list = <span class="keyword">new</span> ArrayList&lt;Object&gt;();</span><br><span class="line"><span class="keyword">long</span> startTime1 = System.currentTimeMillis();</span><br><span class="line">list.ensureCapacity(N);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">list.add(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> endTime1 = System.currentTimeMillis();</span><br><span class="line">System.out.println(<span class="string">"使用ensureCapacity方法后："</span>+(endTime1 - startTime1));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>运行结果：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">使用ensureCapacity方法前：4637</span><br><span class="line">使用ensureCapacity方法后：241</span><br></pre></td></tr></table></figure><p></p><p>通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p><p><br></p><h2 id="LinkedList分析"><a href="#LinkedList分析" class="headerlink" title="LinkedList分析"></a>LinkedList分析</h2><p>LinkedList是一个实现了List接口和Deque接口的双端链表。 LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性；LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List list = Collections.synchronizedList(<span class="keyword">new</span> LinkedList(...));</span><br></pre></td></tr></table></figure><p></p><p><br></p><h3 id="内部结构分析"><a href="#内部结构分析" class="headerlink" title="内部结构分析"></a>内部结构分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">E item;<span class="comment">//节点值</span></span><br><span class="line">    Node&lt;E&gt; next;<span class="comment">//后继节点</span></span><br><span class="line">    Node&lt;E&gt; prev;<span class="comment">//前驱节点</span></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.item = element;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">        <span class="keyword">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。</p><p><br></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><strong>空构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure><p><strong>用已有的集合创建链表的构造方法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h3><p><strong>add(E e)</strong> 方法：将元素添加到链表尾部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e); <span class="comment">// 这里就只调用了这一个方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 链接使e作为最后一个元素。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">    last = newNode; <span class="comment">// 新建节点</span></span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    l.next = newNode; <span class="comment">// 指向后继元素也就是指向下一个元素</span></span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>add(int index,E e)</strong>：在指定位置添加元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    checkPositionIndex(index); <span class="comment">// 检查索引是否处于[0-size]之间</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) <span class="comment">// 添加在链表尾部</span></span><br><span class="line">        linkLast(element);</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 添加在链表中间</span></span><br><span class="line">        linkBefore(element, node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>linkBefore方法需要给定两个参数，一个插入节点的值，一个指定的node，所以我们又调用了Node(index)去找到index对应的node</p><p><strong>addAll(Collection c )：将集合插入到链表尾部</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>addAll(int index, Collection c)：</strong> 将集合从指定位置开始插入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1:检查index范围是否在size之内</span></span><br><span class="line">    checkPositionIndex(index);</span><br><span class="line">    <span class="comment">// 2:toArray()方法把集合的数据存到对象数组中</span></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 3：得到插入位置的前驱节点和后继节点</span></span><br><span class="line">    Node&lt;E&gt; pred, succ;</span><br><span class="line">    <span class="comment">// 如果插入位置为尾部，前驱节点为last，后继节点为null</span></span><br><span class="line">    <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">        succ = <span class="keyword">null</span>;</span><br><span class="line">        pred = last;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则，调用node()方法得到后继节点，再得到前驱节点</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        succ = node(index);</span><br><span class="line">        pred = succ.prev;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 4：遍历数据将数据插入</span></span><br><span class="line">    <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">        <span class="comment">//创建新节点</span></span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">//如果插入位置在链表头部</span></span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        pred = newNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果插入位置在尾部，重置last节点</span></span><br><span class="line">    <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = pred;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//否则，将插入的链表与先前链表连接起来</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        pred.next = succ;</span><br><span class="line">        succ.prev = pred;</span><br><span class="line">    &#125;</span><br><span class="line">    size += numNew;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面可以看出addAll方法通常包括下面四个步骤：</p><ol><li>检查index范围是否在size之内</li><li>toArray()方法把集合的数据存到对象数组中</li><li>得到插入位置的前驱和后继节点</li><li>遍历数据，将数据插入到指定位置</li></ol><p><strong>addFirst(E e)：</strong> 将元素添加到链表头部</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkFirst(e);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(<span class="keyword">null</span>, e, f); <span class="comment">// 新建节点，以头节点为后继节点</span></span><br><span class="line">    first = newNode;</span><br><span class="line">    <span class="comment">// 如果链表为空，last节点也指向该节点</span></span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        last = newNode;</span><br><span class="line">    <span class="comment">// 否则，将头节点的前驱指针指向新节点，也就是指向前一个元素</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        f.prev = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>addLast(E e)：</strong> 将元素添加到链表尾部，与 <strong>add(E e)</strong> 方法一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="根据位置取数据的方法"><a href="#根据位置取数据的方法" class="headerlink" title="根据位置取数据的方法"></a>根据位置取数据的方法</h3><p><strong>get(int index)：</strong> 根据指定索引返回数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查index范围是否在size之内</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">//调用Node(index)去找到index对应的node然后返回它的值</span></span><br><span class="line">    <span class="keyword">return</span> node(index).item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>获取头节点（index=0）数据方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">element</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getFirst();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">return</span> (f == <span class="keyword">null</span>) ? <span class="keyword">null</span> : f.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>区别：</strong> getFirst()，element()，peek()，peekFirst() 这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中<strong>getFirst()</strong> 和<strong>element()</strong> 方法将会在链表为空时，抛出异常</p><p>element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException</p><p><strong>获取尾节点（index=-1）数据方法:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两者区别：</strong> <strong>getLast()</strong> 方法在链表为空时，会抛出<strong>NoSuchElementException</strong>，而<strong>peekLast()</strong> 则不会，只是会返回 <strong>null</strong>。</p><p><br></p><h3 id="根据对象得到索引的方法"><a href="#根据对象得到索引的方法" class="headerlink" title="根据对象得到索引的方法"></a>根据对象得到索引的方法</h3><p><strong>int indexOf(Object o)：</strong> 从头遍历找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从头遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从头遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>int lastIndexOf(Object o)：</strong> 从尾遍历找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index = size;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从尾遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 从尾遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">            index--;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="检查链表是否包含某对象的方法"><a href="#检查链表是否包含某对象的方法" class="headerlink" title="检查链表是否包含某对象的方法"></a>检查链表是否包含某对象的方法</h3><p><strong>contains(Object o)：</strong> 检查对象o是否存在于链表中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) != -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="删除方法"><a href="#删除方法" class="headerlink" title="删除方法"></a>删除方法</h3><p><strong>remove()</strong> ,<strong>removeFirst(),pop():</strong> 删除头节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeFirst();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>removeLast(),pollLast():</strong> 删除尾节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">return</span> (l == <span class="keyword">null</span>) ? <span class="keyword">null</span> : unlinkLast(l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>区别：</strong> removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。</p><p><strong>remove(Object o):</strong> 删除指定元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果删除对象为null</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 从头开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">// 找到元素</span></span><br><span class="line">            <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 从链表中移除找到的元素</span></span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//从头开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">            <span class="comment">//找到元素</span></span><br><span class="line">            <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                <span class="comment">//从链表中移除找到的元素</span></span><br><span class="line">                unlink(x);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。<br>unlink(Node x) 方法：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert x != null;</span></span><br><span class="line">    <span class="keyword">final</span> E element = x.item;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; next = x.next; <span class="comment">// 得到后继节点</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev; <span class="comment">// 得到前驱节点</span></span><br><span class="line">    <span class="comment">// 删除前驱指针</span></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        first = next; <span class="comment">// 如果删除的节点是头节点,令头节点指向该节点的后继节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = next; <span class="comment">// 将前驱节点的后继节点指向后继节点</span></span><br><span class="line">        x.prev = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除后继指针</span></span><br><span class="line">    <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        last = prev; <span class="comment">// 如果删除的节点是尾节点,令尾节点指向该节点的前驱节点</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.prev = prev;</span><br><span class="line">        x.next = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    x.item = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>remove(int index)</strong>：删除指定位置的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查index范围</span></span><br><span class="line">    checkElementIndex(index);</span><br><span class="line">    <span class="comment">// 将节点删除</span></span><br><span class="line">    <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="LinkedList类常用方法测试"><a href="#LinkedList类常用方法测试" class="headerlink" title="LinkedList类常用方法测试"></a>LinkedList类常用方法测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedListDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] srgs)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建存放int类型的linkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; linkedList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="comment">/************************** linkedList的基本操作 ************************/</span></span><br><span class="line">        linkedList.addFirst(<span class="number">0</span>); <span class="comment">// 添加元素到列表开头</span></span><br><span class="line">        linkedList.add(<span class="number">1</span>);     <span class="comment">// 在列表结尾添加元素</span></span><br><span class="line">        linkedList.add(<span class="number">2</span>, <span class="number">2</span>); <span class="comment">// 在指定位置添加元素</span></span><br><span class="line">        linkedList.addLast(<span class="number">3</span>); <span class="comment">// 添加元素到列表结尾</span></span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"LinkedList（直接输出的）: "</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">"getFirst()获得第一个元素: "</span> + </span><br><span class="line">                           linkedList.getFirst()); <span class="comment">// 返回此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"getLast()获得第最后一个元素: "</span> + </span><br><span class="line">                           linkedList.getLast()); <span class="comment">// 返回此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"removeFirst()删除第一个元素并返回: "</span> + </span><br><span class="line">                           linkedList.removeFirst()); <span class="comment">// 移除并返回此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"removeLast()删除最后一个元素并返回: "</span> + </span><br><span class="line">                           linkedList.removeLast()); <span class="comment">// 移除并返回此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"After remove:"</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">"contains()方法判断列表是否包含1这个元素:"</span> + </span><br><span class="line">                           linkedList.contains(<span class="number">1</span>)); <span class="comment">// 判断此列表包含指定元素，如果是则返回真</span></span><br><span class="line">        System.out.println(<span class="string">"该linkedList的大小 : "</span> +</span><br><span class="line">                           linkedList.size()); <span class="comment">// 返回此列表的元素个数</span></span><br><span class="line">        <span class="comment">/************************** 位置访问操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.set(<span class="number">1</span>, <span class="number">3</span>); <span class="comment">// 将此列表中指定位置的元素替换为指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">"After set(1, 3):"</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">"get(1)获得指定位置（这里为1）的元素: "</span> +</span><br><span class="line">                           linkedList.get(<span class="number">1</span>)); <span class="comment">// 返回此列表中指定位置处的元素</span></span><br><span class="line">        <span class="comment">/************************** Search操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">"indexOf(3): "</span> +</span><br><span class="line">                           linkedList.indexOf(<span class="number">3</span>)); <span class="comment">// 返回此列表中首次出现的指定元素的索引</span></span><br><span class="line">        System.out.println(<span class="string">"lastIndexOf(3): "</span> +</span><br><span class="line">                           linkedList.lastIndexOf(<span class="number">3</span>));<span class="comment">// 返回此列表中最后出现的指定元素的索引</span></span><br><span class="line">        <span class="comment">/************************** Queue操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        System.out.println(<span class="string">"peek(): "</span> + linkedList.peek()); <span class="comment">// 获取但不移除此列表的头</span></span><br><span class="line">        System.out.println(<span class="string">"element(): "</span> + linkedList.element()); <span class="comment">// 获取但不移除此列表的头</span></span><br><span class="line">        linkedList.poll(); <span class="comment">// 获取并移除此列表的头</span></span><br><span class="line">        System.out.println(<span class="string">"After poll():"</span> + linkedList);</span><br><span class="line">        linkedList.remove();</span><br><span class="line">        System.out.println(<span class="string">"After remove():"</span> + linkedList); <span class="comment">// 获取并移除此列表的头</span></span><br><span class="line">        linkedList.offer(<span class="number">4</span>);</span><br><span class="line">        System.out.println(<span class="string">"After offer(4):"</span> + linkedList); <span class="comment">// 将指定元素添加到此列表的末尾</span></span><br><span class="line">        <span class="comment">/************************** Deque操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.offerFirst(<span class="number">2</span>); <span class="comment">// 在此列表的开头插入指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">"After offerFirst(2):"</span> + linkedList);</span><br><span class="line">        linkedList.offerLast(<span class="number">5</span>); <span class="comment">// 在此列表末尾插入指定的元素</span></span><br><span class="line">        System.out.println(<span class="string">"After offerLast(5):"</span> + linkedList);</span><br><span class="line">        System.out.println(<span class="string">"peekFirst(): "</span> +</span><br><span class="line">                           linkedList.peekFirst()); <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"peekLast(): "</span> +</span><br><span class="line">                           linkedList.peekLast()); <span class="comment">// 获取但不移除此列表的第一个元素</span></span><br><span class="line">        linkedList.pollFirst(); <span class="comment">// 获取并移除此列表的第一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"After pollFirst():"</span> + linkedList);</span><br><span class="line">        linkedList.pollLast(); <span class="comment">// 获取并移除此列表的最后一个元素</span></span><br><span class="line">        System.out.println(<span class="string">"After pollLast():"</span> + linkedList);</span><br><span class="line">        linkedList.push(<span class="number">2</span>); <span class="comment">// 将元素推入此列表所表示的堆栈（插入到列表的头）</span></span><br><span class="line">        System.out.println(<span class="string">"After push(2):"</span> + linkedList);</span><br><span class="line">        linkedList.pop(); <span class="comment">// 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素）</span></span><br><span class="line">        System.out.println(<span class="string">"After pop():"</span> + linkedList);</span><br><span class="line">        linkedList.add(<span class="number">3</span>);</span><br><span class="line">        linkedList.removeFirstOccurrence(<span class="number">3</span>); <span class="comment">// 移除第一次出现的指定元素（从头到尾遍历）</span></span><br><span class="line">        System.out.println(<span class="string">"After removeFirstOccurrence(3):"</span> + linkedList);</span><br><span class="line">        linkedList.removeLastOccurrence(<span class="number">3</span>); <span class="comment">// 移除最后一次出现的指定元素（从尾到头遍历）</span></span><br><span class="line">        System.out.println(<span class="string">"After removeFirstOccurrence(3):"</span> + linkedList);</span><br><span class="line">        <span class="comment">/************************** 遍历操作 ************************/</span></span><br><span class="line">        System.out.println(<span class="string">"-----------------------------------------"</span>);</span><br><span class="line">        linkedList.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            linkedList.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 迭代器遍历</span></span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        Iterator&lt;Integer&gt; iterator = linkedList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"Iterator："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">        <span class="comment">// 顺序遍历(随机遍历)</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linkedList.size(); i++) &#123;</span><br><span class="line">            linkedList.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"for："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">        <span class="comment">// 另一种for循环遍历</span></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : linkedList)</span><br><span class="line">            ;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"for2："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">        <span class="comment">// 通过pollFirst()或pollLast()来遍历LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; temp1 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        temp1.addAll(linkedList);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (temp1.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            temp1.pollFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"pollFirst()或pollLast()："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">        <span class="comment">// 通过removeFirst()或removeLast()来遍历LinkedList</span></span><br><span class="line">        LinkedList&lt;Integer&gt; temp2 = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        temp2.addAll(linkedList);</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">while</span> (temp2.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            temp2.removeFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">"removeFirst()或removeLast()："</span> + (end - start) + <span class="string">" ms"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h2 id="Arrays-asList"><a href="#Arrays-asList" class="headerlink" title="Arrays.asList"></a>Arrays.asList</h2><p><code>Arrays.asList()</code>将数组转换为集合后,底层其实还是数组。<strong>传递的数组必须是对象数组，而不是基本类型。</strong><code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size()); <span class="comment">// 1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>)); <span class="comment">// 数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>)); <span class="comment">// 报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="keyword">int</span> [] array=(<span class="keyword">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p></p><p>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。我们使用包装类型数组就可以解决这个问题。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><p></p><p><strong>使用集合的修改方法:add()、remove()、clear()会抛出异常。</strong><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> </span></span><br><span class="line"><span class="class"><span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再看一下<code>java.util.AbstractList</code>的<code>remove()</code>方法，这样我们就明白为啥会抛出<code>UnsupportedOperationException</code>。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>正确的数组转集合的方法：<code>List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code></p><p><br></p><h2 id="Comparable-amp-Comparator"><a href="#Comparable-amp-Comparator" class="headerlink" title="Comparable &amp; Comparator"></a>Comparable &amp; Comparator</h2><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><blockquote><p>This interface imposes a total ordering on the objects of each class that implements it. This ordering is referred to as the class’s natural ordering, and the class’s compareTo method is referred to as its natural comparison method.</p><p>Lists (and arrays) of objects that implement this interface can be sorted automatically by Collections.sort (and Arrays.sort). Objects that implement this interface can be used as keys in a sorted map or as elements in a sorted set, without the need to specify a comparator.<br>compareTo 方法的返回值有三种情况：</p><ul><li>e1.compareTo(e2) &gt; 0 即 e1 &gt; e2</li><li>e1.compareTo(e2) = 0 即 e1 = e2</li><li>e1.compareTo(e2) &lt; 0 即 e1 &lt; e2<br>满足上述规则的是升序排序，与上诉规则相反则是降序排序。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">    Set&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">50</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">30</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">90</span>));</span><br><span class="line">    Iterator&lt;Person&gt; iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="keyword">if</span>(age &gt; o.age)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(age &lt; o.age)</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Person [age="</span> + age + <span class="string">"]"</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote><blockquote><p>Note that null is not an instance of any class, and e.compareTo(null) should throw a NullPointerException even though e.equals(null) returns false.<br>The natural ordering for a class C is said to be consistent with equals if and only if e1.compareTo(e2) == 0 has the same boolean value as e1.equals(e2) for every e1 and e2 of class C. It is strongly recommended (though not required) that natural orderings be consistent with equals. This is so because sorted sets (and sorted maps)without explicit comparators behave “strangely” when they are used with elements (or keys) whose natural ordering is inconsistent with equals. In particular, such a sorted set (or sorted map) violates（违反） the general contract for set (or map), which is defined in terms of（依据） the equals method.</p><p>For example, if one adds two keys a and b such that (!a.equals(b) &amp;&amp; a.compareTo(b) == 0) to a sorted set that does not use an explicit comparator, the second add operation returns false (and the size of the sorted set does not increase) because a and b are equivalent from the sorted set’s perspective.<br>这段话的意思是如果compareTo规则和equals规则不同就会发生奇怪的问题，即在<code>!a.equals(b) &amp;&amp; a.compareTo(b) == 0</code>这种情况下，不能插入集合中，因为从排序集合判断是否相等使用compareTo的规则。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Set&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">50</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">50</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">90</span>));</span><br><span class="line">    Iterator&lt;Person&gt; iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(o == <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"><span class="keyword">if</span>(age == o.age)<span class="comment">// 模仿 a.compareTo(b) == 0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(age &gt; o.age)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Person [age="</span> + age + <span class="string">"]"</span>; &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(obj == <span class="keyword">null</span> || !(obj <span class="keyword">instanceof</span> Person))</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">Person p = (Person)obj;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.age == <span class="number">50</span> || p.age == <span class="number">50</span>) &#123;<span class="comment">// 模仿 !a.equals(b)</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">this</span>.age == p.age) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age.hashCode(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Person [age=50]</span></span><br><span class="line"><span class="comment">// Person [age=90]</span></span><br></pre></td></tr></table></figure><p></p></blockquote><p><br></p><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><p>使用自然排序需要类实现 Comparable，并且在内部重写 comparaTo 方法。而 Comparator 则是在外部制定排序规则，然后作为排序策略参数传递给某些类，比如 Collections.sort(), Arrays.sort(), 或者一些内部有序的集合（比如 SortedSet，SortedMap 等）。<strong>同时存在时采用 Comparator（定制排序）的规则进行比较。</strong><br>使用方式主要分三步：</p><ol><li>创建一个 Comparator 接口的实现类，并赋值给一个对象。在 compare 方法中针对自定义类写排序规则。</li><li>将 Comparator 对象作为参数传递给 排序类的某个方法</li><li>向排序类中添加 compare 方法中使用的自定义类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">    Comparator&lt;Person&gt; com = <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(o1.getAge() &gt; o2.getAge())</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(o1.getAge() &lt; o2.getAge())</span><br><span class="line"><span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    Set&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(com);</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">50</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">20</span>));</span><br><span class="line">    set.add(<span class="keyword">new</span> Person(<span class="number">90</span>));</span><br><span class="line">    Iterator&lt;Person&gt; iterator = set.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> Integer age;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Person [age="</span> + age + <span class="string">"]"</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>需要注意的一点是，compare的相等规则需要个equals相同。</p><p><br></p><h2 id="Collections和Arrays常见方法"><a href="#Collections和Arrays常见方法" class="headerlink" title="Collections和Arrays常见方法"></a>Collections和Arrays常见方法</h2><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><h4 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span><span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span><span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span><span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span><span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。</span></span></span><br></pre></td></tr></table></figure><h4 id="查找，替换操作"><a href="#查找，替换操作" class="headerlink" title="查找，替换操作"></a>查找，替换操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(Collection coll)</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOfSubList</span><span class="params">(List source, list target)</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span> <span class="comment">//用新元素替换旧元素</span></span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><h4 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序 : sort()"></a>排序 : <code>sort()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// sort(int[] a)方法按照数字顺序排列指定的数组。</span></span><br><span class="line">Arrays.sort(a);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(a):"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// sort(int[] a,int fromIndex,int toIndex)按升序排列数组的指定范围</span></span><br><span class="line"><span class="keyword">int</span> b[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line">Arrays.sort(b, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(b, 2, 6):"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : b) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="keyword">int</span> c[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// parallelSort(int[] a) 按照数字顺序排列指定的数组(并行的)。同sort方法一样也有按范围的排序</span></span><br><span class="line">Arrays.parallelSort(c);</span><br><span class="line">System.out.println(<span class="string">"Arrays.parallelSort(c)："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : c) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// parallelSort给字符数组排序，sort也可以</span></span><br><span class="line"><span class="keyword">char</span> d[] = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line">Arrays.parallelSort(d);</span><br><span class="line">System.out.println(<span class="string">"Arrays.parallelSort(d)："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> d2 : d) &#123;</span><br><span class="line">System.out.print(d2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找-binarySearch"><a href="#查找-binarySearch" class="headerlink" title="查找 : binarySearch()"></a>查找 : <code>binarySearch()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] e = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="comment">// 排序后再进行二分查找，否则找不到</span></span><br><span class="line">Arrays.sort(e);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(e)"</span> + Arrays.toString(e));</span><br><span class="line">System.out.println(<span class="string">"Arrays.binarySearch(e, 'c')："</span>);</span><br><span class="line"><span class="keyword">int</span> s = Arrays.binarySearch(e, <span class="string">'c'</span>);</span><br><span class="line">System.out.println(<span class="string">"字符c在数组的位置："</span> + s);</span><br></pre></td></tr></table></figure><h4 id="比较-equals"><a href="#比较-equals" class="headerlink" title="比较: equals()"></a>比较: <code>equals()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] e = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="keyword">char</span>[] f = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 元素数量相同，并且相同位置的元素相同。 另外，如果两个数组引用都是null，则它们被认为是相等的 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 输出true</span></span><br><span class="line">System.out.println(<span class="string">"Arrays.equals(e, f):"</span> + Arrays.equals(e, f));</span><br></pre></td></tr></table></figure><h4 id="填充-fill"><a href="#填充-fill" class="headerlink" title="填充 : fill()"></a>填充 : <code>fill()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] g = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="comment">// 数组中所有元素重新分配值</span></span><br><span class="line">Arrays.fill(g, <span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.fill(g, 3)："</span>);</span><br><span class="line"><span class="comment">// 输出结果：333333333</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : g) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="keyword">int</span>[] h = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, &#125;;</span><br><span class="line"><span class="comment">// 数组中指定范围元素重新分配值</span></span><br><span class="line">Arrays.fill(h, <span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.fill(h, 0, 2, 9);："</span>);</span><br><span class="line"><span class="comment">// 输出结果：993333666</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : h) &#123;</span><br><span class="line">System.out.print(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转列表-asList"><a href="#转列表-asList" class="headerlink" title="转列表 asList()"></a>转列表 <code>asList()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回由指定数组支持的固定大小的列表。</span></span><br><span class="line"><span class="comment">* （将返回的列表更改为“写入数组”。）该方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()相结合 。</span></span><br><span class="line"><span class="comment">* 返回的列表是可序列化的，并实现RandomAccess 。</span></span><br><span class="line"><span class="comment">* 此方法还提供了一种方便的方式来创建一个初始化为包含几个元素的固定大小的列表如下：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Moe"</span>, <span class="string">"Curly"</span>);</span><br><span class="line">System.out.println(stooges);</span><br></pre></td></tr></table></figure><h4 id="转字符串-toString"><a href="#转字符串-toString" class="headerlink" title="转字符串 toString()"></a>转字符串 <code>toString()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回指定数组的内容的字符串表示形式。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span>[] k = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line">System.out.println(Arrays.toString(k));<span class="comment">// [a, f, b, c, e, A, C, B]</span></span><br></pre></td></tr></table></figure><h4 id="复制-copyOf"><a href="#复制-copyOf" class="headerlink" title="复制 copyOf()"></a>复制 <code>copyOf()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copyOf 方法实现数组复制,h为数组，6为复制的长度</span></span><br><span class="line"><span class="keyword">int</span>[] h = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, &#125;;</span><br><span class="line"><span class="keyword">int</span> i[] = Arrays.copyOf(h, <span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.copyOf(h, 6);："</span>);</span><br><span class="line"><span class="comment">// 输出结果：123333</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : i) &#123;</span><br><span class="line">System.out.print(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// copyOfRange将指定数组的指定范围复制到新数组中</span></span><br><span class="line"><span class="keyword">int</span> j[] = Arrays.copyOfRange(h, <span class="number">6</span>, <span class="number">11</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.copyOfRange(h, 6, 11)："</span>);</span><br><span class="line"><span class="comment">// 输出结果66600(h数组只有9个元素这里是从索引6到索引11复制所以不足的就为0)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j2 : j) &#123;</span><br><span class="line">System.out.print(j2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;集合概览&quot;&gt;&lt;a href=&quot;#集合概览&quot; class=&quot;headerlink&quot; title=&quot;集合概览&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="Java" scheme="https://isjinhao.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://isjinhao.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>04.02-网络-链路层</title>
    <link href="https://isjinhao.github.io/posts/24372.html/"/>
    <id>https://isjinhao.github.io/posts/24372.html/</id>
    <published>2019-12-20T09:22:11.000Z</published>
    <updated>2019-12-30T13:20:35.752Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="相邻"><a href="#相邻" class="headerlink" title="相邻"></a>相邻</h2><p>计算机网络中链路层的功能是“相邻节点间的数据传输”。这句话什么意思呢？我们先讨论“相邻”一词，再讨论“数据传输”。两台主机，用一根网线相连是相邻。多台主机，用一根网线相连，仍然是相邻。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/56b3b0fe-68ac-4f0a-96ca-5d1a91d3ddca"></div><p>这根线缆退化成一个节点，这样的设备称为集线器。通过集线器相连的多台主机也是相邻。集线器没有任何智能，等同于线缆。在集线器上增加简单的智能控制功能，就是交换机。通过交换机相连的多台主机也是相邻。交换机将计算机互联在一起，构成局域网。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/02a42964-8121-4cd4-aa4d-320e8fbe1f87"></div><p>所以“相邻节点间的数据传输”换一种说法就是“构建局域网”，再换一种说法就是“局域网内的主机都是邻居关系”。链路层的功能就是构建局域网。相邻这一概念很重要，主机间的数据传输可以分为两种情况，一种是两个主机在同<br>一个局域网内，两主机是相邻关系，简称内网通信，另一种是两个主机在两个不同的网络里，可称外网通信，两种数据传输原理完全不同。本篇文章只关注内网通信。</p><p><br></p><h2 id="链路层解决的问题"><a href="#链路层解决的问题" class="headerlink" title="链路层解决的问题"></a>链路层解决的问题</h2><p>数据传输就是将一台主机内的数据传输到另一台主机，物理层解决了比特转换为电磁信号传输的问题，但这不是数据传输的全部问题，还有一些问题，例如：</p><ul><li>物理层传输中的数据有可能出错，如何处理？</li><li>发送方与接收方的速度可能不匹配，如何调节？</li><li>数据如何封装成数据帧，然后传输，如何传输封装？</li><li>发生碰撞该怎么办？<br>针对这些问题制定的解决方案称为数据链路层的通信协议。物理链路+通信协议构成了我们要研究的数据链路。</li></ul><p><br></p><h2 id="循环冗余码"><a href="#循环冗余码" class="headerlink" title="循环冗余码"></a>循环冗余码</h2><p>循环冗余码（CRC）在很多地方都被用来校验传输的数据是否出错，至于其如何证明，笔者也未曾探究，下文介绍冗余码的思想和计算方法。<br>如果发送方只传输 87，接收方收到 82，接收方是无法判断 82 是不是发送方发送的数据，就是说无法判断 82 是对还是错。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/9cc48d60-5fb9-48aa-bee8-289923b4def8"></div><p>怎么办？发送方与接收方事先商量好一个数，例如 15，发送时先计算 87 除 15 的余数，为 12，将这个余数与 87 一起发送，即 8712，接收时先计算 82 除 15 的余数，为 7，不等于 12，就认为传输的数据出错，这样检错的概率并非百分之百，例如87 错成 72 就检测不出来，但总体来说，检错概率已经非常高了。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/deb03917-f54b-4a55-a49a-035080cb338c"></div><p><br></p><h3 id="CRC-计算方法"><a href="#CRC-计算方法" class="headerlink" title="CRC 计算方法"></a>CRC 计算方法</h3><ul><li>第一，CRC 有一个生成多项式 P(x)，其作用等同于除数 15，将其写成比特串，转化规则如图：</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/b05ad501-470b-401d-a351-30621e3a5a5b"></div><ul><li>第二，如果 P(x) 的比特串是 n 位，在发送数据后补 n-1 个 0。例如 P(x)为 1101，就要补 000。</li><li>第三，做模2除法。<strong>注意模二除法不是二进制除法。</strong></li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/2fe57653-6891-4811-9f64-64ddf0a63426"></div><ul><li>第四，用<strong>余数</strong>替换补的 0，形成发送数据，101001001。</li><li>第五，接收方用接收数据 101001001 除以 P(x)1101，如果能整除，就表示没有错（等同与原理中的余数相同），如果不能整除，就表示出错了（等同与原理中的余数不相等）。</li></ul><p><br></p><h2 id="停止等待协议（Stop-and-Wait-protocol）"><a href="#停止等待协议（Stop-and-Wait-protocol）" class="headerlink" title="停止等待协议（Stop-and-Wait protocol）"></a>停止等待协议（Stop-and-Wait protocol）</h2><p>如果两个主机间数据传输时，接收方的速度永远不会低于发送方的速度；传输的数据帧不会出错，也不会丢失，完全理想化的数据传输，那就没有什么问题，当然也不需要解决问题的办法，也就不需要协议。现在假设，没有差错，但是接收方的速度低于发送方的速度，怎么办？显然控制的思路只能是快的一方牵就慢的一方，就是由慢的一方指挥快的一方。具体来说，就是发送方每发送一帧就停下来，等待；收到 ACK 发送下一帧，接收方则是等待，收到数据帧，发送 ACK（确认 Acknowledgment ），等待下一帧。停下来，等待就是停止等待协议的由来。<br>停止等待协议当然不仅仅需要这一个问题，其需要解决的问题如下：</p><ul><li>接收方的速度低于发送方的速度；</li><li>传输的数据帧可能出错；</li><li>数据帧可能丢失，确认帧 ACK 也可能丢失；</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/94b7f382-3546-4f7b-9b20-d4922ad72022"></div><p><strong>确认号</strong></p><p>接收方收到一个数据帧，并校验正确，给发送方一个确认 ACKn，ACKn 表示“第 n-1 号帧已经收到，现在期望接收第 n 号帧”。确认号是接收方预期接收的下一帧的序号。</p><p><strong>差错</strong></p><p>数据帧出错时，接收方收到一个数据帧，校验时发现数据帧出错，接收方丢弃此数据帧，此外不做任何事，即不发送 ACK。发送方发送完数据帧后在停止等待 ACK，然而此时不会有 ACK，发送方就等死在这里了。</p><p><strong>重传定时器</strong></p><p>发送方设计一个重传定时器的机制，发送方每发送一个数据帧，就启动一个倒计时的重传定时器，如果在超时 timeout 之前收到确认，就关闭定时器并发送下一帧。如果超时，就重传之前的帧。</p><p><strong>丢失</strong></p><p>接收方收到一个数据帧，校验正确发送 ACK，等待接收下一帧，如果确认帧丢失，发送方收不到确认，超时后重传旧帧，而接收方在等待新帧，此刻发送方与接收方的状态不同步，如何区分新帧与重传的帧？</p><p><strong>帧编号</strong></p><p>停等协议使用序号和确认号，以区分重传的数据帧。发送方发送帧时使用序号，接收方使用确认号。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/748650d2-50d3-4df5-8c6e-6a6a4ba625ff"></div><p><br></p><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>停止等待协议的优点是简单，但缺点是信道利用率太低。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a73393e2-cbc6-4080-a3d2-1c94b49054e0"></div><p>信道利用率公式：$U=\frac{T_D}{T_D+RTT+T_A}$，其中：</p><ul><li>$T_D$：数据帧传输时延</li><li>$RTT$：数据帧+确认帧传播时延</li><li>$T_A$：确认帧传输时延<br>举例：假设主机甲与主机乙使用停等协议传输数据，若甲乙之间的单向传播延迟是 15ms，数据帧长为 1000 字节，信道宽带为 100Mbps，乙每收到一个数据帧立即利用一个短帧（忽略其发送时延）进行确认，则信道利用率为：发送一个数据帧到 100Mbps 链路所需时间为：$T_D = \frac{1000 \ast 8bits}{100 \ast 10^6bit/s }= 80\mu s$。发送方在 t=0 时刻发送，15ms 后第 1 个比特到达主机乙，15.08ms 时主机乙收到最后一比特，开始发送确认帧，由于确认帧很短，我们忽略其发送时延，在30.08ms 时，确认帧到达主机甲，总时间周期为T𝐷 + RTT + T𝐴(忽略) = 30.08ms，信道利用率为0.0027。信道利用率为 0.27%，就是说发送方只有百分之0.27的时间是忙的。停止等待协议信道利用率太低了。</li></ul><p><br></p><h2 id="GBN-协议"><a href="#GBN-协议" class="headerlink" title="GBN 协议"></a>GBN 协议</h2><p>我们讨论一个可以获得较高信道利用率的协议：连续 ARQ 协议(Go-back-NProtocol)，或称 GBN 协议，也称为滑动窗口协议（Sliding Window Protocol）。发送方在接收到确认之前，发送一组数据帧，而不是发送一个数据帧就停止等待确认。</p><p><strong>确认号</strong></p><p>在 GBN 协议中，采用累积确认的方式，确认号是希望接收的下一个分组序号。举例，ACK7 表示序号 6 以内的所有帧都已正确收到了，等待接收 7 号帧。</p><p><strong>发送窗口</strong></p><p>在 GBN 协议中，发送一组帧，然后停止等待确认。发送窗口定义了最多可以发送多少个数据帧。举例如下图：一个大小为 7 的窗口，窗口左侧是已确认，已丢弃的帧，窗口内有色的是已发送的，尚未收到确认的帧，0，1，2，3 号帧，发送方需要等待，可称为未完成帧，窗口内无色的是可发送还未发送的帧，是 4，5，6 号帧，窗口右侧是不能发送的帧。描述发送窗口需 3 个变量：</p><ul><li>$S_f$：发送窗口，第一个未完成分组。完成指的是发送方接收到确认方的确认帧。</li><li>$S_n$：发送窗口，下一个待发送分组。</li><li>$S_{size}$：发送窗口，大小。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/2abd2748-98e6-4814-8109-52b707ded1f9"></div><p>当 ackNo 大于等于 $S_f$ 且小于 $S_n$ 的无错 ACK 到达时，发送窗口可以滑动一个或多个槽。举例，当发送方收到 $ACK_6$，表示 4，5 号帧已正确接收，窗口滑动，状态如下图。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/57c10335-51ac-4ae5-b198-48d7b27e2cdf"></div><p><strong>接收窗口</strong></p><p>在 GBN 协议中，接收窗口大小总是 1。只有序号在接收窗口内的数据帧才接收。任何失序的分组都会被丢弃，需要重发。描述接收窗口控制只需 1 个变量 $R_n$，表示其期待下一次接收的帧，</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/16e25de1-cd2e-4926-b80b-bad21e0665cb"></div><p><strong>重传定时器</strong></p><p>在 GBN 协议中，只使用一个计时器。接收窗口大小总是 1。当定时器超时，发送方重发所有未完成分组。例如，假设发送方已经发送了分组 6（$S_n=7$），但是唯一的计时器终止。如果 $S_f=3$，这意味着分组 3、4、5 和 6 没有被确认；发送方回退并重发分组 3、4、5 和 6。</p><ul><li>发送方<ul><li>发送分组。发送方会开启唯一的计时器。$S_n$ 的值增长，（$S_n=S_n+1$）如果达到窗口值进入阻塞状态。</li><li>如果 ACK 到达，其 ackNo 与一个未完成分组有关，那么发送方滑动窗口（令 $S_f=ackNo$），并且如果所有未完成分组都被确认（$ackNo=S_n$），那么关闭计时器。如果并不是所有未完成分组都被确认，那么重新开启计时器。</li><li>如果超时发生，发送方重发所有未完成分组并重新开启计时器。</li></ul></li><li>接收方<ul><li>如果 $seqNo=R_n$ 的无错分组到达，之后窗口滑动，$R_n=（R_n+1）$。$ackNo=R_n$的 ACK 被发送。</li><li>如果 seqNo 在窗口之外的无错分组到来，分组被丢弃，但是 $ackNo=R_n$的 ACK 被发送。</li></ul></li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/431b9ded-4d9a-4c03-8462-9ab01615ac63"></div><p><strong>发送窗口的最大值</strong></p><p>当用 n 个比特进行帧编号时，接收窗口的大小为 1，则只有在发送窗口的大小$W_T ≤ 2^n − 1$时，连续 ARQ 协议才能正确运行。例如，当采用 2bit 编码时，发送窗口的最大值是 3 而不是 4。下图比较 4 与 3 两种情况。如果窗口的大小是 4 并且所有确认都丢失，发送方将会重传旧的所有 4 个帧。但是接收方等待接收的是新的 0 号帧，由于窗口匹配，接收 0 号帧，接收方认为接收的是新的 0 号帧，这是一个错误。如果窗口大小为 3 并且所有三个确认都丢失，那么超时并且重发所有 3 个分组，接收方现在期待 3 号帧，而不是 0 号帧，因此重传分组被正确丢弃。不会产生错误。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/68b3e6ca-aacc-441b-ad6d-85ca8f56e6d9"></div><p>为能正确区分重传的帧，应保证在$W_T+W_R$的窗口内不出现重复序号，即$W_T + W_R ≤ 2^n$，我们将 WT 和 WR 拼接在一起，在$W_T + W_R$窗口内如果出现重复序号，就会发生上述的错误，如果不出现重复的序号，就不会发生上述的错误。GBN 协议的接收窗口为 1，所以发送窗口最大为$2^n − 1$</p><p><br></p><h2 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h2><p>共享信道有一个基本问题，碰撞 （Collision）。若某时刻两帧同时发出，会相互重叠，结果使信号无法辨认，称为碰撞。如下图便是碰撞：</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/527274c9-4165-4b0a-8bc4-721b372b901c"></div><p>碰撞的结果是两个帧都变得无用。解决碰撞的思路大致有两类：</p><ul><li>一类思路是将工作做在前面，预防碰撞，即受控接入：各主机不能任意发送数据，必须服从一定的控制。如令牌环网，拥有令牌的主机可发送数据，没有令牌的主机只能接收数据，令牌如击鼓传花般依次传递。</li><li>另一类思路是将工作做在后面，撞就撞吧，做好事故的处理，即随机接入：所有主机都可以根据自己的意愿随机地发送数据。<br>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）载波监听多点接入/碰撞检测。载波监听（Carrier Sense）指监测信道上有无数据信号传输，监测方法是判断基带上是否有脉冲二进制 0 或 1。多点接入（Multiple Access）同时有多个站点连接在信道上。显然，使用随机接入的方式是无法避免碰撞的。在随机接入的情况下，需要完成几项工作：</li><li>尽量减少碰撞</li><li>是否碰撞有明确结论</li><li>碰撞之后的事故处理<br>CSMA/CD 协议完成这些工作的原理，简缩为三句口诀。</li><li>先听后发</li><li>边发边听</li><li>冲突重发</li></ul><p><br></p><h3 id="先听后发"><a href="#先听后发" class="headerlink" title="先听后发"></a>先听后发</h3><p>我们当然希望尽量减少碰撞，想个什么办法呢？就是在发送数据帧之前，先监听信道。“载波监听”就是“发送前先监听”，如果信道上有数据帧，当然就先不发送数据帧，否则一发送数据帧就产生碰撞，碰撞了就毫无意义。当监听信道时，如果信道忙有数据帧，站点回去睡一段随机时间，然后再回来监听信道，这种策略称非坚持型 CSMA。当监听信道时，如果信道忙有数据帧。站点不是回去睡一会，而是蹲守在这儿，继续监听直到信道空闲，这种策略称坚持型 CSMA。当监听到信道空闲下来时，站点立即就发送数据，称 1-坚持型 CSMA。当监听到信道空闲下来时，站点并不立即发送数据，先抛一次硬币，如果是字就发，如果是花就不发，就是说以概率 p 发送数据，称 p-坚持型 CSMA。</p><p><br></p><h3 id="边发边听"><a href="#边发边听" class="headerlink" title="边发边听"></a>边发边听</h3><p>站点发出数据帧后，是否碰撞需要有明确的结论。就需要“碰撞检测”（Collision Detection）。如何检测呢？站点检测信道上的信号电压大小，当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，“碰撞检测”也称为“冲突检测”。<br>假设 A 站点与 B 站点是网络最远的两端，从 A 站点发出一数据帧，到达 B站点的所花费的时间为$\tau$，A 站点发出一数据帧，就在即将到达 B 站的时刻，B站发出一数据帧，立即发生碰撞，碰撞信号继续到达 A 站，A 站在经过时间 $2\tau$（两倍的端到端传播时延）发现碰撞。所以，$发送站点监听时间&gt;2\tau$，就可以得到是否碰撞的明确结论。$2\tau$ 也即称为争用期，或碰撞窗口。所以为得到是否碰撞的明确结论，只需要$监听时间&gt;2\tau$就可以了。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/21337352-8cd5-428c-9c57-ebcc9ef4f616"></div><p><br></p><h3 id="冲突重发"><a href="#冲突重发" class="headerlink" title="冲突重发"></a>冲突重发</h3><p>发生碰撞，两个数据帧都损坏，当然需要重发。但是如果两个站点都立即重发数据帧，又会再次碰撞，两个站点发送时刻最好能够错开一些。CSMA/CD 协议使用<strong>截断二进制指数退避算法</strong>，发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。</p><ul><li>重传次数 k，$k=Min[重传次数,10]$</li><li>从整数集合$[0,1,…,(2^k-1)]$中随机地取出一个数，记为 r。</li><li>重传所需的时延就是 r 倍的基本退避时间。基本退避时间一般是取为争用期。<br>当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。使用 CSMA/CD 协议后不能进行全双工通信而只能进行双向交替通信（半双工通信）。每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</li></ul><p><br></p><h2 id="10BASE-T-以太网"><a href="#10BASE-T-以太网" class="headerlink" title="10BASE-T 以太网"></a>10BASE-T 以太网</h2><p>10Base-T以太网使用的是1-坚持型CSMA / CD。<br>10BASE-T 以太网不用同轴电缆而用无屏蔽双绞线，降低了成本，还增加了一种可靠性非常高的设备，叫做集线器（hub）。正是这两个原因，使得 10BASE-T以太网拥有很低的成本和很高的可靠性，迅速在局域网中占据了统治地位。10BASE-T 以太网定义：</p><ul><li>争用期的长度为 51.2 us，而$监听时间 &gt; 2 \tau$ 便等价于$发送数据帧的时间 &gt; 2\tau$。可得：$\frac{帧长L}{10Mbps}&gt;51.2 \mu s$，即$L &gt; 512bit$。最短帧长 64 字节。</li><li>帧间最小间隔为 9.6us，因为要给双方留下缓冲时间。</li><li>站点到集线器的距离不超过 100m，为了保证双绞线上的信号不会出错。</li><li>如果数据帧太长就会出现有的主机长时间不能发送数据，而且有的发送数据可能超出接收端的缓冲区大小，造成缓冲溢出。为避免单一主机占用信道时间过长，规定了以太网帧的数据部分最大长度为1500。</li></ul><p><br></p><h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>在主机内部，需要 10BASE-T 的网络接口板又称为通信适配器（adapter）或网络接口卡 NIC(Network Interface Card)，或“网卡”。网络适配器的重要功能：</p><ul><li>对数据进行串行/并行传输的转换</li><li>编码与译码即曼彻斯特编码与译码。</li><li>链路管理主要是 CSMA/CD 协议的实现。</li><li>数据的封装与解封封装以太网帧。<br>网卡的第一，第二项功能属于物理层的功能。第三项 CSMA/CD 协议的原理上文也介绍了，在此主要介绍一下以太网帧，也称 MAC 帧。网络适配器工作在数据链路层和物理层。生产网卡时，在网卡的 ROM 固化了 6 字节的 MAC 地址，因此 MAC 地址也叫做硬件地址(hardware address)或物理地址。MAC 地址唯一标识了一块网卡。MAC 地址字段是 6 字节（48 位），前三个字节（即高位 24 位），是生产厂家标识，称为组织唯一标识符，后三个字节（即低位 24 位）由厂家自行指派的产品串号，称为扩展唯一标识符，必须保证串号没有重复。网卡将上一层交下来的数据加上首部和尾部，成为以太网的帧。接收时将以太网的帧剥去首部和尾部，然后送交上一层。常用的以太网 MAC 帧格式有两种标准：DIXEthernetV2 标准和 IEEE 的 802.3 标准，最常用的 MAC 帧是以太网 V2 的格式。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/57c68567-71f2-48eb-8302-5615a05c6932"></div><p><br></p><h3 id="网卡工作要点"><a href="#网卡工作要点" class="headerlink" title="网卡工作要点"></a>网卡工作要点</h3><ul><li>适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中，准备发送。</li><li>若适配器检测到信道空闲，就发送这个帧。若检测到信道忙，则继续检测并等待信道转为空闲（加上 96 比特时间），然后发送这个帧。</li><li>在发送过程中继续检测信道，若一直未检测到碰撞，就顺利把这个帧成功发送完毕。若检测到碰撞，则中止数据的发送，并发送人为干扰信号。</li><li>在中止发送后，适配器就执行指数退避算法，等待 r 倍 512 比特时间后，返回到步骤 2。<br>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。早期以太网采用无源的总线结构。现在采用以太网交换机的星形结构成为以太网的首选拓扑。总线以太网使用 CSMA/CD 协议，以半双工方式工作。以太网<br>交换机以全双工方式工作，不使用共享总线，没有碰撞问题，因此不使用CSMA/CD 协议。但仍然采用以太网的帧结构。</li></ul><p><br></p><h2 id="网桥与交换机"><a href="#网桥与交换机" class="headerlink" title="网桥与交换机"></a>网桥与交换机</h2><p>我们看下面一个拓扑，某学院有三个系，各自有一个以太网，三个以太网是三个独立的碰撞域，如果用集线器连成一个更大的以太网，同时也形成一个更大的碰撞域。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/dc645445-17f8-4e1b-81dc-62ca4e233b11"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/35f7eb90-8d1e-474c-81f5-2537406a1092"></div><p>连接的范围扩大了，但碰撞也多了，能不能只扩大范围，不扩大碰撞呢？</p><p><br></p><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>有一种网络设备，称为网桥（bridge），能只扩大范围，不扩大碰撞。网桥工作在数据链路层，其内部维护一张转发表，根据 MAC 地址转发数据帧。当网桥收到一个帧时，根据此帧的目的 MAC 地址，检索转发表，然后再转发帧到接口。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/b5a7f938-7c1e-4f68-ab44-86f02adc0f1c"></div><p>我们看下面的一个拓扑图，先不考虑网桥的转发表是怎么来的，先看一下网桥 B1 和网桥 B2 的转发表的最终形态，可以看出，转发表的本质就是拓扑图的描述，推想一下，这是必然的，网桥若要正确转发数据帧，就需要知道各主机与其的位置关系。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/bdec481c-20b7-42fc-a7d9-8b095ea16a01"></div><p>那么，这张转发表又是怎么来的呢？网桥 B1 和网桥 B2 刚上电时，其内部转发表都是空表，这时，主机 A 给主<br>机 B 发送一数据帧，网桥 B1 的接口 1 收到这帧，网桥 B1 能判断出主机 A 在它的接口 1 侧，但判断不出主机 B 在哪侧，首先转发，把帧向网桥除接口 1 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“A 接口 1”填入转发表，网桥 B1 就学到 1 个条目。网桥 B2 收到网桥 B1 的转发帧，网桥 B2 也能判断出主机 A 在它的接口 1 侧，但判断不出主机 B 在哪侧，首先转发，把帧向网桥除接口 1 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“A 接口 1”填入转发表，网桥 B2 也学到 1 个条目。<br>接下来，第二个数据帧是主机 F 给主机 C 发送的，网桥 B2 的接口 2 收到这帧，网桥 B2 能判断出主机 F 在它的接口 2 侧，但判断不出主机 C 在哪侧，首先转发，把帧向网桥除接口 2 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“F 接口 2”填入转发表，网桥 B2 就学到 2 个条目。网桥 B1 收到网桥 B2 的转发帧，网桥 B1 也能判断出主机 F 在它的接口 2 侧，但判断不出主机 C 在哪侧，首先转发，把帧向网桥除接口 2 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“F 接口 2”填入转发表，网桥 B1 也学到 2 个条目。<br>第三个数据帧是主机 B 给主机 A 发送的，网桥 B1 的接口 1 收到这帧，网桥B1 能判断出主机 B 在它的接口 1 侧，由于已经学到 2 个条目，网桥 B1 由前 2个条目，知道主机 A 在接口 1 侧的，所以不转发。第二，将“B 接口 1”填入转发表，网桥 B2 就学到 3 个条目。因为网桥 1 没转发，网桥 B2 没收到任何数据帧，网桥 B2 仍维持着 2 个条目。<br>经过一段时间，各主机发送了很多数据帧，网桥 B1 和网桥 B2 就学习到了完整的转发表。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/06c46dbe-9db3-4e95-8778-d974ce4eca44"></div><p>但是需要注意，在下图中三个碰撞域内是可以进行通信，但是跨碰撞域之后还是会产生碰撞。如A给D发消息时，B和C不能进行通信。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/4e88f21e-c0aa-4266-8897-b079929fa81b"></div><p><br></p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>网桥只有 2 个接口，可是谁规定网桥只能有 2 个接口呢，网桥也可以有更多接口，这就是以太网交换机，以太网交换机（switch）实质上就是一个多接口的网桥。通常都有十几个或更多的接口。每个接口都直接与一个单台主机或另一个以太网交换机相连，工作在全双工方式。以太网交换机工作原理也是按转发表转发数据帧，工作在数据链路层，是第二层交换机，其内部的帧交换表（又称为地址表）是通过自学习算法自动地逐渐建立起来的。<br>我们看下面的一个拓扑图，先不考虑交换机的转发表是怎么来的，先看一下交换机的转发表的最终形态，可以看出，转发表的本质就是拓扑图的描述，推想一下，这是必然的，交换机若要正确转发数据帧，就需要知道哪个接口与哪个主机相连。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/1c417675-7ccc-4520-9631-54ac9d2a013c"></div><p>那么，这张转发表又是怎么来的呢？交换机启动时，其内部转发表是空表。A 先向 B 发送一帧，交换机收到帧后，先执行转发功能。查找交换表，如果没有查到，洪泛，交换机向除接口 1 以外的所有的接口广播这个帧。再执学习发功能，把这个帧的源地址 A 和接口 1 写入交换表中。当所有主机都发送过数据帧后，交换机就将交换表学完整了。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a35ff815-0672-4828-974f-aa0398fab524"></div><p>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就自动被删除。以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。交换机工作原理是按转发表（MAC 表）转发数据帧，转发表的本质就是拓扑图的描述。要把交换机转发表的本质牢固的记住：<strong>交换机就是要知道哪个接口与哪个主机相连。</strong></p><p><br></p><h3 id="MAC-表抖动与广播风暴"><a href="#MAC-表抖动与广播风暴" class="headerlink" title="MAC 表抖动与广播风暴"></a>MAC 表抖动与广播风暴</h3><p>网桥和交换机的使用可能会发生一下问题，我们以网桥举例：</p><ul><li>会发生 MAC 表抖动（flapping）的问题：就是说同一个MAC地址在一台交换机上的两个及以上接口都学习到，导致MAC地址表中关于此MAC地址与交换机的端口对应不断改变。</li><li>数据帧会循环兜圈子，形成广播风暴。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/19775cdd-57d8-4935-8d64-77b5bf9bb174"></div><p>在拓扑图上，我们可以看到 帧F 到 网桥1 的时候将 F 转发出去，设为 F1，此时 网桥1 学习 到MACA（主机A的MAC地址）在下方接口。F1 到 F2 是 网桥2 学习到 MACA 在 上方接口，但是 帧F 到达 网桥2 的时候网桥2学习到MACA在下方接口，这便是MAC表抖动。同样的 F2 到 网桥1 的时候 网桥1 学习到 MACA 在上方接口，也会发生抖动。（注意：F、F1、F2的MAC地址一致）<br>如果数据帧按照我们上面所述的方式运行，他们会在网桥1和网桥2之间不停的转圈。<br>至于交换机自然也会出现上述的问题。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/99c85247-548b-4a65-81ce-80e5e13ba214"></div><p>解决的办法，就是在逻辑上将环打断，环打断就是棵树。一句话，就是将环打断生成树，简称为“生成树”。在网桥或交换机上运行生成树协议 STP（Spanning Tree Protocol）。生成树协议的要点是：不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。</p><p><br></p><h2 id="无线局域网与-CSMA-CA"><a href="#无线局域网与-CSMA-CA" class="headerlink" title="无线局域网与 CSMA/CA"></a>无线局域网与 CSMA/CA</h2><p>IEEE802.11是一个有固定基础设施的无线局域网WLAN（Wireless Local Area Network）的国际标准。简单地说，802.11 就是无线以太网的标准：使用星形拓扑，其中心叫做接入点 AP(Access Point)，在 MAC 层使用 CSMA/CA 协议，802.11 无线局域网又称为 Wi-Fi（Wireless-Fidelity，意思是“无线保真度”）。以下讨论都是这种无线局域网。<br>无线局域网最小构件是基本服务集 BSS（Basic Service Set），基本服务集里面的基站叫做接入点 AP（AccessPoint，AP 的逻辑功能等同与以太网的集线器），一个基本服务集通过接入点 AP 连接到一个主干分配系统 DS（Distribution System），然后再接入到另一个基本服务集，构成了一个扩展的服务集 ESS。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/f61ba2fe-de15-4c12-8068-b2b21fda115e"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/1f2b499a-9727-4986-8995-225524d90c5a"></div><p><br></p><h3 id="无线局域网没有碰撞检测"><a href="#无线局域网没有碰撞检测" class="headerlink" title="无线局域网没有碰撞检测"></a>无线局域网没有碰撞检测</h3><p>无线局域网逻辑上也是共享信道，采用的也是随机接入的思路。但是，无线局域网与有线局域网有一个重要的差异，无线局域网没有碰撞检测（Collision Detection）。</p><ul><li>“碰撞检测”要求一个站点在发送本站数据的同时，还必须不间断地检测信道，但接收到的信号强度往往会远远小于发送信号的强度，在无线局域网的设备中要实现这种功能就花费过大。</li><li>隐蔽站问题，如下图，有 ABCD 四个站，但 A 只知道有 B，不知道有 CD。A 和 C 互相检测不到对方的无线信号时，都以为 B 是空闲的，都向 B 发送数据，结果发生碰撞。隐蔽站问题使“碰撞检测”失去意义。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/af2532d2-b781-46fd-aea9-0f43b7589f28"></div><p>由于以上两个原因，无线局域网没有碰撞检测。为什么没有碰撞检测就成为问题了呢？因为没有碰撞检测引发了两个问题：</p><ul><li>怎么确定发出的数据帧是否发生碰撞，是否碰撞要有明确的结论，这个结论怎么下？</li><li>在碰撞发生时，就没有感觉，撞了发送方也不会停止发送数据，仍发送数据，直到发送完才停止。不是“撞-停”的情况，而是“撞撞撞撞撞撞···”的情况，碰撞的损失过大。<br>这两个问题都需要解决。先说第一个问题，是否碰撞的结论怎么下？无线网使用了停止等待协议，由接收方发送 ACK 帧来表示正确收到数据帧，否则引发超时重传。再说第二个问题，对于这个问题的解决办法，当然就是“尽量不碰撞”。无线网为了“尽量不碰撞”，设计了一个复杂的协议 CSMA/CA。注意，CSMA/CA协议只能做到“尽量少碰撞”，做不到“完全不碰撞”。第一个问题仍需解决，无线网的 CSMA/CA 替代不了无线网的停等协议。</li></ul><p><br></p><h3 id="CSMA-CA-协议"><a href="#CSMA-CA-协议" class="headerlink" title="CSMA/CA 协议"></a>CSMA/CA 协议</h3><p>无线局域网没有碰撞检测，所以有线的 CSMA/CD 就被阉割为 CSMA，可不甘心，还想进一步的减少碰撞，就又加了一个 CA（Collision Avoidance 碰撞避免）功能。802.11 就使用 CSMA/CA 协议。而在使用 CSMA/CA 的同时，还增加使用停止等待协议。</p><h4 id="帧间间隔-IFS"><a href="#帧间间隔-IFS" class="headerlink" title="帧间间隔 IFS"></a>帧间间隔 IFS</h4><p>所有的站在完成发送后，必须再等待一段很短的时间（继续监听）才能发送下一帧。这段时间的通称是帧间间隔 IFS（Inter Frame Space）。SIFS，即短（Short）帧间间隔，长度为 28us，使用 SIFS 的帧类型有：ACK 帧、CTS 帧。DIFS，即分布协调功能帧间间隔，长度为 128us。DIFS 用来发送数据帧和管理帧。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/9ba7baf3-7466-4506-84c2-8cca4944ef2a"></div><h4 id="争用窗口（二进制指数退避）"><a href="#争用窗口（二进制指数退避）" class="headerlink" title="争用窗口（二进制指数退避）"></a>争用窗口（二进制指数退避）</h4><p>信道从忙态变为空闲时，任何一个站要发送数据帧时，不仅都必须等待一个DIFS 的间隔，而且还要进入争用窗口，各站就要执行退避算法。802.11 使用二进制指数退避算法。这样做就减少了发生碰撞的概率。但其避退算法和CSMA/CD的有区别。第i次退避就在$2^{2+i}$个时隙中随机地选择一个。这就是说，第1次退避是在8个时隙（而不是2个）中随机选择一个，而第2次退避是在16个时隙（而不是4个）中随机选择一个。 这样做的目的是减少碰撞。<br>发送算法如下：</p><ol><li>如果某站点检测到信道空闲，会等待一个DIFS发送该帧。</li><li>否则该站点选取一个随机值进行避退，并且在检测到信道忙的时候递减该值。当检测不忙的时候计数值保持不变。</li><li>当计数值减为0的时候（此时信道一定为空闲），该站点发送整个数据帧并等待确认。</li><li>如果发送方收到确认，发送站点知道他的帧被目的站正确接收了，如果该站点要发送另一帧它需要从第二步开始进行。如果未收到，执行回退算法，此次会在一个更大的范围里选取。</li></ol><div align="center"><img src="http://blogfileqiniu.isjinhao.site/eeadb88c-5d8a-4bc0-bb4a-30002461f518"></div><p>需要注意，上图中的退避区间内退避算法得到的计数值不一定在减少。冻结指的就是再次检测到信道忙的时候不再减少计数值。</p><p><br></p><h3 id="信道预约"><a href="#信道预约" class="headerlink" title="信道预约"></a>信道预约</h3><p>为了更好地解决隐蔽站带来的碰撞问题，802.11 允许要发送数据的站对信道进行预约。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/796e3d46-c4d9-4ae1-af12-b9217e20a90c"></div><p><br></p><h3 id="有线与无线的对比"><a href="#有线与无线的对比" class="headerlink" title="有线与无线的对比"></a>有线与无线的对比</h3><p>无线局域网与有线局域网都是使用随机接入的方式，都是无法绝对避免碰撞的。在这种情况下，都需要考虑以下问题：尽量减少碰撞、是否碰撞要有明确结论、碰撞之后的事故处理。简单做一对比：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/5b2f531a-545f-4014-9d5f-1c9f591bb0bd"></div><p>无线网中碰撞造成的损失更大，就需要在减少碰撞的方面做更多的工作，精心设计了 CSMA/CA 协议，包含帧间间隔，争用窗口（二进制指数退避），信道预约三种机制，但仍无法完全避免碰撞。由于没有碰撞检测，是否碰撞的明确结论，由接收方发送 ACK 确认帧机制。碰撞事故处理是空，是因为将重发中的二进制指数退避已经融合到 CSMA/CA 协议中。</p><p><br></p><h3 id="802-11-局域网的-MAC-帧"><a href="#802-11-局域网的-MAC-帧" class="headerlink" title="802.11 局域网的 MAC 帧"></a>802.11 局域网的 MAC 帧</h3><p>802.11 帧共有三种类型：控制帧、数据帧和管理帧。只简单讨论数据帧。数据帧的三大部分，MAC 首部，共 30 字节。帧的复杂性都在帧的首部。帧主体，数据部分不超过 2312 字节，通常都是小于 1500 字节。帧检验序列 FCS 是尾部，共 4 字节。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/21028d9d-ae4c-4f4d-bd06-eda73c2a39ce"></div><p>802.11 数据帧最特殊的地方就是有四个地址字段。地址 4 用于自组网络（博主暂未接触）。我们在这里只讨论前三种地址。地址 1 总是帧将访问的下一个设备的地址，地址 2 总是帧离开的前一个设备的地址，如果地址 1 没有定义最后的目的地址，地址 3 就是最后的目的站点的地址，如果地址 2 没有定义原始源地址，地址 3 就是原始源站点地址。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a6b5ea14-5de9-48fe-8bbb-d452b9b68fe1"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/f4e5d00a-3eb1-4e2e-b69c-385af0f8eebf"></div><p>站点 A 向 B 发送数据帧，但这个数据帧必须经过 AP 转发。首先站点 A 发送数据帧到 AP1，然后 AP1 把数据帧发送给 B。举例：A-&gt;AP1 时：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/04e71d45-4d7d-44a9-8b46-d704cb112caf"></div><p><br></p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>ARP（Address Resolution Protocol），根据 IP 地址查询MAC 地址。ARP 协议的工作原理如下图，有 ARP 请求（Request）和 ARP 回答（Reply）两个报文。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/5fd13274-deb0-49f7-80ed-0ac4d3857d82"></div><p>ARP 报文封装成 Mac 帧，是 Mac 帧的负载，mac 帧类型值 0806 指示 mac 帧的数据部分是 ARP 报文。ARP 请求（Request）是广播，ARP 回答（Reply）是单播，见下图：ARP 请求报文所封装的 Mac 帧，目的 Mac 地址是 FF-FF-FF-FF-FF-FF，这 个地址是广播地址，交换机就会广播这个帧。ARP 请求报文和校园广播的大喇叭是不是很像呢？如果目的主机也在你的网络里，你用大喇叭喊它，要来它的mac 地址，就可以封装 mac 帧了。注意，ARP 直接封装为 MAC 帧，不是封装为 IP 报。从这点看，我个人更赞同将 ARP 理解为链路层协议。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/0b5f2881-2e5f-469a-a93d-15aae56325d7"></div><p>报文格式：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/25614eda-c07d-4487-9f50-9855491f0af9"></div><p><br></p><h2 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h2><p>ARP 是设备通过自己知道的IP地址来获得自己不知道的物理地址的协议。假如一个设备不知道它自己的IP地址，但是知道自己的物理地址，应该怎么办呢？RARP（逆地址解析协议）正是针对这种情况的一种协议。<br>RARP以与ARP相反的方式工作。RARP发出要反向解析的物理地址并希望返回其对应的IP地址，应答包括由能够提供所需信息的RARP服务器发出的IP地址。虽然发送方发出的是广播信息，RARP规定只有RARP服务器能产生应答。许多网络指定多个RARP服务器，这样做既是为了平衡负载也是为了作为出现问题时的备份。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;相邻&quot;&gt;&lt;a href=&quot;#相邻&quot; class=&quot;headerlink&quot; title=&quot;相邻&quot;&gt;&lt;/a&gt;相邻&lt;/
      
    
    </summary>
    
      <category term="网络" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://isjinhao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>04.04-网络-运输层</title>
    <link href="https://isjinhao.github.io/posts/22725.html/"/>
    <id>https://isjinhao.github.io/posts/22725.html/</id>
    <published>2019-12-20T09:22:11.000Z</published>
    <updated>2019-12-30T13:20:35.763Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="传输服务"><a href="#传输服务" class="headerlink" title="传输服务"></a>传输服务</h2><p>网络层完成了“主机到主机”的通信，但主机间的通信并不是最后的结果，产生和消耗数据的并不是主机，而是某项网络应用，真正通信的是两个应用“进程”。“进程”就是“正在进行的程序”。而“进程到进程的通信”正是传输层的功能。但这不是全部，更重要的，传输层的任务是为从源主机到目的主机提供可靠的，低价格的数据传输。可靠性，低价格是两个关键词，或者为了更明显一些，可以有第三个关键词，拥塞控制。其实可靠性与拥塞控制本质上是一个词。可靠性、低价格、拥塞控制使传输层成为整个协议体系的核心与灵魂。如果没有传输层，就没有可靠的数据传输，网络层也将失去意义。<br>传输层的服务与网络层服务很相似，为何要分为两个层呢？答案就是“可靠性”。网络层并不提供可靠性，路由器可以丢失分组，用户无法控制中间的网络设备，用户不能选择性能更好的路由器或质量更好的数据链路，那么如何保证数据可以正常传输呢？添加一个传输层，传输层应该检测到各种问题，并采取补救措施，从而提供可靠的数据传输。传输层就是要弥补网络层技术、设计的各种缺陷。用个不恰当的比方，传输层就是“填坑的”，将网络层与应用层之间的坑、沟填平。传输层服务前，是遍布坑、沟的公路，传输层服务后，是平坦的公路。<br>再谈谈“低价格”这个关键词。如果在设计网络时，由网络层提供可靠性，会如何呢？如果由网络层提供可靠性，就要在中间网络的千万个路由器上添加可靠性的功能，系统的复杂性会提高数据传输的成本，那就与电话通信网的成本差别不大。可靠性由通信网提供还是由端计算机提供，二者的价格差别可太大了。可靠性由端计算机提供，才有了低成本的数据传输，低价格才是计算机网络将其他通信技术淘汰的本质。要低价格，可靠性就要放置在端计算机内部。显然放置在操作系统内部更加合理，直接由操作系统对应用程序提供可靠的数据传输服务，是非常自然的选择。传输层封装在端计算机的操作系统内，用个不恰当的比方，如同封装在房间内的电线，在装修时已经埋好了，只是提供了许多插座，这个插座接洗衣机，那个插座接冰箱，那个插座接电视，等等。<br>对计算机网络来说，“可靠性”的关键是什么？或者反过来，造成数据传输不可靠的最主要的原因是什么？是网络拥塞，当网络拥塞时，路由器就会丢弃数据包。传输层需要具有“调控网络”的功能。我们说，传输层在端主机内，而端主机是无法控制中间的网络设备的，“调控网络”从何谈起呢？后面会说到网络拥塞如同现实生活的堵车，根本的解决办法是不让车上路，所有的车都不上路，路就不堵了。“调控网络”是说所有端计算机内的传输层要能感知到网络的状态，能感知到当前通信网的态势，网络拥塞，就少发数据，网络通畅，就多发数据。尤其是网络拥塞时，要少发数据，让中间网络尽快恢复传输能力。</p><p><br></p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>最常用的进程到进程的通信方式是客户机与服务器模式。我们这里说的客户机与服务器都是指一个应用进程，而不是机器。客户机，请求服务，主动发起呼叫的进程。服务器，提供服务，被动等待的进程。总是客户机呼叫服务器，绝不可能是服务器呼叫客户机。在生活中，总是你给消防队打电话，绝不可能是消防队给你打电话。某一项服务，就是一项网络应用。端主机完全可以同时有多项网络应用，如同时打开浏览器浏览网页，打开 QQ 聊天。标识不同的网络应用进程的标识符称为协议端口号 (protocol port number)，简称为端口 (port)。端口是一个 16 位的标识符。客户机用一个临时端口号定义自己。客户机可以随机选择一个端口号使用。服务器也需要用一个端口号来定义自己，但是服务器不能随机选用一个端口号。为什么呢？假设消防队随机使用一个电话号码，当发生火灾时，人们向哪打电话呢？服务器必须使用一个预先定义的，众所周知的端口号，就如同消防队使用119，急救中心使用 120 一样。</p><p><br></p><h3 id="端口范围划分"><a href="#端口范围划分" class="headerlink" title="端口范围划分"></a>端口范围划分</h3><ul><li>熟知端口，端口号范围是 0~1023。由 ICANN 分配和控制。</li><li>注册端口，端口号范围是 1024~49151，ICANN 不分配也不控制，但必须在 ICANN 登记以防止重复。通常为没有熟知端口号的应用程序使用的。</li><li>动态端口，端口号范围是 49152~65535，这范围的端口号即不用指派，也不需注册，可以由任何进程使用。最初的建议是客户机使用的临时端口号应该在这个范围，但许多程序员可没有遵守这个建议。<br>注意：端口号只具有本地意义，只是为了标志本计算机应用层中的各进程。</li></ul><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/d19ce3a4-2d66-410b-9d29-cfc7638fc33b"></div><p><br></p><h3 id="复用与分用"><a href="#复用与分用" class="headerlink" title="复用与分用"></a>复用与分用</h3><p>某台主机中可能有多个应用进程同时分别和网络上的许多其他主机中的某个或多个应用进程通信。这表明运输层有一个很重要的功能：复用（multiplexing）和分用（demultiplexing）。<br>当一个实体接受来自多个源的输入时，就称为复用（multiplexing） （多到一）。<br>而当一个实体将数据交到多个源时，就称为分用（demultiplexing）（一到多）。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/9ddb4411-0ed2-4975-b6de-83abc3c6fc51"></div><p><br></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>用户数据报协议 UDP（User Datagram Protocol）是无连接不可靠的传输层协议。它只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和校验和的功能。校验和功能是可选的，如果不选择校验功能，就全填入 0。UDP 缺点是不可靠，优点是开销小。发送数据之前不需要建立连接。这对某些实时应用是很重要的。网络出现拥塞时，不调整，不降低发送速率。UDP 用户数据报首部如下图：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/60f8cda8-e859-4f21-ba03-232c9603df05"></div><p>源端口和目的端口号，各占 16 位，标志应用进程，总长度为 UDP 的总长度，UDP 首部加 UDP 数据的长度，校验和计算下面介绍。</p><p><br></p><h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><p>UDP 的校验和功能是可选的，如果不选择校验和功能，就全填入 0，否则，计算校验和。计算时包含三个部分，伪首部，首部，数据部分，注意计算校验和是包含了数据部分的。如下图：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/21ce0657-8c31-4c2e-a1f6-d5667dee5395" width="80%"></div><h4 id="计算-UDP-检验和的例子"><a href="#计算-UDP-检验和的例子" class="headerlink" title="计算 UDP 检验和的例子"></a>计算 UDP 检验和的例子</h4><p>二进制反码计算规则：0 + 0 = 10；0 + 1 = 1； 1 + 1 = 0</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/86e18cb5-a16b-48c9-858d-39dad429d10b" width="80%"></div><p><br></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP格式"><a href="#TCP格式" class="headerlink" title="TCP格式"></a>TCP格式</h3><p>一个 TCP 报文段分为首部和数据两部分，首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。而 TCP 的全部功能都体现在它首部中各字段的作用：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/dfeef354-34b9-46ef-95e8-dc9416e0de6c"></div><ul><li>源端口和目的端口字段：各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。</li><li>序号字段：占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</li><li>确认号字段：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li><li>窗口字段：占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</li><li>数据偏移（即首部长度）：占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。</li><li>保留：占 6 位，保留为今后使用。</li><li>控制：占 6 位，定义了 6 种不同的控制位或标志。在同一时间可设置位或多位标志位。分别是 URG、ACK、PSH、RST、SYN、FIN。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/18eddd52-8822-47d6-aca7-47babefa45ae"></div><ul><li>检验和：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</li><li>紧急指针字段：占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。</li><li>选项字段：长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”<h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3>TCP 是可靠的传输层协议。就是说 TCP 向应用层交付的是按顺序的，没有差错的，没有丢失的数据。TCP 通过 2 种机制进行差错控制：<code>检验和</code>、<code>确认和超时</code>。</li></ul><p><strong>检验和</strong></p><p>TCP 规定每个报文段都必须使用 16 位的检验和。TCP 检验计算时包含三个部分，伪首部，首部，数据部分，注意计算校验和是包含了数据部分的。计算方 法同 UDP 一样。</p><p><strong>确认和超时</strong></p><p>TCP 采用确认的方式来证实收到报文。接收方可以在合适的时候单独发送确 认报文，也可以在自己有数据要发送时把确认信息捎带上。TCP 使用肯定的累积确认。先解释“肯定”，ACK 就是“肯定”的意思。就是只在正确的情况下才发送确认。当发生丢弃，丢失，重复这些错误时，就什么也不做。“报喜不报忧”，注意，当发生错误时，不发送确认。这样，对方收不到确认，重传定时器就会超时，触发重传。 再解释“累积”，就是表示的累积效果，确认号字段值表示的是希望接收的下一个字节的序号。例如确认号为 301，是表示 301 号字节之前的数据都正确接收了，希望接收的下一个字节是 301 号字节。</p><p><strong>重传定时器</strong></p><p>差错控制的核心就是重传机制。TCP 使用确认-超时重传机制。具体说，TCP 每发送一个报文段，就设置一个重传定时器，当重传时间到，但还没有收到确认，就要重传这一报文段。重传定时器的值怎么设是 TCP 最复杂的事情之一。后面我们会解释原因，现在我们只要知道，重传定时器的值的估算要尽可能的准确，定时器的值不像加班费，越大越好，也不是越小越好，是越准确越好。<br>首先，很自然的想法，重传定时器的值应该是“一个往返时延再多一点”。“一个往返时延”如何确定？举例，8 点测了一次往返时延，8:05 又测一次，间隔 5 分钟，测了 10 次，往返时延应该用哪次测量的值呢？显然，用哪一次的<br>也不合适，应该是某种“平均值”。下面介绍的这个算法的目标是使估计值更加“平滑”，我们将往返时延估计值记作 RTTs。这个算法中，历史的累积效应权重更大一些，占比 7/8，新测量值的权重小，占比1/8。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/3ff3ce9c-8b0a-4de9-8841-527c8c48fc77"></div><p>下图是 RTT 样本与 RTT 估计值示意图，蓝色的是各次的测量值，红色的是RTT 的估计值。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/b04a113a-7bb5-41a9-9720-b2a0bb804e63"></div><p>说完“一个往返时延”，再说“多一点”。这一点Δ怎么算呢？取样本值到平滑线的距离为Δ，|RTTs-新样本|，显然，每个样本点到平滑线都有一个Δ，就是Δ1，Δ2，Δ3，Δ4，···，取哪个Δ合适呢？显然，用哪一个Δ也不合适，还应<br>该是某种“平均值”。算法也是给出一种“平滑平均值”，记作 RTTD。这个算法中，历史的累积效应权重更大一些，占比 3/4，新测量值的权重小，占比 1/4。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6c9b3665-ac82-4cc0-ada1-2f9479621db1"></div><p>总的RTO计算公式：$RTO=RTTs + 4 \ast RTTD$</p><p><br></p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 是全双工通信，TCP 为每个方向的数据传输使用两个窗口，发送窗口和接收窗口。双向通信就有四个窗口，为简化讨论，只讨论单向数据传输。</p><p><strong>发送窗口</strong></p><p>下图是一发送窗口例子，TCP 中的窗口以字节为单位。TCP 的传输实际是一个一个的报文段，但控制窗口的变量是以字节为单位。TCP 中只使用一个重传计时器。为方便说明，字节编号取得很小。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6bf72bbc-5975-478d-9240-ecd57e4b9d97"></div><p>发送窗口的后沿（left wall）只能向前移动（关闭 closes），前沿可向前移动（opens），也可收缩（shrinks），但 TCP 标准不赞成收缩。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/52271787-924e-4fbe-9341-63b39fd0f013"></div><p><strong>接收窗口</strong></p><p>下图是一接收窗口例子。实际上，接收窗口永远不会收缩。通常，接收方 TCP 等待应用进程来取数据。就是说，分配给接收方的缓存可能包含已接收且确认的数据字节，它们在正等待应用进程将它们拉走。接收窗口总是小于缓冲区的大小。接收窗口通常称为 rwnd，rwnd = 缓冲区大小 – 正在等待被拉走的字节数，如下图：rwnd = 40 。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/49a96632-fe3f-41c4-a55a-9974d2796802"></div><p><strong>窗口如何滑动</strong></p><p>TCP 通过滑动窗口机制实现流量控制。我们先忽略差错、拥塞等其他因素，且只简化讨论一个方向的数据传输。下图描述了一个例子，总是客户端发送数据，服务器确认。客户端是发送方，发送窗口，使用序号字段，服务器是接收方，接收窗口，使用确认号和窗口两个字段，窗口字段值是 rwnd 的值。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/035533ae-e496-40d2-9474-8823e132cfe1" width="80%"></div><p>假设发送方的缓冲区与接收方的缓冲区大小都是 800 字节。</p><ol><li>第 1 个报文段，客户端发给服务器，SYN 报文段，seq=100。三次握手建立连接的第一个报文，请求连接，并通告初始序号是 seq=100。</li><li>第 2 个报文段，服务器发给客户端，SYN+ACK 报文段，ack=101，rwnd=800。三次握手建立连接的第二个报文，窗口值通告 rwnd=800。</li><li>第3个报文段，客户端发给服务器，ACK报文段。客户端通告rwnd=2000，表示客户端的接收缓冲区的大小，我们忽略这个值，只讨论单向传输。</li><li>第 4 个报文段，客户端发给服务器，数据报文段，seq=101。客户端发送一数据报文段，携带 200 字节数据，数据字节编号 101~300，序号字段填写第 1个数据字节的编号 seq=101。发送窗口前沿在 901，后沿在 101，显示已发送 200字节数据，正等待确认。</li><li>第 5 个报文段，服务器发给客户端，ACK 报文段，ack=301，rwnd=600。服务器收到 101~300 号字节，共 200 字节数据，接收窗口调整，后沿向前滑动 200 字节，表示已收好 200 字节。向客户端发送 ACK 确认，确认字段值 ack=301，表示 301 号之前数据收好，下一个希望接收的字节是 301 号字节。注意，此刻 200 字节数据仍在接收缓冲区内，服务器的应用进程还没将它们拉走，接收窗口的大小 rwnd= 800 – 200 = 600。报文段中通告的窗口值为 600。</li><li>第 6 个报文段，客户端发给服务器，数据报文段，seq=301。客户端收到确认 ack=301，rwnd=600。客户端知道服务器已经收好 101~300 号字节，就可以删除这些数据，发送窗口调整，后沿向前滑动 200 字节，至01 处。但前沿不能向前滑动，因为现在接收方通告的 rwnd=600，前沿=301+600=901。客户端发送数据报文段，携带 300 字节数据，数据字节编号 301~600，序号字段eq=301。</li><li>第 7 个报文段，服务器发给客户端，ACK 报文段，ack=601，rwnd=400。服务器收到第二次的 301~600 号字节数据，共 300 字节数据。接收窗口调整，后沿向前滑动 300 字节，至 601 处。因 TCP 使用累积确认，向客户端发送的确认为 ack=601，表示 601 号之前所有数据收好，下一个希望接收的字节是 601 号字节。注意，此刻 200+300=500 字节数据仍在接收缓冲区内。这时，服务器的应用进程拉走 100 字节数据，接收缓冲区的 101~200 号字节空间被释放，但 201~601的 400 字节数据滞留在接收缓冲区内。接收窗口的大小 wnd= 800 – 400 = 400。通告窗口值为 rwnd=400。客户端收到确认 ack=601，rwnd=400。客户端知道服务器已经收好 601 号之前的数据，就可以删除这些数据，发送窗口调整，后沿向前滑动至 601 处。因为现在接收方通告的 rwnd=400，前沿=601+400=1001。前沿向前滑动至 1001 处。</li><li>第 8 个报文段，服务器发给客户端，ACK 报文段，ack=601，rwnd=600。服务器的应用进程又拉走 200 字节数据，接收缓冲区的 201~400 号字节空间被释放，但 401~601 的 200 字节数据仍滞留在接收缓冲区内。接收窗口的大小 rwnd= 800 – 200 = 600。通告窗口值为 400。对于确认来说，服务器现在收好的是 601 号字节之前的数据，确认为 ack=601，表示希望接收的下一个字节是 601 号字节。客户端收到确认 ack=601，wnd=600。客户端知道服务器已经收好 601 号之前的数据，发送窗口的后沿就在 601 处，不需滑动。因为现在接收方通告的rwnd=600，前沿=601+600=1201。前沿向前滑动至 1201 处。</li></ol><p><br></p><h3 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h3><p>假如 TCP 发送的报文段只含有 1 个字节的数据，那么意味着为发送 1 字节的数据，而发送了 41 个字节的报文段，20 个字节的 TCP 首部和 20 个字节的 IP首部。此时的效率是 1/41。这一现象称为糊涂窗口综合症（Silly Window Syndrome）。糊涂窗口综合症是怎样产生的呢?</p><p><strong>由发送方产生的糊涂窗口综合症（Syndrome Created by the Sender）</strong></p><p>如果发送方 TCP 正在为一个产生数据很缓慢的应用程序服务，例如一次产生 1 字节数据，就有可能产生糊涂窗口综合症。解决方法是使用 Nagle 算法。<br>Nagle 算法</p><ol><li>发送方 TCP 把它从应用进程收到的第一块数据发送出去，即使只有 1 字节。</li><li>在发送一个报文段后，发送方 TCP 就在输出缓存中累积数据并等待，直至收到接收方发来的确认，或者已积累了足够的数据已达到报文段的最大长度时，就立即发送一个报文段。</li><li>重复步骤 2。<br>Nagle 算法之巧妙，在于其巧妙地平衡了应用程序产生数据速度和网络传输速度。如果应用程序比网络速度快，报文段就大（最大报文段长度），如果应用程序比网络速度慢，报文段就小。</li></ol><p><strong>由接收方产生的糊涂窗口综合症（Syndrome Created by the Receiver）</strong></p><p>如果接收方 TCP 正在为一个消耗数据很缓慢的应用程序服务，例如一次消耗 1 字节数据，接收方每次发送 rwnd=1 的通告，就有可能产生糊涂窗口综合症。解决方法的是推迟确认。<br>报文到达时，不立即发送确认，接收方等待一段时间，直到输入缓存有足够的空间（或者接收缓存已有一个最长报文段的空间，或者接收缓存已有一半空闲的空间），就发送确认报文。但推迟确认不能超过 500ms。</p><p><br></p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制是 TCP 协议中最重要的一部分。理解 TCP 的拥塞控制，关键在于真正理解网络拥塞这一现象，理解了拥塞，以后的内容都会顺理成章的很好理解。</p><p><strong>拥塞概述</strong></p><p>两个主机，通过中间的一个传输网，连接在一起。正是因为中间有网络，就有了网络拥塞问题。谈网络拥塞之前，先回忆一下路由器的原理。网络层的路由器是一种“尽力而为”的机制。当超过路由器的能力时，路由器就将会丢弃数据报。假设路由器每秒能转发 1000 个数据报，此刻来了 1200 个数据报，路由器就将后 200 个数据报丢弃。注意：当没有超过路由器的负载能力时，路由器是不会丢弃数据报的。换一句话说，就是某个路由节点拥塞了，才会丢弃数据报。<br>怎么解决拥堵呢？很明显有两种方案，用公路网来打比方就是增加路的数量和减少驶入公路网的车。从协议的角度考虑，自然是做不到增加路的数量，所以我们就要控制发送到网络中的数据量。</p><p><strong>传输网络</strong></p><p>当网络拥塞时，如同城市交通堵塞，南城的人去不了北城，北城的人一样也去不了南城，路都堵死了，谁也走不了。也就是说，拥塞时，网络外围的所有主机，发送的数据包都会被丢掉，所以一定不会有返回的 ACK 确认，超时定时器一定会闹响。也就是说，网络拥塞时，所有主机都会超时。这样问题就解决了，简单归纳为一句话，超时就表示网络拥塞。</p><blockquote><p>超时就表示网络全拥塞。<br>因为 TCP 协议中以超时做为网络拥塞的判断依据，重传定时器的值需要估算合适，这很重要。值估算小了，实际网络不拥塞，确产生了超时重传，误判为拥塞，就不能充分使用网络的传输能力。值估算大了，实际网络已经拥塞，确没有产生超时重传，误判为通畅，就会使拥塞更加恶化，最终通信崩溃。在日常的生活中，城市的交通堵塞一定是渐渐堵死的，绝无可能在前一分钟，全城都是通畅的，后一分钟，全城所有的道路都堵死。总是开始时某些路段堵死，然后慢慢扩大，最后全部堵死。如果在某些路段堵死的时候，就开始疏导，有可能不会演变为全堵死。同理在计算机网络中，也很难相信，在前一分钟，所有的路由器都负载很轻，后一分钟，所有的路由器都超负载。应该是，某些路由器超负载了，其他路由器正常，这时后续的数据包就会自动绕路。假设某主机，连续发送了 2，3，4，5号数据包，2 号数据包碰到超负荷的路由器，被路由器丢弃，3，4，5 号数据包绕路到达目的主机，目的主机发送了 3 个 ACK 确认，请求 2 号数据包。当发送方收到 3 个重复 ACK 时，就会判断，网络是部分拥塞的，前面的数据包堵死在路上，后面的数据包绕路走了，已经到达目的地。简单归纳为一句话，3 个重复ACK 就表示网络部分拥塞，我称为半拥塞。<br>3 个重复 ACK 就表示网络半拥塞。<br>至此，外围的主机有了推测中间传输网络状态的办法，这两个事件就标志着网络的两种状态。用两个事件标志两种网络状态的方法，需要认真领会。TCP 的拥塞控制不能算闭环，没有一个具体的设备发出一个网络拥塞的信号，因为拥塞是全网的状态，不是某一个路由器的状态。一个路由器超载，可以绕其他路由器。TCP 的拥塞控制也不能算开环，“超时”与“3ACK”这两个事件确实反馈了中间传输网络的状态，为决策提供了依据。了解了网络现在的状态，就好办了。全拥塞有全拥塞的处理办法，半拥塞有半拥塞的处理办法。</p></blockquote><p><strong>拥塞窗口</strong></p><p>在上文中，讨论过 TCP 的流量控制，发送方窗口大小是由接收方的可用缓存空间（rwnd）决定的，就是由接收方指示发送方应当使用多大的窗口，这当然可以保证接收方不会溢出。但是，这个方法没考虑网络的存在，上文说过，要调控网络拥塞，就要根据当前网络的状态，调整发送到网络中的数据量。也就是说，TCP 需要一个控制变量，即TCP 发送方使用拥塞窗口 cwnd （Congestion Window）作为控制变量，根据当前网络的拥塞程度，拥塞窗口的大小动态地变化，调整发送的数据量。这样一来发送窗口大小不仅取决于接收方通告的接收窗口 rwnd，还取决于网络的拥塞状况 cwnd，进而 实际的发送窗口 = min（ rwnd , cwnd ）</p><p><strong>拥塞检测</strong></p><p>TCP 的发送方使用两个事件作为判断网络全拥塞和半拥塞的依据。超时表示网络全拥塞。3 次重复 ACK 表示网络半拥塞。</p><blockquote><p>超时<br>上文已经解释过拥塞的现象，我们现在简单理解为：发送方的超时事件就表示中间网络全部堵死了。<br>发送方 TCP 在整个连接期间，只维护一个 RTO 计时器。发送方发送段 1 和 段 2，计时器启动，接收方发回 ACK，发送方收到 ACK 后，计时器清零。在启动计时器，发送段 3，段 4，段 3 丢失，段 4 到达，接收方将段 4 存储下来，因为段 3 丢失，接收方留出一个间隙，表明数据是不连续的，接收方只能再发送对段 2 的确认 ACK。发送方收到确认，但因为不是对段 3，段 4 的确认，计时器不能清零，计时器超时，就会重传段 3，并重启计时器，这次段 3 正常到达，接收方发送 ACK，发送方收到，将计时器清零。</p></blockquote><div align="center"><img src="http://blogfileqiniu.isjinhao.site/84f15937-f917-4fa2-9f6b-9bd4790bcddd"></div><blockquote><p>三次重复 ACK（3dupACKs）<br>三次重复 ACK，也称做“快重传”（Fast retransmission）。如下图：发送方发送 2 个段后，正常收到 ACK，这个 ACK 是原始的 ACK，超时计时器清零。发送方再发送 4 个段，并再次启动超时计时器，段 3 丢失，段 4，5，6 到达。当接收方收到失序的数据段时，立即发送 ACK。接收方会发出 3 个重复的 ACK。发送方收到三个重复的 ACK，就立即重传丢失的报文段，而不等待计时器超时，并重启计时器。这一规则称为“快重传”，目前的 TCP 都遵守这规则。</p></blockquote><div align="center"><img src="http://blogfileqiniu.isjinhao.site/798ac667-fc74-4728-8ea6-e41631d22166"></div><p>三次重复 ACK，显然是某个报文段丢失了，后面的报文段正常到达。这就表示网络有堵死的地方，造成丢失，其他部分通畅，后面的报文段绕行了通畅的路径。我们现在简单理解为：发送方收到三次重复 ACK，就表示中间网络半堵死。</p><h4 id="拥塞控制策略"><a href="#拥塞控制策略" class="headerlink" title="拥塞控制策略"></a>拥塞控制策略</h4><p>TCP 拥塞策略基于两个阶段，慢启动（slow-start，SS）阶段和拥塞避免（congestion avoidance，CA）阶段。在慢启动阶段，发送方从非常慢的速率开始，很快达到一个门限值。当到达门限值，进入拥塞避免阶段。</p><p><strong>慢启动（SS, Slow start）</strong></p><p>指数增大，拥塞窗口 cwnd 从 1 个最大报文段 MSS 开始。每收到一个 ACK 确认，拥塞窗口增加一个 MSS。慢启动算法开始很慢，但它是以指数增大的。<br>按 ACK 计算， cwnd = cwnd + 1。<br>如图，从 cwnd=1 开始，第 1 个 ACK 到达后，cwnd 加 1，就是 2。这时，就可发送 2 个段，相应的回来 2 个 ACK，对于每个 ACK，cwnd 加 1，就是 4 了。是按指数增大的。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/b458f253-508e-4a58-abf6-9035cb56c1ea"></div><p>慢启动不能无限制的指数增大，有一个门限值来终止慢启动。发送方有一个慢开始门限 ssthresh（slow-start threshold）的变量，当拥塞窗口大小达到阈值时，慢启动停止，开始拥塞避免阶段。</p><p><strong>拥塞避免（CA，Congestion avoidance）</strong></p><p>加法增大，在慢启动阶段，当拥塞窗口达到慢开始门限 ssthresh 的值时，慢启动停止，进入拥塞避免阶段。此时，拥塞窗口按加法增大。每次整个“窗口”的所有段都被确认后，拥塞窗口增加 1。<br>举例，发送方以 cwnd=4 开始，此刻发送方只能发 4 个段，在 4 个 ACK 到达后，拥塞窗口才加 1。如果按往返时延 RTT 观察，拥塞窗口是每一轮次加 1。<br>按 ACK 计算， cwnd = cwnd + ( 1 / cwnd )<br>按 RTT 计算， cwnd = cwnd + 1</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/1ea0b9ed-9022-4808-82a5-bd5ce4ae9ca9"></div><p><strong>拥塞控制策略的转换</strong></p><p>在拥塞避免阶段，拥塞窗口加法增大。拥塞避免阶段会一直持续下去吗？继续下去，会是什么情况？显然，拥塞避免阶段继续下去，网络只会有处于通畅，半拥塞，全拥塞三种状态中的一种。就如同城市交通一样，只会是不堵车，部分堵死，全部堵死这三种情况之一。</p><blockquote><p>通畅<br>标志是无事件发生。拥塞避免阶段继续，拥塞窗口继续按加法增大。<br>半拥塞</p><ul><li>标志事件是：发送方收到三次重复 ACK（3dupACKs）。</li><li>处理办法是：<ul><li>ssthresh 门限值设为此刻 cwnd 的一半 ssthresh = cwnd / 2</li><li>将拥塞窗口设为门限值。 cwnd = ssthresh</li><li>进入拥塞避免阶段。<br>全拥塞</li></ul></li><li>标志事件是：发送方超时。</li><li>处理办法是：<ul><li>ssthresh 门限值设为此刻 cwnd 的一半 ssthresh = cwnd / 2</li><li>将拥塞窗口重新设置设为 1。 cwnd = 1</li><li>进入慢启动阶段</li></ul></li></ul></blockquote><div align="center"><img src="http://blogfileqiniu.isjinhao.site/ddef19c7-997b-49f1-a770-1376ac491b01"></div><p><strong>拥塞举例</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/1eb816dc-dcee-40b4-9cca-ac8f6a628e40"></div><p><br></p><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>TCP 是一种面向连接的协议。TCP 以全双工方式传送数据。在 TCP 中，面向连接的传输需要经过三个阶段：连接建立，数据传输，连接断开。TCP 连接采用客户服务器方式。主动发起连接建立的应用进程叫做客户（client），被动等待连接建立的应用进程叫做服务器（server）。</p><p><strong>TCP 连接管理的三规则</strong></p><ul><li>规则 1：TCP 规定，SYN 报文段不能携带数据，但要消耗掉一个序号</li><li>规则 2：TCP 的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号。</li><li>规则 3：TCP 规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。</li></ul><h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h4><p>TCP 建立连接的过程叫做三次握手（three-way handshaking）。服务器首先打开一个端口，端口处于监听态，称为被动打开。客户端发起连接请求，连接到服务器的打开的端口上，连接就建立了。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/525579dd-b72f-4bcc-953d-b747534cdb28"></div><ol><li>客户端发送第 1 个报文段，SYN 标志置 1，SYN 是请求同步的意思，SYN 报文段是控制报文，只在每个方向的第 1 个报文里出现。客户随机选择一个数字作为初始序号，假设为 x。<strong>TCP协议规定：SYN 报文段不能携带数据，但要消耗掉一个序号。</strong></li><li>服务器发送第 2 个报文段，SYN，ACK 置 1。SYN 标志表示服务器方的请求同步，并且服务器设置自己的初始序号，假设为 y。ACK 置 1 表示包含确认，这个确认是对客户端 SYN 报文的确认，所以确认号=x+1，表示序号 x+1 之前的报文都收好了，希望收到序号为 x+1 的报文段。</li><li>客户端发送第 3 个报文段，ACK 标志置 1。这个报文段仅仅是一个 ACK 段，通常不携带数据。这个段是客户端发出的，序号就是 x+1。ACK 置 1 表示包含确认，这是对服务器 SYN 报文的确认，确认号=y+1，表示服务器发送的序号 y+1 之前的报文都收好了，希望收到服务器发送的序号为 y+1 的报文段。要特别注意教材中的这句话，并需要真正理解。<strong>TCP 的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号。</strong><br>举例：客户端发送的第 1 个 SYN 报文段，序号为 8000，服务器发送的第 2 个 SYN+ACK 报文段，序号为 15000，此后，客户端发送了第 3 个报文段，未携带数据，第 4 个报文段，携带 100 字节数据，问客户端发送的第 3，4 个报文段的序号是什么？<br>解析：第 3 个报文段，序号为 8001，因为序号 8000 已经被 SYN 报用掉了。 第 4 个报文段，序号仍然是 8001，注意不是 8002，因为第 3 个报文段是一个 ACK 报文段，并且没携带数据，所以不消耗序号，就是说第 3 个报文的序号 8001 没有被用掉，在第 4 个报文中继续使用。</li></ol><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>连接建立后，可进行双向的数据传输。客户端和服务器都可以发送数据和确认。TCP 连接使用了序号和确认号的机制。</p><h5 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h5><p>TCP 把要发送的数据都按字节编上号。两个方向的编号是相互独立的。编号并不是从 0 开始，而是使用一个随机数作为初始编号，初始编号在建立连接的第一个 SYN 报文段里通告给对方。每个 TCP 报文段都有序号字段，序号字段值是这个报文段中第一个数据字节的编号。</p><blockquote><p>TCP 报文的序号字段值是这个报文段中第一个数据字节的编号。</p></blockquote><h5 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h5><p>TCP 使用确认机制。当报文段中 ACK 标志置 1，报文的确认号字段有效，TCP 的确认是累计确认，确认号字段值是完全接收好的数据的最后一个字节的编号+1，表示此值前的数据已收好，期望接收的下一字节是此值。举例，确认号是5644，表示从开始到 5643 号字节的数据都已收好，希望接收 5644 号字节。<br>TCP 是累积确认。确认号字段值是期望接收的下一个字节的编号。<br>举例：客户端发送一报文段，序号 8001，确认号 15001，携带 1000 字节数据。服务器发送的下一个报文段，序号，确认号是多少？服务器的回复携带 2000 字节数据，则客户端发送的再下一个报文，序号，确认号是多少？<br>解析：因第 1 个报文的确认号 15001，是期望接收的下一个报文段的序号，所以，服务器发送的下一个报文段的序号是 15001。因第 1 个报文的序号 8001，携带 1000 字节数据，服务器收到了 8001-9000 编号的 1000 字节数据，确认号是9001，表示 9001 号字节之前的数据已经收好，希望接收的下一个字节是 9001号字节。同理，第 3 个报文，序号为 9001，确认号是 17001。</p><h4 id="连接断开"><a href="#连接断开" class="headerlink" title="连接断开"></a>连接断开</h4><p>数据传输结束后，客户端和服务器任一方都可以发起断开连接。一般来说客户端发起断开连接。TCP 连接释放过程是四次握手。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/1538eed9-f35b-4b5b-bb0d-bf820cda3e89"></div><ol><li>正常情况下，客户端发起连接断开的请求。客户端发送第 1 个报文段，FIN 标志置 1，FIN 是请求结束的意思，表示客户端方向数据传输结束。假设这个段的序号是 u，在此图中，FIN 报文段值只是控制报文，没携带数据。<strong>TCP 规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。</strong></li><li>服务器发送第 2 个报文段，ACK 报文段，确认它收到了客户端的 FIN 报文段，假设其序号为 v，确认号= u+1。</li><li>服务器发送第 3 个报文段，FIN 报文段，两个标志 FIN，ACK 置 1，FIN 表示服务器方向数据传输结束，确认仍是对第 1 个报文段的确认，确认号= u+1。注意，其序号仍然是 v，原因是第 2 个报文段运用了下述的规则 2，其序号 v 没有消耗，继续使用。</li><li>客户端发送第 4 个报文段，ACK 报文段，ACK 标志置 1，确认是对服务器 FIN 报文段的确认，确认号= v+1。其序号是 u+1，原因第 1 个报文段运用了规则 3，序号 u 被消耗掉了，所以现在序号是 u+1。</li></ol><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;传输服务&quot;&gt;&lt;a href=&quot;#传输服务&quot; class=&quot;headerlink&quot; title=&quot;传输服务&quot;&gt;&lt;/
      
    
    </summary>
    
      <category term="网络" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://isjinhao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>04.01-网络-绪论&amp;物理层</title>
    <link href="https://isjinhao.github.io/posts/52199.html/"/>
    <id>https://isjinhao.github.io/posts/52199.html/</id>
    <published>2019-12-20T09:22:11.000Z</published>
    <updated>2019-12-30T13:20:35.743Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>计算机网络就是互联的、自治的计算机集合。自治指的是所有的计算机直接没有主从关系；互联指的是互联互通，能进行数据交换。<br>计算机网络的本质是一种通信网络，只不过信源和信宿都是主机。它是计算机技术和通信技术的结合。</p><p><strong>信道</strong></p><p>信道是数据交换的载体。狭义上说人和人之间交流所承载信息的空气就是信道。广义上说它还可以包括有关的变换装置，这样的话信道往往被分成信道编码器、信道本身和信道译码器。简易通信系统模型如下：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/cb141b56-b5ee-4a92-9d19-2be0a5a24e75"></div><p><br></p><h2 id="计算机网络基本原理"><a href="#计算机网络基本原理" class="headerlink" title="计算机网络基本原理"></a>计算机网络基本原理</h2><p>分组交换技术，也就是拆分分组、传输分组、合并分组的技术。这个技术的优点就是便宜，因为把数据打包成分组和分组拆分都在计算机中进行，网络上只进行分组的转发，就使得网络的结构很简单，路由器设计也很简单。这一中原则被叫做“端到端的原则”，即能在端系统做的事情不在网络上实现。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e86bd0fa-aeae-45e2-afb5-c10e2b8af5d3" style="width:60%"></div><p><strong>主机（host）</strong></p><p>诸如手机、电脑、服务器等端系统（end systems）。</p><p><strong>交换机</strong></p><p>如果想实现多个计算机之间的互联，按照之前的想法是每两台计算机进行连接，但这样太麻烦，一个好的做法是把这个计算机连接在某一中心上，这个中心把所有连接上来的计算机进行互联，在链路层这个中心叫做交换机。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/540709b5-356a-40fd-96f6-bff6dfd4b7e7" style="width:25%"></div><p><strong>分组</strong></p><p>分组是带有地址信息的信息小片，可以理解成是计算机把一个文件切片后打成的包裹，由两部分构成：地址信息和真正传输的东西。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/9f112321-0df3-423e-bd4f-0f1311fccf6b"></div><p><strong>路由器</strong></p><p>是计算机网络的一种专用计算机，它只有一个功能，就是转发分组。可以简单的理解为路由器是电子化的邮局，全国所有的邮局之间互联，是包裹能够传递，路由器之间互联，是分组能够正确转发。<br>路由器和交换机的区别是：交换机将计算机连在一起，构成局域网；路由器将局域网连在一起，形成互联网。</p><p><br></p><h3 id="分组交换技术"><a href="#分组交换技术" class="headerlink" title="分组交换技术"></a><strong>分组交换技术</strong></h3><ol><li>一个主机至少连接一个路由器：数据最终是通过路由器进行转发的，所以一个主机至少得连接一个路由器。</li><li>分组存储转发：分组完全进入路由器后，路由器按照地址信息检索转发表。注意不是第一个bit或Byte进入时就开始转发，是全部进入才转发。</li><li>分组独立选择路径：一个文件被分成多个分组，但这些分组之间是独立的，路由器给他们看成相互独立的数据。分组的组装是通过接收方进行的，和网络无关。</li></ol><p><br></p><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><p><strong>ISP</strong></p><p>ISP，全称为Internet Service Provider，因特网服务提供商，即指提供互联网服务的公司。能提供拨号上网服务、网上浏览、下载文件、收发电子邮件等服务。</p><p><strong>不同角度看Internet</strong></p><ul><li>组成细节角度：ISP网络互联形成的网络之网络。由运行各种网路应用的计算设备，光纤、铜缆、无线电等通信链路、路由器和交换机等组成的分组交换设备组成。</li><li>服务角度：是为网络应用提供通信服务的通信基础设施和为网络应用提供的应用编程接口。</li></ul><p><br></p><h3 id="Internet结构"><a href="#Internet结构" class="headerlink" title="Internet结构"></a>Internet结构</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6c2e0e1d-7464-4e21-9613-555098981116" style="width:70%"></div><ul><li><code>一级ISP包含</code>：网通、电信等商业ISP，还包含谷歌、微软等内容提供商网络。</li><li><code>IXP</code>：全称：Internet eXchange Point，即互联网交换中心。互联网Internet是由众多的网络互相连接而形成的全球性网络，互联网交换中心负责这些不同的网络之间互相通信的交换点，是互联网的关键基础设施。</li></ul><p><br></p><h2 id="网络的结构"><a href="#网络的结构" class="headerlink" title="网络的结构"></a>网络的结构</h2><ul><li>网络边缘：位于“网络边缘”运行网络应用程序的端系统。</li><li>接入网络、物理介质：有线或无线的通信链路。</li><li>网络核心：互联的路由器（或分组转发设备）。构成“网络之网络”的关键。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/be135250-0412-4b86-8a24-fc9721f3e72a" style="width:25%"></div><p><br></p><h3 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h3><p>接入网络是一种用户网络，它连接用户到特定的服务提供商并通过承载网络到达其他网络。两个被用户关心的特征：带宽（数据传输速率，bps）、独占/共享（独占是带宽为某用户独用，共享是多个用户分用同一带宽）。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/f3a7b5dd-8def-42e9-a42b-dab1f978146a" style="width:45%"></div><p><strong>家庭接入</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/4e2f6236-0695-4119-aeab-83a40f1c6872" style="width:60%"></div><p><strong>机构（企业）接入</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/746d62b1-e5b4-45c2-add6-ab4481d685d5" style="width:55%"></div><p><strong>无线局域网</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/fbf80f8f-4746-447e-a9b6-aef4e6efe108" style="width:25%"></div><p><strong>广域局域网</strong></p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/5b47b9b2-71be-4283-8fc5-ee8199b954d2" style="width:30%"></div><p><br></p><h3 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h3><p>网络核心的功能是：路由（routing）：确定分组从源到目的传输路径；转发（forwarding）：将分组从路由器的输入端口交换至正确的输出端口。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/62b0406d-4aef-4de6-8280-651809e62c3f" style="width:70%"></div><p><br></p><h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>包含三个阶段：建立连接、通信、释放连接。最显著的特点是独占电路资源。最典型的是电话网络。（下图的中继线上可以存在多组用户通信，详见复用技术）</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/d6034a53-8e86-47fc-bf19-5bf762352514" style="width:80%"></div><p><br></p><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>报文交换是指把信息整个打包，然后经过存储转发送到目的地。</p><p><br></p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>分组交换是把信息拆分成不同的分组，然后把所有的分组相继发送给路由器，路由器通过路由&amp;转发把数据传输到目的地。</p><ul><li>和报文交换的区别是：报文交换不拆分信息。</li><li>和电路交换的区别是：如果把每个分组看成原子单位，区别就是各分组走不同的路径，不需要独占资源。</li></ul><h4 id="分组交换的优势"><a href="#分组交换的优势" class="headerlink" title="分组交换的优势"></a>分组交换的优势</h4><ul><li>和报文交换相比：速度快，因为在报文交换时，同一时间只有一个路由器在工作，其他路由器在等待。路由器的存储空间小，最低存储空间和分组大小差不多。</li><li>和电路交换相比：分组交换允许更多用户同时使用网络，让网络资源充分共享。</li></ul><h4 id="分组交换的劣势"><a href="#分组交换的劣势" class="headerlink" title="分组交换的劣势"></a>分组交换的劣势</h4><p>可能产生拥塞（congestion）：分组延迟和丢失。需要协议处理可靠数据传输和拥塞控制。</p><p><br></p><h3 id="图解三种交换"><a href="#图解三种交换" class="headerlink" title="图解三种交换"></a>图解三种交换</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/8285469f-5cc3-4866-8578-a7a72f4aba93" style="width:80%"></div><p><br></p><h2 id="网络性能参数"><a href="#网络性能参数" class="headerlink" title="网络性能参数"></a>网络性能参数</h2><p><strong>速率 &amp; 带宽</strong></p><ul><li>速率：又称数据率，数据传输速率或比特率。单位bps、kbps、Mbps、Gbps。</li><li>带宽：数字信道所能传输的最大数据率。单位bps等。</li></ul><p><strong>丢包</strong></p><p>如果路由器的缓存满了，再到达的分组会被路由器丢弃，即造成丢包现象。丢包率 = 丢包数 / 已发分组数。</p><p><strong>分组延迟</strong></p><ul><li>结点处理延迟：差错检测、确定输出链路；</li><li>排队延迟：等待输出链路可用、取决于路由器拥塞程度；</li><li>传输延迟：分组长度/链路带宽；</li><li>传播延迟：物理链路长度/信号传输速度。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/bb29b169-33bb-4979-a91e-c1e282396508" style="width:60%"></div><p><strong>流量强度</strong></p><p>设链路带宽为R(bps)，分组长度为L(bits)，平均每组到达速率为v。则：</p><ul><li>$L \ast v / R \longrightarrow 0 $时：平均排队延迟很小；</li><li>$L \ast v / R \longrightarrow 1$时：平均排队延迟很大；</li><li>$L \ast v / R &gt; 1$时：超出服务能力，延迟 趋向于 无限大。</li></ul><p><strong>时延带宽积</strong></p><p>$时延带宽积 = 传播时延 \ast 带宽$，单位：bit。实际意义是：从我们向某一信道上发送第一个bit，到这个bit被接收方接受这个时间里，发送方总共向信道上发送了多少bit。也可以称为以比特为单位的链路长度，比如某段链路长度为n比特。</p><p><strong>吞吐率/量（Throughput）</strong></p><p>发送端与接收端之间的传送数据率（b/s）。端到端的吞吐量取决于瓶颈链路。</p><p><br></p><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>network protocol。为进行网络中的数据交换而建立的规则、标准或约定。其中规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到的消息或发生的事件而产生的动作。也可以说网络协议规定了网络中所有信息的发送和接受过程。</p><p><strong>协议三要素</strong></p><ul><li>语义：语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。</li><li>语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。</li><li>时序：时序是对事件发生顺序的详细说明。（也可称为“同步”）。<br>总结：语义表示要做什么，语法表示要怎么做，时序表示做的顺序。</li></ul><p><br></p><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><p>指通信系统的整体设计，它为网络硬件、软件、协议、存取控制和拓扑提供标准。计算机网络是一个非常复杂的系统，需要解决的问题很多并且性质各不相同。所以，在设计时使用了“分层”的思想，即将庞大而复杂的问题分为若干较小的易于处理的局部问题。各层之间是按照功能进行分层的，同时每层遵循相应的网络协议完成本层功能。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/db782db0-9889-4ba0-a9a3-92684553f7b5"></div><p><strong>各层的主要功能</strong></p><ul><li>应用层：为用户提供具体的网络应用服务。</li><li>运输层：通过中间网络，两个主机中进程之间的通信服务。包含有可靠通信的协议TCP和无可靠性的协议UDP。</li><li>网络层：两台主机间的通信。分组交换网上的两台主机间的通信，选择合适的路由，构建互联网络，这些是同一件事的不同说法。</li><li>数据链路层：两个相邻结点之间，数据的可靠传输。</li><li>物理层：透明地传送比特流。</li></ul><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/b7177899-d60c-43b9-b045-50e37fddc7bc"></div><p><strong>各层传输数据的叫法</strong></p><ul><li>协议数据单元PDU（Protocol Data Unit）：对等层之间传送数据的单位。</li><li>服务数据单元SDU（Service Data Unit）：层与层之间交换数据的单位。<br>即：<code>PDU=首部+SDU=下一层的SDU</code>。</li></ul><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/c00de438-4b7e-4c9e-8039-fa14b1376978"></div><p><br></p><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><p>假如基带信号是<code>101011000110111010...</code>，如果直接发送，则每个码元携带一个比特的信息（每个码元只有2种状态），但是如果将信号中的三个比特编为一组，即101，011，000，110，111，010…，三个比特共有8种不同的排列，我们可以用不同的调制方法来表示这种信，如8种不同的振幅，频率，相位等，如果采用相位调制，相位$\phi_0$表示000，$\phi_1$表示001，以此类推，那么接收端如果收到相位是$\phi_0$的信号就知道表示的是000，以此类推，这样一个码元就不知不觉的传输了三个比特位的信号，此时每个码元有8种状态。一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难。</p><p><strong>编码级别</strong></p><p>如果把n个比特编码成一个码元，则此时编码状态$M=2^n$，其表示当前传输时有多少不同的状态，如8级编码，会有：<code>000、001、010 …</code>，共计8种状态。</p><p><br></p><h2 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h2><p>数据通信中很自然很重要的一个问题：在一个通道中，能够以多快的速率发送数据，即每秒钟能发送多少比特？比特是由电磁信号携带的，所以这个问题要再拆分一下：</p><ol><li>问题1：在一个通道中，能够以多快的速率发送信号？</li><li>问题2：一个信号能携带多少个比特？</li></ol><p><br></p><h3 id="奈斯准则"><a href="#奈斯准则" class="headerlink" title="奈斯准则"></a>奈斯准则</h3><p><strong>码间串扰</strong></p><p>码元的传输速率是有限制的，超过某上限就会出现码间串扰问题。这是由于在真正传输中，信号在传输时都不是理想化的，如下图就是理想化的高低电平和真实传输时的高低电平。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/86866885-db6c-4686-a45d-f1c29d05e60a" style="width:40%"></div><p>假如此时速度太快，就可能把低电平和高电平弄混。而最高的码元传输速率被奈斯准则限制。</p><p><strong>奈斯准则内容</strong></p><ul><li>理想低通信道（能通过信号频率在某值之下）的最高码元传输速率为：$2W Baud$。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/68d8fe1f-0d45-4778-b233-ca72ca0cb4fd" style="width:80%"></div><ul><li>理想带通信道（能通过信号频率在某范围之内）的最高码元传输速率为：$1W Baud$。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/7ec776ff-084d-4641-884e-c82bf93ae0b4" style="width:80%"></div><p>W是理想低通信道的带宽，单位为赫(Hz)。Baud 是波特，是码元传输速率的单位，1 波特为每秒传送 1 个码元。</p><ul><li>波特率：单位时间内数据通信系统所传输的码元个数（信号个数），单位是波特（Baud）。</li><li>比特率：表示单位时间内数据通信系统传输的比特数，单位是比特/秒（b/s或bps）。$比特率 = 波特率 * log_2M$</li></ul><p><br></p><h3 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h3><p><strong>编码级数限制</strong></p><p>虽然码元传输速率有限制，但是如果我们能尽可能提高编码级数不就能提升信息传输速率了吗？但事实上信号传输速率不受限于调制技术，而是受限于信噪比。举个例子，如果我们是在天气晴朗的一天出门，我们穿任意颜色衣服都能被分辨出来，但是如果我们在沙尘暴天气出门，穿<code>橘黄</code>和<code>橙黄</code>两种颜色的衣服别人自然就认不出来了。在这个比喻中衣服的颜色代表码元，确定衣服的颜色代表信息，沙尘暴就是噪声。</p><p><strong>香农公式内容</strong></p><p>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率$C=W \ast log_2(1+PS/PN)（b/s）$。</p><ul><li>其中$W$是信道的带宽。$PS$是信号的能量。$PN$是噪声的能量。</li><li>信噪比：$S/N=10lg{PS/PN}$。<br>举例：带宽是<code>1MHz</code>，信噪比是<code>24dB</code>，则信道的最高信息传输速率：$C=1M \ast log_2{(1+(10^{2.4}))}=7.98Mbps$。</li></ul><p><br></p><h3 id="奈氏准则vs香农公式"><a href="#奈氏准则vs香农公式" class="headerlink" title="奈氏准则vs香农公式"></a>奈氏准则vs香农公式</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6011892c-da47-4cf8-a1e8-a7acf176cd0f" style="width:80%"></div><p><br></p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>电路交换中独占电路资源，并不是指用户线和中继线都被此次交换所独占，而是说在两个用户建立连接之后，除非连接中断，否则他们当前所拥有的资源不会被释放，即使他们之间不传输信息。而如何在中继线上实现多组用户通信就是多路复用技术。<br>产生多路复用的物理基础是：传输媒体的带宽或容量往往会大于传输单一信号的需求，使用多路复用，为了有效地利用通信线路，希望一个信道同时传输多路信号。<br>这种技术会将链路/网络资源（如带宽）划分为“资源片”，将资源片分配给各路“呼叫”（calls），每路呼叫独占分配到的资源片进行通信，资源片可能“闲置”<br>常见的复用技术有：频分多路复用、时分多路复用、波分多路复用、码分多路复用。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/a0a4f676-e2fd-47d2-bdbb-566054c38206" style="width:80%"></div><p><strong>频分多路复用</strong></p><p>FMD：Frequency-division multiplexing，是指载波带宽被划分为多种不同频带的子信道，每个子信道可以并行传送一路信号的一种多路复用技术。也就是说信道的可用频带被分成若干个互不交叠的频段，每路信号用其中一个频段传输，因而可以用滤波器将它们分别滤出来，然后分别解调接收。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e2799478-b496-4a0a-853f-bfc708b69443" style="width:40%"></div><p><strong>时分多路复用</strong></p><p>TDM：time division multiplexing，它使不同的信号在不同的时间内传送，将整个传输时间分为许多时间间隔（Time Slot，TS，又称为时隙），每个时间片被一路信号占用。TDM就是通过在时间上交叉发送每一路信号的一部分来实现一条电路传送多路信号的。电路上的每一短暂时刻只有一路信号存在。因数字信号是有限个离散值，所以TDM多应用于数字通信系统。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/64c09afb-772f-43a0-90a9-cd44eeec4368" style="width:70%"></div><p><strong>波分多路复用</strong></p><p>将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器（亦称合波器，Multiplexer）汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；在接收端，经解复用器（亦称分波器或称去复用器，Demultiplexer）将各种波长的光载波分离，然后由光接收机作进一步处理以恢复原信号。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/08d98e2f-6c88-430f-9bb7-e055f3c4b476" style="width:70%"></div><p><strong>码分多路复用</strong></p><p>为每个用户分配一个唯一的mbit的码片序列（chipping sequence），二进制下的0用-1表示，二进制下的1用+1表示。在信道上传输的信号 = 原始数据 <em>码片序列，比如码片序列是：(-1, 1, 1)，需要传一个0，应该是 -1 </em>(-1, 1, 1)，所以传输的就是(1, -1, -1)。<br>同时为了保证数据之间不相互影响，被共享的用户所占有的码片应该相互正交的。即：$\frac{1}{m}S_i \cdot S_j = 0 (i \neq j)$。而信道上真正传输的数据是各用户发送数据的叠加值。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/79261e94-12b6-41c9-a4e0-0759e893e6ea" style="width:80%"></div><p><br></p><h2 id="数字信号在模拟信道传输"><a href="#数字信号在模拟信道传输" class="headerlink" title="数字信号在模拟信道传输"></a>数字信号在模拟信道传输</h2><p>数字信号需要编码后才能传输。常见的三种编码：</p><ol><li>NRZ编码：进制数字0、1分别用两种电平来表示。常用-5V表示1，+5V表示0。</li><li>曼切斯特编码：用电压的变化表示0和1：高→低 &lt;=&gt; 0，低→高 &lt;=&gt; 1。</li><li>差分曼切斯特编码：在码元开始处有无跳变来表示0和1：有 &lt;=&gt; 0，无 &lt;=&gt; 1。</li></ol><div align="center"><img src="http://blogfileqiniu.isjinhao.site/e8108185-883f-4246-92a3-e68184a1baf8" style="width:80%"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;计算机网络&quot;&gt;&lt;a href=&quot;#计算机网络&quot; class=&quot;headerlink&quot; title=&quot;计算机网络&quot;
      
    
    </summary>
    
      <category term="网络" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://isjinhao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>04.03-网络-网络层</title>
    <link href="https://isjinhao.github.io/posts/12139.html/"/>
    <id>https://isjinhao.github.io/posts/12139.html/</id>
    <published>2019-12-20T09:22:11.000Z</published>
    <updated>2019-12-30T13:20:35.758Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><blockquote><p>网络层分为两分布，网络构建和网络通信</p></blockquote><p><br></p><h2 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h2><p>Autonomous System，AS。每个AS由一组通常处在相同管理控制下的路由器组成。一个ISP中的路由器以及连接他们的线路可以构成一个AS，一个ISP也可以将他们的网络划分成多个AS。每个AS由一个唯一的ASN来标识。所以在构建网络的时候，我们需要对 AS 内的网络和 AS 之外的网络进行区分。这两个统称为路由协议。</p><p><strong>内部网关协议</strong></p><p>Interior Gateway Protocol （IGP），用于自治系统（AS）内部的路由交换也叫做域内路由选择（intradomain routing），如 RIP 和 OSPF 协议</p><p><strong>外部网关协议</strong></p><p>Exterior Gateway Protocol （EGP），用于不同自治系统（AS）之间的路由交换，也叫做域间路由选择（interdomain routing），目前使用最多的是 BGP-4。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/80d95615-de0a-4b0f-9a33-94f3c2b3cd37"></div><p><strong>路由选择算法分类</strong></p><p>常用的分类是：每个路由器知道的是全局的信息还是分散的信息？</p><ul><li>全局的<ul><li>所有的路由器具有完整的拓扑和链路费用信息</li><li>“链路状态(L-S)”算法</li><li>应用于RIP协议</li></ul></li><li>分散的<ul><li>路由器只知道物理连接的邻居和到邻居的链路费用</li><li>迭代的计算过程，与邻居交换信息</li><li>“距离向量(D-V)”算法</li><li>应用于OSPF协议</li></ul></li></ul><p><br></p><h2 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h2><p>基于距离向量的分布式路由选择协议，规定：</p><ul><li>“距离”为到目的网络所经过的路由器数。</li><li>从一路由器到直接连接的网络的距离定义为 1。</li><li>RIP允许一个通路最多包含15个路由器，多于15个路由器时不可达。</li><li>RIP不能在两个网络之间同时使用多条路由，它选择一个具有最少路由器的路由，具有相同路径长度的路规定先入为主。</li></ul><p><br></p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>仅和相邻路由器交换信息。</li><li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。</li><li>按固定的时间间隔交换路由信息，例如，每隔 30 秒。</li></ul><p><br></p><h3 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h3><p>收到相邻路由器（其地址为 X）的一个 RIP 报文：</p><ol><li>先修改此 RIP 报文中的所有项目：将“下一跳”字段中的地址都改为 X，并将所有的“距离”字段的值加 1。</li><li>对修改后的 RIP 报文中的每一个项目，重复以下步骤：<ul><li>若项目中的目的网络不在路由表中，则将该项目加到路由表中。</li><li>否则<ul><li>若下一跳字段给出的路由器地址是同样的，则将收到的项目替换原路由表中的项目</li><li>否则<ul><li>若收到项目中的距离小于路由表中的距离，则进行更新</li><li>否则，什么也不做。</li></ul></li></ul></li></ul></li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则将此相邻路由器记为不可达的路由器，即将距离置为16（距离为16表示不可达）。</li><li>返回。</li></ol><p><br></p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>一开始，各路由表只有到相邻路由器的信息：</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/877953f4-af6f-424c-b4ce-e93378883861"></div><p>路由器 B 收到相邻路由器 A 和 C 的路由表：<br>修改 A 的路由表，将 RIP 报文中的所有项目下一跳的字段都改成 A ，距离增加 1。<br>| 目的网络 | 距离 | 下一跳 |<br>| :——: | :–: | :—-: |<br>| 1 | 2 | A |<br>| 2 | 3 | A |<br>| 3 | 3 | A |<br>修改 C 的路由表，将 RIP 报文中的所有项目下一跳的字段都改成 C ，距离增加 1。<br>| 目的网络 | 距离 | 下一跳 |<br>| :——: | :–: | :—-: |<br>| 4 | 2 | C |<br>| 6 | 2 | C |<br>将 B 原来不可达的项目加入到B的路由表中，加入后B的路由表：<br>| 目的网络 | 距离 | 下一跳 |<br>| :——: | :–: | :—-: |<br>| 3 | 1 | - |<br>| 4 | 1 | - |<br>| 1 | 2 | A |<br>| 2 | 2 | A |<br>| 6 | 2 | C |<br>修改 收到的目的网络原本在B路由器中且下一跳的字段和原B路由表项目中的字段一致 的项目，发现不用修改。<br>修改 B 可达，A和C也可达的项目，发现收到项目中的距离小于路由表中的距离，则进行更新，否则不更新。则修改后B的路由表是：<br>| 目的网络 | 距离 | 下一跳 |<br>| :——: | :–: | :—-: |<br>| 3 | 1 | - |<br>| 4 | 1 | - |<br>| 1 | 2 | A |<br>| 2 | 2 | A |<br>| 6 | 2 | C |</p><p><br></p><h3 id="RIP-协议的优缺点"><a href="#RIP-协议的优缺点" class="headerlink" title="RIP 协议的优缺点"></a>RIP 协议的优缺点</h3><ul><li>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。即好消息传播得快，而坏消息传播得慢。</li><li>RIP 协议最大的优点就是实现简单，开销较小。</li><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li></ul><p><strong>好消息传播得快，坏消息传播得慢</strong></p><p>在正常情况下，R1中项目表示到网1距离为1，R2中项目表示到网1距离为2。R2收到 R1 的项目后修改R2的项目为：1 2 R1，R2发现到网1的下一跳为R1，和原路由表一致，修改原路由表该项目为：1 2 R1。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/05b3939d-9535-4f8b-a62e-fa0a9bdb227b"></div><p>R1 说：“我到网 1 的距离是 16 （表示无法到达），是直接交付”。但 R2 在收到 R1 的更新报文之前，还发送原来的报文，因为这时 R2 并不知道 R1 出了故障。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6907f7d7-c64d-4cae-a506-1eafebd225a6"></div><p>我们列出一个网1出现故障后的交换表：<br>| | R1 | R2 |<br>| :—: | :—–: | :—–: |<br>| 正常 | 1 1 - | 1 2 R1 |<br>| 故障 | 1 16 - | 1 2 R1 |<br>| 第1次 | 1 3 R2 | 1 16 R1 |<br>| 第2次 | 1 16 R2 | 1 4 R1 |<br>| 第3次 | 1 5 R2 | 1 16 R1 |<br>| … | … | … |<br>这样不断更新下去，直到 R1 和 R2 到网 1 的距离都增大到 16 时，R1 和 R2 才知道网1是不可达的。</p><p><br></p><h3 id="RIP协议的位置"><a href="#RIP协议的位置" class="headerlink" title="RIP协议的位置"></a>RIP协议的位置</h3><ul><li>RIP 协议使用运输层的用户数据报 UDP进行传送（使用 UDP 的端口 520）。</li><li>因此 RIP 协议的位置应当在应用层。但转发 IP 数据报的过程是在网络层完成的。<br>这时有一个困惑，RIP是网络层协议，可是为什么用UDP封装？因为路由器虽然是网络层设备，但并不代表他只具备物理层、链路层、网络层功能，他还具备一些应用层的功能，当遇到RIP报文这类应用层的协议，他也能够解封。然后读取RIP报文中的下一跳路由。</li></ul><p><br></p><h3 id="RIP2-协议的报文格式"><a href="#RIP2-协议的报文格式" class="headerlink" title="RIP2 协议的报文格式"></a>RIP2 协议的报文格式</h3><p>RIP2由RIP而来，属于RIP协议的补充协议，提升装载的信息量，增加安全性。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/b3e522eb-a295-43fa-a8ad-db7c9a5a40d2"></div><p><br></p><h2 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h2><p>开放最短路径优先协议OSPF （Open Shortest Path First）。</p><p><br></p><h3 id="RIP-协议的问题"><a href="#RIP-协议的问题" class="headerlink" title="RIP 协议的问题"></a>RIP 协议的问题</h3><ul><li>以跳数评估的路由并非最优路径</li><li>最大跳数16导致网络尺度小</li><li>收敛速度慢</li><li>更新发送全部路由表浪费网络资源</li></ul><p><br></p><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li>向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。<ul><li>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”（metric）。</li></ul></li><li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</li></ul><p><br></p><h3 id="链路状态数据库"><a href="#链路状态数据库" class="headerlink" title="链路状态数据库"></a>链路状态数据库</h3><p>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得快是其重要优点。</p><p><br></p><h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/f82cf955-ba06-4232-9e93-ed9fa5c8aa0b"></div><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">1</th><th style="text-align:center">2</th><th style="text-align:center">3</th><th style="text-align:center">4</th><th style="text-align:center">5</th><th style="text-align:center">6</th></tr></thead><tbody><tr><td style="text-align:center">初始化1</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">6</td><td style="text-align:center"><strong>1</strong></td><td style="text-align:center">+无穷</td><td style="text-align:center">+无穷</td></tr><tr><td style="text-align:center">第1步</td><td style="text-align:center">0</td><td style="text-align:center">2</td><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center"><strong>2</strong></td><td style="text-align:center">+无穷</td></tr><tr><td style="text-align:center">第2步</td><td style="text-align:center">0</td><td style="text-align:center"><strong>2</strong></td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">4</td></tr><tr><td style="text-align:center">第3步</td><td style="text-align:center">0</td><td style="text-align:center"><strong>2</strong></td><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">6</td></tr></tbody></table><p>路径：1 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 3 -&gt; 6</p><p><br></p><h3 id="OSPF-的区域-area"><a href="#OSPF-的区域-area" class="headerlink" title="OSPF 的区域(area)"></a>OSPF 的区域(area)</h3><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。每一个区域都有一个 32 bit 的区域标识符（用点分十进制表示）。区域也不能太大，在一个区域内的路由器最好不超过 200 个。 同时 OSPF 划分为两种不同的区域：</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/e8c18218-ed29-4398-8bdd-0ca802b40a8c"></div><p>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。OSPF 使用层次结构的区域划分。在上层的区域叫作主干区域(backbone area)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。 图中的R3、R4、R6、R7是主干路由器。</p><p><br></p><h3 id="OSPF-载体"><a href="#OSPF-载体" class="headerlink" title="OSPF 载体"></a>OSPF 载体</h3><ul><li>OSPF 不用 UDP 而是直接用 IP 数据报传送。</li><li>OSPF 构成的数据报很短。这样做可减少路由信息的通信量。</li><li>数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</li></ul><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/3efadacc-da1f-41a2-8b64-81c10d07c755"></div><p><br></p><h3 id="OSPF-的五种分组类型"><a href="#OSPF-的五种分组类型" class="headerlink" title="OSPF 的五种分组类型"></a>OSPF 的五种分组类型</h3><ul><li>类型1，问候（Hello）分组。</li><li>类型2，数据库描述（Database Description）分组。</li><li>类型3，链路状态请求（Link State Request）分组。</li><li>类型4，链路状态更新（Link State Update）分组，用洪泛法对全网更新链路状态。</li><li>类型5，链路状态确认（Link State Acknowledgment）分组。</li></ul><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/91d30389-500d-4b4c-8ae0-f7e60f34f956"></div><p><br></p><h2 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h2><p>BGP 是不同自治系统的路由器之间交换路由信息的协议。 BGP 较新版本是 2006 年 1 月发表的 BGP-4，可以将 BGP-4 简写为 BGP。</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/a0012ab0-82aa-4243-8b0c-7a9ad66a00f6"></div><p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP 发言人” 。一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。<br>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话（session），利用 BGP 会话交换路由信息。使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站或对等站。</p><p><br></p><h3 id="BGP报文"><a href="#BGP报文" class="headerlink" title="BGP报文"></a>BGP报文</h3><ul><li>打开（Open）报文，用来与相邻的另一个BGP发言人建立关系。</li><li>更新（Update）报文，用来发送某一路由的信息，以及列出要撤消的多条路由。</li><li>保活（Keepalive）报文，用来确认打开报文和周期性地证实邻站关系。</li><li>通知（Notificaton）报文，用来发送检测到的差错。</li></ul><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/e82597b8-4c61-4f6e-840c-efa802aacd75"></div><p><br></p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><ul><li>IP协议<ul><li>只有一种报文格式：IP报文</li><li>功能：传递上层数据</li><li>缺乏：应付可能出现差错的能力</li></ul></li><li>网际控制报文协议 ICMP (Internet Control Message Protocol)<ul><li>IP的辅助协议</li><li>为IP提供差错报告机制</li><li>同时为其它层（TCP/UDP、应用）提供辅助功能<br>ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</li></ul></li></ul><p><br></p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><div align="center"><img src="http://blogfileqiniu.isjinhao.site/43d8be87-449f-4b2e-8c98-8e4c7ac25b92" width="80%"></div><p><br></p><h3 id="差错报告报文"><a href="#差错报告报文" class="headerlink" title="差错报告报文"></a>差错报告报文</h3><ul><li>终点不可达</li><li>源点抑制(Source quench)</li><li>时间超过</li><li>参数问题</li><li>改变路由（重定向）(Redirect)</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/d8ee4745-03c7-48f6-af25-c2c1c53f51e4" width="80%"></div><p><br></p><h3 id="询问报文"><a href="#询问报文" class="headerlink" title="询问报文"></a>询问报文</h3><ul><li>回送请求和回答报文</li><li>时间戳请求和回答报文</li></ul><p><br></p><h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h3><p>Ping发送一个ICMP 报文；回声请求消息给目的地并报告是否收到所希望的ICMPecho （ICMP回声应答）。它是用来检查网络是否通畅或者网络连接速度的命令。</p><blockquote><p>此上是<strong>网络层-网络构建</strong>部分<br>此下是<strong>网络层-网络通信</strong>部分</p></blockquote><p><br></p><h2 id="网络通信分类"><a href="#网络通信分类" class="headerlink" title="网络通信分类"></a>网络通信分类</h2><p>不同主机间的数据通信可以分为三种：两个主机属于同一个网、两个主机属于相邻的两个网中、两个主机属于不相邻的两个网络中。其中第一类是链路层所解决的问题，而后两类都是网络需要解决的问题，图示如下。为了叙述方便，博主将第二类情况简称“两个网”，第三类情况简称“三个网”，但实际上“三个网”的理论可以推广到“n个网”中。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/df9159ab-39c1-4e1e-b875-f79439ce098b"></div><p><br></p><h2 id="传统的IP地址划分"><a href="#传统的IP地址划分" class="headerlink" title="传统的IP地址划分"></a>传统的IP地址划分</h2><p>传统的IP地址划分规则中，地址由两个部分组成：网络号 + 主机号。具有相同网络号的IP地址属于同一个网络。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/b7f583ca-bd60-416e-ba0c-e15933180e04"></div><p>同时网络被划分为5类：</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/17a560db-9ff3-4055-a487-e836f9d51394"></div><p>但是并不是所有的主机号都能被用来标识主机，主机号全为0的IP地址被称为网络地址，标识一个网络。主机号全为1的地址被称为广播地址，用于向某个网络的所有主机广播。例：主机 212.111.44.136 所在网络的广播地址为212.111.44.255。而对于任意一个主机若想向其所在的网络中广播都可以使用255.255.255.255。按照这个划分我们可以得到各类地址的特性：</p><p><strong>A类地址</strong></p><ul><li>前1字节标识网络地址，后3字节标识主机地址</li><li>每个网络最多可容纳（$2^{24} －2$）台主机</li><li>从高位起，前1位为“0”，第1字节用十进制表示的取值范围为“0～127”</li><li>具有A类地址特征的网络总数为126个</li></ul><p><strong>B类地址</strong></p><ul><li>前2字节标识网络地址，后2字节标识主机地址</li><li>每个网络最多可容纳（$2^{16} －2$）台主机</li><li>从高位起，前2位为“10”，第1字节用十进制表示的取值范围为“128～191”</li><li>具有B类地址特征的网络总数为 $2^{14} －1$ 个</li></ul><p><strong>C类地址</strong></p><ul><li>前3字节标识网络地址，后1字节标识主机地址</li><li>每个网络最多可容纳254台主机</li><li>从高位起，前3位为“110”，第1字节用十进制表示的取值范围为“192～223”</li><li>具有C类地址特征的网络总数为 $2^{21} －1$个</li></ul><p><strong>D类地址</strong></p><ul><li>多播通信地址（multicast address）</li><li>从高位起，前4位为“1110”，第1字节用十进制表示的取值范围为“224－239”，用于标识multicast通信地址</li><li>后28位用于区分不同的multicast组</li></ul><p><strong>E类地址</strong></p><ul><li>从高位起，前4位为“1111”，第1字节用十进制表示的取值范围为“240－255”，用于标识E类地址</li><li>后28位留作它用</li></ul><p><br></p><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>早期的 IP 地址的设计确实不够合理。会存在如下问题：</p><ul><li>IP 地址空间的利用率有时很低。</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li><li>两级的 IP 地址不够灵活。</li><li>网络很快就被分配完了。<br>所以从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址。但划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。其实现思路就是从主机号借用若干个比特作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个比特。</li></ul><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/30996293-909a-4077-bc46-c4b25db49e4d"></div><p><br></p><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><p>划分子网后仍然没有解决IP V4的问题，1992年互联网的三大危机：</p><ul><li>B类地址耗尽</li><li>路由表爆炸</li><li>IP地址整体耗尽<br>无分类域间路由选择，Classless Inter-Domain Routing，是为解决上述危机而开发的一种方案。<br>在CIDR技术中，IP 地址由两部分组成，网络前缀 + 主机号。CIDR 还使用“斜线记法”(slash notation)，它又称为CIDR记法，即在IP地址后面加上一个斜线“/”，然后写上网络前缀所占的比特数（这个数值对应于三级编址中子网掩码中比特 1 的个数）。CIDR 将网络前缀都相同的连续的 IP 地址组成“CIDR地址块”。</li><li>128.14.32.0/20 表示的地址块共有 212 个地址（因为斜线后面的 20 是网络前缀的比特数，所以主机号的比特数是 12）。</li><li>这个地址块的起始地址是 128.14.32.0。</li><li>在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”。</li><li>128.14.32.0/20 地址块的最小地址：128.14.32.0。128.14.32.0/20 地址块的最大地址：128.14.47.255</li><li>全 0 和全 1 的主机号地址一般不使用。</li></ul><p><br></p><h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3><p>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由，减少了路由器之间的路由信息交换。路由聚合也称为构成超网。（super netting）。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/62ef63c5-d9c2-4c42-8ead-5b8ff4c891bb"></div><p>这个 ISP 共有 6 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每一个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，只需用路由聚合后的 1 个项目 206.0.64.0/18 就能找到该 ISP。 需要注意的是若是因特网中某路由器想标识该ISP，只需要记录206.0.64.0/18，但是对于ISP内的路由器还是会将各子地址块的网络地址记录。</p><p><br></p><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><ul><li>使用 CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果。</li><li>应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配（longest-prefix matching）。</li><li>网络前缀越长，其地址块就越小，因而路由就越具体。</li><li>最长前缀匹配又称为最长匹配或最佳匹配。</li></ul><p><br></p><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>如果把计算机网络与快递网络做类比，假设东北大学是一个网络，西南大学是一个网络，东北大学想向西南大学寄点东西那么它需要通过自己学校的驿站寄到西南大学的驿站。网络之间进行通信的时候也需要有一个这种“驿站”。这便是网关。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/6f3f0b89-45f9-433c-9d93-fedd1ef553f6"></div><p>默认网关就是为主机转发分组的路由器网络接口，就是主机的第一跳路由器，网关就是你邮信时需要找到的校园邮筒的地址，即默认网关是在网关中选一个。主机 H1 的默认网关是路由器的 E0 接口。“两个网”时，需要正确配置网关。网关是主机的第一跳路由器。举例：假设主机 H2 的 E0 接口 IP 地址 100.16.0.1，掩码 255.255.0.0，E1 接口 IP 地址 100.17.0.1，掩码 255.255.0.0：主机 H1 本地连接 IP 地址 100.16.0.2，掩码 255.255.0.0，默认网关 100.16.0.1。主机 H3 的默认网关是什么呢？100.16.0.1。主机 H5 的默认网关又是什么？是100.17.0.1。<br>在“多个网”时，多个网络如何互联？我们看下面的网络拓扑图，这是 3 个路由器连接了 4 个网络。</p><div align="center"><img src="http://blogfileqiniu.isjinhao.site/9925731e-bd05-4bc0-aa7c-f361df4228fe"></div><p>假设网 1 内部有一个主机 H1，网 1 内部只有一个路由器 R1，因此默认网关只能设为 R1 的 15.0.0.4，再配置好 IP 地址，就可以与外网通信了。假设网 2 内部有一个主机 H3，在网 2 内有两个路由器 R1 和 R2，可以任选一个做默认网关，假设选 R2，默认网关设为 20.0.0.9，再配置好 IP 地址，就可以与外网通信了。<br>再讨论如何配置路由器。路由器不傻，只要配置好路由器接口的 IP 地址，路由器会从接口的 IP 地址计算出网络地址，也就是说路由器能看清自己身边的网络。至于路由器是怎么看到的，在网络层-网络构建中会解释。</p><p><br></p><h2 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h2><p>之前说了这么多都是在做铺垫，本篇博文主要想介绍的一点是路由器是如何转发不同网络中的数据包。算法如下：</p><ol><li>从收到的分组的首部提取目的 IP 地址 D。</li><li>先用各网络的子网掩码和 D 逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行3。</li><li>若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行4。</li><li>对路由表中的每一行的子网掩码和 D 逐位相“与”，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行5。</li><li>若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行6。</li><li>报告转发分组出错。</li></ol><div align="center"><img src="http://blogfileqiniu.isjinhao.site/0f1eb042-f036-497c-9343-78e15368c0d4"></div><p>R1的路由表：<br>| 目的网络地址 | 子网掩码 | 下一跳 |<br>| :———–: | :————-: | :—-: |<br>| 128.30.33.0 | 255.255.255.128 | 接口0 |<br>| 128.30.33.128 | 255.255.255.128 | 接口1 |<br>| 128.30.36.0 | 255.255.255.0 | R2 |<br>R2的路由表：<br>| 目的网络地址 | 子网掩码 | 下一跳 |<br>| :———–: | :————-: | :—-: |<br>| 128.30.33.0 | 255.255.255.128 | R1 |<br>| 128.30.33.128 | 255.255.255.128 | 接口0 |<br>| 128.30.36.0 | 255.255.255.0 | 接口1 |<br>在上图中，若H1（128.30.33.13）想给H3（128.30.36.12）发送数据，我们来分析一下具体的过程：</p><ol><li>主机 H1 首先将本子网的子网掩码 255.255.255.128与分组的 IP 地址 128.30.36.12 逐位相“与”（AND 操作）。即255.255.255.128 AND 128.30.36.12 得到 128.30.36.0，发现不等于128.30.33.0，所以他要将数据报发送到它的默认网关（128.30.33.1）上。</li><li>R1收到这个地址后，会遍历所有的子网掩码，进行按位与后再和对应的网络地址做比对。可以得到转发给R2计算过程如下：<ol><li>255.255.255.128 AND 128.30.36.12 = 128.30.36.0 不等于 128.30.33.0</li><li>255.255.255.128 AND 128.30.36.12 = 128.30.36.0 不等于 128.30.33.128、</li><li>255.255.255.0 AND 128.30.36.12 等于 128.30.36.0</li></ol></li><li>R1收到这个地址后，会遍历所有的子网掩码，进行按位与后再和对应的网络地址做比对。可以得到转发给接口1。</li><li>然后便是链路层需要解决的问题。</li></ol><p><br></p><h3 id="ARP深入"><a href="#ARP深入" class="headerlink" title="ARP深入"></a>ARP深入</h3><p>只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。可以分为四种情况：</p><ul><li>发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li><li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li></ul><p><br></p><h2 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h2><div align="center"><img src="http://blogfileqiniu.isjinhao.site/cc935459-2325-48cf-bfbe-5c1bdfdd9182"></div><div align="center"><img src="http://blogfileqiniu.isjinhao.site/31da1294-a3ee-48a0-b39d-b4a471b95a67"></div><ul><li>版本：占 4 位，指 IP 协议的版本目前的 IP 协议版本号为 4 （即 IPv4）。</li><li>首部长度：占 4 位，可表示的最大数值是 15 个单位（一个单位为 4 字节）因此 IP 的首部长度的最大值是 60 字节。</li><li>区分服务：占 8 位，用来获得更好的服务在旧标准中叫做服务类型，但实际上一直未被使用过。1998 年这个字段改名为区分服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段。</li><li>总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。</li><li>标识（identification）：占 16 位，它是一个计数器，用来产生数据报的标识。</li><li>标志（flag）：占 3 位，目前只有前两位有意义。标志字段的最低位是 MF（More Fragment）。MF = 1 表示后面“还有分片”。MF = 0 表示最后一个分片。标志字段中间的一位是 DF（Don’t Fragment）。只有当 DF=0 时才允许分片。</li><li>片偏移(13 位)指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/8117370c-6825-4dbe-b615-d0325a27c3c8"></div><ul><li>生存时间（8 位）记为 TTL（Time To Live）：数据报在网络中可通过的路由器数的最大值。</li><li>协议（8 位）：指出此数据报携带的数据使用何种协议，即运输层协议。</li><li>首部检验和（16 位）字段只检验数据报的首部不检验数据部分。</li><li>源地址和目的地址都各占 4 字节。</li></ul><p><br></p><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><p>在现在的网络中，IP地址分为公网IP地址和私有IP地址。公网IP是在Internet使用的IP地址，而私有IP地址则是在局域网中使用的IP地址。私有IP地址是一段保留的IP地址。只使用在局域网中，无法在Internet上使用。</p><ul><li>A类私有地址：10.0.0.0～10.255.255.255</li><li>B类私有地址：172.16.0.0～172.31.255.255</li><li>C类私有地址：192.168.0.0～192.168.255.255<br>这些地址可以在任何组织或企业内部使用，和其他Internet地址的区别就是，仅能在内部使用，不能作为全球路由地址。这就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到Internet，就可以使用这些地址而不用向 IANA（The Internet Assigned Numbers Authority，互联网数字分配机构，是负责协调一些使Internet正常运作的机构） 提出申请，而在内部的路由管理和报文传递方式与其他网络没有差异。<br>对于有Internet访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署NAT网关，在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有IP地址了。</li></ul><div align="center"><img src="http://blogfileqiniu.isjinhao.site/f617babc-a4f1-49ad-9681-1427664ee7f7"></div><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;blockquote&gt;&lt;p&gt;网络层分为两分布，网络构建和网络通信&lt;/p&gt;&lt;/blockquote&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;自治系统&quot;&gt;
      
    
    </summary>
    
      <category term="网络" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://isjinhao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>04.05-网络-网络安全</title>
    <link href="https://isjinhao.github.io/posts/46574.html/"/>
    <id>https://isjinhao.github.io/posts/46574.html/</id>
    <published>2019-12-20T09:22:11.000Z</published>
    <updated>2019-12-30T13:20:35.768Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="网络安全威胁"><a href="#网络安全威胁" class="headerlink" title="网络安全威胁"></a>网络安全威胁</h2><h3 id="拟人模型"><a href="#拟人模型" class="headerlink" title="拟人模型"></a>拟人模型</h3><p>在网络通信中，数据肯定有发送方和接收方，在全双工通信的时候双方既为发送者也为接受者，这便是图上的Alice和Bob，而Trudy可以指破坏通信的软件，也可以指破坏通信的主机。如：</p><ul><li>病毒（virus）</li><li>蠕虫（worm）</li><li>间谍软件（spyware）：记录键盘输入、web站点访问、向收集站点上传信息等</li></ul><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/7641f209-e0a7-4f79-a196-abb236cce4f5"></div><p><br></p><h3 id="Trudy可以做什么"><a href="#Trudy可以做什么" class="headerlink" title="Trudy可以做什么"></a>Trudy可以做什么</h3><p><strong>映射（Mapping）</strong></p><p>在任何网络攻击发起之前都会有一个映射，这是发起攻击前的“探路”（case the joint），即找出网络上在运行什么服务：</p><ul><li>利用ping命令确定网络上主机的地址</li><li>端口扫描（Port-scanning）：获得主机地址后依次尝试与每个端口建立TCP连接<br>对策（Countermeasures）</li><li>记录到达的网络流量</li><li>分析、识别出可疑活动（IP地址和端口被依次扫描）</li></ul><p><strong>分组“嗅探”（sniffing）</strong></p><ul><li>广播介质（共享式以太网，无线网络）</li><li>混杂（promiscuous）模式网络接口可以接收/记录所有经过的分组/帧</li><li>可以读到所有未加密数据（例如账户密码）</li><li>不一定所有的嗅探都是有害的，Wireshark就是一个典型免费的分组嗅探软件</li></ul><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/f8af59de-5097-49fc-a1fd-a2010d4e562d"></div><p>对策</p><ul><li>组织中的所有主机都运行软件，周期性监测网络接口是否工作在混杂模式</li><li>每段广播介质连接一台主机（如交换式以太网）</li></ul><p><strong>IP欺骗（Spoofing）：</strong></p><ul><li>直接由应用生成“原始”IP分组，可以设置分组的源IP地址字段为任意值</li><li>接收方无法判断源地址是否被欺骗</li><li>e.g.: C冒充B</li></ul><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/258cf251-cf53-4dd1-ad40-2c93dea0edb3"></div><p>对策<br>入口过滤（ingress filtering），即路由器不转发源IP地址无效的IP分组（例如当源IP地址不属于所连接网络时）。这是很有效的对策！但是不能强制所有网络都执行入口过滤。</p><p><strong>拒绝服务DOS（Denial of service）</strong></p><p>向接收方恶意泛洪（flood）分组，淹没（swamp）接收方</p><ul><li>带宽耗尽</li><li>资源耗尽<br>分布式拒绝服务攻击（DDOS）：多个源主机协同淹没接收方，例如C与另一个远程主机协同对A进行SYN攻击。</li></ul><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/3bd06301-ef88-40e2-b19f-de748801d7cc"></div><p>SYN 攻击<br>利用TCP连接的三次握手过程，Trudy向服务器发送第一次握手，服务器给建立TCP连接分配资源，发送第二次握手，但是Trudy在发送第一次握手之后不再做任何响应，服务器接收不到三次握手信号，一直发送第二次握手信息。大量的类似TCP连接产生后，服务器会陷于拒绝服务的状态。<br>对策：在接收到第一次握手信号后不立即分配资源，而是将源IP、目的IP、源端口、目的端口、随机数构成的五元组哈希成服务器的序列号<code>y</code>，并且发送二次握手信号。此时服务器不进行超时重传等机制。如果再接收到ACK为<code>y+1</code>第三次握手信号才去分配资源。所以在接收到第一次握手后服务器可以保留一份<code>y</code>到五元组的映射，这样的话在接收到ACK为<code>y+1</code>第三次握手信号之后就可以查一下<code>y</code>是否在哈希表中，如果在便可以为为客户端分配资源。</p><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/3f4e50e1-4b61-4a96-9324-cac5a009326a"></div><p><br></p><h2 id="密码学名词"><a href="#密码学名词" class="headerlink" title="密码学名词"></a>密码学名词</h2><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/5bfae191-c089-46ce-9fc9-6292b77075ba"></div><p>在我们现今的密码学体系中，加密结果的影响因素有两个，加密算法和加密秘钥，而加密算法一般是公开的，因为创建一个加密算法是非常困难的事情。所以密文可以被表示为：$K_A(m)$，解密后的密文：$m=K_B(K_A(m))$。</p><p><br></p><h3 id="对称秘钥加密"><a href="#对称秘钥加密" class="headerlink" title="对称秘钥加密"></a><strong>对称秘钥加密</strong></h3><p>对称密码是我们最容易被理解的密码算法，其对应上图就是$K_B == K_A$，也就是说对于一次加密过程，我们进行一次逆过程就可以完成解密。</p><p><strong>DES</strong></p><p>Data Encryption Standard。IBM公司研制。DES的部分部分是保密的。</p><ul><li>1972年，美国国家标准局开始实施计算机数据保护标准的开发计划。</li><li>1973年5月13日，NBS征集在传输和存贮数据中保护计算机数据的密码算法。</li><li>1975年3月17日，首次公布DES算法描述。</li><li>1977年1月15日，正式批准为加密标准，当年7月1日正式生效。</li><li>1994年1月的评估后决定1998年12月以后不再将DES作为数据加密标准。</li></ul><p><strong>AES</strong></p><p>Advanced Encryption Standard，1997年美国国家标准技术研究所NIST宣布征集AES算法，要求：</p><ul><li>可公开加密方法</li><li>分组加密，分组长度为128位</li><li>至少像3DES一样安全</li><li>更加高效、快</li><li>可提供128/192/256位密钥</li><li>比利时学者Joan Daemen和Vincent Rijmen提出的Rijndael加密算法最终被选为AES算法。</li><li>NIST在2001年12月正式颁布了基于Rijndael算法AES标准</li></ul><p><br></p><h3 id="公钥密码学"><a href="#公钥密码学" class="headerlink" title="公钥密码学"></a><strong>公钥密码学</strong></h3><p>公钥密码也是非对称密码。公钥加密算法一般由五个部分组成：</p><ul><li>原文（Message）：需要加密的信息，可以是数字、文字、视频、音频等，用$M$表示。</li><li>密文（Ciphertext）：加密后得到的信息，用$C$表示。</li><li>公钥（Public Key）和私钥（Private Key），用$PU$和$PR$表示。</li><li>加密算法（Encryption）：若$E(x)$为加密算法，加密过程可以理解为$C=E(m)$，根据原文和加密算法得到密文。</li><li>解密算法（Decryption）：若$D(x)$为解密算法，解密过程可以理解为$M=D(c)$，根据密文和解密算法得到原文。<br>对于公钥密码学，我们不去探究他们的数学原理是什么，但是需要了解算法的特性和用途。我们先看算法的特性，在下面的其他部分再看算法的用处。<br>我们先不考虑公钥和私钥，将秘钥设为秘钥A和秘钥B，使用密钥A加密数据得到的密文，只有密钥B可以进行解密操作（即使密钥A也无法解密），对应的，使用了密钥B加密数据得到的密文，只有密钥A可以解密。此时我们把一个秘钥公开出去，一个秘钥自己掌握，便区分为公钥和私钥。而根据不同用途，对数据进行加密所使用的密钥也不相同，即有时用公钥加密，私钥解密；有时则相反，用私钥加密，公钥解密。</li></ul><p><br></p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><h3 id="消息完整性"><a href="#消息完整性" class="headerlink" title="消息完整性"></a><strong>消息完整性</strong></h3><p>报文/消息完整性（message integrity），也称为报文/消息认证（或报文鉴别），指在传输、存储信息或数据的过程中，确保信息或数据不被未授权的篡改或在篡改后能够被迅速发现。它有几个核心目标：</p><ul><li>证明报文确实来自声称的发送方</li><li>验证报文在传输过程中没有被篡改</li><li>预防报文的时间、顺序被篡改</li><li>预防报文持有期被修改</li><li>预防抵赖<ul><li>发送方否认</li><li>接收方否认</li></ul></li></ul><p><br></p><h3 id="密码散列函数"><a href="#密码散列函数" class="headerlink" title="密码散列函数"></a><strong>密码散列函数</strong></h3><p>密码散列函数（Cryptograph ic Hash Function）的特点：</p><ul><li>散列算法公开</li><li>H(m)能够快速计算</li><li>对任意长度报文进行映射，均产生定长输出</li><li>对于任意报文无法预知其散列值</li><li>不同报文不能产生相同的散列值</li><li>单向性：无法根据散列值倒推出报文，即对于给定散列值h，无法计算找到满足h = H(m)的报文m</li><li>抗弱碰撞性（Weak Collision Resistence-WCR），即对于给定报文x，计算上不可能找到y且y≠x，使得H(x)=H(y)。</li><li>抗强碰撞性（Strong Collision Resistence-SCR），在计算上，不可能找到任意两个不同报文x和y(x≠y)，使得<br>H(x)=H(y)。</li></ul><p><strong>散列函数算法</strong></p><p>MD5：被广泛应用的散列函数（RFC 1321）。对任意长度的报文输入，计算输出128位的散列值。但是MD5不是足够安全，1996年，Dobbertin找到了两个不同的512-bit块，在MD5计算下产生了相同的散列值<br>SHA-1：Secure Hash Algorithm，SHA-1要求输入消息长度$&lt;2^{64}$，SHA-1的散列值为160位。其速度慢于MD5，安全性优于MD5。</p><p><strong>报文摘要</strong></p><p>Message digests，对报文m应用散列函数H，得到一个固定长度的散列码，称为报文摘要（message digest），记为H(m)。可以作为报文m的数字指纹（fingerprint）。</p><div align="center"><img width="50%" src="http://blogfileqiniu.isjinhao.site/4b305c4c-d1de-41b5-9fee-d9d0ae3dfab6"></div><p><br></p><h3 id="报文认证"><a href="#报文认证" class="headerlink" title="报文认证"></a><strong>报文认证</strong></h3><p><strong>简单的报文认证</strong></p><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/a4e06403-1801-4b1b-ad71-7b4ae2a50203"></div><p>在不知道散列的情况下，简单的报文认证什么都不能保证，因为在简单的报文认证中修改了报文，只要顺便修改了报文摘要就无法检测报文的正确性。</p><p><strong>报文认证码MAC</strong></p><p>Message Authentication Code。在简单报文的基础上，加上认证密钥（对称秘钥）。</p><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/a0842382-efbc-42a8-a9a7-d3e230fee72c"></div><p>加上认证秘钥之后，只要能保证秘钥的安全性（后面会介绍如何保证对称秘钥的安全性）。但是此时仍然不能解决如下问题：</p><ul><li>否认<ul><li>发送方不承认自己发送过某一份报文</li><li>接收方不承认自己接收过某一份报文</li></ul></li><li>伪造：接收方自己伪造一份报文，并声称来自发送方</li><li>篡改：接收方对收到的信息进行篡改</li></ul><p><br></p><h3 id="数字签名-1"><a href="#数字签名-1" class="headerlink" title="数字签名"></a>数字签名</h3><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/426724a8-039d-4865-b37f-89ce24c7f18b"></div><p>使用数字签名后，假设Alice收到报文m以及签名，Alice利用Bob的公 解密 ，并检验来证实报文m是Bob签名的。如果成立，则签名m的一定是Bob的私钥，于是，Alice可以证实：</p><ul><li>Bob签名了m。</li><li>没有其他人签名m的可能。即这份报文只能是来自Bob。</li><li>Bob签名的是m而不是其他报文m。因为只有Bob知道他自己的私钥。<br>同时，Alice没有Bob的私钥，不可能伪造，篡改Bob发来的报文。<br>数字签名相比于MAC又能解决更多的问题，但是数字签名不能解决“接收方不承认自己接收过某一份报文”的问题，想要解决这个问题必须采用其他的协议。</li></ul><p><br></p><h2 id="秘钥分发"><a href="#秘钥分发" class="headerlink" title="秘钥分发"></a>秘钥分发</h2><h3 id="KDC"><a href="#KDC" class="headerlink" title="KDC"></a>KDC</h3><p>Key Distribution Center。对称秘钥的问题便是如何建立共享秘钥。即在Alice和Bob通信过程中，如何保证双方接收到的会话秘钥都是正确的且没有被Trudy接收到。而解决办法就是设立一个可信任的密钥分发中心作为中介。<br>密钥分发中心是一种运行在物理安全服务器上的服务，KDC维护着领域中所有安全主体账户信息数据库。与每一个安全主体的其他信息一起，KDC存储了仅安全主体和KDC知道的加密密钥，这个密钥也称长效密钥（主密钥），用于在安全主体和KDC之间进行交换。而用于Alice和Bob相互认证的会话密钥就是由KDC分发的。</p><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/42c86c06-43e6-4664-9d22-88dcdedd98c8"></div><p>KDC的工作方式如下：</p><ol><li>Alice使用自己和KDC共享的那一份秘钥加密自己和Bob的信息。表示自己想和Bob通信。</li><li>KDC使用Bob和KDC共享的那份秘钥加密Alice的信息和给本地通信颁发的会话秘钥R1。设为E。</li><li>KDC将E用Alice的秘钥加密，发送给Alice。</li><li>Alice用自己的秘钥解密后，可以获得E。</li><li>Alice将E发送给Bob，Bob用其有KDC共享的秘钥解密E后就可以知道自己需要和Alice使用R1通信。</li></ol><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/f78cb111-1f00-4397-b672-88e903ef0c8a"></div><p>使用KDC进行通信加密的时候有个破绽，就是Alice和Bob与KDC之间共享的那份秘钥</p><p><br></p><h3 id="CA"><a href="#CA" class="headerlink" title="CA"></a>CA</h3><p>Certification Authority。公钥通信的问题就是如何保证接收方接到的是发送方的公钥。即如何避免中间人攻击。</p><p><strong>中间人攻击</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/0cbec0df-c73f-4fe5-986c-9f5688d3469b"></div><ol><li>Bob给Alice发送自己公钥，这个消息被Trudy接收到了。此时Trudy有了Bob的公钥。</li><li>Trudy将自己的公钥发送给了Alice，此时Alice有的是Trudy的公钥。</li><li>Bob给Alice发送消息，消息被Trudy截获，Trudy有Bob的公钥能解密Bob的报文。</li><li>Trudy给Alice发送假消息，Alice用第二步获得的Bob的公钥解密，以为是Bob给自己发送的消息。</li></ol><p><strong>可信任的认证中心</strong></p><p>中间人攻击的解决方案就是寻找一个可信任的认证中心。实现特定实体E与其公钥的绑定</p><ul><li>每个E（如人、路由器等）在CA上注册其公钥。需要Bob的个人信息和Bob的公钥。</li><li>CA创建绑定E及其公钥的证书（certificate）</li><li>证书包含由CA签名的E的公钥 – CA声明：“这是E的公钥”</li></ul><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/617bc167-697e-4975-a0a8-4b4c280bb8c4"></div><p>可信赖的认证中心可以解决很多问题，但是还有一个缺陷，就是Bob怎么获得CA的公钥？如果Bob通过网络获取CA的公钥，那么仍然会被中间人攻击，所以在现在的浏览器、操作系统中已经内置了一些认证中心的公钥。这样的话，Bob发送给CA的信息就不可能被劫持。Alice也能使用内置的公钥解密CA签发的公钥证书。</p><p><br></p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><p><strong>数字证书</strong></p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/e95c0b5b-eb54-474e-95c4-e4051c7d961a"></div><p><strong>https基本原理</strong></p><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/141df582-50fe-4a61-95d8-801fc99828f2"></div><p><strong>回放攻击的抵御</strong></p><p>我们上面的https能够抵御中间人攻击，但是却无法抵御回放攻击。什么是回放攻击呢？<br>假如Alice想向Bob转10块钱。Alice发送一个报文个给支付宝，Alice和支付宝之间的通信使用https进行加密，此时Trudy通过嗅探的方式获得了这个数据包，虽然Trudy无法知道这个报文的内容是什么，但是如果Trudy将这个报文多次发送给支付宝，Alice就相当于转了好多次钱给Bob。那么该如何解决呢？<br>一次性随机数<br>Alice在向服务器发送转账报文之前，先向服务器申请一个一次性随机数，服务器在生成这个随机数<code>R</code>后一边将其存储在服务器上（设为表<code>X</code>），一边再将其发送给Alice。然后在发送转账报文的时候将<code>R+1</code>附在报文上，服务器收到报文后解密报文再减一得到便可以得到<code>R</code>，然后再查表<code>X</code>，此时服务器就知道<code>R</code>没有被使用过，在处理完此次请求后，服务器将<code>R</code>从表<code>X</code>中删除。如果Trudy伪造了一份报文发送给服务器，服务器在表中查不到<code>R</code>，便不会处理此次请求。<br>过期时间<br>一次性随机数可以抵御回访攻击，但是还有点缺陷，就是如果Alice在获得<code>R</code>后不发送转账报文，表<code>X</code>中的<code>R</code>永远不会被删除，就会造成内存泄漏。此时可以将表中的每个随机数设置一个过期时间，便可以很好的解决这个问题。</p><p><br></p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。<br>SSH使用的加密方式也是公钥加密技术，所以其和https面临相同的问题，就是中间人攻击。但是和https寻找CA认证不同，SSH采用用户自行确认的方式进行认证。<br>所以在第一次登录到对方主机的时候，系统会出现类似下面的提示：<br></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user@host</span><br><span class="line">The authenticity of host &apos;host (12.18.429.21)&apos; can&apos;t be established.</span><br><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure><p></p><p>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。<br>如果用户经过核对（或者不核对）之后确定是对方主机，就可以和对方主机建立连接。然后便是输入用户名密码的环节了。</p><p><br></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>哈尔滨工业大学mooc</li><li><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc0NzExNg==&amp;mid=2665513779&amp;idx=1&amp;sn=a1de58690ad4f95111e013254a026ca2&amp;chksm=80d67b70b7a1f26697fa1626b3e9830dbdf4857d7a9528d22662f2e43af149265c4fd1b60024&amp;mpshare=1&amp;scene=1&amp;srcid=1218TNdDIgHKi0iNGqcuUHIK&amp;sharer_sharetime=1576679757750&amp;sharer_shareid=4ee2705235be865f9b9d37ec8d0880da&amp;key=24f4c229624f48232229f8ff098300bbabbf27cc8205e886555c110b686feecc3ec87498d571e56403557416f09a3398afeb9fb53cbd747d5d6f67e079f7012ee64f504c893b7a5c616cc692fc42e431&amp;ascene=1&amp;uin=MTE0ODk0OTI2&amp;devicetype=Windows+10&amp;version=62070158&amp;lang=zh_CN&amp;exportkey=AS6xaCbzJExHlv9GvBG8bcc%3D&amp;pass_ticket=XKq1g7kn6ID3JUkISrEmy5kSZzr7rf2NdClQ0jY13cY%3D">码农翻身</a></li><li><a href="https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html">https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html</a></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;网络安全威胁&quot;&gt;&lt;a href=&quot;#网络安全威胁&quot; class=&quot;headerlink&quot; title=&quot;网络安全
      
    
    </summary>
    
      <category term="网络" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://isjinhao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>04.06-网络-面试题</title>
    <link href="https://isjinhao.github.io/posts/329.html/"/>
    <id>https://isjinhao.github.io/posts/329.html/</id>
    <published>2019-12-20T09:22:11.000Z</published>
    <updated>2019-12-30T13:20:35.773Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --><p><br></p><h2 id="TCP-对比-UDP"><a href="#TCP-对比-UDP" class="headerlink" title="TCP 对比 UDP"></a>TCP 对比 UDP</h2><p><strong>对比</strong></p><ul><li>TCP提供面向连接的、可靠的数据流传输，TCP传输单位称为TCP报文段。</li><li>UDP提供的是非面向连接的、不可靠的数据流传输。UDP传输单位称为用户数据报。</li></ul><p><strong>应用层协议</strong></p><blockquote><p>TCP对应的协议</p><ul><li>FTP：定义了文件传输协议，使用21端口。</li><li>SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。</li><li>POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。</li><li>HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。<br>UDP对应的协议</li><li>DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。</li></ul></blockquote><p><br></p><h2 id="TCP的可靠传输"><a href="#TCP的可靠传输" class="headerlink" title="TCP的可靠传输"></a>TCP的可靠传输</h2><p><strong>差错控制</strong></p><p>TCP保证差错控制使用的方式是：校验和 &amp; 确认与重传</p><blockquote><p>校验和<br>校验和的目的是为了保证接收端接收到的数据不会因为网络的不稳定导致数据出错。<br>确认与重传<br>确认和重传机制是为了保证报文段在传输的时候没有发生丢失。</p></blockquote><p><strong>流量控制</strong></p><p>流量控制的目的是为了保证传输两端之间速率的匹配。即不能由于发送方发送的速度太快而导致接收在接收到数据后来不及处理而被迫丢弃进而引起发送方重传。<br>使用GBN协议或者选择重传协议来控制。即使用<code>发送-确认</code>的机制来协调点到点之间传输的速率。</p><blockquote><p>接收方窗口<br>在流量控制阶段接收方会分配一段内存空间做为接收缓冲区。通常情况，接收方的缓存中包含已接收且确认的数据字节，它们在正等待应用进程将它们拉走，称为未交付数据。接收缓冲区剩余的空间，即可用来接收新数据的空间，称为接收窗口（通常记为rwnd）。若应用进程迟迟不讲缓存区中的数据取走，随着不断接收新数据，接收窗口（可用的接收缓存）会越来越小，直到为零。而对于任何时刻：<code>rwnd(接收窗口)=缓冲区大小-未交付数据字节数</code>。</p></blockquote><p><strong>拥塞控制</strong></p><p>拥塞控制作用于网络，它防止过多的数据注入到网络中，避免出现网络负载过大的情况。</p><blockquote><p>阻塞的检测</p><ul><li>全阻塞：超时表示网络全阻塞。</li><li>半阻塞：三次重复ACK表示网络半阻塞。<br>拥塞控制策略</li></ul><ol><li>慢开始，指数增大</li><li>到达慢开始门限值（ssthresh）的时候进行加法增大（起始的慢开始门限值是人为设置的）</li><li>当发生全阻塞时<ol><li>ssthresh门限值设为此刻cwnd的一半，ssthresh=cwnd/2</li><li>将拥塞窗口重新设置设为1。cwnd =1</li><li>进入慢启动阶段。</li></ol></li><li>当发生半阻塞时<ol><li>ssthresh门限值设为此刻cwnd的一半，ssthresh=cwnd/2</li><li>将拥塞窗口设为门限值。 cwnd=ssthresh</li><li>进入拥塞避免阶段。</li></ol></li></ol></blockquote><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/74e6326a-2cfb-4c0e-bded-d9cba2da99d1"></div><p><br></p><h2 id="TCP的三次握手和四次挥手"><a href="#TCP的三次握手和四次挥手" class="headerlink" title="TCP的三次握手和四次挥手"></a>TCP的三次握手和四次挥手</h2><p><strong>三次握手</strong></p><ul><li>客户端向服务器发送建立连接请求，并且携带一个客户端起始序列号。</li><li>服务器向客户端确认已收到客户端的序列号，并且将服务器起始序列号发送给客户端。</li><li>客户端收到服务器的序列号之后，客户端向服务器确认已收到服务器序列号。</li></ul><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/c5150931-5dea-4eba-9e6a-6ba4ec5ed059"></div><ul><li>客户端状态：<ul><li>SYN_SENT：客户端发送请求给服务器后的状态</li><li>ESTABLISHED：客户端进入连接建立状态</li></ul></li><li>服务器状态：<ul><li>SYN_RECV：服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态</li><li>ESTABLISHED：服务器进入连接建立状态</li></ul></li></ul><p><strong>二次握手的缺陷</strong></p><blockquote><p>二次挥手不能防止已失效的连接请求又传送到服务器端。</p><ul><li>客户端发送第一个请求给服务器（第一次<code>第一次握手</code>），如果这个请求在网络上迷失，客户端在超时之后会再发一次请求给服务器（第二次<code>第一次握手</code>）</li><li>服务器收到第一次握手的这个连接之后会发送ACK给客户端（<code>第二次握手</code>）。</li><li>在二次握手的情况下，客户端不发送ACK，此时可以进行通信。</li><li>此时若我们第一次发送的<code>第一次握手</code>信号达到了服务器，那么服务器以为是新的连接，就会发确认报文到客户端确认并建立连接，但发送端可能已经关闭，接收端可能就这样等待，这在网络中就浪费了资源。</li><li>但是有了<code>第三次握手</code>不一样了，服务器在接收到了滞留在网络中的信息后，会发送确认信息给客户端，但是当客户端没有理会的时候，服务器在超时之后就会自动关闭这次连接。</li></ul></blockquote><p><strong>四次挥手</strong></p><p>连接断开时可以先由服务器发起，也可以先由客户端发起。下面假设是客户端发起的连接断开。</p><ul><li>客户端向服务器发送一个FIN报文段；此时，服务器进入FIN_WAIT_1状态。这表示客户端没有数据要发送给服务器了。</li><li>服务器收到了客户端发送的FIN报文段，向客户端回一个ACK报文段，服务器进入CLOSE_WAIT状态。表示服务器知道客户端没有数据要传送过来了，服务器自己进入<code>等待关闭</code>状态，表示发完手上的数据就进行关闭。</li><li>服务器发完手上的数据后向客户端发送FIN报文段来请求关闭连接。这表示客户端服务器已经没有数据要传给客户端了。</li><li>客户端收到服务器发送的FIN报文段，向服务器发送ACK报文段。服务器收到客户端的ACK报文段以后，就关闭连接。此时服务器关闭连接完成。如果客户端等待2MSL后依然没有收到回复，客户端的定时器关闭，表示客户端关闭连接完成。</li></ul><div align="center"><img width="60%" src="http://blogfileqiniu.isjinhao.site/7b9939d2-b1fc-4cc9-aa44-c2e486888200"></div><ul><li>客户端状态：<ul><li>FIN_WAIT_1：客户端发送FIN报文段后的状态</li><li>FIN_WAIT_2：客户端接收到服务器的ACK报文段之后的状态</li><li>TIME_WAIT：客户端接收到服务器发送的最后一个ACK之后，进入一个2MSL的等待期。</li></ul></li><li>服务器状态：<ul><li>CLOSE_WAIT：服务器接收到客户端请求关闭的报文之后进入关闭等待期</li><li>LAST_ACK：服务器发送完关闭连接报文段后（FIN）等待接收客户端的确认的状态。</li></ul></li></ul><p><strong>为什么四次挥手后需要等待一段时间</strong></p><ol><li><strong>为了保证客户端发送的最后一个ACK报文能够到达服务器。</strong>这个ACK的报文有可能丢失，这样处于LAST-ACK状态的服务器如果收不到客户端的ACK报文，会再次发送<code>第三次挥手</code>信号，而客户端在2MSL的时间内收到这个重传的信号。接着客户端重传一次确认，重新启动2MSL计时器。如果客户端不在TIME-WAIT状态下等待一段时间，而是在发送完ACK报文后立即释放连接，那么就无法收到重传的<code>第三次挥手</code>报文，因而也不会再一次的发送确认报文，那么服务器就会永远进行重传。</li><li><strong>避免新旧连接混淆。</strong>等待2MSL可以让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接请求不会出现旧的连接请求报文。我们假设TCP连接是<code>A(1.2.3.4:8888)-B(6.7.8.9:9999)</code>，这就是一个TCP四元组。当TCP连接关闭后，四元组释放。后面的新连接可能会重用到这个四元组，那么问题就来了：新四元组和旧四元组完全一致，他们的网络包会产生混乱。所以等待一段时间可以让旧四元组对应的所有网络包都消失，避免新旧连接混淆。</li></ol><p><br></p><h2 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h2><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/db782db0-9889-4ba0-a9a3-92684553f7b5"></div><p><strong>各层的功能</strong></p><blockquote><p>应用层（application layer）<br>是体系结构中的最高。直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。<br>协议：HTTP协议、SMTP协议、FTP协议、DNS、POP3、SNMP、Telnet<br>运输层（transport layer）<br>负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能</p><ul><li>复用，就是多个应用层进程可同时使用下面运输层的服务。</li><li>分用，就是把收到的信息分别交付给上面应用层中相应的进程。<br>协议：UDP协议、TCP协议<br>网络层(network layer）<br>网络层(network layer)主要包括以下两个任务：</li><li>负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。</li><li>选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。<br>协议：IP、ICMP、IGMP、ARP、RARP<br>数据链路层（data link layer）<br>将网络层交下来的IP数据报组装成帧（framing），在两个相邻结点之间的链路上“透明”地传送帧中的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。<br>协议：GBN协议、选择重传协议<br>物理层（physical layer）<br>物理层的任务就是透明地传送比特流。</li></ul></blockquote><p><br></p><h2 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h2><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      
      
        &lt;!-- build time:Mon Dec 30 2019 21:21:01 GMT+0800 (GMT+08:00) --&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;&lt;h2 id=&quot;TCP-对比-UDP&quot;&gt;&lt;a href=&quot;#TCP-对比-UDP&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="网络" scheme="https://isjinhao.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="网络" scheme="https://isjinhao.github.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="课内学习" scheme="https://isjinhao.github.io/tags/%E8%AF%BE%E5%86%85%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
