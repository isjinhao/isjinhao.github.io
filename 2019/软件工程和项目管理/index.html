<!-- build time:Sun Sep 22 2019 14:44:30 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>.pace .pace-progress{background:#1E92FB;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1E92FB,0 0 5px #1E92FB}.pace .pace-activity{border-top-color:#1E92FB;border-left-color:#1E92FB}</style><meta name="theme-color" content="#222"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=6.7.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon16x16.ico?v=6.7.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32x32.ico?v=6.7.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16x16.ico?v=6.7.0"><link rel="mask-icon" href="/images/favicon16x16.ico?v=6.7.0" color="#222"><link rel="manifest" href="/images/favicon16x16.ico"><meta name="msapplication-config" content="/images/favicon16x16.ico"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"6.7.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"28dbf854"}),daovoice("update")</script><meta name="description" content="软件危机软件危机指在计算机软件的开发和维护过程中，所遇到的一系列严重问题。软件危机主要包括的问题：如何开发软件如何维护软件软件危机的典型表现：发费用和进度难以估算和控制，大大超过预期的资金和规定日期软件需求分析不够充分，用户不满意“已经完成”的软件系统。软件质量难于保证软件维护困难难以改正程序中的错误难以根据用户的需要在原有程序中增加一些新的功能。通常没有保留适当的文档资料。文档的作用：软件开发管"><meta name="keywords" content="软件项目管理"><meta property="og:type" content="article"><meta property="og:title" content="软件工程和项目管理"><meta property="og:url" content="https://isjinhao.github.io/2019/软件工程和项目管理/index.html"><meta property="og:site_name" content="ISJINHAO"><meta property="og:description" content="软件危机软件危机指在计算机软件的开发和维护过程中，所遇到的一系列严重问题。软件危机主要包括的问题：如何开发软件如何维护软件软件危机的典型表现：发费用和进度难以估算和控制，大大超过预期的资金和规定日期软件需求分析不够充分，用户不满意“已经完成”的软件系统。软件质量难于保证软件维护困难难以改正程序中的错误难以根据用户的需要在原有程序中增加一些新的功能。通常没有保留适当的文档资料。文档的作用：软件开发管"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/软件开发面临的挑战.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/软件工程基本要素.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/软件工程方法.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/软件生命周期.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/软件工程过程.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/软件开发活动.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/瀑布模型.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/快速原型.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/增量模型.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/风险更大的增量模型.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/螺旋模型.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/软件工程工具.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/分而治之.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/ISO9126质量模型.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/经济可行性.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/系统开发的认知过程.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/具体模型到现实模型.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/DD定义数据.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/DD数据流.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/SA和SD.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/概要设计的过程.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/模块化.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/模块化和逐步精化.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/耦合性.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/无直接耦合.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/数据耦合.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/控制耦合.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/特征耦合.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/公共环境耦合.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/内容耦合.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/去除控制耦合.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/特征耦合修改为数据耦合.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/巧合内聚.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/逻辑内聚.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/过程内聚.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/通信内聚.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/顺序内聚.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/改进软件结构提高模块独立性.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/深度、宽度、扇出和扇入适中%20.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/使任一模块的作用域在其控制域内.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/五种基本的结构化控制结构.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/控制流图.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/判定节点.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/VG计算举例.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/测试步骤.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/单元测试的测试环境.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/等价类表.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/报表处理系统等价类表.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/报表合理等价类.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/报表不合理等价类.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/因果图基本符号.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/因果图基本符号2.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/因果图例.png"><meta property="og:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/软件维护比例.png"><meta property="og:updated_time" content="2019-05-31T09:09:22.114Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="软件工程和项目管理"><meta name="twitter:description" content="软件危机软件危机指在计算机软件的开发和维护过程中，所遇到的一系列严重问题。软件危机主要包括的问题：如何开发软件如何维护软件软件危机的典型表现：发费用和进度难以估算和控制，大大超过预期的资金和规定日期软件需求分析不够充分，用户不满意“已经完成”的软件系统。软件质量难于保证软件维护困难难以改正程序中的错误难以根据用户的需要在原有程序中增加一些新的功能。通常没有保留适当的文档资料。文档的作用：软件开发管"><meta name="twitter:image" content="https://isjinhao.github.io/2019/软件工程和项目管理/软件开发面临的挑战.png"><link rel="alternate" href="/atom.xml" title="ISJINHAO" type="application/atom+xml"><link rel="canonical" href="https://isjinhao.github.io/2019/软件工程和项目管理/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>软件工程和项目管理 | ISJINHAO</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">ISJINHAO</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://isjinhao.github.io/2019/软件工程和项目管理/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ISJINHAO"><meta itemprop="description" content="Living & Working"><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ISJINHAO"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">软件工程和项目管理</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-05-26 18:20:23" itemprop="dateCreated datePublished" datetime="2019-05-26T18:20:23+08:00">2019-05-26</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-05-31 17:09:22" itemprop="dateModified" datetime="2019-05-31T17:09:22+08:00">2019-05-31</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/软件项目管理/" itemprop="url" rel="index"><span itemprop="name">软件项目管理</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">20k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">18 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="软件危机"><a href="#软件危机" class="headerlink" title="软件危机"></a>软件危机</h2><p>软件危机指在计算机软件的开发和维护过程中，所遇到的一系列严重问题。软件危机主要包括的问题：</p><ul><li>如何开发软件</li><li>如何维护软件</li></ul><p>软件危机的典型表现：</p><ul><li>发费用和进度难以估算和控制，大大超过预期的资金和规定日期</li><li>软件需求分析不够充分，用户不满意“已经完成”的软件系统。</li><li>软件质量难于保证</li><li>软件维护困难<ul><li>难以改正程序中的错误</li><li>难以根据用户的需要在原有程序中增加一些新的功能。</li></ul></li><li><p>通常没有保留适当的文档资料。文档的作用：</p><ul><li>软件开发管理人员：用于管理和评价软件开发工程的进展状况</li><li>软件开发人员：用于开发人员对各个阶段的工作都进行周密思考、全盘权衡、从而减少返工。并且可在开发早期发现错误和不一致性，便于及时加以纠正</li><li>软件维护人员：软件维护的依据</li></ul></li><li><p>开发成本逐年上升，软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势。</p></li></ul><h3 id="产生软件危机的原因"><a href="#产生软件危机的原因" class="headerlink" title="产生软件危机的原因"></a>产生软件危机的原因</h3><h4 id="软件本身的特点"><a href="#软件本身的特点" class="headerlink" title="软件本身的特点"></a>软件本身的特点</h4><ul><li>软件与硬件不同<ul><li>抽象性。软件生产没有明显的制造过程，难以衡量开发进展，也难以控制软件质量。</li><li>问题的隐蔽性。没有硬件的磨损、老化问题，但存在开发早期在分析、设计阶段的错误，修改难度较大。</li></ul></li><li>软件与一般程序不同<ul><li>软件远比一般程序规模庞大，复杂性高。而复杂性包括实际问题的复杂性和程序逻辑结构的复杂性。</li><li>大型软件开发既有技术问题，还有社会问题。如：开发团队成员分工合作、技术与管理的矛盾、软件开发人员对软件应用的领域知识的了解。包括的社会因素有：组织机构、体制、管理方式、观念、人的心理素质等。</li></ul></li></ul><h4 id="软件开发与维护的方法不正确"><a href="#软件开发与维护的方法不正确" class="headerlink" title="软件开发与维护的方法不正确"></a>软件开发与维护的方法不正确</h4><ul><li>对用户需求的获取不正确<ul><li>用户的原因</li><li>分析人员的原因，对分析人员的要求：沟通能力、归纳总结能力、经验。</li></ul></li><li>软件开发不是编写程序。<ul><li>一个完整的软件产品由一整套完整的配置组成，程序只是其中的一个组成部分。</li><li>软件开发过程包括多个阶段，每个阶段的产品都是最终的完整的软件产品的一部分。</li></ul></li><li>软件开发只要依靠个别编程高手就能完成。</li><li>轻视软件维护。软件维护约占软件费用55%-75%，包括修改软件运行的错误；对软件进行改进和功能扩充。</li></ul><h4 id="其他产生软件危机的原因"><a href="#其他产生软件危机的原因" class="headerlink" title="其他产生软件危机的原因"></a>其他产生软件危机的原因</h4><ul><li>软件开发尚未完全摆脱手工艺的开发方式。</li><li>软件成本相当昂贵，主要依靠大量复杂的、高强度的脑力劳动。</li><li>软件的开发和运行常常受到计算机系统的限制，对计算机系统有着不同程度的依赖性。</li></ul><h2 id="软件的本质特性"><a href="#软件的本质特性" class="headerlink" title="软件的本质特性"></a>软件的本质特性</h2><ul><li>复杂性</li><li>一致性<ul><li>软件不能独立存在，需要依附于一定的环境（如硬件、网络以及其他软件）</li><li>软件必须遵从认为的惯例并适应已有的技术和系统</li><li>软件需要随接口不同而改变，随时间推移而变化，而这些变化是不同人设计的结果</li></ul></li><li>可变性：软件需要不断的进行调整来满足用户的需求</li><li>不可见性<ul><li>软件是一种“看不见，摸不着”的逻辑实体，不具有空间的形体特征。</li><li>开发人员可以直接看到程序代码，但是源代码并不是软件本身。</li><li>软件是以机器代码的形式运行，但是开发人员无法看到源代码是如何执行的。</li></ul></li></ul><h2 id="软件开发面临的挑战"><a href="#软件开发面临的挑战" class="headerlink" title="软件开发面临的挑战"></a>软件开发面临的挑战</h2><div align="center"><img width="80%" src="//isjinhao.github.io/2019/软件工程和项目管理/软件开发面临的挑战.png"></div><h2 id="消除软件危机的途径"><a href="#消除软件危机的途径" class="headerlink" title="消除软件危机的途径"></a>消除软件危机的途径</h2><ul><li>彻底消除“软件就是程序”的错误观念。</li><li>充分认识到软件开发是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目，不是个人独立的劳动。</li><li>推广和使用在实践中总结出来的软件开发的成功技术和方法。</li><li>开发和使用更好的软件工具</li></ul><p>“软件工程”的方法理论是摆脱软件危机的一个主要出路。即按工程化的原则和方法组织软件开发工作是有效的，是摆脱软件危机的一个主要出路。</p><h2 id="软件开发的误区"><a href="#软件开发的误区" class="headerlink" title="软件开发的误区"></a>软件开发的误区</h2><ul><li>只要是编程高手，即使是不懂软件工程，也能编出很好的软件。<ul><li>软件是服务于大众，却是由个性化的开发人员完成的。如果个性化太强，程序就无法阅读，其他人员也就无法维护。例：国内 80 年代涌现出来的众多汉字操作系统均是由编程高手完成的。</li></ul></li><li>只要拥有一套讲述如何开发软件的书籍，并了解了书中的标准与示例，就可以解决软件开发中遇到的任何问题。<ul><li>软件是用来解决现实问题的，现实问题的特殊性对规范提出了挑战（要进行适应）。</li><li>软件技术是发展的，没有祖传秘方。</li><li>就像拥有食谱并不能成为名厨一样，软件开发需要实践。</li></ul></li><li>只要拥有最好的开发工具、最好的计算机，一定能做出优秀的软件。<ul><li>硬件环境只是必要条件，人才是充分条件，软件是人在一定的约束条件下创造出来的。因人因事而异。</li></ul></li><li>软件开发时，如果进度慢，落后于计划，可以增加更多的程序员来解决。<ul><li>Brook法则：当人数增加后，项目所需的工作量将不成比例的增加。因为需要增加管理、协调、通信等工作。</li></ul></li></ul><h2 id="软件的定义"><a href="#软件的定义" class="headerlink" title="软件的定义"></a>软件的定义</h2><p>软件 = 程序 + 数据 + 文档</p><ul><li>软件：计算机可以接受的一系列指令，运行时可以提供所要求的功能和性能。</li><li>数据：使得程序能够适当地操作信息的数据结构</li><li>文档：描述程序的研制过程、方法和使用的图文资料。</li></ul><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><ul><li>1968 年，第一届NATO会议：为了经济地获得可靠的且能在实际机器上有效地运行的软件，而建立和使用完善的工程原理。</li><li>1993 年，IEEE/CS：将系统化的、规范的、可度量的方法应用于软件的开发、运行和维护的过程，即将工程化应用于软件中。软件工程便是对上述提到的各种方法的研究。</li></ul><h2 id="另一个角度的看软件工程本质特性"><a href="#另一个角度的看软件工程本质特性" class="headerlink" title="另一个角度的看软件工程本质特性"></a>另一个角度的看软件工程本质特性</h2><ul><li>软件工程关注于大型程序的构造。<ul><li>软件工程的中心课题是控制复杂性</li><li>主要考虑：如何分解和集成。为什么要分解： G .Miller（美国认知心理学家乔治·米勒）, “7±2 ” 原则，即短时间内人的记忆广度大约为7±2个单位。比如在记忆圆周率的时候只能记忆7±2位，超过这个范围需要分组记忆。</li></ul></li><li>软件经常变化</li><li>开发软件的效率非常重要</li><li>和谐地合作是开发软件的关键</li><li>软件必须有效地支持它的用户</li><li>在软件工程领域中是由具有一种文化背景的人替具有另一种文化背景的人创造产品</li></ul><p>扩展定义：软件 = 知识＋程序 + 数据 + 文档</p><h2 id="软件工程的基本原理"><a href="#软件工程的基本原理" class="headerlink" title="软件工程的基本原理"></a>软件工程的基本原理</h2><ul><li>用分阶段的生命周期计划严格管理</li><li>坚持进行阶段评审</li><li>实行严格的产品控制基线：基线（baseline）控制</li><li>采用现代程序设计技术</li><li>结果应能清楚地审查</li><li>开发小组的人员应该少而精</li><li>承认不断改进软件工程实践的必要性</li></ul><h2 id="软件工程方法学"><a href="#软件工程方法学" class="headerlink" title="软件工程方法学"></a>软件工程方法学</h2><p>软件工程包括“管理”和“技术”两方面内容：</p><ul><li>管理：对人、财、物的合理使用和配置；</li><li>技术：指软件开发中采用的方法、工具和过程。</li></ul><p>软件工程方法学：通常把在软件生命周期全过程中使用的一整套技术方法的集合称为方法学（methodology），也称为范型（paradigm）。</p><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><ul><li>软件工程过程：规定了完成各项任务的工作步骤。</li><li>软件工程方法：完成软件开发的各项任务的技术方法，为软件开发提供了“如何做”的技术。如项目计划与估算、软件系统需求分析、数据结构、系统总体结构的设计、算法过程的设计、编码、测试以及维护等。</li><li>软件工程工具：计算机辅助软件工程 CASE（computer Aided sottware Engineering），为软件工程方法提供自动或半自动的软件支撑环境。</li></ul><div align="center"><img width="80%" src="//isjinhao.github.io/2019/软件工程和项目管理/软件工程基本要素.png"></div><h4 id="软件工程方法"><a href="#软件工程方法" class="headerlink" title="软件工程方法"></a>软件工程方法</h4><div align="center"><img width="80%" src="//isjinhao.github.io/2019/软件工程和项目管理/软件工程方法.png"></div><h3 id="软件工程方法学思想"><a href="#软件工程方法学思想" class="headerlink" title="软件工程方法学思想"></a>软件工程方法学思想</h3><h4 id="传统方法学"><a href="#传统方法学" class="headerlink" title="传统方法学"></a>传统方法学</h4><ul><li>采用结构化技术（结构化分析、结构化设计和结构化实现）来完成软件开发的各项任务；</li><li>把软件生命周期划分为若干个阶段，按顺序完成每个阶段的任务；</li><li>每个阶段开始和结束都有严格的标准，对任何两个相邻的阶段而言，前一个阶段的结束标准就是后一阶段的开始标准；</li><li>每一个阶段结束之前都必须进行正式严格的技术审查和管理复审</li></ul><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>分解任务，分工合作，降低整个软件开发工程的困难；</li><li>采用科学的管理技术和良好的技术方法对每个阶段成果都进行严格的审查。保证了软件的质量。</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><p>把数据和操作人为地分离成两个独立的部分，增加了软件开发与维护的难度。</p><h4 id="面向对象方法学"><a href="#面向对象方法学" class="headerlink" title="面向对象方法学"></a>面向对象方法学</h4><p>模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类认识世界解决问题的方法与过程，从而使描述问题的问题空间（也称为问题域）与实现解法的解空间（也称为求解域）在结构上尽可能一致。要点如下：</p><ul><li>把对象（object）作为融合了数据及在数据上的操作行为的统一的软件构件。</li><li>把所有对象都划分成类（class ）。</li><li>按照父类（或称为基类）与子类（或称为派生类）的关系，把若干个相关类组成一个层次结构的系统（也称为类等级）。</li><li>对象彼此间仅能通过发送消息互相联系。</li></ul><p>和传统方法学的区别是：</p><ul><li>传统方法学强调自顶向下顺序地完成软件开发的各阶段任务。</li><li>面向对象方法是主动地多次反复迭代的演化过程。</li></ul><h2 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h2><div align="center"><img width="80%" src="//isjinhao.github.io/2019/软件工程和项目管理/软件生命周期.png"></div><h3 id="软件定义时期"><a href="#软件定义时期" class="headerlink" title="软件定义时期"></a>软件定义时期</h3><ul><li>确定软件开发工程必须完成的总目标；</li><li>确定工程的可行性；</li><li>导出实现工程目标应该采用的策略及系统必须完成的功能；</li><li>估计完成该项工程需要的资源和成本，并且制定工程进度表。</li><li>通常分为问题定义、可行性研究和需求分析三个阶段。</li></ul><h4 id="问题定义阶段"><a href="#问题定义阶段" class="headerlink" title="问题定义阶段"></a>问题定义阶段</h4><p>要解决的问题是什么？</p><h4 id="可行性研究阶段"><a href="#可行性研究阶段" class="headerlink" title="可行性研究阶段"></a>可行性研究阶段</h4><p>对于上一个阶段所确定的问题有行得通的解决办法吗？</p><h4 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h4><p>为了解决这个问题，目标系统必须做什么。用正式文档准确地记录对目标系统的需求，这份文档通常称为规格说明书（specification）。</p><h3 id="软件开发时期"><a href="#软件开发时期" class="headerlink" title="软件开发时期"></a>软件开发时期</h3><p>具体设计和实现前一个时期定义的软件，通常分为四个阶段。</p><h4 id="总体设计（概要设计）"><a href="#总体设计（概要设计）" class="headerlink" title="总体设计（概要设计）"></a>总体设计（概要设计）</h4><p>根据需求分析，设计软件的体系结构；定义结构中的组成模块。</p><h4 id="详细设计（模块设计）"><a href="#详细设计（模块设计）" class="headerlink" title="详细设计（模块设计）"></a>详细设计（模块设计）</h4><p>对每个模块要完成的工作进行具体的描述，为源程序编写打下基础。编写设计说明书，提交评审。与总体设计统称系统设计。</p><h4 id="程序编写（Coding-Programming）"><a href="#程序编写（Coding-Programming）" class="headerlink" title="程序编写（Coding, Programming）"></a>程序编写（Coding, Programming）</h4><p>把软件设计转换成计算机可以接受的程序代码。</p><h4 id="软件测试（Testing）"><a href="#软件测试（Testing）" class="headerlink" title="软件测试（Testing）"></a>软件测试（Testing）</h4><p>按规定的各项需求，逐项进行有效性测试，决定已开发的软件是否合格，能否交付用户使用，包括单元测试和组装测试。与程序编写统称系统实现。</p><h3 id="运行维护（软件维护）时期"><a href="#运行维护（软件维护）时期" class="headerlink" title="运行维护（软件维护）时期"></a>运行维护（软件维护）时期</h3><p>使软件持久的满足用户的需要，包括：</p><ul><li>改正性维护：运行中发现了软件中的错误需要修正。</li><li>适应性维护：为了适应变化了的软件工作环境，需做适当变更。</li><li>完善性维护：当用户有新的要求时，应该及时改进软件以满足用户的要求。</li><li>预防性维护: 即修改软件为将来的维护活动预先做准备。</li></ul><h2 id="软件过程"><a href="#软件过程" class="headerlink" title="软件过程"></a>软件过程</h2><p>软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。软件过程描述为了开发出客户需要的软件，什么人（who）、在什么时候（when）、做什么事（what）以及怎样（how）做这些事以实现某一个特定的具体目标。通常用软件生命周期模型来描述。</p><p>ISO 9000的定义：使用资源将输入转化为输出的活动所构成的系统。 “系统”是相互关联或相互作用的一组要素。</p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/软件工程和项目管理/软件工程过程.png"></div><div align="center"><img width="80%" src="//isjinhao.github.io/2019/软件工程和项目管理/软件开发活动.png"></div><h2 id="软件生命周期模型"><a href="#软件生命周期模型" class="headerlink" title="软件生命周期模型"></a>软件生命周期模型</h2><p>指软件项目从需求定义直至软件经使用后废弃为止，跨越整个生存周期的系统开发、运作和维护所实施的全部过程、活动和任务的结构框架。</p><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><ul><li>从上一阶段接受本阶段的工作对象，作为输入；</li><li>利用输入，完成本阶段活动的内容。</li><li>本阶段的工作成果作为输出传入下一阶段。</li></ul><div align="center"><img width="80%" src="//isjinhao.github.io/2019/软件工程和项目管理/瀑布模型.png"></div><p>实际的瀑布模型增加了一个评审活动，评审每个阶段完成的活动，若得到确认，则进行下一阶段的活动；否则返回前一阶段，甚至更前阶段返工。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>阶段间具有顺序性和依赖性。</li><li>推迟实现的观点。</li><li>质量保证的观点。</li></ul><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>可强迫开发人员采用规范的方法；</li><li>严格地规定了每个阶段必须提交的文档；</li><li>要求每个阶段的所有产品都必须经过质量保证小组的仔细验证；</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>无法解决软件需求不明确或不准确的问题；可能导致最终开发的产品不能真正满足用户需要。</li></ul><p>瀑布模型比较适合开发需求明确的软件。</p><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><p>原型是快速实现和运行的早期版本，反映最终系统部分重要特性。常见的原型实例：人机界面；系统主要功能。快速原型就是快速开发一个能用的版本再后期修改。</p><ul><li>获得用户的基本需求说明，据此快速建立一个小型软件系统。</li><li>用户试用，对其评价；</li><li>开发人员按照用户的意见快速地修改原型系统，获得新的原型版本，再请用户试用，如此反复，直到满足用户的要求；</li><li>用户确认原型系统之后，开发人员据此书写规格说明文档，进行下一步开发。</li></ul><div align="center"><img width="50%" src="//isjinhao.github.io/2019/软件工程和项目管理/快速原型.png"></div><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>通常能反映用户真实需求；</li><li>软件产品的开发基本上是线性顺序进行的。</li></ul><h3 id="增量（渐增）模型"><a href="#增量（渐增）模型" class="headerlink" title="增量（渐增）模型"></a>增量（渐增）模型</h3><p>把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成，并且能够完成特定的功能。</p><p>使用增量模型时，第一个阶段的增量构件往往实现软件的基本需求，提供最核心的功能；后面的增量构架逐渐添加系统的功能。</p><div align="center"><img width="75%" src="//isjinhao.github.io/2019/软件工程和项目管理/增量模型.png"></div><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><ul><li>增量构件规模适中；</li><li>分解的约束条件是当把新构件集成到现有软件中时，所形成的产品必须是可测试的；</li><li>软件体系必须是开放的，即在对现有系统添加新增量构件时，不能破坏系统原有功能。</li></ul><h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><ul><li>能在较短的时间内，提供可完成部分工作的初步产品给用户；</li><li>用户有较为充裕的时间学习和适应新产品。</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>对开发人员技术能力要求较高，要求能从系统整体出发正确划分增量构件，并进行分别开发，最后能很好地集成这些构件。</p><h4 id="一种风险更大的增量模型"><a href="#一种风险更大的增量模型" class="headerlink" title="一种风险更大的增量模型"></a>一种风险更大的增量模型</h4><div align="center"><img width="80%" src="//isjinhao.github.io/2019/软件工程和项目管理/风险更大的增量模型.png"></div><p>有可能提高开发速度，但需要密切地监控整个开发过程，否则会有构件无法集成到一起的风险。</p><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><p>大型软件开发面临的重要问题：软件风险，如：</p><ul><li>产品交付给用户之后，用户不满意；</li><li>开发进度落后，开发成本超出预算；</li><li>产品完成前关键的开发人员跳槽；</li><li>在产品投人市场前，竞争对手发布了一个功能相近，价格更低的软件 …</li></ul><p>构建原型能使某些类型的风险降到最低。</p><div align="center"><img width="100%" src="//isjinhao.github.io/2019/软件工程和项目管理/螺旋模型.png"></div><h4 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h4><ul><li>强调可选方案和约束条件，有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标；</li><li>减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的风险；</li><li>维护是一个周期，与开发并没有本质区别</li></ul><h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><ul><li>需要开发人员具有相当丰富的风险评估经验和专门知识；</li><li>进行风险分析的费用可能较大。</li></ul><p>适合大型软件开发。</p><h3 id="各种模型的比较"><a href="#各种模型的比较" class="headerlink" title="各种模型的比较"></a>各种模型的比较</h3><table><thead><tr><th style="text-align:center"><strong>模型</strong></th><th style="text-align:center"><strong>优点</strong></th><th style="text-align:center"><strong>缺点</strong></th></tr></thead><tbody><tr><td style="text-align:center"><strong>瀑布模型</strong></td><td style="text-align:center">规范，文档驱动</td><td style="text-align:center">系统可能不满足客户真正的需求</td></tr><tr><td style="text-align:center"><strong>快速原型</strong></td><td style="text-align:center">克服了瀑布型的缺点</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>增量模型</strong></td><td style="text-align:center">开发早期回报明确，易于维护</td><td style="text-align:center">要求开放的软件体系结构</td></tr><tr><td style="text-align:center"><strong>螺旋模型</strong></td><td style="text-align:center">风险驱动，适用于大型项目开发</td><td style="text-align:center">风险分析人员需要有经验且经过充分训练</td></tr></tbody></table><h2 id="软件工程工具"><a href="#软件工程工具" class="headerlink" title="软件工程工具"></a>软件工程工具</h2><div align="center"><img width="80%" src="//isjinhao.github.io/2019/软件工程和项目管理/软件工程工具.png"></div><h2 id="软件开发的基本策略"><a href="#软件开发的基本策略" class="headerlink" title="软件开发的基本策略"></a>软件开发的基本策略</h2><h3 id="软件复用"><a href="#软件复用" class="headerlink" title="软件复用"></a>软件复用</h3><p>利用已有的软件制品，直接组装或合理修改形成新的软件系统，从而提高开发效率和产品质量，降低维护成本。软件复用不仅仅是代码复用，函数库、类库、模板（文档、网页）、设计模式、组件、框架。</p><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>软件工程是一项解决问题的工程活动，通过对问题进行研究分析，将一个复杂的问题分解成可以理解并能够处理的若干小问题，然后再逐个解决。</p><div align="center"><img width="100%" src="//isjinhao.github.io/2019/软件工程和项目管理/分而治之.png"></div><h3 id="逐步演进"><a href="#逐步演进" class="headerlink" title="逐步演进"></a>逐步演进</h3><p>软件开发应该遵循软件的客观规律，不断进行迭代式增量开发，最终交付符合客户价值的产品。</p><h3 id="优化折中"><a href="#优化折中" class="headerlink" title="优化折中"></a>优化折中</h3><p>软件工程师应该把优化当成一种责任，不断改进和提升软件质量；但是优化是一个多目标的最优决策，在不可能使所有目标都得到优化时，需要进行折中实现整体最优。</p><h2 id="ISO9126-质量模型"><a href="#ISO9126-质量模型" class="headerlink" title="ISO9126 质量模型"></a>ISO9126 质量模型</h2><div align="center"><img width="80%" src="//isjinhao.github.io/2019/软件工程和项目管理/ISO9126质量模型.png"></div><h3 id="功能性"><a href="#功能性" class="headerlink" title="功能性"></a>功能性</h3><ul><li>适合性：当软件你在指定条件下使用，其满足明确和隐含要求功能的能力。</li><li>准确性：软件提供给用户功能的精准度能不能满足要求</li><li>互操作性：软件与其他系统进行交互的能力</li><li>安全性：软件保护信息和数据的安全能力</li></ul><h3 id="可靠性"><a href="#可靠性" class="headerlink" title="可靠性"></a>可靠性</h3><ul><li>成熟性：软件产品避免因软件中错误开发而导致失效的能力</li><li>容错性：软件防止外部接口错误扩散而导致系统失效的能力</li><li>可恢复性：系统失效后，重新恢复原有功能和性能的能力</li></ul><h3 id="易用性"><a href="#易用性" class="headerlink" title="易用性"></a>易用性</h3><ul><li>易理解性：软件显示的信息要清晰、准确且易懂，使用户能够快速理解软件。</li><li>易学习性：软件使用户能学习其应用的能力</li><li>易操作性：软件产品使用户能易于操作和控制它的能力。</li><li>吸引性：软件具有的某些独特的、能让用户眼前一亮的属性。</li></ul><h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><ul><li>时间特性：在规定的条件下，软件产品执行其功能时能够提供适当的响应时间效和处理时间以及吞吐率的能力。</li><li>资源利用：软件系统在完成用户指定的业务请求所消耗的系统资源，诸如CPU占有率、内存占有率、网络带宽占有率等。</li></ul><h3 id="可维护性"><a href="#可维护性" class="headerlink" title="可维护性"></a>可维护性</h3><ul><li>易分析性：软件提供辅助手段帮助开发人员定位缺陷原因并判断出修改之处。</li><li>易改变性：软件产品使得指定的修改容易实现的能力。</li><li>稳定性：软件产品避免由于软件修改而造成意外结果的能力。</li><li>易测试性：软件提供辅助性手段帮助测试人员实现其测试意图。</li></ul><h3 id="可移植性"><a href="#可移植性" class="headerlink" title="可移植性"></a>可移植性</h3><ul><li>适应性：软件产品无需做任何相应变动就能适应不同运行环境的能力。</li><li>易安装性：在平台变化后成功安装软件的难易程度</li><li>共存性：软件产品在公共环境与其共享资源的其他系统共存的能力。</li><li>替换性：软件系统的升级能力，包括在线升级、打补丁升级等。</li></ul><h2 id="可行性研究的目的"><a href="#可行性研究的目的" class="headerlink" title="可行性研究的目的"></a>可行性研究的目的</h2><ul><li>说明该软件开发项目的实现在技术上、经济上和社会条件上的可行性；评述为合理地达到开发目标可能选择的各种方案。</li><li>用最小的代价在尽可能短的时间内确定问题是否能够并且值得解决。</li></ul><p>可行性研究最根本任务是对以后的行动方针提出建议，一般占预期工程总成本的 5%-10%。</p><h2 id="可行性研究的基本内容"><a href="#可行性研究的基本内容" class="headerlink" title="可行性研究的基本内容"></a>可行性研究的基本内容</h2><ul><li>技术可行性：使用现有的技术能实现这个系统吗？主要考虑：开发风险；资源；相关技术的发展</li><li>经济可行性：这个系统的经济效益能超过它的开发成本吗？<ul><li>系统经济效益 = 新系统增加的收入＋ 新系统节省的费用</li><li>考虑：成本——效益分析、长期的公司经营策略、对其他单位或产品的影响、开发所需的成本和资源、潜在的市场前景</li></ul></li><li>操作可行性：系统的操作方式在用户组织内行得通吗？</li><li>其他：法律可行性、社会效应、管理问题等</li></ul><h3 id="技术可行性"><a href="#技术可行性" class="headerlink" title="技术可行性"></a>技术可行性</h3><p>对系统的性能、可靠性、可维护性以及生产率等方面的信息进行评价。通过技术可行性的分析，将为新系统提交技术可行性评估。以指明为完成系统的功能和性能需要什么技术？需要哪些材料、方法、算法、或者过程等。</p><p>技术可行性分析方法：数学模型和优化技术、概率和统计、排队论、控制论等方法。</p><h3 id="经济可行性"><a href="#经济可行性" class="headerlink" title="经济可行性"></a>经济可行性</h3><p>进行成本效益分析，评估项目的开发成本。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/经济可行性.png"></div><h3 id="操作可行性"><a href="#操作可行性" class="headerlink" title="操作可行性"></a>操作可行性</h3><ul><li>一个地区、一个行业乃至一个国家计算机应用发展的客观道路及规律</li><li>客观发展规律，各阶段是不能超越的</li><li>结合实际分析本单位、本部门、本行业的实际情况，参照国内外经验教训，实事求是地规划本企业信息系统的发展。</li></ul><h2 id="可行性研究的任务"><a href="#可行性研究的任务" class="headerlink" title="可行性研究的任务"></a>可行性研究的任务</h2><p>可行性研究的目的是建立目标系统的逻辑模型。通常软件软件开发项目是要实现目标系统的物理模型，即确定待开发软件系统的系统元素，并将功能和数据结构分配到这些系统元素中。它是软件实现的基础。但是目标系统的物理模型是由它的逻辑模型经实例化，即具体到某个业务领域而得到的。与物理模型不同，<strong>逻辑模型</strong>忽视机制和细节，<strong>只描述系统要完成的功能和要处理的数据</strong>。为此，该阶段的主要任务是，借助于当前系统的逻辑模型导出目标系统的逻辑模型，也就是解决目标系统<strong>“做什么”的问题</strong>。</p><p>其实系统的开发过程就是根据需要解决的问题，建立一个有信息技术支撑、与解决问题相关的、数据处理的、可运行的计算机模型。</p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/软件工程和项目管理/系统开发的认知过程.png"></div><h3 id="具体模型到逻辑模型举例"><a href="#具体模型到逻辑模型举例" class="headerlink" title="具体模型到逻辑模型举例"></a>具体模型到逻辑模型举例</h3><div align="center"><img width="80%" src="//isjinhao.github.io/2019/软件工程和项目管理/具体模型到现实模型.png"></div><h2 id="可行性研究的定义"><a href="#可行性研究的定义" class="headerlink" title="可行性研究的定义"></a>可行性研究的定义</h2><p>了解客户的要求及现实环境，从技术、经济和社会因素等三方面研究并论证本软件项目的可行性，编写可行性研究报告，制定初步项目开发计划。</p><p>可行性分析的描述手段：系统流程图、数据流图</p><h2 id="可行性研究报告功能"><a href="#可行性研究报告功能" class="headerlink" title="可行性研究报告功能"></a>可行性研究报告功能</h2><p>说明软件项目的实现在技术上、经济上和社会因素上的可行性，评述为合理地达到开发目标可供选择的各种可能的实现方案，说明并论证所选定实施方案的理由。</p><h2 id="成本／效益分析"><a href="#成本／效益分析" class="headerlink" title="成本／效益分析"></a>成本／效益分析</h2><p>从经济角度分析开发一个特定的新系统是否划算，帮助客户负责人作出是否投资的决定。主要包括成本估计和成本效益分析。</p><h3 id="成本估计"><a href="#成本估计" class="headerlink" title="成本估计"></a>成本估计</h3><p>包括开发成本和运行成本</p><h4 id="开发成本"><a href="#开发成本" class="headerlink" title="开发成本"></a>开发成本</h4><ul><li>代码行技术：根据经验和历史数据，估算实现一个功能需要多少源程序行数，用每行代码的平均成本乘以行数。</li><li>任务分解技术：将软件开发工程分解成若干个相对独立的任务，分别估算，然后累加得出总成本。<ul><li>按阶段分解</li><li>按功能分解</li></ul></li><li>自动估计成本技术：采用自动估计成本的软件工具，需要有长期搜集的大量历史数据为基础，并需要良好的数据库系统支持。</li></ul><h4 id="运行成本"><a href="#运行成本" class="headerlink" title="运行成本"></a>运行成本</h4><p>取决于系统的操作费用（操作人员数、工作时间、消耗的物资等）和维护费用。</p><h2 id="需求定义"><a href="#需求定义" class="headerlink" title="需求定义"></a>需求定义</h2><p>需求是人们要解决的问题某个问题或达到某种目的的需要。是系统或其组成部分为满足某种书面规定（合同、标准、规范等）所要具备的能力。需求将作为系统开发、测试、验收、提交的正式文档的依据。</p><h2 id="需求的内容"><a href="#需求的内容" class="headerlink" title="需求的内容"></a>需求的内容</h2><ul><li>需求是系统为满足客户期望的目标而完成的行为</li><li>需求要体现出对问题领域的清晰理解</li><li>给出系统的使用场景和上下文</li><li>需求定义涵盖如下内容<ul><li>为什么要设计此系统</li><li>系统由谁使用</li><li>系统要做什么</li><li>系统涉及哪些信息</li><li>对解决方案有什么额外补充</li><li>如何使用该系统</li><li>质量需要达到何种程度</li></ul></li></ul><h2 id="需求内容来源"><a href="#需求内容来源" class="headerlink" title="需求内容来源"></a>需求内容来源</h2><ul><li>干系人：<ul><li>干系人是任何和系统有关的人，如：资方、客户、系统用户、领域专家、项目研发团队。</li><li>识别干系人可以从以下几个方面来判别：产品谁来用、输入谁提供、输出谁要、谁监管、影响谁、奖励谁、惩罚谁。</li></ul></li><li>业务过程：对现有业务过程的分析有助于识别业务问题并改进<ul><li>找出并列举当前业务过程中的问题</li><li>分析问题的本质，可能是遗漏的，可能不好用，可能有新需求</li><li>分析改进的机会</li><li>分析改进的实质</li></ul></li><li>组织规章制度：分析规章制度有益于确定业务规则和约束条件<ul><li>业务规则：描述对业务过程的要求，如支撑系统的业务过程的结构、控制、行为效果</li><li>约束：对系统开发过程的管理限制，主要涉及经济、政治、技术和环境四个方面，具体包括项目资源、时间、目标环境级</li></ul></li><li>现有系统：分析现有系统有助于了解未来系统的工作数据</li></ul><h2 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h2><p>软件需求指用户对所开发的软件在功能、性能、环境、可靠性等各方面的要求。需求分析主要回答待开发的系统必须“做什么”，并用 《 需求规格说明书 》 的形式准确、详细、规范地表达出来。</p><ul><li><p>需求分析阶段，系统分析员的主要关注点是“做什么（ what ) ” ，不是“怎样做（ how）”；</p></li><li><p>需求分析阶段，系统分析员应该给出软件需求规格书。</p></li></ul><h3 id="需求分析的任务"><a href="#需求分析的任务" class="headerlink" title="需求分析的任务"></a>需求分析的任务</h3><ol><li>确定对系统的综合要求</li><li>分析系统的数据要求</li><li>导出系统的逻辑模型</li><li>修正系统开发计划</li></ol><h3 id="确定对系统的综合要求"><a href="#确定对系统的综合要求" class="headerlink" title="确定对系统的综合要求"></a>确定对系统的综合要求</h3><ul><li>功能需求。指定系统必须提供的服务。</li><li>性能需求。指定系统必须满足的定时约束或容量约束等。</li><li>可靠性和可用性需求。应定量指定。</li><li>出错处理需求。指环境错误，非系统本身的错误。</li><li>接口需求。常见的接口需求：用户接口需求；硬件接口需求；软件接口需求；通信接口需求。</li><li>常见的约束：精度；工具和语言约束；设计约束；应该使用的标准；应该使用的硬件平台。</li><li>逆向需求。指定系统不应该做什么，</li><li>将来可能提出的要求。</li></ul><h2 id="分析建模"><a href="#分析建模" class="headerlink" title="分析建模"></a>分析建模</h2><p>结构化分析（Structured Analysis，SA）是面向数据流进行分析的方法，主要建立以下几种模型：</p><ul><li>实体关系图（Entity-Relationship Diagram，E-R图）来创建数据模型，描述系统中所有重要的数据对象；</li><li>数据流图（Data Flow Diagram，DFD）：用来创建功能模型，描述了信息流和数据转换；</li><li>状态转换图（State-Transition Diagram，STD）用来创建行为模型，描述系统状态如何响应外部事件，而进行转换。</li></ul><p>面向对象分祈方法（OOA）所建立的摸型</p><ul><li>对象模型（Object model）：定义实体，描述系统的静态结构，定义“对谁做”</li><li>动态模型（Dynamic model）：描述对象之间的交互过程，规定“何时做”</li><li>功能模型（Functional model） ：描述内部数据的处理，指明系统应“做什么”</li></ul><h2 id="数据词典"><a href="#数据词典" class="headerlink" title="数据词典"></a>数据词典</h2><p>DD 是对数据流图中包含的所有元素的定义的集合，使得每个图形元素的名字都有一个精确的、严格的定义。数据流图和词典结合在一起，能清楚地表达数据处理的要求，构成了“需求说明书”</p><h3 id="定义数据的方法"><a href="#定义数据的方法" class="headerlink" title="定义数据的方法"></a>定义数据的方法</h3><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/DD定义数据.png" width="60%"></div><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>北京某高校可用的电话号码有以下几类：校内电话号码由4位数字组成，第1位数字不是0；校外电话又分为本市电话和外地电话两类，拨校外电话需先拨0，若是本市电话则再接着拨8位数字(第1位不是0)，若是外地电话则拨3位区码再拨8位电话号码(第1位不是0)。请用定义数据字典的方法，定义上述的电话号码。</p><ul><li>电话号码 = [校内电话号码|校外电话号码]</li><li>校内电话号码 = 非零数字+ 3 位数字 //后面继续定义</li><li>校外电话号码 = [本市号码|外地号码]</li><li>本市号码 = 数字零+8位数字</li><li>外地号码 = 数字零+3位数字+8位数字</li><li>非零数字 = [1|2|3|4|5|6|7|8|9]</li><li>数字零＝0</li><li>3位数字＝3{数字}3 //3至3个数字</li><li>8位数字 = 非零数字+7位数字</li><li>7位数字 = 7{数字}7</li><li>数字＝[0|1|2|3|4|5|6|7|8|9]</li></ul><h3 id="DD定义数据流"><a href="#DD定义数据流" class="headerlink" title="DD定义数据流"></a>DD定义数据流</h3><ul><li>数据流名：</li><li>说明：简要介绍作用即它产生的原因和结果。</li><li>数据流来源：来自何方。</li><li>数据流去向：去向何处。</li><li>数据流组成：数据结构。</li><li>数据量流通量：数据量，流通量</li></ul><h4 id="数据流定义"><a href="#数据流定义" class="headerlink" title="数据流定义"></a>数据流定义</h4><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/DD数据流.png" width="60%"></div><ul><li>数据流：购物单</li><li>别名：无</li><li>简述：学生购书时填写的项目</li><li>来源：学生</li><li>去向：审查并开发票</li><li>组成：学号+姓名+书号+数量</li><li>数据流量：1000次/周</li><li>高峰值：开学期间1000次/天</li></ul><h3 id="DD定义数据元素"><a href="#DD定义数据元素" class="headerlink" title="DD定义数据元素"></a>DD定义数据元素</h3><p>数据元素，又叫数据项，指数据处理中最小的，不可再分的单位。描述包括：</p><ul><li>数据元素名</li><li>类型：数字（离散值，连续值），文字（编码类型）</li><li>长度</li><li>取值范围</li><li>相关的数据元素及数据结构</li></ul><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><ul><li>数据元素名：商品编号</li><li>别名：</li><li>描述：唯一的描述库存库清单中一个特定商品的关键域</li><li>定义：商品编号 = 8 {字符} 8</li><li>位置：<ul><li>订货报表</li><li>订货信息</li><li>库存清单</li></ul></li></ul><h3 id="DD定义数据存储"><a href="#DD定义数据存储" class="headerlink" title="DD定义数据存储"></a>DD定义数据存储</h3><ul><li>数据文件名：</li><li>简述：存放的是什么数据</li><li>输入数据：</li><li>输出数据：</li><li>数据文件组成：数据结构</li><li>存储方式：顺序，直接，关键码</li><li>存取频率：</li></ul><h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><ul><li>数据文件名：库存记录</li><li>别名：无</li><li>简述：存放库存所有可供货物的信息</li><li>组成：货物名称+编号+生产厂家+单价+库存量</li><li>组织方式：索引文件，以货物编号为关键字</li><li>查询要求：要求能立即查询</li></ul><h3 id="DD定义数据处理"><a href="#DD定义数据处理" class="headerlink" title="DD定义数据处理"></a>DD定义数据处理</h3><ul><li>处理名</li><li>编号：DFD中的编号</li><li>激活条件</li><li>处理逻辑：此处理的子项</li><li>执行频率</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><ul><li>数据处理名：登记报名单</li><li>编号：1</li><li>激活条件：收到报告单</li><li>数据处理组成：<ul><li>1.1：检查报告单</li><li>1.2：编准考证号</li><li>1.3：登记考生</li></ul></li><li>执行频率：2000次/日</li></ul><h2 id="软件设计的目标"><a href="#软件设计的目标" class="headerlink" title="软件设计的目标"></a>软件设计的目标</h2><p>软件需求：解决“做什么”。软件设计：解决“怎么做”。</p><ul><li>软件设计的任务：以软件需求规格说明书为依据，着手实现软件的需求，并将设计的结果反映在“设计规格说明书”文档中。</li><li>软件设计的重要性：是软件开发阶段的第一步，最终影响软件实现的成败和软件维护的难易程度。</li></ul><h3 id="软件设计的两个阶段"><a href="#软件设计的两个阶段" class="headerlink" title="软件设计的两个阶段"></a>软件设计的两个阶段</h3><h4 id="第一阶段：概要设计（总体设计）"><a href="#第一阶段：概要设计（总体设计）" class="headerlink" title="第一阶段：概要设计（总体设计）"></a>第一阶段：概要设计（总体设计）</h4><p>根据软件需求，设计软件系统结构和数据结构，确定程序的组成模块及模块之间的相互关系。回答“概括地说，系统应该如何实现？”。其重要性是：站在全局高度，从较抽象的层次上分析对比多种可能的系统实现方案和软件结构，从中选出最佳方案和最合理的软件结构，从而用较低成本开发出较高质量的软件系统。</p><h4 id="第二阶段：详细设计（过程设计）"><a href="#第二阶段：详细设计（过程设计）" class="headerlink" title="第二阶段：详细设计（过程设计）"></a>第二阶段：详细设计（过程设计）</h4><ul><li><p>确定模块内部的算法和数据结构；</p></li><li><p>选定某种过程的表达形式来描述各种算法；</p></li><li><p>产生精确描述各模块程序过程的详细文档，并进行评审。</p></li></ul><h2 id="SA和SD"><a href="#SA和SD" class="headerlink" title="SA和SD"></a>SA和SD</h2><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/SA和SD.png" width="60%"></div><h2 id="概要设计的任务"><a href="#概要设计的任务" class="headerlink" title="概要设计的任务"></a>概要设计的任务</h2><ul><li>制定规范：为软件开发小组制定在进行软件设计，应该共同遵守的标准，以便协调组内各员的工作。</li><li>设计软件系统结构（简称软件结构）<ul><li>将系统按功能划分成模块</li><li>确定每个模块的功能</li><li>确定模块之间的调用关系</li><li>确定模块之间的接口，即模块之间传递的信息</li><li>评价模块结构的质量</li></ul></li><li>处理方式设计<ul><li>功能设计：确定实现功能法，评估算法的性能．</li><li>性能设计：确定实现性能需求必须的算法和模块间的控制方式</li></ul></li><li>数据结构及数据库设计</li><li>可靠性设计</li><li>编写概要设计文档</li><li>概要设计评审</li></ul><h2 id="软件设计的过程"><a href="#软件设计的过程" class="headerlink" title="软件设计的过程"></a>软件设计的过程</h2><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/概要设计的过程.png" width="80%"></div><h2 id="软件设计的原理"><a href="#软件设计的原理" class="headerlink" title="软件设计的原理"></a>软件设计的原理</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>采取自顶向下的方式，逐层把软件系统划分成若干可单独命名和可编址的部分，即“ 模块” ，每个模块完成一个特定的子功能；所有模块按某种方法组成一个整体，完成整个系统所要求的功能。软件系统就是通过这些模块的组合来实现。</p><p>模块化是在逻辑和无理上将整个系统分解成多个更小的部分，其实质是“分而治之”，即将一个复杂问题分解成若干个简单问题，然后再逐个解决。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/模块化.png"></div><h3 id="自顶向下，逐步求精的基本思想"><a href="#自顶向下，逐步求精的基本思想" class="headerlink" title="自顶向下，逐步求精的基本思想"></a>自顶向下，逐步求精的基本思想</h3><ul><li>将功能、信息的说明分为多个层次，最高层也最抽象 ― 仅仅只是概念性地描述功能或信息，不提供功能的内部工作情况或信息的内部结构；</li><li>设计者从最高层开始，仔细推敲，进行功能和信息的细化，给出下层实现的细节；</li><li>随着每个后续细化逐步的完成，提供越来越多的细节，最终得出用程序设计语言表达的程序。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/模块化和逐步精化.png" width="60%"></div><h2 id="模块独立"><a href="#模块独立" class="headerlink" title="模块独立"></a>模块独立</h2><p>系统分解的目标：高内聚、低耦合。</p><p>内聚性是一个模块或子系统内部的依赖程度。如果一个模块或子系统含有许多彼此相关的元素，并且它们执行类似任务，那么其内聚性比较高；如果一个模块或子系统含有许多彼此不相关的元素，其内聚性就比较低。</p><p>耦合性是两个模块或子系统之间依赖关系的强度。如果两个模块或 子系统是松散耦合的，二者相互独立，那么当其中一个发生变化时对另一个产生的影响就很小；如果两个模块或子系统是紧密耦合的，其中一个发生变化就可能对另一个产生较大影响。</p><h3 id="耦合性"><a href="#耦合性" class="headerlink" title="耦合性"></a>耦合性</h3><p>也称块间的联系。是对软件系统结构中，各模块间相互联系紧密程度的一种度量。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/耦合性.png" width="80%"></div><h4 id="无直接藕合"><a href="#无直接藕合" class="headerlink" title="无直接藕合"></a>无直接藕合</h4><p>两个模块没有直接关系，模块独立性最强。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/无直接耦合.png"></div><h4 id="数据耦合"><a href="#数据耦合" class="headerlink" title="数据耦合"></a>数据耦合</h4><p>属松散耦合。一模块访问另一模块时，通过数据参数交换输入、输出信息。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/数据耦合.png"></div><h4 id="控制藕合"><a href="#控制藕合" class="headerlink" title="控制藕合"></a>控制藕合</h4><p>模块之间传递的是控制信息（如开关、标志、名字等），控制被调用模块的内部逻辑。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/控制耦合.png" width="60%"></div><h4 id="特征耦合"><a href="#特征耦合" class="headerlink" title="特征耦合"></a>特征耦合</h4><p>两个模块通过传递数据结构加以联系，或都与一个数据结构有关系，则称这两个模块间存在特征耦合。可能出现的情况：当把整个数据结构作为参数传递时，被调用的模块虽然只需要使用其中的一部分数据元素，但实际可以使用的数据多于它真正需要的数据，这将导致对数据访问失去控制。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/特征耦合.png"></div><p>“住户情况”是一个数据结构，图中模块都与此数据结构有关。</p><p>“计算水费”和“计算电费”本无关，由于引用了此数据结构产生依赖关系。</p><h4 id="公共环境耦合"><a href="#公共环境耦合" class="headerlink" title="公共环境耦合"></a>公共环境耦合</h4><p>一组模块引用同一个公用数据区（也称全局数据区、公共数据环境）。公共数据区指：</p><ul><li>全局数据结构。</li><li>共享通讯区。</li><li>内存公共覆盖区等</li></ul><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/公共环境耦合.png"></div><p>公共耦合存在的问题：</p><ul><li>软件可理解性降低</li><li>诊断错误困难</li><li>软件可维护性差</li><li>软件可靠性差</li></ul><h4 id="内容耦合"><a href="#内容耦合" class="headerlink" title="内容耦合"></a>内容耦合</h4><p>有下列情况之一的。是最不好的耦合形式！</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/内容耦合.png" width="60%"></div><h4 id="控制耦合改为数据耦合"><a href="#控制耦合改为数据耦合" class="headerlink" title="控制耦合改为数据耦合"></a>控制耦合改为数据耦合</h4><ul><li>将被调用模块内的判定上移到调用模块中进行</li><li>被调用模块分解成若干单一功能模块</li></ul><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/去除控制耦合.png" width="40%"></div><h4 id="特征耦合修改为数据耦合"><a href="#特征耦合修改为数据耦合" class="headerlink" title="特征耦合修改为数据耦合"></a>特征耦合修改为数据耦合</h4><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/特征耦合修改为数据耦合.png" width="40%"></div><h3 id="内聚性"><a href="#内聚性" class="headerlink" title="内聚性"></a>内聚性</h3><h4 id="巧合内聚"><a href="#巧合内聚" class="headerlink" title="巧合内聚"></a>巧合内聚</h4><p>块内各组成成份在功能上是互不相关的。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/巧合内聚.png" width="60%"></div><h4 id="逻辑内聚"><a href="#逻辑内聚" class="headerlink" title="逻辑内聚"></a>逻辑内聚</h4><p>把几种相关功能（逻辑上相似的功能）组合在一模块内，每次调用由传给模块的参数确定执行哪种功能。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/逻辑内聚.png" width="70%"></div><h4 id="时间内聚"><a href="#时间内聚" class="headerlink" title="时间内聚"></a>时间内聚</h4><p>模块完成的功能必须在同一时间内执行，这些功能只因时间因素关联在一起。如：</p><ul><li>]初始化系统模块</li><li>系统结束模块、</li><li>紧急故障处理模块等</li></ul><h4 id="过程内聚"><a href="#过程内聚" class="headerlink" title="过程内聚"></a>过程内聚</h4><p>模块内各处理成分相关，且必须以特定次序执行。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/过程内聚.png" width="70%"></div><h4 id="通信内聚"><a href="#通信内聚" class="headerlink" title="通信内聚"></a>通信内聚</h4><p>模块内各部分使用相同的输入数据，或产生相同的输出结果。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/通信内聚.png" width="70%"></div><h4 id="顺序内聚"><a href="#顺序内聚" class="headerlink" title="顺序内聚"></a>顺序内聚</h4><p>模块完成多个功能，各功能都在同一数据结构上操作，每一功能有唯一入口。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/顺序内聚.png"></div><h4 id="功能内聚"><a href="#功能内聚" class="headerlink" title="功能内聚"></a>功能内聚</h4><p>模块仅包括为完成某个功能所必须的所有成分。模块所有成分共同完成一个功能，缺一不可。</p><h3 id="启发规则"><a href="#启发规则" class="headerlink" title="启发规则"></a>启发规则</h3><ul><li>改进软件结构，提高模块独立性：通过模块分解或合并，降低耦合提高内聚</li></ul><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/改进软件结构提高模块独立性.png" width="60%"></div><ul><li><p>模块规模适中：在考虑模块的独立性同时，为了增加可理解性，模块的大小最好在 50-150 条语句左右，可以用 1-2 页打印纸打印，便于人们阅读与研究。</p><ul><li>模块过大：可理解程度下降</li><li>模块过小：开销大于有效操作系统接口复杂</li></ul></li><li><p>深度、宽度、扇出和扇入适中</p></li></ul><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/深度、宽度、扇出和扇入适中 .png" width="70%"></div><ul><li>将模块的影响限制在控制范围内：使任一模块的作用域在其控制域内<ul><li>作用域是指受模块内一个判定影响的所有模块的集合</li><li>控制域是指这个模块本身及其所有的下属模块的集合</li></ul></li></ul><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/使任一模块的作用域在其控制域内.png" width="40%"></div><p>模块 C 的控制范围： C 、 D 、 E 、 F 、 G 、 H 。如果模块 C 作出的决策影响了模块 L ，L超出了 C 的控制范围</p><ul><li>降低模块接口的复杂性：接口传递信息应简单且和模块功能一致。模块的接口要简单、清晰、含义明确，便于理解，易于实现、测试与维护。</li><li>设计单入口单出口的模块：不要使模块间出现内容耦合。</li><li>模块功能可预测：如果一个模块可以当作一个黑盒子，相同输入产生相同输出，其功能为可预测的。若模块带有内部“存储器”，其功能可能是不可预测的，难理解、难测试、难维护。单一的模块具有高内聚。但模块功能过分局限，可使用范围将过分狭窄，缺乏灵活性和扩充性。</li></ul><h2 id="描绘软件结构的图形具"><a href="#描绘软件结构的图形具" class="headerlink" title="描绘软件结构的图形具"></a>描绘软件结构的图形具</h2><h3 id="层次图和-HIPO-图"><a href="#层次图和-HIPO-图" class="headerlink" title="层次图和 HIPO 图"></a>层次图和 HIPO 图</h3><p>描述软件的层次结构。层次图中，一个方框代表一个模块，方框间的连线表示调用关系。 HIPO图=层次图+ IPO 图</p><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p>…</p><h2 id="结构程序设计"><a href="#结构程序设计" class="headerlink" title="结构程序设计"></a>结构程序设计</h2><p>经典定义：如果一个程序的代码块仅仅通过顺序、选择和循环这 3 种基本控制结构进行连接，而且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。</p><p>比较全面的定义：结构程序设计是尽可能少用 GOTO 语句的程序设计方法，最好仅仅在检测出错误时才使用 GOTO 语句，而且应该总是使用前向的 GOTO 语句。</p><h3 id="SP主要原则"><a href="#SP主要原则" class="headerlink" title="SP主要原则"></a>SP主要原则</h3><ul><li>使用语言中的顺序、选择、重复等有限的基本控制结构表示程序逻辑。</li><li>选用的控制结构只准许有一个入口和一个出口。</li><li>复杂结构应该用基本控制结构进行组合嵌套来实现。</li><li>严格控制 GOTO 语句，仅在下列情形才可使用。<ul><li>用一个非结构化的程序设计语言去实现一个结构化的构造。</li><li>在某种可以改善而不是损害程序可读性的情况下。</li></ul></li></ul><h3 id="五种基本的结构化控制结构"><a href="#五种基本的结构化控制结构" class="headerlink" title="五种基本的结构化控制结构"></a>五种基本的结构化控制结构</h3><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/五种基本的结构化控制结构.png" width="70%"></div><h2 id="控制流图"><a href="#控制流图" class="headerlink" title="控制流图"></a>控制流图</h2><ul><li><p>符号“ O ”为程序图的结点，表示一个或多个无分支的语句；</p></li><li><p>箭头为边，表示控制流的方向。</p></li><li><p>边和结点圈定的封闭范围叫做区域。</p></li></ul><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/控制流图.png" width="60%"></div><h3 id="程序图的基本元素"><a href="#程序图的基本元素" class="headerlink" title="程序图的基本元素"></a>程序图的基本元素</h3><p>从图论的观点看，它是一个可以用 G = &lt; N , E ＞来表示的有向图。其中：</p><ul><li><p>N一结点；</p></li><li><p>E一有向边，指明程序的流程；</p></li><li><p>包含条件的结点称为判定结点；</p></li></ul><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/判定节点.png" width="60%"></div><h3 id="环路复杂性"><a href="#环路复杂性" class="headerlink" title="环路复杂性"></a>环路复杂性</h3><ul><li><p>V ( G ) ＝流图中区域数（包括图外区域）</p></li><li><p>V ( G ) ＝判定结点数＋ 1</p></li><li><p>V ( G )= E - N + 2</p></li></ul><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/VG计算举例.png" width="30%"></div><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><h3 id="选择程序设计语言"><a href="#选择程序设计语言" class="headerlink" title="选择程序设计语言"></a>选择程序设计语言</h3><p>从软件工程的角度，根据程序设计语言发展的历程，大致分为 4 类：</p><ul><li>第一代语言：从属于机器的语言</li><li>第二代语言：汇编语言</li><li>第三代语言：高级程序设计语言</li><li>第四代语言（4GL）</li></ul><h3 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h3><p>编码风格是指一个人编制程序时所表现出来的特点、习惯、逻辑思路等。良好编码风格包括：</p><ul><li>程序内部应该有很好的文档：如标识符、注释良好，程序文档结构易读易理解。</li><li>数据说明应易于理解和维护</li><li>语句结构尽可能简单直观</li><li>输入输出风格遵守人机界面设计准则</li><li>效率满足用户需求即可</li></ul><h2 id="软件测试的基础"><a href="#软件测试的基础" class="headerlink" title="软件测试的基础"></a>软件测试的基础</h2><ul><li>什么是软件测试？<ul><li>是为了发现错误而执行程序的过程。</li><li>发现错误是为了更正错误，最终得到一个高质量的软件系统。</li></ul></li><li>软件测试的对象：整个软件定义、开发周期的产品</li><li>测试用例：通常指测试数据和预期的输出结果</li></ul><h3 id="软件测试存在的矛盾"><a href="#软件测试存在的矛盾" class="headerlink" title="软件测试存在的矛盾"></a>软件测试存在的矛盾</h3><p>用户希望通过软件测试暴露软件中隐藏的错误和缺陷，以考虑是否可接受该产品。软件开发者希望通过软件测试表明软件产品中不存在错误，已正确地实现了用户的要求。</p><h3 id="软件测试目的"><a href="#软件测试目的" class="headerlink" title="软件测试目的"></a>软件测试目的</h3><ul><li><p>测试是为了发现错误而执行程序的过程</p></li><li><p>好的测试用例是极可能发现至今为止尚未发现的错误的测试方案；</p></li><li><p>成功的测试是发现了至今未发现的错误的测试</p></li></ul><p>总之，测试的目的是以最少的时间和人力，系统地找出软件中潜在的各种错误和缺陷；测试附带的收获是它能证明软件的功能和性能与需求说明相符合。注意：测试不能表明软件中不存在错误，它只能说明软件中存在错误。</p><h3 id="软件测试的准则"><a href="#软件测试的准则" class="headerlink" title="软件测试的准则"></a>软件测试的准则</h3><ul><li>所有测试都能追溯到用户需求</li><li>应该远在测试开始之前就制定出测试计划</li><li>应该把 Pareto原理应用到软件测试中<ul><li>群集现象： 80 ％的错误可能是由 20 ％的模块造成的</li></ul></li><li>从“小规模”测试开始，逐步过渡到“大规模”测试</li><li>穷举测试是不可能的<ul><li>测试只能证明程序有错，不能证明程序没有错误</li></ul></li><li>应由独立的第三方从事测试工作</li></ul><h3 id="测试步骤"><a href="#测试步骤" class="headerlink" title="测试步骤"></a>测试步骤</h3><ul><li><p>单元（模块）测试：检查各各程序模块是否有错误，能发现编码和详细设计的错误。</p></li><li><p>集成测试（子系统和系统测试）：测试模块（子系统）接口，发现软件设计和需求说明的错误。</p></li><li><p>确认（验收）测试：检查软件是否满足用户的需要以及文档资料是否完整、准确</p></li><li><p>平行运行：同时运行新、旧系统</p></li></ul><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/测试步骤.png" width="80%"></div><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="模块接口测试"><a href="#模块接口测试" class="headerlink" title="模块接口测试"></a>模块接口测试</h3><p>在单元测试的开始，应对通过被测模块的数据流进行测试。测试项目：</p><ul><li>调用本模块的输入参数是否正确；</li><li>本模块调用子模块时，输入给子模块的参数是否正确；</li><li>输出给标准函数的参数是否正确；</li><li>全局量的定义和用法在各摸块中是否一致；</li><li>与外部设备的输入输出是否正确</li></ul><h3 id="局部数据结构测试"><a href="#局部数据结构测试" class="headerlink" title="局部数据结构测试"></a>局部数据结构测试</h3><p>测试项目：</p><ul><li>不正确或不一致的数据类型说明</li><li>使用尚未赋值或尚未初始化的变量</li><li>错误的初始值或错误的缺省值</li><li>变量名拼写错或书写错</li><li>不一致的数据类型</li><li>全局数据对模块的影响</li></ul><h3 id="重要的执行通路测试"><a href="#重要的执行通路测试" class="headerlink" title="重要的执行通路测试"></a>重要的执行通路测试</h3><p>白盒测试</p><h3 id="错误处理测试"><a href="#错误处理测试" class="headerlink" title="错误处理测试"></a>错误处理测试</h3><p>着重测试以下可能发生的错误：</p><ul><li>出错的措述是否难以理解</li><li>出错的描述是否能够对错误定位</li><li>显示的错误与实际的错误是否相符</li><li>对错误条件的处理正确与否</li><li>在对错误进行处理之前，错误条件是否已经引起系统的干预等</li></ul><h3 id="边界测试"><a href="#边界测试" class="headerlink" title="边界测试"></a>边界测试</h3><p>重点检查刚好等于、大于或小于边界值的数据;</p><p>对运行时间有要求的模块，还要专门进行关键路径测试，以确定最坏情况下和平均意义下影响模块运行时间的因素。</p><h3 id="代码审查"><a href="#代码审查" class="headerlink" title="代码审查"></a>代码审查</h3><p>人工测试源程序。</p><ul><li><p>参与者：程序的设计者、编写者、测试者没有直接参与系统开发，但有力的程序员。</p></li><li><p>方法：研究设计说明书，一起审查程序代码如何实现设计，从中发现问题。</p></li><li><p>注意：通常代码审查和机器测试结合使用。</p></li></ul><h3 id="计算机测试"><a href="#计算机测试" class="headerlink" title="计算机测试"></a>计算机测试</h3><p>单元测试通常在编码阶段进行。常用机器测试，即通过运行模块发现问题。两个重要概念：</p><ul><li>驱动程序（ driver ) ：相当于被测试模块的“主程序”，接收测试数据，把这些数据传送给被测试的模块，并且输出相关结果。</li><li>存根程序（stub）：代替被测试模块所调用的模块。不需要具有子模块所有功能，但不允许什么事情也不做。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/单元测试的测试环境.png" width="70%"></div><h2 id="集成测试"><a href="#集成测试" class="headerlink" title="集成测试"></a>集成测试</h2><p>在单元测试之后，将模块组装成系统，为发现并排除模块在连接中可能出现的问题，而进行的测试。需要考虑：</p><ul><li><p>模块连接时穿越模块接口的数据是否会 丢失；</p></li><li><p>一个模块对另一个模块是否会产生不利的影响；</p></li><li><p>各子功能组合起来，能 否达到预期要求的父功能</p></li><li><p>全局数据结构是否有问题；</p></li><li><p>单个模块的误差累积起来，是 否会放大至不能接受的程度。</p></li></ul><h3 id="集成测试的两种方式"><a href="#集成测试的两种方式" class="headerlink" title="集成测试的两种方式"></a>集成测试的两种方式</h3><h4 id="非渐增式组装方式"><a href="#非渐增式组装方式" class="headerlink" title="非渐增式组装方式"></a>非渐增式组装方式</h4><p>对每个模块分别进行单元测试，再把所有模块组装成一个完整的系统进行的测试，从而得到要求的软件系统。</p><h4 id="渐增式组装方式"><a href="#渐增式组装方式" class="headerlink" title="渐增式组装方式"></a>渐增式组装方式</h4><p>先对模块进行单元测试，然后将测试后的模块逐步组装成较大的系统；在组装的过程中边连接边测试，以发现连接过程中产生的问题；最后组装成为要求的软件系统。</p><h5 id="自顶向下的渐增方式"><a href="#自顶向下的渐增方式" class="headerlink" title="自顶向下的渐增方式"></a>自顶向下的渐增方式</h5><p>将模块按系统程序结构，沿控制层次自顶向下进行组装。不需要驱动模块，需要存根模块</p><h5 id="自底向上结合的渐增方式"><a href="#自底向上结合的渐增方式" class="headerlink" title="自底向上结合的渐增方式"></a>自底向上结合的渐增方式</h5><p>从程序模块结构最底层的模块开始组装和测试。不再需要存根程序，需要驱动模块。组合策略：</p><ol><li>把低层模块组合成实现某个特定的软件子功能的族；</li><li>用驱动程序协调测试数据的输入和输出;</li><li>对由模块组成的子功能族进行测试;</li><li>去掉驱动程序，没软件结构自下向上移动，把子功能族组合起来形成更大的子功能族。</li></ol><h5 id="混合渐增测试"><a href="#混合渐增测试" class="headerlink" title="混合渐增测试"></a>混合渐增测试</h5><ul><li><p>衍变的自顶向下的增殖测试：</p><ul><li>先对输入／输出模块和引入新算法模块进行测试；</li><li>再自底向上组装成为功能相当完整且相对独立的子系统；</li><li>然后由主模块开始自顶向下进行增殖测试。</li></ul></li><li><p>自底向上 - 自顶向下的增殖测试：</p><ul><li>先对含读操作的子系统自底向上直至根结点模块进行组装和测试；</li><li>再对含写操作的子系统做自顶向下的组装与测试。</li></ul></li></ul><h2 id="确认测试"><a href="#确认测试" class="headerlink" title="确认测试"></a>确认测试</h2><p>又称有效性测试。验证软件的功能、性能及其它特性是否与用户的要求一致。</p><ul><li>确认测试的基础 ：软件需求规格说明书</li><li>确认测试的主要工作：有效性测试与软件配置审查</li><li>主要参与人员：以用户为主</li></ul><h3 id="确认测试范围"><a href="#确认测试范围" class="headerlink" title="确认测试范围"></a>确认测试范围</h3><p>通常采用黑盒测试，验证被测软件是否满足用户需求。</p><ul><li>测试计划：包括测试种类及进度安排；</li><li>测试步骤：描述具体的测试用例</li><li>测试目的：<ul><li>确定软件的特性是否与需求相符；</li><li>所有的文档都是正确且便于使用；</li><li>其它软件需求。</li></ul></li><li>测试结果：<ul><li>与预期的结果相符；</li><li>与预期的结果不符：要提交一份问题报告。</li></ul></li></ul><h3 id="软件配置复查"><a href="#软件配置复查" class="headerlink" title="软件配置复查"></a>软件配置复查</h3><p>目的：</p><ul><li>保证软件配置的所有成分都齐全；</li><li>各方面的质量都符合要求；</li><li>具有维护阶段所必需的细节；</li><li>而且已经编排好分类的目录。</li></ul><p>应当严格遵守用户手册和操作手册中规定的使用步骤，以便检查这些文档资料的完整性和正确性。</p><h3 id="α测试和β测试"><a href="#α测试和β测试" class="headerlink" title="α测试和β测试"></a>α测试和β测试</h3><ul><li><p>α测试：由用户在开发环境下进行的测试。主要评价软件产品的:FLURPS(即功能、局域化、可使用性、可靠性、性能和支持）</p></li><li><p>β测试：由最终用户在实际使用环境下进行的测试，这些用户定期返回有关错误信息给开发者。</p></li></ul><p>注意：只有当α测试达到一定的可靠程度时，才开始β测试。</p><h2 id="自盒测试技术"><a href="#自盒测试技术" class="headerlink" title="自盒测试技术"></a>自盒测试技术</h2><p>白盒测试执行的要求：</p><ul><li>对程序模块的所有独立的执行路径至少测试一次</li><li>对所有的逻辑判定，取“真”与取“假”的两种情况都至少测试一次；</li><li>在循环的边界和运行界限内执行循环体；</li><li>测试内部数据结构的有效性。</li></ul><h3 id="逻辑覆盖"><a href="#逻辑覆盖" class="headerlink" title="逻辑覆盖"></a>逻辑覆盖</h3><h4 id="语句覆盖"><a href="#语句覆盖" class="headerlink" title="语句覆盖"></a>语句覆盖</h4><p>使得每一可执行语句至少执行一次。</p><h4 id="判定覆盖"><a href="#判定覆盖" class="headerlink" title="判定覆盖"></a>判定覆盖</h4><p>运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次。</p><h4 id="条件覆盖"><a href="#条件覆盖" class="headerlink" title="条件覆盖"></a>条件覆盖</h4><p>使得程序中每个判断的每个条件的可能取值至少执行一次。</p><h4 id="判定一条件覆盖"><a href="#判定一条件覆盖" class="headerlink" title="判定一条件覆盖"></a>判定一条件覆盖</h4><p>使得判断中每个条件的所有可能取值至少执行一次，每个判断中的每个分支至少执行一次。即同时满足判断覆盖和条件覆盖。</p><h4 id="条件组合覆盖"><a href="#条件组合覆盖" class="headerlink" title="条件组合覆盖"></a>条件组合覆盖</h4><p>使得每个判断的所有可能的条件取值组合至少执行一次。</p><h4 id="点覆盖"><a href="#点覆盖" class="headerlink" title="点覆盖"></a>点覆盖</h4><p>如果连通图G的子图G′是连通的，而且包含G的所有结点，则称G′是G的点覆盖。点覆盖标准和语句覆盖标准是相同的。</p><h4 id="边覆盖"><a href="#边覆盖" class="headerlink" title="边覆盖"></a>边覆盖</h4><p>要求选取足够多测试数据，使得程序执行路径至少经过流图中每条边一次。通常边覆盖和判定覆盖是一致的。</p><h4 id="路径覆盖"><a href="#路径覆盖" class="headerlink" title="路径覆盖"></a>路径覆盖</h4><p>覆盖程序中所有可能的路径。</p><h3 id="控制结构测试"><a href="#控制结构测试" class="headerlink" title="控制结构测试"></a>控制结构测试</h3><h4 id="基本路径测试"><a href="#基本路径测试" class="headerlink" title="基本路径测试"></a>基本路径测试</h4><ul><li><p>以环形复杂度为基础，导出基本可执行路径集合，设计测试用例的方法。</p></li><li><p>测试用例要保证程序的每个可执行语句至少执行一次。</p></li></ul><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>由程序流程图导出程序控制流图，并计算其环路复杂度：</li><li>确定程序的独立路径<ul><li>什么是独立路径？流图中，一条独立路径是至少包含一条在其它独立路径中从未有过的边的路径。独立路径条数是确保程序中，每个可执行语句至少能被执行一次所必需的测试用例数目的上界。独立路径条数＝程序环路复杂性 V ( G )</li></ul></li></ol><h2 id="黑盒测试技术"><a href="#黑盒测试技术" class="headerlink" title="黑盒测试技术"></a>黑盒测试技术</h2><p>黑盒测试主要是为了发现以下错误：</p><ul><li>是否有不正确或遗漏了的功能？</li><li>能否正确地接受输入？能否正确的输出结果？</li><li>是否有数据结构错误或外部数据库访问错误？</li><li>性能上是否能够满足要求？</li><li>是否有初始化或终止性错误？</li></ul><p>几种黑盒测试技术：</p><ul><li>等价类划分</li><li>边界值分析</li><li>错误推测法</li><li>因果图</li></ul><h2 id="等价划分"><a href="#等价划分" class="headerlink" title="等价划分"></a>等价划分</h2><p>把所有可能的输入数据（包括有效或无效的），划分成若干数据类（等价类），然后从每个数据类中选取少数有代表性的数据做为测试用例。这种方法完全不考虑程序的内部结构，只依据程序的规格说明来设计测试用例。</p><h3 id="步骤1：划分等价类"><a href="#步骤1：划分等价类" class="headerlink" title="步骤1：划分等价类"></a>步骤1：划分等价类</h3><p>等价类是指输入数据的子集合。在该子集合中，各输入数据对于发现程序中的错误都是等效的。根据程序功能说明，确定有效和无效的等价类</p><h4 id="等价类划分原则"><a href="#等价类划分原则" class="headerlink" title="等价类划分原则"></a>等价类划分原则</h4><ul><li>若规定了取值范围，或输入值的个数，则可以确立一个有效等价类和两个无效等价类。</li><li>如果规定了输入数据的一组值，而且程序要对每种输入数据分别处理，则可为每种输入值确立一个有效等价类，此外针对这组值确立一个无效等价类，它是所有不允许的输入值的集合。</li><li>若规定了输入值的集合，或者是规定了“必须如何”的条件，则可确立一个有效等价类和一个无效等价类。</li><li>如果规定输入数据为整型，则可划分出正整、零和负整数三个有效类，其他数据为无效类</li><li>如果程序处理对象是表格，则应使用空表、含一项和多项的表。</li><li>如果确知，已划分的等价类中各元素在程序中的处理方式不同，则应将此等价类进一步划分成更小的等价类。</li></ul><h3 id="步骤2：根据等价类设计测试用例"><a href="#步骤2：根据等价类设计测试用例" class="headerlink" title="步骤2：根据等价类设计测试用例"></a>步骤2：根据等价类设计测试用例</h3><p>在确立了等价类之后，建立等价类表，列出所有划分出的等价类。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/等价类表.png"></div><h4 id="测试用例的选择原则"><a href="#测试用例的选择原则" class="headerlink" title="测试用例的选择原则"></a>测试用例的选择原则</h4><ul><li><p>为每一个等价类规定一个唯一编号；</p></li><li><p>设计一个新的测试用例，使其<strong>尽可能多地覆盖</strong>尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止；</p></li><li>设计一个新的测试用例，使其<strong>仅覆盖一个尚未被覆盖</strong>的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。</li></ul><h3 id="某报表处理系统"><a href="#某报表处理系统" class="headerlink" title="某报表处理系统"></a>某报表处理系统</h3><p>系统规定日期由年、月的 6 位数字字符组成，前 4 位代表年，后两位代表月。设日期限制在 1990 年 1 月至 1999 年 12 月，即系统只能对该段时期内的报表进行处理。如果用户输入的日期不在此范围内，则显示输入错误。现用等价类划分法设计测试用例，来测试程序的“日期检查功能”。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/报表处理系统等价类表.png" width="60%"></div><h4 id="为合理等价类设计测试用例"><a href="#为合理等价类设计测试用例" class="headerlink" title="为合理等价类设计测试用例"></a>为合理等价类设计测试用例</h4><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/报表合理等价类.png" width="70%"></div><h4 id="不合理等价类设计测试用例"><a href="#不合理等价类设计测试用例" class="headerlink" title="不合理等价类设计测试用例"></a>不合理等价类设计测试用例</h4><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/报表不合理等价类.png" width="50%"></div><h2 id="边界值分析"><a href="#边界值分析" class="headerlink" title="边界值分析"></a>边界值分析</h2><p>边界是指，对于输入和输出等价类而言，稍高和稍低于其边界值的一些特定情况。经验得知，大量的错误是发生在输入或输出范围的边界上，而不是在输入范围的内部。边界值分析方法思想：确定边界之后，选取正好等于、刚刚大于或刚刚小于边界的值做为测试数据，而不是选取等价类中典型值或任意值做为测试数据。通常总是与等价划分技术联合使用，是等价划分方法的补充。</p><p>假设一个数据库产品规范要求该产品能够处理从1到1000中间的任何数量的记录。请首先为其划分等价类，并利用等价类划分和边界值分析技术为其设计测试用例，并说明每个测试用例属于某等价类成员还是属于边界值或是邻接边界值。</p><h3 id="等价类"><a href="#等价类" class="headerlink" title="等价类"></a>等价类</h3><ul><li>等价类1：少于1个记录</li><li>等价类2：1到1000个记录</li><li>等价类3：多于1000个记录</li></ul><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><ul><li>测试用例1：0个记录 //等价类1成员且邻接边界值</li><li>测试用例2：1个记录 //边界值</li><li>测试用例3：2个记录 //邻接边界值</li><li>测试用例4：100个记录 //等价类2的成员</li><li>测试用例5：999个记录 //邻接边界值</li><li>测试用例6：1000个记录 //边界值</li><li>测试用例7：1001个记录 //等价类3成员且邻接边界值</li></ul><h2 id="因果图"><a href="#因果图" class="headerlink" title="因果图"></a>因果图</h2><p>因果图是借助图形来设计测试用例的一种系统方法。它适用于被测程序具有多种输入条件，程序的输出又依赖于输入条件的各种组合的情况。因果图是一种简化了的逻辑图，它能直观地表明程序输入条件（原因）和输出动作（结果）之间的相互关系。</p><h3 id="利用因果图产生测试用例的基本步骤"><a href="#利用因果图产生测试用例的基本步骤" class="headerlink" title="利用因果图产生测试用例的基本步骤"></a>利用因果图产生测试用例的基本步骤</h3><ol><li>分析软件规格说明书中，哪些是原因（即输入条件或输入条件的等价类），哪些是结果（即输出条件）并给每个原因和结果赋予一个标识。</li><li>分析软件规格说明书中所描述的语义，找出原因与结果之间、原因与原因之间对应的是什么关系？根据这些关系画出因果图。</li><li>由于语法或环境的限制，有些原因与原因之间、原因与结果之间的组合情况不可能出现。为表明这些特殊情况，在因果图上用一些记号标明约束或限制条件。</li><li>把因果图转换为判断表</li><li>把判断表的每一列拿出来作为依据，设计测试用例。</li></ol><h3 id="在因果图中出现的基本符号"><a href="#在因果图中出现的基本符号" class="headerlink" title="在因果图中出现的基本符号"></a>在因果图中出现的基本符号</h3><p>通常在因果图中用 Ci 来表示原因，用Ei表示结果其基本符号如下图所示。其中各结点表示状态，可取值为 “0”或“1”。“0”表示某状态不出现，“1”表示某状态出现。主要的原因和结果之间的关系如下:</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/因果图基本符号.png"></div><ul><li>恒等：表示原因与结果之间是一对一的对应关系。若原因出现，则结果出现。若原因不出现，则结果也不出现。</li><li>非：表示原因与结果之间的一种否定关系。若原因出现，则结果不出现。若原因不出现，反而结果出现。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/因果图基本符号2.png"></div><ul><li>或：表示若几个原因中有一个出现，则结果出现，而当这几个原因都不出现时，结果才不出现。</li><li>与：表示若几个原因都出现，则结果才出现若几个原因中有一个不出现，结果就不出现。</li></ul><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><p>设有一个处理单价为5角钱饮料自动售货机其规格说明为，若投入5角钱或1元钱的硬币 ，再按下橙汁或啤酒按钮，则相应的饮料就送出来；若售货机 没有零钱找，则一个显示零钱已找完的红灯亮，这时在投入1元硬币并按下按钮后，饮料不送出来而且1元硬币也退出来;若有零钱找，则应显示零钱找完的红灯灭， 在送出饮料的同时退还5角硬币。</p><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">原因</th><th style="text-align:center"><strong>序号</strong></th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">售货机有零钱找</td><td style="text-align:center">2.1</td><td style="text-align:center">售货机零钱找完灯亮</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">投入1元硬币</td><td style="text-align:center">2.2</td><td style="text-align:center">退还1元硬币</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">投入5角硬币</td><td style="text-align:center">2.3</td><td style="text-align:center">退还5角硬币</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">按下橙汁按钮</td><td style="text-align:center">2.4</td><td style="text-align:center">送出橙汁饮料</td></tr><tr><td style="text-align:center">5</td><td style="text-align:center">按下啤酒按钮</td><td style="text-align:center">2.5</td><td style="text-align:center">送出啤酒饮料</td></tr></tbody></table><table><thead><tr><th style="text-align:center">序号</th><th style="text-align:center">中间结点</th></tr></thead><tbody><tr><td style="text-align:center">11</td><td style="text-align:center">投入1元硬币且按下饮料按钮</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">按下橙汁或啤酒的按钮</td></tr><tr><td style="text-align:center">13</td><td style="text-align:center">应当找5角零钱并且售货机有零钱找</td></tr><tr><td style="text-align:center">14</td><td style="text-align:center">钱已付请</td></tr></tbody></table><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/因果图例.png"></div><h2 id="软件维护的定义"><a href="#软件维护的定义" class="headerlink" title="软件维护的定义"></a>软件维护的定义</h2><p>软件维护是指在软件运行或维护阶段对软件产品所进行的修改。分为四类：</p><h3 id="改正性维护"><a href="#改正性维护" class="headerlink" title="改正性维护"></a>改正性维护</h3><p>在软件交付使用后，由于开发时测试得不彻底或不完全，在运行阶段会暴露一些开发时未能测试出来的错误。为了识别和纠正软件错误，改正软件性能上的缺陷，避免实施中的错误使用，应当进行的诊断和改正错误的过程，这就是改正性维护。</p><h3 id="适应性维护"><a href="#适应性维护" class="headerlink" title="适应性维护"></a>适应性维护</h3><p>随着计算机技术的飞速发展和更新换代，软件系统所需的外部环境或数据环境可能会更新和升级。为了使软件系统适应这种变化，需要对软件进行相应的修改，这种维护活动称为适应性维护。</p><h3 id="扩充与完善性维护"><a href="#扩充与完善性维护" class="headerlink" title="扩充与完善性维护"></a>扩充与完善性维护</h3><p>在软件的使用过程中，用户往往会对软件提出新的功能与性能要求。为了满足这些要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。这种情况下进行的维护活动叫做完善性维护。</p><h3 id="预防性维护"><a href="#预防性维护" class="headerlink" title="预防性维护"></a>预防性维护</h3><p>采用先进的软件工程方法，对需要维护的软件或软件中的某一部分重新进行设计、编制和测试。</p><div align="center"><img src="//isjinhao.github.io/2019/软件工程和项目管理/软件维护比例.png" width="70%"></div><h2 id="软件的可维护性"><a href="#软件的可维护性" class="headerlink" title="软件的可维护性"></a>软件的可维护性</h2><p>指纠正软件系统出现的错误和缺陷，以及为满足新的要求进行修改、扩充或压缩的容易程度。</p><p>衡量软件质量的几个主要质量特性：</p><ul><li><p>可理解性：人们通过阅读源代码和相关文档，了解程序功能及其如何运行的容易程度。</p></li><li><p>可靠性：表明一个程序按照用户的要求和设计目标，在给定的一段时间内正确执行的概率。</p></li><li>可测试性：表明诊断和测试的容易程度。</li><li>可修改性：表明程序容易修改的程度。</li><li>可移植性：表明把程序从一种计算环境转移到另一种计算环境的难易程度。</li><li>可重用性：指同一个软件（或软件成份）不做修改或稍加改动，就可以在不同环境中多次重复使用。</li></ul><h2 id="软件再工程过程"><a href="#软件再工程过程" class="headerlink" title="软件再工程过程"></a>软件再工程过程</h2><p>预防性维护也称为软件再工程</p><h3 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h3><p>软件的逆向工程是分析程序，力图在比源代码更高的抽象层次上建立程序表示的过程，是一个设计恢复的过程，逆向工程工具可以从已有的程序中抽取数据结构、体系结构和程序设计信息。</p><h3 id="正向工程"><a href="#正向工程" class="headerlink" title="正向工程"></a>正向工程</h3><p>应用现代软件工程的概念、原理、技术和方法，重新开发现有的某个应用系统。</p><h3 id="软件再工程"><a href="#软件再工程" class="headerlink" title="软件再工程"></a>软件再工程</h3><p>软件再工程是一个工程过程，它将逆向工程、重构和正向工程组合起来，旨在对现存的大量软件系统进行挖掘、整理，重新获得设计信息，用这些信息改建或重构现有的系统，以改进它的综合质量；或者得到有用的软件构件，对已有软件构件进行维护以延长其生存期。再工程的基础是系统理解，包括对运行系统、源代码、设计、分析、文档等的全面理解。但在很多情况下，由于各类文档的丢失，只能对源代码进行理解，即程序理解。</p><p>典型的软件再工程过程模型定义了库存目录分析、文档重构、逆向工程、代码重构、数据重构和正向工程6类活动。</p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-如果您有什么建议，推荐使用右下角的DaoVoice与我联系-</div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读！-------------</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div></div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/weichatpay.png" alt="ISJINHAO 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.jpg" alt="ISJINHAO 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/软件项目管理/" rel="tag"># 软件项目管理</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/运输层/" rel="next" title="运输层"><i class="fa fa-chevron-left"></i> 运输层</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/软件开发文档用图/" rel="prev" title="软件开发文档用图">软件开发文档用图 <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80MjQ4NC8xOTAzMQ=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="ISJINHAO"><p class="site-author-name" itemprop="name">ISJINHAO</p><p class="site-description motion-element" itemprop="description">Living & Working</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">120</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">31</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">60</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/isjinhao" title="GitHub &rarr; https://github.com/isjinhao" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_38206090" title="CSDN &rarr; https://blog.csdn.net/qq_38206090" rel="noopener" target="_blank"><i class="fa fa-fw fa-heartbeat"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:isjinhao@163.com" title="E-Mail &rarr; mailto:isjinhao@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://http://59.110.143.226/qz/0.html" title="http://http://59.110.143.226/qz/0.html" rel="noopener" target="_blank">求职（Java后台开发）</a></li><li class="links-of-blogroll-item"><a href="http://http://59.110.143.226/Sharing-Your-Story" title="http://http://59.110.143.226/Sharing-Your-Story" rel="noopener" target="_blank">博客涉及到的软件</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#软件危机"><span class="nav-number">1.</span> <span class="nav-text">软件危机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#产生软件危机的原因"><span class="nav-number">1.1.</span> <span class="nav-text">产生软件危机的原因</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#软件本身的特点"><span class="nav-number">1.1.1.</span> <span class="nav-text">软件本身的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#软件开发与维护的方法不正确"><span class="nav-number">1.1.2.</span> <span class="nav-text">软件开发与维护的方法不正确</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#其他产生软件危机的原因"><span class="nav-number">1.1.3.</span> <span class="nav-text">其他产生软件危机的原因</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件的本质特性"><span class="nav-number">2.</span> <span class="nav-text">软件的本质特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件开发面临的挑战"><span class="nav-number">3.</span> <span class="nav-text">软件开发面临的挑战</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#消除软件危机的途径"><span class="nav-number">4.</span> <span class="nav-text">消除软件危机的途径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件开发的误区"><span class="nav-number">5.</span> <span class="nav-text">软件开发的误区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件的定义"><span class="nav-number">6.</span> <span class="nav-text">软件的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件工程"><span class="nav-number">7.</span> <span class="nav-text">软件工程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#另一个角度的看软件工程本质特性"><span class="nav-number">8.</span> <span class="nav-text">另一个角度的看软件工程本质特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件工程的基本原理"><span class="nav-number">9.</span> <span class="nav-text">软件工程的基本原理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件工程方法学"><span class="nav-number">10.</span> <span class="nav-text">软件工程方法学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#三要素"><span class="nav-number">10.1.</span> <span class="nav-text">三要素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#软件工程方法"><span class="nav-number">10.1.1.</span> <span class="nav-text">软件工程方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件工程方法学思想"><span class="nav-number">10.2.</span> <span class="nav-text">软件工程方法学思想</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#传统方法学"><span class="nav-number">10.2.1.</span> <span class="nav-text">传统方法学</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#优点"><span class="nav-number">10.2.1.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缺点"><span class="nav-number">10.2.1.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#面向对象方法学"><span class="nav-number">10.2.2.</span> <span class="nav-text">面向对象方法学</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件生命周期"><span class="nav-number">11.</span> <span class="nav-text">软件生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#软件定义时期"><span class="nav-number">11.1.</span> <span class="nav-text">软件定义时期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#问题定义阶段"><span class="nav-number">11.1.1.</span> <span class="nav-text">问题定义阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#可行性研究阶段"><span class="nav-number">11.1.2.</span> <span class="nav-text">可行性研究阶段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#需求分析"><span class="nav-number">11.1.3.</span> <span class="nav-text">需求分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件开发时期"><span class="nav-number">11.2.</span> <span class="nav-text">软件开发时期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#总体设计（概要设计）"><span class="nav-number">11.2.1.</span> <span class="nav-text">总体设计（概要设计）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#详细设计（模块设计）"><span class="nav-number">11.2.2.</span> <span class="nav-text">详细设计（模块设计）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#程序编写（Coding-Programming）"><span class="nav-number">11.2.3.</span> <span class="nav-text">程序编写（Coding, Programming）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#软件测试（Testing）"><span class="nav-number">11.2.4.</span> <span class="nav-text">软件测试（Testing）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行维护（软件维护）时期"><span class="nav-number">11.3.</span> <span class="nav-text">运行维护（软件维护）时期</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件过程"><span class="nav-number">12.</span> <span class="nav-text">软件过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件生命周期模型"><span class="nav-number">13.</span> <span class="nav-text">软件生命周期模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#瀑布模型"><span class="nav-number">13.1.</span> <span class="nav-text">瀑布模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#特点"><span class="nav-number">13.1.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-1"><span class="nav-number">13.1.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-1"><span class="nav-number">13.1.3.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#快速原型模型"><span class="nav-number">13.2.</span> <span class="nav-text">快速原型模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-2"><span class="nav-number">13.2.1.</span> <span class="nav-text">优点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#增量（渐增）模型"><span class="nav-number">13.3.</span> <span class="nav-text">增量（渐增）模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#注意事项"><span class="nav-number">13.3.1.</span> <span class="nav-text">注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-3"><span class="nav-number">13.3.2.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-2"><span class="nav-number">13.3.3.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#一种风险更大的增量模型"><span class="nav-number">13.3.4.</span> <span class="nav-text">一种风险更大的增量模型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#螺旋模型"><span class="nav-number">13.4.</span> <span class="nav-text">螺旋模型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#优点-4"><span class="nav-number">13.4.1.</span> <span class="nav-text">优点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺点-3"><span class="nav-number">13.4.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#各种模型的比较"><span class="nav-number">13.5.</span> <span class="nav-text">各种模型的比较</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件工程工具"><span class="nav-number">14.</span> <span class="nav-text">软件工程工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件开发的基本策略"><span class="nav-number">15.</span> <span class="nav-text">软件开发的基本策略</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#软件复用"><span class="nav-number">15.1.</span> <span class="nav-text">软件复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分而治之"><span class="nav-number">15.2.</span> <span class="nav-text">分而治之</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逐步演进"><span class="nav-number">15.3.</span> <span class="nav-text">逐步演进</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#优化折中"><span class="nav-number">15.4.</span> <span class="nav-text">优化折中</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ISO9126-质量模型"><span class="nav-number">16.</span> <span class="nav-text">ISO9126 质量模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#功能性"><span class="nav-number">16.1.</span> <span class="nav-text">功能性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可靠性"><span class="nav-number">16.2.</span> <span class="nav-text">可靠性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#易用性"><span class="nav-number">16.3.</span> <span class="nav-text">易用性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#效率"><span class="nav-number">16.4.</span> <span class="nav-text">效率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可维护性"><span class="nav-number">16.5.</span> <span class="nav-text">可维护性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可移植性"><span class="nav-number">16.6.</span> <span class="nav-text">可移植性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可行性研究的目的"><span class="nav-number">17.</span> <span class="nav-text">可行性研究的目的</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可行性研究的基本内容"><span class="nav-number">18.</span> <span class="nav-text">可行性研究的基本内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#技术可行性"><span class="nav-number">18.1.</span> <span class="nav-text">技术可行性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#经济可行性"><span class="nav-number">18.2.</span> <span class="nav-text">经济可行性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作可行性"><span class="nav-number">18.3.</span> <span class="nav-text">操作可行性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可行性研究的任务"><span class="nav-number">19.</span> <span class="nav-text">可行性研究的任务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#具体模型到逻辑模型举例"><span class="nav-number">19.1.</span> <span class="nav-text">具体模型到逻辑模型举例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可行性研究的定义"><span class="nav-number">20.</span> <span class="nav-text">可行性研究的定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#可行性研究报告功能"><span class="nav-number">21.</span> <span class="nav-text">可行性研究报告功能</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成本／效益分析"><span class="nav-number">22.</span> <span class="nav-text">成本／效益分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#成本估计"><span class="nav-number">22.1.</span> <span class="nav-text">成本估计</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#开发成本"><span class="nav-number">22.1.1.</span> <span class="nav-text">开发成本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运行成本"><span class="nav-number">22.1.2.</span> <span class="nav-text">运行成本</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需求定义"><span class="nav-number">23.</span> <span class="nav-text">需求定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需求的内容"><span class="nav-number">24.</span> <span class="nav-text">需求的内容</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需求内容来源"><span class="nav-number">25.</span> <span class="nav-text">需求内容来源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需求分析-1"><span class="nav-number">26.</span> <span class="nav-text">需求分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#需求分析的任务"><span class="nav-number">26.1.</span> <span class="nav-text">需求分析的任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#确定对系统的综合要求"><span class="nav-number">26.2.</span> <span class="nav-text">确定对系统的综合要求</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分析建模"><span class="nav-number">27.</span> <span class="nav-text">分析建模</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据词典"><span class="nav-number">28.</span> <span class="nav-text">数据词典</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#定义数据的方法"><span class="nav-number">28.1.</span> <span class="nav-text">定义数据的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#举例"><span class="nav-number">28.1.1.</span> <span class="nav-text">举例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DD定义数据流"><span class="nav-number">28.2.</span> <span class="nav-text">DD定义数据流</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据流定义"><span class="nav-number">28.2.1.</span> <span class="nav-text">数据流定义</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DD定义数据元素"><span class="nav-number">28.3.</span> <span class="nav-text">DD定义数据元素</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#举例-1"><span class="nav-number">28.3.1.</span> <span class="nav-text">举例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DD定义数据存储"><span class="nav-number">28.4.</span> <span class="nav-text">DD定义数据存储</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#举例-2"><span class="nav-number">28.4.1.</span> <span class="nav-text">举例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DD定义数据处理"><span class="nav-number">28.5.</span> <span class="nav-text">DD定义数据处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#例子"><span class="nav-number">28.5.1.</span> <span class="nav-text">例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件设计的目标"><span class="nav-number">29.</span> <span class="nav-text">软件设计的目标</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#软件设计的两个阶段"><span class="nav-number">29.1.</span> <span class="nav-text">软件设计的两个阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#第一阶段：概要设计（总体设计）"><span class="nav-number">29.1.1.</span> <span class="nav-text">第一阶段：概要设计（总体设计）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#第二阶段：详细设计（过程设计）"><span class="nav-number">29.1.2.</span> <span class="nav-text">第二阶段：详细设计（过程设计）</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SA和SD"><span class="nav-number">30.</span> <span class="nav-text">SA和SD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概要设计的任务"><span class="nav-number">31.</span> <span class="nav-text">概要设计的任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件设计的过程"><span class="nav-number">32.</span> <span class="nav-text">软件设计的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件设计的原理"><span class="nav-number">33.</span> <span class="nav-text">软件设计的原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模块化"><span class="nav-number">33.1.</span> <span class="nav-text">模块化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自顶向下，逐步求精的基本思想"><span class="nav-number">33.2.</span> <span class="nav-text">自顶向下，逐步求精的基本思想</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#模块独立"><span class="nav-number">34.</span> <span class="nav-text">模块独立</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#耦合性"><span class="nav-number">34.1.</span> <span class="nav-text">耦合性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#无直接藕合"><span class="nav-number">34.1.1.</span> <span class="nav-text">无直接藕合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据耦合"><span class="nav-number">34.1.2.</span> <span class="nav-text">数据耦合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#控制藕合"><span class="nav-number">34.1.3.</span> <span class="nav-text">控制藕合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特征耦合"><span class="nav-number">34.1.4.</span> <span class="nav-text">特征耦合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#公共环境耦合"><span class="nav-number">34.1.5.</span> <span class="nav-text">公共环境耦合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内容耦合"><span class="nav-number">34.1.6.</span> <span class="nav-text">内容耦合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#控制耦合改为数据耦合"><span class="nav-number">34.1.7.</span> <span class="nav-text">控制耦合改为数据耦合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#特征耦合修改为数据耦合"><span class="nav-number">34.1.8.</span> <span class="nav-text">特征耦合修改为数据耦合</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内聚性"><span class="nav-number">34.2.</span> <span class="nav-text">内聚性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#巧合内聚"><span class="nav-number">34.2.1.</span> <span class="nav-text">巧合内聚</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#逻辑内聚"><span class="nav-number">34.2.2.</span> <span class="nav-text">逻辑内聚</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时间内聚"><span class="nav-number">34.2.3.</span> <span class="nav-text">时间内聚</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#过程内聚"><span class="nav-number">34.2.4.</span> <span class="nav-text">过程内聚</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通信内聚"><span class="nav-number">34.2.5.</span> <span class="nav-text">通信内聚</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#顺序内聚"><span class="nav-number">34.2.6.</span> <span class="nav-text">顺序内聚</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#功能内聚"><span class="nav-number">34.2.7.</span> <span class="nav-text">功能内聚</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#启发规则"><span class="nav-number">34.3.</span> <span class="nav-text">启发规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#描绘软件结构的图形具"><span class="nav-number">35.</span> <span class="nav-text">描绘软件结构的图形具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#层次图和-HIPO-图"><span class="nav-number">35.1.</span> <span class="nav-text">层次图和 HIPO 图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构图"><span class="nav-number">35.2.</span> <span class="nav-text">结构图</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#结构程序设计"><span class="nav-number">36.</span> <span class="nav-text">结构程序设计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SP主要原则"><span class="nav-number">36.1.</span> <span class="nav-text">SP主要原则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#五种基本的结构化控制结构"><span class="nav-number">36.2.</span> <span class="nav-text">五种基本的结构化控制结构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#控制流图"><span class="nav-number">37.</span> <span class="nav-text">控制流图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#程序图的基本元素"><span class="nav-number">37.1.</span> <span class="nav-text">程序图的基本元素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#环路复杂性"><span class="nav-number">37.2.</span> <span class="nav-text">环路复杂性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#编码"><span class="nav-number">38.</span> <span class="nav-text">编码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#选择程序设计语言"><span class="nav-number">38.1.</span> <span class="nav-text">选择程序设计语言</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编码风格"><span class="nav-number">38.2.</span> <span class="nav-text">编码风格</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件测试的基础"><span class="nav-number">39.</span> <span class="nav-text">软件测试的基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#软件测试存在的矛盾"><span class="nav-number">39.1.</span> <span class="nav-text">软件测试存在的矛盾</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件测试目的"><span class="nav-number">39.2.</span> <span class="nav-text">软件测试目的</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件测试的准则"><span class="nav-number">39.3.</span> <span class="nav-text">软件测试的准则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试步骤"><span class="nav-number">39.4.</span> <span class="nav-text">测试步骤</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#单元测试"><span class="nav-number">40.</span> <span class="nav-text">单元测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#模块接口测试"><span class="nav-number">40.1.</span> <span class="nav-text">模块接口测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#局部数据结构测试"><span class="nav-number">40.2.</span> <span class="nav-text">局部数据结构测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重要的执行通路测试"><span class="nav-number">40.3.</span> <span class="nav-text">重要的执行通路测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#错误处理测试"><span class="nav-number">40.4.</span> <span class="nav-text">错误处理测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#边界测试"><span class="nav-number">40.5.</span> <span class="nav-text">边界测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#代码审查"><span class="nav-number">40.6.</span> <span class="nav-text">代码审查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#计算机测试"><span class="nav-number">40.7.</span> <span class="nav-text">计算机测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#集成测试"><span class="nav-number">41.</span> <span class="nav-text">集成测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#集成测试的两种方式"><span class="nav-number">41.1.</span> <span class="nav-text">集成测试的两种方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非渐增式组装方式"><span class="nav-number">41.1.1.</span> <span class="nav-text">非渐增式组装方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#渐增式组装方式"><span class="nav-number">41.1.2.</span> <span class="nav-text">渐增式组装方式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#自顶向下的渐增方式"><span class="nav-number">41.1.2.1.</span> <span class="nav-text">自顶向下的渐增方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#自底向上结合的渐增方式"><span class="nav-number">41.1.2.2.</span> <span class="nav-text">自底向上结合的渐增方式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#混合渐增测试"><span class="nav-number">41.1.2.3.</span> <span class="nav-text">混合渐增测试</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#确认测试"><span class="nav-number">42.</span> <span class="nav-text">确认测试</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#确认测试范围"><span class="nav-number">42.1.</span> <span class="nav-text">确认测试范围</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件配置复查"><span class="nav-number">42.2.</span> <span class="nav-text">软件配置复查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#α测试和β测试"><span class="nav-number">42.3.</span> <span class="nav-text">α测试和β测试</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自盒测试技术"><span class="nav-number">43.</span> <span class="nav-text">自盒测试技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑覆盖"><span class="nav-number">43.1.</span> <span class="nav-text">逻辑覆盖</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#语句覆盖"><span class="nav-number">43.1.1.</span> <span class="nav-text">语句覆盖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判定覆盖"><span class="nav-number">43.1.2.</span> <span class="nav-text">判定覆盖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#条件覆盖"><span class="nav-number">43.1.3.</span> <span class="nav-text">条件覆盖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#判定一条件覆盖"><span class="nav-number">43.1.4.</span> <span class="nav-text">判定一条件覆盖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#条件组合覆盖"><span class="nav-number">43.1.5.</span> <span class="nav-text">条件组合覆盖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#点覆盖"><span class="nav-number">43.1.6.</span> <span class="nav-text">点覆盖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#边覆盖"><span class="nav-number">43.1.7.</span> <span class="nav-text">边覆盖</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#路径覆盖"><span class="nav-number">43.1.8.</span> <span class="nav-text">路径覆盖</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#控制结构测试"><span class="nav-number">43.2.</span> <span class="nav-text">控制结构测试</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基本路径测试"><span class="nav-number">43.2.1.</span> <span class="nav-text">基本路径测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#步骤"><span class="nav-number">43.2.2.</span> <span class="nav-text">步骤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#黑盒测试技术"><span class="nav-number">44.</span> <span class="nav-text">黑盒测试技术</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#等价划分"><span class="nav-number">45.</span> <span class="nav-text">等价划分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤1：划分等价类"><span class="nav-number">45.1.</span> <span class="nav-text">步骤1：划分等价类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#等价类划分原则"><span class="nav-number">45.1.1.</span> <span class="nav-text">等价类划分原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#步骤2：根据等价类设计测试用例"><span class="nav-number">45.2.</span> <span class="nav-text">步骤2：根据等价类设计测试用例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#测试用例的选择原则"><span class="nav-number">45.2.1.</span> <span class="nav-text">测试用例的选择原则</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#某报表处理系统"><span class="nav-number">45.3.</span> <span class="nav-text">某报表处理系统</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为合理等价类设计测试用例"><span class="nav-number">45.3.1.</span> <span class="nav-text">为合理等价类设计测试用例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#不合理等价类设计测试用例"><span class="nav-number">45.3.2.</span> <span class="nav-text">不合理等价类设计测试用例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#边界值分析"><span class="nav-number">46.</span> <span class="nav-text">边界值分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#等价类"><span class="nav-number">46.1.</span> <span class="nav-text">等价类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试用例"><span class="nav-number">46.2.</span> <span class="nav-text">测试用例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#因果图"><span class="nav-number">47.</span> <span class="nav-text">因果图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#利用因果图产生测试用例的基本步骤"><span class="nav-number">47.1.</span> <span class="nav-text">利用因果图产生测试用例的基本步骤</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#在因果图中出现的基本符号"><span class="nav-number">47.2.</span> <span class="nav-text">在因果图中出现的基本符号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#例"><span class="nav-number">47.3.</span> <span class="nav-text">例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件维护的定义"><span class="nav-number">48.</span> <span class="nav-text">软件维护的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#改正性维护"><span class="nav-number">48.1.</span> <span class="nav-text">改正性维护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#适应性维护"><span class="nav-number">48.2.</span> <span class="nav-text">适应性维护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩充与完善性维护"><span class="nav-number">48.3.</span> <span class="nav-text">扩充与完善性维护</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预防性维护"><span class="nav-number">48.4.</span> <span class="nav-text">预防性维护</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件的可维护性"><span class="nav-number">49.</span> <span class="nav-text">软件的可维护性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#软件再工程过程"><span class="nav-number">50.</span> <span class="nav-text">软件再工程过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逆向工程"><span class="nav-number">50.1.</span> <span class="nav-text">逆向工程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#正向工程"><span class="nav-number">50.2.</span> <span class="nav-text">正向工程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#软件再工程"><span class="nav-number">50.3.</span> <span class="nav-text">软件再工程</span></a></li></ol></li></ol></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">ISJINHAO</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">1.2m</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">18:33</span></div><div class="powered-by"><i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv"> 本站访客数：<span id="busuanzi_value_site_uv"></span></span></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">| 博客全站共489.3k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/src/utils.js?v=6.7.0"></script><script src="/js/src/motion.js?v=6.7.0"></script><script src="/js/src/schemes/muse.js?v=6.7.0"></script><script src="/js/src/scrollspy.js?v=6.7.0"></script><script src="/js/src/post-details.js?v=6.7.0"></script><script src="/js/src/bootstrap.js?v=6.7.0"></script><script>window.livereOptions={refer:"2019/软件工程和项目管理/"},function(e,t){var n,r=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,r.parentNode.insertBefore(n,r))}(document,"script")</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: "AMS"
      }
    }
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });</script><script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><style>.MathJax_Display{overflow:auto hidden}</style></body></html><!-- rebuild by neat -->