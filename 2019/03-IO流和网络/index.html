<!-- build time:Wed Aug 28 2019 15:57:25 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>.pace .pace-progress{background:#1E92FB;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1E92FB,0 0 5px #1E92FB}.pace .pace-activity{border-top-color:#1E92FB;border-left-color:#1E92FB}</style><meta name="theme-color" content="#222"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=6.7.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon16x16.ico?v=6.7.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32x32.ico?v=6.7.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16x16.ico?v=6.7.0"><link rel="mask-icon" href="/images/favicon16x16.ico?v=6.7.0" color="#222"><link rel="manifest" href="/images/favicon16x16.ico"><meta name="msapplication-config" content="/images/favicon16x16.ico"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"6.7.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"28dbf854"}),daovoice("update")</script><meta name="description" content="IO流构造方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001"><meta name="keywords" content="应届求职复习,面试"><meta property="og:type" content="article"><meta property="og:title" content="03-IO流和网络"><meta property="og:url" content="https://isjinhao.github.io/2019/03-IO流和网络/index.html"><meta property="og:site_name" content="ISJINHAO"><meta property="og:description" content="IO流构造方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/2019-07-15_000310.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/信道.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/交换机.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/分组.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/计算机网络基本原则.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/计算机网络结构.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/接入网络.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/DSL.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/电缆网络.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/家庭接入.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/企业接入.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/无线局域网.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/广域局域网.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/网络核心.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/Internet结构.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/电路交换.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/图解三种交换.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/分组延迟.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/osi.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/osi数据.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/TCPIP模型.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/五层模型.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/三种模型对应.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/链路层.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/网络层.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络真实和理想.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络低通信道.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络带通信道.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络香农公式和奈斯准则.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络多路复用.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络频分多路复用.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络时分多路复用.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络波分多路复用.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络码分多路复用.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络数字信号编码.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/网线相邻.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/集线器和交换机.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/CRC例子8782.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/CRC例子87821.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/生成多项式.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/CRC举例.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/停止等待协议解决的问题.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/停止等待协议举例.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/停止等待协议信道利用率.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/GBN1.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/GBN2.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/GBN3.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/GBN4.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/GBN5.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/碰撞.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/碰撞窗口.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/以太网V2格式.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/碰撞扩大.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/碰撞扩大2.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/网桥.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/网桥表.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/网桥表2.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/网桥.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/交换机表1.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/交换机表2.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/网桥网络风暴.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/交换机网络风暴.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/ESS.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/AP和集线器对等.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/隐蔽站问题.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/IFS.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/争用窗口.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/信道预约.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/有线无线对比.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/无线网帧.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/局域网帧.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/无线网帧举例.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/111.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/arp工作图解.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/arp报文举例.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/arp格式.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/网络通信分类.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/网络号举例.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/地址分类.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/划分子网.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/CIDR划分IP地址.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/两个网.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/多个网.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/转发举例.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/IP数据报的格式.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/IP首部.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/分片举例.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/NAT.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/路由选择协议.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/rip1.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/好消息传播得快坏消息传播得慢1.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/好消息传播得快坏消息传播得慢2.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/rip报文格式.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/Dijkstra.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/划分区域.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/OSPF格式.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/OSPF操作.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/BGP协议.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/BGP格式.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/ICMP格式.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/ICMP差错.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/复用与分用.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/udp首部.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/UDP校验和.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/校验和计算.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/TCP格式.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/TCP格式控制.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/RTTS.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/RTTS图.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/RTTD.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/发送窗口1.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/发送窗口2.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/接收窗口.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/窗口滑动.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/超时.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/3次ACK.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/慢开始.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/拥塞避免.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/转化图.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/拥塞举例.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/三次握手.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/20170606084851272.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/各种协议与HTTP协议之间的关系.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/Buffer和Channel.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/分配之后.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/写模式.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/flip之后.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/scatter.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/gather.png"><meta property="og:image" content="https://isjinhao.github.io/2019/03-IO流和网络/非阻塞技术模型.png"><meta property="og:updated_time" content="2019-08-22T15:06:09.792Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="03-IO流和网络"><meta name="twitter:description" content="IO流构造方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798991001"><meta name="twitter:image" content="https://isjinhao.github.io/2019/03-IO流和网络/2019-07-15_000310.jpg"><link rel="alternate" href="/atom.xml" title="ISJINHAO" type="application/atom+xml"><link rel="canonical" href="https://isjinhao.github.io/2019/03-IO流和网络/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>03-IO流和网络 | ISJINHAO</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">ISJINHAO</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://isjinhao.github.io/2019/03-IO流和网络/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ISJINHAO"><meta itemprop="description" content="Living & Working"><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ISJINHAO"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">03-IO流和网络</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-28 21:47:20" itemprop="dateCreated datePublished" datetime="2019-07-28T21:47:20+08:00">2019-07-28</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-08-22 23:06:09" itemprop="dateModified" datetime="2019-08-22T23:06:09+08:00">2019-08-22</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/应届求职复习/" itemprop="url" rel="index"><span itemprop="name">应届求职复习</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">79k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">1:12</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><p></p><div align="center"><img width="90%" src="//isjinhao.github.io/2019/03-IO流和网络/2019-07-15_000310.jpg"></div><p></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">ByteArrayInputStream(<span class="keyword">byte</span>[] buf) </span><br><span class="line"><span class="comment">// 创建一个 ByteArrayInputStream，使用 buf 作为其缓冲区数组。 </span></span><br><span class="line">    </span><br><span class="line">ByteArrayInputStream(<span class="keyword">byte</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length) </span><br><span class="line"><span class="comment">// 创建 ByteArrayInputStream，使用 buf 作为其缓冲区数组。 </span></span><br><span class="line"></span><br><span class="line">FileInputStream(File file) </span><br><span class="line"><span class="comment">// 通过打开一个到实际文件的连接来创建一个 FileInputStream，</span></span><br><span class="line"><span class="comment">// 该文件通过文件系统中的 File 对象 file 指定。 </span></span><br><span class="line"></span><br><span class="line">FileInputStream(String name) </span><br><span class="line"><span class="comment">// 通过打开一个到实际文件的连接来创建一个 FileInputStream，</span></span><br><span class="line"><span class="comment">// 该文件通过文件系统中的路径名 name 指定。 </span></span><br><span class="line"></span><br><span class="line">ObjectInputStream(InputStream in) </span><br><span class="line"><span class="comment">// 创建从指定 InputStream 读取的 ObjectInputStream。</span></span><br><span class="line">    </span><br><span class="line">BufferedInputStream(InputStream in) </span><br><span class="line"><span class="comment">// 创建一个 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 </span></span><br><span class="line">    </span><br><span class="line">BufferedInputStream(InputStream in, <span class="keyword">int</span> size) </span><br><span class="line"><span class="comment">// 创建具有指定缓冲区大小的 BufferedInputStream 并保存其参数，即输入流 in，以便将来使用。 </span></span><br><span class="line"></span><br><span class="line">BufferedReader(Reader in) </span><br><span class="line"><span class="comment">// 创建一个使用默认大小输入缓冲区的缓冲字符输入流。 </span></span><br><span class="line"></span><br><span class="line">BufferedReader(Reader in, <span class="keyword">int</span> sz)</span><br><span class="line"><span class="comment">// 创建一个使用指定大小输入缓冲区的缓冲字符输入流。 </span></span><br><span class="line"></span><br><span class="line">CharArrayReader(<span class="keyword">char</span>[] buf) </span><br><span class="line"><span class="comment">// 根据指定的 char 数组创建一个 CharArrayReader。 </span></span><br><span class="line"></span><br><span class="line">CharArrayReader(<span class="keyword">char</span>[] buf, <span class="keyword">int</span> offset, <span class="keyword">int</span> length) </span><br><span class="line"><span class="comment">// 根据指定的 char 数组创建一个 CharArrayReader。 </span></span><br><span class="line"></span><br><span class="line">StringReader(String s) </span><br><span class="line"><span class="comment">// 创建一个新字符串 reader。</span></span><br><span class="line"></span><br><span class="line">FileReader(File file) </span><br><span class="line"><span class="comment">// 在给定从中读取数据的 File 的情况下创建一个新 FileReader。 </span></span><br><span class="line"></span><br><span class="line">FileReader(String fileName) </span><br><span class="line"><span class="comment">// 在给定从中读取数据的文件名的情况下创建一个新 FileReader。 </span></span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream() </span><br><span class="line"><span class="comment">// 创建一个新的 byte 数组输出流。 </span></span><br><span class="line"></span><br><span class="line">ByteArrayOutputStream(<span class="keyword">int</span> size) </span><br><span class="line"><span class="comment">// 创建一个新的 byte 数组输出流，它具有指定大小的缓冲区容量（以字节为单位）。 </span></span><br><span class="line"></span><br><span class="line">FileOutputStream(File file)</span><br><span class="line"><span class="comment">// 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 </span></span><br><span class="line"></span><br><span class="line">FileOutputStream(File file, <span class="keyword">boolean</span> append) </span><br><span class="line"><span class="comment">// 创建一个向指定 File 对象表示的文件中写入数据的文件输出流。 </span></span><br><span class="line"></span><br><span class="line">FileOutputStream(String name) </span><br><span class="line"><span class="comment">// 创建一个向具有指定名称的文件中写入数据的输出文件流。 </span></span><br><span class="line"></span><br><span class="line">FileOutputStream(String name, <span class="keyword">boolean</span> append) </span><br><span class="line"><span class="comment">// 创建一个向具有指定 name 的文件中写入数据的输出文件流。 </span></span><br><span class="line"></span><br><span class="line">ObjectOutputStream(OutputStream out) </span><br><span class="line"><span class="comment">// 创建写入指定 OutputStream 的 ObjectOutputStream。</span></span><br><span class="line"></span><br><span class="line">BufferedOutputStream(OutputStream out) </span><br><span class="line"><span class="comment">// 创建一个新的缓冲输出流，以将数据写入指定的底层输出流。 </span></span><br><span class="line"></span><br><span class="line">BufferedOutputStream(OutputStream out, <span class="keyword">int</span> size) </span><br><span class="line"><span class="comment">// 创建一个新的缓冲输出流，以将具有指定缓冲区大小的数据写入指定的底层输出流。 </span></span><br><span class="line"></span><br><span class="line">PrintStream(File file) </span><br><span class="line"><span class="comment">// 创建具有指定文件且不带自动行刷新的新打印流。 </span></span><br><span class="line"></span><br><span class="line">PrintStream(File file, String csn) </span><br><span class="line"><span class="comment">// 创建具有指定文件名称和字符集且不带自动行刷新的新打印流。 </span></span><br><span class="line"></span><br><span class="line">PrintStream(OutputStream out) </span><br><span class="line"><span class="comment">// 创建新的打印流。 </span></span><br><span class="line"></span><br><span class="line">PrintStream(OutputStream out, <span class="keyword">boolean</span> autoFlush) </span><br><span class="line"><span class="comment">// 创建新的打印流。 </span></span><br><span class="line"></span><br><span class="line">PrintStream(OutputStream out, <span class="keyword">boolean</span> autoFlush, String encoding) </span><br><span class="line"><span class="comment">// 创建新的打印流。 </span></span><br><span class="line"></span><br><span class="line">PrintStream(String fileName) </span><br><span class="line"><span class="comment">// 创建具有指定文件名称且不带自动行刷新的新打印流。 </span></span><br><span class="line"></span><br><span class="line">PrintStream(String fileName, String csn) </span><br><span class="line"><span class="comment">// 创建具有指定文件名称和字符集且不带自动行刷新的新打印流。 </span></span><br><span class="line"></span><br><span class="line">BufferedWriter(Writer out) </span><br><span class="line"><span class="comment">// 创建一个使用默认大小输出缓冲区的缓冲字符输出流。 </span></span><br><span class="line"></span><br><span class="line">BufferedWriter(Writer out, <span class="keyword">int</span> sz) </span><br><span class="line"><span class="comment">// 创建一个使用给定大小输出缓冲区的新缓冲字符输出流。 </span></span><br><span class="line"></span><br><span class="line">CharArrayWriter() </span><br><span class="line"><span class="comment">// 创建一个新的 CharArrayWriter。 </span></span><br><span class="line"></span><br><span class="line">CharArrayWriter(<span class="keyword">int</span> initialSize) </span><br><span class="line"><span class="comment">// 创建一个具有指定初始大小的新 CharArrayWriter。 </span></span><br><span class="line"></span><br><span class="line">StringWriter() </span><br><span class="line"><span class="comment">// 使用默认初始字符串缓冲区大小创建一个新字符串 writer。 </span></span><br><span class="line"></span><br><span class="line">StringWriter(<span class="keyword">int</span> initialSize) </span><br><span class="line"><span class="comment">// 使用指定初始字符串缓冲区大小创建一个新字符串 writer。 </span></span><br><span class="line"></span><br><span class="line">FileWriter(File file) </span><br><span class="line"><span class="comment">// 根据给定的 File 对象构造一个 FileWriter 对象。 </span></span><br><span class="line"></span><br><span class="line">FileWriter(File file, <span class="keyword">boolean</span> append) </span><br><span class="line"><span class="comment">// 根据给定的 File 对象构造一个 FileWriter 对象。 </span></span><br><span class="line"></span><br><span class="line">FileWriter(String fileName) </span><br><span class="line"><span class="comment">// 根据给定的文件名构造一个 FileWriter 对象。 </span></span><br><span class="line"></span><br><span class="line">FileWriter(String fileName, <span class="keyword">boolean</span> append) </span><br><span class="line"><span class="comment">// 根据给定的文件名以及指示是否附加写入数据的 boolean 值来构造 FileWriter 对象。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(File file) </span><br><span class="line"><span class="comment">// 使用指定文件创建不具有自动行刷新的新 PrintWriter。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(File file, String csn) </span><br><span class="line"><span class="comment">// 创建具有指定文件和字符集且不带自动刷行新的新 PrintWriter。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(OutputStream out) </span><br><span class="line"><span class="comment">// 根据现有的 OutputStream 创建不带自动行刷新的新 PrintWriter。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(OutputStream out, <span class="keyword">boolean</span> autoFlush) </span><br><span class="line"><span class="comment">// 通过现有的 OutputStream 创建新的 PrintWriter。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(String fileName) </span><br><span class="line"><span class="comment">// 创建具有指定文件名称且不带自动行刷新的新 PrintWriter。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(String fileName, String csn) </span><br><span class="line"><span class="comment">// 创建具有指定文件名称和字符集且不带自动行刷新的新 PrintWriter。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(Writer out) </span><br><span class="line"><span class="comment">// 创建不带自动行刷新的新 PrintWriter。 </span></span><br><span class="line"></span><br><span class="line">PrintWriter(Writer out, <span class="keyword">boolean</span> autoFlush) </span><br><span class="line"><span class="comment">// 创建新 PrintWriter。</span></span><br></pre></td></tr></table></figure><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><p>计算机网络就是互联的、自治的计算机集合。自治指的是所有的计算机直接没有主从关系；互联指的是互联互通，能进行数据交换。</p><p>计算机网络的本质是一种通信网络，只不过信源和信宿都是主机。它是计算机技术和通信技术的结合。</p><h3 id="信道"><a href="#信道" class="headerlink" title="信道"></a>信道</h3><p>信道是数据交换的载体。狭义上说人和人之间交流所承载信息的空气就是信道。广义上说它还可以包括有关的变换装置，这样的话信道往往被分成信道编码器、信道本身和信道译码器。</p><p>简易通信系统模型如下：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/信道.png"></div><p></p><h3 id="主机（host）"><a href="#主机（host）" class="headerlink" title="主机（host）"></a>主机（host）</h3><p>诸如手机、电脑、服务器等端系统（end systems）。</p><h3 id="交换机"><a href="#交换机" class="headerlink" title="交换机"></a>交换机</h3><p>如果想实现多个计算机之间的互联，按照之前的想法是每两台计算机进行连接，但这样太麻烦，一个好的做法是把这个计算机连接在某一中心上，这个中心把所有连接上来的计算机进行互联，在链路层这个中心叫做交换机。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/交换机.png" style="width:25%"></div><p></p><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>分组是带有地址信息的信息小片，可以理解成是计算机把一个文件切片后打成的包裹，由两部分构成：地址信息和真正传输的东西。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/分组.jpg"></div><p></p><h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><p>是计算机网络的一种专用计算机，它只有一个功能，就是转发分组。可以简单的理解为路由器是电子化的邮局，全国所有的邮局之间互联，是包裹能够传递，路由器之间互联，是分组能够正确转发。</p><p>路由器和交换机的区别是：交换机将计算机连在一起，构成局域网；路由器将局域网连在一起，形成互联网。</p><h2 id="计算机网络基本原理"><a href="#计算机网络基本原理" class="headerlink" title="计算机网络基本原理"></a>计算机网络基本原理</h2><p><strong>分组交换技术</strong>，也就是拆分分组、传输分组、合并分组的技术。</p><p>这个技术的优点就是便宜，因为把数据打包成分组和分组拆分都在计算机中进行，网络上只进行分组的转发，就使得网络的结构很简单，路由器设计也很简单。这一中原则被叫做“端到端的原则”，即能在端系统做的事情不在网络上实现。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/计算机网络基本原则.jpg" style="width:60%"></div><p></p><h3 id="分组交换技术"><a href="#分组交换技术" class="headerlink" title="分组交换技术"></a>分组交换技术</h3><ol><li>一个主机至少连接一个路由器：数据最终是通过路由器进行转发的，所以一个主机至少得连接一个路由器。</li><li>分组存储转发：分组完全进入路由器后，路由器按照地址信息检索转发表。注意不是第一个bit或Byte进入时就开始转发，是<strong>全部进入</strong>才转发。</li><li>分组独立选择路径：一个文件被分成多个分组，但这些分组之间是独立的，路由器给他们看成相互独立的数据。分组的组装是通过接收方进行的，和网络无关。</li></ol><h2 id="Internet"><a href="#Internet" class="headerlink" title="Internet"></a>Internet</h2><h3 id="组成细节角度"><a href="#组成细节角度" class="headerlink" title="组成细节角度"></a>组成细节角度</h3><p>ISP网络互联形成的网络之网络。由运行各种网路应用的计算设备，光纤、铜缆、无线电等通信链路、路由器和交换机等组成的分组交换设备组成。</p><h3 id="服务角度"><a href="#服务角度" class="headerlink" title="服务角度"></a>服务角度</h3><p>是为网络应用提供通信服务的通信基础设施和为网络应用提供的应用编程接口。</p><h3 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h3><p>ISP，全称为Internet Service Provider，因特网服务提供商，即指提供互联网服务的公司。能提供拨号上网服务、网上浏览、下载文件、收发电子邮件等服务。</p><h3 id="IXP"><a href="#IXP" class="headerlink" title="IXP"></a>IXP</h3><p>Internet eXchange Point，互联网交换点IXP的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。</p><h2 id="网络的结构"><a href="#网络的结构" class="headerlink" title="网络的结构"></a>网络的结构</h2><ul><li><p>网络边缘：位于“网络边缘”运行网络应用程序的端系统。</p></li><li><p>接入网络、物理介质：有线或无线的通信链路。</p></li><li><p>网络核心：互联的路由器（或分组转发设备）。构成“网络之网络”的关键。</p></li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/计算机网络结构.png" style="width:30%"></div><p></p><h3 id="网络应用模型"><a href="#网络应用模型" class="headerlink" title="网络应用模型"></a>网络应用模型</h3><p>客户/服务器应用模型：依赖于专用服务器，如Web应用。</p><p>对等应用模型：不依赖专用服务器，通信在对等实体之间进行，如P2P应用。</p><h2 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h2><p>接入网络是一种用户网络，它连接用户到特定的服务提供商并通过承载网络到达其他网络。两个被用户关心的特征：带宽（数据传输速率，bps）、独占/共享（独占是带宽为某用户独用，共享是多个用户分用同一带宽）。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/接入网络.jpg" style="width:50%"></div><p></p><h3 id="数字用户线路：DSL"><a href="#数字用户线路：DSL" class="headerlink" title="数字用户线路：DSL"></a>数字用户线路：DSL</h3><p>是以电话线为传输介质的传输技术组合。DSL技术在传递公用电话网络的用户环路上支持对称和非对称传输ADSL：上行速度较慢，下行速度较快）模式。</p><p>用DSL接入Internet时用户一方会有DSL调制解调器，被接入方会有DSL接入多路复用器与多个用户进行接入。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/DSL.png" style="width:60%"></div><p></p><h3 id="电缆网络"><a href="#电缆网络" class="headerlink" title="电缆网络"></a>电缆网络</h3><p>又被称为混合光纤同轴电缆网络。也是一种非对称式的接入网络。但它是共享网络，多个用户共同接入一个解调器。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/电缆网络.png" style="width:80%"></div><p></p><h3 id="常见网络接入"><a href="#常见网络接入" class="headerlink" title="常见网络接入"></a>常见网络接入</h3><h4 id="家庭接入"><a href="#家庭接入" class="headerlink" title="家庭接入"></a>家庭接入</h4><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/家庭接入.png" style="width:75%"></div><p></p><h4 id="机构（企业）接入"><a href="#机构（企业）接入" class="headerlink" title="机构（企业）接入"></a>机构（企业）接入</h4><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/企业接入.png" style="width:70%"></div><p></p><h4 id="无线局域网"><a href="#无线局域网" class="headerlink" title="无线局域网"></a>无线局域网</h4><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/无线局域网.png"></div><p></p><h4 id="广域局域网"><a href="#广域局域网" class="headerlink" title="广域局域网"></a>广域局域网</h4><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/广域局域网.png" style="width:40%"></div><p></p><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><p>网络核心的功能是：路由（routing）：确定分组从源到目的传输路径；转发（forwarding）：将分组从路由器的输入端口交换至正确的输出端口。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网络核心.png" style="width:70%"></div><p></p><h2 id="Internet结构"><a href="#Internet结构" class="headerlink" title="Internet结构"></a>Internet结构</h2><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/Internet结构.png" style="width:70%"></div><p></p><ul><li><code>一级ISP包含</code>：网通、电信等商业ISP，还包含谷歌、微软等内容提供商网络。</li><li><code>IXP</code>：全称：Internet eXchange Point，即互联网交换中心。互联网Internet是由众多的网络互相连接而形成的全球性网络，互联网交换中心负责这些不同的网络之间互相通信的交换点，是互联网的关键基础设施。</li></ul><h2 id="数据交换方式"><a href="#数据交换方式" class="headerlink" title="数据交换方式"></a>数据交换方式</h2><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><p>包含三个阶段：建立连接、通信、释放连接。最显著的特点是独占电路资源。最典型的是电话网络。（下图的中继线上可以存在多组用户通信，详见复用技术）</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/电路交换.png" style="width:80%"></div><p></p><h3 id="报文交换"><a href="#报文交换" class="headerlink" title="报文交换"></a>报文交换</h3><p>报文交换是指把信息整个打包，然后经过存储转发送到目的地。</p><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><p>分组交换是把信息拆分成不同的分组，然后把所有的分组相继发送给路由器，路由器通过路由&amp;转发把数据传输到目的地。</p><ul><li><p>和报文交换的区别是：报文交换不拆分信息。</p></li><li><p>和电路交换的区别是：如果把每个分组看成原子单位，区别就是各分组走不同的路径，不需要独占资源。</p></li></ul><h3 id="图解三种交换"><a href="#图解三种交换" class="headerlink" title="图解三种交换"></a>图解三种交换</h3><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/图解三种交换.png" style="width:80%"></div><p></p><h3 id="分组交换的优势"><a href="#分组交换的优势" class="headerlink" title="分组交换的优势"></a>分组交换的优势</h3><ul><li><p>和报文交换相比：速度快，因为在报文交换时，同一时间只有一个路由器在工作，其他路由器在等待。路由器的存储空间小，最低存储空间和分组大小差不多。</p></li><li><p>和电路交换相比：分组交换允许更多用户同时使用网络，让网络资源充分共享。</p></li></ul><h3 id="分组交换的劣势"><a href="#分组交换的劣势" class="headerlink" title="分组交换的劣势"></a>分组交换的劣势</h3><p>可能产生拥塞（congestion）：分组延迟和丢失。需要协议处理可靠数据传输和拥塞控制。</p><h2 id="RFC文档"><a href="#RFC文档" class="headerlink" title="RFC文档"></a>RFC文档</h2><p>Request For Comments（RFC），是一系列以编号排定的文件。文件收集了有关互联网相关信息，以及UNIX和互联网社区的软件文件。目前RFC文件是由Internet Society（ISOC）赞助发行。基本的互联网通信协议都有在RFC文件内详细说明。RFC文件还额外加入许多的论题在标准内，例如对于互联网新开发的协议及发展中所有的记录。因此几乎所有的互联网标准都有收录在RFC文件之中。</p><h2 id="IETF"><a href="#IETF" class="headerlink" title="IETF"></a>IETF</h2><p>全称：The Internet Engineering Task Force，国际互联网工程任务组。全球互联网最具权威的技术标准化组织，主要任务是负责互联网相关技术规范的研发和制定，是一个由为互联网技术工程及发展做出贡献的专家自发参与和管理的国际民间机构。主要任务是负责互联网相关技术标准的研发和制定，是国际互联网业界具有一定权威的网络相关技术研究团体。绝大多数国际互联网技术标准出自IETF。</p><h2 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h2><p>network protocol。为进行网络中的数据交换而建立的规则、标准或约定。其中规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到的消息或发生的事件而产生的动作。也可以说网络协议规定了网络中所有信息的发送和接受过程。</p><h3 id="协议三要素"><a href="#协议三要素" class="headerlink" title="协议三要素"></a>协议三要素</h3><ul><li><p>语义：语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。</p></li><li><p>语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。</p></li><li><p>时序：时序是对事件发生顺序的详细说明。（也可称为“同步”）。</p></li></ul><p>总结：语义表示要做什么，语法表示要怎么做，时序表示做的顺序。</p><h2 id="速率-amp-带宽"><a href="#速率-amp-带宽" class="headerlink" title="速率 &amp; 带宽"></a>速率 &amp; 带宽</h2><ul><li>速率：又称数据率，数据传输速率或比特率。单位bps、kbps、Mbps、Gbps。</li><li>带宽：数字信道所能传输的最大数据率。单位bps等。</li></ul><h2 id="丢包"><a href="#丢包" class="headerlink" title="丢包"></a>丢包</h2><p>如果路由器的缓存满了，再到达的分组会被路由器丢弃，即造成丢包现象。丢包率 = 丢包数 / 已发分组数。</p><h2 id="分组延迟"><a href="#分组延迟" class="headerlink" title="分组延迟"></a>分组延迟</h2><ul><li><p>结点处理延迟：差错检测、确定输出链路；</p></li><li><p>排队延迟：等待输出链路可用、取决于路由器拥塞程度；</p></li><li><p>传输延迟：分组长度/链路带宽；</p></li><li><p>传播延迟：物理链路长度/信号传输速度。</p></li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/分组延迟.jpg" style="width:60%"></div><p></p><h2 id="流量强度"><a href="#流量强度" class="headerlink" title="流量强度"></a>流量强度</h2><p>设链路带宽为R(bps)，分组长度为L(bits)，平均每组到达速率为v。则：</p><ul><li><p>$L \ast v / R \longrightarrow 0 $时：平均排队延迟很小；</p></li><li><p>$L \ast v / R \longrightarrow 1$时：平均排队延迟很大；</p></li><li><p>$L \ast v / R &gt; 1$时：超出服务能力，延迟 趋向于 无限大。</p></li></ul><h2 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h2><p>$时延带宽积 = 传播时延 \ast 带宽$，单位：bit。实际意义是：从我们向某一信道上发送第一个bit，到这个bit被接收方接受这个时间里，发送方总共向信道上发送了多少bit。也可以称为以比特为单位的链路长度，比如某段链路长度为n比特。</p><h2 id="吞吐率-量（Throughput）"><a href="#吞吐率-量（Throughput）" class="headerlink" title="吞吐率/量（Throughput）"></a>吞吐率/量（Throughput）</h2><p>发送端与接收端之间的传送数据率（b/s）。端到端的吞吐量取决于瓶颈链路。</p><h2 id="网络体系结构"><a href="#网络体系结构" class="headerlink" title="网络体系结构"></a>网络体系结构</h2><p>指通信系统的整体设计，它为网络硬件、软件、协议、存取控制和拓扑提供标准。</p><p>计算机网络是一个非常复杂的系统，需要解决的问题很多并且性质各不相同。所以，在设计时，就使用了“分层”的思想，即将庞大而复杂的问题分为若干较小的易于处理的局部问题。各层之间是按照功能进行分层的，同时每层遵循相应的网络协议完成本层功能。</p><h2 id="OSI参考模型的通信过程"><a href="#OSI参考模型的通信过程" class="headerlink" title="OSI参考模型的通信过程"></a>OSI参考模型的通信过程</h2><p>七层结构：物理层、数据链路层、网络层、传输层、对话层、表示层和应用层。</p><ul><li><p>端系统需要完成七层的功能，中间系统完成三层功能。</p></li><li><p>协议之间是对等的，比如应用层的协议对发送方来说是如何把信息传输到表示层，而对接收方来说，是如何把从表示层传来的信息还原到应用层。</p></li><li>对于后四层，从逻辑上说不需要经过中间系统，所以被称为“端-端层”。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/osi.png" style="width:70%"></div><p></p><h3 id="OSI参考模型的数据封装"><a href="#OSI参考模型的数据封装" class="headerlink" title="OSI参考模型的数据封装"></a>OSI参考模型的数据封装</h3><ul><li>后六层每层在把数据向下一层传输时都会加上控制信息。而物理层不再封装，因为到达它的数据已经时二进制数据，直接传输就行。</li><li>数据链路层传送给物理层时一般加头加尾，其他层只加头。头是首部，尾是循环冗余校验。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/osi数据.png" style="width:80%"></div><p></p><h3 id="PDU"><a href="#PDU" class="headerlink" title="PDU"></a>PDU</h3><p>协议数据单元。可能包括地址：标识发送端/接收端等；差错检测编码：用于差错检测或纠正；协议控制：一些如优先级、服务质量、安全控制等信息。</p><h2 id="TCP-IP参考模型"><a href="#TCP-IP参考模型" class="headerlink" title="TCP/IP参考模型"></a>TCP/IP参考模型</h2><p>四层结构：应用层、运输层、网际层和网络接口层。</p><p>所有的应用都架构在IP上，在网络接口层只要能构建IP，能进行分组就可以算是网络的一部分，这是互联网发展迅速的一大原因。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/TCPIP模型.png" style="width:70%"></div><p></p><h2 id="五层参考模型"><a href="#五层参考模型" class="headerlink" title="五层参考模型"></a>五层参考模型</h2><p>五层结构：物理层、链路层、网络层、传输层和应用层。此模型结合了OSI概念清晰，分工明确的优点和TCP/IP简单实用的优点。</p><h3 id="五层传输模型的数据封装"><a href="#五层传输模型的数据封装" class="headerlink" title="五层传输模型的数据封装"></a>五层传输模型的数据封装</h3><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/五层模型.png" style="width:70%"></div><p></p><h3 id="三种模型对应"><a href="#三种模型对应" class="headerlink" title="三种模型对应"></a>三种模型对应</h3><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/三种模型对应.png" style="width:70%"></div><p></p><h3 id="物理层实现的功能概述"><a href="#物理层实现的功能概述" class="headerlink" title="物理层实现的功能概述"></a>物理层实现的功能概述</h3><p>核心功能：<strong>透明地传送比特流</strong>。解决的问题一般如下：</p><ul><li>接口特性：<ul><li>机械特性：接口的几何形状，位置等等；</li><li>电气特性：使用电压的高低等等；</li><li>功能特性：各个引脚的作用等等；</li><li>规程特性：工作的过程是什么样的，如哪个引脚先发送数据，哪个后发送等。</li></ul></li><li>比特编码：用信号的什么特征表示信息，如什么时候用0，什么时候用1。</li><li>数据率：在物理层上传输数据的速率。</li><li>比特同步：解决时钟同步问题，发送端何时发送数据，接收端何时接受数据。</li><li>传输模式：<ul><li>单工通信：一个为确定的发送端、一个为确定的接收端，不能互换。</li><li>半双工：发送端和接收端可以互换，但是随时间交替的。</li><li>双工：两端可以同时发送和接受数据。</li></ul></li></ul><h3 id="数据链路层功能概述"><a href="#数据链路层功能概述" class="headerlink" title="数据链路层功能概述"></a>数据链路层功能概述</h3><p>核心功能：<strong>在两个相邻结点之间的链路上“透明”地传送数据</strong>。解决的问题如下：</p><ul><li>组帧：来自网络层的数据被加头加尾后形成的数据叫做帧。组帧问题包含：头和尾里包含什么信息等。</li><li>物理寻址：物理层只进行比特流的传输，其他的都不做。物理寻址是在数据链路层做的，也就是数据链路层传输层给物理层的数据包含处理好的地址。</li><li>流量控制：使数据的发送和数据的接收尽可能平衡，防止数据太多造成丢失等。</li><li>差错处理：检测并重传损坏或丢失帧，并避免重复帧。</li><li>访问（接入）控制：在任一时刻觉得哪个设备拥有链路使用权。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/链路层.png" style="width:80%"></div><p></p><h3 id="网络层功能概述"><a href="#网络层功能概述" class="headerlink" title="网络层功能概述"></a>网络层功能概述</h3><p>核心功能：</p><ol><li>负责为分组交换网上的不同主机提供通信服务。</li><li>选择合适的路由，是源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。</li></ol><p>解决的问题：</p><ul><li>逻辑寻址：全局唯一逻辑地址，确保数据分组被送达的主机，如IP地址。</li><li><p>路由和分组转发：确保在网络中数据能从源主机到目的主机</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网络层.png" style="width:70%"></div><p></p><h3 id="传输层功能"><a href="#传输层功能" class="headerlink" title="传输层功能"></a>传输层功能</h3></li></ul><p>核心功能：负责向两个主机中进程之间的通信提供服务。</p><p>解决的问题：</p><ul><li>分段与重组：网络层传输的分组大小是有限制的。应用层的</li><li>SAP寻址：确保将完整报文提交给正确进程，如端口号<ul><li>SAP：Service Access Point，在同一系统中相邻两层的实体进行交互的地方。</li></ul></li><li>连接控制：有两种协议，面向连接的TCP和无连接的UDP。</li><li>流量控制：匹配发送方和接收方的速度。</li><li>差错控制：如发送的报文接收方没有接受到或者接收方缓冲区由于满把报文丢弃该怎么处理。</li></ul><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>核心功能：直接为用户的应用进程提供服务。</p><h2 id="码元"><a href="#码元" class="headerlink" title="码元"></a>码元</h2><h3 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h3><p>数字通信中对数字信号的计量单位。在使用时间域（或简称为时域）的波形表示数字信号时，代表不同离散数值的基本波形。</p><h3 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h3><p>假如基带信号是<code>101011000110111010...</code>，如果直接发送，则每个码元携带一个比特的信息（每个码元只有2种状态），但是如果将信号中的三个比特编为一组，即101，011，000，110，111，010…，三个比特共有8种不同的排列，我们可以用不同的调制方法来表示这种信，如8种不同的振幅，频率，相位等，如果采用相位调制，相位$\phi_0$表示000，$\phi_1$表示001，以此类推，那么接收端如果收到相位是$\phi_0$的信号就知道表示的是000，以此类推，这样一个码元就不知不觉的传输了三个比特位的信号，此时每个码元有8种状态。一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难。</p><h3 id="编码级别"><a href="#编码级别" class="headerlink" title="编码级别"></a>编码级别</h3><p>如果把n个比特编码成一个码元，则此时编码状态$M=2^n$，其表示当前传输时有多少不同的状态，如8级编码，会有：<code>000、001、010 …</code></p><h2 id="奈斯准则"><a href="#奈斯准则" class="headerlink" title="奈斯准则"></a>奈斯准则</h2><h3 id="码间串扰"><a href="#码间串扰" class="headerlink" title="码间串扰"></a>码间串扰</h3><p>码元的传输速率是有限制的，超过某上限就会出现码间串扰问题。这是由于在真正传输中，信号在传输时都不是理想化的，如下图就是理想化的高低电平和真实传输时的高低电平。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络真实和理想.jpg" style="width:50%"></div><br>假如此时速度太快，就可能把低电平和高电平弄混。而最高的码元传输速率被奈斯准则限制。<p></p><h3 id="奈斯准则内容"><a href="#奈斯准则内容" class="headerlink" title="奈斯准则内容"></a>奈斯准则内容</h3><ul><li>理想低通信道（能通过信号频率在某值之下）的最高码元传输速率为：$2W Baud$。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络低通信道.png" style="width:80%"></div><p></p><ul><li>理想带通信道（能通过信号频率在某范围之内）的最高码元传输速率为：$1W Baud$。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络带通信道.png" style="width:80%"></div><br>W是理想低通信道的带宽，单位为赫(Hz)。Baud 是波特，是码元传输速率的单位，1 波特为每秒传送 1 个码元。<p></p><h3 id="波特率"><a href="#波特率" class="headerlink" title="波特率"></a>波特率</h3><p>单位时间内数据通信系统所传输的码元个数（信号个数），单位是波特（Baud）。</p><h3 id="比特率"><a href="#比特率" class="headerlink" title="比特率"></a>比特率</h3><p>表示单位时间内数据通信系统传输的比特数，单位是比特/秒（b/s或bps）。$比特率 = 波特率 * log_2M$</p><h2 id="香农公式"><a href="#香农公式" class="headerlink" title="香农公式"></a>香农公式</h2><h3 id="编码级数限制"><a href="#编码级数限制" class="headerlink" title="编码级数限制"></a>编码级数限制</h3><p>虽然码元传输速率有限制，但是如果我们能尽可能提高编码级数不就能提升信息传输速率了吗？但事实上信号传输速率不受限于调制技术，而是受限于信噪比。举个例子，如果我们是在天气晴朗的一天出门，我们穿任意颜色衣服都能被分辨出来，但是如果我们在沙尘暴天气出门，穿<code>橘黄</code>和<code>橙黄</code>两种颜色的衣服别人自然就认不出来了。在这个比喻中衣服的颜色代表码元，确定衣服的颜色代表信息，沙尘暴就是噪声。</p><h3 id="香农公式内容"><a href="#香农公式内容" class="headerlink" title="香农公式内容"></a>香农公式内容</h3><p>带宽受限且有高斯白噪声干扰的信道的极限信息传输速率$C=W \ast log_2(1+PS/PN)（b/s）$。</p><ul><li>其中$W$是信道的带宽。$PS$是信号的能量。$PN$是噪声的能量。</li><li>信噪比：$S/N=10lg{PS/PN}$。</li></ul><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>设带宽是<code>1MHz</code>，信噪比是<code>24dB</code>，则信道的最高信息传输速率为：$C=1M \ast log_2{(1+(10^{2.4}))}=7.98Mbps$。</p><h2 id="奈氏准则vs香农公式"><a href="#奈氏准则vs香农公式" class="headerlink" title="奈氏准则vs香农公式"></a>奈氏准则vs香农公式</h2><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络香农公式和奈斯准则.png" style="width:80%"></div><p></p><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>电路交换中独占电路资源，并不是指用户线和中继线都被此次交换所独占，而是说在两个用户建立连接之后，除非连接中断，否则他们当前所拥有的资源不会被释放，即使他们之间不传输信息。而如何在中继线上实现多组用户通信就是多路复用技术。</p><p>产生多路复用的物理基础是：传输媒体的带宽或容量往往会大于传输单一信号的需求，使用多路复用，为了有效地利用通信线路，希望一个信道同时传输多路信号。</p><p>这种技术会将链路/网络资源（如带宽）划分为“资源片”，将资源片分配给各路“呼叫”（calls），每路呼叫独占分配到的资源片进行通信，资源片可能“闲置”</p><p>常见的复用技术有：频分多路复用、时分多路复用、波分多路复用、码分多路复用。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络多路复用.png" style="width:80%"></div><p></p><h3 id="频分多路复用"><a href="#频分多路复用" class="headerlink" title="频分多路复用"></a>频分多路复用</h3><p>FMD：Frequency-division multiplexing，是指载波带宽被划分为多种不同频带的子信道，每个子信道可以并行传送一路信号的一种多路复用技术。也就是说信道的可用频带被分成若干个互不交叠的频段，每路信号用其中一个频段传输，因而可以用滤波器将它们分别滤出来，然后分别解调接收。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络频分多路复用.png" style="width:40%"></div><p></p><h3 id="时分多路复用"><a href="#时分多路复用" class="headerlink" title="时分多路复用"></a>时分多路复用</h3><p>TDM：time division multiplexing，它使不同的信号在不同的时间内传送，将整个传输时间分为许多时间间隔（Time Slot，TS，又称为时隙），每个时间片被一路信号占用。TDM就是通过在时间上交叉发送每一路信号的一部分来实现一条电路传送多路信号的。电路上的每一短暂时刻只有一路信号存在。因数字信号是有限个离散值，所以TDM多应用于数字通信系统。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络时分多路复用.png" style="width:70%"></div><p></p><h3 id="波分多路复用"><a href="#波分多路复用" class="headerlink" title="波分多路复用"></a>波分多路复用</h3><p>将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器（亦称合波器，Multiplexer）汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；在接收端，经解复用器（亦称分波器或称去复用器，Demultiplexer）将各种波长的光载波分离，然后由光接收机作进一步处理以恢复原信号。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络波分多路复用.png" style="width:70%"></div><p></p><h3 id="码分多路复用"><a href="#码分多路复用" class="headerlink" title="码分多路复用"></a>码分多路复用</h3><p>为每个用户分配一个唯一的mbit的码片序列（chipping sequence），二进制下的0用-1表示，二进制下的1用+1表示。在信道上传输的信号 = 原始数据 <em>码片序列，比如码片序列是：(-1, 1, 1)，需要传一个0，应该是 -1 </em>(-1, 1, 1)，所以传输的就是(1, -1, -1)。</p><p>同时为了保证数据之间不相互影响，被共享的用户所占有的码片应该相互正交的。即：$\frac{1}{m}S_i \cdot S_j = 0 (i \neq j)$。而信道上真正传输的数据是各用户发送数据的叠加值。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络码分多路复用.png" style="width:80%"></div><p></p><h3 id="数字信号在模拟信道传输"><a href="#数字信号在模拟信道传输" class="headerlink" title="数字信号在模拟信道传输"></a>数字信号在模拟信道传输</h3><p>数字信号需要编码后才能传输。常见的三种编码：</p><ol><li>NRZ编码：进制数字0、1分别用两种电平来表示。常用-5V表示1，+5V表示0。</li><li>曼切斯特编码：用电压的变化表示0和1：高→低 &lt;=&gt; 0，低→高 &lt;=&gt; 1。</li><li>差分曼切斯特编码：在码元开始处有无跳变来表示0和1：有 &lt;=&gt; 0，无 &lt;=&gt; 1。</li></ol><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/03-IO流和网络数字信号编码.png" style="width:80%"></div><p></p><h2 id="相邻"><a href="#相邻" class="headerlink" title="相邻"></a>相邻</h2><p>计算机网络中链路层的功能是“相邻节点间的数据传输”。这句话什么意思呢？我们先讨论“相邻”一词，再讨论“数据传输”。两台主机，用一根网线相连是相邻。多台主机，用一根网线相连，仍然是相邻。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网线相邻.png"></div><br>这根线缆退化成一个节点，这样的设备称为集线器。通过集线器相连的多台主机也是相邻。集线器没有任何智能，等同于线缆。在集线器上增加简单的智能控制功能，就是交换机。通过交换机相连的多台主机也是相邻。交换机将计算机互联在一起，构成局域网。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/集线器和交换机.png"></div><br>所以“相邻节点间的数据传输”换一种说法就是“构建局域网”，再换一种说法就是“局域网内的主机都是邻居关系”。链路层的功能就是构建局域网。相邻这一概念很重要，主机间的数据传输可以分为两种情况，一种是两个主机在同<br>一个局域网内，两主机是相邻关系，简称内网通信，另一种是两个主机在两个不同的网络里，可称外网通信，两种数据传输原理完全不同。本篇博文只关注内网通信。<p></p><h2 id="链路层解决的问题"><a href="#链路层解决的问题" class="headerlink" title="链路层解决的问题"></a>链路层解决的问题</h2><p>数据传输就是将一台主机内的数据传输到另一台主机，物理层解决了比特转换为电磁信号传输的问题，但这不是数据传输的全部问题，还有一些问题，例如：</p><ul><li>物理层传输中的数据有可能出错，如何处理？</li><li>发送方与接收方的速度可能不匹配，如何调节？</li><li>数据如何封装成数据帧，然后传输，如何传输封装？</li><li>发生碰撞该怎么办？</li></ul><p>针对这些问题制定的解决方案称为数据链路层的通信协议。物理链路+通信协议构成了我们要研究的数据链路。</p><h2 id="循环冗余码"><a href="#循环冗余码" class="headerlink" title="循环冗余码"></a>循环冗余码</h2><p>循环冗余码（CRC）在很多地方都被用来校验传输的数据是否出错，至于其如何证明，博主也未曾探究，下文介绍冗余码的思想和计算方法。</p><p>如果发送方只传输 87，接收方收到 82，接收方是无法判断 82 是不是发送方发送的数据，就是说无法判断 82 是对还是错。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/CRC例子8782.png"></div><br>怎么办？发送方与接收方事先商量好一个数，例如 15，发送时先计算 87 除 15 的余数，为 12，将这个余数与 87 一起发送，即 8712，接收时先计算 82 除 15 的余数，为 7，不等于 12，就认为传输的数据出错，这样检错的概率并非百分之百，例如87 错成 72 就检测不出来，但总体来说，检错概率已经非常高了。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/CRC例子87821.png"></div><p></p><h3 id="CRC-计算方法"><a href="#CRC-计算方法" class="headerlink" title="CRC 计算方法"></a>CRC 计算方法</h3><ul><li>第一，CRC 有一个生成多项式 P(x)，其作用等同于除数 15，将其写成比特串，转化规则如图：</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/生成多项式.png"></div><p></p><ul><li>第二，如果 P(x) 的比特串是 n 位，在发送数据后补 n-1 个 0。例如 P(x)为 1101，就要补 000。</li><li>第三，做模2除法。<strong>注意模二除法不是二进制除法。</strong></li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/CRC举例.png"></div><p></p><ul><li>第四，用<strong>余数</strong>替换补的 0，形成发送数据，101001001。</li><li>第五，接收方用接收数据 101001001 除以 P(x)1101，如果能整除，就表示没有错（等同与原理中的余数相同），如果不能整除，就表示出错了（等同与原理中的余数不相等）。</li></ul><h2 id="停止等待协议（Stop-and-Wait-protocol）"><a href="#停止等待协议（Stop-and-Wait-protocol）" class="headerlink" title="停止等待协议（Stop-and-Wait protocol）"></a>停止等待协议（Stop-and-Wait protocol）</h2><p>如果两个主机间数据传输时，接收方的速度永远不会低于发送方的速度；传输的数据帧不会出错，也不会丢失，完全理想化的数据传输，那就没有什么问题，当然也不需要解决问题的办法，也就不需要协议。现在假设，没有差错，但是接收方的速度低于发送方的速度，怎么办？显然控制的思路只能是快的一方牵就慢的一方，就是由慢的一方指挥快的一方。具体来说，就是发送方每发送一帧就停下来，等待；收到 ACK 发送下一帧，接收方则是等待，收到数据帧，发送 ACK（确认 Acknowledgment ），等待下一帧。停下来，等待就是停止等待协议的由来。</p><p>停止等待协议当然不仅仅需要这一个问题，其需要解决的问题如下：</p><ul><li>接收方的速度低于发送方的速度；</li><li>传输的数据帧可能出错；</li><li>数据帧可能丢失，确认帧 ACK 也可能丢失；</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/停止等待协议解决的问题.png"></div><p></p><h3 id="确认号"><a href="#确认号" class="headerlink" title="确认号"></a>确认号</h3><p>接收方收到一个数据帧，并校验正确，给发送方一个确认 ACKn，ACKn 表示“第 n-1 号帧已经收到，现在期望接收第 n 号帧”。确认号是接收方预期接收的下一帧的序号。</p><h3 id="差错"><a href="#差错" class="headerlink" title="差错"></a>差错</h3><p>数据帧出错时，接收方收到一个数据帧，校验时发现数据帧出错，接收方丢弃此数据帧，此外不做任何事，即不发送 ACK。发送方发送完数据帧后在停止等待 ACK，然而此时不会有 ACK，发送方就等死在这里了。</p><h3 id="重传定时器"><a href="#重传定时器" class="headerlink" title="重传定时器"></a>重传定时器</h3><p>发送方设计一个重传定时器的机制，发送方每发送一个数据帧，就启动一个倒计时的重传定时器，如果在超时 timeout 之前收到确认，就关闭定时器并发送下一帧。如果超时，就重传之前的帧。</p><h3 id="丢失"><a href="#丢失" class="headerlink" title="丢失"></a>丢失</h3><p>接收方收到一个数据帧，校验正确发送 ACK，等待接收下一帧，如果确认帧丢失，发送方收不到确认，超时后重传旧帧，而接收方在等待新帧，此刻发送方与接收方的状态不同步，如何区分新帧与重传的帧？</p><h3 id="帧编号"><a href="#帧编号" class="headerlink" title="帧编号"></a>帧编号</h3><p>停等协议使用序号和确认号，以区分重传的数据帧。发送方发送帧时使用序号，接收方使用确认号。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/停止等待协议举例.png"></div><p></p><h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><p>停止等待协议的优点是简单，但缺点是信道利用率太低。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/停止等待协议信道利用率.png"></div><br>信道利用率公式：$U=\frac{T_D}{T_D+RTT+T_A}$，其中：<p></p><ul><li>$T_D$：数据帧传输时延</li><li>$RTT$：数据帧+确认帧传播时延</li><li>$T_A$：确认帧传输时延</li></ul><p>举例：假设主机甲与主机乙使用停等协议传输数据，若甲乙之间的单向传播延迟是 15ms，数据帧长为 1000 字节，信道宽带为 100Mbps，乙每收到一个数据帧立即利用一个短帧（忽略其发送时延）进行确认，则信道利用率为：发送一个数据帧到 100Mbps 链路所需时间为：$T_D = \frac{1000 \ast 8bits}{100 \ast 10^6bit/s }= 80\mu s$。发送方在 t=0 时刻发送，15ms 后第 1 个比特到达主机乙，15.08ms 时主机乙收到最后一比特，开始发送确认帧，由于确认帧很短，我们忽略其发送时延，在30.08ms 时，确认帧到达主机甲，总时间周期为T𝐷 + RTT + T𝐴(忽略) = 30.08ms，信道利用率为0.0027。信道利用率为 0.27%，就是说发送方只有百分之0.27的时间是忙的。停止等待协议信道利用率太低了。</p><h2 id="GBN-协议"><a href="#GBN-协议" class="headerlink" title="GBN 协议"></a>GBN 协议</h2><p>我们讨论一个可以获得较高信道利用率的协议：连续 ARQ 协议(Go-back-NProtocol)，或称 GBN 协议，也称为滑动窗口协议（Sliding Window Protocol）。发送方在接收到确认之前，发送一组数据帧，而不是发送一个数据帧就停止等待确认。</p><h3 id="确认号-1"><a href="#确认号-1" class="headerlink" title="确认号"></a>确认号</h3><p>在 GBN 协议中，采用累积确认的方式，确认号是希望接收的下一个分组序号。举例，ACK7 表示序号 6 以内的所有帧都已正确收到了，等待接收 7 号帧。</p><h3 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h3><p>在 GBN 协议中，发送一组帧，然后停止等待确认。发送窗口定义了最多可以发送多少个数据帧。举例如下图：一个大小为 7 的窗口，窗口左侧是已确认，已丢弃的帧，窗口内有色的是已发送的，尚未收到确认的帧，0，1，2，3 号帧，发送方需要等待，可称为未完成帧，窗口内无色的是可发送还未发送的帧，是 4，5，6 号帧，窗口右侧是不能发送的帧。描述发送窗口需 3 个变量：</p><ul><li>$S_f$：发送窗口，第一个未完成分组。完成指的是发送方接收到确认方的确认帧。</li><li>$S_n$：发送窗口，下一个待发送分组。</li><li>$S_{size}$：发送窗口，大小。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/GBN1.png"></div><br>当 ackNo 大于等于 $S_f$ 且小于 $S_n$ 的无错 ACK 到达时，发送窗口可以滑动一个或多个槽。举例，当发送方收到 $ACK_6$，表示 4，5 号帧已正确接收，窗口滑动，状态如下图。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/GBN2.png"></div><p></p><h3 id="接收窗口"><a href="#接收窗口" class="headerlink" title="接收窗口"></a>接收窗口</h3><p>在 GBN 协议中，接收窗口大小总是 1。只有序号在接收窗口内的数据帧才接收。任何失序的分组都会被丢弃，需要重发。描述接收窗口控制只需 1 个变量 $R_n$，表示其期待下一次接收的帧，</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/GBN3.png"></div><p></p><h3 id="重传定时器-1"><a href="#重传定时器-1" class="headerlink" title="重传定时器"></a>重传定时器</h3><p>在 GBN 协议中，只使用一个计时器。接收窗口大小总是 1。当定时器超时，发送方重发所有未完成分组。例如，假设发送方已经发送了分组 6（$S_n=7$），但是唯一的计时器终止。如果 $S_f=3$，这意味着分组 3、4、5 和 6 没有被确认；发送方回退并重发分组 3、4、5 和 6。</p><h4 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h4><ul><li>发送分组。发送方会开启唯一的计时器。$S_n$ 的值增长，（$S_n=S_n+1$）如果达到窗口值进入阻塞状态。</li><li>如果 ACK 到达，其 ackNo 与一个未完成分组有关，那么发送方滑动窗口（令 $S_f=ackNo$），并且如果所有未完成分组都被确认（$ackNo=S_n$），那么关闭计时器。如果并不是所有未完成分组都被确认，那么重新开启计时器。</li><li>如果超时发生，发送方重发所有未完成分组并重新开启计时器。</li></ul><h4 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h4><ul><li>如果 $seqNo=R_n$ 的无错分组到达，之后窗口滑动，$R_n=（R_n+1）$。$ackNo=R_n$的 ACK 被发送。</li><li>如果 seqNo 在窗口之外的无错分组到来，分组被丢弃，但是 $ackNo=R_n$的 ACK 被发送。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/GBN4.png"></div><p></p><h3 id="发送窗口的最大值"><a href="#发送窗口的最大值" class="headerlink" title="发送窗口的最大值"></a>发送窗口的最大值</h3><p>当用 n 个比特进行帧编号时，接收窗口的大小为 1，则只有在发送窗口的大小$W_T ≤ 2^n − 1$时，连续 ARQ 协议才能正确运行。例如，当采用 2bit 编码时，发送窗口的最大值是 3 而不是 4。下图比较 4 与 3 两种情况。如果窗口的大小是 4 并且所有确认都丢失，发送方将会重传旧的所有 4 个帧。但是接收方等待接收的是新的 0 号帧，由于窗口匹配，接收 0 号帧，接收方认为接收的是新的 0 号帧，这是一个错误。如果窗口大小为 3 并且所有三个确认都丢失，那么超时并且重发所有 3 个分组，接收方现在期待 3 号帧，而不是 0 号帧，因此重传分组被正确丢弃。不会产生错误。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/GBN5.png"></div><br>为能正确区分重传的帧，应保证在$W_T+W_R$的窗口内不出现重复序号，即$W_T + W_R ≤ 2^n$，我们将 WT 和 WR 拼接在一起，在$W_T + W_R$窗口内如果出现重复序号，就会发生上述的错误，如果不出现重复的序号，就不会发生上述的错误。GBN 协议的接收窗口为 1，所以发送窗口最大为$2^n − 1$<p></p><h2 id="CSMA-CD"><a href="#CSMA-CD" class="headerlink" title="CSMA/CD"></a>CSMA/CD</h2><p>共享信道有一个基本问题，碰撞 （Collision）。若某时刻两帧同时发出，会相互重叠，结果使信号无法辨认，称为碰撞。如下图便是碰撞：</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/碰撞.png"></div><br>碰撞的结果是两个帧都变得无用。解决碰撞的思路大致有两类：<p></p><ul><li>一类思路是将工作做在前面，预防碰撞，即受控接入：各主机不能任意发送数据，必须服从一定的控制。如令牌环网，拥有令牌的主机可发送数据，没有令牌的主机只能接收数据，令牌如击鼓传花般依次传递。</li><li>另一类思路是将工作做在后面，撞就撞吧，做好事故的处理，即随机接入：所有主机都可以根据自己的意愿随机地发送数据。</li></ul><p>CSMA/CD（Carrier Sense Multiple Access with Collision Detection）载波监听多点接入/碰撞检测。载波监听（Carrier Sense）指监测信道上有无数据信号传输，监测方法是判断基带上是否有脉冲二进制 0 或 1。多点接入（Multiple Access）同时有多个站点连接在信道上。显然，使用随机接入的方式是无法避免碰撞的。在随机接入的情况下，需要完成几项工作：</p><ul><li>尽量减少碰撞</li><li>是否碰撞有明确结论</li><li><p>碰撞之后的事故处理</p><p>CSMA/CD 协议完成这些工作的原理，简缩为三句口诀。</p></li><li><p>先听后发</p></li><li>边发边听</li><li>冲突重发</li></ul><h3 id="先听后发"><a href="#先听后发" class="headerlink" title="先听后发"></a>先听后发</h3><p>我们当然希望尽量减少碰撞，想个什么办法呢？就是在发送数据帧之前，先监听信道。“载波监听”就是“发送前先监听”，如果信道上有数据帧，当然就先不发送数据帧，否则一发送数据帧就产生碰撞，碰撞了就毫无意义。当监听信道时，如果信道忙有数据帧，站点回去睡一段随机时间，然后再回来监听信道，这种策略称非坚持型 CSMA。当监听信道时，如果信道忙有数据帧。站点不是回去睡一会，而是蹲守在这儿，继续监听直到信道空闲，这种策略称坚持型 CSMA。当监听到信道空闲下来时，站点立即就发送数据，称 1-坚持型 CSMA。当监听到信道空闲下来时，站点并不立即发送数据，先抛一次硬币，如果是字就发，如果是花就不发，就是说以概率 p 发送数据，称 p-坚持型 CSMA。</p><h3 id="边发边听"><a href="#边发边听" class="headerlink" title="边发边听"></a>边发边听</h3><p>站点发出数据帧后，是否碰撞需要有明确的结论。就需要“碰撞检测”（Collision Detection）。如何检测呢？站点检测信道上的信号电压大小，当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，“碰撞检测”也称为“冲突检测”。</p><p>假设 A 站点与 B 站点是网络最远的两端，从 A 站点发出一数据帧，到达 B站点的所花费的时间为$\tau$，A 站点发出一数据帧，就在即将到达 B 站的时刻，B站发出一数据帧，立即发生碰撞，碰撞信号继续到达 A 站，A 站在经过时间 $2\tau$（两倍的端到端传播时延）发现碰撞。所以，$发送站点监听时间&gt;2\tau$，就可以得到是否碰撞的明确结论。$2\tau$ 也即称为争用期，或碰撞窗口。所以为得到是否碰撞的明确结论，只需要$监听时间&gt;2\tau$就可以了。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/碰撞窗口.png"></div><p></p><h3 id="冲突重发"><a href="#冲突重发" class="headerlink" title="冲突重发"></a>冲突重发</h3><p>发生碰撞，两个数据帧都损坏，当然需要重发。但是如果两个站点都立即重发数据帧，又会再次碰撞，两个站点发送时刻最好能够错开一些。CSMA/CD 协议使用<strong>截断二进制指数退避算法</strong>，发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。</p><ul><li>重传次数 k，$k=Min[重传次数,10]$</li><li>从整数集合$[0,1,…,(2^k-1)]$中随机地取出一个数，记为 r。</li><li>重传所需的时延就是 r 倍的基本退避时间。基本退避时间一般是取为争用期。</li></ul><p>当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。使用 CSMA/CD 协议后不能进行全双工通信而只能进行双向交替通信（半双工通信）。每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。</p><h2 id="10BASE-T-以太网"><a href="#10BASE-T-以太网" class="headerlink" title="10BASE-T 以太网"></a>10BASE-T 以太网</h2><p>10Base-T以太网使用的是1-坚持型CSMA / CD。</p><p>10BASE-T 以太网不用同轴电缆而用无屏蔽双绞线，降低了成本，还增加了一种可靠性非常高的设备，叫做集线器（hub）。正是这两个原因，使得 10BASE-T以太网拥有很低的成本和很高的可靠性，迅速在局域网中占据了统治地位。10BASE-T 以太网定义：</p><ul><li>争用期的长度为 51.2 us，而$监听时间 &gt; 2 \tau$ 便等价于$发送数据帧的时间 &gt; 2\tau$。可得：$\frac{帧长L}{10Mbps}&gt;51.2 \mu s$，即$L &gt; 512bit$。最短帧长 64 字节。</li><li>帧间最小间隔为 9.6us，因为要给双方留下缓冲时间。</li><li>站点到集线器的距离不超过 100m，为了保证双绞线上的信号不会出错。</li><li>如果数据帧太长就会出现有的主机长时间不能发送数据，而且有的发送数据可能超出接收端的缓冲区大小，造成缓冲溢出。为避免单一主机占用信道时间过长，规定了以太网帧的数据部分最大长度为1500。</li></ul><h2 id="网卡"><a href="#网卡" class="headerlink" title="网卡"></a>网卡</h2><p>在主机内部，需要 10BASE-T 的网络接口板又称为通信适配器（adapter）或网络接口卡 NIC(Network Interface Card)，或“网卡”。网络适配器的重要功能：</p><ul><li>对数据进行串行/并行传输的转换</li><li>编码与译码即曼彻斯特编码与译码。</li><li>链路管理主要是 CSMA/CD 协议的实现。</li><li>数据的封装与解封封装以太网帧。</li></ul><p>网卡的第一，第二项功能属于物理层的功能。第三项 CSMA/CD 协议的原理上文也介绍了，在此主要介绍一下以太网帧，也称 MAC 帧。网络适配器工作在数据链路层和物理层。生产网卡时，在网卡的 ROM 固化了 6 字节的 MAC 地址，因此 MAC 地址也叫做硬件地址(hardware address)或物理地址。MAC 地址唯一标识了一块网卡。MAC 地址字段是 6 字节（48 位），前三个字节（即高位 24 位），是生产厂家标识，称为组织唯一标识符，后三个字节（即低位 24 位）由厂家自行指派的产品串号，称为扩展唯一标识符，必须保证串号没有重复。网卡将上一层交下来的数据加上首部和尾部，成为以太网的帧。接收时将以太网的帧剥去首部和尾部，然后送交上一层。常用的以太网 MAC 帧格式有两种标准：DIXEthernetV2 标准和 IEEE 的 802.3 标准，最常用的 MAC 帧是以太网 V2 的格式。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/以太网V2格式.png"></div><p></p><h3 id="网卡工作要点"><a href="#网卡工作要点" class="headerlink" title="网卡工作要点"></a>网卡工作要点</h3><ul><li>适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中，准备发送。</li><li>若适配器检测到信道空闲，就发送这个帧。若检测到信道忙，则继续检测并等待信道转为空闲（加上 96 比特时间），然后发送这个帧。</li><li>在发送过程中继续检测信道，若一直未检测到碰撞，就顺利把这个帧成功发送完毕。若检测到碰撞，则中止数据的发送，并发送人为干扰信号。</li><li>在中止发送后，适配器就执行指数退避算法，等待 r 倍 512 比特时间后，返回到步骤 2。</li></ul><p>对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。早期以太网采用无源的总线结构。现在采用以太网交换机的星形结构成为以太网的首选拓扑。总线以太网使用 CSMA/CD 协议，以半双工方式工作。以太网<br>交换机以全双工方式工作，不使用共享总线，没有碰撞问题，因此不使用CSMA/CD 协议。但仍然采用以太网的帧结构。</p><h2 id="网桥与交换机"><a href="#网桥与交换机" class="headerlink" title="网桥与交换机"></a>网桥与交换机</h2><p>我们看下面一个拓扑，某学院有三个系，各自有一个以太网，三个以太网是三个独立的碰撞域，如果用集线器连成一个更大的以太网，同时也形成一个更大的碰撞域。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/碰撞扩大.png"></div><p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/碰撞扩大2.png"></div><br>连接的范围扩大了，但碰撞也多了，能不能只扩大范围，不扩大碰撞呢？<p></p><h3 id="网桥"><a href="#网桥" class="headerlink" title="网桥"></a>网桥</h3><p>有一种网络设备，称为网桥（bridge），能只扩大范围，不扩大碰撞。网桥工作在数据链路层，其内部维护一张转发表，根据 MAC 地址转发数据帧。当网桥收到一个帧时，根据此帧的目的 MAC 地址，检索转发表，然后再转发帧到接口。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网桥.png"></div><br>我们看下面的一个拓扑图，先不考虑网桥的转发表是怎么来的，先看一下网桥 B1 和网桥 B2 的转发表的最终形态，可以看出，转发表的本质就是拓扑图的描述，推想一下，这是必然的，网桥若要正确转发数据帧，就需要知道各主机与其的位置关系。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网桥表.png"></div><br>那么，这张转发表又是怎么来的呢？网桥 B1 和网桥 B2 刚上电时，其内部转发表都是空表，这时，主机 A 给主<br>机 B 发送一数据帧，网桥 B1 的接口 1 收到这帧，网桥 B1 能判断出主机 A 在它的接口 1 侧，但判断不出主机 B 在哪侧，首先转发，把帧向网桥除接口 1 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“A 接口 1”填入转发表，网桥 B1 就学到 1 个条目。网桥 B2 收到网桥 B1 的转发帧，网桥 B2 也能判断出主机 A 在它的接口 1 侧，但判断不出主机 B 在哪侧，首先转发，把帧向网桥除接口 1 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“A 接口 1”填入转发表，网桥 B2 也学到 1 个条目。<p></p><p>接下来，第二个数据帧是主机 F 给主机 C 发送的，网桥 B2 的接口 2 收到这帧，网桥 B2 能判断出主机 F 在它的接口 2 侧，但判断不出主机 C 在哪侧，首先转发，把帧向网桥除接口 2 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“F 接口 2”填入转发表，网桥 B2 就学到 2 个条目。网桥 B1 收到网桥 B2 的转发帧，网桥 B1 也能判断出主机 F 在它的接口 2 侧，但判断不出主机 C 在哪侧，首先转发，把帧向网桥除接口 2 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“F 接口 2”填入转发表，网桥 B1 也学到 2 个条目。</p><p>第三个数据帧是主机 B 给主机 A 发送的，网桥 B1 的接口 1 收到这帧，网桥B1 能判断出主机 B 在它的接口 1 侧，由于已经学到 2 个条目，网桥 B1 由前 2个条目，知道主机 A 在接口 1 侧的，所以不转发。第二，将“B 接口 1”填入转发表，网桥 B2 就学到 3 个条目。因为网桥 1 没转发，网桥 B2 没收到任何数据帧，网桥 B2 仍维持着 2 个条目。</p><p>经过一段时间，各主机发送了很多数据帧，网桥 B1 和网桥 B2 就学习到了完整的转发表。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网桥表2.png"></div><br>但是需要注意，在下图中三个碰撞域内是可以进行通信，但是跨碰撞域之后还是会产生碰撞。如A给D发消息时，B和C不能进行通信。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网桥.png"></div><p></p><h3 id="交换机-1"><a href="#交换机-1" class="headerlink" title="交换机"></a>交换机</h3><p>网桥只有 2 个接口，可是谁规定网桥只能有 2 个接口呢，网桥也可以有更多接口，这就是以太网交换机，以太网交换机（switch）实质上就是一个多接口的网桥。通常都有十几个或更多的接口。每个接口都直接与一个单台主机或另一个以太网交换机相连，工作在全双工方式。以太网交换机工作原理也是按转发表转发数据帧，工作在数据链路层，是第二层交换机，其内部的帧交换表（又称为地址表）是通过自学习算法自动地逐渐建立起来的。</p><p>我们看下面的一个拓扑图，先不考虑交换机的转发表是怎么来的，先看一下交换机的转发表的最终形态，可以看出，转发表的本质就是拓扑图的描述，推想一下，这是必然的，交换机若要正确转发数据帧，就需要知道哪个接口与哪个主机相连。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/交换机表1.png"></div><br>那么，这张转发表又是怎么来的呢？交换机启动时，其内部转发表是空表。A 先向 B 发送一帧，交换机收到帧后，先执行转发功能。查找交换表，如果没有查到，洪泛，交换机向除接口 1 以外的所有的接口广播这个帧。再执学习发功能，把这个帧的源地址 A 和接口 1 写入交换表中。当所有主机都发送过数据帧后，交换机就将交换表学完整了。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/交换机表2.png"></div><br>考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就自动被删除。以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。交换机工作原理是按转发表（MAC 表）转发数据帧，转发表的本质就是拓扑图的描述。要把交换机转发表的本质牢固的记住：<strong>交换机就是要知道哪个接口与哪个主机相连。</strong><p></p><h3 id="MAC-表抖动与广播风暴"><a href="#MAC-表抖动与广播风暴" class="headerlink" title="MAC 表抖动与广播风暴"></a>MAC 表抖动与广播风暴</h3><p>网桥和交换机的使用可能会发生一下问题，我们以网桥举例：</p><ul><li>会发生 MAC 表抖动（flapping）的问题：就是说同一个MAC地址在一台交换机上的两个及以上接口都学习到，导致MAC地址表中关于此MAC地址与交换机的端口对应不断改变。</li><li>数据帧会循环兜圈子，形成广播风暴。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网桥网络风暴.png"></div><br>在拓扑图上，我们可以看到 帧F 到 网桥1 的时候将 F 转发出去，设为 F1，此时 网桥1 学习 到MACA（主机A的MAC地址）在下方接口。F1 到 F2 是 网桥2 学习到 MACA 在 上方接口，但是 帧F 到达 网桥2 的时候网桥2学习到MACA在下方接口，这便是MAC表抖动。同样的 F2 到 网桥1 的时候 网桥1 学习到 MACA 在上方接口，也会发生抖动。（注意：F、F1、F2的MAC地址一致）<p></p><p>如果数据帧按照我们上面所述的方式运行，他们会在网桥1和网桥2之间不停的转圈。</p><p>至于交换机自然也会出现上述的问题。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/交换机网络风暴.png"></div><br>解决的办法，就是在逻辑上将环打断，环打断就是棵树。一句话，就是将环打断生成树，简称为“生成树”。在网桥或交换机上运行生成树协议 STP（Spanning Tree Protocol）。生成树协议的要点是：不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。<p></p><h2 id="无线局域网与-CSMA-CA"><a href="#无线局域网与-CSMA-CA" class="headerlink" title="无线局域网与 CSMA/CA"></a>无线局域网与 CSMA/CA</h2><p>IEEE802.11是一个有固定基础设施的无线局域网WLAN（Wireless Local Area Network）的国际标准。简单地说，802.11 就是无线以太网的标准：使用星形拓扑，其中心叫做接入点 AP(Access Point)，在 MAC 层使用 CSMA/CA 协议，802.11 无线局域网又称为 Wi-Fi（Wireless-Fidelity，意思是“无线保真度”）。以下讨论都是这种无线局域网。</p><p>无线局域网最小构件是基本服务集 BSS（Basic Service Set），基本服务集里面的基站叫做接入点 AP（AccessPoint，AP 的逻辑功能等同与以太网的集线器），一个基本服务集通过接入点 AP 连接到一个主干分配系统 DS（Distribution System），然后再接入到另一个基本服务集，构成了一个扩展的服务集 ESS。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/ESS.png"></div><p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/AP和集线器对等.png"></div><p></p><h3 id="无线局域网没有碰撞检测"><a href="#无线局域网没有碰撞检测" class="headerlink" title="无线局域网没有碰撞检测"></a>无线局域网没有碰撞检测</h3><p>无线局域网逻辑上也是共享信道，采用的也是随机接入的思路。但是，无线局域网与有线局域网有一个重要的差异，无线局域网没有碰撞检测（Collision Detection）。</p><ul><li>“碰撞检测”要求一个站点在发送本站数据的同时，还必须不间断地检测信道，但接收到的信号强度往往会远远小于发送信号的强度，在无线局域网的设备中要实现这种功能就花费过大。</li><li>隐蔽站问题，如下图，有 ABCD 四个站，但 A 只知道有 B，不知道有 CD。A 和 C 互相检测不到对方的无线信号时，都以为 B 是空闲的，都向 B 发送数据，结果发生碰撞。隐蔽站问题使“碰撞检测”失去意义。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/隐蔽站问题.png"></div><br>由于以上两个原因，无线局域网没有碰撞检测。为什么没有碰撞检测就成为问题了呢？因为没有碰撞检测引发了两个问题：<p></p><ul><li>怎么确定发出的数据帧是否发生碰撞，是否碰撞要有明确的结论，这个结论怎么下？</li><li>在碰撞发生时，就没有感觉，撞了发送方也不会停止发送数据，仍发送数据，直到发送完才停止。不是“撞-停”的情况，而是“撞撞撞撞撞撞···”的情况，碰撞的损失过大。</li></ul><p>这两个问题都需要解决。先说第一个问题，是否碰撞的结论怎么下？无线网使用了停止等待协议，由接收方发送 ACK 帧来表示正确收到数据帧，否则引发超时重传。再说第二个问题，对于这个问题的解决办法，当然就是“尽量不碰撞”。无线网为了“尽量不碰撞”，设计了一个复杂的协议 CSMA/CA。注意，CSMA/CA协议只能做到“尽量少碰撞”，做不到“完全不碰撞”。第一个问题仍需解决，无线网的 CSMA/CA 替代不了无线网的停等协议。</p><h3 id="CSMA-CA-协议"><a href="#CSMA-CA-协议" class="headerlink" title="CSMA/CA 协议"></a>CSMA/CA 协议</h3><p>无线局域网没有碰撞检测，所以有线的 CSMA/CD 就被阉割为 CSMA，可不甘心，还想进一步的减少碰撞，就又加了一个 CA（Collision Avoidance 碰撞避免）功能。802.11 就使用 CSMA/CA 协议。而在使用 CSMA/CA 的同时，还增加使用停止等待协议。</p><h4 id="帧间间隔-IFS"><a href="#帧间间隔-IFS" class="headerlink" title="帧间间隔 IFS"></a>帧间间隔 IFS</h4><p>所有的站在完成发送后，必须再等待一段很短的时间（继续监听）才能发送下一帧。这段时间的通称是帧间间隔 IFS（Inter Frame Space）。SIFS，即短（Short）帧间间隔，长度为 28us，使用 SIFS 的帧类型有：ACK 帧、CTS 帧。DIFS，即分布协调功能帧间间隔，长度为 128us。DIFS 用来发送数据帧和管理帧。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/IFS.png"></div><p></p><h3 id="争用窗口（二进制指数退避）"><a href="#争用窗口（二进制指数退避）" class="headerlink" title="争用窗口（二进制指数退避）"></a>争用窗口（二进制指数退避）</h3><p>信道从忙态变为空闲时，任何一个站要发送数据帧时，不仅都必须等待一个DIFS 的间隔，而且还要进入争用窗口，各站就要执行退避算法。802.11 使用二进制指数退避算法。这样做就减少了发生碰撞的概率。但其避退算法和CSMA/CD的有区别。第i次退避就在$2^{2+i}$个时隙中随机地选择一个。这就是说，第1次退避是在8个时隙（而不是2个）中随机选择一个，而第2次退避是在16个时隙（而不是4个）中随机选择一个。 这样做的目的是减少碰撞。</p><p>发送算法如下：</p><ol><li>如果某站点检测到信道空闲，会等待一个DIFS发送该帧。</li><li>否则该站点选取一个随机值进行避退，并且在检测到信道忙的时候递减该值。当检测不忙的时候计数值保持不变。</li><li>当计数值减为0的时候（此时信道一定为空闲），该站点发送整个数据帧并等待确认。</li><li>如果发送方收到确认，发送站点知道他的帧被目的站正确接收了，如果该站点要发送另一帧它需要从第二步开始进行。如果未收到，执行回退算法，此次会在一个更大的范围里选取。</li></ol><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/争用窗口.png"></div><br>需要注意，上图中的退避区间内退避算法得到的计数值不一定在减少。冻结指的就是再次检测到信道忙的时候不再减少计数值。<p></p><h3 id="信道预约"><a href="#信道预约" class="headerlink" title="信道预约"></a>信道预约</h3><p>为了更好地解决隐蔽站带来的碰撞问题，802.11 允许要发送数据的站对信道进行预约。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/信道预约.png"></div><p></p><h3 id="有线与无线的对比"><a href="#有线与无线的对比" class="headerlink" title="有线与无线的对比"></a>有线与无线的对比</h3><p>无线局域网与有线局域网都是使用随机接入的方式，都是无法绝对避免碰撞的。在这种情况下，都需要考虑以下问题：尽量减少碰撞、是否碰撞要有明确结论、碰撞之后的事故处理。简单做一对比：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/有线无线对比.png"></div><br>无线网中碰撞造成的损失更大，就需要在减少碰撞的方面做更多的工作，精心设计了 CSMA/CA 协议，包含帧间间隔，争用窗口（二进制指数退避），信道预约三种机制，但仍无法完全避免碰撞。由于没有碰撞检测，是否碰撞的明确结论，由接收方发送 ACK 确认帧机制。碰撞事故处理是空，是因为将重发中的二进制指数退避已经融合到 CSMA/CA 协议中。<p></p><h3 id="802-11-局域网的-MAC-帧"><a href="#802-11-局域网的-MAC-帧" class="headerlink" title="802.11 局域网的 MAC 帧"></a>802.11 局域网的 MAC 帧</h3><p>802.11 帧共有三种类型：控制帧、数据帧和管理帧。只简单讨论数据帧。数据帧的三大部分，MAC 首部，共 30 字节。帧的复杂性都在帧的首部。帧主体，数据部分不超过 2312 字节，通常都是小于 1500 字节。帧检验序列 FCS 是尾部，共 4 字节。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/无线网帧.png"></div><br>802.11 数据帧最特殊的地方就是有四个地址字段。地址 4 用于自组网络（博主暂未接触）。我们在这里只讨论前三种地址。地址 1 总是帧将访问的下一个设备的地址，地址 2 总是帧离开的前一个设备的地址，如果地址 1 没有定义最后的目的地址，地址 3 就是最后的目的站点的地址，如果地址 2 没有定义原始源地址，地址 3 就是原始源站点地址。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/局域网帧.png"></div><p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/无线网帧举例.png"></div><br>站点 A 向 B 发送数据帧，但这个数据帧必须经过 AP 转发。首先站点 A 发送数据帧到 AP1，然后 AP1 把数据帧发送给 B。举例：A-&gt;AP1 时：<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/111.png"></div><p></p><h2 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h2><p>ARP（Address Resolution Protocol），根据 IP 地址查询MAC 地址。ARP 协议的工作原理如下图，有 ARP 请求（Request）和 ARP 回答（Reply）两个报文。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/arp工作图解.png"></div><br>ARP 报文封装成 Mac 帧，是 Mac 帧的负载，mac 帧类型值 0806 指示 mac 帧的数据部分是 ARP 报文。ARP 请求（Request）是广播，ARP 回答（Reply）是单播，见下图：ARP 请求报文所封装的 Mac 帧，目的 Mac 地址是 FF-FF-FF-FF-FF-FF，这 个地址是广播地址，交换机就会广播这个帧。ARP 请求报文和校园广播的大喇叭是不是很像呢？如果目的主机也在你的网络里，你用大喇叭喊它，要来它的mac 地址，就可以封装 mac 帧了。注意，ARP 直接封装为 MAC 帧，不是封装为 IP 报。从这点看，我个人更赞同将 ARP 理解为链路层协议。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/arp报文举例.png"></div><br>报文格式：<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/arp格式.png"></div><p></p><h2 id="RARP"><a href="#RARP" class="headerlink" title="RARP"></a>RARP</h2><p>ARP 是设备通过自己知道的IP地址来获得自己不知道的物理地址的协议。假如一个设备不知道它自己的IP地址，但是知道自己的物理地址，应该怎么办呢？RARP（逆地址解析协议）正是针对这种情况的一种协议。</p><p>RARP以与ARP相反的方式工作。RARP发出要反向解析的物理地址并希望返回其对应的IP地址，应答包括由能够提供所需信息的RARP服务器发出的IP地址。虽然发送方发出的是广播信息，RARP规定只有RARP服务器能产生应答。许多网络指定多个RARP服务器，这样做既是为了平衡负载也是为了作为出现问题时的备份。</p><h2 id="网络通信分类"><a href="#网络通信分类" class="headerlink" title="网络通信分类"></a>网络通信分类</h2><p>不同主机间的数据通信可以分为三种：两个主机属于同一个网、两个主机属于相邻的两个网中、两个主机属于不相邻的两个网络中。其中第一类是链路层所解决的问题，而后两类都是网络需要解决的问题，图示如下。为了叙述方便，博主将第二类情况简称“两个网”，第三类情况简称“三个网”，但实际上“三个网”的理论可以推广到“n个网”中。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网络通信分类.png"></div><p></p><h2 id="传统的IP地址划分"><a href="#传统的IP地址划分" class="headerlink" title="传统的IP地址划分"></a>传统的IP地址划分</h2><p>传统的IP地址划分规则中，地址由两个部分组成：网络号 + 主机号。具有相同网络号的IP地址属于同一个网络。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/网络号举例.png"></div><br>同时网络被划分为5类：<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/地址分类.png"></div><br>但是并不是所有的主机号都能被用来标识主机，主机号全为0的IP地址被称为网络地址，标识一个网络。主机号全为1的地址被称为广播地址，用于向某个网络的所有主机广播。例：主机 212.111.44.136 所在网络的广播地址为212.111.44.255。而对于任意一个主机若想向其所在的网络中广播都可以使用255.255.255.255。按照这个划分我们可以得到各类地址的特性：<p></p><h3 id="各类地址特性"><a href="#各类地址特性" class="headerlink" title="各类地址特性"></a>各类地址特性</h3><h4 id="A类地址"><a href="#A类地址" class="headerlink" title="A类地址"></a>A类地址</h4><ul><li><p>前1字节标识网络地址，后3字节标识主机地址</p></li><li><p>每个网络最多可容纳（$2^{24} －2$）台主机</p></li><li><p>从高位起，前1位为“0”，第1字节用十进制表示的取值范围为“0～127”</p></li><li><p>具有A类地址特征的网络总数为126个</p></li></ul><h4 id="B类地址"><a href="#B类地址" class="headerlink" title="B类地址"></a>B类地址</h4><ul><li>前2字节标识网络地址，后2字节标识主机地址</li><li>每个网络最多可容纳（$2^{16} －2$）台主机</li><li>从高位起，前2位为“10”，第1字节用十进制表示的取值范围为“128～191”</li><li>具有B类地址特征的网络总数为 $2^{14} －1$ 个</li></ul><h4 id="C类地址"><a href="#C类地址" class="headerlink" title="C类地址"></a>C类地址</h4><ul><li>前3字节标识网络地址，后1字节标识主机地址</li><li>每个网络最多可容纳254台主机</li><li>从高位起，前3位为“110”，第1字节用十进制表示的取值范围为“192～223”</li><li>具有C类地址特征的网络总数为 $2^{21} －1$个</li></ul><h4 id="D类地址"><a href="#D类地址" class="headerlink" title="D类地址"></a>D类地址</h4><ul><li>多播通信地址（multicast address）</li><li>从高位起，前4位为“1110”，第1字节用十进制表示的取值范围为“224－239”，用于标识multicast通信地址</li><li>后28位用于区分不同的multicast组</li></ul><h4 id="E类地址"><a href="#E类地址" class="headerlink" title="E类地址"></a>E类地址</h4><ul><li>从高位起，前4位为“1111”，第1字节用十进制表示的取值范围为“240－255”，用于标识E类地址</li><li>后28位留作它用</li></ul><h2 id="划分子网"><a href="#划分子网" class="headerlink" title="划分子网"></a>划分子网</h2><p>早期的 IP 地址的设计确实不够合理。会存在如下问题：</p><ul><li>IP 地址空间的利用率有时很低。</li><li>给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。</li><li>两级的 IP 地址不够灵活。</li><li>网络很快就被分配完了。</li></ul><p>所以从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址。但划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。其实现思路就是从主机号借用若干个比特作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个比特。</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/划分子网.png"></div><p></p><h2 id="CIDR"><a href="#CIDR" class="headerlink" title="CIDR"></a>CIDR</h2><p>划分子网后仍然没有解决IP V4的问题，1992年互联网的三大危机：</p><ul><li>B类地址耗尽</li><li>路由表爆炸</li><li>IP地址整体耗尽</li></ul><p>无分类域间路由选择，Classless Inter-Domain Routing，是为解决上述危机而开发的一种方案。</p><p>在CIDR技术中，IP 地址由两部分组成，网络前缀 + 主机号。CIDR 还使用“斜线记法”(slash notation)，它又称为CIDR记法，即在IP地址后面加上一个斜线“/”，然后写上网络前缀所占的比特数（这个数值对应于三级编址中子网掩码中比特 1 的个数）。CIDR 将网络前缀都相同的连续的 IP 地址组成“CIDR地址块”。</p><ul><li>128.14.32.0/20 表示的地址块共有 212 个地址（因为斜线后面的 20 是网络前缀的比特数，所以主机号的比特数是 12）。</li><li>这个地址块的起始地址是 128.14.32.0。</li><li>在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”。</li><li>128.14.32.0/20 地址块的最小地址：128.14.32.0。128.14.32.0/20 地址块的最大地址：128.14.47.255</li><li>全 0 和全 1 的主机号地址一般不使用。</li></ul><h3 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h3><p>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由，减少了路由器之间的路由信息交换。路由聚合也称为构成超网。（super netting）。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/CIDR划分IP地址.png"></div><br>这个 ISP 共有 6 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每一个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，只需用路由聚合后的 1 个项目 206.0.64.0/18 就能找到该 ISP。 需要注意的是若是因特网中某路由器想标识该ISP，只需要记录206.0.64.0/18，但是对于ISP内的路由器还是会将各子地址块的网络地址记录。<p></p><h3 id="最长前缀匹配"><a href="#最长前缀匹配" class="headerlink" title="最长前缀匹配"></a>最长前缀匹配</h3><ul><li>使用 CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果。</li><li>应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配（longest-prefix matching）。</li><li>网络前缀越长，其地址块就越小，因而路由就越具体。</li><li>最长前缀匹配又称为最长匹配或最佳匹配。</li></ul><h2 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h2><p>如果把计算机网络与快递网络做类比，假设东北大学是一个网络，西南大学是一个网络，东北大学想向西南大学寄点东西那么它需要通过自己学校的驿站寄到西南大学的驿站。网络之间进行通信的时候也需要有一个这种“驿站”。这便是网关。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/两个网.png"></div><br>默认网关就是为主机转发分组的路由器网络接口，就是主机的第一跳路由器，网关就是你邮信时需要找到的校园邮筒的地址，即默认网关是在网关中选一个。主机 H1 的默认网关是路由器的 E0 接口。“两个网”时，需要正确配置网关。网关是主机的第一跳路由器。举例：假设主机 H2 的 E0 接口 IP 地址 100.16.0.1，掩码 255.255.0.0，E1 接口 IP 地址 100.17.0.1，掩码 255.255.0.0：主机 H1 本地连接 IP 地址 100.16.0.2，掩码 255.255.0.0，默认网关 100.16.0.1。主机 H3 的默认网关是什么呢？100.16.0.1。主机 H5 的默认网关又是什么？是100.17.0.1。<p></p><p>在“多个网”时，多个网络如何互联？我们看下面的网络拓扑图，这是 3 个路由器连接了 4 个网络。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/多个网.png"></div><br>假设网 1 内部有一个主机 H1，网 1 内部只有一个路由器 R1，因此默认网关只能设为 R1 的 15.0.0.4，再配置好 IP 地址，就可以与外网通信了。假设网 2 内部有一个主机 H3，在网 2 内有两个路由器 R1 和 R2，可以任选一个做默认网关，假设选 R2，默认网关设为 20.0.0.9，再配置好 IP 地址，就可以与外网通信了。<p></p><p>再讨论如何配置路由器。路由器不傻，只要配置好路由器接口的 IP 地址，路由器会从接口的 IP 地址计算出网络地址，也就是说路由器能看清自己身边的网络。至于路由器是怎么看到的，在网络层-网络构建中会解释。</p><h2 id="数据转发"><a href="#数据转发" class="headerlink" title="数据转发"></a>数据转发</h2><p>之前说了这么多都是在做铺垫，其实主要想介绍的一点是路由器是如何转发不同网络中的数据包。算法如下：</p><ol><li>从收到的分组的首部提取目的 IP 地址 D。</li><li>先用各网络的子网掩码和 D 逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行3。</li><li>若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行4。</li><li>对路由表中的每一行的子网掩码和 D 逐位相“与”，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行5。</li><li>若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行6。</li><li>报告转发分组出错。</li></ol><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/转发举例.png"></div><br>R1的路由表：<p></p><table><thead><tr><th style="text-align:center">目的网络地址</th><th style="text-align:center">子网掩码</th><th style="text-align:center">下一跳</th></tr></thead><tbody><tr><td style="text-align:center">128.30.33.0</td><td style="text-align:center">255.255.255.128</td><td style="text-align:center">接口0</td></tr><tr><td style="text-align:center">128.30.33.128</td><td style="text-align:center">255.255.255.128</td><td style="text-align:center">接口1</td></tr><tr><td style="text-align:center">128.30.36.0</td><td style="text-align:center">255.255.255.0</td><td style="text-align:center">R2</td></tr></tbody></table><p>R2的路由表：</p><table><thead><tr><th style="text-align:center">目的网络地址</th><th style="text-align:center">子网掩码</th><th style="text-align:center">下一跳</th></tr></thead><tbody><tr><td style="text-align:center">128.30.33.0</td><td style="text-align:center">255.255.255.128</td><td style="text-align:center">R1</td></tr><tr><td style="text-align:center">128.30.33.128</td><td style="text-align:center">255.255.255.128</td><td style="text-align:center">接口0</td></tr><tr><td style="text-align:center">128.30.36.0</td><td style="text-align:center">255.255.255.0</td><td style="text-align:center">接口1</td></tr></tbody></table><p>在上图中，若H1（128.30.33.13）想给H3（128.30.36.12）发送数据，我们来分析一下具体的过程：</p><ol><li>主机 H1 首先将本子网的子网掩码 255.255.255.128与分组的 IP 地址 128.30.36.12 逐位相“与”（AND 操作）。即255.255.255.128 AND 128.30.36.12 得到 128.30.36.0，发现不等于128.30.33.0，所以他要将数据报发送到它的默认网关（128.30.33.1）上。</li><li>R1收到这个地址后，会遍历所有的子网掩码，进行按位与后再和对应的网络地址做比对。可以得到转发给R2计算过程如下：<ol><li>255.255.255.128 AND 128.30.36.12 = 128.30.36.0 不等于 128.30.33.0</li><li>255.255.255.128 AND 128.30.36.12 = 128.30.36.0 不等于 128.30.33.128、</li><li>255.255.255.0 AND 128.30.36.12 等于 128.30.36.0</li></ol></li><li>R1收到这个地址后，会遍历所有的子网掩码，进行按位与后再和对应的网络地址做比对。可以得到转发给接口1。</li><li>然后便是链路层需要解决的问题。</li></ol><h3 id="ARP深入"><a href="#ARP深入" class="headerlink" title="ARP深入"></a>ARP深入</h3><p>只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。可以分为四种情况：</p><ul><li>发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li><li>发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。</li><li>发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。</li></ul><h2 id="IP数据报的格式"><a href="#IP数据报的格式" class="headerlink" title="IP数据报的格式"></a>IP数据报的格式</h2><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/IP数据报的格式.png"></div><p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/IP首部.png"></div><p></p><ul><li>版本：占 4 位，指 IP 协议的版本目前的 IP 协议版本号为 4 （即 IPv4）。</li><li>首部长度：占 4 位，可表示的最大数值是 15 个单位（一个单位为 4 字节）因此 IP 的首部长度的最大值是 60 字节。</li><li>区分服务：占 8 位，用来获得更好的服务在旧标准中叫做服务类型，但实际上一直未被使用过。1998 年这个字段改名为区分服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段。</li><li>总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。</li><li>标识（identification）：占 16 位，它是一个计数器，用来产生数据报的标识。</li><li>标志（flag）：占 3 位，目前只有前两位有意义。标志字段的最低位是 MF（More Fragment）。MF = 1 表示后面“还有分片”。MF = 0 表示最后一个分片。标志字段中间的一位是 DF（Don’t Fragment）。只有当 DF=0 时才允许分片。</li><li>片偏移(13 位)指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/分片举例.png"></div><p></p><ul><li><p>生存时间（8 位）记为 TTL（Time To Live）：数据报在网络中可通过的路由器数的最大值。</p></li><li><p>协议（8 位）：指出此数据报携带的数据使用何种协议，即运输层协议。</p></li><li>首部检验和（16 位）字段只检验数据报的首部不检验数据部分。</li><li>源地址和目的地址都各占 4 字节。</li></ul><h2 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h2><h3 id="私有地址"><a href="#私有地址" class="headerlink" title="私有地址"></a>私有地址</h3><p>在现在的网络中，IP地址分为公网IP地址和私有IP地址。公网IP是在Internet使用的IP地址，而私有IP地址则是在局域网中使用的IP地址。私有IP地址是一段保留的IP地址。只使用在局域网中，无法在Internet上使用。</p><ul><li>A类私有地址：10.0.0.0～10.255.255.255</li><li>B类私有地址：172.16.0.0～172.31.255.255</li><li>C类私有地址：192.168.0.0～192.168.255.255</li></ul><p>这些地址可以在任何组织或企业内部使用，和其他Internet地址的区别就是，仅能在内部使用，不能作为全球路由地址。这就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到Internet，就可以使用这些地址而不用向 IANA（The Internet Assigned Numbers Authority，互联网数字分配机构，是负责协调一些使Internet正常运作的机构） 提出申请，而在内部的路由管理和报文传递方式与其他网络没有差异。</p><p>对于有Internet访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署NAT网关，在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有IP地址了。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/NAT.jpg"></div><p></p><h2 id="自治系统"><a href="#自治系统" class="headerlink" title="自治系统"></a>自治系统</h2><p>Autonomous System，AS。每个AS由一组通常处在相同管理控制下的路由器组成。一个ISP中的路由器以及连接他们的线路可以构成一个AS，一个ISP也可以将他们的网络划分成多个AS。每个AS由一个唯一的ASN来标识。所以在构建网络的时候，我们需要对 AS 内的网络和 AS 之外的网络进行区分。这两个统称为路由协议。</p><h3 id="内部网关协议"><a href="#内部网关协议" class="headerlink" title="内部网关协议"></a>内部网关协议</h3><p>Interior Gateway Protocol （IGP），用于自治系统（AS）内部的路由交换也叫做域内路由选择（intradomain routing），如 RIP 和 OSPF 协议</p><h3 id="外部网关协议"><a href="#外部网关协议" class="headerlink" title="外部网关协议"></a>外部网关协议</h3><p>Exterior Gateway Protocol （EGP），用于不同自治系统（AS）之间的路由交换，也叫做域间路由选择（interdomain routing），目前使用最多的是 BGP-4。</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/路由选择协议.png"></div><p></p><h3 id="路由选择算法分类"><a href="#路由选择算法分类" class="headerlink" title="路由选择算法分类"></a>路由选择算法分类</h3><p>常用的分类是：每个路由器知道的是全局的信息还是分散的信息？</p><ul><li>全局的<ul><li>所有的路由器具有完整的拓扑和链路费用信息</li><li>“链路状态(L-S)”算法</li><li>应用于RIP协议</li></ul></li><li>分散的<ul><li>路由器只知道物理连接的邻居和到邻居的链路费用</li><li>迭代的计算过程，与邻居交换信息</li><li>“距离向量(D-V)”算法</li><li>应用于OSPF协议</li></ul></li></ul><h2 id="RIP协议"><a href="#RIP协议" class="headerlink" title="RIP协议"></a>RIP协议</h2><p>基于距离向量的分布式路由选择协议，规定：</p><ul><li>“距离”为到目的网络所经过的路由器数。</li><li>从一路由器到直接连接的网络的距离定义为 1。</li><li>RIP允许一个通路最多包含15个路由器，多于15个路由器时不可达。</li><li>RIP不能在两个网络之间同时使用多条路由，它选择一个具有最少路由器的路由，具有相同路径长度的路规定先入为主。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>仅和相邻路由器交换信息。</li><li>交换的信息是当前本路由器所知道的全部信息，即自己的路由表。</li><li>按固定的时间间隔交换路由信息，例如，每隔 30 秒。</li></ul><h3 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h3><p>收到相邻路由器（其地址为 X）的一个 RIP 报文：</p><ol><li>先修改此 RIP 报文中的所有项目：将“下一跳”字段中的地址都改为 X，并将所有的“距离”字段的值加 1。</li><li>对修改后的 RIP 报文中的每一个项目，重复以下步骤：<ul><li>若项目中的目的网络不在路由表中，则将该项目加到路由表中。</li><li>否则<ul><li>若下一跳字段给出的路由器地址是同样的，则将收到的项目替换原路由表中的项目</li><li>否则<ul><li>若收到项目中的距离小于路由表中的距离，则进行更新</li><li>否则，什么也不做。</li></ul></li></ul></li></ul></li><li>若 3 分钟还没有收到相邻路由器的更新路由表，则将此相邻路由器记为不可达的路由器，即将距离置为16（距离为16表示不可达）。</li><li>返回。</li></ol><h3 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h3><p>一开始，各路由表只有到相邻路由器的信息：</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/rip1.png"></div><br>路由器 B 收到相邻路由器 A 和 C 的路由表：<p></p><p>修改 A 的路由表，将 RIP 报文中的所有项目下一跳的字段都改成 A ，距离增加 1。</p><table><thead><tr><th style="text-align:center">目的网络</th><th style="text-align:center">距离</th><th style="text-align:center">下一跳</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">3</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">3</td><td style="text-align:center">A</td></tr></tbody></table><p>修改 C 的路由表，将 RIP 报文中的所有项目下一跳的字段都改成 C ，距离增加 1。</p><table><thead><tr><th style="text-align:center">目的网络</th><th style="text-align:center">距离</th><th style="text-align:center">下一跳</th></tr></thead><tbody><tr><td style="text-align:center">4</td><td style="text-align:center">2</td><td style="text-align:center">C</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">2</td><td style="text-align:center">C</td></tr></tbody></table><p>将 B 原来不可达的项目加入到B的路由表中，加入后B的路由表：</p><table><thead><tr><th style="text-align:center">目的网络</th><th style="text-align:center">距离</th><th style="text-align:center">下一跳</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">2</td><td style="text-align:center">C</td></tr></tbody></table><p>修改 收到的目的网络原本在B路由器中且下一跳的字段和原B路由表项目中的字段一致 的项目，发现不用修改。</p><p>修改 B 可达，A和C也可达的项目，发现收到项目中的距离小于路由表中的距离，则进行更新，否则不更新。则修改后B的路由表是：</p><table><thead><tr><th style="text-align:center">目的网络</th><th style="text-align:center">距离</th><th style="text-align:center">下一跳</th></tr></thead><tbody><tr><td style="text-align:center">3</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">1</td><td style="text-align:center">-</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">2</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">2</td><td style="text-align:center">A</td></tr><tr><td style="text-align:center">6</td><td style="text-align:center">2</td><td style="text-align:center">C</td></tr></tbody></table><h3 id="RIP-协议的优缺点"><a href="#RIP-协议的优缺点" class="headerlink" title="RIP 协议的优缺点"></a>RIP 协议的优缺点</h3><ul><li>RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。即好消息传播得快，而坏消息传播得慢。</li><li>RIP 协议最大的优点就是实现简单，开销较小。</li><li>RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。</li><li>路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。</li></ul><h3 id="好消息传播得快，坏消息传播得慢"><a href="#好消息传播得快，坏消息传播得慢" class="headerlink" title="好消息传播得快，坏消息传播得慢"></a>好消息传播得快，坏消息传播得慢</h3><p>在正常情况下，R1中项目表示到网1距离为1，R2中项目表示到网1距离为2。R2收到 R1 的项目后修改R2的项目为：1 2 R1，R2发现到网1的下一跳为R1，和原路由表一致，修改原路由表该项目为：1 2 R1。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/好消息传播得快坏消息传播得慢1.png"></div><br>R1 说：“我到网 1 的距离是 16 （表示无法到达），是直接交付”。但 R2 在收到 R1 的更新报文之前，还发送原来的报文，因为这时 R2 并不知道 R1 出了故障。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/好消息传播得快坏消息传播得慢2.png"></div><br>我们列出一个网1出现故障后的交换表：<p></p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">R1</th><th style="text-align:center">R2</th></tr></thead><tbody><tr><td style="text-align:center">正常</td><td style="text-align:center">1 1 -</td><td style="text-align:center">1 2 R1</td></tr><tr><td style="text-align:center">故障</td><td style="text-align:center">1 16 -</td><td style="text-align:center">1 2 R1</td></tr><tr><td style="text-align:center">第1次</td><td style="text-align:center">1 3 R2</td><td style="text-align:center">1 16 R1</td></tr><tr><td style="text-align:center">第2次</td><td style="text-align:center">1 16 R2</td><td style="text-align:center">1 4 R1</td></tr><tr><td style="text-align:center">第3次</td><td style="text-align:center">1 5 R2</td><td style="text-align:center">1 16 R1</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>这样不断更新下去，直到 R1 和 R2 到网 1 的距离都增大到 16 时，R1 和 R2 才知道网1是不可达的。</p><h3 id="RIP协议的位置"><a href="#RIP协议的位置" class="headerlink" title="RIP协议的位置"></a>RIP协议的位置</h3><ul><li>RIP 协议使用运输层的用户数据报 UDP进行传送（使用 UDP 的端口 520）。</li><li>因此 RIP 协议的位置应当在应用层。但转发 IP 数据报的过程是在网络层完成的。</li></ul><p>这时有一个困惑，RIP是网络层协议，可是为什么用UDP封装？因为路由器虽然是网络层设备，但并不代表他只具备物理层、链路层、网络层功能，他还具备一些应用层的功能，当遇到RIP报文这类应用层的协议，他也能够解封。然后读取RIP报文中的下一跳路由。</p><h3 id="RIP2-协议的报文格式"><a href="#RIP2-协议的报文格式" class="headerlink" title="RIP2 协议的报文格式"></a>RIP2 协议的报文格式</h3><p>RIP2由RIP而来，属于RIP协议的补充协议，提升装载的信息量，增加安全性。</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/rip报文格式.png"></div><p></p><h2 id="OSPF协议"><a href="#OSPF协议" class="headerlink" title="OSPF协议"></a>OSPF协议</h2><p>开放最短路径优先协议OSPF （Open Shortest Path First）。</p><h3 id="RIP-协议的问题"><a href="#RIP-协议的问题" class="headerlink" title="RIP 协议的问题"></a>RIP 协议的问题</h3><ul><li>以跳数评估的路由并非最优路径</li><li>最大跳数16导致网络尺度小</li><li>收敛速度慢</li><li>更新发送全部路由表浪费网络资源</li></ul><h3 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h3><ul><li>向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。<ul><li>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”（metric）。</li></ul></li><li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</li></ul><h3 id="链路状态数据库"><a href="#链路状态数据库" class="headerlink" title="链路状态数据库"></a>链路状态数据库</h3><p>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得快是其重要优点。</p><h3 id="Dijkstra-算法"><a href="#Dijkstra-算法" class="headerlink" title="Dijkstra 算法"></a>Dijkstra 算法</h3><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/Dijkstra.png"></div><br>| | 1 | 2 | 3 | 4 | 5 | 6 |<br>| :—–: | :–: | :—: | :–: | :—: | :—: | :—: |<br>| 初始化1 | 0 | 2 | 6 | <strong>1</strong> | +无穷 | +无穷 |<br>| 第1步 | 0 | 2 | 4 | 1 | <strong>2</strong> | +无穷 |<br>| 第2步 | 0 | <strong>2</strong> | 3 | 1 | 2 | 4 |<br>| 第3步 | 0 | <strong>2</strong> | 3 | 1 | 2 | 6 |<p></p><p>路径：1 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 3 -&gt; 6</p><h3 id="OSPF-的区域-area"><a href="#OSPF-的区域-area" class="headerlink" title="OSPF 的区域(area)"></a>OSPF 的区域(area)</h3><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。每一个区域都有一个 32 bit 的区域标识符（用点分十进制表示）。区域也不能太大，在一个区域内的路由器最好不超过 200 个。 同时 OSPF 划分为两种不同的区域：</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/划分区域.png"></div><br>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。OSPF 使用层次结构的区域划分。在上层的区域叫作主干区域(backbone area)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。 图中的R3、R4、R6、R7是主干路由器。<p></p><h3 id="OSPF-载体"><a href="#OSPF-载体" class="headerlink" title="OSPF 载体"></a>OSPF 载体</h3><ul><li>OSPF 不用 UDP 而是直接用 IP 数据报传送。</li><li>OSPF 构成的数据报很短。这样做可减少路由信息的通信量。</li><li>数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</li></ul><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/OSPF格式.png"></div><p></p><h3 id="OSPF-的五种分组类型"><a href="#OSPF-的五种分组类型" class="headerlink" title="OSPF 的五种分组类型"></a>OSPF 的五种分组类型</h3><ul><li>类型1，问候（Hello）分组。</li><li>类型2，数据库描述（Database Description）分组。</li><li>类型3，链路状态请求（Link State Request）分组。</li><li>类型4，链路状态更新（Link State Update）分组，用洪泛法对全网更新链路状态。</li><li>类型5，链路状态确认（Link State Acknowledgment）分组。</li></ul><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/OSPF操作.png"></div><p></p><h2 id="BGP协议"><a href="#BGP协议" class="headerlink" title="BGP协议"></a>BGP协议</h2><p>BGP 是不同自治系统的路由器之间交换路由信息的协议。 BGP 较新版本是 2006 年 1 月发表的 BGP-4，可以将 BGP-4 简写为 BGP。</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/BGP协议.png"></div><br>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP 发言人” 。一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。<p></p><p>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话（session），利用 BGP 会话交换路由信息。使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站或对等站。</p><h3 id="BGP报文"><a href="#BGP报文" class="headerlink" title="BGP报文"></a>BGP报文</h3><ul><li>打开（Open）报文，用来与相邻的另一个BGP发言人建立关系。</li><li>更新（Update）报文，用来发送某一路由的信息，以及列出要撤消的多条路由。</li><li>保活（Keepalive）报文，用来确认打开报文和周期性地证实邻站关系。</li><li>通知（Notificaton）报文，用来发送检测到的差错。</li></ul><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/BGP格式.png"></div><p></p><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><ul><li>IP协议<ul><li>只有一种报文格式：IP报文</li><li>功能：传递上层数据</li><li>缺乏：应付可能出现差错的能力</li></ul></li><li>网际控制报文协议 ICMP (Internet Control Message Protocol)<ul><li>IP的辅助协议</li><li>为IP提供差错报告机制</li><li>同时为其它层（TCP/UDP、应用）提供辅助功能</li></ul></li></ul><p>ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。</p><h3 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h3><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/ICMP格式.png" width="80%"></div><p></p><h3 id="差错报告报文"><a href="#差错报告报文" class="headerlink" title="差错报告报文"></a>差错报告报文</h3><ul><li>终点不可达</li><li>源点抑制(Source quench)</li><li>时间超过</li><li>参数问题</li><li>改变路由（重定向）(Redirect)</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/ICMP差错.png" width="80%"></div><p></p><h3 id="询问报文"><a href="#询问报文" class="headerlink" title="询问报文"></a>询问报文</h3><ul><li><p>回送请求和回答报文</p></li><li><p>时间戳请求和回答报文</p></li></ul><h3 id="PING"><a href="#PING" class="headerlink" title="PING"></a>PING</h3><p>Ping发送一个ICMP 报文；回声请求消息给目的地并报告是否收到所希望的ICMPecho （ICMP回声应答）。它是用来检查网络是否通畅或者网络连接速度的命令。</p><p>网络层完成了“主机到主机”的通信，但主机间的通信并不是最后的结果，产生和消耗数据的并不是主机，而是某项网络应用，真正通信的是两个应用“进程”。“进程”就是“正在进行的程序”。而“进程到进程的通信”正是传输层的功能。但这不是全部，更重要的，传输层的任务是为从源主机到目的主机提供可靠的，低价格的数据传输。可靠性，低价格是两个关键词，或者为了更明显一些，可以有第三个关键词，拥塞控制。其实可靠性与拥塞控制本质上是一个词。可靠性、低价格、拥塞控制使传输层成为整个协议体系的核心与灵魂。如果没有传输层，就没有可靠的数据传输，网络层也将失去意义。</p><h2 id="传输服务"><a href="#传输服务" class="headerlink" title="传输服务"></a>传输服务</h2><p>传输层的服务与网络层服务很相似，为何要分为两个层呢？答案就是“可靠性”。网络层并不提供可靠性，路由器可以丢失分组，用户无法控制中间的网络设备，用户不能选择性能更好的路由器或质量更好的数据链路，那么如何保证数据可以正常传输呢？添加一个传输层，传输层应该检测到各种问题，并采取补救措施，从而提供可靠的数据传输。传输层就是要弥补网络层技术、设计的各种缺陷。用个不恰当的比方，传输层就是“填坑的”，将网络层与应用层之间的坑、沟填平。传输层服务前，是遍布坑、沟的公路，传输层服务后，是平坦的公路。</p><p>再谈谈“低价格”这个关键词。如果在设计网络时，由网络层提供可靠性，会如何呢？如果由网络层提供可靠性，就要在中间网络的千万个路由器上添加可靠性的功能，系统的复杂性会提高数据传输的成本，那就与电话通信网的成本差别不大。可靠性由通信网提供还是由端计算机提供，二者的价格差别可太大了。可靠性由端计算机提供，才有了低成本的数据传输，低价格才是计算机网络将其他通信技术淘汰的本质。要低价格，可靠性就要放置在端计算机内部。显然放置在操作系统内部更加合理，直接由操作系统对应用程序提供可靠的数据传输服务，是非常自然的选择。传输层封装在端计算机的操作系统内，用个不恰当的比方，如同封装在房间内的电线，在装修时已经埋好了，只是提供了许多插座，这个插座接洗衣机，那个插座接冰箱，那个插座接电视，等等。</p><p>对计算机网络来说，“可靠性”的关键是什么？或者反过来，造成数据传输不可靠的最主要的原因是什么？是网络拥塞，当网络拥塞时，路由器就会丢弃数据包。传输层需要具有“调控网络”的功能。我们说，传输层在端主机内，而端主机是无法控制中间的网络设备的，“调控网络”从何谈起呢？后面会说到网络拥塞如同现实生活的堵车，根本的解决办法是不让车上路，所有的车都不上路，路就不堵了。“调控网络”是说所有端计算机内的传输层要能感知到网络的状态，能感知到当前通信网的态势，网络拥塞，就少发数据，网络通畅，就多发数据。尤其是网络拥塞时，要少发数据，让中间网络尽快恢复传输能力。</p><h2 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h2><p>最常用的进程到进程的通信方式是客户机与服务器模式。我们这里说的客户机与服务器都是指一个应用进程，而不是机器。客户机，请求服务，主动发起呼叫的进程。服务器，提供服务，被动等待的进程。总是客户机呼叫服务器，绝不可能是服务器呼叫客户机。在生活中，总是你给消防队打电话，绝不可能是消防队给你打电话。某一项服务，就是一项网络应用。端主机完全可以同时有多项网络应用，如同时打开浏览器浏览网页，打开 QQ 聊天。标识不同的网络应用进程的标识符称为协议端口号 (protocol port number)，简称为端口 (port)。端口是一个 16 位的标识符。客户机用一个临时端口号定义自己。客户机可以随机选择一个端口号使用。服务器也需要用一个端口号来定义自己，但是服务器不能随机选用一个端口号。为什么呢？假设消防队随机使用一个电话号码，当发生火灾时，人们向哪打电话呢？服务器必须使用一个预先定义的，众所周知的端口号，就如同消防队使用119，急救中心使用 120 一样。</p><h3 id="端口范围划分"><a href="#端口范围划分" class="headerlink" title="端口范围划分"></a>端口范围划分</h3><ul><li><p>熟知端口，端口号范围是 0~1023。由 ICANN 分配和控制。</p></li><li><p>注册端口，端口号范围是 1024~49151，ICANN 不分配也不控制，但必须在 ICANN 登记以防止重复。通常为没有熟知端口号的应用程序使用的。</p></li><li><p>动态端口，端口号范围是 49152~65535，这范围的端口号即不用指派，也不需注册，可以由任何进程使用。最初的建议是客户机使用的临时端口号应该在这个范围，但许多程序员可没有遵守这个建议。</p></li></ul><p>注意：端口号只具有本地意义，只是为了标志本计算机应用层中的各进程。</p><h3 id="复用与分用"><a href="#复用与分用" class="headerlink" title="复用与分用"></a>复用与分用</h3><p>某台主机中可能有多个应用进程同时分别和网络上的许多其他主机中的某个或多个应用进程通信。这表明运输层有一个很重要的功能：复用（multiplexing）和分用（demultiplexing）。</p><p>当一个实体接受来自多个源的输入时，就称为复用（multiplexing） （多到一）。</p><p>而当一个实体将数据交到多个源时，就称为分用（demultiplexing）（一到多）。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/复用与分用.png"></div><p></p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>用户数据报协议 UDP（User Datagram Protocol）是无连接不可靠的传输层协议。它只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和校验和的功能。校验和功能是可选的，如果不选择校验功能，就全填入 0。UDP 缺点是不可靠，优点是开销小。发送数据之前不需要建立连接。这对某些实时应用是很重要的。网络出现拥塞时，不调整，不降低发送速率。UDP 用户数据报首部如下图：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/udp首部.png"></div><br>源端口和目的端口号，各占 16 位，标志应用进程，总长度为 UDP 的总长度，UDP 首部加 UDP 数据的长度，校验和计算下面介绍。<p></p><h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><p>UDP 的校验和功能是可选的，如果不选择校验和功能，就全填入 0，否则，计算校验和。计算时包含三个部分，伪首部，首部，数据部分，注意计算校验和是包含了数据部分的。如下图：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/UDP校验和.png" width="80%"></div><p></p><h4 id="计算-UDP-检验和的例子"><a href="#计算-UDP-检验和的例子" class="headerlink" title="计算 UDP 检验和的例子"></a>计算 UDP 检验和的例子</h4><p>二进制反码计算规则：0 + 0 = 10；0 + 1 = 1； 1 + 1 = 0</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/校验和计算.png" width="80%"></div><p></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><h3 id="TCP格式"><a href="#TCP格式" class="headerlink" title="TCP格式"></a>TCP格式</h3><p>一个 TCP 报文段分为首部和数据两部分，首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。而 TCP 的全部功能都体现在它首部中各字段的作用：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/TCP格式.png"></div><p></p><ul><li>源端口和目的端口字段：各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。</li><li>序号字段：占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。</li><li>确认号字段：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。</li><li>窗口字段：占 2 字节，用来让对方设置发送窗口的依据，单位为字节。</li><li>数据偏移（即首部长度）：占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。</li><li>保留：占 6 位，保留为今后使用。</li><li>控制：占 6 位，定义了 6 种不同的控制位或标志。在同一时间可设置位或多位标志位。分别是 URG、ACK、PSH、RST、SYN、FIN。</li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/TCP格式控制.png"></div><p></p><ul><li><p>检验和：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。</p></li><li><p>紧急指针字段：占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。</p></li><li><p>选项字段：长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”</p></li></ul><h3 id="差错控制"><a href="#差错控制" class="headerlink" title="差错控制"></a>差错控制</h3><p>TCP 是可靠的传输层协议。就是说 TCP 向应用层交付的是按顺序的，没有差错的，没有丢失的数据。TCP 通过 3 种机制进行差错控制：检验和，确认与超时。</p><h4 id="检验和"><a href="#检验和" class="headerlink" title="检验和"></a>检验和</h4><p>TCP 规定每个报文段都必须使用 16 位的检验和。TCP 检验计算时包含三个部分，伪首部，首部，数据部分，注意计算校验和是包含了数据部分的。计算方 法同 UDP 一样。</p><h4 id="确认和超时"><a href="#确认和超时" class="headerlink" title="确认和超时"></a>确认和超时</h4><p>TCP 采用确认的方式来证实收到报文。接收方可以在合适的时候单独发送确 认报文，也可以在自己有数据要发送时把确认信息捎带上。TCP 使用肯定的累积确认。先解释“肯定”，ACK 就是“肯定”的意思。就是只在正确的情况下才发送确认。当发生丢弃，丢失，重复这些错误时，就什么也不做。“报喜不报忧”，注意，当发生错误时，不发送确认。这样，对方收不到确认，重传定时器就会超时，触发重传。 再解释“累积”，就是表示的累积效果，确认号字段值表示的是希望接收的下一个字节的序号。例如确认号为 301，是表示 301 号字节之前的数据都正确接收了，希望接收的下一个字节是 301 号字节。</p><h4 id="重传定时器-2"><a href="#重传定时器-2" class="headerlink" title="重传定时器"></a>重传定时器</h4><p>差错控制的核心就是重传机制。TCP 使用确认-超时重传机制。具体说，TCP 每发送一个报文段，就设置一个重传定时器，当重传时间到，但还没有收到确认，就要重传这一报文段。重传定时器的值怎么设是 TCP 最复杂的事情之一。后面我们会解释原因，现在我们只要知道，重传定时器的值的估算要尽可能的准确，定时器的值不像加班费，越大越好，也不是越小越好，是越准确越好。</p><p>首先，很自然的想法，重传定时器的值应该是“一个往返时延再多一点”。“一个往返时延”如何确定？举例，8 点测了一次往返时延，8:05 又测一次，间隔 5 分钟，测了 10 次，往返时延应该用哪次测量的值呢？显然，用哪一次的<br>也不合适，应该是某种“平均值”。下面介绍的这个算法的目标是使估计值更加“平滑”，我们将往返时延估计值记作 RTTs。这个算法中，历史的累积效应权重更大一些，占比 7/8，新测量值的权重小，占比1/8。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/RTTS.png"></div><br>下图是 RTT 样本与 RTT 估计值示意图，蓝色的是各次的测量值，红色的是RTT 的估计值。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/RTTS图.png"></div><br>说完“一个往返时延”，再说“多一点”。这一点Δ怎么算呢？取样本值到平滑线的距离为Δ，|RTTs-新样本|，显然，每个样本点到平滑线都有一个Δ，就是Δ1，Δ2，Δ3，Δ4，···，取哪个Δ合适呢？显然，用哪一个Δ也不合适，还应<br>该是某种“平均值”。算法也是给出一种“平滑平均值”，记作 RTTD。这个算法中，历史的累积效应权重更大一些，占比 3/4，新测量值的权重小，占比 1/4。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/RTTD.png"></div><br>总的RTO计算公式：$RTO=RTTs + 4 \ast RTTD$<p></p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>TCP 是全双工通信，TCP 为每个方向的数据传输使用两个窗口，发送窗口和接收窗口。双向通信就有四个窗口，为简化讨论，只讨论单向数据传输。</p><h4 id="发送窗口-1"><a href="#发送窗口-1" class="headerlink" title="发送窗口"></a>发送窗口</h4><p>下图是一发送窗口例子，TCP 中的窗口以字节为单位。TCP 的传输实际是一个一个的报文段，但控制窗口的变量是以字节为单位。TCP 中只使用一个重传计时器。为方便说明，字节编号取得很小。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/发送窗口1.png"></div><br>发送窗口的后沿（left wall）只能向前移动（关闭 closes），前沿可向前移动（opens），也可收缩（shrinks），但 TCP 标准不赞成收缩。<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/发送窗口2.png"></div><p></p><h4 id="接收窗口-1"><a href="#接收窗口-1" class="headerlink" title="接收窗口"></a>接收窗口</h4><p>下图是一接收窗口例子。实际上，接收窗口永远不会收缩。通常，接收方 TCP 等待应用进程来取数据。就是说，分配给接收方的缓存可能包含已接收且确认的数据字节，它们在正等待应用进程将它们拉走。接收窗口总是小于缓冲区的大小。接收窗口通常称为 rwnd，rwnd = 缓冲区大小 – 正在等待被拉走的字节数，如下图：rwnd = 40 。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/接收窗口.png"></div><p></p><h4 id="窗口如何滑动"><a href="#窗口如何滑动" class="headerlink" title="窗口如何滑动"></a>窗口如何滑动</h4><p>TCP 通过滑动窗口机制实现流量控制。我们先忽略差错、拥塞等其他因素，且只简化讨论一个方向的数据传输。下图描述了一个例子，总是客户端发送数据，服务器确认。客户端是发送方，发送窗口，使用序号字段，服务器是接收方，接收窗口，使用确认号和窗口两个字段，窗口字段值是 rwnd 的值。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/窗口滑动.png" width="80%"></div><br>假设发送方的缓冲区与接收方的缓冲区大小都是 800 字节。<p></p><ol><li>第 1 个报文段，客户端发给服务器，SYN 报文段，seq=100。三次握手建立连接的第一个报文，请求连接，并通告初始序号是 seq=100。</li><li>第 2 个报文段，服务器发给客户端，SYN+ACK 报文段，ack=101，rwnd=800。三次握手建立连接的第二个报文，窗口值通告 rwnd=800。</li><li><p>第3个报文段，客户端发给服务器，ACK报文段。客户端通告rwnd=2000，表示客户端的接收缓冲区的大小，我们忽略这个值，只讨论单向传输。</p></li><li><p>第 4 个报文段，客户端发给服务器，数据报文段，seq=101。客户端发送一数据报文段，携带 200 字节数据，数据字节编号 101~300，序号字段填写第 1个数据字节的编号 seq=101。发送窗口前沿在 901，后沿在 101，显示已发送 200字节数据，正等待确认。</p></li><li>第 5 个报文段，服务器发给客户端，ACK 报文段，ack=301，rwnd=600。服务器收到 101~300 号字节，共 200 字节数据，接收窗口调整，后沿向前滑动 200 字节，表示已收好 200 字节。向客户端发送 ACK 确认，确认字段值 ack=301，表示 301 号之前数据收好，下一个希望接收的字节是 301 号字节。注意，此刻 200 字节数据仍在接收缓冲区内，服务器的应用进程还没将它们拉走，接收窗口的大小 rwnd= 800 – 200 = 600。报文段中通告的窗口值为 600。</li><li>第 6 个报文段，客户端发给服务器，数据报文段，seq=301。客户端收到确认 ack=301，rwnd=600。客户端知道服务器已经收好 101~300 号字节，就可以删除这些数据，发送窗口调整，后沿向前滑动 200 字节，至01 处。但前沿不能向前滑动，因为现在接收方通告的 rwnd=600，前沿=301+600=901。客户端发送数据报文段，携带 300 字节数据，数据字节编号 301~600，序号字段eq=301。</li><li>第 7 个报文段，服务器发给客户端，ACK 报文段，ack=601，rwnd=400。服务器收到第二次的 301~600 号字节数据，共 300 字节数据。接收窗口调整，后沿向前滑动 300 字节，至 601 处。因 TCP 使用累积确认，向客户端发送的确认为 ack=601，表示 601 号之前所有数据收好，下一个希望接收的字节是 601 号字节。注意，此刻 200+300=500 字节数据仍在接收缓冲区内。这时，服务器的应用进程拉走 100 字节数据，接收缓冲区的 101~200 号字节空间被释放，但 201~601的 400 字节数据滞留在接收缓冲区内。接收窗口的大小 wnd= 800 – 400 = 400。通告窗口值为 rwnd=400。客户端收到确认 ack=601，rwnd=400。客户端知道服务器已经收好 601 号之前的数据，就可以删除这些数据，发送窗口调整，后沿向前滑动至 601 处。因为现在接收方通告的 rwnd=400，前沿=601+400=1001。前沿向前滑动至 1001 处。</li><li>第 8 个报文段，服务器发给客户端，ACK 报文段，ack=601，rwnd=600。服务器的应用进程又拉走 200 字节数据，接收缓冲区的 201~400 号字节空间被释放，但 401~601 的 200 字节数据仍滞留在接收缓冲区内。接收窗口的大小 rwnd= 800 – 200 = 600。通告窗口值为 400。对于确认来说，服务器现在收好的是 601 号字节之前的数据，确认为 ack=601，表示希望接收的下一个字节是 601 号字节。客户端收到确认 ack=601，wnd=600。客户端知道服务器已经收好 601 号之前的数据，发送窗口的后沿就在 601 处，不需滑动。因为现在接收方通告的rwnd=600，前沿=601+600=1201。前沿向前滑动至 1201 处。</li></ol><h3 id="糊涂窗口综合症"><a href="#糊涂窗口综合症" class="headerlink" title="糊涂窗口综合症"></a>糊涂窗口综合症</h3><p>假如 TCP 发送的报文段只含有 1 个字节的数据，那么意味着为发送 1 字节的数据，而发送了 41 个字节的报文段，20 个字节的 TCP 首部和 20 个字节的 IP首部。此时的效率是 1/41。这一现象称为糊涂窗口综合症（Silly Window Syndrome）。糊涂窗口综合症是怎样产生的呢?</p><h4 id="由发送方产生的糊涂窗口综合症（Syndrome-Created-by-the-Sender）"><a href="#由发送方产生的糊涂窗口综合症（Syndrome-Created-by-the-Sender）" class="headerlink" title="由发送方产生的糊涂窗口综合症（Syndrome Created by the Sender）"></a>由发送方产生的糊涂窗口综合症（Syndrome Created by the Sender）</h4><p>如果发送方 TCP 正在为一个产生数据很缓慢的应用程序服务，例如一次产生 1 字节数据，就有可能产生糊涂窗口综合症。解决方法是使用 Nagle 算法。</p><h5 id="Nagle-算法"><a href="#Nagle-算法" class="headerlink" title="Nagle 算法"></a>Nagle 算法</h5><ol><li>发送方 TCP 把它从应用进程收到的第一块数据发送出去，即使只有 1 字节。</li><li>在发送一个报文段后，发送方 TCP 就在输出缓存中累积数据并等待，直至收到接收方发来的确认，或者已积累了足够的数据已达到报文段的最大长度时，就立即发送一个报文段。</li><li>重复步骤 2。</li></ol><p>Nagle 算法之巧妙，在于其巧妙地平衡了应用程序产生数据速度和网络传输速度。如果应用程序比网络速度快，报文段就大（最大报文段长度），如果应用程序比网络速度慢，报文段就小。</p><h4 id="由接收方产生的糊涂窗口综合症（Syndrome-Created-by-the-Receiver）"><a href="#由接收方产生的糊涂窗口综合症（Syndrome-Created-by-the-Receiver）" class="headerlink" title="由接收方产生的糊涂窗口综合症（Syndrome Created by the Receiver）"></a>由接收方产生的糊涂窗口综合症（Syndrome Created by the Receiver）</h4><p>如果接收方 TCP 正在为一个消耗数据很缓慢的应用程序服务，例如一次消耗 1 字节数据，接收方每次发送 rwnd=1 的通告，就有可能产生糊涂窗口综合症。解决方法的是推迟确认。</p><p>报文到达时，不立即发送确认，接收方等待一段时间，直到输入缓存有足够的空间（或者接收缓存已有一个最长报文段的空间，或者接收缓存已有一半空闲的空间），就发送确认报文。但推迟确认不能超过 500ms。</p><h3 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h3><p>拥塞控制是 TCP 协议中最重要的一部分。理解 TCP 的拥塞控制，关键在于真正理解网络拥塞这一现象，理解了拥塞，以后的内容都会顺理成章的很好理解。</p><h4 id="拥塞概述"><a href="#拥塞概述" class="headerlink" title="拥塞概述"></a>拥塞概述</h4><p>两个主机，通过中间的一个传输网，连接在一起。正是因为中间有网络，就有了网络拥塞问题。谈网络拥塞之前，先回忆一下路由器的原理。网络层的路由器是一种“尽力而为”的机制。当超过路由器的能力时，路由器就将会丢弃数据报。假设路由器每秒能转发 1000 个数据报，此刻来了 1200 个数据报，路由器就将后 200 个数据报丢弃。注意：当没有超过路由器的负载能力时，路由器是不会丢弃数据报的。换一句话说，就是某个路由节点拥塞了，才会丢弃数据报。</p><p>怎么解决拥堵呢？很明显有两种方案，用公路网来打比方就是增加路的数量和减少驶入公路网的车。从协议的角度考虑，自然是做不到增加路的数量，所以我们就要控制发送到网络中的数据量。</p><h4 id="传输网络"><a href="#传输网络" class="headerlink" title="传输网络"></a>传输网络</h4><p>当网络拥塞时，如同城市交通堵塞，南城的人去不了北城，北城的人一样也去不了南城，路都堵死了，谁也走不了。也就是说，拥塞时，网络外围的所有主机，发送的数据包都会被丢掉，所以一定不会有返回的 ACK 确认，超时定时器一定会闹响。也就是说，网络拥塞时，所有主机都会超时。这样问题就解决了，简单归纳为一句话，超时就表示网络拥塞。</p><blockquote><p>超时就表示网络全拥塞。</p></blockquote><p>因为 TCP 协议中以超时做为网络拥塞的判断依据，重传定时器的值需要估算合适，这很重要。值估算小了，实际网络不拥塞，确产生了超时重传，误判为拥塞，就不能充分使用网络的传输能力。值估算大了，实际网络已经拥塞，确没有产生超时重传，误判为通畅，就会使拥塞更加恶化，最终通信崩溃。在日常的生活中，城市的交通堵塞一定是渐渐堵死的，绝无可能在前一分钟，全城都是通畅的，后一分钟，全城所有的道路都堵死。总是开始时某些路段堵死，然后慢慢扩大，最后全部堵死。如果在某些路段堵死的时候，就开始疏导，有可能不会演变为全堵死。同理在计算机网络中，也很难相信，在前一分钟，所有的路由器都负载很轻，后一分钟，所有的路由器都超负载。应该是，某些路由器超负载了，其他路由器正常，这时后续的数据包就会自动绕路。假设某主机，连续发送了 2，3，4，5号数据包，2 号数据包碰到超负荷的路由器，被路由器丢弃，3，4，5 号数据包绕路到达目的主机，目的主机发送了 3 个 ACK 确认，请求 2 号数据包。当发送方收到 3 个重复 ACK 时，就会判断，网络是部分拥塞的，前面的数据包堵死在路上，后面的数据包绕路走了，已经到达目的地。简单归纳为一句话，3 个重复ACK 就表示网络部分拥塞，我称为半拥塞。</p><blockquote><p>3 个重复 ACK 就表示网络半拥塞。</p></blockquote><p>至此，外围的主机有了推测中间传输网络状态的办法，这两个事件就标志着网络的两种状态。用两个事件标志两种网络状态的方法，需要认真领会。TCP 的拥塞控制不能算闭环，没有一个具体的设备发出一个网络拥塞的信号，因为拥塞是全网的状态，不是某一个路由器的状态。一个路由器超载，可以绕其他路由器。TCP 的拥塞控制也不能算开环，“超时”与“3ACK”这两个事件确实反馈了中间传输网络的状态，为决策提供了依据。了解了网络现在的状态，就好办了。全拥塞有全拥塞的处理办法，半拥塞有半拥塞的处理办法。</p><h4 id="拥塞窗口"><a href="#拥塞窗口" class="headerlink" title="拥塞窗口"></a>拥塞窗口</h4><p>在上文中，讨论过 TCP 的流量控制，发送方窗口大小是由接收方的可用缓存空间（rwnd）决定的，就是由接收方指示发送方应当使用多大的窗口，这当然可以保证接收方不会溢出。但是，这个方法没考虑网络的存在，上文说过，要调控网络拥塞，就要根据当前网络的状态，调整发送到网络中的数据量。也就是说，TCP 需要一个控制变量，即TCP 发送方使用拥塞窗口 cwnd （Congestion Window）作为控制变量，根据当前网络的拥塞程度，拥塞窗口的大小动态地变化，调整发送的数据量。这样一来发送窗口大小不仅取决于接收方通告的接收窗口 rwnd，还取决于网络的拥塞状况 cwnd，进而 实际的发送窗口 = min（ rwnd , cwnd ）</p><h4 id="拥塞检测"><a href="#拥塞检测" class="headerlink" title="拥塞检测"></a>拥塞检测</h4><p>TCP 的发送方使用两个事件作为判断网络全拥塞和半拥塞的依据。超时表示网络全拥塞。3 次重复 ACK 表示网络半拥塞。</p><h5 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h5><p>上文已经解释过拥塞的现象，我们现在简单理解为：发送方的超时事件就表示中间网络全部堵死了。</p><p>发送方 TCP 在整个连接期间，只维护一个 RTO 计时器。发送方发送段 1 和 段 2，计时器启动，接收方发回 ACK，发送方收到 ACK 后，计时器清零。在启动计时器，发送段 3，段 4，段 3 丢失，段 4 到达，接收方将段 4 存储下来，因为段 3 丢失，接收方留出一个间隙，表明数据是不连续的，接收方只能再发送对段 2 的确认 ACK。发送方收到确认，但因为不是对段 3，段 4 的确认，计时器不能清零，计时器超时，就会重传段 3，并重启计时器，这次段 3 正常到达，接收方发送 ACK，发送方收到，将计时器清零。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/超时.png"></div><p></p><h5 id="三次重复-ACK（3dupACKs）"><a href="#三次重复-ACK（3dupACKs）" class="headerlink" title="三次重复 ACK（3dupACKs）"></a>三次重复 ACK（3dupACKs）</h5><p>三次重复 ACK，也称做“快重传”（Fast retransmission）。如下图：发送方发送 2 个段后，正常收到 ACK，这个 ACK 是原始的 ACK，超时计时器清零。发送方再发送 4 个段，并再次启动超时计时器，段 3 丢失，段 4，5，6 到达。当接收方收到失序的数据段时，立即发送 ACK。接收方会发出 3 个重复的 ACK。发送方收到三个重复的 ACK，就立即重传丢失的报文段，而不等待计时器超时，并重启计时器。这一规则称为“快重传”，目前的 TCP 都遵守这规则。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/3次ACK.png"></div><br>三次重复 ACK，显然是某个报文段丢失了，后面的报文段正常到达。这就表示网络有堵死的地方，造成丢失，其他部分通畅，后面的报文段绕行了通畅的路径。我们现在简单理解为：发送方收到三次重复 ACK，就表示中间网络半堵死。<p></p><h4 id="拥塞控制策略"><a href="#拥塞控制策略" class="headerlink" title="拥塞控制策略"></a>拥塞控制策略</h4><p>TCP 拥塞策略基于两个阶段，慢启动（slow-start，SS）阶段和拥塞避免（congestion avoidance，CA）阶段。在慢启动阶段，发送方从非常慢的速率开始，很快达到一个门限值。当到达门限值，进入拥塞避免阶段。</p><h5 id="慢启动（SS-Slow-start）"><a href="#慢启动（SS-Slow-start）" class="headerlink" title="慢启动（SS, Slow start）"></a>慢启动（SS, Slow start）</h5><p>指数增大，拥塞窗口 cwnd 从 1 个最大报文段 MSS 开始。每收到一个 ACK 确认，拥塞窗口增加一个 MSS。慢启动算法开始很慢，但它是以指数增大的。</p><p>按 ACK 计算， cwnd = cwnd + 1。</p><p>如图，从 cwnd=1 开始，第 1 个 ACK 到达后，cwnd 加 1，就是 2。这时，就可发送 2 个段，相应的回来 2 个 ACK，对于每个 ACK，cwnd 加 1，就是 4 了。是按指数增大的。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/慢开始.png"></div><br>慢启动不能无限制的指数增大，有一个门限值来终止慢启动。发送方有一个慢开始门限 ssthresh（slow-start threshold）的变量，当拥塞窗口大小达到阈值时，慢启动停止，开始拥塞避免阶段。<p></p><h5 id="拥塞避免（CA，Congestion-avoidance）"><a href="#拥塞避免（CA，Congestion-avoidance）" class="headerlink" title="拥塞避免（CA，Congestion avoidance）"></a>拥塞避免（CA，Congestion avoidance）</h5><p>加法增大，在慢启动阶段，当拥塞窗口达到慢开始门限 ssthresh 的值时，慢启动停止，进入拥塞避免阶段。此时，拥塞窗口按加法增大。每次整个“窗口”的所有段都被确认后，拥塞窗口增加 1。</p><p>举例，发送方以 cwnd=4 开始，此刻发送方只能发 4 个段，在 4 个 ACK 到达后，拥塞窗口才加 1。如果按往返时延 RTT 观察，拥塞窗口是每一轮次加 1。</p><p>按 ACK 计算， cwnd = cwnd + ( 1 / cwnd )<br>按 RTT 计算， cwnd = cwnd + 1</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/拥塞避免.png"></div><p></p><h5 id="拥塞控制策略的转换"><a href="#拥塞控制策略的转换" class="headerlink" title="拥塞控制策略的转换"></a>拥塞控制策略的转换</h5><p>在拥塞避免阶段，拥塞窗口加法增大。拥塞避免阶段会一直持续下去吗？继续下去，会是什么情况？显然，拥塞避免阶段继续下去，网络只会有处于通畅，半拥塞，全拥塞三种状态中的一种。就如同城市交通一样，只会是不堵车，部分堵死，全部堵死这三种情况之一。</p><ul><li>通畅：标志是无事件发生。拥塞避免阶段继续，拥塞窗口继续按加法增大。</li><li>半拥塞：<ul><li>标志事件是：发送方收到三次重复 ACK（3dupACKs）。</li><li>处理办法是：<ul><li>ssthresh 门限值设为此刻 cwnd 的一半 ssthresh = cwnd / 2</li><li>将拥塞窗口设为门限值。 cwnd = ssthresh</li><li>进入拥塞避免阶段。</li></ul></li></ul></li><li>全拥塞<ul><li>标志事件是：发送方超时。</li><li>处理办法是：<ul><li>ssthresh 门限值设为此刻 cwnd 的一半 ssthresh = cwnd / 2</li><li>将拥塞窗口重新设置设为 1。 cwnd = 1</li><li>进入慢启动阶段</li></ul></li></ul></li></ul><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/转化图.png"></div><br>拥塞举例：<p></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/拥塞举例.png"></div><p></p><h3 id="连接管理"><a href="#连接管理" class="headerlink" title="连接管理"></a>连接管理</h3><p>TCP 是一种面向连接的协议。TCP 以全双工方式传送数据。在 TCP 中，面向连接的传输需要经过三个阶段：连接建立，数据传输，连接断开。TCP 连接采用客户服务器方式。主动发起连接建立的应用进程叫做客户(client)，被动等待连接建立的应用进程叫做服务器(server)。</p><h4 id="连接建立"><a href="#连接建立" class="headerlink" title="连接建立"></a>连接建立</h4><p>TCP 建立连接的过程叫做三次握手（three-way handshaking）。服务器首先打开一个端口，端口处于监听态，称为被动打开。客户端发起连接请求，连接到服务器的打开的端口上，连接就建立了。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/三次握手.png"></div><p></p><ol><li>客户端发送第 1 个报文段，SYN 标志置 1，SYN 是请求同步的意思，SYN 报文段是控制报文，只在每个方向的第 1 个报文里出现。客户随机选择一个数字作为初始序号，假设为 x。<strong>TCP协议规定：SYN 报文段不能携带数据，但要消耗掉一个序号。</strong></li><li>服务器发送第 2 个报文段，SYN，ACK 置 1。SYN 标志表示服务器方的请求同步，并且服务器设置自己的初始序号，假设为 y。ACK 置 1 表示包含确认，这个确认是对客户端 SYN 报文的确认，所以确认号=x+1，表示序号 x+1 之前的报文都收好了，希望收到序号为 x+1 的报文段。</li><li>客户端发送第 3 个报文段，ACK 标志置 1。这个报文段仅仅是一个 ACK 段，通常不携带数据。这个段是客户端发出的，序号就是 x+1。ACK 置 1 表示包含确认，这是对服务器 SYN 报文的确认，确认号=y+1，表示服务器发送的序号 y+1 之前的报文都收好了，希望收到服务器发送的序号为 y+1 的报文段。要特别注意教材中的这句话，并需要真正理解。<strong>TCP 的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号。</strong></li></ol><p>举例：客户端发送的第 1 个 SYN 报文段，序号为 8000，服务器发送的第 2 个 SYN+ACK 报文段，序号为 15000，此后，客户端发送了第 3 个报文段，未携带数据，第 4 个报文段，携带 100 字节数据，问客户端发送的第 3，4 个报文段的序号是什么？</p><p>解析：第 3 个报文段，序号为 8001，因为序号 8000 已经被 SYN 报用掉了。 第 4 个报文段，序号仍然是 8001，注意不是 8002，因为第 3 个报文段是一个 ACK 报文段，并且没携带数据，所以不消耗序号，就是说第 3 个报文的序号 8001 没有被用掉，在第 4 个报文中继续使用。</p><h4 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h4><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h5 id="为什么TCP客户端最后还要发送一次确认呢"><a href="#为什么TCP客户端最后还要发送一次确认呢" class="headerlink" title="为什么TCP客户端最后还要发送一次确认呢"></a>为什么TCP客户端最后还要发送一次确认呢</h5><p>一句话<strong>，主要防止已经失效的连接请求报文突然又传送到了服务器</strong>，从而产生错误。</p><p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p><p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p><h4 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h4><p>连接建立后，可进行双向的数据传输。客户端和服务器都可以发送数据和确认。TCP 连接使用了序号和确认号的机制。</p><h5 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h5><p>TCP 把要发送的数据都按字节编上号。两个方向的编号是相互独立的。编号并不是从 0 开始，而是使用一个随机数作为初始编号，初始编号在建立连接的第一个 SYN 报文段里通告给对方。每个 TCP 报文段都有序号字段，序号字段值是这个报文段中第一个数据字节的编号。</p><blockquote><p>TCP 报文的序号字段值是这个报文段中第一个数据字节的编号。</p></blockquote><h5 id="确认号-2"><a href="#确认号-2" class="headerlink" title="确认号"></a>确认号</h5><p>TCP 使用确认机制。当报文段中 ACK 标志置 1，报文的确认号字段有效，TCP 的确认是累计确认，确认号字段值是完全接收好的数据的最后一个字节的编号+1，表示此值前的数据已收好，期望接收的下一字节是此值。举例，确认号是5644，表示从开始到 5643 号字节的数据都已收好，希望接收 5644 号字节。</p><p>TCP 是累积确认。确认号字段值是期望接收的下一个字节的编号。</p><p>举例：客户端发送一报文段，序号 8001，确认号 15001，携带 1000 字节数据。服务器发送的下一个报文段，序号，确认号是多少？服务器的回复携带 2000 字节数据，则客户端发送的再下一个报文，序号，确认号是多少？</p><p>解析：因第 1 个报文的确认号 15001，是期望接收的下一个报文段的序号，所以，服务器发送的下一个报文段的序号是 15001。因第 1 个报文的序号 8001，携带 1000 字节数据，服务器收到了 8001-9000 编号的 1000 字节数据，确认号是9001，表示 9001 号字节之前的数据已经收好，希望接收的下一个字节是 9001号字节。同理，第 3 个报文，序号为 9001，确认号是 17001。</p><h4 id="连接断开"><a href="#连接断开" class="headerlink" title="连接断开"></a>连接断开</h4><p>数据传输结束后，客户端和服务器任一方都可以发起断开连接。一般来说客户端发起断开连接。TCP 连接释放过程是四次握手。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/20170606084851272.png"></div><p></p><ol><li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li>服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li><li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li>客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗ *∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ol><h5 id="为什么客户端最后还要等待2MSL"><a href="#为什么客户端最后还要等待2MSL" class="headerlink" title="为什么客户端最后还要等待2MSL"></a>为什么客户端最后还要等待2MSL</h5><p>MSL（Maximum Segment Lifetime），TCP允许不同的实现可以设置不同的MSL值。</p><p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p><p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p><h5 id="为什么建立连接是三次握手，关闭连接确是四次挥手呢"><a href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢" class="headerlink" title="为什么建立连接是三次握手，关闭连接确是四次挥手呢"></a>为什么建立连接是三次握手，关闭连接确是四次挥手呢</h5><p>建立连接的时候， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。</p><p>而关闭连接时，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。</p><h5 id="如果已经建立了连接，但是客户端突然出现故障了怎么办"><a href="#如果已经建立了连接，但是客户端突然出现故障了怎么办" class="headerlink" title="如果已经建立了连接，但是客户端突然出现故障了怎么办"></a>如果已经建立了连接，但是客户端突然出现故障了怎么办</h5><p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h4 id="TCP-连接管理的三规则"><a href="#TCP-连接管理的三规则" class="headerlink" title="TCP 连接管理的三规则"></a>TCP 连接管理的三规则</h4><ul><li>规则 1：TCP 规定，SYN 报文段不能携带数据，但要消耗掉一个序号</li><li>规则 2：TCP 的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号。</li><li>规则 3：TCP 规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。</li></ul><h2 id="打开网页的过程"><a href="#打开网页的过程" class="headerlink" title="打开网页的过程"></a>打开网页的过程</h2><p>总体来说分为以下几个过程:</p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/03-IO流和网络/各种协议与HTTP协议之间的关系.png"></div><p></p><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><h3 id="InetAddress"><a href="#InetAddress" class="headerlink" title="InetAddress"></a>InetAddress</h3><blockquote><p>This class represents an Internet Protocol (IP) address.</p></blockquote><h4 id="获得本机IP地址"><a href="#获得本机IP地址" class="headerlink" title="获得本机IP地址"></a>获得本机IP地址</h4><ul><li>获得本地IP地址</li></ul><p><code>InetAddress iaddress = InetAddress.getLocalHost();</code></p><p>但是这个函数有问题，因为这个函数的原理是通过获取本机的<code>hostname</code>，然后对此<code>hostname</code>做解析，从而获取<code>IP</code>地址的。那么问题来了，如果在本机的<code>/etc/hosts</code>文件里对这个主机名指向了一个错误的<code>IP</code>地址，那么<code>InetAddress.getLocalHost</code>就会返回这个错误的<code>IP</code>地址。当然如果你的<code>hostname</code>是到<code>DNS</code>去解析的，碰巧<code>DNS</code>上的信息也是错的，也同样是悲惨结局。</p><p><code>InetAddress</code>是由两部分组成的，一部分是getHostName()，一部分是getHostAddress()。</p><ul><li>获得本机所有的IP地址</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取机器所有网卡的IP（ipv4）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getLocalIP</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; ipList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	InetAddress ip = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Enumeration&lt;NetworkInterface&gt; netInterfaces = (Enumeration&lt;NetworkInterface&gt;) NetworkInterface.getNetworkInterfaces();</span><br><span class="line">		<span class="keyword">while</span> (netInterfaces.hasMoreElements()) &#123;</span><br><span class="line">			NetworkInterface ni = (NetworkInterface) netInterfaces.nextElement();</span><br><span class="line">			<span class="comment">// 遍历所有ip</span></span><br><span class="line">			Enumeration&lt;InetAddress&gt; ips = ni.getInetAddresses();</span><br><span class="line">			<span class="keyword">while</span> (ips.hasMoreElements()) &#123;</span><br><span class="line">				ip = (InetAddress) ips.nextElement();</span><br><span class="line">				<span class="keyword">if</span> (<span class="keyword">null</span> == ip || <span class="string">""</span>.equals(ip)) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				String sIP = ip.getHostAddress();</span><br><span class="line">				<span class="keyword">if</span>(sIP == <span class="keyword">null</span> || sIP.indexOf(<span class="string">":"</span>) &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				ipList.add(sIP);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ipList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>获取其他主机的IP地址对象</li></ul><p><code>InetAddress otherInetAddress = InetAddress.getByName(&quot;www.baidu.com&quot;);</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line">	<span class="comment">//1.获取本地主机</span></span><br><span class="line">	InetAddress iaddress = InetAddress.getLocalHost();</span><br><span class="line">	System.out.println(iaddress);	 <span class="comment">//打印 InetAddress对象 默认格式: 用户名/IP地址</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">//2.获取主机名</span></span><br><span class="line">	String hostName = iaddress.getHostName();</span><br><span class="line">	<span class="comment">//3.获取主机IP地址</span></span><br><span class="line">	String ip = iaddress.getHostAddress();</span><br><span class="line">	System.out.println(hostName);</span><br><span class="line">	System.out.println(ip);</span><br><span class="line">	<span class="comment">//3.获取其他主机的IP地址对象</span></span><br><span class="line">	InetAddress otherInetAddress = InetAddress.getByName(<span class="string">"www.baidu.com"</span>);</span><br><span class="line">	System.out.println(otherInetAddress);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP-1"><a href="#UDP-1" class="headerlink" title="UDP"></a>UDP</h3><p>UDP通信需要两个类的支持：</p><ul><li>数据的发送接收器：DatagramSocket</li><li>数据包类：DatagramPacket</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//1.创建DatagramSocket对象,</span></span><br><span class="line">		<span class="comment">//强调:接收端必须指定一个端口号</span></span><br><span class="line">		DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">12345</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="comment">//2.直接创建一个DatagramPacket对象</span></span><br><span class="line">			<span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">			DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bs, bs.length);</span><br><span class="line">			<span class="comment">//3.接收</span></span><br><span class="line">			System.out.println(<span class="string">"等待发送端发送数据...."</span>);</span><br><span class="line">			ds.receive(dp);<span class="comment">//这个方法具有等待功能,等待发送端发送过来的数据</span></span><br><span class="line">			System.out.println(<span class="string">"接收数据成功!!"</span>);</span><br><span class="line">			<span class="comment">//获取发送端的地址</span></span><br><span class="line">			InetAddress sendAddress = dp.getAddress();</span><br><span class="line">			System.out.println(<span class="string">"发送端是:"</span>+sendAddress.getHostAddress());</span><br><span class="line">			<span class="comment">//获取真正的数据</span></span><br><span class="line">			<span class="keyword">byte</span>[] data = dp.getData();</span><br><span class="line">			<span class="comment">//获取发送端 发来了多少字节</span></span><br><span class="line">			<span class="keyword">int</span> len = dp.getLength();</span><br><span class="line">			<span class="comment">//打印数据</span></span><br><span class="line">			String receiveMsg = <span class="keyword">new</span> String(data, <span class="number">0</span>, len);</span><br><span class="line">			System.out.println(<span class="string">"发送端说:"</span>+receiveMsg);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.关闭资源（程序运行结束之后是需要关闭资源的，但是我们的程序是一个死循环，此句永不会执行，所以不能加关闭）</span></span><br><span class="line">		<span class="comment">//ds.close();	</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.DatagramPacket;</span><br><span class="line"><span class="keyword">import</span> java.net.DatagramSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPSender</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">		<span class="comment">//1.创建DatagramSocket对象</span></span><br><span class="line">		DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="comment">//2.创建DatagramPacket对象</span></span><br><span class="line">			<span class="comment">//存储 发送的数据,对方的IP,端口号</span></span><br><span class="line">			System.out.println(<span class="string">"请输入您要发送的数据:"</span>);</span><br><span class="line">			String sendMsg = sc.nextLine();</span><br><span class="line">			<span class="keyword">byte</span>[] bs = sendMsg.getBytes();</span><br><span class="line">			<span class="comment">//IP地址:127.0.0.1  代表本机,本地回环地址</span></span><br><span class="line">			DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bs,bs.length,InetAddress.getByName(<span class="string">"127.0.0.1"</span>),<span class="number">12345</span>);</span><br><span class="line">			<span class="comment">//3.发送</span></span><br><span class="line">			ds.send(dp);</span><br><span class="line">			System.out.println(<span class="string">"发送数据成功!!!"</span>);<span class="comment">//192.168.146.72</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//4.关闭资源（程序运行结束之后是需要关闭资源的，但是我们的程序是一个死循环，此句永不会执行，所以不能加关闭）</span></span><br><span class="line">		<span class="comment">//ds.close();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TCP-1"><a href="#TCP-1" class="headerlink" title="TCP"></a>TCP</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * TCP服务器:(ServerSocket) 步骤:</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 1.创建一个ServerSocket对象,必须绑定一个端口,这个端口必须和客户端连接的端口一致</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.调用server的accept()方法,获取到底哪一个客户端连接的服务器</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.通过刚刚获取到的客户端对象 调用getInputStream()方法</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4.通过输入流调用read方法,读取客户端写过来的数据</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 5.关闭资源</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 1.创建一个ServerSocket对象,必须绑定一个端口,这个端口必须和客户端连接的端口一致</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">12345</span>);</span><br><span class="line">		<span class="comment">// 2.获取到 哪一个 客户端连接的我</span></span><br><span class="line">		System.out.println(<span class="string">"等待客户端连接..."</span>);</span><br><span class="line">		Socket client = server.accept();<span class="comment">// 此方法也具有等待功能,等待某一个客户端连接</span></span><br><span class="line">		<span class="comment">// 打印一些和客户端有关信息</span></span><br><span class="line">		String ip = client.getInetAddress().getHostAddress();</span><br><span class="line">		System.out.println(<span class="string">"小样,抓到你了:"</span> + ip);</span><br><span class="line">		<span class="comment">// 3.获取输入流,实际上是客户端写数据时的输出流</span></span><br><span class="line">		InputStream in = client.getInputStream();</span><br><span class="line">		<span class="comment">// 4.读取数据</span></span><br><span class="line">		<span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = in.read(bs);</span><br><span class="line">		<span class="comment">// 打印</span></span><br><span class="line">		System.out.println(<span class="string">"客户端说:"</span> + <span class="keyword">new</span> String(bs, <span class="number">0</span>, len));</span><br><span class="line">		<span class="comment">// 5.要向客户端 回写数据,告诉客户端您的信息我已经收到了</span></span><br><span class="line">		OutputStream out = client.getOutputStream();</span><br><span class="line">		out.write(<span class="string">"您的消息已经收到..."</span>.getBytes());</span><br><span class="line">		System.out.println(<span class="string">"给客户端反馈的信息发送成功!!!"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">		server.close();</span><br><span class="line">		client.close();</span><br><span class="line">		in.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用TCP协议的客户端(Socket类) 步骤: 1.创建一个客户端对象(注意:指定这个Socket要连接的服务器的IP和端口)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 2.从客户端对象中获取 输出流:getOutputStream()</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 3.调用输出流的Write方法写数据到服务器即可</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 4.关闭资源</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 1.创建一个客户端对象(注意:指定这个Socket要连接的服务器的IP和端口)</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 这个构造方法干了很多事情: a.自动去连接服务器 b.自动进行三次握手,建立连接 c.自动为连接中创建两个流</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">12345</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 2.从客户端对象中获取 输出流:getOutputStream()</span></span><br><span class="line">		<span class="comment">// OutputStream out = client.getOutputStream();</span></span><br><span class="line">		<span class="comment">// 3.调用输出流的Write方法写数据到服务器即可</span></span><br><span class="line">		<span class="comment">// out.write("How are you".getBytes());</span></span><br><span class="line">		client.getOutputStream().write(<span class="string">"How are you"</span>.getBytes());</span><br><span class="line">		System.out.println(<span class="string">"给服务器发送数据成功!!"</span>);</span><br><span class="line">		<span class="comment">// 4.读取服务器 发送过来的反馈信息</span></span><br><span class="line">		InputStream in = client.getInputStream();</span><br><span class="line">		<span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = in.read(bs);</span><br><span class="line">		System.out.println(<span class="string">"服务器响应:"</span> + <span class="keyword">new</span> String(bs, <span class="number">0</span>, len));</span><br><span class="line">		<span class="comment">// 关闭资源</span></span><br><span class="line">		client.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文件传输案例"><a href="#文件传输案例" class="headerlink" title="文件传输案例"></a>文件传输案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="comment">//1.创建ServerSocket对象,绑定一个端口</span></span><br><span class="line">		ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">12345</span>);</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="comment">//2.获取哪一个客户端连接的服务器</span></span><br><span class="line">			System.out.println(<span class="string">"等待客户端连接..."</span>);</span><br><span class="line">			<span class="keyword">final</span> Socket client = server.accept();</span><br><span class="line">			<span class="comment">//开启一个线程,和clinet进行交互</span></span><br><span class="line">			<span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">				<span class="meta">@Override</span></span><br><span class="line">				<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">					<span class="keyword">try</span> &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">						System.out.println(<span class="string">"小样:"</span>+client.getInetAddress().getHostAddress());</span><br><span class="line">						<span class="comment">//3.获取输入流,读取客户端发来数据</span></span><br><span class="line">						InputStream in = client.getInputStream();</span><br><span class="line">						<span class="comment">//4.创建文件的输出流,把数据写到文件中</span></span><br><span class="line">						String picName = <span class="string">"D:\\"</span>+System.currentTimeMillis()+<span class="string">".png"</span>;</span><br><span class="line">						FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(picName);</span><br><span class="line">						<span class="comment">//5.循环 从输入流读取客户端数据, 写入到文件中</span></span><br><span class="line">						<span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">						<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">						<span class="keyword">while</span>((len=in.read(bs))!=-<span class="number">1</span>)&#123;</span><br><span class="line">							fos.write(bs, <span class="number">0</span>, len);</span><br><span class="line">						&#125;<span class="comment">//1小时</span></span><br><span class="line">						System.out.println(<span class="string">"客户端的文件已经保存完毕,可以查看了"</span>+picName);</span><br><span class="line">						<span class="comment">//6.告知客户端,文件真的真的真的上传成功</span></span><br><span class="line">						<span class="keyword">try</span> &#123;</span><br><span class="line">							Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">						&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">							e.printStackTrace();</span><br><span class="line">						&#125;</span><br><span class="line">						OutputStream out = client.getOutputStream();</span><br><span class="line">						out.write(<span class="string">"您的文件真的真的真的上传成功"</span>.getBytes());</span><br><span class="line">						client.close();</span><br><span class="line">						in.close();</span><br><span class="line">						out.close();</span><br><span class="line">						fos.close();</span><br><span class="line">					&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">						<span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">						e.printStackTrace();</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;).start();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//6.关闭</span></span><br><span class="line">	<span class="comment">//	server.close();</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStream;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadClient</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">		<span class="comment">//1.创建Socket对象,连接服务器</span></span><br><span class="line">		Socket client = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">12345</span>);</span><br><span class="line">		System.out.println(<span class="string">"连接服务器成功.."</span>);</span><br><span class="line">		<span class="comment">//2.获取输出流,把数据写向服务器</span></span><br><span class="line">		OutputStream out = client.getOutputStream();</span><br><span class="line">		<span class="comment">//3.创建文件的输入流,读取本地的文件数据</span></span><br><span class="line">		FileInputStream fis = </span><br><span class="line">            <span class="keyword">new</span> FileInputStream(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\我.jpg"</span>);</span><br><span class="line">		<span class="comment">//4.循环,读取本地文件,写到服务器</span></span><br><span class="line">		<span class="keyword">byte</span>[] bs = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>((len=fis.read(bs))!=-<span class="number">1</span>)&#123;</span><br><span class="line">			out.write(bs, <span class="number">0</span>, len);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//关闭输出流</span></span><br><span class="line">		client.shutdownOutput();</span><br><span class="line">		<span class="comment">//5.获取服务器反馈的信息</span></span><br><span class="line">		InputStream in = client.getInputStream();</span><br><span class="line">		<span class="keyword">byte</span>[] bs1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">		<span class="keyword">int</span> len1 = in.read(bs1);</span><br><span class="line">		System.out.println(<span class="string">"服务器说:"</span>+<span class="keyword">new</span> String(bs1,<span class="number">0</span>,len1));</span><br><span class="line">		<span class="comment">//6关闭</span></span><br><span class="line">		client.close();</span><br><span class="line">		out.close();</span><br><span class="line">		fis.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Socket属性"><a href="#Socket属性" class="headerlink" title="Socket属性"></a>Socket属性</h3><ul><li>TCP_NODELAY：是否采用nagle算法。</li><li>SO_REUSEADDR：表示是否允许重用Socket所绑定的本地地址。</li><li>SO_TIMEOUT：表示接收数据时的等待超时时间。</li><li>SO_SNFBUF：表示发送数据的缓冲区的大小。</li><li>SO_RCVBUF：表示接收数据的缓冲区的大小。</li><li>SO_KEEPALIVE：表示对于长时间处于空闲状态的Socket，是否要自动把它关闭。</li><li>SO_LINGER：表示当执行Socket的close()方法时，是否立即关闭底层的Socket。默认第一种。</li></ul><table><thead><tr><th>on</th><th style="text-align:center">linger</th><th style="text-align:center">closesocket行为</th><th style="text-align:center">发送队列</th><th style="text-align:center">底层行为</th></tr></thead><tbody><tr><td>true</td><td style="text-align:center">忽略</td><td style="text-align:center">立即返回。</td><td style="text-align:center">保持直至发送完成。</td><td style="text-align:center">系统接管套接字并保证将数据发送至对端。</td></tr><tr><td>false</td><td style="text-align:center">零</td><td style="text-align:center">立即返回。</td><td style="text-align:center">立即放弃。</td><td style="text-align:center">直接发送RST包，自身立即复位，不用经过2MSL状态。对端收到复位错误号。</td></tr><tr><td>false</td><td style="text-align:center">非零</td><td style="text-align:center">阻塞直到linger时间超时或数据发送完成。(套接字必须设置为阻塞状态)</td><td style="text-align:center">在超时时间段内保持尝试发送，若超时则立即放弃。</td><td style="text-align:center">超时则同第二种情况，若发送完成则皆大欢喜。</td></tr></tbody></table><ul><li><p>OOBINLINE：Enable/disable SO_OOBINLINE(receipt of TCP urgent data)By default, this option is disabled and TCP urgent data received on a socket is silently discarded. If the user wishes to receive urgent data, then this option must be enabled. When enabled, urgent data is received inline with normal data.</p><p>Note, only limited support is provided for handling incoming urgent data. In particular, no notification of incoming urgent data is provided and there is no capability to distinguish between normal data and urgentdata unless provided by a higher level protocol.</p></li><li><p>PerformancePreferences：设置连接时间、低延迟、高带宽之间的权重。</p></li></ul><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>Java NIO的通道类似流，但又有些不同：</p><ul><li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li><li>通道可以异步地读写。</li><li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li></ul><p>java.nio.channels.Channel接口只声明了两个方法：</p><ul><li>close()：关闭通道。</li><li>isOpen()：判断通道是否打开。</li></ul><p>通道在创建时被打开，一旦关闭通道，就不能重新打开它。</p><h3 id="Channel的实现"><a href="#Channel的实现" class="headerlink" title="Channel的实现"></a>Channel的实现</h3><p>这些是Java NIO中最重要的通道的实现：</p><ul><li>FileChannel：从文件中读写数据。</li><li>DatagramChannel：能通过UDP读写网络中的数据。</li><li>SocketChannel：能通过TCP读写网络中的数据。</li><li>ServerSocketChannel：可以监听新进来的TCP连接，像Web服务器那样。对每一个新进来的连接都会创建一个SocketChannel。</li></ul><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><p>Java NIO中的Buffer用于和NIO通道进行交互。如你所知，数据是从通道读入缓冲区，从缓冲区写入到通道中的。缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/Buffer和Channel.png"></div><br>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。为了理解Buffer的工作原理，需要熟悉它的三个属性：<p></p><ul><li>capacity：作为一个内存块，Buffer有一个固定的大小值，叫“capacity”。你只能往对应的Buffer里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</li><li>position：<ul><li>当你写数据到Buffer中时，position表示当前的位置。初始的position值为0，当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1。</li><li>当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</li></ul></li><li>limit：<ul><li>写模式下，Buffer的limit表示你最多能往Buffer里写多少数据，此时limit等于Buffer的capacity。</li><li>当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</li></ul></li></ul><h3 id="Buffer的实现"><a href="#Buffer的实现" class="headerlink" title="Buffer的实现"></a>Buffer的实现</h3><p>Java NIO 有以下Buffer类型</p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer</li></ul><h2 id="Buffer详解"><a href="#Buffer详解" class="headerlink" title="Buffer详解"></a>Buffer详解</h2><p>在我们刚才的说明中提到了写模式和读模式，但是实际上这只是被强行赋予的，即JDK中并没有说法，这么说只是为了更方便的理解，所以下面我们来解读一下Buffer的API及怎么在两种模式之间进行切换。</p><p>需要指出：写模式指的是想Buffer写入，读模式是从Buffer里读出。</p><h3 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h3><ul><li><p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。<code>ByteBuffer buf = ByteBuffer.allocate(48);</code></p></li><li><p>这是分配一个可存储1024个字符的CharBuffer：<code>CharBuffer buf = CharBuffer.allocate(1024);</code></p></li></ul><p><strong>刚获得的Buffer默认是写模式。</strong></p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/分配之后.png"></div><p></p><h3 id="向Buffer中写数据"><a href="#向Buffer中写数据" class="headerlink" title="向Buffer中写数据"></a>向Buffer中写数据</h3><p>写数据到Buffer有两种方式：</p><ul><li>从Channel写到Buffer：<code>int bytesRead = inChannel.read(buf); //read into buffer</code><ul><li>bytesRead指读出的数据大小。当bytesRead为-1时表示缓存区中不再有数据。</li></ul></li><li>通过Buffer的put()方法写到Buffer里：<code>buf.put(127);</code><ul><li>put()：相对写。向缓冲区的当前位置写入一个单元的数据，写完后把位置加1。</li><li>put(int index)：绝对写。向参数index指定的位置写入一个单元的数据。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * test_in是有数据的文件，用于被读入至Java程序</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		RandomAccessFile fileIn = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_in"</span>, <span class="string">"rw"</span>);</span><br><span class="line">		</span><br><span class="line">		FileChannel inChannel = fileIn.getChannel();</span><br><span class="line">		</span><br><span class="line">		ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">int</span> bytesRead = inChannel.read(buf);</span><br><span class="line">		<span class="keyword">while</span> (bytesRead != -<span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">			System.out.println(<span class="string">"Read "</span> + bytesRead);</span><br><span class="line">			buf.flip();		<span class="comment">//写模式切换为读模式</span></span><br><span class="line">			System.out.println(charset.decode(buf).toString());</span><br><span class="line">			buf.clear();</span><br><span class="line">			bytesRead = inChannel.read(buf);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">		fileIn.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>inChannel.read(buf);</code>之后，<code>buf.flip();</code>之前Buffer的状态：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/写模式.png"></div><p></p><h3 id="向Channel中写数据"><a href="#向Channel中写数据" class="headerlink" title="向Channel中写数据"></a>向Channel中写数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * test_in是有数据的文件，用于被读入至Java程序</span></span><br><span class="line"><span class="comment">		 * test_out中没有数据，用于Java程序的写出</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		RandomAccessFile fileIn = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_in"</span>, <span class="string">"rw"</span>);</span><br><span class="line">		RandomAccessFile fileOut = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_out"</span>, <span class="string">"rw"</span>);</span><br><span class="line">		</span><br><span class="line">		FileChannel inChannel = fileIn.getChannel();</span><br><span class="line">		FileChannel outChannel = fileOut.getChannel();</span><br><span class="line">		</span><br><span class="line">		ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">		<span class="keyword">int</span> bytesRead = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			bytesRead = inChannel.read(buf);</span><br><span class="line">			System.out.println(<span class="string">"Read "</span> + bytesRead);</span><br><span class="line">			buf.flip();		<span class="comment">//写模式切换为读模式</span></span><br><span class="line">			outChannel.write(buf);</span><br><span class="line">			buf.clear();</span><br><span class="line">		&#125;<span class="keyword">while</span>(bytesRead != -<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		fileIn.close();</span><br><span class="line">		fileOut.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>buf.flip();</code>之后，<code>outChannel.write(buf);</code>之前Buffer的状态。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/flip之后.png"></div><p></p><h3 id="测试limit"><a href="#测试limit" class="headerlink" title="测试limit"></a>测试limit</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		 * test_in是有数据的文件，用于被读入至Java程序</span></span><br><span class="line"><span class="comment">		 * test_out中没有数据，用于Java程序的写出</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		RandomAccessFile fileIn = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_in"</span>, <span class="string">"rw"</span>);</span><br><span class="line">		RandomAccessFile fileOut = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_out"</span>, <span class="string">"rw"</span>);</span><br><span class="line">		</span><br><span class="line">		FileChannel inChannel = fileIn.getChannel();</span><br><span class="line">		FileChannel outChannel = fileOut.getChannel();</span><br><span class="line">		</span><br><span class="line">		ByteBuffer buf = ByteBuffer.allocate(<span class="number">48</span>);</span><br><span class="line">		<span class="keyword">int</span> bytesRead = -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			bytesRead = inChannel.read(buf);</span><br><span class="line">			System.out.println(<span class="string">"写模式下： "</span> + buf.limit());</span><br><span class="line">			buf.flip();		<span class="comment">//写模式切换为读模式</span></span><br><span class="line">			System.out.println(<span class="string">"读模式下： "</span> + buf.limit());</span><br><span class="line">			outChannel.write(buf);</span><br><span class="line">			buf.clear();</span><br><span class="line">		&#125;<span class="keyword">while</span>(bytesRead != -<span class="number">1</span>);</span><br><span class="line">		</span><br><span class="line">		fileIn.close();</span><br><span class="line">		fileOut.close();</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rewind-方法"><a href="#rewind-方法" class="headerlink" title="rewind()方法"></a>rewind()方法</h3><p>Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。</p><h3 id="clear-与compact-方法"><a href="#clear-与compact-方法" class="headerlink" title="clear()与compact()方法"></a>clear()与compact()方法</h3><p>一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。</p><p>如果调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer被清空了。Buffer中的数据并未清除。如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</p><p>如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p><h3 id="mark-与reset-方法"><a href="#mark-与reset-方法" class="headerlink" title="mark()与reset()方法"></a>mark()与reset()方法</h3><p>通过调用Buffer.mark()方法，可以标记Buffer中的一个特定位置。之后可以通过调用Buffer.reset()方法将position置于这个位置。</p><h3 id="equals-与compareTo-方法"><a href="#equals-与compareTo-方法" class="headerlink" title="equals()与compareTo()方法"></a>equals()与compareTo()方法</h3><h4 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h4><p>当满足下列条件时，表示两个Buffer相等：</p><ol><li>有相同的类型（byte、char、int等）。</li><li>Buffer中剩余的byte、char等的个数相等。</li><li>Buffer中所有剩余的byte、char等都相同。</li></ol><p>如你所见，equals只是比较Buffer的一部分，不是每一个在它里面的元素都比较。实际上，它只比较Buffer中的剩余元素。</p><h4 id="compareTo-方法"><a href="#compareTo-方法" class="headerlink" title="compareTo()方法"></a>compareTo()方法</h4><p>compareTo()方法比较两个Buffer的剩余元素(byte、char等)， 如果满足下列条件，则认为一个Buffer“小于”另一个Buffer：</p><ol><li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li><li>所有元素都相等，但第一个Buffer比另一个先耗尽（第一个Buffer的元素个数比另一个少）。</li></ol><h2 id="Scatter-Gather"><a href="#Scatter-Gather" class="headerlink" title="Scatter/Gather"></a>Scatter/Gather</h2><ul><li>scatter：分散，从Channel中读取是指在读操作时将读取的数据写入多个buffer中。因此，Channel将从Channel中读取的数据“分散（scatter）”到多个Buffer中。</li></ul><p>Scattering Reads是指数据从一个channel读取到多个buffer中。如下图描述：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/scatter.png"></div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Charset charset = Charset.forName(<span class="string">"UTF-8"</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		RandomAccessFile file = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_in"</span>, <span class="string">"rw"</span>);</span><br><span class="line">		FileChannel channel = file.getChannel();</span><br><span class="line">		ByteBuffer header = ByteBuffer.allocate(<span class="number">6</span>);</span><br><span class="line">		ByteBuffer body   = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line">		ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line">		<span class="keyword">long</span> read = channel.read(bufferArray);</span><br><span class="line">		System.out.println(read);</span><br><span class="line">		header.flip();</span><br><span class="line">		body.flip();</span><br><span class="line">		System.out.println(charset.decode(header).toString());</span><br><span class="line">		System.out.println(charset.decode(body).toString());		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p>read()方法按照buffer在数组中的顺序将从channel中读取的数据写入到buffer，当一个buffer被写满后，channel紧接着向另一个buffer中写。</p><p>Scattering Reads在移动下一个buffer前，必须填满当前的buffer，这也意味着它不适用于动态消息（消息大小不固定）。换句话说，如果存在消息头和消息体，消息头必须完成填充（例如 128byte），Scattering Reads才能正常工作。</p><ul><li>gather：聚集，写入Channel是指在写操作时将多个buffer的数据写入同一个Channel，因此，Channel 将多个Buffer中的数据“聚集（gather）”后发送到Channel。</li></ul><p>Gathering Writes是指数据从多个buffer写入到同一个channel。如下图描述：</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/gather.png"></div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line">		RandomAccessFile fileOut = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_out"</span>, <span class="string">"rw"</span>);</span><br><span class="line">		FileChannel channelOut = fileOut.getChannel();</span><br><span class="line">		</span><br><span class="line">		ByteBuffer header = ByteBuffer.allocate(<span class="number">6</span>);</span><br><span class="line">		ByteBuffer body   = ByteBuffer.allocate(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line">		header.put(<span class="string">"陈"</span>.getBytes());</span><br><span class="line">		body.put(<span class="string">"钰琪是个大可爱"</span>.getBytes());</span><br><span class="line">		ByteBuffer[] bufferArray = &#123; header, body &#125;;</span><br><span class="line">		</span><br><span class="line">		header.flip();</span><br><span class="line">		body.flip();</span><br><span class="line">		</span><br><span class="line">		channelOut.write(bufferArray);</span><br><span class="line">		fileOut.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><h2 id="通道之间的数据传输"><a href="#通道之间的数据传输" class="headerlink" title="通道之间的数据传输"></a>通道之间的数据传输</h2><p>在Java NIO中，如果两个通道中有一个是FileChannel，那你可以直接将数据从一个channel传输到另外一个channel。</p><h3 id="transferFrom"><a href="#transferFrom" class="headerlink" title="transferFrom()"></a>transferFrom()</h3><p>FileChannel的transferFrom()方法可以将数据从源通道传输到FileChannel中（这个方法在JDK文档中的解释为将字节从给定的可读取字节通道传输到此通道的文件中）。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo5</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line">		RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_in"</span>, <span class="string">"rw"</span>);</span><br><span class="line">		FileChannel fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">		RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_out"</span>, <span class="string">"rw"</span>);</span><br><span class="line">		FileChannel toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">		toChannel.transferFrom(fromChannel, position, count);</span><br><span class="line">	</span><br><span class="line">		fromFile.close();</span><br><span class="line">		toFile.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="transferTo"><a href="#transferTo" class="headerlink" title="transferTo()"></a>transferTo()</h3><p>将数据从FileChannel传输到其他的channe中。下面是一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.RandomAccessFile;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.FileChannel;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo6</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		</span><br><span class="line">		RandomAccessFile fromFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_in"</span>, <span class="string">"rw"</span>);</span><br><span class="line">		FileChannel      fromChannel = fromFile.getChannel();</span><br><span class="line"></span><br><span class="line">		RandomAccessFile toFile = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test_out"</span>, <span class="string">"rw"</span>);</span><br><span class="line">		FileChannel      toChannel = toFile.getChannel();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">long</span> position = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">long</span> count = fromChannel.size();</span><br><span class="line"></span><br><span class="line">		fromChannel.transferTo(position, count, toChannel);</span><br><span class="line">		</span><br><span class="line">		fromFile.close();</span><br><span class="line">		toFile.close();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>服务器程序只需要一个线程就能同时负责接收客户的连接、接收各个客户发送的数据，以及向各个客户发送响应数据。服务器程序的处理流程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(一直等待，直到有接收连接就绪事件、读就绪事件或写就绪事件发生)&#123; <span class="comment">//阻塞</span></span><br><span class="line">	<span class="keyword">if</span>(有客户连接)</span><br><span class="line">		接收客户的连接; <span class="comment">//非阻塞</span></span><br><span class="line">	<span class="keyword">if</span>(某个Socket的输入流中有可读数据)</span><br><span class="line">		从输入流中读数据; <span class="comment">//非阻塞</span></span><br><span class="line">	<span class="keyword">if</span>(某个Socket的输出流可以写数据)</span><br><span class="line">		向输出流写数据; <span class="comment">//非阻塞</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上处理流程采用了轮询的工作方式，当某一种操作就绪，就执行该操作，否则就察看是否还有其他就绪的操作可以执行。线程不会因为某一个操作还没有就绪，就进入阻塞状态，一直傻傻的在那里等待这个操作就绪。</p><p></p><div align="center"><img src="//isjinhao.github.io/2019/03-IO流和网络/非阻塞技术模型.png"></div><p></p><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>Selector（选择器）是Java NIO中能够检测一到多个NIO通道，并能够知晓通道是否为诸如读写事件做好准备的组件。这样，一个单独的线程可以管理多个channel，从而管理多个网络连接。</p><h3 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h3><p>通过调用Selector.open()方法创建一个Selector，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Selector selector = Selector.open();</span><br></pre></td></tr></table></figure><h3 id="向Selector注册通道"><a href="#向Selector注册通道" class="headerlink" title="向Selector注册通道"></a>向Selector注册通道</h3><p>为了将Channel和Selector配合使用，必须将channel注册到selector上。通过SelectableChannel.register()方法来实现，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">SelectionKey key = channel.register(selector, Selectionkey.OP_READ);</span><br></pre></td></tr></table></figure><p>与Selector一起使用时，Channel必须处于非阻塞模式下。这意味着不能将FileChannel与Selector一起使用，因为FileChannel不能切换到非阻塞模式。而套接字通道都可以。</p><p>注意register()方法的第二个参数。这是一个“interest集合”，意思是在通过Selector监听Channel时对什么事件感兴趣。可以监听四种不同类型的事件：</p><ul><li>SelectionKey.OP_ACCEPT：接收连接就绪事件，表示服务器监听到了客户连接，服务器可以接收这个连接了。常量值为16</li><li>SelectionKey.OP_CONNECT：连接就绪事件，表示客户与服务器的连接已经建立成功。常量值为8。</li><li>SelectionKey.OP_READ：读就绪事件，表示通道中已经有了可读数据，可以执行读操作了。常量值为1。</li><li>SelectionKey.OP_WRITE：写就绪事件，表示已经可以向通道写数据了。常量值为4。</li></ul><p>以上常量分别占居不同的二进制位，因此可以通过二进制的或运算“|”，来将它们进行任意组合。</p><p>总结来说：通道触发了一个事件意思是该事件已经就绪。所以，某个channel成功连接到另一个服务器称为“连接就绪”。一个serverSocketChannel准备好接收新进入的连接称为“接收就绪”。一个有数据可读的通道可以说是“读就绪”。等待写数据的通道可以说是“写就绪”。</p><h3 id="SelectionKey"><a href="#SelectionKey" class="headerlink" title="SelectionKey"></a>SelectionKey</h3><p>在上一小节中，当向Selector注册Channel时，register()方法会返回一个SelectionKey对象。这个对象包含了一些你感兴趣的属性：</p><ul><li>interest集合</li><li>ready集合</li><li>Channel</li><li>Selector</li><li>附加的对象（可选）</li></ul><h4 id="interest集合"><a href="#interest集合" class="headerlink" title="interest集合"></a>interest集合</h4><p>就像向Selector注册通道一节中所描述的，interest集合是你所选择的感兴趣的事件集合。可以通过SelectionKey读写interest集合，像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> interestSet = selectionKey.interestOps();</span><br><span class="line"><span class="keyword">boolean</span> isInterestedInAccept  = </span><br><span class="line">	(interestSet &amp; SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT；</span><br><span class="line"><span class="comment">//  其他的也类似...</span></span><br></pre></td></tr></table></figure><h4 id="ready集合"><a href="#ready集合" class="headerlink" title="ready集合"></a>ready集合</h4><p>ready 集合是通道已经准备就绪的操作的集合。在一次选择（Selection）之后，你会首先访问这个ready set。Selection将在下一小节进行解释。可以这样访问ready集合：<code>intreadySet = selectionKey.readyOps();</code></p><p>可以用像检测interest集合那样的方法，来检测channel中什么事件或操作已经就绪。但是，也可以使用以下四个方法，它们都会返回一个布尔类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.isAcceptable();</span><br><span class="line">selectionKey.isConnectable();</span><br><span class="line">selectionKey.isReadable();</span><br><span class="line">selectionKey.isWritable();</span><br></pre></td></tr></table></figure><h4 id="Channel-Selector"><a href="#Channel-Selector" class="headerlink" title="Channel + Selector"></a>Channel + Selector</h4><p>从SelectionKey访问Channel和Selector很简单。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Channel  channel  = selectionKey.channel();</span><br><span class="line">Selector selector = selectionKey.selector();</span><br></pre></td></tr></table></figure><h4 id="附加的对象"><a href="#附加的对象" class="headerlink" title="附加的对象"></a>附加的对象</h4><p>可以将一个对象或者更多信息附着到SelectionKey上，这样就能方便的识别某个给定的通道。例如，可以附加 与通道一起使用的Buffer，或是包含聚集数据的某个对象。使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">selectionKey.attach(theObject);</span><br><span class="line">Object attachedObj = selectionKey.attachment();</span><br></pre></td></tr></table></figure><p>还可以在用register()方法向Selector注册Channel的时候附加对象。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SelectionKey key = channel.register(selector, SelectionKey.OP_READ, theObject);</span><br></pre></td></tr></table></figure><h3 id="通过Selector选择通道"><a href="#通过Selector选择通道" class="headerlink" title="通过Selector选择通道"></a>通过Selector选择通道</h3><p>一旦向Selector注册了一或多个通道，就可以调用几个重载的select()方法。这些方法返回你所感兴趣的事件（如连接、接受、读或写）已经准备就绪的那些通道。换句话说，如果你对“读就绪”的通道感兴趣，select()方法会返回读事件已经就绪的那些通道。</p><p>下面是select()方法：</p><ul><li>int select()：阻塞到至少有一个通道在你注册的事件上就绪了。</li><li>int select(long timeout)：和select()一样，除了最长会阻塞timeout毫秒(参数)。</li><li>int selectNow()：不会阻塞，不管什么通道就绪都立刻返回（<em>此方法执行非阻塞的选择操作。如果自从前一次选择操作后，没有通道变成可选择的，则此方法直接返回零。</em>）。</li></ul><p>select()方法返回的int值表示有多少通道已经就绪。亦即，自上次调用select()方法后有多少通道变成就绪状态。如果调用select()方法，因为有一个通道变成就绪状态，返回了1，若再次调用select()方法，如果另一个通道就绪了，它会再次返回1。如果对第一个就绪的channel没有做任何操作，现在就有两个就绪的通道，但在每次select()方法调用之间，只有一个通道就绪了。</p><h4 id="selectedKeys"><a href="#selectedKeys" class="headerlink" title="selectedKeys()"></a>selectedKeys()</h4><p>一旦调用了select()方法，并且返回值表明有一个或更多个通道就绪了，然后可以通过调用selector的selectedKeys()方法，访问“已选择键集（selected key set）”中的就绪通道。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br></pre></td></tr></table></figure><p>当像Selector注册Channel时，Channel.register()方法会返回一个SelectionKey 对象。这个对象代表了注册到该Selector的通道。可以通过SelectionKey的selectedKeySet()方法访问这些对象。</p><p>可以遍历这个已选择的键集合来访问就绪的通道。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Set selectedKeys = selector.selectedKeys();</span><br><span class="line">Iterator keyIterator = selectedKeys.iterator();</span><br><span class="line"><span class="keyword">while</span>(keyIterator.hasNext()) &#123;</span><br><span class="line">    SelectionKey key = keyIterator.next();</span><br><span class="line">    <span class="keyword">if</span>(key.isAcceptable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was accepted by a ServerSocketChannel.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isConnectable()) &#123;</span><br><span class="line">        <span class="comment">// a connection was established with a remote server.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for reading</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">        <span class="comment">// a channel is ready for writing</span></span><br><span class="line">    &#125;</span><br><span class="line">    keyIterator.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个循环遍历已选择键集中的每个键，并检测各个键所对应的通道的就绪事件。注意每次迭代末尾的keyIterator.remove()调用。Selector不会自己从已选择键集中移除SelectionKey实例。必须在处理完通道时自己移除。下次该通道变成就绪时，Selector会再次将其放入已选择键集中。</p><p>SelectionKey.channel()方法返回的通道需要转型成你要处理的类型，如ServerSocketChannel或SocketChannel等。</p><h2 id="SocketChannel"><a href="#SocketChannel" class="headerlink" title="SocketChannel"></a>SocketChannel</h2><h3 id="打开-SocketChannel"><a href="#打开-SocketChannel" class="headerlink" title="打开 SocketChannel"></a>打开 SocketChannel</h3><p>下面是SocketChannel的打开方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SocketChannel socketChannel = SocketChannel.open();</span><br><span class="line">socketChannel.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"127.0.0.1"</span>, <span class="number">20000</span>));</span><br></pre></td></tr></table></figure><h3 id="关闭-SocketChannel"><a href="#关闭-SocketChannel" class="headerlink" title="关闭 SocketChannel"></a>关闭 SocketChannel</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socketChannel.close();</span><br></pre></td></tr></table></figure><h2 id="ServerSocketChannel"><a href="#ServerSocketChannel" class="headerlink" title="ServerSocketChannel"></a>ServerSocketChannel</h2><p>Java NIO中的 ServerSocketChannel 是一个可以监听新进来的TCP连接的通道, 就像标准IO中的ServerSocket一样。ServerSocketChannel类在 java.nio.channels包中。</p><h3 id="打开-ServerSocketChannel"><a href="#打开-ServerSocketChannel" class="headerlink" title="打开 ServerSocketChannel"></a>打开 ServerSocketChannel</h3><p>通过调用 ServerSocketChannel.open() 方法来打开ServerSocketChannel，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br></pre></td></tr></table></figure><h3 id="关闭-ServerSocketChannel"><a href="#关闭-ServerSocketChannel" class="headerlink" title="关闭 ServerSocketChannel"></a>关闭 ServerSocketChannel</h3><p>通过调用ServerSocketChannel.close() 方法来关闭ServerSocketChannel，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serverSocketChannel.close();</span><br></pre></td></tr></table></figure><h3 id="监听新进来的连接"><a href="#监听新进来的连接" class="headerlink" title="监听新进来的连接"></a>监听新进来的连接</h3><p>通过 ServerSocketChannel.accept() 方法监听新进来的连接。当 accept()方法返回的时候,它返回一个包含新进来的连接的 SocketChannel。因此, accept()方法会一直阻塞到有新连接到达。</p><p>通常不会仅仅只监听一个连接,在while循环中调用 accept()方法，如下面的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel =</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//do something with socketChannel...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然，也可以在while循环中使用除了true以外的其它退出准则。</p><h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>ServerSocketChannel可以设置成非阻塞模式。在非阻塞模式下，accept() 方法会立刻返回，如果还没有新进来的连接,返回的将是null。 因此，需要检查返回的SocketChannel是否是null，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">9999</span>));</span><br><span class="line">serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">    SocketChannel socketChannel =</span><br><span class="line">            serverSocketChannel.accept();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(socketChannel != <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="comment">//do something with socketChannel...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务器使用NIO向客户端Echo数据的例子"><a href="#服务器使用NIO向客户端Echo数据的例子" class="headerlink" title="服务器使用NIO向客户端Echo数据的例子"></a>服务器使用NIO向客户端Echo数据的例子</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ClosedChannelException;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.ServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.charset.Charset;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoSeverZJH</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Selector selector;</span><br><span class="line">	<span class="keyword">private</span> ServerSocketChannel serverSocketChannel;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">8000</span>;</span><br><span class="line">	<span class="keyword">private</span> Charset charset = Charset.forName(<span class="string">"utf-8"</span>);</span><br><span class="line">	<span class="keyword">private</span> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">EchoSeverZJH</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			selector = Selector.open();</span><br><span class="line">			serverSocketChannel = ServerSocketChannel.open();</span><br><span class="line">			serverSocketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">			serverSocketChannel.socket().setReuseAddress(<span class="keyword">true</span>);</span><br><span class="line">			serverSocketChannel.socket().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">			e1.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"服务器开启成功... : "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">		list.add(<span class="string">"一共有18018条航班数据"</span>);</span><br><span class="line">		<span class="keyword">try</span> (Scanner cin = <span class="keyword">new</span> Scanner(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"copy"</span>)))) &#123;</span><br><span class="line">			String line = <span class="keyword">null</span>;</span><br><span class="line">			<span class="keyword">while</span>(cin.hasNext()) &#123;</span><br><span class="line">				line = cin.nextLine();</span><br><span class="line">				list.add(line);</span><br><span class="line">			&#125;</span><br><span class="line">			list.add(<span class="string">"no data"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		num = list.size();</span><br><span class="line">		System.out.println(<span class="string">"数据已准备好... : "</span> + <span class="keyword">new</span> Date());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">			<span class="comment">//没有连接就会阻塞</span></span><br><span class="line">			<span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				n = selector.select();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			Set&lt;SelectionKey&gt; readkeys = selector.selectedKeys();</span><br><span class="line">			Iterator&lt;SelectionKey&gt; iterator = readkeys.iterator();</span><br><span class="line">			<span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">				SelectionKey key = iterator.next();</span><br><span class="line">				<span class="keyword">if</span>(!key.isValid()) &#123;</span><br><span class="line">					iterator.remove();</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">					accept(key);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">					send(key);</span><br><span class="line">				&#125;</span><br><span class="line">				iterator.remove();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理接收连接就绪事件</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">		<span class="comment">// 返回一个对象</span></span><br><span class="line">		SocketChannel socketChannel;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			socketChannel = serverSocketChannel.accept();</span><br><span class="line">			System.out.println(<span class="string">"收到了客户端连接，来自 ： "</span> + socketChannel.getRemoteAddress());</span><br><span class="line">			socketChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">			<span class="comment">//注册到selector</span></span><br><span class="line">			socketChannel.register(selector, SelectionKey.OP_WRITE, <span class="number">0</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 处理写就绪事件</span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(SelectionKey key)</span></span>&#123;</span><br><span class="line">		SocketChannel socketChannel = (SocketChannel) key.channel();</span><br><span class="line">		<span class="keyword">int</span> index = (<span class="keyword">int</span>)key.attachment();</span><br><span class="line">		key.attach((index + <span class="number">1</span>) % num);</span><br><span class="line">		String line = list.get(index);</span><br><span class="line">		ByteBuffer outputBuffer = charset.encode(line + <span class="string">"\r\n"</span>);</span><br><span class="line">		<span class="keyword">while</span> (outputBuffer.hasRemaining()) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				socketChannel.write(outputBuffer);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				key.cancel();</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					System.out.println(socketChannel.getRemoteAddress() + <span class="string">"   断开连接----"</span>);</span><br><span class="line">					socketChannel.socket().close();</span><br><span class="line">					socketChannel.close();</span><br><span class="line">					outputBuffer.clear();</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e1) &#123;</span><br><span class="line">					e1.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">		<span class="keyword">new</span> EchoSeverZJH().service();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.core;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReadFromSocket</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Socket socket = <span class="keyword">null</span>;</span><br><span class="line">		Scanner sc = <span class="keyword">null</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			socket = <span class="keyword">new</span> Socket(InetAddress.getByName(<span class="string">"127.0.0.1"</span>), <span class="number">8000</span>);</span><br><span class="line">			String line = <span class="keyword">null</span>;</span><br><span class="line">			sc = <span class="keyword">new</span> Scanner(socket.getInputStream());</span><br><span class="line">			line = sc.nextLine();</span><br><span class="line">			System.out.println(line);</span><br><span class="line">			<span class="keyword">while</span> (sc.hasNext()) &#123;</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				line = sc.nextLine();</span><br><span class="line">				System.out.println(line);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				socket.close();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">			sc.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Selector维护的集合"><a href="#Selector维护的集合" class="headerlink" title="Selector维护的集合"></a>Selector维护的集合</h2><p>对上面的代码有一个很大的疑问，即服务器端为什么要进行<code>iterator.remove();</code>。解答这个问题之前我们先来理一下思路：</p><ol><li>服务器端有一个<code>ServerSocketChannel</code>，它绑定了端口号，且设置为非阻塞模式，它先向<code>Selector</code>中注册：<code>serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);</code>。ServerSocketChannel在注册的时候指定的事件是：<code>OP_ACCEPT</code>，表示接收连接就绪事件，即服务器在监听客户连接。</li><li>每一个注册到<code>selector</code>上的<code>channel</code>都会被加入一个集合（key set），这个集合可以通过<code>selector.keys()</code>方法返回。</li><li>然后判断已经准备好的连接<code>n = selector.select();</code>有几个，如果等于0则表示没有准备好的连接，此时需要<code>continue</code>。其中，已经准备好的连接可以按如下获得：<code>Set&lt;SelectionKey&gt; readkeys = selector.selectedKeys();</code>。即所有已经准备好channel都在一个集合（selected-key）中。</li><li>但是selected-key本身并不是线程安全的，所以在处理的时候需要判断其是不是已经合法的，比如如果客户端中断了访问，则不能在传输数据，即其实不合法的。</li></ol><p>同时，每个都撤销的channel都在<code>cancelled-key set</code>中，但是所关联<code>channel</code>还没有被撤销登记。其不能够被直接返回，但也一定是key set的子集。</p><p>所以我们移出的其实只是已准备好的channel的key。</p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-如果您有什么建议，推荐使用右下角的DaoVoice与我联系-</div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读！-------------</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div></div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/weichatpay.png" alt="ISJINHAO 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.jpg" alt="ISJINHAO 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/应届求职复习/" rel="tag"># 应届求职复习</a> <a href="/tags/面试/" rel="tag"># 面试</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/02-MySQL/" rel="next" title="02-MySQL"><i class="fa fa-chevron-left"></i> 02-MySQL</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/04-操作系统和Linux/" rel="prev" title="04-操作系统和Linux">04-操作系统和Linux <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80MjQ4NC8xOTAzMQ=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="ISJINHAO"><p class="site-author-name" itemprop="name">ISJINHAO</p><p class="site-description motion-element" itemprop="description">Living & Working</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">120</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">31</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">60</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/isjinhao" title="GitHub &rarr; https://github.com/isjinhao" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_38206090" title="CSDN &rarr; https://blog.csdn.net/qq_38206090" rel="noopener" target="_blank"><i class="fa fa-fw fa-heartbeat"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:isjinhao@163.com" title="E-Mail &rarr; mailto:isjinhao@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://http://59.110.143.226/qz/0.html" title="http://http://59.110.143.226/qz/0.html" rel="noopener" target="_blank">求职（Java后台开发）</a></li><li class="links-of-blogroll-item"><a href="http://http://59.110.143.226/Sharing-Your-Story" title="http://http://59.110.143.226/Sharing-Your-Story" rel="noopener" target="_blank">博客涉及到的软件</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#IO流"><span class="nav-number">1.</span> <span class="nav-text">IO流</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#构造方法"><span class="nav-number">1.1.</span> <span class="nav-text">构造方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机网络"><span class="nav-number">2.</span> <span class="nav-text">计算机网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#信道"><span class="nav-number">2.1.</span> <span class="nav-text">信道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#主机（host）"><span class="nav-number">2.2.</span> <span class="nav-text">主机（host）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交换机"><span class="nav-number">2.3.</span> <span class="nav-text">交换机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组"><span class="nav-number">2.4.</span> <span class="nav-text">分组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由器"><span class="nav-number">2.5.</span> <span class="nav-text">路由器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#计算机网络基本原理"><span class="nav-number">3.</span> <span class="nav-text">计算机网络基本原理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分组交换技术"><span class="nav-number">3.1.</span> <span class="nav-text">分组交换技术</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Internet"><span class="nav-number">4.</span> <span class="nav-text">Internet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#组成细节角度"><span class="nav-number">4.1.</span> <span class="nav-text">组成细节角度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#服务角度"><span class="nav-number">4.2.</span> <span class="nav-text">服务角度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ISP"><span class="nav-number">4.3.</span> <span class="nav-text">ISP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IXP"><span class="nav-number">4.4.</span> <span class="nav-text">IXP</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络的结构"><span class="nav-number">5.</span> <span class="nav-text">网络的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#网络应用模型"><span class="nav-number">5.1.</span> <span class="nav-text">网络应用模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#接入网络"><span class="nav-number">6.</span> <span class="nav-text">接入网络</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#数字用户线路：DSL"><span class="nav-number">6.1.</span> <span class="nav-text">数字用户线路：DSL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#电缆网络"><span class="nav-number">6.2.</span> <span class="nav-text">电缆网络</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常见网络接入"><span class="nav-number">6.3.</span> <span class="nav-text">常见网络接入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#家庭接入"><span class="nav-number">6.3.1.</span> <span class="nav-text">家庭接入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#机构（企业）接入"><span class="nav-number">6.3.2.</span> <span class="nav-text">机构（企业）接入</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#无线局域网"><span class="nav-number">6.3.3.</span> <span class="nav-text">无线局域网</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#广域局域网"><span class="nav-number">6.3.4.</span> <span class="nav-text">广域局域网</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络核心"><span class="nav-number">7.</span> <span class="nav-text">网络核心</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Internet结构"><span class="nav-number">8.</span> <span class="nav-text">Internet结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据交换方式"><span class="nav-number">9.</span> <span class="nav-text">数据交换方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#电路交换"><span class="nav-number">9.1.</span> <span class="nav-text">电路交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#报文交换"><span class="nav-number">9.2.</span> <span class="nav-text">报文交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组交换"><span class="nav-number">9.3.</span> <span class="nav-text">分组交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#图解三种交换"><span class="nav-number">9.4.</span> <span class="nav-text">图解三种交换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组交换的优势"><span class="nav-number">9.5.</span> <span class="nav-text">分组交换的优势</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分组交换的劣势"><span class="nav-number">9.6.</span> <span class="nav-text">分组交换的劣势</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RFC文档"><span class="nav-number">10.</span> <span class="nav-text">RFC文档</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IETF"><span class="nav-number">11.</span> <span class="nav-text">IETF</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络协议"><span class="nav-number">12.</span> <span class="nav-text">网络协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#协议三要素"><span class="nav-number">12.1.</span> <span class="nav-text">协议三要素</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#速率-amp-带宽"><span class="nav-number">13.</span> <span class="nav-text">速率 &amp; 带宽</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#丢包"><span class="nav-number">14.</span> <span class="nav-text">丢包</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分组延迟"><span class="nav-number">15.</span> <span class="nav-text">分组延迟</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流量强度"><span class="nav-number">16.</span> <span class="nav-text">流量强度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#时延带宽积"><span class="nav-number">17.</span> <span class="nav-text">时延带宽积</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#吞吐率-量（Throughput）"><span class="nav-number">18.</span> <span class="nav-text">吞吐率/量（Throughput）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络体系结构"><span class="nav-number">19.</span> <span class="nav-text">网络体系结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OSI参考模型的通信过程"><span class="nav-number">20.</span> <span class="nav-text">OSI参考模型的通信过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#OSI参考模型的数据封装"><span class="nav-number">20.1.</span> <span class="nav-text">OSI参考模型的数据封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PDU"><span class="nav-number">20.2.</span> <span class="nav-text">PDU</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP-IP参考模型"><span class="nav-number">21.</span> <span class="nav-text">TCP/IP参考模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#五层参考模型"><span class="nav-number">22.</span> <span class="nav-text">五层参考模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#五层传输模型的数据封装"><span class="nav-number">22.1.</span> <span class="nav-text">五层传输模型的数据封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三种模型对应"><span class="nav-number">22.2.</span> <span class="nav-text">三种模型对应</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#物理层实现的功能概述"><span class="nav-number">22.3.</span> <span class="nav-text">物理层实现的功能概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据链路层功能概述"><span class="nav-number">22.4.</span> <span class="nav-text">数据链路层功能概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#网络层功能概述"><span class="nav-number">22.5.</span> <span class="nav-text">网络层功能概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#传输层功能"><span class="nav-number">22.6.</span> <span class="nav-text">传输层功能</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#应用层"><span class="nav-number">22.7.</span> <span class="nav-text">应用层</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#码元"><span class="nav-number">23.</span> <span class="nav-text">码元</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#官方解释"><span class="nav-number">23.1.</span> <span class="nav-text">官方解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理解"><span class="nav-number">23.2.</span> <span class="nav-text">理解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编码级别"><span class="nav-number">23.3.</span> <span class="nav-text">编码级别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#奈斯准则"><span class="nav-number">24.</span> <span class="nav-text">奈斯准则</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#码间串扰"><span class="nav-number">24.1.</span> <span class="nav-text">码间串扰</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#奈斯准则内容"><span class="nav-number">24.2.</span> <span class="nav-text">奈斯准则内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#波特率"><span class="nav-number">24.3.</span> <span class="nav-text">波特率</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#比特率"><span class="nav-number">24.4.</span> <span class="nav-text">比特率</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#香农公式"><span class="nav-number">25.</span> <span class="nav-text">香农公式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#编码级数限制"><span class="nav-number">25.1.</span> <span class="nav-text">编码级数限制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#香农公式内容"><span class="nav-number">25.2.</span> <span class="nav-text">香农公式内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举例"><span class="nav-number">25.3.</span> <span class="nav-text">举例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#奈氏准则vs香农公式"><span class="nav-number">26.</span> <span class="nav-text">奈氏准则vs香农公式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多路复用"><span class="nav-number">27.</span> <span class="nav-text">多路复用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#频分多路复用"><span class="nav-number">27.1.</span> <span class="nav-text">频分多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时分多路复用"><span class="nav-number">27.2.</span> <span class="nav-text">时分多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#波分多路复用"><span class="nav-number">27.3.</span> <span class="nav-text">波分多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#码分多路复用"><span class="nav-number">27.4.</span> <span class="nav-text">码分多路复用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数字信号在模拟信道传输"><span class="nav-number">27.5.</span> <span class="nav-text">数字信号在模拟信道传输</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#相邻"><span class="nav-number">28.</span> <span class="nav-text">相邻</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链路层解决的问题"><span class="nav-number">29.</span> <span class="nav-text">链路层解决的问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环冗余码"><span class="nav-number">30.</span> <span class="nav-text">循环冗余码</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#CRC-计算方法"><span class="nav-number">30.1.</span> <span class="nav-text">CRC 计算方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#停止等待协议（Stop-and-Wait-protocol）"><span class="nav-number">31.</span> <span class="nav-text">停止等待协议（Stop-and-Wait protocol）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#确认号"><span class="nav-number">31.1.</span> <span class="nav-text">确认号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#差错"><span class="nav-number">31.2.</span> <span class="nav-text">差错</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重传定时器"><span class="nav-number">31.3.</span> <span class="nav-text">重传定时器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#丢失"><span class="nav-number">31.4.</span> <span class="nav-text">丢失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#帧编号"><span class="nav-number">31.5.</span> <span class="nav-text">帧编号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信道利用率"><span class="nav-number">31.6.</span> <span class="nav-text">信道利用率</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GBN-协议"><span class="nav-number">32.</span> <span class="nav-text">GBN 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#确认号-1"><span class="nav-number">32.1.</span> <span class="nav-text">确认号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送窗口"><span class="nav-number">32.2.</span> <span class="nav-text">发送窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接收窗口"><span class="nav-number">32.3.</span> <span class="nav-text">接收窗口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#重传定时器-1"><span class="nav-number">32.4.</span> <span class="nav-text">重传定时器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发送方"><span class="nav-number">32.4.1.</span> <span class="nav-text">发送方</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收方"><span class="nav-number">32.4.2.</span> <span class="nav-text">接收方</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送窗口的最大值"><span class="nav-number">32.5.</span> <span class="nav-text">发送窗口的最大值</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CSMA-CD"><span class="nav-number">33.</span> <span class="nav-text">CSMA/CD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#先听后发"><span class="nav-number">33.1.</span> <span class="nav-text">先听后发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#边发边听"><span class="nav-number">33.2.</span> <span class="nav-text">边发边听</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#冲突重发"><span class="nav-number">33.3.</span> <span class="nav-text">冲突重发</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10BASE-T-以太网"><span class="nav-number">34.</span> <span class="nav-text">10BASE-T 以太网</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网卡"><span class="nav-number">35.</span> <span class="nav-text">网卡</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#网卡工作要点"><span class="nav-number">35.1.</span> <span class="nav-text">网卡工作要点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网桥与交换机"><span class="nav-number">36.</span> <span class="nav-text">网桥与交换机</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#网桥"><span class="nav-number">36.1.</span> <span class="nav-text">网桥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#交换机-1"><span class="nav-number">36.2.</span> <span class="nav-text">交换机</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MAC-表抖动与广播风暴"><span class="nav-number">36.3.</span> <span class="nav-text">MAC 表抖动与广播风暴</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#无线局域网与-CSMA-CA"><span class="nav-number">37.</span> <span class="nav-text">无线局域网与 CSMA/CA</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#无线局域网没有碰撞检测"><span class="nav-number">37.1.</span> <span class="nav-text">无线局域网没有碰撞检测</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#CSMA-CA-协议"><span class="nav-number">37.2.</span> <span class="nav-text">CSMA/CA 协议</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#帧间间隔-IFS"><span class="nav-number">37.2.1.</span> <span class="nav-text">帧间间隔 IFS</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#争用窗口（二进制指数退避）"><span class="nav-number">37.3.</span> <span class="nav-text">争用窗口（二进制指数退避）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信道预约"><span class="nav-number">37.4.</span> <span class="nav-text">信道预约</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有线与无线的对比"><span class="nav-number">37.5.</span> <span class="nav-text">有线与无线的对比</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#802-11-局域网的-MAC-帧"><span class="nav-number">37.6.</span> <span class="nav-text">802.11 局域网的 MAC 帧</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ARP"><span class="nav-number">38.</span> <span class="nav-text">ARP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RARP"><span class="nav-number">39.</span> <span class="nav-text">RARP</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网络通信分类"><span class="nav-number">40.</span> <span class="nav-text">网络通信分类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传统的IP地址划分"><span class="nav-number">41.</span> <span class="nav-text">传统的IP地址划分</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#各类地址特性"><span class="nav-number">41.1.</span> <span class="nav-text">各类地址特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#A类地址"><span class="nav-number">41.1.1.</span> <span class="nav-text">A类地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#B类地址"><span class="nav-number">41.1.2.</span> <span class="nav-text">B类地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#C类地址"><span class="nav-number">41.1.3.</span> <span class="nav-text">C类地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#D类地址"><span class="nav-number">41.1.4.</span> <span class="nav-text">D类地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#E类地址"><span class="nav-number">41.1.5.</span> <span class="nav-text">E类地址</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#划分子网"><span class="nav-number">42.</span> <span class="nav-text">划分子网</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CIDR"><span class="nav-number">43.</span> <span class="nav-text">CIDR</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#路由聚合"><span class="nav-number">43.1.</span> <span class="nav-text">路由聚合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最长前缀匹配"><span class="nav-number">43.2.</span> <span class="nav-text">最长前缀匹配</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#网关"><span class="nav-number">44.</span> <span class="nav-text">网关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数据转发"><span class="nav-number">45.</span> <span class="nav-text">数据转发</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ARP深入"><span class="nav-number">45.1.</span> <span class="nav-text">ARP深入</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IP数据报的格式"><span class="nav-number">46.</span> <span class="nav-text">IP数据报的格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NAT"><span class="nav-number">47.</span> <span class="nav-text">NAT</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#私有地址"><span class="nav-number">47.1.</span> <span class="nav-text">私有地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自治系统"><span class="nav-number">48.</span> <span class="nav-text">自治系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内部网关协议"><span class="nav-number">48.1.</span> <span class="nav-text">内部网关协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#外部网关协议"><span class="nav-number">48.2.</span> <span class="nav-text">外部网关协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#路由选择算法分类"><span class="nav-number">48.3.</span> <span class="nav-text">路由选择算法分类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RIP协议"><span class="nav-number">49.</span> <span class="nav-text">RIP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特点"><span class="nav-number">49.1.</span> <span class="nav-text">特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#距离向量算法"><span class="nav-number">49.2.</span> <span class="nav-text">距离向量算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举例-1"><span class="nav-number">49.3.</span> <span class="nav-text">举例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RIP-协议的优缺点"><span class="nav-number">49.4.</span> <span class="nav-text">RIP 协议的优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#好消息传播得快，坏消息传播得慢"><span class="nav-number">49.5.</span> <span class="nav-text">好消息传播得快，坏消息传播得慢</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RIP协议的位置"><span class="nav-number">49.6.</span> <span class="nav-text">RIP协议的位置</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RIP2-协议的报文格式"><span class="nav-number">49.7.</span> <span class="nav-text">RIP2 协议的报文格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OSPF协议"><span class="nav-number">50.</span> <span class="nav-text">OSPF协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RIP-协议的问题"><span class="nav-number">50.1.</span> <span class="nav-text">RIP 协议的问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#要点"><span class="nav-number">50.2.</span> <span class="nav-text">要点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#链路状态数据库"><span class="nav-number">50.3.</span> <span class="nav-text">链路状态数据库</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dijkstra-算法"><span class="nav-number">50.4.</span> <span class="nav-text">Dijkstra 算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OSPF-的区域-area"><span class="nav-number">50.5.</span> <span class="nav-text">OSPF 的区域(area)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OSPF-载体"><span class="nav-number">50.6.</span> <span class="nav-text">OSPF 载体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#OSPF-的五种分组类型"><span class="nav-number">50.7.</span> <span class="nav-text">OSPF 的五种分组类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#BGP协议"><span class="nav-number">51.</span> <span class="nav-text">BGP协议</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#BGP报文"><span class="nav-number">51.1.</span> <span class="nav-text">BGP报文</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ICMP"><span class="nav-number">52.</span> <span class="nav-text">ICMP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#格式"><span class="nav-number">52.1.</span> <span class="nav-text">格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#差错报告报文"><span class="nav-number">52.2.</span> <span class="nav-text">差错报告报文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#询问报文"><span class="nav-number">52.3.</span> <span class="nav-text">询问报文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PING"><span class="nav-number">52.4.</span> <span class="nav-text">PING</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传输服务"><span class="nav-number">53.</span> <span class="nav-text">传输服务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#端口"><span class="nav-number">54.</span> <span class="nav-text">端口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#端口范围划分"><span class="nav-number">54.1.</span> <span class="nav-text">端口范围划分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#复用与分用"><span class="nav-number">54.2.</span> <span class="nav-text">复用与分用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UDP"><span class="nav-number">55.</span> <span class="nav-text">UDP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#校验和"><span class="nav-number">55.1.</span> <span class="nav-text">校验和</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#计算-UDP-检验和的例子"><span class="nav-number">55.1.1.</span> <span class="nav-text">计算 UDP 检验和的例子</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TCP"><span class="nav-number">56.</span> <span class="nav-text">TCP</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP格式"><span class="nav-number">56.1.</span> <span class="nav-text">TCP格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#差错控制"><span class="nav-number">56.2.</span> <span class="nav-text">差错控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#检验和"><span class="nav-number">56.2.1.</span> <span class="nav-text">检验和</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#确认和超时"><span class="nav-number">56.2.2.</span> <span class="nav-text">确认和超时</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#重传定时器-2"><span class="nav-number">56.2.3.</span> <span class="nav-text">重传定时器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流量控制"><span class="nav-number">56.3.</span> <span class="nav-text">流量控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#发送窗口-1"><span class="nav-number">56.3.1.</span> <span class="nav-text">发送窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接收窗口-1"><span class="nav-number">56.3.2.</span> <span class="nav-text">接收窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#窗口如何滑动"><span class="nav-number">56.3.3.</span> <span class="nav-text">窗口如何滑动</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#糊涂窗口综合症"><span class="nav-number">56.4.</span> <span class="nav-text">糊涂窗口综合症</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#由发送方产生的糊涂窗口综合症（Syndrome-Created-by-the-Sender）"><span class="nav-number">56.4.1.</span> <span class="nav-text">由发送方产生的糊涂窗口综合症（Syndrome Created by the Sender）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Nagle-算法"><span class="nav-number">56.4.1.1.</span> <span class="nav-text">Nagle 算法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#由接收方产生的糊涂窗口综合症（Syndrome-Created-by-the-Receiver）"><span class="nav-number">56.4.2.</span> <span class="nav-text">由接收方产生的糊涂窗口综合症（Syndrome Created by the Receiver）</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#拥塞控制"><span class="nav-number">56.5.</span> <span class="nav-text">拥塞控制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#拥塞概述"><span class="nav-number">56.5.1.</span> <span class="nav-text">拥塞概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#传输网络"><span class="nav-number">56.5.2.</span> <span class="nav-text">传输网络</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拥塞窗口"><span class="nav-number">56.5.3.</span> <span class="nav-text">拥塞窗口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拥塞检测"><span class="nav-number">56.5.4.</span> <span class="nav-text">拥塞检测</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#超时"><span class="nav-number">56.5.4.1.</span> <span class="nav-text">超时</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#三次重复-ACK（3dupACKs）"><span class="nav-number">56.5.4.2.</span> <span class="nav-text">三次重复 ACK（3dupACKs）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#拥塞控制策略"><span class="nav-number">56.5.5.</span> <span class="nav-text">拥塞控制策略</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#慢启动（SS-Slow-start）"><span class="nav-number">56.5.5.1.</span> <span class="nav-text">慢启动（SS, Slow start）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#拥塞避免（CA，Congestion-avoidance）"><span class="nav-number">56.5.5.2.</span> <span class="nav-text">拥塞避免（CA，Congestion avoidance）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#拥塞控制策略的转换"><span class="nav-number">56.5.5.3.</span> <span class="nav-text">拥塞控制策略的转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接管理"><span class="nav-number">56.6.</span> <span class="nav-text">连接管理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#连接建立"><span class="nav-number">56.6.1.</span> <span class="nav-text">连接建立</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么要三次握手"><span class="nav-number">56.6.2.</span> <span class="nav-text">为什么要三次握手</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么TCP客户端最后还要发送一次确认呢"><span class="nav-number">56.6.2.1.</span> <span class="nav-text">为什么TCP客户端最后还要发送一次确认呢</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据传输"><span class="nav-number">56.6.3.</span> <span class="nav-text">数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#序号"><span class="nav-number">56.6.3.1.</span> <span class="nav-text">序号</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#确认号-2"><span class="nav-number">56.6.3.2.</span> <span class="nav-text">确认号</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#连接断开"><span class="nav-number">56.6.4.</span> <span class="nav-text">连接断开</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么客户端最后还要等待2MSL"><span class="nav-number">56.6.4.1.</span> <span class="nav-text">为什么客户端最后还要等待2MSL</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#为什么建立连接是三次握手，关闭连接确是四次挥手呢"><span class="nav-number">56.6.4.2.</span> <span class="nav-text">为什么建立连接是三次握手，关闭连接确是四次挥手呢</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#如果已经建立了连接，但是客户端突然出现故障了怎么办"><span class="nav-number">56.6.4.3.</span> <span class="nav-text">如果已经建立了连接，但是客户端突然出现故障了怎么办</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TCP-连接管理的三规则"><span class="nav-number">56.6.5.</span> <span class="nav-text">TCP 连接管理的三规则</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打开网页的过程"><span class="nav-number">57.</span> <span class="nav-text">打开网页的过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Socket"><span class="nav-number">58.</span> <span class="nav-text">Socket</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#InetAddress"><span class="nav-number">58.1.</span> <span class="nav-text">InetAddress</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获得本机IP地址"><span class="nav-number">58.1.1.</span> <span class="nav-text">获得本机IP地址</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP-1"><span class="nav-number">58.2.</span> <span class="nav-text">UDP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP-1"><span class="nav-number">58.3.</span> <span class="nav-text">TCP</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#文件传输案例"><span class="nav-number">58.4.</span> <span class="nav-text">文件传输案例</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Socket属性"><span class="nav-number">58.5.</span> <span class="nav-text">Socket属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Channel"><span class="nav-number">59.</span> <span class="nav-text">Channel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Channel的实现"><span class="nav-number">59.1.</span> <span class="nav-text">Channel的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer"><span class="nav-number">60.</span> <span class="nav-text">Buffer</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer的实现"><span class="nav-number">60.1.</span> <span class="nav-text">Buffer的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer详解"><span class="nav-number">61.</span> <span class="nav-text">Buffer详解</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Buffer的分配"><span class="nav-number">61.1.</span> <span class="nav-text">Buffer的分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向Buffer中写数据"><span class="nav-number">61.2.</span> <span class="nav-text">向Buffer中写数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向Channel中写数据"><span class="nav-number">61.3.</span> <span class="nav-text">向Channel中写数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#测试limit"><span class="nav-number">61.4.</span> <span class="nav-text">测试limit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#rewind-方法"><span class="nav-number">61.5.</span> <span class="nav-text">rewind()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#clear-与compact-方法"><span class="nav-number">61.6.</span> <span class="nav-text">clear()与compact()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mark-与reset-方法"><span class="nav-number">61.7.</span> <span class="nav-text">mark()与reset()方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#equals-与compareTo-方法"><span class="nav-number">61.8.</span> <span class="nav-text">equals()与compareTo()方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#equals"><span class="nav-number">61.8.1.</span> <span class="nav-text">equals()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#compareTo-方法"><span class="nav-number">61.8.2.</span> <span class="nav-text">compareTo()方法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Scatter-Gather"><span class="nav-number">62.</span> <span class="nav-text">Scatter/Gather</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通道之间的数据传输"><span class="nav-number">63.</span> <span class="nav-text">通道之间的数据传输</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#transferFrom"><span class="nav-number">63.1.</span> <span class="nav-text">transferFrom()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#transferTo"><span class="nav-number">63.2.</span> <span class="nav-text">transferTo()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">64.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Selector"><span class="nav-number">65.</span> <span class="nav-text">Selector</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Selector的创建"><span class="nav-number">65.1.</span> <span class="nav-text">Selector的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#向Selector注册通道"><span class="nav-number">65.2.</span> <span class="nav-text">向Selector注册通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SelectionKey"><span class="nav-number">65.3.</span> <span class="nav-text">SelectionKey</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#interest集合"><span class="nav-number">65.3.1.</span> <span class="nav-text">interest集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ready集合"><span class="nav-number">65.3.2.</span> <span class="nav-text">ready集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Channel-Selector"><span class="nav-number">65.3.3.</span> <span class="nav-text">Channel + Selector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#附加的对象"><span class="nav-number">65.3.4.</span> <span class="nav-text">附加的对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#通过Selector选择通道"><span class="nav-number">65.4.</span> <span class="nav-text">通过Selector选择通道</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#selectedKeys"><span class="nav-number">65.4.1.</span> <span class="nav-text">selectedKeys()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SocketChannel"><span class="nav-number">66.</span> <span class="nav-text">SocketChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#打开-SocketChannel"><span class="nav-number">66.1.</span> <span class="nav-text">打开 SocketChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭-SocketChannel"><span class="nav-number">66.2.</span> <span class="nav-text">关闭 SocketChannel</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ServerSocketChannel"><span class="nav-number">67.</span> <span class="nav-text">ServerSocketChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#打开-ServerSocketChannel"><span class="nav-number">67.1.</span> <span class="nav-text">打开 ServerSocketChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭-ServerSocketChannel"><span class="nav-number">67.2.</span> <span class="nav-text">关闭 ServerSocketChannel</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#监听新进来的连接"><span class="nav-number">67.3.</span> <span class="nav-text">监听新进来的连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#非阻塞模式"><span class="nav-number">67.4.</span> <span class="nav-text">非阻塞模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#服务器使用NIO向客户端Echo数据的例子"><span class="nav-number">68.</span> <span class="nav-text">服务器使用NIO向客户端Echo数据的例子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Selector维护的集合"><span class="nav-number">69.</span> <span class="nav-text">Selector维护的集合</span></a></li></ol></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">ISJINHAO</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">1.2m</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">17:59</span></div><div class="powered-by"><i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv"> 本站访客数：<span id="busuanzi_value_site_uv"></span></span></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">| 博客全站共475.4k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/src/utils.js?v=6.7.0"></script><script src="/js/src/motion.js?v=6.7.0"></script><script src="/js/src/schemes/muse.js?v=6.7.0"></script><script src="/js/src/scrollspy.js?v=6.7.0"></script><script src="/js/src/post-details.js?v=6.7.0"></script><script src="/js/src/bootstrap.js?v=6.7.0"></script><script>window.livereOptions={refer:"2019/03-IO流和网络/"},function(e,t){var n,r=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,r.parentNode.insertBefore(n,r))}(document,"script")</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: "AMS"
      }
    }
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });</script><script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><style>.MathJax_Display{overflow:auto hidden}</style></body></html><!-- rebuild by neat -->