<!-- build time:Tue Aug 06 2019 14:34:00 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>.pace .pace-progress{background:#1E92FB;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1E92FB,0 0 5px #1E92FB}.pace .pace-activity{border-top-color:#1E92FB;border-left-color:#1E92FB}</style><meta name="theme-color" content="#222"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=6.7.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon16x16.ico?v=6.7.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32x32.ico?v=6.7.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16x16.ico?v=6.7.0"><link rel="mask-icon" href="/images/favicon16x16.ico?v=6.7.0" color="#222"><link rel="manifest" href="/images/favicon16x16.ico"><meta name="msapplication-config" content="/images/favicon16x16.ico"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"6.7.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"28dbf854"}),daovoice("update")</script><meta name="description" content="JVM&amp;amp;JDK&amp;amp;JREJVMJava虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。什么是字节码?采用字节码的好处是什么?在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java"><meta name="keywords" content="应届求职复习,面试"><meta property="og:type" content="article"><meta property="og:title" content="01-Java基础"><meta property="og:url" content="https://isjinhao.github.io/2019/01-Java基础/index.html"><meta property="og:site_name" content="ISJINHAO"><meta property="og:description" content="JVM&amp;amp;JDK&amp;amp;JREJVMJava虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。什么是字节码?采用字节码的好处是什么?在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/Java%20程序运行过程.png"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/受查非受查异常.png"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/2019-07-11_165800.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/例2.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/2019-07-12_181943.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/2.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/3.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/4.png"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/5.png"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/6.png"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/7.png"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/8.png"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/9.png"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/后继图示.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/删除图示.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/10.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/11.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/12.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/13.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/14.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/15.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/16.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/17.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/序列化.png"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/2019-07-13_160318.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/01-Java基础/2019-07-13_160809.jpg"><meta property="og:updated_time" content="2019-08-06T06:31:07.702Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="01-Java基础"><meta name="twitter:description" content="JVM&amp;amp;JDK&amp;amp;JREJVMJava虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。什么是字节码?采用字节码的好处是什么?在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java"><meta name="twitter:image" content="https://isjinhao.github.io/2019/01-Java基础/Java%20程序运行过程.png"><link rel="alternate" href="/atom.xml" title="ISJINHAO" type="application/atom+xml"><link rel="canonical" href="https://isjinhao.github.io/2019/01-Java基础/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>01-Java基础 | ISJINHAO</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">ISJINHAO</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://isjinhao.github.io/2019/01-Java基础/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ISJINHAO"><meta itemprop="description" content="Living & Working"><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ISJINHAO"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">01-Java基础</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-28 16:38:28" itemprop="dateCreated datePublished" datetime="2019-07-28T16:38:28+08:00">2019-07-28</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-08-06 14:31:07" itemprop="dateModified" datetime="2019-08-06T14:31:07+08:00">2019-08-06</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/应届求职复习/" itemprop="url" rel="index"><span itemprop="name">应届求职复习</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">79k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">1:12</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="JVM-amp-JDK-amp-JRE"><a href="#JVM-amp-JDK-amp-JRE" class="headerlink" title="JVM&amp;JDK&amp;JRE"></a>JVM&amp;JDK&amp;JRE</h2><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><p><strong>什么是字节码?采用字节码的好处是什么?</strong></p><blockquote><p>在 Java 中，JVM可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote><p><strong>Java 程序从源代码到运行一般有下面3步：</strong></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/01-Java基础/Java 程序运行过程.png"></div><br>我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了 JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。<br><br>&gt; HotSpot采用了惰性评估（Lazy Evaluation）的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9引入了一种新的编译模式AOT（Ahead of Time Compilation），它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。<br><br><strong>总结：</strong><br><br>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。<br><br><br><br>### JDK 和 JRE<br><br>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。<br><br>JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。<br><br>如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装JDK了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。<br><br><br><br>## Java和C++的区别<br><br>- 都是面向对象的语言，都支持封装、继承和多态<br>- Java 不提供指针来直接访问内存，程序内存更加安全<br>- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。<br>- Java 有自动内存管理机制，不需要程序员手动释放无用内存<br><br><br><br>## 异常<br><br>异常是程序在运行时出现的会导致程序运行终止的错误。这种错误是不能通过编译系统检查出来的。常见的异常的发生原因为系统资源错误和用户操所错误两种。<br><br>Java把异常信息封装成一个类。当发生某种异常时将某种对应的类作为异常信息抛出。异常的根类时Throwable，其有两个直接子类 Error和Exception。Error是描述系统资源错误的类。Exception是描述用户操作错误的类。<br><br>发生了Error就是必须修改代码或调整外部环境问题，程序肯定会终止。比如需要开辟一个内存大小为99999999个int的数组。一般来说Error很少发生。发生了Exception就要进行处理，使程序运行下去，如数组越界异常。而Exception又可以分为两种，一种是程序本身存在的问题引发的异常（健壮性不够），即：RuntimeException；一种是程序本身可能没有问题，但遇到诸如文件不存在所导致的错误，Excption中除了RuntimeException外都是此种异常。而RuntimeException是不允许存在的，遇到RuntimeException就说明程序有问题，需要修改代码。<br><br><div align="center"><img width="65%" src="//isjinhao.github.io/2019/01-Java基础/受查非受查异常.png"></div><br>### 受查异常、非受查异常<br><br>Java语言规范规定派生于Error类或RuntimeException类的异常都称为非受查异常，其余异常都被成为受查异常。受查异常就是必须告诉它的调用者可能会出现异常，让其调用者抛出或者捕获处理，这类异常如果没有在程序中进行异常处理，编译不通过。非受查异常则不需要。<br><br><br><br>### 声明受查异常（throws）<br><br>除了Error和RuntimeException的异常都是受查异常，这些异常如：IOException、SQLException等，在可能发生的方法中需要被声明。同时非受查异常最好不要被声明。需要使用throws声明异常后的情况如下：<br><br>- 调用一个抛出受查异常的方法：<code>public int read() throws IOException</code><br>- 方法中使用throw语句抛出了受查异常。<br><br><br><br>### 抛出异常（throw）<br><br>throw可以用于抛出异常对象，一般是受查异常对象。格式如下例：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">demo</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;    </span><br><span class="line">	<span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"出现异常"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### return和finally的决斗<br><br>一旦进入<code>try … catch …</code>的异常捕获结构，无论try和catch的语句块有没有return语句，finally一定会被执行，但是如果finally中还有return语句，return之后的不会被执行。同时后来的return值会覆盖之前的return值。但若未进入异常捕获结构则return后不允许有语句，因为即使有也一定不会被执行。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewReview</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(test());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> Integer <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"111"</span>);</span><br><span class="line">			<span class="keyword">int</span> i = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">			System.out.println(<span class="string">"222"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//			System.out.println("333");		// 报错</span></span><br><span class="line">		&#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			System.out.println(<span class="string">"---"</span>);</span><br><span class="line">			<span class="keyword">int</span> j = <span class="number">1</span> / <span class="number">0</span>;</span><br><span class="line">			System.out.println(<span class="string">"```"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">//			System.out.println("...");		// 报错</span></span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"aaa"</span>);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line"><span class="comment">//			System.out.println("bbb");		// 报错</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;	</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	111</span></span><br><span class="line"><span class="comment">    ---</span></span><br><span class="line"><span class="comment">    aaa</span></span><br><span class="line"><span class="comment">    100</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><br>## final<br><br>### 修饰类<br><br>当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。<br><br><br><br>### 修饰方法<br><br>只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。即父类的final方法是不能被子类所覆盖的。<br><br>重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义方法签名相同的方法，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。（注：类的private方法会隐式地被指定为final方法。）<br><br><br><br>### 修饰变量<br><br>final成员变量表示常量，只能被赋值一次，赋值后值不再改变。<br><br>- 当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；<br>- 如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。<br><br>final修饰一个成员变量，必须要显示初始化。这里有两种初始化方式，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。<br><br><br><br>### finalize<br><br>Object 类的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。该方法更像是一个对象生命周期的临终方法，当该方法被系统调用则代表该对象即将“死亡”，但是需要注意的是，我们主动行为上去调用该方法并不会导致该对象“死亡”，这是一个被动的方法（其实就是回调方法），不需要我们调用。<br><br><br><br>## static<br><br>### 修饰方法<br><br>- 在静态方法中不能访问类的非静态成员变量和非静态成员方法。<br><br>- 在非静态成员方法中是可以访问静态成员方法/变量的。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterviewReview</span> <span class="keyword">extends</span> <span class="title">Dad</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		test();</span><br><span class="line">	&#125;</span><br><span class="line">		</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;	<span class="comment">// static方法可以被重新定义</span></span><br><span class="line">		System.out.println(<span class="string">"son"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;	</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dad</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"dad"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 面试题<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> <span class="keyword">extends</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Base</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"base constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	父类先于子类、静态先于普通</span></span><br><span class="line"><span class="comment">	base static</span></span><br><span class="line"><span class="comment">    test static</span></span><br><span class="line"><span class="comment">    base constructor</span></span><br><span class="line"><span class="comment">    test constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Test"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person "</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"MyClass"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	test static</span></span><br><span class="line"><span class="comment">    myclass static</span></span><br><span class="line"><span class="comment">    person static</span></span><br><span class="line"><span class="comment">    person Test</span></span><br><span class="line"><span class="comment">    test constructor</span></span><br><span class="line"><span class="comment">    person MyClass</span></span><br><span class="line"><span class="comment">    myclass constructor</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><br>首先加载Test类，因此会执行Test类中的static块。接着执行new MyClass()，而MyClass类还没有被加载，因此需要加载MyClass类。在加载MyClass类的时候，发现MyClass类继承自Test类，但是由于Test类已经被加载了，所以只需要加载MyClass类，那么就会执行MyClass类的中的static块。在加载完之后，就通过构造器来生成对象。<strong>而在生成对象的时候，必须先初始化父类的成员变量</strong>，因此会执行Test中的Person person = new Person()，而Person类还没有被加载过，因此会先加载Person类并执行Person类中的static块，接着执行父类的构造器，完成了父类的初始化，然后就来初始化自身了，因此会接着执行MyClass中的Person person = new Person()，最后执行MyClass的构造器。<br><br><br><br>## 重载和重写<br><br>### 重写<br><br>- 参数列表必须完全与被重写方法的相同；<br>- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类<br>- 访问权限不能比父类中被重写的方法的访问权限更低。<br>- 父类的成员方法只能被它的子类重写。<br>- 声明为final的方法不能被重写。<br>- 声明为static的方法<strong>不能被重写</strong>，但是能够被再次声明。<br>- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。<br>- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。<br>- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常。<br>- 构造方法不能被重写。<br>- 如果不能继承一个方法，则不能重写这个方法。<br><br><br><br>### 重载<br><br>- 被重载的方法必须改变参数列表（参数个数或类型不一样）；<br>- 被重载的方法可以改变返回类型；<br>- 被重载的方法可以改变访问修饰符；<br>- 被重载的方法可以声明新的或更广的检查异常；<br>- 方法能够在同一个类中或者在一个子类中被重载。<br>- 无法以返回值类型作为重载函数的区分标准。<br><br><br><br>### 区别<br><br>| 区别点 | 重载方法 | 重写方法 |<br>| :——: | :——: | :——————————————–: |<br>| 参数列表 | 必须修改 | 一定不能修改 |<br>| 返回类型 | 可以修改 | 一定不能修改 |<br>| 异常 | 可以修改 | 可以减少或删除，一定不能抛出新的或者更广的异常 |<br>| 访问 | 可以修改 | 一定不能做更严格的限制（可以降低限制） |<br><br><br><br>## 抽象类<br><br>- 抽象类中可以定义构造器<br>- 可以有抽象方法和具体方法<br>- 抽象类中可以定义成员变量<br>- 有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法<br>- 抽象一个类只能继承一个抽象类<br>- 抽象类可以包含静态方法<br><br>抽象方法不可同时是静态的、不能同时是本地的、也不能同时被synchronized修饰。<br><br>- 抽象方法需要子类重写，而静态的方法是无法被重写的，因此二者是矛盾的。<br>- 本地方法是由本地代码（如 C 代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。<br>- synchronized 和方法的实现细节有关，抽象方法不涉及实现细节，因此也是相互矛盾的。<br><br><br><br>## 接口<br><br>- 接口中不能定义构造器<br>- 方法全部都是抽象方法<br>- 抽象类中的成员可以是 private、默认、protected、public<br>- 接口中定义的成员变量实际上都是常量<br>- 接口中不能有静态方法<br>- 一个类可以实现多个接口<br><br><br><br>### 接口和抽象类的区别是什么<br><br>1. 接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。<br>2. 接口中除了static、final变量，不能有其他变量，而抽象类中则不一定。<br>3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。<br>4. 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。<br>5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。<br><br>备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。<br><br><br><br>## 基本类型和包装类型<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testInter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	Integer a = <span class="keyword">new</span> Integer(<span class="number">200</span>);</span><br><span class="line">	Integer b = <span class="keyword">new</span> Integer(<span class="number">200</span>);</span><br><span class="line">	Integer c = <span class="number">200</span>;</span><br><span class="line">	Integer e = <span class="number">200</span>;</span><br><span class="line">	<span class="keyword">int</span> d = <span class="number">200</span>;</span><br><span class="line">	Object o = <span class="number">200</span>;</span><br><span class="line">	System.out.println(<span class="string">"基本类型和数字常量    ==判断"</span> + (o == c));</span><br><span class="line">	System.out.println(<span class="string">"基本类型和数字常量    equal判断"</span> + c.equals(o));</span><br><span class="line">	System.out.println(<span class="string">"两个new出来的对象    ==判断"</span> + (a == b));</span><br><span class="line">	System.out.println(<span class="string">"两个new出来的对象    equal判断"</span> + a.equals(b));</span><br><span class="line">	System.out.println(<span class="string">"new出的对象和用int赋值的Integer   ==判断"</span> + (a == c));</span><br><span class="line">	System.out.println(<span class="string">"new出的对象和用int赋值的Integer   equal判断"</span> + (a.equals(c)));</span><br><span class="line">	System.out.println(<span class="string">"两个用int赋值的Integer    ==判断"</span> + (c == e));</span><br><span class="line">	System.out.println(<span class="string">"两个用int赋值的Integer    equal判断"</span> + (c.equals(e)));</span><br><span class="line">	System.out.println(<span class="string">"基本类型和new出的对象   ==判断"</span> + (d == a));</span><br><span class="line">	System.out.println(<span class="string">"基本类型和new出的对象   equal判断"</span> + (a.equals(d)));</span><br><span class="line">	System.out.println(<span class="string">"基本类型和自动装箱的对象   ==判断"</span> + (d == c));</span><br><span class="line">	System.out.println(<span class="string">"基本类型和自动装箱的对象   equal判断"</span> + (c.equals(d)));</span><br><span class="line">	</span><br><span class="line">	Integer f = <span class="number">100</span>;</span><br><span class="line">	Integer g = <span class="number">100</span>;</span><br><span class="line">	<span class="comment">// 如果在-128到127之间相等的话，它们会共用一块内存</span></span><br><span class="line">	System.out.println(f == g);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>自动装箱发生的过程是：基本类型转换为包装类型。自动拆箱发生的过程是：包装类型转换为基本类型。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">40</span>;</span><br><span class="line">Integer i2 = <span class="number">40</span>;</span><br><span class="line">Integer i3 = <span class="number">0</span>;</span><br><span class="line">Integer i4 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i5 = <span class="keyword">new</span> Integer(<span class="number">40</span>);</span><br><span class="line">Integer i6 = <span class="keyword">new</span> Integer(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"i1=i2   "</span> + (i1 == i2));</span><br><span class="line">System.out.println(<span class="string">"i1=i2+i3   "</span> + (i1 == i2 + i3));</span><br><span class="line">System.out.println(<span class="string">"i1=i4   "</span> + (i1 == i4));</span><br><span class="line">System.out.println(<span class="string">"i4=i5   "</span> + (i4 == i5));</span><br><span class="line">System.out.println(<span class="string">"i4=i5+i6   "</span> + (i4 == i5 + i6));   </span><br><span class="line">System.out.println(<span class="string">"40=i5+i6   "</span> + (<span class="number">40</span> == i5 + i6));  </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	i1=i2   true</span></span><br><span class="line"><span class="comment">    i1=i2+i3   true</span></span><br><span class="line"><span class="comment">    i1=i4   false</span></span><br><span class="line"><span class="comment">    i4=i5   false</span></span><br><span class="line"><span class="comment">    语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数</span></span><br><span class="line"><span class="comment">    值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终</span></span><br><span class="line"><span class="comment">    这条语句转为40 == 40进行数值比较。</span></span><br><span class="line"><span class="comment">    i4=i5+i6   true</span></span><br><span class="line"><span class="comment">    40=i5+i6   true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><br>Java 基本类型的包装类中：Byte，Short，Integer，Long，Character，Boolean实现了常量池技术；Float，Double 并没有实现常量池技术。<br><br>Character缓存了[0,127]之间的数据，Boolean缓存了true和false，其他4种包装类默认创建了数值[-128,127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。<br><br><br><br>### int的范围<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 补码会进行循环</span></span><br><span class="line">System.out.println(Integer.MAX_VALUE);		<span class="comment">// 2147483647</span></span><br><span class="line">System.out.println(Integer.MAX_VALUE + <span class="number">1</span>);	<span class="comment">// -2147483648</span></span><br><span class="line">System.out.println(Integer.MAX_VALUE + <span class="number">2</span>);	<span class="comment">// -2147483647</span></span><br><span class="line"></span><br><span class="line">System.out.println(Integer.MIN_VALUE);		<span class="comment">// -2147483648</span></span><br><span class="line">System.out.println(Integer.MIN_VALUE - <span class="number">1</span>);	<span class="comment">// 2147483647</span></span><br><span class="line">System.out.println(Integer.MIN_VALUE - <span class="number">2</span>);	<span class="comment">// 2147483646</span></span><br></pre></td></tr></table></figure><br><br>### 基本类型之间的转换<br><br>- byte、short、int、long：小范围向大范围的可以自动转，大范围向小范围需要强制转。<br>- char可以自动转换为int、long，可以强制转换为short、byte。byte、short、int、long都需要强制转换才能转为char。<br>- float自动转换为double，double强制转换为float。<br>- byte、short、int、long可以自动float和double。反之需要强制转换。<br>- <code>+=</code>和<code>-=</code>包含自动转换，即<code>short s1 = 1; s1 += 1;</code>不会报错。<br><br><br><br>## 对象克隆<br><br>### 多层浅拷贝<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		Body body = <span class="keyword">new</span> Body(<span class="keyword">new</span> Head(<span class="keyword">new</span> Face(<span class="keyword">new</span> String(<span class="string">"丑"</span>))));</span><br><span class="line">		Body body1 = (Body) body.clone();</span><br><span class="line">		System.out.println(<span class="string">"body == body1 : "</span> + (body == body1));</span><br><span class="line">		System.out.println(<span class="string">"body.head == body1.head : "</span> + (body.head == body1.head));</span><br><span class="line">		System.out.println(body.head.face == body1.head.face);</span><br><span class="line">		System.out.println(body.head.face.name == body1.head.face.name);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Body</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Head head;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Body</span><span class="params">(Head head)</span> </span>&#123; <span class="keyword">this</span>.head = head; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		Body newBody = (Body) <span class="keyword">super</span>.clone();</span><br><span class="line">		newBody.head = (Head) head.clone();</span><br><span class="line">		<span class="keyword">return</span> newBody;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Head</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> Face face;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Head</span><span class="params">(Face face)</span> </span>&#123; <span class="keyword">this</span>.face = face; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		Head newHead = (Head)<span class="keyword">super</span>.clone();</span><br><span class="line">		newHead.face = (Face) face.clone();</span><br><span class="line">		<span class="keyword">return</span> newHead;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Face</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Face</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">	<span class="keyword">public</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">		Face newFace = (Face)<span class="keyword">super</span>.clone();</span><br><span class="line">		newFace.name = <span class="keyword">new</span> String(<span class="keyword">this</span>.name);</span><br><span class="line">		<span class="keyword">return</span> newFace;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 序列化<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloneTest</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			Person p1 = <span class="keyword">new</span> Person(<span class="string">"Hao LUO"</span>, <span class="number">33</span>, <span class="keyword">new</span> Car(<span class="string">"Benz"</span>, <span class="number">300</span>));</span><br><span class="line">			Person p2 = CloneUtils.clone(p1); <span class="comment">// 深度克隆</span></span><br><span class="line">			p2.getCar().setBrand(<span class="string">"BYD"</span>);</span><br><span class="line">			System.out.println(p1);</span><br><span class="line">			System.out.println(p2);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloneUtils</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">CloneUtils</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Serializable&gt; <span class="function">T <span class="title">clone</span><span class="params">(T obj)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">		ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bout);</span><br><span class="line">		oos.writeObject(obj);</span><br><span class="line">		ByteArrayInputStream bin = <span class="keyword">new</span> ByteArrayInputStream(bout.toByteArray());</span><br><span class="line">		ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bin);</span><br><span class="line">		<span class="keyword">return</span> (T) ois.readObject();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">9102017020286042305L</span>;</span><br><span class="line">	<span class="keyword">private</span> String name; <span class="comment">// 姓名</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 年龄</span></span><br><span class="line">	<span class="keyword">private</span> Car car; <span class="comment">// 座驾</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age, Car car)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.car = car;</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// ... getter方法和setter方法</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", age="</span> + age + <span class="string">", car="</span> + car + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">5713945027627603702L</span>;</span><br><span class="line">	<span class="keyword">private</span> String brand; <span class="comment">// 品牌</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> maxSpeed; <span class="comment">// 最高时速</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(String brand, <span class="keyword">int</span> maxSpeed)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.brand = brand;</span><br><span class="line">		<span class="keyword">this</span>.maxSpeed = maxSpeed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// ... getter和setter方法</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Car [brand="</span> + brand + <span class="string">", maxSpeed="</span> + maxSpeed + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>## 泛型<br><br>### 泛型类<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="keyword">this</span>.key = key; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	<span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line">    	<span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span></span><br><span class="line">    	Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span></span><br><span class="line">    	Generic&lt;String&gt; genericString = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"key_vlaue"</span>);</span><br><span class="line">    	System.out.println(<span class="string">"key is "</span> + genericInteger.getKey().getClass());</span><br><span class="line">    	System.out.println(<span class="string">"key is "</span> + genericString.getKey().getClass());</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 泛型接口的实现<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; 当实现泛型接口的类，未传入泛型实参时：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; 当实现泛型接口的类，传入泛型实参时：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 泛型通配符<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="keyword">this</span>.key = key; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showKeyValue</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	Generic&lt;Integer&gt; gInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123</span>);</span><br><span class="line">    	Generic&lt;Number&gt; gNumber = <span class="keyword">new</span> Generic&lt;Number&gt;(<span class="number">456</span>);</span><br><span class="line"></span><br><span class="line">    	showKeyValue(gNumber);</span><br><span class="line"></span><br><span class="line">    	<span class="comment">// showKeyValue这个方法编译器会为我们报错：</span></span><br><span class="line">        <span class="comment">// Generic&lt;java.lang.Integer&gt; cannot be applied to Generic&lt;java.lang.Number&gt;</span></span><br><span class="line">    	</span><br><span class="line">    	<span class="comment">// showKeyValue(gInteger);</span></span><br><span class="line">        </span><br><span class="line">        showKeyValue1(gNumber);		<span class="comment">// 正常 	</span></span><br><span class="line">    	showKeyValue1(gInteger);	<span class="comment">// 正常</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><code>Generic&lt;Integer&gt;</code>不能被看作为<code>Generic&lt;Number&gt;</code>的子类。由此可以看出:同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。<br><br>类型通配符一般是使用<code>？</code>代替具体的类型实参，注意了，此处<code>？</code>是类型实参，而不是类型形参 。再直白点的意思就是，此处的<code>？</code>和Number、String、Integer一样都是一种实际的类型，可以把<code>？</code>看成所有类型的父类。是一种真实的类型。可以解决当具体类型不确定的时候，这个通配符就是 ? ；当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。<br><br><br><br>### 泛型方法<br><br>泛型类，是在实例化类的时候指明泛型的具体类型；<strong>泛型方法，是在调用方法的时候指明泛型的具体类型</strong> 。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span></span><br><span class="line"><span class="function">  IllegalAccessException</span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### 泛型”方法”的详细举例<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="keyword">this</span>.key = key; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">            public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">                 this.key = keu</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">        public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">            ...</span></span><br><span class="line"><span class="comment">        &#125;  </span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### 类中的泛型方法<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFruit</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"fruit"</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"apple"</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Person"</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    	<span class="comment">//方法中的T和类上声明的T一致</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">        <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">        <span class="comment">//编译器会报警告：The type parameter T is hiding the type T</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> GenericFruit().new Apple();</span><br><span class="line">        Person person = <span class="keyword">new</span> GenericFruit().new Person();</span><br><span class="line"></span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = <span class="keyword">new</span> GenericFruit().new GenerateTest&lt;Fruit&gt;();</span><br><span class="line">        <span class="comment">//apple是Fruit的子类，所以这里可以</span></span><br><span class="line">        generateTest.show_1(apple);</span><br><span class="line">        <span class="comment">//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span></span><br><span class="line">        <span class="comment">//generateTest.show_1(person);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法都可以成功</span></span><br><span class="line">        generateTest.show_2(apple);</span><br><span class="line">        generateTest.show_2(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法也都可以成功</span></span><br><span class="line">        generateTest.show_3(apple);</span><br><span class="line">        generateTest.show_3(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 静态方法与泛型<br><br>类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong>即：<strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法</strong> 。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ublic <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          "StaticGenerator cannot be refrenced from static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 泛型上下边界<br><br>#### 上边界<br><br>为泛型添加上边界，即传入的类型实参必须是指定类型的子类型<br><br>&gt; 类<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Number</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="keyword">this</span>.key = key; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; 类的成员方法<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;? extends Number&gt; obj)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; 泛型方法<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment">//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Number&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">    T test = container.getKey();</span><br><span class="line">    <span class="keyword">return</span> test;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>##### 限制<br><br>类C中方法：<code>void setC(T t)</code>。在传入<code>&lt;? extends Fruit&gt;</code>之后：<code>void setC(&lt;? extends Fruit&gt; t)</code>。这时编译器就不知道你传过来的是什么类型，编译不会通过。但是类中的方法可以返回T，因为已经知道了它的上限是A，在调用之后用A来接收一下返回的对象就可以了。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GenerateTest&lt;? extends Fruit&gt; generateTest2 = <span class="keyword">new</span> GenericFruit().new GenerateTest&lt;&gt;();</span><br><span class="line">generateTest2.setC(apple);  <span class="comment">//报错</span></span><br></pre></td></tr></table></figure><br><br>#### 下边界<br><br><code>&lt;? super A&gt;</code>表示传入的只能是A的超类或超接口。此时，类中的方法void setC(T t)可以传入A或A的子类作为参数。但返回时只能返回Object对象。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GenerateTest&lt;? <span class="keyword">super</span> Apple&gt; generateTest2 = <span class="keyword">new</span> GenericFruit().new GenerateTest&lt;&gt;();Object object = generateTest2.get();</span><br></pre></td></tr></table></figure><br><br>### 泛型数组<br><br>sun的说明文档，在java中是<strong>”不能创建一个确切的泛型类型的数组”</strong>的。也就是说下面的这个例子是不可以的：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;String&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><br><br>而使用通配符创建泛型数组是可以的，如下面这个例子：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] ls = <span class="keyword">new</span> ArrayList&lt;?&gt;[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><br><br>这样也是可以的：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] ls = <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br></pre></td></tr></table></figure><br><br>下面使用<a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank" rel="noopener">Sun</a><a href="http://docs.oracle.com/javase/tutorial/extra/generics/fineprint.html" target="_blank" rel="noopener">的一篇文档</a>的一个例子来说明这个问题：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;[] lsa = <span class="keyword">new</span> List&lt;String&gt;[<span class="number">10</span>]; <span class="comment">// Not really allowed.    </span></span><br><span class="line">Object o = lsa;</span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Unsound, but passes run time store check    </span></span><br><span class="line">String s = lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// Run-time error: ClassCastException.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><br><br>下面采用通配符的方式是被允许的:<strong>数组的类型不可以是类型变量，除非是采用通配符的方式</strong>，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;?&gt;[] lsa = <span class="keyword">new</span> List&lt;?&gt;[<span class="number">10</span>]; <span class="comment">// OK, array of unbounded wildcard type.    </span></span><br><span class="line">Object o = lsa;    </span><br><span class="line">Object[] oa = (Object[]) o;    </span><br><span class="line">List&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();    </span><br><span class="line">li.add(<span class="keyword">new</span> Integer(<span class="number">3</span>));    </span><br><span class="line">oa[<span class="number">1</span>] = li; <span class="comment">// Correct.    </span></span><br><span class="line">Integer i = (Integer) lsa[<span class="number">1</span>].get(<span class="number">0</span>); <span class="comment">// OK</span></span><br></pre></td></tr></table></figure><br><br>## 内部类<br><br>### 成员内部类<br><br>成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123; <span class="keyword">this</span>.radius = radius; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"drawshape"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> test = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> count =<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">    	<span class="keyword">private</span> <span class="keyword">int</span> test = <span class="number">2</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">            System.out.println(count);   <span class="comment">//外部类的静态成员</span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.test);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    	Draw draw = <span class="keyword">new</span> Outer(<span class="number">20</span>).new Draw();</span><br><span class="line">    	draw.drawSahpe();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.this.成员变量</span><br><span class="line">外部类.this.成员方法</span><br></pre></td></tr></table></figure><br><br>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> radius = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Circle</span><span class="params">(<span class="keyword">double</span> radius)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.radius = radius;</span><br><span class="line">        getDrawInstance().drawSahpe();   <span class="comment">//必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Draw <span class="title">getDrawInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Draw();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Draw</span> </span>&#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drawSahpe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//第一种方式：</span></span><br><span class="line">        Outter outter = <span class="keyword">new</span> Outter();</span><br><span class="line">        Outter.Inner inner = outter.new Inner();  <span class="comment">//必须通过Outter对象来创建</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第二种方式：</span></span><br><span class="line">        Outter.Inner inner1 = outter.getInnerInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Inner inner = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Inner <span class="title">getInnerInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="keyword">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如上面的例子：<br><br>- private：则只能在外部类的内部访问；<br>- public：则任何地方都能访问；<br>- protected：只能在同一个包下或者继承外部类的情况下访问；<br>- 默认访问权限：则只能在同一个包下访问。<br><br>这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。<br><br><br><br>### 局部内部类<br><br>局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Man</span><span class="params">()</span></span>&#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> People <span class="title">getWoman</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span></span>&#123;   <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="keyword">int</span> age =<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Woman();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 匿名内部类<br><br>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段线程允许代码：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"thread run"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line">		thread.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$数字.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。<br><br><br><br>### 静态内部类<br><br>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。</span></span><br><span class="line">        Outter.Inner inner = <span class="keyword">new</span> Outter.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outter</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 局部内部类和匿名内部类只能访问局部final变量<br><br>想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span>  </span>&#123;  &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(a);</span><br><span class="line">                System.out.println(b);</span><br><span class="line">                <span class="comment">//a = 10;</span></span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>首先我们需要知道：内部类和外部类是处于同一个级别的，内部类不会因为定义在方法中就会随着方法的执行完毕就被销毁。这里就会产生问题：当外部类的方法结束时，局部变量就会被销毁了，但是内部类对象可能还存在（只有没有人再引用它时，才可能死亡）。这里就出现了一个矛盾：内部类对象访问了一个不存在的变量。为了解决这个问题，就将局部变量复制了一份作为内部类的成员变量，这样当局部变量死亡后，内部类仍可以访问它，实际访问的是局部变量的”copy”。这样就好像延长了局部变量的生命周期。<br><br>那么新问题又出现了：将局部变量复制为内部类的成员变量时，必须保证这两个变量是一样的，也就是如果我们在内部类中修改了成员变量，方法中的局部变量也得跟着改变，怎么解决问题呢？就将局部变量设置为<code>final</code>，对它初始化后，我就不让你再去修改这个变量，就保证了内部类的成员变量和方法的局部变量的一致性。这实际上也是一种妥协。<br><br><br><br>## 常见的运行时异常<br><br>- java.lang.NullPointerException ：空指针异常；<br>- 出现原因：调用了未经初始化的对象或者是不存在的对象。<br><br>- java.lang.ClassNotFoundException ：指定的类找不到；<br>- 出现原因：类的名称和路径加载错误；通常都是程序试图通过字符串来加载某个类时可能引发异常。<br><br>- java.lang.NumberFormatException ：字符串转换为数字异常；<br>- 出现原因：字符型数据中包含非数字型字符。<br><br>- java.lang.IndexOutOfBoundsException ：数组角标越界异常，常见于操作数组对象时发生。<br><br>- java.lang.ClassCastException ：数据类型转换异常<br><br>- SQLException ：SQL 异常，常见于操作数据库时的 SQL 语句错误。<br><br><br><br>## 枚举和switch<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		System.out.println(TestEnum.FRI.getClass()); 	<span class="comment">//class TestEnum</span></span><br><span class="line">		System.out.println(TestEnum.FRI);		<span class="comment">// FRI</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> TestEnum &#123;</span><br><span class="line">	 MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>switch中可以跟的类型有byte、short、char、int、String、枚举。<strong>没有long</strong>。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"200"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (str) &#123;</span><br><span class="line">	<span class="keyword">default</span>:		<span class="comment">// default 只能定义一次</span></span><br><span class="line">		System.out.println(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"100"</span>:</span><br><span class="line">		System.out.println(<span class="number">1000</span>);</span><br><span class="line">	<span class="keyword">case</span> <span class="string">"1000"</span>:</span><br><span class="line">		System.out.println(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str = 200;</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//	100</span></span><br><span class="line"><span class="comment">//	1000</span></span><br><span class="line"><span class="comment">//	1000</span></span><br><span class="line"><span class="comment">//因为不能匹配100或1000，所以从defalut口进入。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//str = 100;</span></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="comment">//	1000</span></span><br><span class="line"><span class="comment">//	1000</span></span><br><span class="line"><span class="comment">//因为可以匹配100，从第二个口进入。</span></span><br></pre></td></tr></table></figure><br><br>## 随机数和round<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得随机数：greater than or equal to 0.0 and less than 1.0</span></span><br><span class="line"><span class="keyword">double</span> iRandom = Math.random();</span><br><span class="line">System.out.println(iRandom);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获得区间在[0, n)之间的随机整数</span></span><br><span class="line">Random random2 = <span class="keyword">new</span> Random();</span><br><span class="line"><span class="keyword">int</span> nextInt = random2.nextInt(<span class="number">10</span>);</span><br><span class="line">System.out.println(nextInt);</span><br></pre></td></tr></table></figure><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 负数：加0.5之后向小的取整</span></span><br><span class="line">System.out.println(Math.round(-<span class="number">11.6</span>));</span><br><span class="line">System.out.println(Math.round(-<span class="number">11.5</span>));</span><br><span class="line"><span class="comment">// 正数：加0.5之后向大的取整</span></span><br><span class="line">System.out.println(Math.round(<span class="number">11.6</span>));</span><br><span class="line">System.out.println(Math.round(<span class="number">11.5</span>));</span><br></pre></td></tr></table></figure><br><br>## String和字符串常量池<br><br>字符串常量池只是常量池技术在字符串这个类上的实现，但是为了方便叙述，本条知识点使用常量池和字符串常量池等价。<br><br>### String对象的两种创建方式<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用双引号声明出来的 String 对象会直接存储在常量池中。</span></span><br><span class="line"><span class="comment">// 使用双引号声明时会调用ldc命令，所以其检查的是字符串常量池。</span></span><br><span class="line">String str1 = <span class="string">"abcd"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于new String()则会在堆中创建一个String对象，并返回该对象的引用。</span></span><br><span class="line"><span class="comment">// Initializes a newly created String object so that it represents the same sequence </span></span><br><span class="line"><span class="comment">// of characters as the argument; in other words, the newly created string is a copy </span></span><br><span class="line"><span class="comment">// of the argument string. Unless an explicit copy of original is needed, use of this </span></span><br><span class="line"><span class="comment">// constructor is unnecessary since Strings are immutable.</span></span><br><span class="line">String str2 = <span class="keyword">new</span> String(<span class="string">"abcd"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2);	<span class="comment">//false</span></span><br></pre></td></tr></table></figure><br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/2019-07-11_165800.jpg"></div><br>### intern()<br><br>String.intern() 是一个 Native 方法，JDK对它的解释是（水平有限，不再翻译）：<br><br>&gt; A pool of strings, initially empty, is maintained privately by the class String. When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.（笔者注：add的意思不是克隆一份，就是把这个对象的引用放在常量池中，JDK8中字符串常量池可以存放字符串对象，也可以存放字符串对象的引用，返回的引用是指向常量池中的字符串对象）<br>&gt; It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.<br>&gt; All literal strings and string-valued constant expressions are interned.<br><br>大致意思是：如果字符串常量池中已经有了这个字符串，那么直接返回字符串常量池中的它的引用，如果没有，那就将它的引用保存一份到字符串常量池，然后直接返回这个引用。判断字符串是否相等使用<code>equals</code>方法。<br><br><br><br>### 题<br><br>#### 1<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"计算机"</span>);</span><br><span class="line">String s2 = s1.intern();</span><br><span class="line">String s3 = <span class="string">"计算机"</span>;</span><br><span class="line">System.out.println(s2);<span class="comment">//计算机</span></span><br><span class="line">System.out.println(s1 == s2);<span class="comment">//false，因为一个是堆内存中的String对象一个是常量池中的String对象</span></span><br><span class="line">System.out.println(s3 == s2);<span class="comment">//true，因为两个都是常量池中的String对象</span></span><br></pre></td></tr></table></figure><br><br>#### 2<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Hollis"</span>;</span><br><span class="line">String s2 = <span class="keyword">new</span> String(<span class="string">"Hollis"</span>);</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"Hollis"</span>).intern();</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2); <span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s3); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/01-Java基础/例2.jpg"></div><br>#### 3<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"1"</span>);</span><br><span class="line"><span class="comment">// 常量池中有"1"，堆中有字符串"1"，s是堆中中"1"的引用</span></span><br><span class="line"></span><br><span class="line">String s2 = <span class="string">"1"</span>;</span><br><span class="line"><span class="comment">// s2是常量池中"1"的引用</span></span><br><span class="line"></span><br><span class="line">s.intern();</span><br><span class="line"><span class="comment">// "1"已经存在常量池中，返回常量池中"1"的引用，但没有被接收</span></span><br><span class="line"></span><br><span class="line">System.out.println(s == s2);		<span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"1"</span>) + <span class="keyword">new</span> String(<span class="string">"2"</span>);</span><br><span class="line"><span class="comment">// 常量池中有"1"，"2"。new String("1") + new String("2");的底层是使用StringBuffer的append</span></span><br><span class="line"><span class="comment">// 方 法将"1"和"2"拼接在一块，然后调用toString方法new出"12"；所以此时的“12”字符串是创建在堆区的；</span></span><br><span class="line"></span><br><span class="line">s3.intern();</span><br><span class="line"><span class="comment">// 常量池中没有"12"，intern后常量池中存放堆中"12"的引用</span></span><br><span class="line"></span><br><span class="line">String s4 = <span class="string">"12"</span>;</span><br><span class="line"><span class="comment">// 从常量池中拿"12"，和堆中的"12"是同一个"12"</span></span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);	<span class="comment">//true</span></span><br></pre></td></tr></table></figure><br><br>#### 4<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;</span><br><span class="line"><span class="comment">// 常量池中有"z"和"xy"，堆中有"xyz"</span></span><br><span class="line"></span><br><span class="line">String s2 = s1.intern();  </span><br><span class="line"><span class="comment">// 常量池中有一个指向堆中"xyz"的引用，s2和这个引用相等，即s2指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s1.intern());    <span class="comment">//true </span></span><br><span class="line"><span class="comment">// s1指向堆中"xyz"，s1.intern()也指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s1.intern()); <span class="comment">//true</span></span><br><span class="line"><span class="comment">// s2指向堆中"xyz"的引用</span></span><br></pre></td></tr></table></figure><br><br>#### 5<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;</span><br><span class="line"><span class="comment">// 常量池中有"z"和"xy"，堆中有"xyz"，s1指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"xyz"</span>);</span><br><span class="line"><span class="comment">// 常量池中有"xyz"，s3指向堆中的第二个"xyz"</span></span><br><span class="line"></span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"><span class="comment">// s2指向常量池中的"xyz"</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s3);	<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s1.intern());    <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s1.intern());  <span class="comment">//true</span></span><br></pre></td></tr></table></figure><br><br>#### 6<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;</span><br><span class="line"><span class="comment">// 常量池中有"z"和"xy"，堆中有"xyz"，s1指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"><span class="comment">// 常量池中有一个指向堆中"xyz"的引用，s2和这个引用相等，即s2指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"xyz"</span>);</span><br><span class="line"><span class="comment">// 常量池中有一个指向堆中"xyz"的引用，不再在常量池中创建"xyz"，将常量池中的"xyz"复制一份到堆中</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s3);	<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s1.intern());    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s1.intern());	<span class="comment">// true</span></span><br></pre></td></tr></table></figure><br><br>#### 7<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;</span><br><span class="line"><span class="comment">// 常量池中有"z"和"xy"，堆中有"xyz"，s1指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"><span class="comment">// 常量池中有一个指向堆中"xyz"的引用，s2和这个引用相等，即s2指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="string">"xyz"</span>;</span><br><span class="line"><span class="comment">// 常量池中有一个指向堆中"xyz"的引用，不再在常量池中创建"xyz"，s3指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s3);	<span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s1.intern());    <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(s2 == s1.intern());	<span class="comment">// true</span></span><br></pre></td></tr></table></figure><br><br>#### 8<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"xy"</span> + <span class="string">"z"</span>;</span><br><span class="line"><span class="comment">// 常量池中存在 "xy"  "z"  "xyz"</span></span><br></pre></td></tr></table></figure><br><br>#### 9<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">new</span> String(<span class="string">"xy"</span>) + <span class="string">"z"</span>;</span><br><span class="line"><span class="comment">// 常量池中有"z"和"xy"，堆中有"xyz"，s1指向堆中的"xyz"</span></span><br><span class="line"></span><br><span class="line">String s3 = <span class="string">"xyz"</span>;</span><br><span class="line"><span class="comment">// 常量池中有"xyz"，s3指向常量池中的"xyz"</span></span><br><span class="line"></span><br><span class="line">String s2 = s1.intern();</span><br><span class="line"><span class="comment">// s2指向常量池中的"xyz"</span></span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s3);	<span class="comment">//false</span></span><br><span class="line">System.out.println(s1 == s2);	<span class="comment">//false</span></span><br><span class="line">System.out.println(s2 == s3);	<span class="comment">//true</span></span><br><span class="line">System.out.println(s1 == s1.intern());	<span class="comment">//false</span></span><br><span class="line">System.out.println(s2 == s1.intern()); 	<span class="comment">//true</span></span><br></pre></td></tr></table></figure><br><br>## String、StringBuilder &amp; StringBuffer<br><br>### <strong>可变性</strong><br><br>简单的来说：String 类中使用 final 关键字修饰字符数组来保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串<code>char[]value</code> 但是没有用 final 关键字修饰，所以这两种对象都是可变的。<br><br>StringBuilder 与 StringBuffer 的构造方法都是调用父类构造方法也就是 AbstractStringBuilder 实现的。<br><br>AbstractStringBuilder.java<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="keyword">int</span> count;</span><br><span class="line">    AbstractStringBuilder() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    AbstractStringBuilder(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line">        value = <span class="keyword">new</span> <span class="keyword">char</span>[capacity];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><br>### 线程安全性<br><br>String 中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。<br><br><br><br>### <strong>性能</strong><br><br>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。<br><br><br><br>### <strong>对于三者使用的总结：</strong><br><br>1. 操作少量的数据: 适用String<br>2. 单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder<br>3. 多线程操作字符串缓冲区下操作大量数据: 适用StringBuffer<br><br>Java中字符串相加，编译的时候会创建StringBuilder类，然后利用StringBuilder的append()方法相加。所以不能在循环里使用<code>+</code>，需要在循环外面使用创建StringBuilder的对象，在循环内进行append()操作。<br><br><br><br>## 日期类<br><br>### LocalDate<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当前日期</span></span><br><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line">System.out.println(<span class="string">"Current Date="</span> + today);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据年、月、日创建日期</span></span><br><span class="line">LocalDate firstDay_2014 = LocalDate.of(<span class="number">2014</span>, Month.JANUARY, <span class="number">1</span>);</span><br><span class="line">System.out.println(<span class="string">"Specific Date="</span> + firstDay_2014);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不合法的参数会报 java.time.DateTimeException</span></span><br><span class="line"><span class="comment">// LocalDate feb29_2014 = LocalDate.of(2014, Month.FEBRUARY, 29);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Current date in "Asia/Kolkata", you can get it from ZoneId javadoc</span></span><br><span class="line">LocalDate todayKolkata = LocalDate.now(ZoneId.of(<span class="string">"Asia/Kolkata"</span>));</span><br><span class="line">System.out.println(<span class="string">"Current Date in IST="</span> + todayKolkata);</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.time.zone.ZoneRulesException: Unknown time-zone ID: IST</span></span><br><span class="line"><span class="comment">// LocalDate todayIST = LocalDate.now(ZoneId.of("IST"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Getting date from the base date: 01/01/1970</span></span><br><span class="line">LocalDate dateFromBase = LocalDate.ofEpochDay(<span class="number">365</span>);</span><br><span class="line">System.out.println(<span class="string">"365th day from base date= "</span> + dateFromBase);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到某年的多少天</span></span><br><span class="line">LocalDate hundredDay2014 = LocalDate.ofYearDay(<span class="number">2014</span>, <span class="number">100</span>);</span><br><span class="line">System.out.println(<span class="string">"100th day of 2014="</span> + hundredDay2014);</span><br></pre></td></tr></table></figure><br><br>### LocalTime<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Current Time</span></span><br><span class="line">LocalTime time = LocalTime.now();</span><br><span class="line">System.out.println(<span class="string">"Current Time = "</span> + time);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating LocalTime by providing input arguments</span></span><br><span class="line">LocalTime specificTime = LocalTime.of(<span class="number">12</span>, <span class="number">20</span>, <span class="number">25</span>, <span class="number">40</span>);</span><br><span class="line">System.out.println(<span class="string">"Specific Time of Day = "</span> + specificTime);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try creating time by providing invalid inputs</span></span><br><span class="line"><span class="comment">// LocalTime invalidTime = LocalTime.of(25,20);</span></span><br><span class="line"><span class="comment">// Exception in thread "main" java.time.DateTimeException:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Invalid value for HourOfDay (valid values 0 - 23): 25</span></span><br><span class="line"><span class="comment">// Current date in "Asia/Kolkata", you can get it from ZoneId javadoc</span></span><br><span class="line">LocalTime timeKolkata = LocalTime.now(ZoneId.of(<span class="string">"Asia/Kolkata"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"Current Time in IST = "</span> + timeKolkata);</span><br><span class="line"><span class="comment">// java.time.zone.ZoneRulesException: Unknown time-zone ID: IST</span></span><br><span class="line"><span class="comment">// LocalTime todayIST = LocalTime.now(ZoneId.of("IST"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Getting time from the base date: 00:00:00</span></span><br><span class="line">LocalTime specificSecondTime = LocalTime.ofSecondOfDay(<span class="number">10000</span>);</span><br><span class="line">System.out.println(<span class="string">"10000th second time = "</span> + specificSecondTime);</span><br></pre></td></tr></table></figure><br><br>### LocalDateTime<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Current Date</span></span><br><span class="line">LocalDateTime today = LocalDateTime.now();</span><br><span class="line">System.out.println(<span class="string">"Current DateTime1 = "</span> + today);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Current Date using LocalDate and LocalTime</span></span><br><span class="line">today = LocalDateTime.of(LocalDate.now(), LocalTime.now());</span><br><span class="line">System.out.println(<span class="string">"Current DateTime2 = "</span> + today);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Creating LocalDateTime by providing input arguments</span></span><br><span class="line">LocalDateTime specificDate = LocalDateTime.of(<span class="number">2014</span>, Month.JANUARY, <span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">30</span>);</span><br><span class="line">System.out.println(<span class="string">"Specific Date = "</span> + specificDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Try creating date by providing invalid inputs</span></span><br><span class="line"><span class="comment">// LocalDateTime feb29_2014 = LocalDateTime.of(2014, Month.FEBRUARY, 28, 25, 1, 1);</span></span><br><span class="line"><span class="comment">// Exception in thread "main" java.time.DateTimeException:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Invalid value for HourOfDay (valid values 0 - 23): 25</span></span><br><span class="line"><span class="comment">// Current date in "Asia/Kolkata", you can get it from ZoneId javadoc</span></span><br><span class="line">LocalDateTime todayKolkata = LocalDateTime.now(ZoneId.of(<span class="string">"Asia/Kolkata"</span>));</span><br><span class="line">System.out.println(<span class="string">"Current Date in IST = "</span> + todayKolkata);</span><br><span class="line"></span><br><span class="line"><span class="comment">// java.time.zone.ZoneRulesException: Unknown time-zone ID: IST</span></span><br><span class="line"><span class="comment">// LocalDateTime todayIST = LocalDateTime.now(ZoneId.of("IST"));</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Getting date from the base date: 01/01/1970</span></span><br><span class="line">LocalDateTime dateFromBase = LocalDateTime.ofEpochSecond(<span class="number">10000</span>, <span class="number">0</span>, ZoneOffset.UTC);</span><br><span class="line">System.out.println(<span class="string">"10000th second time from 01/01/1970= "</span> + dateFromBase);</span><br></pre></td></tr></table></figure><br><br>### Instant<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Current timestamp</span></span><br><span class="line">Instant timestamp = Instant.now();</span><br><span class="line">System.out.println(<span class="string">"Current Timestamp = "</span> + timestamp);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转换为 milliseconds from 01/01/1970</span></span><br><span class="line"><span class="keyword">long</span> epochMilli = timestamp.toEpochMilli();</span><br><span class="line">System.out.println(epochMilli);</span><br></pre></td></tr></table></figure><br><br>### Date &amp; SimpleDateFormat<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SimpleDateFormat oldFormatter = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy/MM/dd"</span>);</span><br><span class="line">Date date1 = <span class="keyword">new</span> Date();</span><br><span class="line">System.out.println(oldFormatter.format(date1));</span><br></pre></td></tr></table></figure><br><br>### 相互转换<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Date now = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">LocalDateTime localDateTime = now.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br><span class="line">LocalTime localTime = now.toInstant().atZone(ZoneId.systemDefault()).toLocalTime();</span><br><span class="line">LocalDate localDate = now.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();</span><br><span class="line"></span><br><span class="line">System.out.println(localDateTime);</span><br><span class="line">System.out.println(localTime);</span><br><span class="line">System.out.println(localDate);</span><br><span class="line"></span><br><span class="line"><span class="comment">// LocalTime 和 LocalDate 没有atZone方法</span></span><br><span class="line">Date oldLocalDateTime = </span><br><span class="line">	Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());</span><br><span class="line">System.out.println(oldLocalDateTime);</span><br><span class="line"></span><br><span class="line"><span class="keyword">long</span> millis = </span><br><span class="line">	localDateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();</span><br><span class="line"><span class="keyword">long</span> time = now.getTime();</span><br><span class="line">System.out.println(millis);</span><br><span class="line">System.out.println(time);</span><br><span class="line"></span><br><span class="line">LocalDateTime parseLocalDateTime = </span><br><span class="line">	Instant.ofEpochMilli(millis).atZone(ZoneId.systemDefault()).toLocalDateTime();</span><br><span class="line">LocalDate parseLocalDate = </span><br><span class="line">	Instant.ofEpochMilli(millis).atZone(ZoneId.systemDefault()).toLocalDate();</span><br><span class="line"></span><br><span class="line">System.out.println(parseLocalDateTime);</span><br><span class="line">System.out.println(parseLocalDate);</span><br></pre></td></tr></table></figure><br><br>### 获取年月日时钟秒<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDateTime dt = LocalDateTime.now();</span><br><span class="line">System.out.println(dt.getYear());</span><br><span class="line">System.out.println(dt.getMonthValue()); <span class="comment">// 1 - 12</span></span><br><span class="line">System.out.println(dt.getDayOfMonth());</span><br><span class="line">System.out.println(dt.getHour());</span><br><span class="line">System.out.println(dt.getMinute());</span><br><span class="line">System.out.println(dt.getSecond());</span><br></pre></td></tr></table></figure><br><br>### 获得某月第一天/最后一天<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LocalDate today = LocalDate.now();</span><br><span class="line"><span class="comment">//本月的第一天</span></span><br><span class="line">LocalDate firstday = LocalDate.of(today.getYear(), today.getMonth(), <span class="number">1</span>);</span><br><span class="line"><span class="comment">//本月的最后一天</span></span><br><span class="line">LocalDate lastDay =today.with(TemporalAdjusters.lastDayOfMonth());</span><br><span class="line">System.out.println(<span class="string">"本月的第一天       "</span> + firstday);</span><br><span class="line">System.out.println(<span class="string">"本月的最后一天   "</span> + lastDay);</span><br></pre></td></tr></table></figure><br><br>### 格式化日期<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">DateTimeFormatter dtf1 = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd  HH:mm:ss"</span>);</span><br><span class="line">DateTimeFormatter dtf2 = DateTimeFormatter.ofPattern(<span class="string">"yyyy/MM/dd"</span>);</span><br><span class="line"></span><br><span class="line">LocalDateTime ldt = LocalDateTime.now();</span><br><span class="line">LocalDate ld = LocalDate.now();</span><br><span class="line"></span><br><span class="line">System.out.println(ldt);</span><br><span class="line">System.out.println(ld);</span><br><span class="line"></span><br><span class="line">String format1 = ldt.format(dtf1);		<span class="comment">// 日期格式化为字符串</span></span><br><span class="line">String format2 = ld.format(dtf2);		<span class="comment">// 日期格式化为字符串</span></span><br><span class="line">System.out.println(format1);</span><br><span class="line">System.out.println(format2);</span><br><span class="line"></span><br><span class="line">LocalDateTime parse1 = LocalDateTime.parse(format1, dtf1);	</span><br><span class="line">LocalDate parse2 = LocalDate.parse(format2, dtf2);</span><br><span class="line"></span><br><span class="line">System.out.println(parse1);		<span class="comment">// 字符串转化为日期</span></span><br><span class="line">System.out.println(parse2);		<span class="comment">// 字符串转化为日期</span></span><br></pre></td></tr></table></figure><br><br>## equals()和hashCode()<br><br>Java 对于 eqauls 方法和 hashCode 方法是这样规定的：<br><br>- 如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；<br>- 如果两个对象的 hashCode 相同，它们并不一定相同。<br><br><br><br>### equals()需要满足的性质<br><br>- 自反性：x.equals(x)必须返回 true<br>- 对称性：x.equals(y)返回 true 时，y.equals(x)也必须返回 true<br>- 传递性：x.equals(y)和 y.equals(z)都返回 true 时，x.equals(z)也必须返回 true<br>- 一致性：当x 和 y 引用的对象信息没有被修改时，多次调用 x.equals(y)应该得到同样的返回值，<br>- 对于任何非 null 值的引用 x，x.equals(null)必须返回 false。<br><br><br><br>### 实现高质量的 equals ()<br><br>- 使用==操作符检查”参数是否为这个对象的引用”；<br>- 使用 instanceof 操作符检查”参数是否为正确的类型”；<br>- 对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；<br>- 编写完 equals 方法后，问自己它是否满足对称性、传递性、一致性和空值返回false；<br>- 重写 equals 时总是要重写 hashCode；<br>- 不要将 equals 方法参数中的 Object 对象替换为其他的类型，在重写时不要忘掉@Override注解。<br><br><br><br>### 正确使用equals方法<br><br>推荐使用：<code>Objects.equals(o1, o2)</code>，此方法的底层实现：<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static boolean equals(Object a, Object b) &#123;</span><br><span class="line">    // 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。</span><br><span class="line">    return (a == b) || (a != null &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 两者的关系<br><br>在使用到哈希机制的集合时需要同时重写equles方法和hashCode方法。即重写对象的散列码是为了更好的支持基于哈希机制的Java集合类，例如 Hashtable, HashMap, HashSet 等，如果不重写hashCode()，在使用哈希机制的集合类时会出错。<br><br>当把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。但不同对象的hashCode可能重复，所以哈希机制的集合会在判断hashCode之后再判断一次equals。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p1 = <span class="keyword">new</span> Person(<span class="string">"eee"</span>, <span class="number">100</span>);</span><br><span class="line">        Person p2 = <span class="keyword">new</span> Person(<span class="string">"eee"</span>, <span class="number">100</span>);</span><br><span class="line">        Person p3 = <span class="keyword">new</span> Person(<span class="string">"aaa"</span>, <span class="number">200</span>);</span><br><span class="line">        Person p4 = <span class="keyword">new</span> Person(<span class="string">"EEE"</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        HashSet set = <span class="keyword">new</span> HashSet();</span><br><span class="line">        set.add(p1);</span><br><span class="line">        set.add(p2);</span><br><span class="line">        set.add(p3);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 打印set</span></span><br><span class="line">        System.out.printf(<span class="string">"set:%s\n"</span>, set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">        String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> name.hashCode() ^ age;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="string">"Person [age="</span> + age + <span class="string">", name="</span> + name + <span class="string">"]"</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>&#123;  </span><br><span class="line">            <span class="keyword">if</span>(obj == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果是同一个对象返回true，反之返回false  </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span> == obj) <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">            </span><br><span class="line">            <span class="comment">//判断是否类型相同  </span></span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.getClass() != obj.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;  </span><br><span class="line">              </span><br><span class="line">            Person person = (Person)obj;  </span><br><span class="line">            <span class="keyword">return</span> name.equals(person.name) &amp;&amp; age==person.age;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>## 装饰者模式<br><br>### 准备工作<br><br>假设无人驾驶的标准是Oracle公司制定的，Google想使用Java语言来开发无人驾驶系统，那么首先它需要创建一个类实现Oracle公司提供的无人驾驶的接口（接口为AIDriving，类为GoogleAIDriving）。<br><br>- AIDriving<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AIDriving</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;  <span class="comment">//无人驾驶汽车启动的方法</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span>;   <span class="comment">//无人驾驶汽车停止的方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>- GoogleAIDriving<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GoogleAIDriving</span> <span class="keyword">implements</span> <span class="title">AIDriving</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Google汽车启动了..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Google汽车停止了..."</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 传统方法-继承<br><br>这个时候国内某汽车制造公司（设为A公司）想使用Google提供的无人驾驶系统。但是Google提供的系统不太适合我国国情，所以A公司的工程师就想在Google系统的基础上进行定制。他们选择的方式是继承GoogleAIDriving，创建一个自己的类：A1GoogleAIDriving。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A1GoogleAIDriving</span> <span class="keyword">extends</span> <span class="title">GoogleAIDriving</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"在中国启动汽车"</span>);</span><br><span class="line">		<span class="keyword">super</span>.start();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"在中国停止汽车"</span>);</span><br><span class="line">		<span class="keyword">super</span>.stop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### 装饰者模式<br><br>但理想很美好，现实很残忍。GoogleAIDriving被定义为一个final类（不能被继承），这个是可以理解的，因为如果GoogleAIDriving不是一个final类，任何继承GoogleAIDriving的类都可以对其start()、stop()方法进行覆盖，如果覆盖时出现bug就可能会出现大问题。所以像启动、停止这种核心功能是不允许汽车制造商随意修改的。A公司的工程师就想到了使用装饰者模式来增强功能（设类为A2GoogleAIDriving）。<br><br>装饰者模式该怎么做呢？<br><br>1. 首先，装饰类得和被装饰类实现相同的接口，即AIDriving；<br>2. 第二，在装饰类中定义一个AIDriving类型的属性，即AIDriving car；<br>3. 第三，有一个参数为AIDriving类型的构造函数，即A2GoogleAIDriving(AIDriving car)；<br>4. 第四，装饰类的每个方法都要调用被装饰类相应的方法；<br>5. 第五，使用第三步中的构造函数创建装饰类；<br>6. 第六，在装饰类的方法中自定义功能。<br><br>#### 代码实现<br><br>- 创建装饰类<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A2GoogleAIDriving</span> <span class="keyword">implements</span> <span class="title">AIDriving</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> AIDriving car;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">A2GoogleAIDriving</span><span class="params">(AIDriving car)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.car = car;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"在中国启动汽车..."</span>);</span><br><span class="line">		car.start();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"在中国停止汽车..."</span>);</span><br><span class="line">		car.stop();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>#### 调用装饰类<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		GoogleAIDriving car = <span class="keyword">new</span> GoogleAIDriving();</span><br><span class="line">		A2GoogleAIDriving aCar = <span class="keyword">new</span> A2GoogleAIDriving(car);</span><br><span class="line">		aCar.start();</span><br><span class="line">		 <span class="comment">/* Console : </span></span><br><span class="line"><span class="comment">		  		在中国启动汽车...</span></span><br><span class="line"><span class="comment">				Google汽车启动了...		 */</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>## BigInteger&amp;BigDecimal<br><br>### BigInteger<br><br>理论上可以表示无限大的数字。常用方法：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BigInteger <span class="title">abs</span><span class="params">()</span>  返回大整数的绝对值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">add</span><span class="params">(BigInteger val)</span> 返回两个大整数的和</span></span><br><span class="line"><span class="function">BigInteger <span class="title">and</span><span class="params">(BigInteger val)</span>  返回两个大整数的按位与的结果</span></span><br><span class="line"><span class="function">BigInteger <span class="title">andNot</span><span class="params">(BigInteger val)</span> 返回两个大整数与非的结果</span></span><br><span class="line"><span class="function">BigInteger <span class="title">divide</span><span class="params">(BigInteger val)</span>  返回两个大整数的商</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">doubleValue</span><span class="params">()</span>   返回大整数的<span class="keyword">double</span>类型的值</span></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">floatValue</span><span class="params">()</span>   返回大整数的<span class="keyword">float</span>类型的值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">gcd</span><span class="params">(BigInteger val)</span>  返回大整数的最大公约数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> 返回大整数的整型值</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">longValue</span><span class="params">()</span> 返回大整数的<span class="keyword">long</span>型值</span></span><br><span class="line"><span class="function">BigInteger <span class="title">max</span><span class="params">(BigInteger val)</span> 返回两个大整数的最大者</span></span><br><span class="line"><span class="function">BigInteger <span class="title">min</span><span class="params">(BigInteger val)</span> 返回两个大整数的最小者</span></span><br><span class="line"><span class="function">BigInteger <span class="title">mod</span><span class="params">(BigInteger val)</span> 用当前大整数对val求模</span></span><br><span class="line"><span class="function">BigInteger <span class="title">multiply</span><span class="params">(BigInteger val)</span> 返回两个大整数的积</span></span><br><span class="line"><span class="function">BigInteger <span class="title">negate</span><span class="params">()</span> 返回当前大整数的相反数</span></span><br><span class="line"><span class="function">BigInteger <span class="title">not</span><span class="params">()</span> 返回当前大整数的非</span></span><br><span class="line"><span class="function">BigInteger <span class="title">or</span><span class="params">(BigInteger val)</span> 返回两个大整数的按位或</span></span><br><span class="line"><span class="function">BigInteger <span class="title">pow</span><span class="params">(<span class="keyword">int</span> exponent)</span> 返回当前大整数的exponent次方</span></span><br><span class="line"><span class="function">BigInteger <span class="title">remainder</span><span class="params">(BigInteger val)</span> 返回当前大整数除以val的余数</span></span><br><span class="line"><span class="function">BigInteger <span class="title">leftShift</span><span class="params">(<span class="keyword">int</span> n)</span> 将当前大整数左移n位后返回</span></span><br><span class="line"><span class="function">BigInteger <span class="title">rightShift</span><span class="params">(<span class="keyword">int</span> n)</span> 将当前大整数右移n位后返回</span></span><br><span class="line"><span class="function">BigInteger <span class="title">subtract</span><span class="params">(BigInteger val)</span>返回两个大整数相减的结果</span></span><br><span class="line"><span class="function"><span class="keyword">byte</span>[] <span class="title">toByteArray</span><span class="params">(BigInteger val)</span>将大整数转换成二进制反码保存在<span class="keyword">byte</span>数组中</span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span> 将当前大整数转换成十进制的字符串形式</span></span><br><span class="line"><span class="function">BigInteger <span class="title">xor</span><span class="params">(BigInteger val)</span> 返回两个大整数的异或</span></span><br></pre></td></tr></table></figure><br><br>### BigDecimal<br><br>浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。具体原理和浮点数的编码方式有关。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">1.0f</span> - <span class="number">0.9f</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">0.9f</span> - <span class="number">0.8f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999964</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><br><br>具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（<strong>精度丢失</strong>），我们如何解决这个问题呢？一种很常用的方法是：<strong>使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。</strong><br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">"1.0"</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">"0.9"</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">"0.8"</span>);</span><br><span class="line">BigDecimal x = a.subtract(b);<span class="comment">// 0.1</span></span><br><span class="line">BigDecimal y = b.subtract(c);<span class="comment">// 0.1</span></span><br><span class="line">System.out.println(x.equals(y));<span class="comment">// true</span></span><br></pre></td></tr></table></figure><br><br>#### API<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal(<span class="keyword">int</span>)       创建一个具有参数所指定整数值的对象。      </span><br><span class="line">BigDecimal(<span class="keyword">double</span>)    创建一个具有参数所指定双精度值的对象。     </span><br><span class="line">BigDecimal(<span class="keyword">long</span>)      创建一个具有参数所指定长整数值的对象。     </span><br><span class="line">BigDecimal(String)    创建一个具有参数所指定以字符串表示的数值的对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(BigDecimal)       BigDecimal对象中的值相加，然后返回这个对象。</span><br><span class="line">subtract(BigDecimal)  BigDecimal对象中的值相减，然后返回这个对象。</span><br><span class="line">multiply(BigDecimal)  BigDecimal对象中的值相乘，然后返回这个对象。</span><br><span class="line">divide(BigDecimal)    BigDecimal对象中的值相除，然后返回这个对象。</span><br><span class="line">toString()            将BigDecimal对象的数值转换成字符串。    </span><br><span class="line">doubleValue()         将BigDecimal对象中的值以双精度数返回。   </span><br><span class="line">floatValue()          将BigDecimal对象中的值以单精度数返回。   </span><br><span class="line">longValue()           将BigDecimal对象中的值以长整数返回。    </span><br><span class="line">intValue()            将BigDecimal对象中的值以整数返回。</span><br></pre></td></tr></table></figure><br><br>我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 <strong>BigDecimal(String)</strong> 构造方法来创建对象。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="number">1.01</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="number">1.02</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">"1.01"</span>);</span><br><span class="line">BigDecimal d = <span class="keyword">new</span> BigDecimal(<span class="string">"1.02"</span>);</span><br><span class="line">System.out.println(a.add(b));</span><br><span class="line">System.out.println(c.add(d));</span><br><span class="line"></span><br><span class="line">输出：</span><br><span class="line"><span class="number">2.0300000000000000266453525910037569701671600341796875</span></span><br><span class="line"><span class="number">2.03</span></span><br></pre></td></tr></table></figure><br><br>### 整型包装类值的比较<br><br>所有整形包装类对象值得比较必须使用equals方法。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer x = <span class="number">3</span>;</span><br><span class="line">Integer y = <span class="number">3</span>;</span><br><span class="line">System.out.println(x == y);<span class="comment">// true</span></span><br><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">System.out.println(a == b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><br><br>## Arrays.asList<br><br><code>Arrays.asList()</code>将数组转换为集合后,底层其实还是数组。<strong>传递的数组必须是对象数组，而不是基本类型。</strong><code>Arrays.asList()</code>是泛型方法，传入的对象必须是对象数组。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">List myList = Arrays.asList(myArray);</span><br><span class="line">System.out.println(myList.size());<span class="comment">//1</span></span><br><span class="line">System.out.println(myList.get(<span class="number">0</span>));<span class="comment">//数组地址值</span></span><br><span class="line">System.out.println(myList.get(<span class="number">1</span>));<span class="comment">//报错：ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="keyword">int</span> [] array=(<span class="keyword">int</span>[]) myList.get(<span class="number">0</span>);</span><br><span class="line">System.out.println(array[<span class="number">0</span>]);<span class="comment">//1</span></span><br></pre></td></tr></table></figure><br><br>当传入一个原生数据类型数组时，<code>Arrays.asList()</code> 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。我们使用包装类型数组就可以解决这个问题。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer[] myArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br></pre></td></tr></table></figure><br><br><strong>使用集合的修改方法:add()、remove()、clear()会抛出异常。</strong><code>Arrays.asList()</code> 方法返回的并不是 <code>java.util.ArrayList</code> ，而是 <code>java.util.Arrays</code> 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> </span></span><br><span class="line"><span class="class">	<span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">replaceAll</span><span class="params">(UnaryOperator&lt;E&gt; operator)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; c)</span> </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>我们再看一下<code>java.util.AbstractList</code>的<code>remove()</code>方法，这样我们就明白为啥会抛出<code>UnsupportedOperationException</code>。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>正确的数组转集合的方法：<code>List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code><br><br><br><br><br><br><br><br>## List<br><br>ArrayList的扩容机制<br><br><br><br>## Comparable &amp; Comparator<br><br>### Comparable<br><br>&gt; This interface imposes a total ordering on the objects of each class that implements it. This ordering is referred to as the class’s natural ordering, and the class’s compareTo method is referred to as its natural comparison method.<br>&gt;<br>&gt; Lists (and arrays) of objects that implement this interface can be sorted automatically by Collections.sort (and Arrays.sort). Objects that implement this interface can be used as keys in a sorted map or as elements in a sorted set, without the need to specify a comparator.<br><br>compareTo 方法的返回值有三种情况：<br><br>- e1.compareTo(e2) &gt; 0 即 e1 &gt; e2<br>- e1.compareTo(e2) = 0 即 e1 = e2<br>- e1.compareTo(e2) &lt; 0 即 e1 &lt; e2<br><br>满足上述规则的是升序排序，与上诉规则相反则是降序排序。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">    	</span><br><span class="line">    	Set&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    	set.add(<span class="keyword">new</span> Person(<span class="number">50</span>));</span><br><span class="line">    	set.add(<span class="keyword">new</span> Person(<span class="number">30</span>));</span><br><span class="line">    	set.add(<span class="keyword">new</span> Person(<span class="number">90</span>));</span><br><span class="line">    	</span><br><span class="line">    	Iterator&lt;Person&gt; iterator = set.iterator();</span><br><span class="line">    	<span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">    		System.out.println(iterator.next());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(o == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">		<span class="keyword">if</span>(age &gt; o.age)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(age &lt; o.age)</span><br><span class="line">			<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Person [age="</span> + age + <span class="string">"]"</span>; &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>&gt; Note that null is not an instance of any class, and e.compareTo(null) should throw a NullPointerException even though e.equals(null) returns false.<br><br>&gt; The natural ordering for a class C is said to be consistent with equals if and only if e1.compareTo(e2) == 0 has the same boolean value as e1.equals(e2) for every e1 and e2 of class C. It is strongly recommended (though not required) that natural orderings be consistent with equals. This is so because sorted sets (and sorted maps)without explicit comparators behave “strangely” when they are used with elements (or keys) whose natural ordering is inconsistent with equals. In particular, such a sorted set (or sorted map) violates（违反） the general contract for set (or map), which is defined in terms of（依据） the equals method.<br>&gt;<br>&gt; For example, if one adds two keys a and b such that (!a.equals(b) &amp;&amp; a.compareTo(b) == 0) to a sorted set that does not use an explicit comparator, the second add operation returns false (and the size of the sorted set does not increase) because a and b are equivalent from the sorted set’s perspective.<br><br>这段话的意思是如果compareTo规则和equals规则不同就会发生奇怪的问题，即在<code>!a.equals(b) &amp;&amp; a.compareTo(b) == 0</code>这种情况下，不能插入集合中，因为从排序集合判断是否相等使用compareTo的规则。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    	</span><br><span class="line">    	Set&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;();</span><br><span class="line">    	set.add(<span class="keyword">new</span> Person(<span class="number">50</span>));</span><br><span class="line">    	set.add(<span class="keyword">new</span> Person(<span class="number">50</span>));</span><br><span class="line">    	set.add(<span class="keyword">new</span> Person(<span class="number">90</span>));</span><br><span class="line">    	</span><br><span class="line">    	Iterator&lt;Person&gt; iterator = set.iterator();</span><br><span class="line">    	<span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">    		System.out.println(iterator.next());</span><br><span class="line">    	</span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Person</span>&gt;</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Person o)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(o == <span class="keyword">null</span>)</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">		<span class="keyword">if</span>(age == o.age)	<span class="comment">// 模仿 a.compareTo(b) == 0</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(age &gt; o.age)</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Person [age="</span> + age + <span class="string">"]"</span>; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(obj == <span class="keyword">null</span> || !(obj <span class="keyword">instanceof</span> Person))</span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		Person p = (Person)obj;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span>.age == <span class="number">50</span> || p.age == <span class="number">50</span>) &#123;			<span class="comment">// 模仿 !a.equals(b)</span></span><br><span class="line">			<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> (<span class="keyword">this</span>.age == p.age) ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age.hashCode(); &#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Person [age=50]</span></span><br><span class="line"><span class="comment">// Person [age=90]</span></span><br></pre></td></tr></table></figure><br><br>### Comparator<br><br>使用自然排序需要类实现 Comparable，并且在内部重写 comparaTo 方法。而 Comparator 则是在外部制定排序规则，然后作为排序策略参数传递给某些类，比如 Collections.sort(), Arrays.sort(), 或者一些内部有序的集合（比如 SortedSet，SortedMap 等）。<strong>同时存在时采用 Comparator（定制排序）的规则进行比较。</strong><br><br>使用方式主要分三步：<br><br>1. 创建一个 Comparator 接口的实现类，并赋值给一个对象。在 compare 方法中针对自定义类写排序规则。<br>2. 将 Comparator 对象作为参数传递给 排序类的某个方法<br>3. 向排序类中添加 compare 方法中使用的自定义类<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException  </span>&#123;</span><br><span class="line">    	Comparator&lt;Person&gt; com = <span class="keyword">new</span> Comparator&lt;Person&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Person o1, Person o2)</span> </span>&#123;</span><br><span class="line">				<span class="keyword">if</span>(o1.getAge() &gt; o2.getAge())</span><br><span class="line">					<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">				<span class="keyword">else</span> <span class="keyword">if</span>(o1.getAge() &lt; o2.getAge())</span><br><span class="line">					<span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">    	Set&lt;Person&gt; set = <span class="keyword">new</span> TreeSet&lt;&gt;(com);</span><br><span class="line">    	set.add(<span class="keyword">new</span> Person(<span class="number">50</span>));</span><br><span class="line">    	set.add(<span class="keyword">new</span> Person(<span class="number">20</span>));</span><br><span class="line">    	set.add(<span class="keyword">new</span> Person(<span class="number">90</span>));</span><br><span class="line">    	Iterator&lt;Person&gt; iterator = set.iterator();</span><br><span class="line">    	<span class="keyword">while</span>(iterator.hasNext())</span><br><span class="line">    		System.out.println(iterator.next());</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(Integer age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">"Person [age="</span> + age + <span class="string">"]"</span>; &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Integer <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> age; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>## 红黑树<br><br>### 二叉搜索树<br><br>由于红黑树本质上就是一棵二叉查找树，所以在了解红黑树之前，咱们先来看下二叉查找树。<br><br>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：<br><br>- 若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；<br>- 若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；<br>- 任意结点的左、右子树也分别为二叉查找树。<br>- 没有键值相等的结点（no duplicate nodes）。<br><br>因为，一棵由n个结点，随机构造的二叉查找树的高度为lgn，一般操作的执行时间为O（lgn）。但二叉树若退化成了一棵具有n个结点的线性链后，则此些操作最坏情况运行时间为O（n）。<br><br><br><br>### 性质<br><br>红黑树是一颗平衡二叉树，平衡二叉树的概念：每课树的左右子树高度差都不超过1。<br><br>- 每个结点都有颜色，红色或者黑色<br>- 根结点是黑色的<br>- 每个叶结点是黑色的（设叶结点是NIL，NIL指的是空节点）<br>- 如果一个结点是红色的，则它的两个子结点都是黑色的<br>- 对每个结点，从该结点到其所有后代结点的简单路径上，均包含相同数目的黑色结点<br><br><div align="center"><img width="80%" src="//isjinhao.github.io/2019/01-Java基础/2019-07-12_181943.jpg"></div><br>图中的NIL其实可以用一个哨兵（T.nil）替代，但在画图时往往其实不画NIL结点。<br><br><br><br>### 旋转<br><br>对红黑树的增加和删除会破坏红黑树原本的性质，旋转是用来使其恢复到红黑树的手段。<br><br>#### 左旋<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/2.jpg"></div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// LEFT-ROTATE(T, x)    设x是图中的pivot</span></span><br><span class="line">y = x.right</span><br><span class="line">x.right = y.left</span><br><span class="line"><span class="keyword">if</span> y.left != T.nil</span><br><span class="line">	y.left.p = x</span><br><span class="line">y.p = x.p</span><br><span class="line"><span class="keyword">if</span> x.p == T.nil</span><br><span class="line">	T.root = y</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> x == x.p.left		<span class="comment">// 判断应该放在P的左子树还是右子树上</span></span><br><span class="line">	x.p.left = y</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    x.p.right = y</span><br><span class="line">y.left = x</span><br><span class="line">x.p = y</span><br></pre></td></tr></table></figure><br><br>#### 右旋<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/3.jpg"></div><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RIGHT-ROTATE(T, x)    设x是图中的pivot</span></span><br><span class="line">y = x.left</span><br><span class="line">x.left = y.right</span><br><span class="line"><span class="keyword">if</span> y.right != T.nil</span><br><span class="line">	y.right.p = x</span><br><span class="line">y.p = x.p</span><br><span class="line"><span class="keyword">if</span> x.p == T.nil</span><br><span class="line">	T.root = y</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> x == x.p.right		<span class="comment">// 判断应该放在P的左子树还是右子树上</span></span><br><span class="line">	x.p.right = y</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    x.p.lrft = y</span><br><span class="line">y.right = x</span><br><span class="line">x.p = y</span><br></pre></td></tr></table></figure><br><br>### 二叉查找树的插入<br><br>如果要在二叉查找树中插入一个结点，首先要查找到结点插入的位置，然后进行插入，假设插入的结点为z的话，插入的伪代码如下：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TREE-INSERT(T, z)</span></span><br><span class="line">y = T.nil</span><br><span class="line">x = T.root</span><br><span class="line"><span class="keyword">while</span> x != NIL</span><br><span class="line">	y = x</span><br><span class="line">	<span class="keyword">if</span> z.key &lt; x.key</span><br><span class="line">		x = x.left</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        x = x.right</span><br><span class="line">z.p = y</span><br><span class="line"><span class="keyword">if</span> y == NIL</span><br><span class="line">	T.root = z              <span class="comment">// Tree T was empty</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z.key &lt; y.key</span><br><span class="line">	y.left = z</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    y.right = z</span><br></pre></td></tr></table></figure><br><br>### 红黑树的插入<br><br>如果我们插入的是黑色节点，会违反了性质五，需要进行大规模调整，如果我们插入的是红色节点，那就只有在要插入节点的父节点也是红色的时候违反性质四或者是当插入的节点是根节点时，违反性质二，所以，我们把要插入的节点的颜色变成红色。仍然设被插入结点是z：<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RB-INSERT(T, z)</span></span><br><span class="line">y = T.nil</span><br><span class="line">x = T.root</span><br><span class="line"><span class="keyword">while</span> x != T.nil</span><br><span class="line">	y = x</span><br><span class="line">	<span class="keyword">if</span> z.key &lt; x.key</span><br><span class="line">		x = x.left</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		x = x.right</span><br><span class="line">z.p = y</span><br><span class="line"><span class="keyword">if</span> y == T.nil</span><br><span class="line">	T.root = z</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z.key &lt; y.key</span><br><span class="line">	y.left = z</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    y.right = z</span><br><span class="line">z.left = T.nil</span><br><span class="line">z.right = T.nil</span><br><span class="line">z.color = RED</span><br><span class="line">RB-INSERT-FIXUP(T, z)</span><br></pre></td></tr></table></figure><br><br>我们把上面这段红黑树的插入代码，跟我们之前看到的二叉查找树的插入代码，可以看出，RB-INSERT(T, z)前面的16行代码基本就是二叉查找树的插入代码，然后第17-18行代码把z的左孩子、右孩子都赋为叶结点nil，第19行再把z结点着为红色，最后为保证红黑性质在插入操作后依然保持，调用一个辅助程序RB-INSERT-FIXUP来对结点进行重新着色，并旋转。 <strong>换言之</strong>：<br><br>- 如果插入的是根结点，因为原树是空树，此情况只会违反性质2，所以直接把此结点涂为黑色。<br>- 如果插入的结点的父结点是黑色，由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时也是什么也不做。<br><br>但当遇到下述3种情况时需要修复：<br><br>- 插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色<br>- 插入修复情况2：当前结点的父结点是红色，叔叔结点是黑色，当前结点是其父结点的右子<br>- 插入修复情况3：当前结点的父结点是红色，叔叔结点是黑色，当前结点是其父结点的左子<br><br><br><br>#### 修复<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">RB-INSERT-FIXUP(T, z)</span><br><span class="line"><span class="keyword">while</span> z.p.color == RED</span><br><span class="line">	<span class="keyword">if</span> z.p == z.p.p.left</span><br><span class="line">		y = z.p.p.right			<span class="comment">// 指向叔叔结点</span></span><br><span class="line">		<span class="keyword">if</span> y.color == RED</span><br><span class="line">			z.p.color = BLACK</span><br><span class="line">			y.color = BLACK</span><br><span class="line">			z.p.p.color = RED</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> z == z.p.right</span><br><span class="line">			z = z.p</span><br><span class="line">			LEFT-ROTATE(T, z)</span><br><span class="line">        z.p.color = BLACK</span><br><span class="line">        z.p.p.color = RED</span><br><span class="line">        RIGHT-ROTATE(T, z.p.p)</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 与 if 对称，等下只分析if，不分析else</span></span><br><span class="line">		y = z.p.p.left</span><br><span class="line">		<span class="keyword">if</span> y.color == RED</span><br><span class="line">			z.p.color = BLACK</span><br><span class="line">			z.p.p.color = RED</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> z == z.p.left</span><br><span class="line">			z = z.p</span><br><span class="line">			RIGHT-ROTATE(T, z)</span><br><span class="line">        z.p.color = BLACK</span><br><span class="line">        z.p.p.color = RED</span><br><span class="line">        LEFT-ROTATE(T, z.p.p)</span><br><span class="line">T.root.color = BLACK</span><br></pre></td></tr></table></figure><br><br>下面，咱们来分别处理上述3种插入修复情况。<br><br><strong>插入修复情况1：当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色。</strong><br><br>上诉代码中第5行至第8行是处理这种情况：将父结点和叔叔结点涂黑，将爷爷结点涂红。<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/4.png"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/5.png"></div><br><strong>插入修复情况2：当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的右子</strong><br><br>上诉代码中第9行至第11行是处理这种情况：当前结点的父结点做为新的当前结点，以新当前结点为支点左旋。<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/6.png"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/7.png"></div><br><strong>插入修复情况3：当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的左子</strong><br><br>上述代码中的12-14行处理此种情况：父结点变为黑色，祖父结点变为红色，在祖父结点为支点右旋。<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/8.png"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/9.png"></div><br>### 二叉查找树的后继<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TREE-SUCCESSOR(x)</span></span><br><span class="line"><span class="keyword">if</span> x.right != T.nil</span><br><span class="line">	<span class="keyword">return</span> TREE-MINIMUM(x.right)</span><br><span class="line">y = x.p</span><br><span class="line"><span class="keyword">while</span> y != T.nil and x == y.right</span><br><span class="line">	x = y</span><br><span class="line">	y = y.p</span><br><span class="line"><span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><br><br>$x$是待查找结点，右子树不为空，右子树的最小值所在的节点是后继。解释第<code>4-8</code>行代码需要证明一个定理：<br><br>&gt; 对于一棵二叉搜索树T，其关键字各不相同，如果T中一个节点$x$的右子树为空，且$x$有一个后继$y$，那么$y$一定是$x$的最底层祖先，并且其左孩子也是$x$的祖先。（每个结点都是其自身的祖先）<br><br>#### 证明<br><br>对于给定结点$x$，若其后继$y$存在，则$y &gt; x$。<br><br>1. 考虑结点$x$，对于$x$的左子树，显然其中任意结点值都小于$x$，所以$y$必定不在其左子树中。<br>2. $x$的右子树，其中任意结点值都大于$x$,但是根据题设，其右子树为空。<br><br>所以，$y$必定为$x$的祖先或其祖先的右子树。<br><br>又因为$y$是其中大于$x$且最小的一个，则$y$不可能是其祖先的右子树，那么我们可以将范围缩小至$y$必定为$x$的某一祖先，又根据$y&gt;x$，则$x$必定在$y$的左子树中，即$y$的左孩子也是$x$的祖先（$x$也是$x$的祖先）<br><br>对于所有满足条件的，假设有$p_0,p_1 \dots p_n$共$n+1$个，且$p_0 &lt; p_1 &lt; p_2 &lt; \dots &lt; p_n$。显然，$x$的前驱结点$y$必定是其中的最小一个，即$y=p_0$。又因为$y$是$x$的祖先，则$y$必然是$x$的最底层祖先。<br><br>#### 结论<br><br>这个定理实际的意义是，对于二叉搜索树中的一个节点（$x$），如果其不存在右子树且还有后继（$y$），则$y$是$x$祖先节点中有左子树的最底层祖先。如下图中13的后继是15。<br><br><div align="center"><img width="70%" src="//isjinhao.github.io/2019/01-Java基础/后继图示.jpg"></div><br>### 二叉查找树的前驱<br><br>前驱的代码和后继对应。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">TREE-PREDECESSOR(x)</span><br><span class="line"><span class="keyword">if</span> x.left != <span class="keyword">null</span></span><br><span class="line">	<span class="keyword">return</span> TREE-MAXNUM(x.left);</span><br><span class="line">y = x.p</span><br><span class="line"><span class="keyword">while</span> y != <span class="keyword">null</span> and x == y.left</span><br><span class="line">	x = y</span><br><span class="line">	y = y.p</span><br><span class="line"><span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><br><br><code>3-7</code>行代码的意思是，对于二叉搜索树中的一个节点（$x$），如果其不存在左子树且还有前驱（$y$），则$y$是$x$祖先节点中有右子树的最底层祖先。如图中17的前驱是15。<br><br><br><br>### 二叉查找树的删除<br><br>讨论删除之前需要证明一个定理：<br><br>&gt; 如果一个二叉搜索树中的一个节点有两个孩子，那么它的后继没有左孩子，它的前驱没有右孩子。<br><br>#### 证明<br><br>如果一棵二叉搜索树中的一个结点有两个孩子，那么它的后继为它的右子树中的最小值，所以它的后继没有左孩子，它的前驱为它的左子树中的最大值，所以它的前驱没有右孩子。<br><br><br><br>删除时有三种情况：<br><br>1. 如果被删除节点（$z$）没有孩子节点，直接删除，修改父节点相应指针指向空。<br>2. 如果$z$只有一个孩子，把孩子提到树中$z$所在的位置，并修改$z$的父节点，用$z$的孩子来替换。<br>3. 如果$z$有两个孩子，那么找$z$的后继$y$（一定在$z$的右子树中）。<br>1. 如果$y$是$z$的右孩子，用$y$替换$z$，同时留下$y$的右孩子。<br>2. 如果$y$不是$z$的右孩子，有之上定理可知，$y$是没有左孩子的，此时用$y$的右孩子替换$y$，用$y$替换$z$，不留下$y$的右孩子。<br><br>#### TRANSPLANT<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TRANSPLANT(T, u, v)</span></span><br><span class="line"><span class="keyword">if</span> u.p == T.nil</span><br><span class="line">	T.root = v</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> u == u.p.left</span><br><span class="line">	u.p.left = v</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	u.p.right = v</span><br><span class="line"><span class="keyword">if</span> v != T.nil</span><br><span class="line">	v.p = u.p</span><br></pre></td></tr></table></figure><br><br><code>TRANSPLANT</code>的功能是在树$T$中用一棵以$v$为根的子树来替换一棵以$u$为根的子树。<br><br>- <code>2-3</code>行：当$u$是树根的时候，直接让$T$的根指向$v$。<br>- <code>4-5</code>行：当$u$是一个左孩子的时候，将$v$放在$u$的左孩子的位置。<br>- <code>6</code>行：当$u$是一个右孩子的时候，将$v$放在$u$的右孩子的位置。<br>- <code>7-8</code>行：更新$v$的父节点。<br><br>#### TREE-DELETE<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">TREE-DELETE(T, z)</span><br><span class="line"><span class="keyword">if</span> z.left == T.nil</span><br><span class="line">	TRANSPLANT(T, z, z.right)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z.right == T.nil</span><br><span class="line">	TRANSPLANT(T, z, z.left)</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">    y = TREE-MINIMUM(z.right)</span><br><span class="line">	<span class="keyword">if</span> y.p != z</span><br><span class="line">		TRANSPLANT(T, y, y.right)</span><br><span class="line">        y.right = z.right</span><br><span class="line">        y.right.p = y</span><br><span class="line">    TRANSPLANT(T, z, y)</span><br><span class="line">    y.left = z.left</span><br><span class="line">    y.left.p = y</span><br></pre></td></tr></table></figure><br><br>1. <code>2-5</code>行：如果$z$没有左孩子，那么用其右孩子替换$z$。如果$z$没有右孩子，那么用其左孩子替换$z$。<br>2. <code>12-14</code>行：如果$y$是$z$的右孩子，用$y$替换$z$，同时留下$z$的左孩子。<br>3. <code>7-11</code>行：如果如果$z$有两个孩子，且$y$不是$z$的右孩子，用$y$的右孩子替换$y$，用$y$替换$z$。<br><br><div align="center"><img width="100%" src="//isjinhao.github.io/2019/01-Java基础/删除图示.jpg"></div><br>### 红黑树的删除<br><br>红黑树的删除和二叉查找树的删除有类似的结构。<br><br>#### RB-TRANSPLANT<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RB-TRANSPLANT(T, u, v)</span></span><br><span class="line"><span class="keyword">if</span> u.p == T.nil</span><br><span class="line">	T.root = v</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> u == u.p.left</span><br><span class="line">	u.p.left = v</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	u.p.right = v</span><br><span class="line">v.p = u.p</span><br></pre></td></tr></table></figure><br><br>过程RB-TRANSPLANT与TRANSPLANT有一点不同，即第8行无条件赋值，因为红黑树中的哨兵不是空。<br><br>#### RB-DELETE<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RB-DELETE(T, z)</span></span><br><span class="line">y = z</span><br><span class="line">y-original-color = y.color			<span class="comment">// 删除的额结点的颜色</span></span><br><span class="line"><span class="keyword">if</span> z.left == T.nil					<span class="comment">// 左子树为空，右子树直接上去</span></span><br><span class="line">	x = z.right						<span class="comment">// x指向被删除结点的右孩子</span></span><br><span class="line">	RB-TRANSPLANT(T, z, z.right)</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> z.right == T.nil			<span class="comment">// 右子树为空，右子树直接上去</span></span><br><span class="line">	x = z.left</span><br><span class="line">	RB-TRANSPLANT(T, z, z.left)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">	y = TREE-MINIMUM(z.right)		<span class="comment">// 右子树中最小的</span></span><br><span class="line">	y-original-color = y.color		<span class="comment">// 删除的节点的颜色</span></span><br><span class="line">	x = y.right</span><br><span class="line">	<span class="keyword">if</span> y.p == z</span><br><span class="line">		x.p = y</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		RB-TRANSPLANT(T, y, y.right)			<span class="comment">// 和二叉搜索树删除时第2、3点一致</span></span><br><span class="line">		y.right = z.right</span><br><span class="line">		y.right.p = y</span><br><span class="line">	RB-TRANSPLANT(T, z, y)</span><br><span class="line">	y.left = z.left</span><br><span class="line">	y.left.p = y</span><br><span class="line">	y.color = z.color</span><br><span class="line"><span class="keyword">if</span> y-original-color == BLACK			<span class="comment">//当删除的是黑色时需要调整，红色不需要</span></span><br><span class="line">	RB-DELETE-FIXUP(T, x)</span><br></pre></td></tr></table></figure><br><br>我们从被删结点后来顶替它的那个结点开始调整，并认为它有额外的一重黑色。这里额外一重黑色是什么意思呢，我们不是把红黑树的结点加上除红与黑的另一种颜色，这里只是一种假设，我们认为我们当前指向它，因此空有额外一种黑色，可以认为它的黑色是从它的父结点被删除后继承给它的，它现在可以容纳两种颜色，如果它原来是红色，那么现在是红+黑，如果原来是黑色，那么它现在的颜色是黑+黑。有了这重额外的黑色，原红黑树性质5就能保持不变。现在只要恢复其它性质就可以了，做法还是尽量向根移动和穷举所有可能性。<br><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RB-DELETE-FIXUP(T, x)</span></span><br><span class="line"><span class="keyword">while</span> x != T.root and x.color == BLACK</span><br><span class="line">	<span class="keyword">if</span> x == x.p.left</span><br><span class="line">		w = x.p.right</span><br><span class="line">		<span class="keyword">if</span> w.color == RED</span><br><span class="line">			w.color = BLACK</span><br><span class="line">			x.p.color = RED</span><br><span class="line">			LEFT-ROTATE(T, x.p)</span><br><span class="line">            w = x.p.right</span><br><span class="line">        <span class="keyword">if</span> w.left.color == BLACK and w.right.color == BLACK</span><br><span class="line">        	w.color = RED</span><br><span class="line">        	x = x.p</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> w.right.color == BLACK</span><br><span class="line">        	w.left.color = BLACK</span><br><span class="line">        	w.color= RED</span><br><span class="line">        	RIGHT-RATATE(T, w)</span><br><span class="line">            w = x.p.right</span><br><span class="line">        w.color = x.p.color</span><br><span class="line">        x.p.color = BLACK</span><br><span class="line">        w.right.color = BLACK</span><br><span class="line">        LEFT-ROTATE(T, x.p)</span><br><span class="line">        x = T.root</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		same as then clause with <span class="string">"right"</span> and <span class="string">"left"</span> exchanged</span><br><span class="line">x.color = BLACK</span><br></pre></td></tr></table></figure><br><br>如果y的颜色是RED，则y不可能为红黑树的根，所以不管x的颜色是什么，都不会影响到红黑树的性质。所以只考虑y的颜色为BLACK的情况。<br><br>在y的颜色是BLACK的情况下，如果x的颜色为RED的话，删除y之后，结点y所在的分支的黑高就会减1，所以，只需要将x的颜色变为BLACK，则该分支的黑高会加1，则会保持住红黑树的颜色性质。所以最终要考虑的情况就是，y颜色为BLACK，x的颜色为BLACK的情况。因把y删除后，x顶替y的位置，y所在分支的黑高减1，所以，假设x节点的颜色为BLACK-BLACK，简称BB，也就是原来y的BLACK增加到x上了，这样就保证了该分支的黑高不变，接下来要做的就是调整x所在的分支，使红黑树的性质保持不变，又分为下面的几种情况（只考虑x为左孩子的情况，右孩子的情况是对称的）<br><br><strong>删除修复情况1：当前结点是黑+黑且兄弟结点为红色(此时父结点和兄弟结点的子结点分为黑)。</strong><br><br>解法：把父结点染成红色，把兄弟结点染成黑色，之后重新进入算法。此变换后原红黑树性质5不变，而把问题转化为兄弟结点为黑色的情况(注：变化前，原本就未违反性质5，只是为了<strong>把问题转化为兄弟结点为黑色的情况</strong>)。 即第5行至第9行。<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/10.jpg"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/11.jpg"></div><br><strong>删除修复情况2：当前结点是黑加黑且兄弟是黑色且兄弟结点的两个子结点全为黑色。</strong><br><br>解法：把当前结点和兄弟结点中抽取一重黑色追加到父结点上，把父结点当成新的当前结点，重新进入算法。（此变换后性质5不变），即第10-12行代码操作。<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/12.jpg"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/13.jpg"></div><br><strong>删除修复情况3：当前结点颜色是黑+黑，兄弟结点是黑色，兄弟的左子是红色，右子是黑色。</strong><br><br>解法：把兄弟结点染红，兄弟左子结点染黑，之后再在兄弟结点为支点解右旋，之后重新进入算法。此是把当前的情况转化为情况4，而性质5得以保持，即第13-17行代码：<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/14.jpg"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/15.jpg"></div><br><strong>删除修复情况4：当前结点颜色是黑-黑色，它的兄弟结点是黑色，但是兄弟结点的右子是红色，兄弟结点左子的颜色任意。</strong><br><br>解法：把兄弟结点染成当前结点父结点的颜色，把当前结点父结点染成黑色，兄弟结点右子染成黑色，之后以当前结点的父结点为支点进行左旋，此时算法结束，红黑树所有性质调整正确，即第18-22行代码，如下所示：<br><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/16.jpg"></div><br><div align="center"><img width="50%" src="//isjinhao.github.io/2019/01-Java基础/17.jpg"></div><h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h2 id="Collections和Arrays常见方法"><a href="#Collections和Arrays常见方法" class="headerlink" title="Collections和Arrays常见方法"></a>Collections和Arrays常见方法</h2><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><h4 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span>	<span class="comment">//反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span>	<span class="comment">//随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span>	<span class="comment">//按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span>	<span class="comment">//定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i , <span class="keyword">int</span> j)</span>	<span class="comment">//交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span><span class="comment">//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。</span></span></span><br></pre></td></tr></table></figure><h4 id="查找-替换操作"><a href="#查找-替换操作" class="headerlink" title="查找,替换操作"></a>查找,替换操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span><span class="comment">//对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">//根据元素的自然顺序，返回最大的元素。</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(Collection coll)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span><span class="comment">//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">(Collection coll, Comparator c)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span><span class="comment">//用指定的元素代替指定list中的所有元素。</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span><span class="comment">//统计元素出现次数</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span><span class="comment">//统计target在list中第一次出现的索引，找不到则返回-1</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastIndexOfSubList</span><span class="params">(List source, list target)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span> <span class="comment">//用新元素替换旧元素</span></span></span><br></pre></td></tr></table></figure><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><h4 id="排序-sort"><a href="#排序-sort" class="headerlink" title="排序 : sort()"></a>排序 : <code>sort()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// sort(int[] a)方法按照数字顺序排列指定的数组。</span></span><br><span class="line">Arrays.sort(a);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(a):"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : a) &#123;</span><br><span class="line">	System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// sort(int[] a,int fromIndex,int toIndex)按升序排列数组的指定范围</span></span><br><span class="line"><span class="keyword">int</span> b[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line">Arrays.sort(b, <span class="number">2</span>, <span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(b, 2, 6):"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : b) &#123;</span><br><span class="line">	System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> c[] = &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">9</span> &#125;;</span><br><span class="line"><span class="comment">// parallelSort(int[] a) 按照数字顺序排列指定的数组(并行的)。同sort方法一样也有按范围的排序</span></span><br><span class="line">Arrays.parallelSort(c);</span><br><span class="line">System.out.println(<span class="string">"Arrays.parallelSort(c)："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : c) &#123;</span><br><span class="line">	System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// parallelSort给字符数组排序，sort也可以</span></span><br><span class="line"><span class="keyword">char</span> d[] = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line">Arrays.parallelSort(d);</span><br><span class="line">System.out.println(<span class="string">"Arrays.parallelSort(d)："</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">char</span> d2 : d) &#123;</span><br><span class="line">	System.out.print(d2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找-binarySearch"><a href="#查找-binarySearch" class="headerlink" title="查找 : binarySearch()"></a>查找 : <code>binarySearch()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] e = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="comment">// 排序后再进行二分查找，否则找不到</span></span><br><span class="line">Arrays.sort(e);</span><br><span class="line">System.out.println(<span class="string">"Arrays.sort(e)"</span> + Arrays.toString(e));</span><br><span class="line">System.out.println(<span class="string">"Arrays.binarySearch(e, 'c')："</span>);</span><br><span class="line"><span class="keyword">int</span> s = Arrays.binarySearch(e, <span class="string">'c'</span>);</span><br><span class="line">System.out.println(<span class="string">"字符c在数组的位置："</span> + s);</span><br></pre></td></tr></table></figure><h4 id="比较-equals"><a href="#比较-equals" class="headerlink" title="比较: equals()"></a>比较: <code>equals()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] e = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="keyword">char</span>[] f = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 元素数量相同，并且相同位置的元素相同。 另外，如果两个数组引用都是null，则它们被认为是相等的 。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">// 输出true</span></span><br><span class="line">System.out.println(<span class="string">"Arrays.equals(e, f):"</span> + Arrays.equals(e, f));</span><br></pre></td></tr></table></figure><h4 id="填充-fill"><a href="#填充-fill" class="headerlink" title="填充 : fill()"></a>填充 : <code>fill()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] g = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="comment">// 数组中所有元素重新分配值</span></span><br><span class="line">Arrays.fill(g, <span class="number">3</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.fill(g, 3)："</span>);</span><br><span class="line"><span class="comment">// 输出结果：333333333</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : g) &#123;</span><br><span class="line">	System.out.print(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span>[] h = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, &#125;;</span><br><span class="line"><span class="comment">// 数组中指定范围元素重新分配值</span></span><br><span class="line">Arrays.fill(h, <span class="number">0</span>, <span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.fill(h, 0, 2, 9);："</span>);</span><br><span class="line"><span class="comment">// 输出结果：993333666</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i : h) &#123;</span><br><span class="line">	System.out.print(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转列表-asList"><a href="#转列表-asList" class="headerlink" title="转列表 asList()"></a>转列表 <code>asList()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回由指定数组支持的固定大小的列表。</span></span><br><span class="line"><span class="comment">* （将返回的列表更改为“写入数组”。）该方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()相结合 。</span></span><br><span class="line"><span class="comment">* 返回的列表是可序列化的，并实现RandomAccess 。</span></span><br><span class="line"><span class="comment">* 此方法还提供了一种方便的方式来创建一个初始化为包含几个元素的固定大小的列表如下：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Moe"</span>, <span class="string">"Curly"</span>);</span><br><span class="line">System.out.println(stooges);</span><br></pre></td></tr></table></figure><h4 id="转字符串-toString"><a href="#转字符串-toString" class="headerlink" title="转字符串 toString()"></a>转字符串 <code>toString()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 返回指定数组的内容的字符串表示形式。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">char</span>[] k = &#123; <span class="string">'a'</span>, <span class="string">'f'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'A'</span>, <span class="string">'C'</span>, <span class="string">'B'</span> &#125;;</span><br><span class="line">System.out.println(Arrays.toString(k));<span class="comment">// [a, f, b, c, e, A, C, B]</span></span><br></pre></td></tr></table></figure><h4 id="复制-copyOf"><a href="#复制-copyOf" class="headerlink" title="复制 copyOf()"></a>复制 <code>copyOf()</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// copyOf 方法实现数组复制,h为数组，6为复制的长度</span></span><br><span class="line"><span class="keyword">int</span>[] h = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, &#125;;</span><br><span class="line"><span class="keyword">int</span> i[] = Arrays.copyOf(h, <span class="number">6</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.copyOf(h, 6);："</span>);</span><br><span class="line"><span class="comment">// 输出结果：123333</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j : i) &#123;</span><br><span class="line">	System.out.print(j);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br><span class="line"><span class="comment">// copyOfRange将指定数组的指定范围复制到新数组中</span></span><br><span class="line"><span class="keyword">int</span> j[] = Arrays.copyOfRange(h, <span class="number">6</span>, <span class="number">11</span>);</span><br><span class="line">System.out.println(<span class="string">"Arrays.copyOfRange(h, 6, 11)："</span>);</span><br><span class="line"><span class="comment">// 输出结果66600(h数组只有9个元素这里是从索引6到索引11复制所以不足的就为0)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j2 : j) &#123;</span><br><span class="line">	System.out.print(j2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 换行</span></span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>把变量从内存中变成可存储或传输的过程称之为序列化，把字节序列恢复为Java对象的过程称为对象的反序列化。对象的序列化主要有两种用途：</p><ol><li>把对象的字节序列永久的保存到硬盘上，通常存放在一个文件中。</li><li>在网络上传送对象的字节序列。</li></ol><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/01-Java基础/序列化.png"></div><p></p><h3 id="默认序列化"><a href="#默认序列化" class="headerlink" title="默认序列化"></a>默认序列化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Server</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		Path path = Paths.get(<span class="string">"test"</span>);</span><br><span class="line">		Person temp = <span class="keyword">new</span> Person(<span class="string">"陈钰琪"</span>, <span class="number">19</span>, <span class="string">"411x2x19xx1x2x6x1x"</span>, <span class="number">20000</span>d);</span><br><span class="line">		</span><br><span class="line">		ObjectOutputStream out = </span><br><span class="line">			<span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(path.toFile()));</span><br><span class="line">		out.writeObject(temp);</span><br><span class="line">		</span><br><span class="line">		ObjectInputStream in = </span><br><span class="line">			<span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(path.toFile()));</span><br><span class="line">		Person readObject = (Person)in.readObject();</span><br><span class="line">		System.out.println(readObject);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">485348963313276072L</span>;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line">	<span class="keyword">private</span> Integer age;</span><br><span class="line">	<span class="keyword">private</span> String id;</span><br><span class="line">	<span class="keyword">private</span> Double money;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age, String id, Double money)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">this</span>.age = age;</span><br><span class="line">		<span class="keyword">this</span>.id = id;</span><br><span class="line">		<span class="keyword">this</span>.money = money;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// getter和setter</span></span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Person [name="</span> + name + <span class="string">", </span></span><br><span class="line"><span class="string">			age="</span> + age + <span class="string">", id="</span> + id + <span class="string">", money="</span> + money + <span class="string">"]"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="版本号"><a href="#版本号" class="headerlink" title="版本号"></a>版本号</h3><p>版本号是为了控制对象的版本而存在的，版本号一致才可认为可以进行对应的序列化和反序列化。比如我们使用上面的代码把一个Person写入temp文件了，然后修改<code>serialVersionUID = 485348963313276072L;</code>，会发现爆出<code>java.io.InvalidClassException</code>。</p><h3 id="单例的处理"><a href="#单例的处理" class="headerlink" title="单例的处理"></a>单例的处理</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MySingleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123; </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">MySingleton</span><span class="params">()</span> </span>&#123; &#125; </span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> MySingleton INSTANCE = <span class="keyword">new</span> MySingleton(); </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE; &#125; </span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException </span>&#123; </span><br><span class="line">	    <span class="comment">// instead of the object we're on, return the class variable INSTANCE </span></span><br><span class="line">		<span class="keyword">return</span> INSTANCE; </span><br><span class="line">  	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反序列化”组装”一个新对象时，就会自动调用这个readResolve方法来返回我们指定好的对象了，单例规则也就得到了保证。</p><p>​</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="ThreadLocal使用"><a href="#ThreadLocal使用" class="headerlink" title="ThreadLocal使用"></a>ThreadLocal使用</h3><p>ThreadLocal是一个线程局部变量，我们都知道全局变量和局部变量的区别，拿Java举例就是定义在类中的是全局的变量，各个方法中都能访问得到（静态方法不能获得实例属性），而局部变量定义在方法中，只能在方法内访问。那线程局部变量（ThreadLocal）就是每个线程都会有一个局部变量，独立于变量的初始化副本，而各个副本是通过线程唯一标识相关联的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> UniqueThreadIdGenerator t;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">TaskThread</span><span class="params">(String threadName, UniqueThreadIdGenerator t)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.setName(threadName);</span><br><span class="line">		<span class="keyword">this</span>.t = t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="keyword">int</span> value = t.getUniqueId();</span><br><span class="line">				System.out.println(<span class="string">"thread[ "</span> + Thread.currentThread().getName() + </span><br><span class="line">                	<span class="string">" ] --&gt; uniqueId[ "</span> + value + <span class="string">" ]"</span>);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		UniqueThreadIdGenerator uniqueThreadId = <span class="keyword">new</span> UniqueThreadIdGenerator();</span><br><span class="line">		<span class="comment">// 为每个线程生成一个唯一的局部标识</span></span><br><span class="line">		TaskThread t1 = <span class="keyword">new</span> TaskThread(<span class="string">"custom-thread-1"</span>, uniqueThreadId);</span><br><span class="line">		TaskThread t2 = <span class="keyword">new</span> TaskThread(<span class="string">"custom-thread-2"</span>, uniqueThreadId);</span><br><span class="line">		TaskThread t3 = <span class="keyword">new</span> TaskThread(<span class="string">"custom-thread-3"</span>, uniqueThreadId);</span><br><span class="line">		t1.start();</span><br><span class="line">		t2.start();</span><br><span class="line">		t3.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniqueThreadIdGenerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 线程局部整型变量</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Integer&gt; uniqueNum = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;() &#123;</span><br><span class="line">		<span class="meta">@Override</span></span><br><span class="line">		<span class="function"><span class="keyword">protected</span> Integer <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 变量值</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUniqueId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		uniqueNum.set(uniqueNum.get() + <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">return</span> uniqueNum.get();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// thread[ custom-thread-2 ] --&gt; uniqueId[ 1 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-1 ] --&gt; uniqueId[ 1 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-3 ] --&gt; uniqueId[ 1 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-1 ] --&gt; uniqueId[ 2 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-2 ] --&gt; uniqueId[ 2 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-1 ] --&gt; uniqueId[ 3 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-3 ] --&gt; uniqueId[ 2 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-1 ] --&gt; uniqueId[ 4 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-2 ] --&gt; uniqueId[ 3 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-3 ] --&gt; uniqueId[ 3 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-2 ] --&gt; uniqueId[ 4 ]</span></span><br><span class="line"><span class="comment">// thread[ custom-thread-3 ] --&gt; uniqueId[ 4 ]</span></span><br><span class="line"><span class="comment">// 每个线程之间的uniqueId是互不干扰的</span></span><br></pre></td></tr></table></figure><h3 id="ThreadLocal源码分析"><a href="#ThreadLocal源码分析" class="headerlink" title="ThreadLocal源码分析"></a>ThreadLocal源码分析</h3><p>每个线程内部有一个ThreadLocalMap，<code>get()</code>的时候就是获得当前线程的<code>ThreadLocalMap</code>，并且将当前<code>ThreadLocal</code>对象传入<code>map.getEntry(this);</code></p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/01-Java基础/2019-07-13_160318.jpg"></div><p></p><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ThreadLocal.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 拿到每个线程内部的ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// this指的是这个ThreadLocal对象，每个ThreadLocalMap可以有多个ThreadLocal对象</span></span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T value = initialValue();</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认初始化为null</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ThreadLocalMap.java</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    table = <span class="keyword">new</span> Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    table[i] = <span class="keyword">new</span> Entry(firstKey, firstValue);</span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="set"><a href="#set" class="headerlink" title="set()"></a>set()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从当前线程的ThreadLocalMap中删除当前的ThreadLocal</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadLocalMap"><a href="#ThreadLocalMap" class="headerlink" title="ThreadLocalMap"></a>ThreadLocalMap</h3><p>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现。</p><p></p><div align="center"><img width="80%" src="//isjinhao.github.io/2019/01-Java基础/2019-07-13_160809.jpg"></div><br>在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象，这点被Entry的构造方法已经限定死了。<p></p><p>Entry继承自WeakReference（弱引用，生命周期只能存活到下次GC前），但只有Key是弱引用类型的，Value并非弱引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Entry.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">    Object value;</span><br><span class="line"></span><br><span class="line">    Entry(ThreadLocal k, Object v) &#123;</span><br><span class="line">        <span class="keyword">super</span>(k);</span><br><span class="line">        value = v;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Hash冲突怎么解决"><a href="#Hash冲突怎么解决" class="headerlink" title="Hash冲突怎么解决"></a>Hash冲突怎么解决</h4><p>和HashMap的最大的不同在于，ThreadLocalMap结构非常简单，没有next引用，也就是说ThreadLocalMap中解决Hash冲突的方式并非链表的方式，而是采用线性探测的方式，所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。</p><p>ThreadLocalMap解决Hash冲突的方式就是简单的步长加1或减1，寻找下一个相邻的位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Increment i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Decrement i modulo len.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然ThreadLocalMap采用线性探测的方式解决Hash冲突的效率很低，如果有大量不同的ThreadLocal对象放入map中时发送冲突，或者发生二次冲突，则效率很低。<strong>所以这里引出的良好建议是：每个线程只存一个变量，需要多个变量 这个时候需要把这些对象封装成变量对象</strong>。</p><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><p>ThreadLocal在ThreadLocalMap中是以一个弱引用身份被Entry中的Key引用的，因此如果ThreadLocal没有外部强引用来引用它，那么ThreadLocal会在下次JVM垃圾收集时被回收。这个时候就会出现Entry中Key已经被回收，出现一个null Key的情况，外部读取ThreadLocalMap中的元素是无法通过null Key来找到Value的。因此如果当前线程的生命周期很长，一直存在，那么其内部的ThreadLocalMap对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：Thread –&gt; ThreadLocalMap–&gt;Entry–&gt;Value，这条强引用链会导致Entry不会回收，Value也不会回收，但Entry中的Key却已经被回收的情况，造成内存泄漏。</p><p>但是JVM团队已经考虑到这样的情况，并做了一些措施来保证ThreadLocal尽量不会内存泄漏：在ThreadLocal的get()、set()、remove()方法调用的时候会清除掉线程ThreadLocalMap中所有Entry中Key为null的Value，并将整个Entry设置为null，利于下次内存回收。</p><p>ThreadLocal的get()方法在调用map.getEntry(this)时，内部会判断key是否为null</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntry</span><span class="params">(ThreadLocal key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">    Entry e = table[i];</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">        <span class="keyword">return</span> e;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal key, <span class="keyword">int</span> i, Entry e)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == key)</span><br><span class="line">            <span class="keyword">return</span> e;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">            expungeStaleEntry(i);		<span class="comment">// 清除空结点的方法</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            i = nextIndex(i, len);</span><br><span class="line">        e = tab[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">    Entry[] tab = table;</span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expunge entry at staleSlot（意思是，删除value，设置为null便于下次回收）</span></span><br><span class="line">    tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">    tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Rehash until we encounter null</span></span><br><span class="line">    <span class="comment">// 将当前Entry删除后，会继续循环往下检查是否有key为null的节点，如果有则一并删除，防止内存泄漏。</span></span><br><span class="line">    Entry e;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">         (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">         i = nextIndex(i, len)) &#123;</span><br><span class="line">        ThreadLocal k = e.get();</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            e.value = <span class="keyword">null</span>;</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">            size--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Unlike Knuth 6.4 Algorithm R, we must scan until</span></span><br><span class="line">                <span class="comment">// null because multiple entries could have been stale.</span></span><br><span class="line">                <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                    h = nextIndex(h, len);</span><br><span class="line">                tab[h] = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这样也并不能保证ThreadLocal不会发生内存泄漏，例如：</p><ul><li>使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏。</li><li>分配使用了ThreadLocal又不再调用get()、set()、remove()方法，那么就会导致内存泄漏</li></ul><h4 id="为什么使用弱引用？"><a href="#为什么使用弱引用？" class="headerlink" title="为什么使用弱引用？"></a>为什么使用弱引用？</h4><p>从表面上看，发生内存泄漏，是因为Key使用了弱引用类型。但其实是因为整个Entry的key为null后，没有主动清除value导致。为什么使用弱引用而不是强引用？</p><p>官方文档的说法：</p><blockquote><p>To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.<br>为了处理非常大和生命周期非常长的线程，哈希表使用弱引用作为 key。</p></blockquote><p>下面我们分两种情况讨论：</p><ul><li><p>key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。</p></li><li><p>key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set，get，remove的时候会被清除。</p></li></ul><p>比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set，get，remove的时候会被清除。</p><p>因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key的value就会导致内存泄漏，而不是因为弱引用。</p><p>所以：<strong>每次使用完ThreadLocal，都调用它的remove()方法，清除数据。</strong>尤其是在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。</p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-如果您有什么建议，推荐使用右下角的DaoVoice与我联系-</div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读！-------------</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div></div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/weichatpay.png" alt="ISJINHAO 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.jpg" alt="ISJINHAO 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/应届求职复习/" rel="tag"># 应届求职复习</a> <a href="/tags/面试/" rel="tag"># 面试</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/Java邮件发送/" rel="next" title="Java邮件发送"><i class="fa fa-chevron-left"></i> Java邮件发送</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/02-MySQL/" rel="prev" title="02-MySQL">02-MySQL <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80MjQ4NC8xOTAzMQ=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="ISJINHAO"><p class="site-author-name" itemprop="name">ISJINHAO</p><p class="site-description motion-element" itemprop="description">Living & Working</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">117</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">30</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">57</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/isjinhao" title="GitHub &rarr; https://github.com/isjinhao" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_38206090" title="CSDN &rarr; https://blog.csdn.net/qq_38206090" rel="noopener" target="_blank"><i class="fa fa-fw fa-heartbeat"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:isjinhao@163.com" title="E-Mail &rarr; mailto:isjinhao@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://http://59.110.143.226/qz/0.html" title="http://http://59.110.143.226/qz/0.html" rel="noopener" target="_blank">求职（Java后台开发）</a></li><li class="links-of-blogroll-item"><a href="http://http://59.110.143.226/Sharing-Your-Story" title="http://http://59.110.143.226/Sharing-Your-Story" rel="noopener" target="_blank">博客涉及到的软件</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-amp-JDK-amp-JRE"><span class="nav-number">1.</span> <span class="nav-text">JVM&amp;JDK&amp;JRE</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#JVM"><span class="nav-number">1.1.</span> <span class="nav-text">JVM</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TreeMap"><span class="nav-number">2.</span> <span class="nav-text">TreeMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HashMap"><span class="nav-number">3.</span> <span class="nav-text">HashMap</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collections和Arrays常见方法"><span class="nav-number">4.</span> <span class="nav-text">Collections和Arrays常见方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collections"><span class="nav-number">4.1.</span> <span class="nav-text">Collections</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#排序操作"><span class="nav-number">4.1.1.</span> <span class="nav-text">排序操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查找-替换操作"><span class="nav-number">4.1.2.</span> <span class="nav-text">查找,替换操作</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Arrays"><span class="nav-number">4.2.</span> <span class="nav-text">Arrays</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#排序-sort"><span class="nav-number">4.2.1.</span> <span class="nav-text">排序 : sort()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#查找-binarySearch"><span class="nav-number">4.2.2.</span> <span class="nav-text">查找 : binarySearch()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#比较-equals"><span class="nav-number">4.2.3.</span> <span class="nav-text">比较: equals()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#填充-fill"><span class="nav-number">4.2.4.</span> <span class="nav-text">填充 : fill()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转列表-asList"><span class="nav-number">4.2.5.</span> <span class="nav-text">转列表 asList()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#转字符串-toString"><span class="nav-number">4.2.6.</span> <span class="nav-text">转字符串 toString()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#复制-copyOf"><span class="nav-number">4.2.7.</span> <span class="nav-text">复制 copyOf()</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#序列化"><span class="nav-number">5.</span> <span class="nav-text">序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#默认序列化"><span class="nav-number">5.1.</span> <span class="nav-text">默认序列化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#版本号"><span class="nav-number">5.2.</span> <span class="nav-text">版本号</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单例的处理"><span class="nav-number">5.3.</span> <span class="nav-text">单例的处理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ThreadLocal"><span class="nav-number">6.</span> <span class="nav-text">ThreadLocal</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal使用"><span class="nav-number">6.1.</span> <span class="nav-text">ThreadLocal使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocal源码分析"><span class="nav-number">6.2.</span> <span class="nav-text">ThreadLocal源码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#get"><span class="nav-number">6.2.1.</span> <span class="nav-text">get()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#set"><span class="nav-number">6.2.2.</span> <span class="nav-text">set()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#remove"><span class="nav-number">6.2.3.</span> <span class="nav-text">remove()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ThreadLocalMap"><span class="nav-number">6.3.</span> <span class="nav-text">ThreadLocalMap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Hash冲突怎么解决"><span class="nav-number">6.3.1.</span> <span class="nav-text">Hash冲突怎么解决</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存泄漏"><span class="nav-number">6.4.</span> <span class="nav-text">内存泄漏</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#为什么使用弱引用？"><span class="nav-number">6.4.1.</span> <span class="nav-text">为什么使用弱引用？</span></a></li></ol></li></ol></li></ol></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">ISJINHAO</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">831k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">12:36</span></div><div class="powered-by"><i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv"> 本站访客数：<span id="busuanzi_value_site_uv"></span></span></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">| 博客全站共310.4k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/src/utils.js?v=6.7.0"></script><script src="/js/src/motion.js?v=6.7.0"></script><script src="/js/src/schemes/muse.js?v=6.7.0"></script><script src="/js/src/scrollspy.js?v=6.7.0"></script><script src="/js/src/post-details.js?v=6.7.0"></script><script src="/js/src/bootstrap.js?v=6.7.0"></script><script>window.livereOptions={refer:"2019/01-Java基础/"},function(e,t){var n,r=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,r.parentNode.insertBefore(n,r))}(document,"script")</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: "AMS"
      }
    }
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });</script><script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><style>.MathJax_Display{overflow:auto hidden}</style></body></html><!-- rebuild by neat -->