<!-- build time:Wed Aug 28 2019 15:53:02 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>.pace .pace-progress{background:#1E92FB;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1E92FB,0 0 5px #1E92FB}.pace .pace-activity{border-top-color:#1E92FB;border-left-color:#1E92FB}</style><meta name="theme-color" content="#222"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=6.7.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon16x16.ico?v=6.7.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32x32.ico?v=6.7.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16x16.ico?v=6.7.0"><link rel="mask-icon" href="/images/favicon16x16.ico?v=6.7.0" color="#222"><link rel="manifest" href="/images/favicon16x16.ico"><meta name="msapplication-config" content="/images/favicon16x16.ico"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"6.7.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"28dbf854"}),daovoice("update")</script><meta name="description" content="操作系统的定义操作系统（Operating System，简称OS）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是管理硬件设备来提高利用率和吞吐量，同时为用户和应用系统提供易于使用的接口。提高利用率：使系统中各设备的空闲时间尽可能短。提高吞吐量：使单位时间内完成的业务更多。提供易于使用的接口：即是方便使用计算机资源。例如没有操作系统，操纵计算机可能需要用户输入二进制代码，有了"><meta name="keywords" content="应届求职复习,面试"><meta property="og:type" content="article"><meta property="og:title" content="04-操作系统和Linux"><meta property="og:url" content="https://isjinhao.github.io/2019/04-操作系统和Linux/index.html"><meta property="og:site_name" content="ISJINHAO"><meta property="og:description" content="操作系统的定义操作系统（Operating System，简称OS）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是管理硬件设备来提高利用率和吞吐量，同时为用户和应用系统提供易于使用的接口。提高利用率：使系统中各设备的空闲时间尽可能短。提高吞吐量：使单位时间内完成的业务更多。提供易于使用的接口：即是方便使用计算机资源。例如没有操作系统，操纵计算机可能需要用户输入二进制代码，有了"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/脱机输入输出.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/单道批处理系统.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/多道批处理.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/单道举例.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/多道举例.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/分时系统.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/模块式os结构.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/前趋图.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/pcb的组织方式.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/五种进程状态.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/引入挂起的进程状态图.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/前趋图例题.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/生产者消费者.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/哲学家进餐.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/读者-写者.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/理发师问题.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/rpc.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/内核级线程.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/运行时系统.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/内核控制线程.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/处理机调度层次.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/批处理系统调度.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/进程调度机制.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/多级队列反馈调度算法.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/多级反馈队列.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/实时调度.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/非抢占式EDF.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/抢占式EDF.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/LLF.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/优先级倒置.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/优先级倒置.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/死锁举例.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/竞争不可抢占资源.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/进程推进顺序非法.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/进程推进顺序非法.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/T0.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/T1.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/T2.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/T3.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/死锁的检测.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/存储器分级.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/静态重定位.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/动态重定位.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/单一连续分配.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/固定分区分配.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/动态分区数据结构.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/分区分配.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/分区回收.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/紧凑.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/分页逻辑地址.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/页表.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/页表项.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/页表基本地址变换.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/具有快表的页表地址变换.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/两级页表.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/两级页表地址变换.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/反置页表.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/分段地址.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/段表.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/分段地址映射.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/分段地址变换.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/段表地址映射.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/段表地址变换.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/页表设计.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/请求分页地址转换机构.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/最佳置换算法.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/先进先出算法.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/LRU.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/寄存器LRU.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/栈LRU.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/工作集.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/段表.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/请求中断处理.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/地址变换机构.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/共享段表.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/IO软件层次.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/IO各模块层次视图.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/IO设备和设备控制器.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/字节多路通道.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/数组选择通道.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/解决瓶颈.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/轮询可编程.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/中断可编程.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/SDT.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/DCT.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/COCT.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/CHCT.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/设备分配算法.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/SPOOLing.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/单缓冲区.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/双缓冲.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/环形缓冲.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/磁盘.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/先来先服务.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/最短寻道.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/扫描算法.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/文件.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/索引文件.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/索引顺序文件.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/文件目录.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/树形文件目录.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/有向无环图.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/利用索引节点.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/利用符号链接.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/访问矩阵.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/连续组织方式.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/隐式链接.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/显示链接.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/索引组织方式.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/多级索引组织方式.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/增量组织方式.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/空闲链表.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/位示图法.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/成组链接法.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/成组链接例.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/成组链接例1.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/成组链接例2.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/成组链接例3.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/第一次回收.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/第二次回收.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/第三四五次回收.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/阿里云服务器.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/根目录.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/根目录格式.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/查看内核版本号.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/uname.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/输入.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/echo.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/date1.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/date2.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/cal1.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/linux用户.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/root.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/user.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/who.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/whoi.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/adduser.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/addmail.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/passwd.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/shadow.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/group.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/gshadow.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/usermodag.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/filesys.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/grep.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/管道.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ls.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ll.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/cp.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/mv.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/mvname.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/文件结构.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/hardlink.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/software.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/用户与权限.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/chmod.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/chmod绝对.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/umask.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/别名.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/crone.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/设置定期任务.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/查看定时任务.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/cronl.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/cronr.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/成组命令.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/testsort.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex11.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex12.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex13.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex14.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex15.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex161.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex162.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex17.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex21.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex22.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex22.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex24.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/vima.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/i1.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/i2.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/I11.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/I22.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/a1.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/a1.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/A11.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/a22.png"><meta property="og:image" content="https://isjinhao.github.io/03-vim/o1.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/o2.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/o11.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/o2.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/r1.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/r2.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/r11.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/r22.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/vim流程图.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/Linux进程管理.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ps.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/psef.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/t1代码.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/t1结果.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/t2代码.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/t2结果.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/t2分析.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/t3代码.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/t3结果.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/t3分析.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/t4.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/t4图.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/最简单shell脚本.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/设置为可执行文件.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/变量.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/算术运算符.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/read.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/readp.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/引号.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/单引号.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/数组.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/选择结构.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/循环结构.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex1.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex2.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex3.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex41.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex42.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex5.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex61.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex62.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex63.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex64.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex65.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/ex66.png"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/1ex.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/2ex.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/3ex.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/4ex.jpg"><meta property="og:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/5ex.jpg"><meta property="og:updated_time" content="2019-08-16T03:37:01.063Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="04-操作系统和Linux"><meta name="twitter:description" content="操作系统的定义操作系统（Operating System，简称OS）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是管理硬件设备来提高利用率和吞吐量，同时为用户和应用系统提供易于使用的接口。提高利用率：使系统中各设备的空闲时间尽可能短。提高吞吐量：使单位时间内完成的业务更多。提供易于使用的接口：即是方便使用计算机资源。例如没有操作系统，操纵计算机可能需要用户输入二进制代码，有了"><meta name="twitter:image" content="https://isjinhao.github.io/2019/04-操作系统和Linux/脱机输入输出.jpg"><link rel="alternate" href="/atom.xml" title="ISJINHAO" type="application/atom+xml"><link rel="canonical" href="https://isjinhao.github.io/2019/04-操作系统和Linux/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>04-操作系统和Linux | ISJINHAO</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">ISJINHAO</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="popup search-popup local-search-popup"><div class="local-search-header clearfix"><span class="search-icon"><i class="fa fa-search"></i> </span><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span><div class="local-search-input-wrapper"><input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input"></div></div><div id="local-search-result"></div></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://isjinhao.github.io/2019/04-操作系统和Linux/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ISJINHAO"><meta itemprop="description" content="Living & Working"><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ISJINHAO"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">04-操作系统和Linux</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-28 21:47:27" itemprop="dateCreated datePublished" datetime="2019-07-28T21:47:27+08:00">2019-07-28</time> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-calendar-check-o"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2019-08-16 11:37:01" itemprop="dateModified" datetime="2019-08-16T11:37:01+08:00">2019-08-16</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/应届求职复习/" itemprop="url" rel="index"><span itemprop="name">应届求职复习</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">70k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">1:03</span></div></div></header><div class="post-body" itemprop="articleBody"><h2 id="操作系统的定义"><a href="#操作系统的定义" class="headerlink" title="操作系统的定义"></a>操作系统的定义</h2><p>操作系统（Operating System，简称OS）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是管理硬件设备来提高利用率和吞吐量，同时为用户和应用系统提供易于使用的接口。</p><ul><li>提高利用率：使系统中各设备的空闲时间尽可能短。</li><li>提高吞吐量：使单位时间内完成的业务更多。</li><li>提供易于使用的接口：即是方便使用计算机资源。例如没有操作系统，操纵计算机可能需要用户输入二进制代码，有了操作系统，用户可以点击图标，操作系统就会将其转换成二进制代码。</li></ul><h3 id="操作系统的目标"><a href="#操作系统的目标" class="headerlink" title="操作系统的目标"></a>操作系统的目标</h3><ul><li>方便性：即对用户和应用程序提供易于使用的接口。</li><li>有效性：提高利用率和吞吐量。</li><li>可扩充性：计算机硬件和体系结构等都在不断发展中，OS需要有好的可扩充性来满足不断发展的需求。</li><li>开放性：为了使计算机的应用环境从单机转换成网络，OS需要满足相应的软硬件标准来实现设备的互联。</li></ul><h3 id="操作系统的作用"><a href="#操作系统的作用" class="headerlink" title="操作系统的作用"></a>操作系统的作用</h3><ul><li>提供易于使用的接口，如Shell、图形界面等。</li><li>管理计算机所有的资源，负责计算机系统全部资源的分配、控制、调度和回收。</li><li>隐蔽硬件特性，如计算2*3，某些机器的实现是使用加法器做2+2+2，而有的机器是乘法器实现2*3。操作系统屏蔽这些细节，用户只需要输入2*3就能完成。</li></ul><h2 id="未配置操作系统的计算机系统"><a href="#未配置操作系统的计算机系统" class="headerlink" title="未配置操作系统的计算机系统"></a>未配置操作系统的计算机系统</h2><ul><li>人工操作：程序员把程序和数据通过穿孔的方式记录在纸带上，再启动机器读入纸带，运行完成并取走计算结果后，才允许下一个用户上机。缺点：<ul><li>用户独占整机：计算机上的资源为上机用户独占。</li><li>设备空闲率高：用户装卡，卸卡等人工操作时，设备资源是空闲的。</li></ul></li><li>脱机输入/输出（Off-Line I/O）：为了解决人机矛盾及CPU、I/O等设备之间速度的不匹配。它是先把纸带通过输入设备在外围机（与主机相比处于次要地位的计算机）的控制下输入到磁带上，当CPU需要这些信息时再从磁带上高速地调取。类似的，在输出时把信息输出到磁盘中，在外围机的控制下通过输出设备输出。也就是说主机直接对磁盘进行操作，输入输出和程序运行脱离。<ul><li>減少了CPU的空闲时间：主机不必依赖输入输出，可以从磁盘中读取数据。</li><li>提升了I/O速度：主机读取信息不再是从卡片中读取，从磁盘读取速度较快。</li></ul></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/脱机输入输出.jpg"></div><h2 id="批处理系统"><a href="#批处理系统" class="headerlink" title="批处理系统"></a>批处理系统</h2><p>为了提升计算机资源的利用率和提升计算机的吞吐量研发出了批操作系统。</p><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul><li>作业：程序+数据+作业说明书（系统根据说明书来对程序的运行进行控制）。</li><li>周转时间：从作业进入系统到作业完成退出系统所用的时间。</li><li>平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NT_i]$</li><li>带权周转时间：作业的周转时间（$T$）和系统为它提供服务的时间（$T_S$）。$W=\frac{T}{T_s}$</li><li>平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NW_i]$</li></ul><h3 id="单道批处理系统"><a href="#单道批处理系统" class="headerlink" title="单道批处理系统"></a>单道批处理系统</h3><p>设计一个常驻内存的程序（监督程序），操作员有选择地把若干作业合成一批，安装输入设备上，并启动监督程序，然后由监督程序自动控制这批作业运行，从而减少部分人工干预，有效地缩短了作业运行前的准备时间，相对的提高CPU的利用率。同一时刻只有一个硬件在运行。特点：自动性、顺序性、单道性。缺点：</p><ul><li>I/O的慢速与CPU 的高速不匹配，且输入时需要CPU等待。</li><li>用户交互性差。作业安装输入后，就不能再交互。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/单道批处理系统.jpg"></div><h3 id="多道批处理系统"><a href="#多道批处理系统" class="headerlink" title="多道批处理系统"></a>多道批处理系统</h3><p>把一个以上的作业存放在主存中，并且同时处于运行状态，使这些作业共享处理机和外部设备等其它系统资源。对于一个单处理机系统来说，作业同时处于运行状态只是宏观的概念，其含义是指每个作业都已开始运行，但尚未完成。就微观而言，在任意特定时刻，处理机上运行的作业只有一个。特点：多道性、无序性、调度性。优缺点：</p><ul><li>优点：资源利用率高、系统吞吐量大。</li><li>缺点：作业仍然要排队处理，所以平均周转时间长、无交互能力。<br>此时如何调度程序已经不是再用一张简单的流程图能说明了，<a href="02-进程&amp;线程.md">第二章</a>会有介绍。下图只是说明处理器利用率高。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/多道批处理.jpg"></div><h3 id="举例证明资源利用率高和系统吞吐量大"><a href="#举例证明资源利用率高和系统吞吐量大" class="headerlink" title="举例证明资源利用率高和系统吞吐量大"></a>举例证明资源利用率高和系统吞吐量大</h3><p>设内存中有三道程序 A、B、C，它们的计算和I/O操作的时间如下表所示：</p><table><thead><tr><th style="text-align:center">程序操作</th><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th></tr></thead><tbody><tr><td style="text-align:center">计算</td><td style="text-align:center">30</td><td style="text-align:center">60</td><td style="text-align:center">20</td></tr><tr><td style="text-align:center">I/O</td><td style="text-align:center">40</td><td style="text-align:center">30</td><td style="text-align:center">40</td></tr><tr><td style="text-align:center">计算</td><td style="text-align:center">10</td><td style="text-align:center">10</td><td style="text-align:center">20</td></tr></tbody></table><ul><li>单道</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/单道举例.jpg" width="100%"></div><br>- 多道<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/多道举例.jpg" width="100%"></div><h2 id="分时系统"><a href="#分时系统" class="headerlink" title="分时系统"></a>分时系统</h2><p>批处理系统中，作业一旦提交就不能进行更改，所以人机交互性很差。为了满足人机交互的需求诞生分时系统。每一个用户通过一台终端与计算机相连，以交互式的命令使用系统，采用分享CPU的方法，由于CPU的速度比人在终端输入指令的时间快得多，所以用户感到自己独占了整个计算机系统。系统规定一个称之为“时间片”的时间单位，所有终端用户轮流享用一个时间片的CPU。需要解决的问题：</p><ul><li>及时接受：所有终端用户输入的信息都要能够被及时的送到处理器上。所以主机会以很快的速度循环扫描各个终端。每个终端也要拥有缓存区来保存输入的信息。</li><li>及时处理：用户需要能对自己的作业及其允许及时地实施控制。所以所有的作业必须驻留在内存中，因此批作业系统不能被使用。它采用的方式是：作业直接进入内存。但每个用户只连续使用一个“时间片”的时间，对所有用户进行循环。这样每个用户都能及时地与自己的作业进行交互。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/分时系统.jpg"></div><h3 id="分时系统与多道批处理系统的不同特性"><a href="#分时系统与多道批处理系统的不同特性" class="headerlink" title="分时系统与多道批处理系统的不同特性"></a>分时系统与多道批处理系统的不同特性</h3><ul><li>多路性：允许多个用户共享一台计算机，提高资源利用率。</li><li>独立性：每个用户之间互不干扰，感觉就是一个人在独占一台计算机。</li><li>及时性：用户的请求能在很短的时间内得到回应。</li><li>交互性：用户可以通过终端和计算机进行及时交互。</li></ul><h2 id="实时系统"><a href="#实时系统" class="headerlink" title="实时系统"></a>实时系统</h2><p>指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。实时系统强调程序运行的时间，它需对接收到的某些信号做出及时地反应。大多数的实时系统是专用系统，如：工业（武器）控制系统、信息查询系统、多媒体系统、嵌入式系统等。最大的特点就是可靠性：系统必须高度可靠，因为任何可能的差错都可能带来灾难性后果，所以系统一般都有多级容错措施。</p><ul><li>按是否周期执行分类：<ul><li>周期性实时任务：如外部设备周期性地发出状态信号给计算机使其状态能被实时感知。</li><li>非周期性实时任务：提交给系统时需要指定开始截止时间和完成截止时间。</li></ul></li><li>硬实时任务&amp;软实时任务：<ul><li>硬实时任务（Hard Real-time Task）：截止时间到达时任务必须完成，比如武器控制系统。</li><li>软实时任务（Soft Real-time Task）：截止时间到达时任务没有完成没有太大影响，比如多媒体系统。</li></ul></li></ul><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><ul><li>进程：在系统中能独立运行并作为资源分配的基本单位。</li><li>线程：独立运行的基本单位，比进程更小，基本上不拥有系统资源。通常在一个进程中包含了若干个线程。</li></ul><h2 id="操作系统的基本特性"><a href="#操作系统的基本特性" class="headerlink" title="操作系统的基本特性"></a>操作系统的基本特性</h2><ul><li>并发：宏观上是多个进程同时运行，微观上是每一时刻只有一道进程在执行。</li><li>共享：系统中的资源可供内存中多个并发执行的进程（线程）共同使用。有两种共享方式：<ul><li>互斥共享方式，如打印机；</li><li>同时访问方式，如共享文件夹、网络资源。</li></ul></li><li>虚拟：通过某种技术把一个物理实体变为若干个逻辑上的对应物。这样可以避免一个进程单独占用某个物理设备，一个物理设备被分配给多个进程便可以提升物理设备的使用率。</li><li>不确定性（异步性）：进程以人们不可预知的速度向前推进，即为进程的不确定性。这样的话很可能是先进入内存的作业后完成；而后进入内存的作业先完成。尽管如此，但只要有合理的进程同步方式且运行环境相同，作业经多次运行，都会获得完全相同的结果。因此，异步运行方式是允许的。</li></ul><h2 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h2><h3 id="传统操作系统结构"><a href="#传统操作系统结构" class="headerlink" title="传统操作系统结构"></a>传统操作系统结构</h3><ul><li>无结构OS：<ul><li>关注功能的实现和获得高的效率操作系统是为数众多的一组过程的集合，各过程之间可以相互调用，在操作系统内部不存在任何结构。</li><li>程序设计的技巧，只是如何编制紧凑的程序，以便于有效地利用内存。</li><li>操作系统既庞大又杂乱，缺乏清晰的程序结构。</li><li>程序错误很多，给调试工作带来很多困难；另一方面也使程序难以阅读和理解，增加了维护人员的负担。</li></ul></li><li>模块化结构OS<ul><li>模块化程序设计技术，是最早（20世纪60年代）出现的一种程序设计技术。该技术是基于“分解”和“模块”原则来控制大型软件的复杂度的。</li><li>将OS按其功能划分为若干个具有一定独立性和大小的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口， 使各模块之间能通过该接口实现交互，然后再进一步将各模块细分为若干个具有一定管理功能的子模块。（会导致模块之间的依赖关系很重，OS结构不清晰）</li><li>若子模块较大时，再进一步将它细分。</li></ul></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/模块式os结构.jpg"></div><br>- 分层式结构OS：<br>- 改进设计方式，使每一步设计都是建立在可靠的基础上一层一层地自底向上增添软件层，每一层都实现若干功能，最后总能构成一个能满足需要的OS。<br>- 每一层都仅使用其底层所提供的功能和服务，这样可使系统的调试和验证都变得容易。<br>- 一旦发现错误后，通常该错误只会局限于某一层，因为它与所有其高层的软件无关，而此层以下的各层软件，又都经过仔细的调试，bug修复较为容易。<br><br>### 客户/服务器结构<br><br>- 为了提高OS的灵活性和可扩充性而将OS划分为两部分。<br>- 一部分是用于提供各种服务的一组服务器（进程），所有这些服务器（进程）都运行在用户态。当有一用户进程（现在称为客户进程）要求读文件的一个盘块时，该进程便向文件服务器（进程）发出一个请求；当服务器完成了该客户的请求后，便给该客户回送一个响应。<br>- 另一部分是内核，用来处理客户和服务器之间的通信， 即由内核来接收客户的请求，再将该请求送至相应的服务器；同时它也接收服务器的应答， 并将此应答回送给请求客户。<br>- 此外，在内核中还应具有其它一些机构，用于实现与硬件紧密相关的和一些较基本的功能。<br><br>### 面向对象结构（20世纪80年代）<br><br>- 该技术是基于“抽象”和“隐蔽”原则来控制大型软件的复杂度的。所谓对象，是指在现实世界中具有相同属性、服从相同规则的一系列事物的抽象，而把其中的具体事物称为对象的实例。<br>- OS中的各类实体如进程、线程、消息、存储器等，都使用了对象这一概念，相应地，便有进程对象、线程对象、 存储器对象等。<br>- 由于隐蔽了表示实体的数据和操作，因而可以改变对象的表示而不会影响其它部分， 从而可以方便地改变老的对象和增加新的对象。<br>- 继承性。继承性是面向对象技术所具有的重要特性。继承性是指子对象可以继承父对象的属性，这样，在创建一个新的对象时， 便可减少大量的时空开销。<br>- 正确性和可靠性。由于对象是构成操作系统的基本单元，可以独立地对它进行测试，这样，比较易于保证其正确性和可靠性，从而比较容易保证整个系统的正确性和可靠性。<br><br>### 微服务结构（20世纪90年代）<br><br>- 能有效支持多处理机，适用于分布式系统环境。<br>- 以微内核为操作系统核心，以客户/服务器为基础，采用了面向对象的程序设计方法。<br>- 所谓微内核技术，是指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS(程序)不同， 它更小更精炼，它不仅运行在核心态，而且开机后常驻内存， 它不会因内存紧张而被换出内存。<br>- 微内核并非是一个完整的OS， 而只是为构建通用OS提供一个重要基础。<br>- 在微内核OS结构中，通常都采用了客户/服务器模式，因此OS的大部分功能和服务，都是由若干服务器来提供的， 如文件服务器、作业服务器和网络服务器等。<br><br><br><br>## 进程概念<br><br>### 前趋图<br><br>数据结构中的有向无环图。箭头表示进程之间执行的先后关系。结点表示一个程序或一个进程，甚至一条语句。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/前趋图.jpg"></div><h3 id="程序的并发执行"><a href="#程序的并发执行" class="headerlink" title="程序的并发执行"></a>程序的并发执行</h3><p>不存在前趋关系的程序之间才有可能并发执行。特征：</p><ul><li>间断性：程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系，进而导致并发程序具有“执行-暂停-执行”这种间断性的活动规律。</li><li>失去封闭性：由于资源共享，所以当某程序的运行影响资源的状态时，其他程序的运行环境就会被破坏。</li><li>不可再现性：计算结果与并发程序各自执行速度有关。即同一程序，使用相同输入、在相同环境下运行，却可能获得完全不同的结果。</li></ul><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><p>在多道程序环境下，程序的执行属于并发执行，此时他们将失去其封闭性，并具有间断性，以及运行结果的不可再现性。由此，决定了通常的程序是不能参与并发执行的。为了能使程序并发执行，引入了进程。</p><ul><li>进程实体：程序+数据+进程控制块（Process Control Block，PCB）。</li><li>进程：运行态的进程实体是就是进程，是系统进行资源分配和调度的一个独立单位。<ul><li>PCB是为了使程序能并发执行而诞生的一种数据结构，它用来控制和管理进程。由于数据和程序本来就存在，所以创建/撤销进程也就是创建/撤销PCB。至于如何并发执行，见下面的进程同步。</li><li>区别于作业：进程是程序在数据集上的一次作执行，作业是用户提交给系统的一个任务，包含一个或多个进程。</li></ul></li></ul><h3 id="进程的特点"><a href="#进程的特点" class="headerlink" title="进程的特点"></a>进程的特点</h3><ul><li>动态性：由创建而产生，由调度而执行，由撤销而消亡。</li><li>并发性：进程的重要特征，操作系统的重要特征。</li><li>独立性：独立运行、独立分配资源、独立接受调度。</li><li>异步性：按各自独立、不可预知的速度向前推进。</li></ul><h2 id="PCB"><a href="#PCB" class="headerlink" title="PCB"></a>PCB</h2><h3 id="PCB中保存的信息"><a href="#PCB中保存的信息" class="headerlink" title="PCB中保存的信息"></a>PCB中保存的信息</h3><ul><li>进程标识符。用于唯一的标识某个进程。<ul><li>外部标识符：不仅可以标识进程，还指明其父进程、子进程以及拥有该进程的用户。</li><li>内部标识符：方便系统使用进程，仅能标识进程。</li></ul></li><li>处理机状态。用于在进程切换时保存处理机中各个寄存器的内容。以便在该进程重新调度时能再从断点执行。</li><li>进程调度信息。<ul><li>进程状态：指明进程的状态，方便进程调度和对换时的依据。</li><li>进程优先级：进程优先级高的更容易获得处理机。</li><li>进程调度所需信息：保存的内容和进程调度算法有关，如进程等待了多久CPU，使用了多长CPU。</li><li>事件：进程因何由执行状态转变为阻塞状态，即阻塞原因。</li></ul></li><li>进程控制信息。<ul><li>程序和数据的地址。</li><li>进程同步的通信机制。</li><li>资源清单。进程已分配到的除处理机之外的资源。</li><li>链接指针。用于指向下一个PCB的首地址。用于进程调度。</li></ul></li></ul><h3 id="PCB的组织方式"><a href="#PCB的组织方式" class="headerlink" title="PCB的组织方式"></a>PCB的组织方式</h3><ul><li>线性方式：所有的PCB都保存在一张表中，每次寻找PCB都在表中查找。效率低。</li><li>链接方式：把具有相同状态的PCB链接起来。</li><li>索引方式：把具有相同状态的PCB保存在相应的表中。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/pcb的组织方式.jpg"></div><h2 id="OS内核"><a href="#OS内核" class="headerlink" title="OS内核"></a>OS内核</h2><h3 id="系统态-amp-用户态"><a href="#系统态-amp-用户态" class="headerlink" title="系统态 &amp; 用户态"></a>系统态 &amp; 用户态</h3><p>对于处理机来说，根据其执行的指令不同，可以将其分成系统态（管态、内核态）和用户态。处理机处于系统态时可以执行任意的指令，访问所有的寄存器和存储区，而处于用户态的时候会受到相应的限制。所以计算机中的程序可以分成系统程序和用户程序，用户程序运行在用户态，这样就可以防止用户程序对操作系统进行破坏。</p><h3 id="指令分类"><a href="#指令分类" class="headerlink" title="指令分类"></a>指令分类</h3><p>操作系统把CPU指令分成两类：</p><ul><li>特权指令：在系统态执行的指令。执行几乎不受限制，如启动外部设备、设置系统时钟等。</li><li>非特权指令：在用户态执行的指令。限制较多，比如不能操作硬件等。</li></ul><h3 id="内核概念"><a href="#内核概念" class="headerlink" title="内核概念"></a>内核概念</h3><p>现代操作系统采用分层设计模式，不同权重的程序分别设置在不同的层次中。通常与<strong>硬件紧密相关的程序</strong>、<strong>设备驱动程序</strong>和<strong>运行频率高的程序</strong>等放置在高级别层次中，操作系统会将它们常驻内存，这些程序便被称为OS内核。OS内核运行在系统态中。</p><h3 id="内核的功能"><a href="#内核的功能" class="headerlink" title="内核的功能"></a>内核的功能</h3><p>不同操作系统的内核在功能上有一定的差异，但是一般都包含两类功能：</p><ul><li>支撑功能<ul><li>中断处理：是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，且处理完毕后又返回原被暂停的程序继续运行。人机交互、设备驱动和进程调度等都需要依赖中断处理。</li><li>时钟管理：系统中很多活动都需要用到时钟，如定时任务、时间片轮转调度算法等。</li><li>原语操作：原语是若干条机器指令构成的，用以完成特定功能的一段程序。而原语操作便是原语的执行，其在执行期间是不可分割的。</li></ul></li><li>资源管理功能<ul><li>进程管理：进程的创建、撤销、调度等操作。</li><li>存储器管理：空间的分配、撤销、逻辑地址转换为物理地址等。</li><li>设备管理：进行设备分配、缓和CPU和I/O速度不匹配矛盾的缓冲管理等。</li></ul></li></ul><h2 id="进程的生命周期"><a href="#进程的生命周期" class="headerlink" title="进程的生命周期"></a>进程的生命周期</h2><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><ol><li>为新进程申请内部标识符，同时从PCB集合中索取一个空白的PCB。</li><li>为新进程分配其运行所需的资源。这些资源直接来自操作系统或者父进程。</li><li>初始化PCB。如处理机状态信息、标识符和进程优先级等。</li><li>若就绪队列还能接受进程，则插入就绪队列。不能接受则执行相应处理机制。</li></ol><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><ol><li>从PCB集合中获得某进程的PCB，并读出该进程的状态。<ul><li>若进程正处于执行状态，应立即终止该进程的执行。</li><li>若此进程有子进程则一并终止，防止其成为不可控进程。</li></ul></li><li>将进程拥有的所有资源归还给其父进程或操作系统。</li><li>将被终止的进程从所在队列或链表（指PCB的组织方式）中移出，等待其他程序收集信息，释放空间等。</li></ol><h3 id="三种基本状态"><a href="#三种基本状态" class="headerlink" title="三种基本状态"></a>三种基本状态</h3><ul><li>就绪状态：分配到出处理机之外的其他所有必要资源。此时可运行，但其他进程正在占用CPU。</li><li>执行状态：就绪状态的进程获得CPU，正在执行的状态。</li><li>阻塞状态：进程发出的请求没有及时得到满足而无法继续执行的状态，此时会引起进程调度，OS把处理机分配给其他就绪进程，原进程暂停。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/五种进程状态.jpg"></div><h3 id="挂起"><a href="#挂起" class="headerlink" title="挂起"></a>挂起</h3><p>进程暂停执行或不接受调度的状态。原因有如下几点：</p><ul><li>用户的需要：用户想暂停正在的进程，观察其状态或修改程序等。</li><li>父进程请求：父进程为了完成某项任务，协调其各子进程间的活动。</li><li>负荷调节的需要：系统压力过大或实时操作系统不能很好的满足可靠性时会挂起一些进程。</li><li>操作系统的需要：操作系统挂起某些进程来更方便的检查系统资源。<br>挂起和阻塞不同在于阻塞是客观条件不能得到满足，即资源不足引起暂停。挂起是主观需要引起暂停。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/引入挂起的进程状态图.jpg"></div><h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><p>进程同步的主要任务是使并发执行的诸进程之间能有效的共享资源和相互合作，从而使程序的执行具有可再现性。</p><h3 id="同步-amp-互斥"><a href="#同步-amp-互斥" class="headerlink" title="同步 &amp; 互斥"></a>同步 &amp; 互斥</h3><p>并发执行的诸进程之间既有独立性又有制约性。</p><ul><li>独立性：各进程都可独立地向前推进；</li><li>制约性：由于资源共享和进程合作引起的进程之间的相互依赖和相互制约的关系。可归结为互斥和同步。<ul><li>同步：两个或多个事件的发生有着某种时序上的关系。按照这种时序关系进行能保证各任务安全的完成。</li><li>互斥：资源的使用要排它使用，防止冲突（不同时使用，但无先后次序。一种特殊同步）。</li></ul></li></ul><h3 id="临界资源-amp-临界区"><a href="#临界资源-amp-临界区" class="headerlink" title="临界资源 &amp; 临界区"></a>临界资源 &amp; 临界区</h3><ul><li>临界资源：需要被各进程互斥访问的资源。</li><li>临界区：各进程中访问临界资源的代码。<br>若能保证各进程互斥地进入自己的临界区，便可以保证互斥地访问临界资源，进而保证进程同步。常用的方式有硬件同步机制和信号量机制。</li></ul><h3 id="同步准则"><a href="#同步准则" class="headerlink" title="同步准则"></a>同步准则</h3><ul><li>空闲让进：当无进程处于临界区时，应当允许一个进程进入自己的临界区。</li><li>忙则等待：当有进程处于临界区时其他请求就如临界区的进程必须等待。</li><li>有限等待：对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区。</li><li>让权等待：当进程不能进入临界区时，应立即释放处理机避免进程陷入“忙等”的状态。</li></ul><h2 id="硬件同步机制"><a href="#硬件同步机制" class="headerlink" title="硬件同步机制"></a>硬件同步机制</h2><h3 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h3><p>当进程在临界区执行期间，计算机系统不响应中断，因此不会引发调度，临界资源只会被一个进程占据，这样就不会发生进程同步问题。</p><h3 id="利用Test-and-Set指令实现互斥"><a href="#利用Test-and-Set指令实现互斥" class="headerlink" title="利用Test-and-Set指令实现互斥"></a>利用Test-and-Set指令实现互斥</h3><p>指令的描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">boolean <span class="title">TS</span><span class="params">(boolean *lock)</span></span>&#123;</span><br><span class="line">    boolean old;</span><br><span class="line">    old = *lock;</span><br><span class="line">    *lock = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为临界资源设置一个布尔变量<code>lock = false</code>。在进程进入临界区之前利用TS指令测试，如果得到的值为<code>false</code>表示资源未被使用，如果得到的值为<code>true</code>，则一直测试到结果为<code>false</code>。使用TS指令实现互斥描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">while</span> (TS(&amp;lock));</span><br><span class="line">	...</span><br><span class="line">	lock = <span class="literal">false</span>;</span><br><span class="line">	...</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h3 id="利用Swap指令实现互斥"><a href="#利用Swap指令实现互斥" class="headerlink" title="利用Swap指令实现互斥"></a>利用Swap指令实现互斥</h3><p>指令描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(boolean *a, boolean *b)</span></span>&#123;</span><br><span class="line">    boolean temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为每个临界资源设置一个全局变量<code>lock=false</code>。每个进程设置一个局部变量<code>key</code>。实现互斥的描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	...</span><br><span class="line">    key = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        swap(&amp;lock, &amp;key);</span><br><span class="line">    &#125;<span class="keyword">while</span>(key != <span class="literal">false</span>)</span><br><span class="line">    critical section;</span><br><span class="line">    lock = <span class="literal">false</span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>关中断：效率低下且不适用于多处理机系统。且其他进行会”忙等“，不符合让权等待。</li><li>TS指令 &amp; Swap指令：其他进行会”忙等“，不符合让权等待。</li></ul><h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><h3 id="整型信号量"><a href="#整型信号量" class="headerlink" title="整型信号量"></a>整型信号量</h3><p>整型信号量是一个用于描述资源数目的整型量（S）。但除了初始化以外，仅能通过两个原子操作来访问。</p><ul><li><p>wait(S)：P操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wait(S)&#123;</span><br><span class="line">    <span class="keyword">while</span>(S &lt;= <span class="number">0</span>);</span><br><span class="line">    S--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>signal(S)：V操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">signal(S)&#123;</span><br><span class="line">    S++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>P操作用于分配资源，V操作用于释放资源。</p></li></ul><h3 id="记录型信号量"><a href="#记录型信号量" class="headerlink" title="记录型信号量"></a>记录型信号量</h3><p>整型信号量未遵循让权等待原则。只要<code>S &lt;= 0</code>就会不断的循环。此时需要增加一个进程链表指针链接等待进程。</p><ul><li><p>数据结构的描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;	<span class="comment">//资源数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">process_control_block</span> *<span class="title">list</span>;</span>	<span class="comment">//阻塞队列</span></span><br><span class="line">&#125; semaphore;</span><br></pre></td></tr></table></figure></li><li><p>wait(S)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value--;</span><br><span class="line">    if(S-&gt;value &lt; 0)</span><br><span class="line">    	block(S-&gt;list);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>signal(S)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">signal(semaphore *S)&#123;</span><br><span class="line">    S-&gt;value++;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;value &lt;= <span class="number">0</span>)</span><br><span class="line">    	wakeup(S-&gt;<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当进程被阻塞时会被加入阻塞对列，资源被满足时唤醒阻塞对列中的某个资源。</p></li></ul><h3 id="AND型信号量"><a href="#AND型信号量" class="headerlink" title="AND型信号量"></a>AND型信号量</h3><p>记录型信号量只能解决共享一个临界资源的情况，若有多个临界资源则需要使用多个记录型信号量。但是信号量越多，系统死锁的概率越大，且大量的同步操作会给系统的管理带来麻烦。AND型信号量的思想是一次性分配进程所需的全部资源，如果有一个没有分配成功，则其他所有可能为之分配的资源亦不分配。</p><ul><li><p>Swait(S)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Swait(S1, S2, ..., Sn)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(Si &gt;= <span class="number">1</span> &amp;&amp; ... &amp;&amp; Sn &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">            	Si--;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            把进程阻塞在请求未能得到满足的资源Si所对应的阻塞队列里，同时把进程的程序计数器（放			  置CPU下一条要执行的指令地址）放置在本操作的开始处（下一次再调度到此进程，需要再次</span><br><span class="line">            检查所有的资源）。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Ssignal(S)：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Ssignal(S1, S2, ..., Sn)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            Si++;</span><br><span class="line">            唤醒等待Si资源的阻塞队列。</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="信号量集"><a href="#信号量集" class="headerlink" title="信号量集"></a>信号量集</h3><p>之前的信号量都是一次申请或释放某资源一份，若申请或释放N份资源需要进行N次操作，效率比较低下。此外，当资源数量低于某一下限值时，为了系统安全，就不能再予以分配。所以产生信号量集解决以上问题。描述如下：</p><ul><li><code>Swait(S1, t1, d1, ..., Sn, tn, dn)</code>：当<code>Si &gt;= ti</code>时<code>Si = Si - di</code>。（<code>di &gt;= ti</code>）</li><li><code>Ssignal(S1, d1, ..., Sn, dn)</code>：<code>Si = Si + di</code>。<br>特殊的信号量集：</li><li><code>Swait(S1, d, d)</code>：每次申请d份资源，资源少于d时不分配。</li><li><code>Swait(S, 1, 1)</code>：退化成一般的记录型信号量。</li><li><code>Swait(S, 1, 0)</code>：<code>S &gt;= 1</code>时运行多个进行进入特定区。<code>S &lt;= 0</code>时禁止进程进入特定区。</li></ul><h3 id="管程"><a href="#管程" class="headerlink" title="管程"></a>管程</h3><p>直接使用信号量机制会把大量的同步操作分散在各个进程中，这会增加系统死锁的概率并且不方便系统的管理。而管程就是把代表共享资源的数据结构和对共享数据结构的操作（包括同步机制）封装起来以更好的为进程使用。这时所有请求访问共享资源的进程都只能通过管程间接访问，同时管程每次只允许一个进程进入管程。<br>此时的管程可以使用面相对象的操作来完成整型信号量的功能。但是此时无法解决“让权等待”的问题，所以再按照面相对象的思想将<code>block</code>和<code>wakeup</code>操作封装起来来解决这个问题，即构成条件变量。条件变量的操作如下：</p><ul><li><code>condition.wait()</code>：使进程在因某条件不能满足时阻塞在其所对应的条件变量上。</li><li><code>condition.signal()</code>：唤醒因某条件不能满足而阻塞的进程。<br>可以很容易看出来，设置不同的条件变量能使由不同原因等待的进程阻塞在不同的队列中。<br>使用时把<code>signal()</code>操作放在函数/过程的最后，这样保证在唤醒其他进程后本进程能直接退出而不再产生冲突。<br><strong>管程的描述如下：</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	1、局部数据和条件变量组成管程内的数据结构。</span></span><br><span class="line"><span class="comment">	2、过程/函数1~过程/函数k组成管程内的一组过程对管程内的数据结构进行操作。</span></span><br><span class="line"><span class="comment">	3、初始化代码：对管程内的数据结构进行初始化。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Monitor monitor_name&#123;</span><br><span class="line">    share variable declartions; <span class="comment">//共享变量说明</span></span><br><span class="line">    condition declarations;		<span class="comment">//条件变量说明</span></span><br><span class="line">    &#123;	<span class="comment">//管程主体</span></span><br><span class="line">        initialization code;    <span class="comment">//初始化代码</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:		<span class="comment">//能被进程调用的过程</span></span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">P1</span><span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">P2</span><span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line">    	...</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="title">Pn</span><span class="params">(...)</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="信号量的应用"><a href="#信号量的应用" class="headerlink" title="信号量的应用"></a>信号量的应用</h2><h3 id="互斥访问资源"><a href="#互斥访问资源" class="headerlink" title="互斥访问资源"></a>互斥访问资源</h3><p>设某共享资源的信号量是<code>mutex</code>，PA和PB进程并发时需互斥访问。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line">PA()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    	...</span><br><span class="line">        wait(mutex);</span><br><span class="line">        ...</span><br><span class="line">        signal(mutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">PB()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        wait(mutex);</span><br><span class="line">        ...</span><br><span class="line">        signal(mutex);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="利用信号量实现前趋关系"><a href="#利用信号量实现前趋关系" class="headerlink" title="利用信号量实现前趋关系"></a>利用信号量实现前趋关系</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/前趋图例题.jpg"></div><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">P1（）&#123;...V(f1);V(f1);V(f1);&#125;</span><br><span class="line">P2（）&#123;P(f1)；... V(f2);&#125;</span><br><span class="line">P3（）&#123;P(f1)；... V(f3);&#125;</span><br><span class="line">P4（）&#123;P(f1)；... V(f4);&#125;</span><br><span class="line">P5（）&#123;P(f2)；... V(f5);&#125;</span><br><span class="line">P6（）&#123;P(f3);P(f4);P(f5);...;&#125;</span><br><span class="line">main()&#123;</span><br><span class="line">    semaphore f1=f2=f3=f4=f5=<span class="number">0</span>；</span><br><span class="line">    Cobegin</span><br><span class="line">    	P1(); P2();P3(); P4();P5(); P6();</span><br><span class="line">    Coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>在并发时，如果<code>P1</code>的功能代码未执行完，<code>f1</code>为0，每次对<code>f1</code>进行V操作能使<code>P2</code>、<code>P3</code>、<code>P4</code>运行一个。其他亦然。<br><br><br><br>### 生产者—消费者问题<br><br>- 问题描述：多个生产者进程生产产品以供多个消费者消费。通过由n个环形缓冲区构成的缓冲池（循环队列），把多个生产者和多个消费者联系起来。不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未取走的缓冲区中投放产品。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/生产者消费者.jpg"></div><br>- 分析：<br><br>- 任何时刻，只能有一个进程在缓冲区中操作。<br>- 对于“生产者”而言，缓冲区满则应等待。<br>- 对于“消费者”而言，缓冲区空则应等待。<br><br>- 利用记录型信号量解决问题<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;<span class="comment">//in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。</span></span><br><span class="line">item buffer[n];<span class="comment">//缓存区大小为n，地址为[0, n-1]。</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;	<span class="comment">//mutex用于互斥访问缓存区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        produce an item nextproducer;</span><br><span class="line">        ...</span><br><span class="line">        wait(empty);	<span class="comment">//消耗一个empty，当empty&lt;=0时等待</span></span><br><span class="line">        wait(mutex);	</span><br><span class="line">        buffer[in] = nextproducer;</span><br><span class="line">        in = (in+<span class="number">1</span>) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(full);	<span class="comment">//增加一个full</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(full);		<span class="comment">//消耗一个full，当full&lt;=0时等待</span></span><br><span class="line">        wait(mutex);</span><br><span class="line">        nextconsumer = buffer[out];</span><br><span class="line">        out = (out+<span class="number">1</span>) % n;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(empty);	<span class="comment">//增加一个empty</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        produce();consumer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>- 互斥信号量 &amp; 资源信号量<br>互斥使用的资源设置一个互斥信号量，资源数为1。资源信号量的资源数和资源的意义有关。资源信号量的资源为1时退化成互斥信号量。<br>在使用时互斥信号量的P操作需要紧邻其对应共享资源的临界区使用，否则可能造成同步问题。比如互换上面代码的第8行和第9行之后，若生产者进程和消费者进程都只有一个，且生产者通过了<code>P(mutex)</code>，阻塞在<code>P(empty)</code>，消费者通过了<code>P(full)</code>，阻塞在<code>P(mutex)</code>，此时生产者等待消费者的<code>V(empty)</code>，消费者等待生产者的<code>V(mutex)</code>，发生死锁。而V操作不需要注意顺序。<br><br>- 利用AND型信号量解决问题<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>;<span class="comment">//in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。</span></span><br><span class="line">item buffer[n];<span class="comment">//缓存区大小为n，地址为[0, n-1]。</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>, empty = n, full = <span class="number">0</span>;	<span class="comment">//mutex用于互斥访问缓存区</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        produce an item nextproducer;</span><br><span class="line">        ...</span><br><span class="line">        Swait(empty, mutex);	<span class="comment">//消耗一个empty，当empty&lt;=0时等待</span></span><br><span class="line">        buffer[in] = nextproducer;</span><br><span class="line">        in = (in+<span class="number">1</span>) % n;</span><br><span class="line">        signal(empty, mutex);	<span class="comment">//增加一个full</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;	</span><br><span class="line">        wait(full, mutex);	<span class="comment">//消耗一个full，当full&lt;=0时等待</span></span><br><span class="line">        nextconsumer = buffer[out];</span><br><span class="line">        out = (out+<span class="number">1</span>) % n;</span><br><span class="line">        signal(full, mutex);	<span class="comment">//增加一个empty</span></span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        produce();consumer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>- 利用管程解决问题<br><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Monitor monitor&#123;</span><br><span class="line">    item buffer[n];</span><br><span class="line">    <span class="keyword">int</span> in = <span class="number">0</span>, out = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">    condition notfull, notempty;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    	<span class="function"><span class="keyword">void</span> <span class="keyword">static</span> <span class="title">put</span><span class="params">(item x)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= n)</span><br><span class="line">            	cwait(notfull);	<span class="comment">//阻塞在队列满的条件下</span></span><br><span class="line">            buffer[in] = x;</span><br><span class="line">            in = (in+<span class="number">1</span>) % n;</span><br><span class="line">            count++;</span><br><span class="line">            csignal(notempty);</span><br><span class="line">    	&#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="keyword">static</span> <span class="title">get</span><span class="params">(item &amp;x)</span></span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(count &lt;= <span class="number">0</span>)</span><br><span class="line">                cwait(notempty);	<span class="comment">//阻塞在队列空的条件下</span></span><br><span class="line">            x = buffer[out];</span><br><span class="line">            out = (out+<span class="number">1</span>) % n;</span><br><span class="line">            count--;</span><br><span class="line">            csignal(notfull);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">producer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    item x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        ...</span><br><span class="line">        produce an item in nextproducer;</span><br><span class="line">        monitor.put(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consumer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    item x;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        monitor.get(x);</span><br><span class="line">        consume the item in nextconsumer;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        produce();consumer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br><br><br>### 哲学家进餐问题<br><br>- 问题描述：五个哲学家坐在圆桌前，每人一份饭，每个哲学家两侧各有一支筷子,只有拿到左右两只筷子才能进餐，哲学家处于吃饭和思考两种状态。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/哲学家进餐.jpg"></div><ul><li><p>分析</p><ul><li>同一时刻一只筷子只能有一个哲学家拿起。</li><li>只有获得两个筷子后才能进餐。</li><li>如果每个哲学家都拿起一只筷子，都饿死。</li><li>并行程度：五只筷子允许两人同时进餐。</li></ul></li><li><p>利用AND型信号量解决问题<br>每次必须拿到两只筷子才能拿起，否则不拿起筷子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    Swait(chopstick[i], chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    ...</span><br><span class="line">    Ssignal(chopstick[i], chopstick[(i+<span class="number">1</span>) % <span class="number">5</span>]);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="读者-写者问题"><a href="#读者-写者问题" class="headerlink" title="读者-写者问题"></a>读者-写者问题</h3><ul><li><p>问题描述：</p><ul><li>写者向共享数据区放数据，读者从共享数据区读数据。</li><li>多个读者可同时读取数据，多个写者不能同时写数据。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/读者-写者.jpg"></div></li><li><p>分析：</p><ul><li>读者进入共享数据区，写者必须等待。</li><li>读者进入共享数据区，读者可以进入。</li><li>写者进入共享数据区，读者必须等待。</li></ul></li><li><p>利用记录型信号量解决问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">semaphore readmutex = <span class="number">1</span>, writemutex = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> readcount = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(readmutex);</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            wait(writemutex);</span><br><span class="line">        readcount++;</span><br><span class="line">        signal(readmutex);</span><br><span class="line">        ...	<span class="comment">//read opreation</span></span><br><span class="line">        wait(readmutex);</span><br><span class="line">        readcount--;</span><br><span class="line">        <span class="keyword">if</span>(readcount == <span class="number">0</span>)</span><br><span class="line">            signal(writemutex);</span><br><span class="line">        signal(readmutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        wait(writemutex);	<span class="comment">//当写者进入共享数据区，reader会阻塞在</span></span><br><span class="line">        ... <span class="comment">//write operation</span></span><br><span class="line">        signal(writemutex);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        reader();writer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码分析：<br>最开始并发的时候：</p><ul><li>假如读者先抢到资源，<code>readcount == 0</code>，<code>P(writemutex)</code>，<code>writer()</code>会阻塞在第20行，但其他<code>reader()</code>仍可以运行，只是不会再<code>P(writemutex)</code>。同时每个<code>reader()</code>都<code>readcount++</code>，直到<code>readcount == 0</code>时<code>V(writemutex)</code>，然后<code>writer()</code>才有可能能进入。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。</li><li>假如写者先抢到资源，<code>P(writemutex)</code>，此时<code>readcount == 0</code>，所有<code>reader()</code>阻塞在第7行。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。<br>综上，完成了要求。</li></ul></li></ul><h3 id="读者-写者问题拓展"><a href="#读者-写者问题拓展" class="headerlink" title="读者-写者问题拓展"></a>读者-写者问题拓展</h3><ul><li><p>问题描述：拓展就是又增加一个条件，最多只允许RN个读者同时读。</p></li><li><p>利用信号量集解决问题</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">semaphore L = RN, mx = <span class="number">1</span>;	<span class="comment">//L用来控制访问数，mx控制写者访问时所有读者阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        Swait(L, <span class="number">1</span>, <span class="number">1</span>);	<span class="comment">//第RN+1个读者进入时会阻塞</span></span><br><span class="line">        Swait(mx, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">//mx &gt;= 1时才可以进入</span></span><br><span class="line">        ...	<span class="comment">//read operation</span></span><br><span class="line">        Ssignal(L, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        Swait(mx, <span class="number">1</span>, <span class="number">1</span>; L, RN, <span class="number">0</span>);	<span class="comment">//mx &gt;= 1 &amp;&amp; L &gt;= RN时进入</span></span><br><span class="line">        ...	<span class="comment">//write operation</span></span><br><span class="line">        Ssignal(mx, <span class="number">1</span>);</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ConcurrentBegin</span><br><span class="line">        reader();writer();</span><br><span class="line">    ConcurrentEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码分析：<br>最开始并发的时候：</p><ul><li>假如读者先抢到资源，<code>L = L - 1</code>，写者阻塞在第12行，但其他<code>reader()</code>仍可以运行，直至没有读者进程在访问共享数据区。当所有的读者进程都退出时，共享数据区中停留的个进程数都为0，即重新开始。</li><li>假如写者先抢到资源，<code>mx = mx - 1</code>，所有读者进程和其他写者进程都要被阻塞，写者进程退出时，共享数据区中停留的个进程数都为0，即重新开始。</li></ul></li></ul><h3 id="理发师问题"><a href="#理发师问题" class="headerlink" title="理发师问题"></a>理发师问题</h3><ul><li><p>问题描述：一把理发椅，N把等待座位。理发师为理发椅上的顾客理发，没有顾客就在理发椅上睡觉，有一个顾客时需要叫醒理发师，多个顾客时需要在等待座位上等候。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/理发师问题.jpg"></div></li><li><p>分析：</p><ul><li>理发椅上只能有一位顾客。</li><li>等待座位是有限缓冲区。</li><li>只要存在顾客，理发师就不能睡觉。</li></ul></li><li><p>利用记录型信号量解决问题：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">semaphore customer = <span class="number">0</span>, barber = <span class="number">0</span>, mutex = <span class="number">1</span>; <span class="comment">//barber使理发师只能为一个顾客服务</span></span><br><span class="line"><span class="keyword">int</span> waiting = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">barber</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">        wait(customer);	<span class="comment">//没有顾客的时候理发师睡觉</span></span><br><span class="line">        wait(mutex);	</span><br><span class="line">        waiting –= <span class="number">1</span>;	<span class="comment">//等待的人少一个</span></span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(barber);</span><br><span class="line">        ...<span class="comment">//获得被激活进程的信息并给相应的顾客剪发</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">customer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    wait(mutex);	</span><br><span class="line">    <span class="keyword">if</span>(waiting &lt; CHAIRS)&#123;	<span class="comment">//顾客到来的时候，还有座位就进去等待</span></span><br><span class="line">        waiting += <span class="number">1</span>;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        signal(customer);</span><br><span class="line">        wait(barber);</span><br><span class="line">        ...  <span class="comment">//将被激活进程的信息发送给barber()</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        signal(mutex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码分析<br>在最开始并发的时候<code>barber()</code>会等待到有顾客时才醒来。顾客一来就需要访问<code>waiting</code>，所以获得<code>mutex</code>。</p><ul><li>如果位置不够就立即释放<code>mutex</code>。</li><li>如果位置够，就让等待的人加1，再释放<code>mutex</code>。然后顾客人数<code>customer += 1</code>来激活理发师进程。理发师进程激活后会<code>V(barber)</code>，然后等待着的<code>customer()</code>进程争夺资源，争夺到<code>P(barber)</code>的进程将被激活进程的信息发送给<code>barber()</code>，<code>barber()</code>获得被激活进程的信息并给相应的顾客剪发。</li></ul></li></ul><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>进程之间合作完成工作不仅仅需要有时序关系，还需要进程信息交互，比如刚才的理发师问题中就设计到了信息交互。从概念上说进程通信是指进程之间的信息交换，所以信号量机制本身就涉及到了信息交换，不过我们把这种信息交换叫做低级进程通信，因为其效率低且需要用户大量的干预。真正的进程通信需要满足使用方便且能高效传输大量数据的需求。</p><h3 id="共享存储器系统"><a href="#共享存储器系统" class="headerlink" title="共享存储器系统"></a>共享存储器系统</h3><ul><li>基于共享数据结构的通信方式：诸进程公用某些数据结构来实现进行通信 ，如生产者—消费者问题中的有界缓冲区，属于低级通信方式。</li><li>基于共享存储区的通信方式：在存储器中划出一块共享存储区，诸进程通过对共享存储区中数据的读或写实现通信，此时数据的形式、位置和访问控制仍是进程实现。适用于传输大量数据，属于高级通信。</li></ul><h3 id="管道通信系统"><a href="#管道通信系统" class="headerlink" title="管道通信系统"></a>管道通信系统</h3><p>所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件。向管道提供输入的发送进程（即写进程）以字符流形式将大量的数据送入管道，而接收进程（即读进程），可从管道中接收数据。管道通信系统必须满足以下三个要求：</p><ul><li>互斥：管道的使用必须互斥。因为存数据和取数据可归于写文件的添加和删除。</li><li>同步：写进程把一定数量的数据写入管道后去睡眠，读进程读完后将其唤醒。读进程读空的管道时需要睡眠。</li><li>确定对方存在：如果写进程不存在，读进程就会一直等待。如果读进程不存在，写进程写完数据后也会一直等待，所以通信双方必须同时存在。</li></ul><h3 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a>消息传递系统</h3><p>指进程可以利用一组通信命令（原语）把数据封装在消息中传送，不需要显示的指定共享存储区或数据结构等。它隐藏了通信的细节，也是目前使用最广泛的进程间通信机制。通常有两种实现方式：</p><ul><li>直接通信方式：OS提供原语给进程使用。</li><li>间接通信方式：借助共享中间实体（称为邮箱）完成进程间的通信。<ul><li>和共享存储器系统的区别是进程不再需要指定数据的形式、位置和访问控制等，信箱内部自有实现。</li></ul></li></ul><h3 id="客户机-服务器系统"><a href="#客户机-服务器系统" class="headerlink" title="客户机-服务器系统"></a>客户机-服务器系统</h3><p>前三种都是单机下的通信机制，这种是网络环境中的通信机制。主要有套接字和RPC两种方式。</p><ul><li>套接字：一个套接字是一个通信标识类型的数据结构，包含了通信目的地址、通信端口号、通信的网络协议、进程自身的地址以及对外提供的系统调用等。使用套接字可以在不同主机上的进程建立连接进而进行通信。</li><li>RPC：Remote Procedure Call，它是一个通信协议，可以使本地进程调用其他主机的进程对程序员表现为常规方法调用。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/rpc.jpg"></div><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程的由来"><a href="#线程的由来" class="headerlink" title="线程的由来"></a>线程的由来</h3><p>进程解决了程序不能并发执行的问题，但是由于进程是拥有资源的基本单位，所以在创建、撤销和切换时所需的时空开销很大，因为处理机势必要付出更大的代价来保存现场。所以把拥有资源和独立运行两项功能分开，让线程作为独立运行的基本单位，进程作为拥有资源的基本单位。不过线程也拥有一些能保证其独立运行的资源，如TCB。</p><h3 id="TCB（Thread-Control-Block）"><a href="#TCB（Thread-Control-Block）" class="headerlink" title="TCB（Thread Control Block）"></a>TCB（Thread Control Block）</h3><p>所有用于控制和管理线程的信息都会被记录在线程控制块中，通常包含：</p><ul><li>线程标识符：每个线程都有唯一的线程标识符。</li><li>处理机信息：包括程序计数器、状态寄存器、通用寄存器的内容。</li><li>线程运行状态：线程和进程一样也有多种运行状态，就绪、阻塞、运行等。详见<code>103-网络编程</code>。</li><li>优先级：和调度算法有关，优先级越高，得到处理机的机会越大。</li><li>线程专有存储区：用于在线程切换时保存现场状态和保存线程的统计信息。</li><li>信号屏蔽：屏蔽某些发送给线程的信号。</li><li>堆栈指针：线程调用别的过程时需要保存局部变量和返回地址等来供返回时能继续执行。</li></ul><h2 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h2><p>线程是为了解决进程调度时过于笨重的问题，所以在不同的环境中实现线程的方式不同。根据内核能否感知到线程的存在可分为内核支持线程（Kernel Supported Threads，KST）和用户级线程（User Level Threads，ULT）。它俩的区别是能否直接调用系统服务，前者可以而后者需要借助中间系统。</p><h3 id="内核支持线程"><a href="#内核支持线程" class="headerlink" title="内核支持线程"></a>内核支持线程</h3><p>若线程是由内核直接调度，线程资源也是保存在内核空间，就可以说此类线程为内核支持线程。此类线程的创建、撤销和切换等操作都是在内核空间完成的，此时线程可以直接调用系统服务。一种可能的实现方式是在创建进程时分配一个任务数据区（Per Task Data Area，PTDA），各个线程的TCB保存在其中即可。不过仅实现内核支持线程的系统对用户进程创建的线程很不友好，每次线程调度处理机都要从用户态转换到核心态。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/内核级线程.jpg"></div><h3 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h3><p>用户级线程是指线程虽客观存在但对内核来说是透明的，此时不能再直接调用系统服务，间接调用系统服务需要有中间系统的支持，通常的中间系统有运行时系统和内核控制线程。</p><ul><li><p>运行时系统：把创建线程、撤销线程和线程同步等只能由OS内核完成的操作封装起来作为运行时系统，而运行时系统停留在用户空间供其他进程调用来实现线程调度。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/运行时系统.jpg"></div></li><li><p>内核控制线程：这种线程又被称作轻量进程（Light Weight Process，LWP），它既可以共享进程的资源，又可以使用内核提供的服务。虽然下图中LWP和用户线程是1对1关系，但实际上多个用户级线程可以复用一个LWP，但每个轻型线程都要连接到一个内核线程中。所以此种方式系统需要同时实现内核支持线程。</p></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/内核控制线程.png" width="80%"></div><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>处理机调度是指通过对处理机资源进程的合理分配来提升系统资源的利用率、降低作业周转时间等。但是由于不同操作系统的目标不同，所以处理机调度的策略和目标也不相同。</p><h3 id="处理机调度的层次"><a href="#处理机调度的层次" class="headerlink" title="处理机调度的层次"></a>处理机调度的层次</h3><ul><li><p>高级调度：又称作业调度或长程调度。它的主要功能是根据某种算法决定把外存上处于后备队列中的哪些作业调入内存，并为他们创建进程、分配资源等，然后放入就绪进程队列。主要用于批处理系统，分时系统的实时系统中不设置高级调度。</p></li><li><p>低级调度：又称进程调度或断层调度。它的主要功能是根据某种算法决定让哪些就绪队列获得处理机，并由分配程序将处理机分配给被选中的进程。在批处理系统、实时系统和分时系统中都设置低级调度。</p></li><li><p>中级调度：又称内存调度。它的主要功能是根据某种算法决定将哪些暂时不能运行的进程调至外存等待，当它们具备运行条件且内存又有空闲时再调入内存。这实际上是存储器管理中的对换功能，在下一章再展开介绍，</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/处理机调度层次.jpg"></div></li></ul><h3 id="处理机调度的目标"><a href="#处理机调度的目标" class="headerlink" title="处理机调度的目标"></a>处理机调度的目标</h3><ul><li>共同目标：<ul><li>提升资源利用率：$CPU的利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$。</li><li>公平：每个进程都应获得合理的CPU时间，不发生进程饥饿现象。</li><li>平衡：进程可以分成多个类型，如计算型、I/O型等等。平衡是指系统中不同的设备都能处于忙碌状态。</li><li>策略强制执行：指某些强制型任务，比如安全策略等，即使会造成其他工作的延迟。</li></ul></li><li>批处理系统的目标：<ul><li>平均周转时间短：<ul><li>周转时间：从作业进入系统到作业完成退出系统所用的时间。</li><li>平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NT_i]$</li><li>带权周转时间：作业的周转时间（$T$）和系统为它提供服务的时间（$T_S$）。$W=\frac{T}{T_s}$</li><li>平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NW_i]$</li></ul></li><li>系统吞吐量高：单位时间内系统完成的作业数尽量多。</li><li>处理机利用率高。</li></ul></li><li>分时系统的目标：<ul><li>响应时间快：指终端提交一个请求到主机返回结果至终端的时间短。</li><li>均衡：不同请求的复杂度不同，所以响应时间必定不同，均衡是指响应时间应和请求复杂度相适应。</li></ul></li><li>实时系统的目标：<ul><li>截止时间的保证：对于HRT任务截止时间必须满足要求，SRT也要尽可能满足。</li><li>可预测性：如在观看电影时一般都会连续播放帧，所以请求是可预测的，假如采用双缓冲实现第<code>i</code>帧和第<code>i+1</code>帧并行处理就能提高实时性。</li></ul></li></ul><h2 id="高级调度"><a href="#高级调度" class="headerlink" title="高级调度"></a>高级调度</h2><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><ul><li>作业：比程序更为广泛的概念，不仅包含了通常的程序和数据，还有一份作业说明书。在批处理系统中，是以作业为基本单位从外存调入内存的。</li><li>作业步：在作业运行期间，每个作业都必须经过若干个相对独立。又相互关联的顺序加工步骤才能得到结果。期中每一个加工步骤成为一个作业步。</li></ul><h3 id="作业控制块"><a href="#作业控制块" class="headerlink" title="作业控制块"></a>作业控制块</h3><p>Job Control Block，JCB。是作业在系统中存在的标志。保存了系统对作业进行管理和调度所需的全部信息。如：作业标识、用户名称、用户账号、作业类型（CPU繁忙型、I/O繁忙型、批量型、终端型等）、作业状态、调度信息（优先级、作业运行时间）、资源需求（预计运行时间、要求内存大小等）、已申请到资源的使用情况。</p><h3 id="作业运行的三个阶段"><a href="#作业运行的三个阶段" class="headerlink" title="作业运行的三个阶段"></a>作业运行的三个阶段</h3><ul><li><p>收容阶段：每一个作业进入系统时（即输入到硬盘），便由“作业注册”程序为该作业建立一个作业控制块JCB并把它放入作业后备队列中。</p></li><li><p>运行阶段：后备队列中的作业被选中后，系统会为其分配必要的资源和建立进程，然后将其放入就绪队列。一个作业从第一次进入就绪状态开始到它运行结束前都是处于运行阶段。</p></li><li><p>完成阶段：当作业完成或发生异常而终止时，作业便处于完成阶段，此时系统会撤销进程和资源，并将运行结果通过某种方式输入，如输出到文件中。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/批处理系统调度.jpg"></div></li></ul><h3 id="先来先服务算法"><a href="#先来先服务算法" class="headerlink" title="先来先服务算法"></a>先来先服务算法</h3><p>First-Come First-served，FCFS。每次调度都是选择一个或多个最先进入队列的作业或进程，为它们分配资源，创建进程和分配CPU，使之投入运行。它是最简单的调度算法，同时也可用于进程调度。效率不高，所以一般不作为主调度算法。</p><p>适用于CPU繁忙型而不适用于I/O繁忙型。因为CPU繁忙型长时间占用CPU很少有I/O操作，一旦获得CPU，就会运行很长时间，就是会长时间占用CPU，而I/O繁忙型由于要频繁访问IO端口，每次访问都要放弃CPU，等I/O访问完后要重新等待下一次调度（此时排到了就绪队列的队尾），所以要等待很久才能重新被调度。因此先来先服务有利于CPU繁忙型而不利于I/O繁忙型。</p><h3 id="短作业优先算法"><a href="#短作业优先算法" class="headerlink" title="短作业优先算法"></a>短作业优先算法</h3><p>Short Job First，SJF。指对短作业优先调度的算法，它从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。</p><p>此种算法对长作业非常不利而且实际使用上很难预估每个作业的运行时间。</p><h3 id="静态优先级调度算法"><a href="#静态优先级调度算法" class="headerlink" title="静态优先级调度算法"></a>静态优先级调度算法</h3><p>为照顾紧迫性作业，使之进入系统后获得优先处理，引入优先级调度算法。按照进程的优先级大小来调度，使高优先级进程得到优先处理的策略称为优先权调度算法。</p><p>静态优先级调度算法是指在输入前作业为其赋予优先级且一直保持不变。虽然可以照顾紧迫性作业，但是没有考虑到作业本身的运行时间和作业的等待时间等，所以产生了更好的动态优先级算法。</p><h3 id="高响应比算法"><a href="#高响应比算法" class="headerlink" title="高响应比算法"></a>高响应比算法</h3><p>高响应比算法是动态优先级算法的一种，其中$优先级 = \frac{响应时间}{要求服务时间} = \frac{等待时间+要求服务时间}{要求服务时间}$。这样可以得到：</p><ul><li>对于短作业：其要求服务时间短，优先级相对较高。</li><li>对于长作业：在等待一段时间之后，其优先级会增长，直至够高而能获得服务。</li><li>对于先来作业：假如在某一时刻其仍未获得服务，和后来的作业相比其优先级相对较高。</li></ul><p>相应时间与周转时间的对比，假如作业运行完了，两者相等，假如没有则 $响应时间&lt;周转时间$</p><ul><li>周转时间：从作业进入系统到作业完成退出系统所用的时间。</li><li>响应时间：等待时间+要求服务时间。</li></ul><h2 id="低级调度"><a href="#低级调度" class="headerlink" title="低级调度"></a>低级调度</h2><h3 id="进程调度的任务和机制"><a href="#进程调度的任务和机制" class="headerlink" title="进程调度的任务和机制"></a>进程调度的任务和机制</h3><ul><li>保存处理机的现场信息：比如程序计数器、通用寄存器里的内容。</li><li>按某种算法选取进程。</li><li>把处理机分配给进程：把选中进程的PCB中的有关处理机调度的信息装入处理器的寄存器中，把处理器的控制权交给进程使其能从上次的断点处恢复运行。</li></ul><h3 id="进程调度机制"><a href="#进程调度机制" class="headerlink" title="进程调度机制"></a>进程调度机制</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/进程调度机制.jpg"></div><br>- 排队器：每当有进程转入就绪状态时，排队器会将它插入到相应的就绪队列。<br>- 分派器：分派器依据进程调度程序（更直接的说，进程调度算法）所选定的进程，将其从就绪队列中取出。<br>- 上下文切换器：会产生两次上下文切换：<br>- 旧进程和分配程序之间的切换；<br>- 分配程序和新进程之间的切换。<br><br>排队器、分派器、上下文切换器本身也是程序，但是它们是处于系统态的程序，而被调度的进程一般是用户态的程序，从系统态到用户态进行上下文切换需要很大的耗费，所以一般采用两组（或多组）寄存器，一组用于处理机在系统态时使用，一组用于系统在用户态时使用，这样在系统态和用户态之间切换时就可以只改变指针（用于从寄存器中存取数据和指令）使其指向指定寄存器就行。<br><br><br><br>### 进程调度方式<br><br>### 非抢占方式<br><br>一旦某进程获得处理机，就会一直运行下去，直至该进程完成或者因发生某种事件而被阻塞其他进程才能获得处理机。此时引起进程调度的因素：<br><br>- 正在执行的进程运行完毕。<br>- 外部环境的改变使其不能再继续运行，如程序运行发生异常。<br>- 进程通信或进程同步时执行了某种原语，如<code>Block</code>。<br>- 正在执行的进程发出I/O请求。<br><br><br><br>### 抢占方式<br><br>允许调度程序根据某种原则去暂停某个正在执行的进程，将处理机分配给其他进程。这些原则一般有三种：<br><br>- 高优先级原则；<br>- 短进程优先原则；<br>- 时间片原则。<br><br>我们后面所提到的进程调度算法其实都是抢占方式下的策略。<br><br><br><br>## 轮转调度算法<br><br>将CPU的处理时间分成固定大小的时间片q， q的大小从几ms到几百ms。系统将所有就绪进程按先来先服务的原则排成队列。每次调度时，把CPU分配给队首进程，令其执行一个时间片，时间片用完后若进程未结束，则送回就需队列尾部重新调度，在一给定的时间内，就绪进程均能获得一时间片的执行时间。<br><br>此时时间片大小是关键问题，一般来说时间片q正比于响应时间，反比于就绪进程数目。计算机的处理能力。速度快，q可小些。通常q值是这样决定的：<br><br>- 批处理系统:80%的CPU周期在一个时间片内完成<br>- 分时系统：$q=T/N_{max}$，（$T-响应时间上限，N_{max}-最大进程数$）<br><br><br><br>## 优先级调度算法<br><br>### 非抢占式优先级调度算法<br><br>即一旦某个高优先级的进程占有了处理机，就一直运行下去，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件）才让另一高优先级进程运行。主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。<br><br><br><br>### 抢占式优先级调度算法<br><br>任何时刻都严格按照高优先级进程在处理机上运行的原则进行进程的调度。常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。<br><br><br><br>#### 静态优先权<br><br>静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，这些整数被称为优先数。确定优先权大小的依据：<br><br>- 进程类型；<br>- 进程对资源的需求；<br>- 用户要求。<br><br><br><br>#### 动态优先权<br><br>动态优先权是指，在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得<br>更好的调度性能。例如，我们可以规定，在就绪队列中的进程，随其等待时间的增长，其优先权以速率<code>a</code>提高。若所有的进程都具有相同的优先权初值，则显然是最先进入就绪队列的进程，将因其动态优先权变得最高而优先获得处理机，此即<code>FCFS算法</code>。若所有的就绪进程具有各不相同的优先权初值，那么，对于优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机。当采用抢占式优先权调度算法时，如果再规定当前进程的优先权以速率b下降，则可防止一个长作业长期地垄断处理机。<br><br><br><br>## 多队列调度算法<br><br>之前介绍的调度算法都是用一个算法来解决所有的进程调度，这样无法满足系统中不同用户对进程调度策略的不同要求。而多队列调度算法就是将就绪队列从一个分成多个，将不同性质或类型的进程放在不同的就绪队列，这样不同的队列之间设置优先级，和队列内部也可以设置优先级，能更好的满足用户的需求。<br><br>同时在多处理机系统中，可以方便的给每个处理机设置单独的就绪队列。<br><br><br><br>## 多级反馈队列调度算法<br><br>1. 设置多个就绪队列，每个队列赋予不同的优先级，一个队列的优先级最高，第二个队列次之，其余各队列的优先级逐个降低，各队列内部使用FCFS原则排列。<br>2. 优先级越高的进程时间片越短。<br>3. 当一个进程进入内存后，首先放在第一队列的尾部，按FCFS的原则调度，如果该时间片内未结束，进程调度时将此进程转入第二队列队尾，直至第N个对列，若进程仍未结束，在第N个对列上采用时间片轮转算法。<br>4. 仅当第<code>i</code>队列空闲时才调度第<code>i+1</code>队列，如果有新进程进入优先级较高的队列，剥夺CPU执行新进程，旧进程放入原队列尾部。<br><br>此算法不必事先知道各进程执行的所需时间，可满足各种进程需要，是目前公认较好的进程调度算法。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/多级队列反馈调度算法.jpg"></div><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>第<code>i</code>个对列的时间片为$2^{i-1}$。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/多级反馈队列.jpg"></div><h2 id="基于公平原则的调度算法"><a href="#基于公平原则的调度算法" class="headerlink" title="基于公平原则的调度算法"></a>基于公平原则的调度算法</h2><h3 id="保证调度算法"><a href="#保证调度算法" class="headerlink" title="保证调度算法"></a>保证调度算法</h3><p>保证每个进程都获得相同的处理机时间：</p><ol><li>跟踪计算每个进程自创建以来已经执行的时间。</li><li>计算每个进程应该获得的处理机时间，即自创建以来的时间除以n。</li><li>比较各进程获得处理机时间的比率，即实际执行时间除以应获得的处理机时间。</li><li>比较各进程获得处理机时间的比率，如A：0.5；B：0.9；C：1.2。</li><li>调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率，然后把处理机让给此时比率最小的进程。</li></ol><h3 id="公平调度算法"><a href="#公平调度算法" class="headerlink" title="公平调度算法"></a>公平调度算法</h3><p>在上个算法中，如果用户A有4个进程，用户B有1各进程，那用户A获得处理机的时间是用户B的四倍。而公平调度算法的目标是保证每个用户都获得相同的处理机时间。</p><h2 id="实时调度"><a href="#实时调度" class="headerlink" title="实时调度"></a>实时调度</h2><p>实时调度必须能满足实时任务对截止时间的要求。所以实时任务的算法和优先级算法有些区别。</p><h3 id="实时算法的分类"><a href="#实时算法的分类" class="headerlink" title="实时算法的分类"></a>实时算法的分类</h3><h4 id="非抢占式调度算法"><a href="#非抢占式调度算法" class="headerlink" title="非抢占式调度算法"></a>非抢占式调度算法</h4><ul><li>非抢占式轮转调度算法；</li><li>非抢占式优先调度算法。</li></ul><h4 id="抢占式调度算法"><a href="#抢占式调度算法" class="headerlink" title="抢占式调度算法"></a>抢占式调度算法</h4><ul><li>基于<a href="https://isjinhao.github.io/2019/%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD/#more">时钟中断</a>的抢占式优先级调度算法：在某实时任务到达后，如果它的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断发生时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先级任务。</li><li>立即抢占式优先级调度算法：一旦出现外部中断，只要当前任务未处于临界区，便立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/实时调度.jpg"></div><br>### 最早截止时间优先算法<br><br>Earliest Deadline First，EDF。可用于非抢占式算法，也可用于抢占式算法。<br><br>#### 非抢占式<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/非抢占式EDF.jpg"></div><br>#### 抢占式<br><br>有两个周期任务，A、B的周期分别是20ms，50ms。A、B的执行时间分别是10ms和25ms。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/抢占式EDF.jpg"></div><br>### 最低松弛度优先即算法<br><br>Least Laxity First，LLF。$松弛度=截止时间-当前时间-任务执行时间$。主要用于抢占式调度。<br><br><br><br>#### 例<br><br>有两个周期任务，A、B的周期分别是20ms，50ms。A、B的执行时间分别是10ms和25ms。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/LLF.jpg"></div><h2 id="优先级倒置"><a href="#优先级倒置" class="headerlink" title="优先级倒置"></a>优先级倒置</h2><p>即高优先级进程（或线程）被低优先级（或线程）延迟或阻塞。例，假如有三个完全独立的进程P1、P2和P3，优先级P1&gt;P2&gt;P3。P1和P3通过共享一个临界资源进行交互。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P1：...P(mutex); CS<span class="number">-1</span>; V(mutex);... </span><br><span class="line">P2: ...Program2...;</span><br><span class="line">P3：...P(mutex); CS<span class="number">-3</span>; V(mutex);...</span><br></pre></td></tr></table></figure><p>假如P3最先执行，在执行了P(mutex)操作后，进入临界区CS-3。在时刻a，P2就绪，因为它比P3的优先级高，P2抢占了P3的处理机而运行，在时刻b，P1就绪，因为它比P2的优先级高，抢占处理机执行，但P1执行P(mutex)之后被阻塞，处理机被P2获得，P2执行结束后，P1仍不能进入临界区，处理机被P3获得，等P3退出临界区，P1才能获得处理机。所以本应该高优先级的P1优先执行，但是由于存在临界资源而导致优先级倒置。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/优先级倒置.jpg"></div><h3 id="优先级倒置的解决"><a href="#优先级倒置的解决" class="headerlink" title="优先级倒置的解决"></a>优先级倒置的解决</h3><p>遵循动态优先级继承原则：当高优先级进程P1要进入临界区去使用临界资源，如果已经有一个低优先级进程P3正在使用该资源，此时一方面P1被阻塞，一方面P3继承P1的优先级并一直保持到P3退出临界区。这样做就能保证不会有比P3优先级高但比P1优先级低的进程插进来。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/优先级倒置.jpg"></div><h2 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h2><h3 id="可重用资源和消耗性资源"><a href="#可重用资源和消耗性资源" class="headerlink" title="可重用资源和消耗性资源"></a>可重用资源和消耗性资源</h3><ul><li>可重用性资源：可供用户重复使用多次的资源。特点：<ul><li>互斥访问</li><li>系统中此资源数目相对固定</li><li>系统中大多数资源属于此类</li></ul></li><li>可消耗性资源：临时性资源<ul><li>由进程动态创建和消耗，数目是可以不断变化的，比如信号量、进程通信的信息等。</li></ul></li></ul><h3 id="可抢占性资源和不可抢占性资源"><a href="#可抢占性资源和不可抢占性资源" class="headerlink" title="可抢占性资源和不可抢占性资源"></a>可抢占性资源和不可抢占性资源</h3><ul><li>可抢占性资源：CPU和主存，不会引起死锁。</li><li>不可抢占性资源：只能进程自行释放。如打印机，因为如果打印到一半，打印机被抢占，造成的结果只能是此次打印作废，所以它是不可抢占资源。</li></ul><h2 id="死锁定义"><a href="#死锁定义" class="headerlink" title="死锁定义"></a>死锁定义</h2><p>如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/死锁举例.jpg"></div><h2 id="死锁的起因"><a href="#死锁的起因" class="headerlink" title="死锁的起因"></a>死锁的起因</h2><h3 id="竞争不可抢占性资源引起死锁"><a href="#竞争不可抢占性资源引起死锁" class="headerlink" title="竞争不可抢占性资源引起死锁"></a>竞争不可抢占性资源引起死锁</h3><p>一个资源只能同时被一个进程使用，但是下图P1在获得R1后还去申请R2，同时P2获得R2后还去申请R1，陷入僵局，引发死锁。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/竞争不可抢占资源.jpg"></div><h3 id="竞争可消耗性资源引起死锁"><a href="#竞争可消耗性资源引起死锁" class="headerlink" title="竞争可消耗性资源引起死锁"></a>竞争可消耗性资源引起死锁</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">P1：receive(p3,m3)； send(p2,m1)；</span><br><span class="line">P2：receive(p1,m1)； send(p3,m2)；</span><br><span class="line">P3：receive(p2,m2)； send(p1,m3)；</span><br></pre></td></tr></table></figure><p>如上代码，P1在等待P3给P1发消息，P2在等待P1给它P2发消息，P3在等待P2给P3发消息。造成一个死循环。</p><h3 id="进程推进顺序非法"><a href="#进程推进顺序非法" class="headerlink" title="进程推进顺序非法"></a>进程推进顺序非法</h3><p>在下图中，X轴表示进程P1推进图，Y轴表示进程P2推进图。如果按照4号路线推进，可以看出P1在经过b、d段的执行之后，获得R1，P2在进过a、c、e段的执行之后获得R2。此时如果不加以处理，系统一定会进入死锁状态，因为接下来P1在拥有R1后又去申请R2，P2在拥有R2后又去申请R1。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/进程推进顺序非法.jpg"></div><h2 id="死锁产生的必要条件"><a href="#死锁产生的必要条件" class="headerlink" title="死锁产生的必要条件"></a>死锁产生的必要条件</h2><ul><li>互斥条件：某段时间内，某资源只能由一个进程使用；</li><li>请求和保持条件：进程因请求资源而阻塞时，对已分配给它的资源保持不放；</li><li>不可抢占条件 ：资源在未使用完前，不能被剥夺，由使用进程释放；</li><li>循环等待条件 ：发生死锁时，有向图必构成一环路。</li></ul><h2 id="死锁处理"><a href="#死锁处理" class="headerlink" title="死锁处理"></a>死锁处理</h2><p>共有三类做法：</p><ul><li><p>第一类是预防死锁，也就是破坏死锁产生的条件（破坏其中一个就可以），这样系统就永远不会产生死锁。</p></li><li><p>第二类是死锁避免，死锁产生的根本原因是系统资源分配出现问题，如果能进行合理的资源分配就能避免死锁的发生。</p></li><li><p>第三类是死锁发生后的检测和解除。</p></li></ul><h2 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h2><p>预防死锁是给系统施加一个条件使其永远不可能满足死锁产生的必要条件，但是互斥条件是不能被破坏的条件，所以预防死锁有三类做法：</p><h3 id="破坏“请求和保持”条件"><a href="#破坏“请求和保持”条件" class="headerlink" title="破坏“请求和保持”条件"></a>破坏“请求和保持”条件</h3><p>即进程在请求资源时，它不能持有不可抢占资源。有两种做法：</p><ol><li>所有进程在开始运行之前，一次性的申请其在整个运行过程中的全部资源，如果申请成功，进程便陷入等待。这样进程在运行的时候就不会再发出请求。</li><li>进程在只获得运行初期所需的资源后便开始运行，但是进程在运行过程中需要逐步释放以分配给自己的资源，等初期获得所有资源都被释放后才能请求其他资源。</li></ol><h3 id="破坏“不可抢占”条件"><a href="#破坏“不可抢占”条件" class="headerlink" title="破坏“不可抢占”条件"></a>破坏“不可抢占”条件</h3><p>当进程保持了某些不可被抢占资源，且提出的新需求又不能被满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这种预防策略的代价非常昂贵，比如进程请求的打印机被强制剥夺后，之前的工作等于作废。</p><h3 id="破坏“循环等待”条件"><a href="#破坏“循环等待”条件" class="headerlink" title="破坏“循环等待”条件"></a>破坏“循环等待”条件</h3><p>常见的方法是“资源有序分配”。其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号升序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程，在拥有大编号资源再申请小编号资源时需要释放和小资源编号相等及以上的编号。</p><h2 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h2><p>避免死锁讲道理是属于死锁的预防，但是它和预防死锁不同，预防死锁是破坏死锁产生的条件，避免死锁是防止系统进入不安全状态。所以我们就要明白什么是安全状态，它和死锁产生的必要条件有什么区别。</p><h3 id="安全状态"><a href="#安全状态" class="headerlink" title="安全状态"></a>安全状态</h3><p>安全状态指的是系统能按某种进程推进顺序<code>(P1, P2, …, Pn)</code>为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。此时，序列<code>(P1, P2, …, Pn)</code>为安全序列。如果系统无法找到这样一个序列，则称系统处于不安全状态。</p><p>为什么能找到这样的序列系统就是安全的呢？其实它是一个递推的关系，假如系统在时刻<code>i</code>发起申请资源请求，其此时状态为<code>a</code>，系统会判断它申请成功后是否还能寻找到一个安全序列，如果能找到便可以分配，否则便是系统不安全状态。假如系统申请到了资源，还想发出申请请求，便会再次判断请求成功之后能否找到安全序列，由此递推下去可保证整个系统能避免死锁。</p><h3 id="安全状态和死锁必要条件的区别"><a href="#安全状态和死锁必要条件的区别" class="headerlink" title="安全状态和死锁必要条件的区别"></a>安全状态和死锁必要条件的区别</h3><p>仍以此图为例。假如我们采用的是预防死锁策略中的破坏“请求和保持”条件里的第一个做法，那么推进顺序就不可能为4，因为进程P1在执行的时候需要获取全部资源才能执行。但对于避免死锁来说，系统可以按照4号推进顺序推进到e段和阴影区的交界处，然后进程P2在申请资源R2的时候会去判断分配R2给P2之后系统能否找到安全序列，事实上是找不到的，所以R2便不会分配给P2，这样系统就进入不了阴影区，从而可以避免死锁。</p><p>所以预防死锁和避免死锁的区别是：</p><ul><li>预防死锁是每个进程在执行之前确保其自身不陷入死锁状态，如果每个进程都能不陷入死锁状态，系统便能永远安全。即从单个进程角度静态解决问题。</li><li>但避免死锁是在每一次进行资源分配时判断分配之后是否系统处于安全状态，如果处于安全状态便可分配，否则便不能分配。即从系统整体角度动态解决问题。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/进程推进顺序非法.jpg"></div><br>### 银行家算法<br><br>#### 数据结构<br><br>1. 可利用资源向量$Available$：是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果$Available[j]=K$，则表示系统中现有$R_j$类资源K个。<br>2. 最大需求矩阵$Max$：这是一个$n×m$的矩阵，它定义了系统中$n$个进程中的每一个进程对$m$类资源的最大需求。如果$Max[i, j]=K$，则表示进程$i$需要$R_j$类资源的最大数目为K。<br>3. 分配矩阵$Allocation$：这也是一个$n×m$的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果$Allocation[i,j]=K$，则表示进程i当前已分得$R_j$类资源的 数目为K。<br>4. 需求矩阵$Need$：这也是一个$n×m$的矩阵，用以表示每一个进程尚需的各类资源数。如果$Need[i,j]=K$，则表示进程$i$还需要$R_j$类资源K个，方能完成其任务。<br><br>可得：$Need[i,j]=Max[i,j]-Allocation[i,j]$<br><br><br><br>#### 算法<br><br>设进程$cusneed$提出请求$REQUEST[i]$，则银行家算法按如下规则进行判断。<br><br>1. 如果$REQUEST[cusneed] [i]&lt;= Need[cusneed][i]$，则转2；否则，出错。<br>2. 如果$REQUEST [cusneed] [i]&lt;= Available[i]$，则转3；否则，等待。<br>3. 系统试探分配资源，修改相关数据：<br>1. $Available[i]-=REQUEST[cusneed][i]$;<br>2. $Allocation[cusneed][i]+=REQUEST[cusneed][i]$;<br>3. $Need[cusneed][i]-=REQUEST[cusneed][i]$;<br>4. 系统执行安全性检查算法，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。<br><br>#### 安全性算法<br><br>1. 设置两个工作向量$Work=Available$、$Finish=false$。<br>2. 从进程集合中找到一个满足下述条件的进程$i$，$Finish[i]==false;$$Need[i, j]&lt;=Work[j];$，如找到，执行3；否则，执行4。<br>3. 设进程获得资源，可顺利执行，直至完成，从而释放资源。$Work[i]=Work[i]+Allocation[i,j];$，$Finish[i]=true;$，循环2。<br>4. 如所有的进程$Finish= true$，则表示安全；否则系统不安全。<br><br>#### 举例<br><br>- 假定系统中有五个进程$\lbrace P0, P1, P2, P3, P4\rbrace$和三类资源$\lbrace A,B, C\rbrace$，各种资源的数量分别为10、5、7，在$T0$时刻的资源分配情况如图所示。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/T0.jpg"></div><br>- $T0$时刻的安全性<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/T1.jpg"></div><br>- $P1$请求资源：$P1$发出请求向量$Request1(1,0,2)$，系统按银行家算法进行检查。<br>- $Request_1(1, 0, 2)≤Need_1(1, 2, 2)$<br>- $Request_1(1, 0, 2)≤Available_1(3, 3, 2)$<br>- 系统先假定可为$P1$分配资源，并修改$Available,Allocation_1和Need_1$向量。由此得到的资源变换情况如上上图括号所示。<br>- 再利用安全性算法检查此时系统是否安全。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/T2.jpg"></div><br>- $P4$请求资源：$P4$发出请求向量$Request_4(3,3,0)$，系统按银行家算法进行检查。<br><br>- $Request_4(3, 3, 0)≤Need_4(4, 3, 1);$。<br>- $Request_4(3, 3, 0)&gt;Available(2, 3, 0)$，让$P4$等待。<br><br>- $P0$请求资源：$P0$发出请求向量$Requst_0(0,2,0)$，系统按银行家算法进行检查。<br><br>- $Request_0(0, 2, 0)≤Need_0(7, 4, 3);$<br>- $Request_0(0, 2, 0)≤Available(2, 3, 0);$<br>- 系统暂时先假定可为$P0$分配资源，并修改有关数据，如下图所示。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/T3.jpg"></div><ul><li>进行安全性检查：此时可用资源$Available(2,1,0)$已经不能满足任何进程的需要，进入不安全状态，因此系统不分配资源。</li></ul><h3 id="死锁的检测和解除"><a href="#死锁的检测和解除" class="headerlink" title="死锁的检测和解除"></a>死锁的检测和解除</h3><h4 id="死锁的检测"><a href="#死锁的检测" class="headerlink" title="死锁的检测"></a>死锁的检测</h4><p>在图中找一既非阻塞又非独立的进程节点$P_i$，如顺利，$P_i$可获得所有资源直至运行完毕。消去$P_i$所有的请求边和分配边，即释放占有的所有资源，同理再选下一进程节点$P_{i+1}, …, $若能消去所有的边，那么该图是可完全简化的，否则该图是不可完全简化的。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/死锁的检测.jpg"></div><br>具体做法如下：<br><br>1. 可利用资源向量$Available[]$，它表示了m类资源中每一类资源的可用数目。<br>2. 把不占用资源的进程（向量$Allocation[i]∶= 0$）记入L表中，即$L_i \bigcup L$。<br>3. 从进程集合中找到一个$Request_i≤Work$的进程，做如下处理：<br>1. 将其资源分配图简化，释放出资源，增加工作向量$Work∶ =Work+Allocation_i$。<br>2. 将它记入L表中。<br>4. 若不能把所有进程都记入L表中， 便表明系统状态S的资源分配图是不可完全简化的。 因此，该系统状态将发生死锁。<br><br><br><br>#### 死锁的解除<br><br>死锁解除有多种做法，如下是按代价递减排序的几种。<br><br>1. 撤销所有死锁的进程。<br>2. 将每个进程回退到先前定义的某个检查点，再重新启动所有进程。<br>3. 逐个撤销死锁进程，直至死锁不存在。撤销进程的顺序应是基于某种最小代价原则，每次撤销后，死锁检测算法应该重新检测死锁是否依然存在。<br>4. 剥夺进程P的资源交给进程Q，P同时会退到获得此资源的节点上。<br><br>对于3和4，选择的标准可以如下：<br><br>- 以占用处理器的时间最小；<br>- 以产生的输出少；<br>- 所估计的剩余运行时间最长；<br>- 所占用的资源最少；<br>- 优先权最低。<br><br><br><br>## 存储器的层次<br><br>我们都知道存储器的容量和速度是限制计算机发展的一大原因，人们对存储器的要求需要既快又大，但是这样带来的结果就是存储器的造价非常昂贵，所以不可能在计算机中全部配置既快又大的存储器。所以现代的计算机系统中都配置了多层结构的存储器系统来平衡速度差异问题。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/存储器分级.jpg"></div><br>存储器一般被分成六层，不过在只有前四层属于内存，所以此篇只介绍前四层：<br><br><br><br>### 主存储器<br><br>- 用于保存进程运行时的程序和数据。<br>- 对于微机系统和大中型机，容量为数十MB到数GB；对于嵌入式系统，容量为数十KB到数MB。<br>- CPU从主存读取指令和数据。<br>- CPU与外设交换信息要依托主存。<br>- 为缓解CPU执行指令速度和主存访问速度的矛盾，引入寄存器和高速缓冲。<br><br><br><br>### 寄存器<br><br>- 访问速度做快，完全与CPU协调工作，价格十分昂贵，容量不可能很大。<br>- 长度一般以字为单位。<br>- 对于微机系统和大中型机，可能有几十个甚至上百个；对于嵌入式系统，仅有几个到几十个。<br><br><br><br>### 高速缓冲<br><br>- 容量大于或远大于寄存器，比内存小两到三个数量级左右，从几十KB到几MB。<br>- 访问速度快于主存。<br>- 将主存中经常访问的信息存放在高速缓冲，减少访问主存次数。<br><br><br><br>### 磁盘缓冲<br><br>- 将一部分频繁使用的磁盘数据和信息，暂时存放在磁盘缓冲中，减少访问磁盘次数。<br>- 不是实际存在的存储介质，利用主存的存储空间，暂存从磁盘读出或写入的信息。<br><br><br><br>总结一下：磁盘缓冲是为了解决内存和外存的速度差异而在内存中开辟的一块用于暂存磁盘数据的存储介质。主存储器是保存进程运行时的程序和数据的。寄存器是和CPU速度匹配的存储器，直接给CPU提供数据。虽然CPU是直接从寄存器去取指令和数据，但是寄存器的数据来源最终还是主存储器，所以为了减少访问CPU的次数，产生了高速缓冲来缓和寄存器和主存储器的矛盾。至于为什么能缓和呢？这是由于<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86/15572003" target="_blank" rel="noopener">程序局部性原理</a>。<br><br><br><br>## 程序的装入和链接<br><br>用户程序要在系统中运行，必须将它装入内存，其中有三个过程。<br><br>- 编译：由编译程序（Complier）将用户源代码编译成若干个目标模块（Object Module）；<br>- 链接：由链接程序（Linker）将编译后形成的目标模块以及它们所需要的库函数，链接在一起，形成一个装入模块（Load Module）；<br>- 装入：由装入程序(Loader)将装入模块装入内存。<br><br><br><br>### 链接<br><br>链接程序的功能是将经过编译或汇编后得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块。<br><br>#### 静态链接方式<br><br>生成可执行文件时进行链接。主要有两步。<br><br>1. 修改相对地址。<br>2. 变换外部调用符号。<br><br>#### 装入时动态链接<br><br>目标模块是在装入内存时，边装入边链接的。装入时动态链接方式有以下优点：<br><br>- 便于修改和更新。<br>- 便于实现对目标模块的共享。<br><br>#### 运行时动态链接<br><br>将对某些模块的链接推迟到执行时才执行，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存， 把它链接到调用者模块上。<br><br>凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。<br><br><br><br>### 装入<br><br>装入是将一个具有执行资格的模块加载进内存。<br><br>#### 绝对装入方式<br><br>在可执行文件中指定内存地址，装入时直接定位在上述（即文件中记录的地址）内存地址。逻辑地址和物理地址完全相同。<br><br>#### 可重定位装入方式<br><br>编译程序所生成的目标模块中采用逻辑地址，根据当前内存情况，将装入模块装入到适当位置。地址映射是在装入模块装入内存时一次性进行的，即是静态重定位。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/静态重定位.jpg"></div><br>#### 动态运行时装入方式<br><br>静态重定位时程序装入内存后不能移动，而且通常需要占用连续的内存空间。所以与其对应的动态重定位是将地址映射工作推迟到程序真正执行时才进行。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/动态重定位.jpg"></div><h3 id="现代计算机运行过程"><a href="#现代计算机运行过程" class="headerlink" title="现代计算机运行过程"></a>现代计算机运行过程</h3><ul><li><p>预处理</p><ul><li>把存储在不同文件中的源程序聚合在一起。</li><li>把被称为宏的缩写语句转换为原始语句。</li></ul></li><li><p>编译：将高级语言翻译成汇编语言或机器语言。</p></li><li><p>链接</p><ul><li>将多个可重定位的机器代码文件（包括库文件）连接到一起。</li><li>解决外部内存地址（一个文件中的代码会引用其他文件中的数据对象或过程，这些数据对象或过程的地址对于此文件来说就是外部地址）问题。</li></ul></li><li><p>装入</p><p>确定程序在内中的绝对地址（即修改程序起始地址），将修改后的指令和数据放到内存中适当的位置。</p></li></ul><h2 id="连续分配存储管理方式"><a href="#连续分配存储管理方式" class="headerlink" title="连续分配存储管理方式"></a>连续分配存储管理方式</h2><p>连续分配是指为一个用户程序分配空间的时候，将所有程序装入到一段连续的物理内存中。在早期（20世纪60-80<br>年代）的操作系统中，这种分配内存的方式曾经被广泛的使用。</p><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>这是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。内存分为以下两个分区：系统区和用户区。操作系统使用系统区；应用程序装入到用户区，可使用用户区全部空间。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/单一连续分配.jpg"></div><h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>固定分区式分配，是最早使用的一种可运行多道程序的存储管理方式。它将内存空间划分为若干个固定大小的区域，每个分区大小可相同，也可不同。OS占一区，其余每个分区中可以装入一道作业。</p><p>为了便于内存分配，系统需建立一张分区使用表。当有一用户程序要装入时，从表中找出一个能满足要求的、尚未分配的分区分配给该程序，然后修改分区使用表。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/固定分区分配.jpg"></div><h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><ul><li>空闲分区表<ul><li>每个空闲分区占用一个表项。</li><li>分区表的表项中包含分区号、分区始址及分区大小等表目。</li><li>表长不易确定。</li><li>占用额外内存。</li></ul></li><li>空闲分区链表<ul><li>利用各空闲分区自身的单元组成双向链表。</li><li>操作速度较慢。</li></ul></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/动态分区数据结构.jpg"></div><br>#### 分区分配<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/分区分配.jpg"></div><br>#### 分区回收<br><br>- 如果回收区的前后有空闲区，可分为图示三种情况。回收时将空闲区和回收区合并。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/分区回收.jpg"></div><br>- 如果回收区的前后无空闲区，新建一个表项，填写信息插入。<br><br><br><br>#### 分区检索算法<br><br>##### 顺序检索算法<br><br>- 首次适应算法：按各空闲分区首址的升序的方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从头查找，找到符合要求的第一个分区。<br>- 循环首次适应算法：分配空闲空间时，不是从链首（或表头）开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找。<br>- 最佳适应算法：按空闲区大小的升序方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从<br>头查找，找到符合要求的第一个分区。就说明它是最适合的（即最佳的）。<br>- 最坏适应算法：按空闲区大小的降序方法组织，分配时总是取空闲分区表（或空闲分区链）中的第一项，<br>若大小不能满足申请者的要求，则表示系统中无满足要求的空闲区，分配失败；否则分配。<br><br><br><br>##### 索引检索算法<br><br>- 快速适应算法：将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应一种空闲分区类型，并记录其表头指针。空闲分区的分类是根据进程常用的空间大小进行划分，对于其他大小的分区，可以放在一个特殊的空闲区链表中。<br>- 伙伴系统：分区大小均为2的K次幂。假设系统可利用空间容量为$2^m$个字，系统运行过程中，不断划分，将空闲分区根据大小分类。为长度为n的进程分配分区时，首先计算$i$值使得$2^{i-1}≦n≦2^i$。先找大小为$2^i$的分区分配，否则找大小为$2^{i+1}$的分区分配，把$2^{i+1}$分区分成两个$2^i$分区（互称伙伴），一个分配，另一个加入$2^i$的空闲分区链表。分配可能经过多次分割，回收可能进行多次合并。<br>- 哈希算法：根据空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最近分配策略。<br><br>#### 紧凑<br><br>可变式分区也有零头问题。在系统不断地分配和回收中，必定会出现一些不连续的小的空闲区，称为外零头。虽然可能所有零头的总和超过某一个作业的要求，但是由于不连续而无法分配。解决零头的方法是拼接（或称紧凑），即向一个方向（例如向低地址端）移动已分配的作业，使那些零散的小空闲区在另一方向连成一片。分区的拼接技术，一方面是要求能够对作业进行重定位，另一方面系统在拼接时要耗费较多的时间。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/紧凑.jpg"></div><h2 id="分页存储管理方式"><a href="#分页存储管理方式" class="headerlink" title="分页存储管理方式"></a>分页存储管理方式</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li><p>页面：将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。</p></li><li><p>物理块：把内存空间分成与页面相同大小的若干个存储块，称为（物理）块或页框（frame）。</p></li><li><p>页面碎片：由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。</p></li><li><p>页面大小：每一页可进行编址的地址数目。页面大小应该<a href="https://isjinhao.github.io/2019/为什么分页存储管理页面大小是2的n次幂/#more">满足2的n此幂</a>。</p></li><li><p>逻辑地址：</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/分页逻辑地址.jpg"></div></li><li><p>页表：系统为每个进程建一张页表，其在内存的起始地址和长度记录在该进程的PCB中。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/页表.jpg"></div></li><li><p>页表项：页表的每一行。</p></li><li><p>页表项长度：每个页表项占用的编址个数。从逻辑地址那里我们可以看到页号占用了20位，对应的块号也要占用20位，当然块号本身可能不止$2^{20}$个。又由于为了控制对物理块的读写等操作，会在页表项中加上控制字段。如果内存按字节编址，即每个编址可以存储8个二进制位，那么页表项占用的二进制位总数大于内存的字长度。我们需要把一个页表项拆开存放在多个编址后的空间中。</p></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/页表项.jpg" style="width:80%"></div><br>### 地址变换<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/页表基本地址变换.jpg"></div><br>$物理地址=块号+块内地址=F(逻辑地址的页号*页表项长度+页表始址)+业内地址$。<br><br>每次进行地址变换需要访问两次内存，内存速度较慢，所以影响计算机整体性能。<br><br><br><br>### 具有快表的地址变换<br><br>根据程序局部性原理，把最近使用的页表项存放在快表中，下次再进行地址变换时先去快表中查找对应项，如果没找到再去内存中查找，然后把新找到的页表项存放在快表中，如果快表已满，采用某种算法淘汰一份。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/具有快表的页表地址变换.jpg"></div><h3 id="有效访问时间"><a href="#有效访问时间" class="headerlink" title="有效访问时间"></a>有效访问时间</h3><p>设t是访问内存的时间，a是快表命中率，λ是查找快表所需的时间。</p><ul><li>普通地址变换时间：<code>t+t</code></li><li>具有快表的地址变换时间：$ a \ast \lambda + (1-a) \ast (t+\lambda)$。</li></ul><h3 id="两级页表"><a href="#两级页表" class="headerlink" title="两级页表"></a>两级页表</h3><p>对于两级页表，是将页表再进行分页，页面的大小与内存物理块的大小相同。逻辑地址结构可描述如下：</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/两级页表.jpg"></div><h3 id="两级页表地址变换"><a href="#两级页表地址变换" class="headerlink" title="两级页表地址变换"></a>两级页表地址变换</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/两级页表地址变换.jpg"></div><br>可推广至N级页表。<br><br><br><br>### 反置页表<br><br>页表是按每个进程的页号排序，指示出物理块号的位置，反置页表是按物理块号排序，指示出每个页隶属的进程和页号。<br><br>此方法需要为每个进程创建一个外部页表，即将页表建立在外存中。进程进行地址变换时先从反置页表里查找，如果查找不到则去外村中查找，再将查找到的页表项调入内存。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/反置页表.jpg"></div><h2 id="分段存储管理方式"><a href="#分段存储管理方式" class="headerlink" title="分段存储管理方式"></a>分段存储管理方式</h2><p>之前的分区管理都是为了更好的利用内存。为了满足程序员在编程上的要求引入了分段管理方式。</p><ul><li><p>方便编程：通常，用户把自己的作业按照逻辑关系划分为若干个段，每个段都是从0开始编址，并有自己的名字和长度。因此，希望要访问的逻辑地址是由段名（段号）和段内偏移量（段内地址）决定的。例如，下述的两条指令便是使用段名和段内地址：其中，前一条指令的含义是将分段A中D单元内的值读入寄存器1；后一条指令的含义是将寄存器1的内容存入B分段的C单元中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOAD 1，[A] |〈D〉；</span><br><span class="line">STORE 1，[B] |〈C〉；</span><br></pre></td></tr></table></figure></li><li><p>信息共享：在实现对程序和数据的共享时，是以信息的逻辑单位为基础的。比如，共享某个例程和函数。分页系统中的“页”只是存放信息的物理单位（块），并无完整的意义，不便于实现共享；然而段却是信息的逻辑单位。由此可知，为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适应。</p></li><li><p>信息保护：信息保护同样是对信息的逻辑单位进行保护，因此，分段管理方式能更有效和方便地实现信息保护功能。</p></li><li><p>动态增长：在实际应用中，往往有些段，特别是数据段，在使用过程中会不断地增长，而事先又无法确切地知道数据段会增长到多大。前述的其它几种存储管理方式，都难以应付这种动态增长的情况，而分段存储管理方式却能较好地解决这一问题。</p></li><li><p>动态链接：动态链接是指在作业运行之前，并不把几个目标程序段链接起来。要运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段（目标程序）调入内存并进行链接。可见，动态链接也要求以段作为管理的单位。</p></li></ul><h3 id="分段地址"><a href="#分段地址" class="headerlink" title="分段地址"></a>分段地址</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/分段地址.jpg"></div><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/段表.jpg"></div><h3 id="地址映射"><a href="#地址映射" class="headerlink" title="地址映射"></a>地址映射</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/分段地址映射.jpg"></div><h3 id="地址变换"><a href="#地址变换" class="headerlink" title="地址变换"></a>地址变换</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/分段地址变换.jpg"></div><h3 id="分页和分段的主要区别"><a href="#分页和分段的主要区别" class="headerlink" title="分页和分段的主要区别"></a>分页和分段的主要区别</h3><ul><li>页是信息的物理单位，段则是信息的逻辑单位；</li><li>页的的大小固定且由系统决定，而段的长度不固定，由用户所编写的程序决定；</li><li>分页的地址空间是一维的，而分段的地址空间是二维的。</li><li>分页是系统管理的需要；分段是为了更好满足用户的需要。</li></ul><h2 id="段页式存储管理方式"><a href="#段页式存储管理方式" class="headerlink" title="段页式存储管理方式"></a>段页式存储管理方式</h2><p>分段结构具有逻辑上清晰的优点，但它的一个致命弱点是每个段必须占据主存储器的连续区域，于是，要装入一个分段时可能要移动已在主存储器中的信息，为了克服这个缺点，可兼用分段和分页的方法，构成段页式存储管理。每个作业仍按逻辑分段，但对每一段不是按单一的连续整体存放到存储器中，而是把每个段再分成若干个页面，每一段不必占据连续的主存空间，可把它按页存放在不连续的主存块中。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ul><li>逻辑地址空间分段，段内分页，内存分块（页框），存储管理的分配单位是：物理块（页框）</li><li>地址结构：段号，页号，页内偏移地址。</li><li>每个作业一张段表，每段一张页表。地址变换：先查段表，再查该段的页表。</li></ul><h3 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/段表地址映射.jpg"></div><h3 id="地址变换机构"><a href="#地址变换机构" class="headerlink" title="地址变换机构"></a>地址变换机构</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/段表地址变换.jpg"></div><h2 id="传统存储器的问题"><a href="#传统存储器的问题" class="headerlink" title="传统存储器的问题"></a>传统存储器的问题</h2><p>传统的内存管理方式要求将一个作业全部装入内存才可以运行，由此造成了以下两种情况：</p><ul><li>大作业对内存的要求超出物理内存总容量，致使其无法运行。</li><li>内存由于容量的限制，只能装入少量的作业使其运行，而其它大量作业留在外存。</li></ul><h3 id="解决原理"><a href="#解决原理" class="headerlink" title="解决原理"></a>解决原理</h3><h4 id="程序局部性原理"><a href="#程序局部性原理" class="headerlink" title="程序局部性原理"></a>程序局部性原理</h4><ol><li>程序执行时， 除了少部分的转移和过程调用指令外，在大多数情况下仍是顺序执行的。</li><li>过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域， 但经研究看出，过程调用的深度在大多数情况下都不超过5。</li><li>程序中存在许多循环结构， 这些虽然只由少数指令构成， 但是它们将多次执行。</li><li>程序中还包括许多对数据结构的处理， 如对数组进行操作， 它们往往都局限于很小的范围内。</li></ol><h4 id="表现两个方面"><a href="#表现两个方面" class="headerlink" title="表现两个方面"></a>表现两个方面</h4><ol><li>时间局限性。如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环。</li><li>空间局限性。一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。</li></ol><h4 id="基于局部性原理"><a href="#基于局部性原理" class="headerlink" title="基于局部性原理"></a>基于局部性原理</h4><p>在程序装入时，不必将其全部读入到内存，而只需将当前需要执行的部分页或段读入到内存，就可让程序开始执行。在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统，将相应的页或段调入到内存，然后继续执行程序。</p><h3 id="虚拟存储器定义"><a href="#虚拟存储器定义" class="headerlink" title="虚拟存储器定义"></a>虚拟存储器定义</h3><p>所谓虚拟存储器， 是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、 中、 小型机器和微型机中。</p><h3 id="实现虚拟存储器的条件"><a href="#实现虚拟存储器的条件" class="headerlink" title="实现虚拟存储器的条件"></a>实现虚拟存储器的条件</h3><p>由于一个作业被分成多次地调入内存运行，所以在内存分配时必须采用离散分配方式。同时需要解决以下问题：</p><ul><li>页表（段表）的设计（软件支持）</li><li>程序不在内存时去外存调度需要中断（硬件支持）</li><li>逻辑地址转换为物理地址（软件硬件支持）</li><li>如何给每个进程分配物理块</li><li>一个页（段）进入内存时，淘汰哪个页（段）</li></ul><h2 id="请求分页存储管理方式"><a href="#请求分页存储管理方式" class="headerlink" title="请求分页存储管理方式"></a>请求分页存储管理方式</h2><h3 id="页表机制"><a href="#页表机制" class="headerlink" title="页表机制"></a>页表机制</h3><p>用于将用户逻辑地址空间变换为内存的物理地址空间。在页表中增加若干项，以便于标志程序或数据的状态。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/页表设计.jpg"></div><br>- 状态位（存在位）P：表示该页是否调入内存。<br>- 访问字段A：用于记录该页在某段时间内被访问的次数。<br>- 修改位M：表示该页在调入内存后是否被修改过。未修改过不必写回外存，修改要写回外存。<br>- 外存地址：该页在外存上的地址，通常是物理块号。<br><br><br><br>### 缺页中断机构<br><br>- 在地址映射过程中，在页表中发现所要访问的页不在内存，则产生缺页中断。操作系统接到此中断信号后，就调出缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使进程继续运行下去。<br>- 如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应页表项目的状态位及相应的内存块号。<br>- 若此时内存中没有空闲块，则要淘汰某页，若该页在内存期间被修改过，则要将其写回外存。<br>- 缺页中断发生在指令执行期间，而通常情况下，CPU是在一条指令执行完后，才检查是否有中断请求到达；一条指令在执行期间，可能产生多次缺页中断。所以硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处，继续执行。<br><br><br><br>### 地址转换机构<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/请求分页地址转换机构.jpg"></div><h3 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h3><h4 id="最小物理块数的确定"><a href="#最小物理块数的确定" class="headerlink" title="最小物理块数的确定"></a>最小物理块数的确定</h4><p>最小物理块数：保证进程正常运行所需的最小物理块数。与计算机的硬件机构有关，取决于指令的格式、功能和寻址方式。</p><h4 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h4><p>在请求分页中，可采取两种分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置<br>换和局部置换（置换范围不同）。于是组合出三种适用的策略：</p><ul><li>固定分配局部置换：分配固定数目的内存空间，在整个运行期间都不改变。如果缺页，则先从该进程在内存的页面中选中一页，进行换出操作，然后再调入一页。</li><li>可变分配全局置换：每个进程预先分配一定数目的物理块，同时OS也保持一个空闲物理块队列。当缺页时，首先将对OS所占有的空闲块进行分配，从而增加了各进程的物理块数。当OS的空闲块全部用完，将引起换出操作。</li><li>可变分配局部置换：系统根据缺页率动态调整各进程占有的物理块数目，使其保持在一个比较低的缺页率状态下。</li></ul><h4 id="物理块分配算法"><a href="#物理块分配算法" class="headerlink" title="物理块分配算法"></a>物理块分配算法</h4><ul><li>平均分配算法：将系统中所有可供分配的物理块，平均分配给各个进程。</li><li>按比例分配算法：按照进程的大小比例分配物理块。</li><li>考虑优先权的分配算法：为了对于紧迫的作业，能够尽快完成。可以将内存的物理块分成两部分，一部分按照比例分配给各进程，另一部分根据进程优先级，适当增加其相应的份额，分配给各进程。</li></ul><h3 id="页面调入"><a href="#页面调入" class="headerlink" title="页面调入"></a>页面调入</h3><h4 id="何时调入页面"><a href="#何时调入页面" class="headerlink" title="何时调入页面"></a>何时调入页面</h4><ul><li>提前取页：预先装入主存一页或几页（提前页）。</li><li>请求取页：当用到某页而不在主存时即缺页时取页。</li></ul><h4 id="从何处调入页面"><a href="#从何处调入页面" class="headerlink" title="从何处调入页面"></a>从何处调入页面</h4><p>外存有两个部分：文件区和对换区。对换区I/O操作速度比文件区相对快一些，因此一般应当尽量使用对换区来调入页面。对于不同情况，采用不同的策略：</p><ul><li>系统有足够的对换空间：全部从对换区调入。</li><li>系统对换空间不足：未修改的从文件区调入，修改的从对换区调入。</li><li>UNIX的调入方式：未运行过的从文件区调入，运行过的放在对换区，允许页面共享。</li></ul><h4 id="页面调入过程"><a href="#页面调入过程" class="headerlink" title="页面调入过程"></a>页面调入过程</h4><ol><li>进程需要的页面不在内存，引起缺页中断</li><li>中断处理程序保留现场环境，转入缺页中断处理程序</li><li>中断处理程序查找页表，得到对应的外存物理块号。如果内存有空闲，则启动磁盘操作，将所缺的页面读入，并修改页表。否则，到4。</li><li>执行置换算法，选出要换出的页面，如果该页修改过，应将其写入磁盘，然后将所缺页调入内存，修改相应表项，将其存在位置为<code>1</code>，并放入快表。</li><li>利用修改后的页表，形成物理地址，访问内存数据。</li></ol><h4 id="缺页率"><a href="#缺页率" class="headerlink" title="缺页率"></a>缺页率</h4><ul><li>假设进程逻辑空间为n页，系统为其分配物理块数为<code>m</code>。</li><li>如果进程运行过程中，访问页面成功次数为S，访问页面失败次数为F，总页面访问次数<code>A=S+F</code>，则进程运行过程中 缺页率<code>f=F/A</code>。</li></ul><p>影响缺页率的主要因素：</p><ul><li>页面大小：页面越大，缺页率越小</li><li>进程所分配物理块数：物理块越多，缺页率越小</li><li>页面置换算法：合理的置换算法能更少将页面调入调出</li><li>程序固有特性：比如做循环操作时，缺页率较低，因为执行的命令都是一系列大致相同的指令。</li></ul><h3 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h3><h4 id="最佳置换算法"><a href="#最佳置换算法" class="headerlink" title="最佳置换算法"></a>最佳置换算法</h4><p>所选择的被淘汰页面，将是以后永不使用的， 或许是在最长（未来）时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。这是一种理想情况，是实际执行中无法预知的，因而不能实现。可用作性能评价的依据。</p><p>例：假定系统为某进程分配了三个物理块， 并考虑有以下的页面号引用串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">7，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1</span><br></pre></td></tr></table></figure><p>进程运行时， 先将7，0，1三个页面装入内存。 以后， 当进程要访问页面2时， 将会产生缺页中断。此时OS根据最佳置换算法， 将选择页面7予以淘汰。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/最佳置换算法.jpg"></div><br>#### 先进先出页面置换算法<br><br>选择装入最早的页面被置换。可以通过链表来表示各页的建立时间先后。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/先进先出算法.jpg"></div><br>#### 最近最久未使用置换算法<br><br>选择内存中最久未使用的页面被置换。这是局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/LRU.jpg"></div><br>##### 硬件支持<br><br>- 寄存器：每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，于是寄存器数<br>值最小的是最久未使用页面。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/寄存器LRU.jpg"></div><ul><li><p>栈：一个特殊的栈，每当进程访问某页面时，便把被访问的页面移到栈顶，于是栈底的是最久未使用页面。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/栈LRU.jpg"></div></li></ul><h4 id="最少使用置换算法"><a href="#最少使用置换算法" class="headerlink" title="最少使用置换算法"></a>最少使用置换算法</h4><p>选择到当前时间为止被访问次数最少的页面被置换。</p><ul><li>实现方法1：每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，这样，在最近一段时间内时用最少的页面将是$\sum_{R_i}$最小的页。</li><li>实现方法2：每页设置访问计数器，每当页面被访问时，该页面的访问计数器加1；发生缺页中断时，淘汰计数值最小的页面，并将所有计数清零。</li></ul><h4 id="Clock置换算法"><a href="#Clock置换算法" class="headerlink" title="Clock置换算法"></a>Clock置换算法</h4><p>也称最近未使用算法（NRU, Not Recently Used），它是LRU（最近最久未使用算法）和FIFO的折衷。</p><p>内存中所有页面通过链接指针形成一个循环队列，每页有一个使用访问位，若该页被访问则置1。置换时采用一个指针，从当前指针位置开始按地址先后检查各页，寻找访问位为0的页面作为被置换页。指针经过的访问位为1的页都修改0，最后指针停留在被置换页的下一个页。</p><h4 id="改进Clock置换算法"><a href="#改进Clock置换算法" class="headerlink" title="改进Clock置换算法"></a>改进Clock置换算法</h4><p>由于Clock算法不考虑换出页面时，页面是否修改过的问题。这样在换出的页面如果被修改过的话，则必须做拷回磁盘处理，开销比较大。于是，改进型的Clock算法为每个页又增加了一个修改位。选择页面时，尽量选择既未使用又没有修改的页面。</p><p>访问位A，修改位M有四种不同情形：</p><ul><li>1类(A=0，M=0）既未访问，又没有修改，最佳淘汰页</li><li>2类(A=0，M=1）未访问，但是有修改，效率低的淘汰页</li><li>3类(A=1，M=0）被访问，但没有修改</li><li>4类(A=1，M=1）既被访问，又有修改</li></ul><p>算法：</p><ol><li>指针从当前位置开始，开始第一轮扫描循环队列，寻找A=0且M=0的页面，找到则可换出。</li><li>如果找不到，则开始第二轮扫描，寻找A=0且M=1的页面，并且每经过一个页面时，将其访问位A设置为0。如果找到一个第2类页面，则可换出。</li><li>如果仍旧未找到合适的换出页面，则此时指针回到初始位置，且所有页面其访问位A为0。再转回1继续工作。</li></ol><h4 id="页面缓冲算法"><a href="#页面缓冲算法" class="headerlink" title="页面缓冲算法"></a>页面缓冲算法</h4><p>在请求分页系统中，进程在运行的时候经常会发生页面换进换出的情况。而影响换进换出效率的原因如下：</p><ul><li>页面置换算法：好的页面置换算法能使进程运行中具有较低的缺页率，从而可以减少换进换出的开销。</li><li>写会磁盘的频率。</li><li>读入内存的频率。</li></ul><p>而页面缓存算法就是降低读写磁盘的频率来降低开销。做法如下：</p><ul><li>空闲页面链表：当有一个未被修改的页要换出时，实际上并不将其换出到外存，而是把它们所在的物理块挂在空闲链表的末尾。如果以后某进程请求此页时，便将其从空闲页面链表上取下。</li><li>修改页面链表：和空闲页面链表的功能一样，只是说此链表是存放已修改页面的。</li></ul><p>当链表上挂有足够多的页面时，将它们一齐写入磁盘，这样可以降低读写磁盘的频率。</p><h3 id="访问内存的有效时间"><a href="#访问内存的有效时间" class="headerlink" title="访问内存的有效时间"></a>访问内存的有效时间</h3><ul><li>被访问页在主存，且相应页表项在快表：$EAT= \lambda +t$<ul><li>查找快表+访问实际物理地址</li></ul></li><li>被访问页在主存，但相应页表项不在快表：$ EAT= \lambda +t + t + \lambda$<ul><li>查找快表+读取页表+读取数据+更新快表</li></ul></li><li>被访问页不在主存：$EAT= \lambda + t + \varepsilon + t + \lambda$<ul><li>查找快表+读取页表+缺页中断处理+读取数据+等新快表</li></ul></li><li>内存的有效访问时间为：$EAT= \lambda + t + (1 - a ) \ast [f \ast ( \varepsilon + \lambda + t)+(1-f) \ast(\lambda+t)]$<ul><li><code>a</code>为命中率，<code>f</code>为缺页率。</li><li>查找快表+访问内存一次+未命中不需要请求缺页访问快表+未命中时不需要请求缺页访问内存+未命中需要请求缺页访问快表+未命中时需要请求缺页访问内存+未命中时需要请求缺页开销。</li></ul></li></ul><h2 id="抖动与工作集"><a href="#抖动与工作集" class="headerlink" title="抖动与工作集"></a>抖动与工作集</h2><h3 id="抖动"><a href="#抖动" class="headerlink" title="抖动"></a>抖动</h3><p>由于只装入一个进程的部分程序和数据便可开始运行，故希望运行更多进程，增加多道程序度。但在多道程序环境下，并不是多道程序的度越高，系统吞吐量越大。当CPU的利用率达到某一峰值后，若继续增加多道程度，将产生“抖动”。</p><p>抖动是指同时运行进程太多，分配给每个进程物理块太少，进程在运行时频繁缺页，必须请求调页，等待页面调进调出的进程增多，磁盘访问时间急剧增加，进程大部分时间用于页面换进换出，处理机利用率急剧下降并趋于0。</p><h3 id="工作集"><a href="#工作集" class="headerlink" title="工作集"></a>工作集</h3><p>基于程序运行的局部性原理，程序运行时，对页面的访问并不均匀，一段时间仅局限于较少的页面；另一段时间，有可能局限于另一些较少的页面，如果能预知这些页面，并提前调入，将大大减少缺页率工作集，是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。</p><ul><li>方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。</li></ul><p>定义：是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。</p><ul><li>方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。</li></ul><p>工作集$ \omega (t, \Delta) $是二元函数。某进程在时间<code>t</code>的工作集记为$ \omega (t, \Delta) $，其中，$\Delta$为工作集的窗口尺寸。</p><h4 id="例"><a href="#例" class="headerlink" title="例"></a>例</h4><ul><li>窗口大小$\Delta$选择得过小，频繁产生缺页中断。</li><li>窗口大小$\Delta$选择得很大，失去了虚拟存储器的意义</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/工作集.jpg"></div><h3 id="抖动的预防方法"><a href="#抖动的预防方法" class="headerlink" title="抖动的预防方法"></a>抖动的预防方法</h3><ul><li>采取局部置换策略：仅允许进程在自身范围内进行置换，不影响其他进程</li><li>在CPU调度程序中引入工作集算法：调入新作业时，应该检查每个进程在内存中的驻留集是否足够大</li><li><code>L=S</code>准则：<code>产生缺页的平均时间L=系统处理进程缺页的平均时间S</code></li><li>选择暂停的进程：使某些低优先级的进程进程挂起，从而腾出内存空间</li></ul><h2 id="请求分段存储管理方式"><a href="#请求分段存储管理方式" class="headerlink" title="请求分段存储管理方式"></a>请求分段存储管理方式</h2><ul><li>请求分页系统建立的虚拟存储器，是以页面为单位进行换入、换出操作的。</li><li>在请求分段系统中实现的虚拟存储器，以分段为单位进行换入和换出。</li><li>程序在运行之前，只需要装入必要的若干个分段即可运行。当访问的分段不在内存时，可由OS将所缺少的段调入内存。</li></ul><p>使用请求分段存储管理方式可以对动态链接有很好的支持。</p><h3 id="请求段表机制"><a href="#请求段表机制" class="headerlink" title="请求段表机制"></a>请求段表机制</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/段表.jpg"></div><br>- 存取方式：标记本段存取属性。如读R，写W，执行X<br>- 访问字段A：记录本段使用的频繁程度<br>- 修改位：是否在调入内存后做过修改<br>- 存在位：本段是否装入内存<br>- 增补位：该段是否动态增长过<br><br><br><br>### 缺段中断机构<br><br>要有专门的缺段中断处理程序。特点：<br><br>- 指令和操作数必定不会跨越在段边界上。<br>- 由于段的长度是不固定的，处理比缺页系统复杂。<br>- 调入一个段可能要淘汰几个内存中的段。<br><br><br><br>### 请求中断处理<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/请求中断处理.jpg"></div><h3 id="地址中断机构"><a href="#地址中断机构" class="headerlink" title="地址中断机构"></a>地址中断机构</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/地址变换机构.jpg"></div><h3 id="分段的共享与保护"><a href="#分段的共享与保护" class="headerlink" title="分段的共享与保护"></a>分段的共享与保护</h3><h4 id="共享段表"><a href="#共享段表" class="headerlink" title="共享段表"></a>共享段表</h4><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/共享段表.jpg"></div><br>- 共享进程计数：多少进程在使用此段。<br>- 存取控制手段：每个共享段，应为不同进程赋予不同的存取权限。<br>- 断号：同一个共享段在不同进程那有不同的断号。<br><br><br><br>#### 分配<br><br>第一个请求的进程，由系统分配一物理块，调入共享段，设置相关表项信息，并置<code>count=1</code>； 以后的进程，在自己的段表中增加一项，填入共享段的信息，在共享段表项中做<code>count=count+1</code>，填写进程相关信息。<br><br>#### 回收<br><br>1. 做count=count-1；<br>2. 若count=0 ，则该共享段被回收。<br><br>#### 分段保护<br><br>- 越界检查：在进行存储访问时，要将逻辑地址的段号与段表长度进行比较，如果超出则发生越界中断信号；其次，将段内地址与段表中该段的长度进行比较，如果有效才进行转换，否则产生越界中断信号。<br>- 存取控制检查：用于规定对该段的访问权限。通常的访问方式有：<br>- 读：允许用户对该段/页内任何信息或其副本进行读操作。<br>- 写：允许用户修改该段/页内任何信息直至撤消整个段/页。<br>- 执行：用户可以执行该段/页程序，数据段/页除外。<br>- 增加：用户可在段/页的末尾添加信息，但不允许修改已存在于段/页中的信息。<br>- 环保护检查：是一种功能较完善的保护机制。<br>- 思想：将所有的程序分成不同的级别，分别放置在不同的环上。内环（编号小，在内侧）的程序具有高优先权，外环的程序优先权低。<br>- 操作系统核心安排在0环内；重要程序和操作系统服务安排在中间环；一般应用程序安排在外环。<br>- 一个程序可以直接访问在相同环或低优先级环（比自身相对靠外的环）上的数据。<br>- 一个程序访问高优先级（比自己靠内的环）时，通过系统调用方式实现。<br><br><br><br>## IO系统的基本功能<br><br>输入输出系统和OS中的其他部分有很大区别，因为其他部分都是在说计算机接受任务后该怎么运行能又快又可靠的完成任务并把结果输出。而输入输出系统是怎么快速稳定的将任务的需求输入和任务的结果输出。<br><br>又由于输入输出设备种类繁多，比如输入设备中的键盘、鼠标、网卡、摄像头，输出设备中的打印机、音频等。所以输入输出系统被划分很多层次来尽可能屏蔽物理细节。<br><br>- 隐藏物理设备的细节：只需要使用简单的命令就能操作各种具有不同实现的硬件完成相应需求。<br>- 与设备的无关性：用户不需要指定哪些设备完成功能，只需要描述需求，OS会选择一个设备完成功能。<br>- 提高处理机和IO设备的利用率：IO设备之间一般是相互独立的，因此设备之间能够并行操作，所以OS应让处理机和设备之间能并行操作。<br>- 对IO设备进行控制：<br>- 轮询的可编程IO方式。<br>- 采用中断你的可编程IO方式。<br>- 直接存储器访问方式。<br>- IO通道方式。<br>- 确保对设备的正确共享。<br>- 错误处理。<br><br><br><br>## IO软件的层次结构<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/IO软件层次.jpg"></div><br>- 用户层软件：提供设备与用户交互的接口，用户可以使用该层提供的功能直接控制设备。<br>- 设备独立性软件：设备分配，设备保护，设备分配，设备回收，数据缓存等。<br>- 设备驱动软件：发出控制设备的命令。<br>- 中断处理程序：保存被中断的进程的CPU环境，转入相应的中断处理程序仅需处理，处理完毕后再恢复被中断进程的现场，返回到被中断的进程。<br><br><br><br>## IO系统各模块层次视图<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/IO各模块层次视图.jpg"></div><br>- 块设备：输入输出以数据块为单位的设备。如磁盘。<br>- 流设备：字符设备的输入输出，如键盘。<br>- 网络通信接口：网卡。<br><br><br><br>## IO设备和设备控制器<br><br>直接和IO设备对接的是设备控制器。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/IO设备和设备控制器.jpg"></div><br>### 作用<br><br>1. 接收和识别命令（控制寄存器、命令译码器）：设备控制器将CPU送来的命令写入控制器寄存器中，并进行译码。<br>2. 数据交换（数据寄存器）。<br>3. 设备状态的了解和报告（状态寄存器）。<br>4. 地址识别（地址译码器）：系统中的每个设备都有自己的地址段，设备接口电路中有多个寄存器，一个寄存器有唯一的一个地址，每个地址为I/O端口，该地址称为I/O端口地址。设备控制器必须能识别每个设备的地址。<br>5. 数据缓冲：缓冲器。<br>6. 差错控制：差错检测码。<br><br><br><br>### 组成<br><br>- 设备控制器和处理机的接口：用于实现CPU与设备控制器之间的通信。<br>- 设备控制器和设备的接口。<br>- IO逻辑：在一个设备控制器上，可以连一个或多个设备。相应的，在控制器中就有一个或多个设备接口，一个接口连一台设备，控制器中的I/O逻辑根据处理机发来的地址信号，去选择一个设备接口。控制器中的I/O逻辑用来实现对设备的控制。通过接收CPU 发来的命令和地址信息，对所选设备进行控制<br><br><br><br>### CPU如何控制设备控制器<br><br>CPU控制内存时需要指定指令地址、数据地址等。控制设备控制器亦如此，一般有两种控制方式：<br><br>- 利用特定IO指令：利用特殊的IO指令控制设备控制器。<br>- 内存映像IO：不再区分内存和控制器中的寄存器地址。假如有一个地址K，当0&lt;=K&lt;N时被认为是内存地址，K&gt;=N时被认为是寄存器地址。<br><br><br><br>### IO通道<br><br>有了设备控制器之后，CPU便可以操作控制器完成对IO设备的控制，但是此时数据交换仍然需要CPU的全程参与，所以引入IO通道来使数据传送、IO设备的组织管理等都独立于CPU。<br><br>通道是独立于CPU的专门负责数据输入/输出传输工作的处理机，对外部设备实现统一管理，代替CPU对输入/输出操作进行控制，从而使输入，输出操作可与CPU并行操作。通道执行通道程序来控制IO操作。与CPU的区别：<br><br>- 通道程序指令类型单一<br>- 通道没有自己的内存，通道程序在主机的内存中，即通道与CPU共享内存。<br><br><br><br>#### 字节多路通道<br><br>主要连接以字节为单位的低速IO设备。如打印机，终端。<br><br>- 按字节交叉方式工作的通道。通常含有许多非分配型子通道，其数量从几十个到数百个，每一个子通道连接一台I/O设备。这些子通道按时间片轮转方式共享主通道。<br>- 字节多路通道以字节为单位传输信息，它可以分时地执行多个通道程序。当一个通道程序控制某台设备传送一个字节后，通道硬件就控制转去执行另一个通道程序，控制另一台设备传送信息。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/字节多路通道.jpg"></div><br>#### 数组选择通道<br><br>主要连接磁盘，磁带等高速I/O设备<br><br>选择通道是按数组方式进行数据传送，每次传送一批数据，故传送速度很高。<br><br>选择通道在一段时间内只能执行一个通道程序，只允许一台设备进行数据传输。当这台设备数据传输完成后，再选择与通道连接的另一台设备，执行它的相应的通道程序。这种独占性又使得通道利用率很低。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/数组选择通道.jpg"></div><br>#### 数组多路通道<br><br>主要连接高速设备。<br><br>- 结合了数组选择通道传送速度高和字节多路通道能进行分时并行操作的优点。它先为一台设备执行一条通道指令，然后自动转接，为另一台设备执行一条通道指令。它含有多个非分配型的子通道，既有很高的数据传输率，又能获得令人满意的通道利用率<br>- 对通道程序采用多道程序设计的硬件实现<br>- 可以连接多台高速设备，数据传输按数组方式，一段时间内可以执行多道通道程序<br><br>#### 解决瓶颈<br><br>通道执行通道程序，向控制器发出命令，并具有向CPU发中断信号的功能。一旦CPU发出指令，启动通道，则通道独立于CPU工作。但是，由于通道价格贵，通道数量少，往往使之成为IO的“瓶颈”。解决办法是在不增加通道的前提下，增加设备到主机间的通路，一个通道可连接多个控制器，一个控制器可连接多个设备，形成树形交叉连接。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/解决瓶颈.jpg"></div><br>## 中断机构和中断处理程序<br><br>### 中断的理解<br><br>说到中断还不得不从现代操作系统的特性说起，无论是桌面PC操作系统还是嵌入式都是多任务的操作系统，而很遗憾，处理器往往是单个的，即使在硬件成本逐渐下降，但处理器的数量依然不可能做到每个任务一个CPU，所以CPU必须作为一种全局的资源让所有任务共享。即什么时候给任务A用，什么时候给任务B用……这就是进程调度，具体的安排就由调度算法决定了。<br><br>进程如何去调度？现代操作系统一般都是采用基于时间片的优先级调度算法，把CPU的时间划分为很细粒度的时间片，一个任务每次只能时间这么多的时间，时间到了就必须交出使用权，即换其他的任务使用。这种要看操作系统的定时器机制了。那么时间片到之后，系统做了什么呢？这就要用到我们的中断了，时间片到了由定时器触发一个软中断，然后进入相应的处理历程。当然这一点不足以表明中断的重要，计算机操作系统自然离不开外部设备：鼠标、键盘、网卡、磁盘等等。就拿网卡来讲，我计算机并不知道时候数据包会来到，我能保证的就是数据来了我能正常接收就行了。但是我又不可能一直等着接收数据包，要是这样其他任务就死完了。所以合理的办法是，你数据包来到之后，通知我，然后我再对你处理，怎么通知呢？？答：中断！键盘、鼠标亦是如此！<br><br><br><br>### 中断的定义<br><br>指处理机处理程序运行中出现的紧急事件的整个过程.程序运行过程中，系统外部、系统内部或者现行程序本身若出现紧急事件，处理机立即中止现行程序的运行，自动转入相应的处理程序（中断服务程序），待处理完后，再返回原来的程序运行，这整个过程称为程序中断。可分为两类：<br><br><br><br>#### 硬中断（Hardware Interrupt）<br><br>- 外部中断：一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断是可屏蔽的。<br>- 内部中断是指因硬件出错（如突然掉电、奇偶校验错等）,或运算出错（除数为零、运算溢出、单步中断等）所引起的中断，内部中断是不可屏蔽的。<br><br>#### 软中断（Software Interrupt）<br><br>软中断是利用硬中断的概念，用软件方式进行模拟，实现宏观上的异步执行效果。很多情况下，软中断和”信号”有些类似，同时，软中断又是和硬中断相对应的，硬中断是外部设备对CPU的中断，软中断通常是硬中断服务程序（模拟硬件发出中断的程序）对内核的中断，信号则是由内核（或其他进程）对某个进程的中断。<br><br><br><br>### 时钟中断<br><br>在Linux的0号中断是一个定时器中断。在固定的时间间隔都发生一次中断，也是说每秒发生该中断的频率都是固定的。该频率是常量HZ，该值一般是在100 ~ 1000之间。该中断的作用是为了定时更新系统日期和时间，使系统时间不断地得到跳转。另外该中断的中断处理函数除了更新系统时间外，还需要更新本地CPU统计数。若进程的时间片递减到0，进程则被调度出去而放弃CPU使用权。<br><br>Linux的OS时钟的物理产生原因是可编程定时/计数器产生的输出脉冲，这个脉冲送入CPU，就可以引发一个中断请求信号，我们就把它叫做<code>时钟中断</code>。<br><br><code>时钟中断</code>是特别重要的一个中断，因为整个操作系统的活动都受到它的激励。系统利用时钟中断维持系统时间、促使环境的切换，以保证所有进程共享CPU；利用时钟中断进行记帐、监督系统工作以及确定未来的调度优先级等工作。可以说，<code>时钟中断</code>是整个操作系统的脉搏。<br><br><br><br>## 设备驱动程序<br><br>### 功能<br><br>1. 接受设备独立性软件发来的命令和参数，将接收到的抽象要求转换为具体要求<br>2. 检查用户IO请求的合法性，了解IO设备的状态，传递有关参数，设置设备的工作方式<br>3. 发出IO命令，如果设备空闲，启动IO设备完成指定的IO操作；如果设备忙碌，则将请求挂在设备队列上等待<br>4. 及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。<br>5. 对于设置有通道的计算机系统，驱动程序还应能够根据用户的IO请求，自动地构成通道程序。<br><br><br><br>### 特点<br><br>1. 驱动程序主要是在设备无关性软件和设备控制器之间的一个通信程序<br>2. 驱动程序与IO设备特性密切相关：通常由硬件厂商提供<br>3. 驱动程序与I/O控制方式密切相关:中断驱动和DMA方式<br>4. 驱动程序与硬件相关,部分代码需用汇编语言编写<br>5. 驱动程序应允许可重入<br><br><br><br>### 处理过程<br><br>1. 将抽象要求转换为具体要求<br>1. 通常设备控制器中都有若干个寄存器，分别用于暂存命令、数据和参数等；<br>2. 用户及上层软件对设备控制器的具体情况毫无了解，因而只能向它们发出抽象的要求(命令)，但不能直接传送给设备控制器。需要将抽象要求转换为具体要求(命令码，数据，参数)。例如，将抽象要求中的盘块号转换为磁盘的盘面、磁道号及扇区。这一转换工作只能由驱动程序来完成；<br>3. 在OS中只有驱动程序才同时了解抽象要求和设备控制器中的寄存器情况；也只有它才知道命令、数据和参数应分别送往哪个寄存器。<br>2. 检查IO请求的合法性<br>3. 读出和检查设备的状态<br>4. 传送必要的参数，设置工作方式<br>5. 启动I/O设备<br>1. 在完成上述准备工作后，驱动程序可以向控制器中的命令寄存器传送相应的控制命令<br>2. 对于字符设备，若发出的是写命令，驱动程序将把一个数据传送给控制器；若发出的是读命令，则驱动程序等待接收数据，并通过从控制器中的状态寄存器读入状态字的方法，来确定数据是否到达。<br>3. 驱动程序发出IO命令后，基本的IO是在设备控制器的控制下进行的，通常IO操作所要完成的工作较多，需要一定的时间，如读/写一个盘块中的数据，此时，驱动程序进程把自己阻塞起来，直至中断到来时才将它唤醒。<br><br><br><br>### 对IO设备的控制方式<br><br>#### 使用轮询的可编程I/O方式<br><br>CPU发出启动外设的I/O指令，同时将忙/闲标志置为1。如果外设的工作没有完成，则标志一直为1，CPU不断循环检测该标志，直到标志为不忙为止。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/轮询可编程.jpg"></div><br>#### 使用中断的可编程I/O方式<br><br>CPU设定I/O设备的初始值，然后不再忙等待，运行其他进程，当前进程阻塞；I/O设备完成对当前数据的处理后，向CPU发出中断，I/O中断处理程序将负责传送剩余数据。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/中断可编程.jpg"></div><br>#### 直接存储器访问(DMA)方式<br><br>采用中断驱动IO方式时的CPU，是以字为单位进行干预的。如果将这种方式用于块设备的I／O，是极其低效的。如：为了从磁盘中读出1KB的数据块；需要中断1K次CPU。而DMA方式使用独立的DMA控制器代替CPU的工作，I/O设备与DMA通信，DMA在传输完成一个数据缓冲区之后再向CPU发中断。<br><br>- 数据传输的基本单位是数据块，即CPU与IO设备之间，每次传送至少是一个数据块，主要用在块设备的IO操作中。<br>- 在DMA方式中，利用总线直接连接外设和内存，由DMA控制机构窃取总线占有权，完成外设与内存间的成批数据交换。所传送的数据是从设备直接送入内存的，或者相反。<br>- 仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的，不再需要CPU进行干预。<br><br>#### I/O通道控制方式<br><br>使用DMA方式，CPU每发出一条I/O指令，只能读写一个连续的数据块。如果需要一次去读多个离散的数据块且将它们分别送到不同的内存区域，则需要CPU分别发出多条I/O指令及进行多次中断处理，才能完成。<br><br>而IO通道可实现CPU、通道和I/O设备三者的并行操作，进一步提高CPU与外设之间的并行工作能力，使I/O操作形成独立于CPU的体系，减少CPU的负担，使外设与内存的数据交换更加灵活，从而更有效地提高整个系统的资源利用率。<br><br><br><br>## 与设备无关的I/O软件<br><br>为了便于对外设进行管理，系统对每台进入计算机系统中的设备都给定一个对应的编号，作为调用时识别和区分设备用。这种编号无任何重复，一般被称为设备的绝对号（或物理设备名）。早期操作系统，应用程序直接使用物理设备名称，非常不灵活。所以引入逻辑设备名，规定用户申请外设时，只需要向系统说明所需用的某类设备真正在实际中使用哪台设备，由系统根据这类设备的应用情况作出分配。<br><br><br><br>### 设备分配<br><br>在多道程序环境下，设备不允许用户自行使用，而必须由系统分配。对于进程的IO请求，只要是安全（无死锁），设备分配程序便按照一定的策略进行设备分配。数据结构：<br><br>- 系统设备表SDT：System Device Table。<br><br>- 整个系统中只有一张，全面反映了系统中的外设资源的类型、数量、占用情况等。<br>- 在SDT表中，每个接入系统中的外围设备都占有一个表目项。登录了该设备的名称、标识、设备控制表DCT的入口地址、设备驱动程序的入口地址及占用设备的进程名称等相关信息。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/SDT.jpg"></div><ul><li><p>设备控制表DCT ：Device Control Table。每台设备都有一张设备控制表DCT，用于记录本设备的情况。</p><ul><li>Type：设备类型</li><li>Deviceid:设备标识符</li><li>设备队列队首指针</li><li>设备状态：标识设备忙或者空闲；</li><li>与设备连接的控制器表指针。</li><li>重复执行次数</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/DCT.jpg"></div></li><li><p>控制器控制表COCT：Controller Control Table。每个控制器都有一张，用于记录某控制器的使用分配情况及与该控制器相连的通道的情况。</p><ul><li>控制器号：控制器的内部标识符。</li><li>控制器状态：控制器忙/闲，好/坏的状态标志。</li><li>通道指针：指向与该控制器相联的通道控制表CHCT，当控制器与若干通道连接时该项内含多个指针。</li><li>等待队列指针：指向等待该控制器的I/O进程队列</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/COCT.jpg"></div></li><li><p>通道控制表CHCT：Channel Control Table。反映了通道的情况，系统中的每个通道一张CHCT。</p><ul><li>通道号：通道内部标识符</li><li>通道状态：通道的各种状态（好/坏，已分/未分等）的反映</li><li>等待队列指针：等待该通道的I/O进程队列的首位置</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/CHCT.jpg"></div></li></ul><h3 id="设备分配算法"><a href="#设备分配算法" class="headerlink" title="设备分配算法"></a>设备分配算法</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/设备分配算法.jpg"></div><h2 id="用户层的I-O软件"><a href="#用户层的I-O软件" class="headerlink" title="用户层的I/O软件"></a>用户层的I/O软件</h2><h3 id="系统调用与库函数"><a href="#系统调用与库函数" class="headerlink" title="系统调用与库函数"></a>系统调用与库函数</h3><p>用户层软件必须使用一组系统调用来取得操作系统服务，在高级语言中都提供了相应的库函数来完成此功能。</p><h3 id="SPOOLing程序"><a href="#SPOOLing程序" class="headerlink" title="SPOOLing程序"></a>SPOOLing程序</h3><p>多道程序技术将一台CPU虚拟为多台CPU，从而可以提高CPU的利用率。而SPOOLing系统是模拟脱机输入输出系统来实现多个用户共享一台物理IO设备。</p><ul><li>脱机输入输出系统的IO处理机 对应 SPOOLing程序。</li><li>脱机输入输出系统的高速缓冲 对应 内存。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/SPOOLing.jpg"></div><h2 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h2><h3 id="单缓冲区"><a href="#单缓冲区" class="headerlink" title="单缓冲区"></a>单缓冲区</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/单缓冲区.jpg"></div><h3 id="双缓冲区"><a href="#双缓冲区" class="headerlink" title="双缓冲区"></a>双缓冲区</h3><p>为输入或输出分配两个缓冲区，让两个缓冲区交替工作，形成并行操作的方式。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/双缓冲.jpg"></div><h3 id="环形缓冲区"><a href="#环形缓冲区" class="headerlink" title="环形缓冲区"></a>环形缓冲区</h3><ul><li>空缓冲区R：用于存放数据（指针：Nexti）</li><li>已装满数据的缓冲区G：其中的数据提供给进程使用。（指针：Nextg）</li><li>现行工作缓冲区C：当前进程使用的缓冲区。（指针：Current）</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/环形缓冲.jpg"></div><h2 id="磁盘存储器的性能和调度"><a href="#磁盘存储器的性能和调度" class="headerlink" title="磁盘存储器的性能和调度"></a>磁盘存储器的性能和调度</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/磁盘.jpg"></div><br>当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头（又叫磁头）下通过，就可以进行数据的读/写了。<br><br>一般磁盘分为固定头盘（磁头固定）和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。<br><br>活动头盘 （如上图）的磁头是可移动的。每一个盘面上只有一个磁头（磁头是双向的，因此正反盘面都能读写）。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的（行动整齐划一）。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。<br><br><br><br>### 磁盘访问时间<br><br>1. 寻道时间$T_s$：$T_s = s$<br>2. 旋转延迟时间$T_τ$：$T_t = \frac{1}{2r}$<br>3. 磁盘访问时间 ：$T_t=\frac{b}{rN}$<br><br>$s$是指磁头从当前位置定位到开始点的时间，$b$是传输的字节数，$r$是每秒的转数，$N$是一条磁道上的字节数。$总时间 = T_s + \frac{1}{2r} + \frac{b}{rN}$<br><br><br><br>### 磁盘调度算法<br><br>假设磁盘访问序列：98，183，37，122，14，124，65，67，读写头起始位置：53。<br><br>#### 先来先服务<br><br>按访问请求到达的先后次序服务。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/先来先服务.jpg"></div><br>#### 最短寻道时间优先<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/最短寻道.jpg"></div><br>#### 扫描算法<br><br>当设备无访问请求时，磁头不动；当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/扫描算法.jpg"></div><br>#### 循环扫描算法<br><br>CSCAN算法规定磁头单向移动，例如由里向外移动，当磁头移到最外的磁道并访问后磁头立即返回到最里的欲访<br>问磁道，即最小磁道号紧接最大磁道号构成循环，进行循环扫描。<br><br><br><br><br><br>## 文件管理概述<br><br>计算机中有很多的程序和数据都是保存在外存中，在需要使用的时候才调入内存中。而如何保存这些信息是很重要的问题，因为不同类型的文件存储的数据格式不同，但这些格式却必须“迎合”硬件只能存储二进制数据的硬性条件。所以操作系统提供了文件管理的功能，让使用者能在不了解文件特性和外存特性的情况下完成文件的存储和查找等功能。同时还提供了文件共享和安全管理等功能。<br><br><br><br>### 文件系统 &amp; 文件<br><br>操作系统中负责管理和存储文件信息的软件称为文件管理系统，简称文件系统。包含：文件系统的接口，对对象操纵和管理的软件集合，对象及属性三部分。它负责对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。包含创建文件、删除文件等功能。<br><br>文件是指具有文件名的若干相关元素的集合，可以分成有结构文件和无结构文件，无结构文件可以看成一个字符流。有结构文件是由一组记录的集合，记录又是一组数据项的集合。<br><br>- 数据项：用来描述一个对象的某种属性的字符集。例如学生的学号、姓名等。<br>- 记录：一组数据项的集合，用来描述一个对象在某方面的属性，例如学生的成绩。能唯一标识一个记录的一个或多个数据项叫做关键字。<br><br><br><br>### 文件类型<br><br>不同的文件类型由于本身存储的信息具有不同的结构，在管理的时候也是不同。所以文件会被分成很多类型，下面是常用的文件分类方法：<br><br>- 按用途分类：系统文件、库文件、用户文件。<br>- 按文件中数据的形式分类：源文件、目标文件、可执行文件。<br>- 按存储控制属性分类：可读、可写、可执行文件。<br>- 按组织形式和处理方法分类：普通文件、目录文件、特殊文件。<br><br><br><br>### 剖析文件和目录<br><br>我们刚才在定义中说道，文件是指具有文件名的若干相关元素的集合，在有结构文件中这些元素是数据项集合的集合，在无结构文件指的是字符流。所以文件的概念中本身是：<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/文件.png"></div><h2 id="文件系统的层次结构"><a href="#文件系统的层次结构" class="headerlink" title="文件系统的层次结构"></a>文件系统的层次结构</h2><p>文件系统从底层到高层可分成三部分：对象及其属性、对对象操纵和管理的软件集合、文件系统接口：</p><ul><li>对象及其属性：文件管理系统管理的文件如下：<ul><li>文件：在文件管理系统中有着各种不同类型的文件，它们都作为文件管理的直接对象。</li><li>目录：用于对文件的存储和检索，目录的每个目录项包含了一个文件或目录的信息。</li><li>磁盘存储空间：文件和目录必定占用存储空间，对这部分空间的有效管理不仅能提高外存的利用率，而且能提高对文件的存取速度。</li></ul></li><li>对对象操纵和管理的软件集合：该层是文件管理系统的核心部分。文件系统的功能大多是在这一层实现的。如：文件存储的管理、文件目录的管理、将文件的逻辑地址转换为物理地址的机制、文件读写控制的管理、文件的共享和保护等功能。这些功能被可分为四层：<ul><li>I/O控制层：文件系统的最底层、主要由磁盘驱动程序等组成。</li><li>基本文件系统层：主要用于处理内存和磁盘之间数据块的交换。</li><li>基本I/O管理程序：完成与磁盘I/O有关的事务，如将文件的逻辑块号转换为物理块号、管理磁盘中的空闲盘块、I/O缓冲的指定等。</li><li>逻辑文件系统：管控对文件的操作，如控制用户或应用程序对文件的读写等。</li></ul></li><li>文件系统的接口：操作系统提供给用户或应用程序用来使用文件系统的接口：<ul><li>命令接口：用户与文件系统直接交互的接口，如Shell命令。</li><li>程序接口：应用程序可以通过一系列命令调用文件系统的服务。</li></ul></li></ul><h2 id="文件的打开和关闭"><a href="#文件的打开和关闭" class="headerlink" title="文件的打开和关闭"></a>文件的打开和关闭</h2><p>当用户要求对一个文件实施多次读/写操作时，如果每次都检索目录效率较低，所以为了避免多次重复的检索目录，OS提供了“打开（Open）”操作，当此操作被执行时，OS会把被打开文件的信息存为“打开文件表”的一个条目，然后把这个条目编号返回用户，这样用户就可以通过这个编号和文件之间建立一个连接，也就可以进行文件的读写等操作。当用户再次向系统发出请求时，把这个编号提交给OS，OS通过这个编号在打开文件表中查找文件信息就可以减少检索时间。而关闭就是OS从“打开文件表”上删除此条目，这样断开了用户和文件之间的连接。</p><h2 id="文件的逻辑结构和物理结构"><a href="#文件的逻辑结构和物理结构" class="headerlink" title="文件的逻辑结构和物理结构"></a>文件的逻辑结构和物理结构</h2><ul><li>逻辑结构：从用户的角度来看，文件是能被存取的基本单位。</li><li>物理结构：文件在磁盘上存储时的组织形式。</li></ul><h3 id="逻辑文件按结构分类"><a href="#逻辑文件按结构分类" class="headerlink" title="逻辑文件按结构分类"></a>逻辑文件按结构分类</h3><ul><li>有结构文件：每个文件用于描述实体集中的一个实体。每个记录的长度对OS来说都是可知的。但记录之间可以分为定长和变长两种。<ul><li>定长记录：所有记录的长度都是相同的、所有记录中的各数据项都处在记录中相同的位置具有相同的顺序和长度。</li><li>变长记录：各记录的长度不相同。比如论文的摘要可能长度差距很大，不能在存储之前估计出所需要的空间。</li></ul></li><li>无结构文件：系统中运行的大量的源程序、可执行文件、文本文件等都是无结构文件，即流式文件。其文件长度是以字节为单位的。</li></ul><h3 id="逻辑文件按组织方式分类"><a href="#逻辑文件按组织方式分类" class="headerlink" title="逻辑文件按组织方式分类"></a>逻辑文件按组织方式分类</h3><p>组织方式指的是文件中记录的组织方式。只对有结构文件有效。可以分成：顺序文件、索引文件、索引顺序文件。</p><h3 id="顺序文件"><a href="#顺序文件" class="headerlink" title="顺序文件"></a>顺序文件</h3><p>指由一系列记录按某种顺序排列所形成的的文件。</p><ul><li>串结构：按存入时间的先后顺序排列。所以检索时必须从头挨个查找，效率低。</li><li>顺序结构：用户指定一个字段作为关键字，他可以是任意类型的变量。如sql文件。</li></ul><h3 id="索引文件"><a href="#索引文件" class="headerlink" title="索引文件"></a>索引文件</h3><p>为变长记录文件创建一张索引表，索引表是定长记录文件，检索时，先查找索引表，再根据指针所指的地址读取记录。可以解决变长文件记录较难直接存取的问题。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/索引文件.jpg"></div><br>### 索引顺序文件<br><br>将顺序文件的所有记录分成若干组，为顺序文件建立一张索引表，索引表中为每组的第一个记录建立一个索引项。检索时，先检索索引表，找到记录所在记录组的第一个记录的表项，再顺序查找主文件，得到要求的记录。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/索引顺序文件.jpg"></div><br>## 文件目录<br><br>### 文件控制块<br><br>包含三类信息：<br><br>- 基本信息类：文件名、文件物理位置、文件逻辑结构、文件物理结构<br>- 控制信息类：各类用户的读、写、可执行文件等。<br>- 使用信息类：文件的建立时间，当前的使用信息，上一次修改的时间，是否被进程锁住等。<br><br><br><br>### 索引节点<br><br>为了唯一确定外存中的一个文件，必须要把文件的FCB加载进内存，而每次加载的数据大小是一定的，所以为了一次能多加载进内存一个文件标识。将FCB分成两部分：<br><br>#### 磁盘索引节点<br><br>- 文件主标识符<br>- 文件类型<br>- 文件存取权限<br>- 文件物理地址<br>- 文件长度<br>- 文件连接计数：本人理解为硬链接计数<br>- 文件存取时间<br><br><br><br>#### 内存索引节点。<br><br>- 索引节点编号<br>- 状态<br>- 访问计数<br>- 文件所属文件系统的逻辑设备号：不明白<br>- 链接指针：不明白<br><br><br><br>### 树形结构目录<br><br>在树形结构目录中，目录应该保存文件的信息。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/文件目录.jpg"></div><br>同时目录的目录项要能既作为目录文件的FCB，又作为数据文件的FCB。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/树形文件目录.jpg"></div><br>## 文件共享<br><br>### 基于有向无循环图实现文件共享<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/有向无环图.jpg" style="width:80%"></div><br>此种方法存在问题：<br><br>比如对于文件<code>F8</code>，<code>D5:p</code>、<code>D6:e</code>、<code>D3:p</code>都保存了<code>F8</code>的物理地址，即从某个盘块开始，总长度多少等。此时如果<code>D6:e</code>对<code>F8</code>进行了删除操作，<code>D5:p</code>和<code>D3:P</code>都无法察觉，仍然会认为在它们存储的位置上有文件，即一个目录项对文件的操作对其他目录项来说是不可见的。<br><br><br><br>### 利用索引节点<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/利用索引节点.jpg" style="width:60%"></div><br>引入索引结点，将文件的物理地址和其他的属性放在索引结点中，只在目录项中存放文件名和指向索引结点的指针。由任何用户对文件进行Append操作或修改，引起相应索引结点内容的改变。此种方法即Linux中的硬链接。<br><br><br><br>### 利用符号链接实现文件共享<br><br>建立符号链接文件，它是一种特殊类型的文件，其内容是被链接文件的路径名。建立符号链接文件，并不影响原文件，实际上它们各是一个文件。可以建立任意的别名关系，甚至原文件是在其他计算机上。只有文件主才有指向索引结点的指针，而其他共享用户只有该文件的路径名。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/利用符号链接.jpg"></div><br>## 文件保护<br><br>### 访问权&amp;保护域<br><br>- 访问权：一个进程能对某对象执行操作的权利，用&lt;对象名，权集&gt;表示，如<code>&lt;F1, {R/W}&gt;</code>表示进程对F1有读和写的权利。<br>- 保护域：进程对一组对象访问权的集合，进程只能在域内进行操作。<br><br><br><br>### 进程和域的联系方式<br><br>进程和域之间是一对多的关系，即一个进程可以联系多个域。此时进程的运行分为多个阶段，每个阶段联系一个域，这样就可以根据运行的实际需要规定进程每个阶段所能访问的对象。<br><br><br><br>### 访问矩阵<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/访问矩阵.jpg"></div><br>- R：在域内运行的进程对文件具有读权限<br>- W：在域内运行的进程对文件具有写权限<br>- $R^\ast$：在域内运行的进程能把其对文件的读权限扩展到其他域中，但在其他域中是R权限，不再是$R^\ast$。<br>- $W^\ast$：在域内运行的进程能把其对文件的写权限扩展到其他域中，但在其他域中是W权限，不再是$W^\ast$。<br>- S：在域Di中运行的进程能转移到域Dj中运行，如图中在域D3运行的进程能转移到域D2中运行。<br>- O：在域中运行的进程能增加或删除对某文件的访问权。<br>- Control：在域Di中运行的进程能删除在域Dj中运行进程对各对象的访问权。如图中在D2中运行的进程能删除在D3中运行进程的访问权。<br><br><br><br>### 访问矩阵的实现<br><br>#### 访问控制表<br><br>将访问对象按列划分，为每一列建立一张访问控制表，在该表中把属于对象的所有空项都删除。此时表中的每一项都是一个有序对<code>&lt;域，权集&gt;</code>构成。<br><br><br><br>#### 访问权限表<br><br>将访问矩阵按行划分，每一行是一个访问权限表，表中的每一项表示该域对某对象的访问权限。<br><br><br><br><br><br>文件管理的目标是管理文件的组织方式，管理文件的访问权等。而磁盘存储器的管理是管理存储器的使用，如何高效利用存储器。他俩是棋与棋盘的关系。<br><br><br><br>## 连续组织方式<br><br>文件的信息存放在若干连续的物理块中。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/连续组织方式.jpg" style="width:70%"></div><br>- 优点<br>- 简单<br>- 支持顺序存取和随机存取<br>- 顺序存取速度快，所需的磁盘寻道次数和寻道时间最少<br>- 缺点<br>- 文件不能动态增长（预留空间：浪费、重新分配和移动）<br>- 不利于文件插入和删除<br>- 外部碎片问题<br><br><br><br>## 链接组织方式<br><br>### 隐式链接<br><br>在文件的目录中记录该文件的第一和最后一个盘块的指针，每一个盘块的指针指向文件的下一物理块号。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/隐式链接.jpg"></div><br>- 优点<br>- 文件可动态增长<br>- 有利于文件的插入和删除<br>- 提高了磁盘空间利用率,不存在外部碎片问题<br>- 缺点<br>- 存取速度慢，不适于随机存取<br>- 可靠性问题，如指针出错<br>- 更多的寻道次数和寻道时间<br>- 链接指针占用一定的空间<br><br><br><br>### 显示链接<br><br>将链接文件各物理块的指针显示地放在内存的一张链接表（文件分配表，File Allocation Table）中。在FCB的物理地址中填写其首指针所对应的盘块号。由于文件分配表示存储在内存中的，可以大大减少访问磁盘的次数。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/显示链接.jpg" style="width:70%"></div><h3 id="FAT"><a href="#FAT" class="headerlink" title="FAT"></a>FAT</h3><p>微软公司早、中期推出的操作系统一直都是采用的FAT技术，即利用文件分配表FAT来记录每个文件中所有盘块之间的链接。FAT中引入了“卷”的概念，支持将一个物理磁盘分成四个逻辑磁盘，每个逻辑磁盘就是一个卷（也称为分区），每个卷都可以被单独格式化和使用。把盘块作为基本分配单位，同时每个分区中都配有两张相同的文件分配表FAT1和FAT2。</p><p>FAT技术的发展有三个阶段：FAT12、FAT16和FAT32</p><h4 id="FAT12"><a href="#FAT12" class="headerlink" title="FAT12"></a>FAT12</h4><p>FAT表的每个表项占用12个bit。所以最多有$2^{12}$个表项，每个盘块的大小是512B，则每个磁盘分区的容量是2MB，能处理的磁盘最大容量是8MB。</p><p>为了增大FAT能管理的最大容量，引入了“簇”的概念，每个簇是一组相邻的扇区，这样如果分配时以簇为单位进行分配就能管理更大的磁盘容量，但是相应的簇内零头也会更大，降低磁盘的利用率。</p><h4 id="FAT16"><a href="#FAT16" class="headerlink" title="FAT16"></a>FAT16</h4><p>FAT表的每个表项占用16个bit。最多有$2^{16}$个表项。</p><h4 id="FAT32"><a href="#FAT32" class="headerlink" title="FAT32"></a>FAT32</h4><p>FAT表的每个表项占用16个bit。最多有$2^{32}$个表项。同时每个簇固定为4KB。所以最大可管理$4 \ast 2^{10} \ast 2^{32} = 2TB$大小的空间。</p><h3 id="NTFS"><a href="#NTFS" class="headerlink" title="NTFS"></a>NTFS</h3><h2 id="索引组织方式"><a href="#索引组织方式" class="headerlink" title="索引组织方式"></a>索引组织方式</h2><h3 id="单级索引组织方式"><a href="#单级索引组织方式" class="headerlink" title="单级索引组织方式"></a>单级索引组织方式</h3><p>一个文件的信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构索引表，并将这些块的块号存放在一个索引表中。一个索引表就是磁盘块地址数组，其中第i个条目指向文件的第i块。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/索引组织方式.jpg" style="width:60%"></div>·<br>### 多级索引组织方式<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/多级索引组织方式.jpg"></div><br>### 增量式索引组织方式<br><br>可以更好的满足大、中、小文件的组织。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/增量组织方式.jpg"></div><br>## 文件存储空间的管理<br><br>文件存储空间的管理包括空闲块的组织分配和回收。<br><br>### 空闲表法<br><br>把一个连续未分配区域称为“空闲文件”，系统为所有空闲文件单独建立一个目录。表目内容：序号，第一个空白块号，空白块个数。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/空闲链表.jpg"></div><br>- 分配算法：内存管理中的首次适应算法、循环首次适应算法。<br>- 合并：空闲区邻接合并<br><br><br><br>### 空闲链表法<br><br>空闲盘块链：所有空闲盘块拉成一条链，分配时从头分配，回收时链接在尾部。<br><br>空闲盘区链：每个连续的盘块组成一个盘区，每个盘区包含本盘区的大小和下一个盘区的地址。<br><br><br><br>### 位示图法<br><br>用一串二进制位反映磁盘空间中分配使用情况，每个物理块对应一位，分配物理块为1，否则为0。申请物理块时，可以在位示图中查找为0的位，返回对应物理块号；归还时；将对应位转置0。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/位示图法.jpg"></div><br>### 成组链接法（重点）<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/成组链接法.jpg"></div><br>- 把所有的空闲盘块按每n个一组分成m个组。<br>- 最后一个组放在内存的空闲盘块号栈中，其他组存在外存上。空闲盘块号栈是一个临界资源，只允许一个进程同时访问。<br>- 数据结构，一个size为n+1的栈。图上是一个倒着的的栈（栈底在上方，栈顶在下方）<br>- 一个n+1的栈实际可用盘块只有n（图上只有99个可用盘块），因为栈底是一个计数器，指示当前有多少个可用盘块，但是可用盘块中有一个是指向下一个组，即stack[1]指向下一个组。如果stack[1]==0表示此时是最后一组。<br>- 分配时从栈顶开始向下分配，直至分配出n-1个盘块，此时如果再想分配一个块就需要把下一个组调入空闲盘块号栈。调入后新组覆盖旧组。<strong>然后把新组在外存中占用的盘块分配出去。</strong><br>- 回收时从栈底向上回收，如果计数器==100时还有空闲盘块（设这个盘块编号为p）要回收，就把空闲盘块号栈内的组取出来存在p中，在空闲盘块号栈内新开辟一个组，新组的stack[1]指向p。<br><br><br><br>### 例<br><br>此题题目及来源：<a href="https://blog.csdn.net/ajay666/article/details/73569654" target="_blank" rel="noopener">https://blog.csdn.net/ajay666/article/details/73569654</a><br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/成组链接例.jpg"></div><br>分配3个盘块后，回收它所占的5个盘块，回收的盘块号依次为700、711、703、788、701，画出分配回收过程。<br><br>#### 第一次分配<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/成组链接例1.jpg"></div><br>#### 第二次分配<br><br>注意：300号盘块中存储的组信息调入空闲盘块号栈之后其自己也可以被分配。<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/成组链接例2.jpg"></div><br>#### 第三次分配<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/成组链接例3.jpg"></div><br>#### 第一次回收<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/第一次回收.jpg"></div><br>#### 第二次回收<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/第二次回收.jpg"></div><br>#### 第三次&amp;第四次&amp;第五次回收<br><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/第三四五次回收.jpg"></div><h2 id="Linux介绍"><a href="#Linux介绍" class="headerlink" title="Linux介绍"></a>Linux介绍</h2><p>Linux是一套免费使用和自由传播的操作系统。严格来讲，Linux这个词本身只表示Linux内核，但一般来说使用Linux内核的操作系统都被称为Linux。而不同的厂家使用相同的Linux内核所构建的操作系统叫做Linux发行版。常见的Linux发行版有Ubuntu、Centos、Debian等。这些发行版的使用方法大同小异。</p><p>但Linux不仅限于使用在PC机上，移动端（安卓系统是由Linux改写而来）、路由器（只保留少许功能的Linux系统）等终端都在使用Linux。</p><h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><ul><li><p>虚拟机安装：<a href="https://blog.csdn.net/qq_38206090/article/details/82559358" target="_blank" rel="noopener">blog.csdn.net/qq_38206090/article/details/82559358</a></p></li><li><p>双系统：笔者没有安装过，因为怕系统出问题导致文件损失。</p></li><li><p>云服务器：云服务器系统配置Linux版本我认为是最简单的方式，所以以下实例均采用阿里云服务器。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/阿里云服务器.png"></div></li></ul><h2 id="连接服务器工具"><a href="#连接服务器工具" class="headerlink" title="连接服务器工具"></a>连接服务器工具</h2><ul><li>SecureCRT：去 <a href="http://59.110.143.226/Sharing-Your-Story/" target="_blank" rel="noopener">http://59.110.143.226/Sharing-Your-Story/</a> 搜索。</li><li>Termius：<a href="https://www.microsoft.com/store/productId/9NK1GDVPX09V" target="_blank" rel="noopener">https://www.microsoft.com/store/productId/9NK1GDVPX09V</a></li></ul><p>推荐使用Termius，好看也好用。SecureCRT是破解版，Termius是免费使用。</p><h2 id="Linux目录结构"><a href="#Linux目录结构" class="headerlink" title="Linux目录结构"></a>Linux目录结构</h2><p>Linux的目录结构是一个树形结构，树根是一个/。直接子目录包括root、home等。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/根目录.png"></div><p>如我的阿里云服务器根目录：</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/根目录格式.jpg"></div><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><p>Shell是指“为使用者提供操作界面”的软件（命令解析器）。Shell翻译过来叫做“壳”，用来区别于“核”，也就是说它把底层的东西封装成命令，使用者键入命令就能得到相应的结果。比如上面的这张图中，我在根目录下输入<code>ll</code>命令，就在终端上给我显示根目录下的文件信息。也就是说Shell解析了我输入的<code>ll</code>命令，返回我想要的信息（根目录文件信息）。</p><h2 id="Bash命令"><a href="#Bash命令" class="headerlink" title="Bash命令"></a>Bash命令</h2><p>Shell是命令解释器，自然会有不同的分类，就类比于同是循环结构，Java和Python却有不同的语法。但是Bash（Bourne-Again SHell）是Linux默认的Shell交互类型，也就是说在Linux中打开一个终端，就启动一个Bash进程。</p><h2 id="Bash命令格式"><a href="#Bash命令格式" class="headerlink" title="Bash命令格式"></a>Bash命令格式</h2><p>格式：命令名 [选项] [参数1] [参数2] … 有如下特点：</p><ul><li>命令名必须是小写英文字母。</li><li>一般格式中，方括号括起来的部分是可选选项。</li><li>选项是对命令的特别定义，以“-”开始。一个命令<strong>可以使用多个选项</strong>且多个选项连接起来同样有效（部分发行版不支持）。如：<code>ls -al</code>和<code>ls -a -l</code>效果相同。</li><li>命令正常执行后返回一个0表示执行成功，返回非0值表示执行过程出错。在终端上很难体现出来，但在shell脚本（后续会介绍）中可作为控制逻辑流程的一部分（用$?查看）。</li></ul><h2 id="Bash举例"><a href="#Bash举例" class="headerlink" title="Bash举例"></a>Bash举例</h2><p>查看内核版本号：<code>uname -a</code>:</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/查看内核版本号.jpg"></div><p><code>uname</code>是命令名，<code>-a</code>是选项，这个命令没有参数。</p><h2 id="uname解释"><a href="#uname解释" class="headerlink" title="uname解释"></a>uname解释</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/uname.png"></div><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>终端窗口中的命令以Enter键结束，且Shell命令区分大小写。如果命令太长，一行放不下时，在行尾输入<code>\</code>并按Enter键。这时Shell会返回一个大于号（&gt;）作为提示符，表示该命令行尚未结束，允许继续输入有关信息。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/输入.png"></div><h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>echo命令把命令行中的参数全部显示到标准输出（终端）中。如果参数用引号引起来，会按原样输出。否则会把各个单词按字符串输出，字符串之间用空格隔开。单引号/双引号的区别请看Shell那一部分。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/echo.png"></div><h2 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h2><p>Linux的标准输出是屏幕，把结果输出到指定的文件叫做输出重定向。</p><ul><li><code>&gt;</code>：目标文件不存在，系统将建立该文件；文件存在，重定向将会删除该文件，并重新建立一个新文件存放结果。</li><li><code>&gt;&gt;</code>：目标文件不存在，系统将建立该文件；如果目标文件存在，新的输出结果将会追加到文件末尾。</li></ul><h2 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h2><p>显示出当前所在目录的路径。</p><h2 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h2><p><code>history</code>命令可以看到用户所有曾经输入过的命令。</p><ul><li><code>!!</code>：执行上一个命令；</li><li>`!n：执行第n个命令；</li><li><code>!-n</code>：执行倒数第n个命令；</li><li><code>!xxx</code>：执行以xxx开头的命令，如之前使用过clear，<code>!cle</code>会执行clear。</li></ul><p><code>~/.bash_history</code>文件中会存储你近期使用过的命令。查看此文件：<code>cat ~/.bash_history</code></p><h2 id="date"><a href="#date" class="headerlink" title="date"></a>date</h2><ul><li><p><code>date</code>命令在屏幕上显示或设置系统的日期和时间：</p><ul><li><code>date [+格式控制字符串]格式控制字符串常用单引号引起来。年:Y 月:m 日:d 小时:H 分:M 秒:S</code></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/date1.png"></div></li><li><p>有且只有超级用户能设置或修改系统时钟，语法如下：</p><ul><li><code>date -s “year-month-day hour:minute:second”</code></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/date2.png"></div></li></ul><p>系统在启动的时候是从CMOS（用来存储计算机某些参数的芯片）中加载时钟，为了保持系统时间与CMOS时间的一致性，Linux每隔一段时间会将系统时间写入CMOS。由于该同步是每隔一段时间进行的，在我们执行<code>date -s</code>后，如果马上重起机器，修改时间就有可能没有被写入CMOS，而<code>hwclock –w</code>强制把系统时间写入CMOS。</p><h2 id="cal"><a href="#cal" class="headerlink" title="cal"></a>cal</h2><p>列出日历信息。</p><ul><li>单独一个cal：列出当前月的日历信息。</li><li>cal xxxx：列出xxxx年的日历信息。</li><li>cal yy xxxx：列出xxxx年yy月的日历信息。</li><li>cal dd yy xxxx：列出xxxx年yy月xx日所在月的日历信息。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/cal1.png"></div><h2 id="clear"><a href="#clear" class="headerlink" title="clear"></a>clear</h2><p>clear命令清除屏幕上的信息，清屏后，提示符移到屏幕左上角。</p><h2 id="关机-amp-重启"><a href="#关机-amp-重启" class="headerlink" title="关机 &amp; 重启"></a>关机 &amp; 重启</h2><ul><li><code>shutdown -h now</code>：立刻关机</li><li><code>shutdown -h 15:30</code>：15:30 关机</li><li><code>shutdown -h +30</code>：30 分钟后关机</li><li><code>reboot</code>：重启</li><li><code>shutdown -k +2 &quot;一会要关机，抓紧保存&quot;</code>：向所有用户输出关机通知，但不做真正操作。<code>+2</code>表示通知的关机时间是现在之后的两分钟。</li></ul><h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><p>如果我们忘记某些命令或其参数如何使用，需要使用帮助命令。</p><ul><li><code>whatis &lt;命令&gt;</code>：显示命令的简短描述。</li><li><code>&lt;命令&gt; -help</code>：显示使用方法概述和参数列表。</li><li><code>man &lt;命令&gt;</code>：为命令提供相关帮助文档，页面分成章节。</li><li><code>info &lt;命令&gt;</code>：类似man命令，但是通常比它更详细。</li></ul><h2 id="切换路径命令"><a href="#切换路径命令" class="headerlink" title="切换路径命令"></a>切换路径命令</h2><ul><li><code>cd &lt;位置&gt;</code>：切换到指定位置；</li><li><code>cd ~</code>：切换到用户家目录；</li><li><code>cd -</code>：切换到上一个所在目录；</li></ul><h2 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h2><p>修改密码。</p><ul><li><code>单独的passwd</code>：修改使用该命令的用户的密码。</li><li><code>passwd 用户名</code>：root用户可以使用该命令修改其他用户的密码。</li></ul><h2 id="Linux用户"><a href="#Linux用户" class="headerlink" title="Linux用户"></a>Linux用户</h2><p>登录Linux系统时，必须通过指定的用户名和密码进行登录。不过所有的用户在Linux眼中都是一个数字，用userid（一个32位的二进制整数）来表示。可以通过id命令，查看自己的userid。userid为0的表示根用户。同时，在系统运行的每个进程、所创建的每个文件都有一个userid，这个userid代表运行这个程序的用户，或者文件的所有者。Linux系统中，用户被保存在<code>/etc/passwd</code>文件中。用户又分成三类：一般用户（userid&gt;=500）、超级用户（userid=0）和系统用户（userid&lt;500）。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/linux用户.png"></div><h2 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h2><p>Linux是一个多用户系统，即很多个用户同时操作一个设备中的资源，但不同的用户有不同的权限。这些用户中有一个是超级用户（root），它是权限最高的用户。root用户在终端中的输入命令以#开头，其他的用户以$开头。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/root.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/user.png"></div><ul><li><p><code>who</code>：列出正在使用系统的<strong>所有</strong>用户、所用的终端名和注册到系统的时间。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/who.png"></div></li><li><p><code>who am i</code>：列出<strong>使用该命令</strong>的用户、所用的终端名和注册到系统的时间。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/whoi.png"></div></li></ul><h2 id="用户组"><a href="#用户组" class="headerlink" title="用户组"></a>用户组</h2><p>由于不同的用户有不同的权限。为了给不同的用户赋予相同的权限更加方便，诞生了用户组的概念。即同一个用户组里的人员可以有相同的某些权限。<strong>Linux中的用户或文件至少属于一个用户组</strong>。</p><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><p><code>useradd</code>或者<code>adduser</code>。执行后的具体操作（不同发行版有区别）：</p><ul><li><p>分配一个新的userid，数值等于之前所有userid中数值最大的加一。</p></li><li><p>在/etc/passwd中添加一行。</p></li><li><p>为用户在/home下建立一个新的目录（用户的家目录），目录名和用户名相同。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/adduser.png"></div></li><li><p>在/etc/group中为用户建立一个新的个人组。</p></li><li><p>在/var/spool/mail中创建用户的邮件文件。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/addmail.png"></div></li></ul><h2 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h2><p><code>userdel &lt;用户&gt;</code>。删除用户及部分相关信息，家目录和邮件文件还会存在。</p><ul><li><code>-r</code>：包括家目录和邮件池等在内的所有用户信息都会被删除。</li></ul><h2 id="添加-删除组"><a href="#添加-删除组" class="headerlink" title="添加/删除组"></a>添加/删除组</h2><ul><li><code>groupadd &lt;组名&gt;</code>。所有的组都保存在/etc/group文件中。</li><li><code>groupdel &lt;组名&gt;</code>。删除组。</li></ul><h2 id="etc-passwd-amp-etc-shadow"><a href="#etc-passwd-amp-etc-shadow" class="headerlink" title="/etc/passwd &amp; /etc/shadow"></a>/etc/passwd &amp; /etc/shadow</h2><ul><li><p><code>/etc/passwd</code>有7列：用户名、密码、用户id、主要组id、备注信息、主目录、登录shell。</p><ul><li>各列之间使用<code>:</code>分割。同时密码一般都是x（被加密了），加密后的密码在/etc/shadow中。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/passwd.png"></div></li><li><p><code>/etc/shadow</code>有9列：用户名、加密密码、最近更改密码的日期、密码不可更改的天数、密码需要重新更改的天使、密码更改期限前的警告期限、密码过期的宽限时间、帐号失效日期、保留字段。但这里显示的密码是加密的。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/shadow.png"></div></li></ul><h2 id="查看用户所属的组"><a href="#查看用户所属的组" class="headerlink" title="查看用户所属的组"></a>查看用户所属的组</h2><ul><li><code>groups</code>：查看使用此命令的用户所属组；</li><li><code>groups &lt;用户&gt;</code>：查看指定用户所属组。用户可多选，使用空格隔开。</li></ul><h2 id="etc-group-amp-etc-gshadow"><a href="#etc-group-amp-etc-gshadow" class="headerlink" title="/etc/group &amp; /etc/gshadow"></a>/etc/group &amp; /etc/gshadow</h2><ul><li><code>/etc/group</code>：组名、组密码、组id、组中附加用户。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/group.png"></div><ul><li><code>/etc/gshadow</code>：组名、密码、组管理者、组中附加用户。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/gshadow.png"></div><h2 id="为用户添加备注"><a href="#为用户添加备注" class="headerlink" title="为用户添加备注"></a>为用户添加备注</h2><ul><li>在创建的时候添加：<code>useradd -c &lt;备注&gt; 用户名</code>。</li><li>创建后修改：<code>usermod -c &lt;备注&gt; 用户名</code>。（会清除之前的备注信息）。</li></ul><h2 id="usermod"><a href="#usermod" class="headerlink" title="usermod"></a>usermod</h2><p>改变用户某些属性的命令。</p><ul><li><p><code>-l</code>：改变用户的名称；</p></li><li><p><code>-G</code>：改变用户支持的用户组，会退出原来的附属组，配合<code>-a</code>不会删除之前组；</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/usermodag.png"></div></li><li><p><code>-L</code>：不让该用户登录；</p></li><li><p><code>-e</code>：设定用户失效日期。日期格式：“YYYY-MM-DD”。</p></li><li><p><code>-s</code>：改变Shell。新创建的用户默认使用bash，此选项修改登录Shell。</p><ul><li>如：<code>usermod -aG 组名 用户</code></li></ul></li></ul><h2 id="gpasswd"><a href="#gpasswd" class="headerlink" title="gpasswd"></a>gpasswd</h2><p><code>gpasswd -d userName groupNam</code>e：从组中删除用户</p><h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><ul><li>超级用户输入<code>su 用户名</code>可以不用输入密码切换到其他用户。</li><li>普通用户切换到其他所有用户（<code>su 用户名</code>）需要输入密码。</li></ul><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。</p><ul><li><p>文件：文件系统中存储数据的一个命名的对象。即使是空文件（不包含用户数据）也会为操作系统提供其他信息。</p></li><li><p>目录：包含文件项目的一类特殊文件。Linux中在应用层上来看目录和文件是被区分开来的。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/filesys.png"></div></li></ul><h2 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h2><p><code>find &lt;路径&gt; -name &#39;正则表达式&#39;</code>：如<code>find . -name &#39;*.so&#39;</code>，查找当前目录下以<code>.so</code>结尾的文件。</p><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><ul><li><code>cat &lt;文件&gt;</code>：显示文件的内容。文件可以多选，之间用空格隔开。</li><li><code>cat f1 &gt; f2</code>：把f1文件的内容合并到f2文件中。</li></ul><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><ul><li><p>文件不存在：则创建一个空的新文件；</p></li><li><p>文件存在：把文件的时间标签更新为系统当前时间。</p></li></ul><h2 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h2><p>命令的意思：global search regular expression and print out the line。</p><h3 id="部分选项如下："><a href="#部分选项如下：" class="headerlink" title="部分选项如下："></a>部分选项如下：</h3><ul><li><code>-a</code>：将 binary 文件以 text 文件的方式搜寻数据</li><li><code>-c</code>：计算找到 ‘搜寻字符串’ 的次数</li><li><code>-i</code>：忽略大小写的不同，所以大小写视为相同</li><li><code>-n</code>：顺便输出行号</li><li><code>-v</code>：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！</li><li><code>--color=auto</code>：可以将找到的关键词部分加上颜色的显示喔！</li></ul><h3 id="举例如下："><a href="#举例如下：" class="headerlink" title="举例如下："></a>举例如下：</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/grep.jpg"></div><h2 id="管道命令"><a href="#管道命令" class="headerlink" title="管道命令"></a>管道命令</h2><p>管道命令是用来过滤信息的，比如我们之前<code>grep -n root /etc/passwd</code>之后显示带有root的行，如果想在结果中再按其他条件过滤就要使用管道命令：“|”。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/管道.png"></div><h2 id="统计文件信息"><a href="#统计文件信息" class="headerlink" title="统计文件信息"></a>统计文件信息</h2><p><code>wc</code>：统计指定文件的字节数（<code>-c</code>）、字数（<code>-w</code>）、行数（<code>-l</code>）</p><ul><li>例子：统计文件a中以b开头的行数：<code>cat a | grep ^b | wc -l</code></li></ul><h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><p><code>mkdir &lt;文件名&gt;</code>。</p><ul><li><code>-p</code>：父目录不存在时也可以创建。</li></ul><h2 id="删除文件-目录"><a href="#删除文件-目录" class="headerlink" title="删除文件/目录"></a>删除文件/目录</h2><p><code>rm -rf &lt;文件名&gt;</code>。<code>-r</code>表示递归删除；<code>-f</code>表示强制删除，不询问。</p><h2 id="列出文件"><a href="#列出文件" class="headerlink" title="列出文件"></a>列出文件</h2><p><code>ls</code>命令列出指定目录的内容。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ls.png"></div><ul><li><p><code>-l</code>：文件的详细信息。输出的信息分成多列，它们依次是：文件类型与权限、链接数、文件主、文件组、文件大小、建立或最近修改的时间、文件名。total的计算：<a href="https://yq.aliyun.com/ziliao/264744" target="_blank" rel="noopener">https://yq.aliyun.com/ziliao/264744</a>。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ll.png"></div></li><li><p><code>-a</code>：显示所有文件。之前显示的没有隐藏文件（以<code>.</code>开头）。</p></li><li><p><code>-h</code>：文件大小以人类可读的方式显示。需要配合<code>-l</code>使用。</p></li></ul><h2 id="拷贝文件"><a href="#拷贝文件" class="headerlink" title="拷贝文件"></a>拷贝文件</h2><p><code>cp &lt;文件&gt; &lt;目录&gt;</code>。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/cp.png"></div><h2 id="剪切文件"><a href="#剪切文件" class="headerlink" title="剪切文件"></a>剪切文件</h2><p><code>mv &lt;文件&gt; &lt;目录&gt;</code>。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/mv.png"></div><h2 id="修改文件名"><a href="#修改文件名" class="headerlink" title="修改文件名"></a>修改文件名</h2><p><code>mv &lt;文件&gt; &lt;新文件名&gt;</code>。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/mvname.png"></div><h2 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h2><p>Linux中所有的文件都由两部分构成。</p><ul><li><p>索引结点：包含此文件的信息，如文件权限、文件主、文件大小等。</p></li><li><p>数据：文件的实际内容，有没有数据都可以。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/文件结构.png"></div></li></ul><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><p>链接就是把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。</p><ul><li><p>硬链接：硬链接是多一个文件名和inode结点关联。由于它依赖于inode，所以不能在不同的文件系统之间做硬链接。硬链接不能用于目录。用法：<code>ln &lt;被链接的文件&gt; &lt;新的文件名&gt;</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/hardlink.png"></div></li><li><p>软连接：软连接是再拓展出一份inode，这个inode指向的区域保存如何找到真正数据的信息。用法：<code>ln -s &lt;被链接的文件&gt; &lt;新的文件名&gt;</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/software.png"></div></li></ul><h2 id="用户和权限"><a href="#用户和权限" class="headerlink" title="用户和权限"></a>用户和权限</h2><ul><li><p>文件主：文件所有者，并赋予唯一的注册名。只有文件主或root才有权利用<code>chown</code>命令改变文件的所有关系（UID）。</p></li><li><p>用户组：通常，组中包含了有相同需求的用户。文件主或超级用户（root）可以利用<code>chgrp</code>命令改变文件的GID。</p></li><li><p>用户存取权限：Linux系统中规定了4种不同类型的用户：文件主、同组用户、其他用户、超级用户。</p></li><li><p>3种访问文件或目录的方式：r（读）、w（写）、 x（可执行或查找）。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/用户与权限.png"></div></li></ul><h2 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h2><ul><li><p>只有文件主或超级用户root才有权用<code>chmod</code>命令改变文件或目录的存取权限。</p></li><li><p>使用格式：<code>chmod [选项] MODE 文件</code>。MODE可多选，之间用<code>,</code>隔开。</p><ul><li>MODE：<code>&lt;who&gt;&lt;操作符号&gt;&lt;权限&gt;</code>。<ul><li>who：u——user、g——group、o——others、a——all（可叠加）。</li><li>操作符号：<code>+ 添加</code>、<code>- 取消</code>、<code>= 赋予</code>；</li><li>权限：r 读、w 写、x 执行。（可叠加）</li></ul></li></ul></li><li><p>举例</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/chmod.png"></div></li><li><p>以绝对方式改变权限</p><ul><li><p>置为1表示有相应权限，置为0表示没有相应权限。例如：</p><p><code>r w x r - x r - -</code></p><p><code>1 1 1 1 0 1 1 0 0</code></p></li><li><p>转换成十进制是754。<code>chmod 754 aa</code>和<code>chmod u=rwx,g=rx,o=r aa</code>一致。</p></li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/chmod绝对.png"></div></li></ul><h2 id="umask"><a href="#umask" class="headerlink" title="umask"></a>umask</h2><p>官方的解释是掩码，其实就是用户创建文件或目录后它们的默认权限。不过和<code>chomd</code>有区别的是它把有权限设置为0，没权限设置为1，而且<code>umask</code>命令显示的是八进制数字。我的<code>umask</code>显示的是0022，转换成二进制就是000 010 010，转换成权限就是<code>rwx r-x r-x</code>。所以创建的目录的默认权限就是这个。但是Linux不允许新创建的文件有可执行权限，所以创建的文件的默认权限是<code>rw- r-- r--</code>。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/umask.png"></div><h2 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h2><p>改变某个文件或目录的所有者。<code>chown &lt;用户&gt; &lt;文件&gt;/&lt;目录&gt;</code></p><h2 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h2><p>改变文件或目录所属的用户组。<code>chgrp &lt;用户组&gt; &lt;文件&gt;/&lt;目录&gt;</code></p><h2 id="文件权限的理解"><a href="#文件权限的理解" class="headerlink" title="文件权限的理解"></a>文件权限的理解</h2><ul><li>可读（r）：浏览文件中的内容；</li><li>可写（w）：修改文件中的内容；</li><li>可执行（x）：将文件作为命令使用。</li></ul><h2 id="目录权限的理解"><a href="#目录权限的理解" class="headerlink" title="目录权限的理解"></a>目录权限的理解</h2><ul><li><p>可读：只能查看到目录下的子目录名和文件名；</p></li><li><p>可执行：可以访问目录中的文件，包括子目录；</p></li><li><p>可写：要在目录下添加删除目录和文件，必须有可执行的权利。</p></li></ul><h2 id="压缩-amp-打包-amp-解压缩"><a href="#压缩-amp-打包-amp-解压缩" class="headerlink" title="压缩 &amp; 打包 &amp; 解压缩"></a>压缩 &amp; 打包 &amp; 解压缩</h2><ul><li><code>tar -zcvf</code>：打包压缩后的文件名 要打包压缩的文件（多个之间用space分开）<ul><li><code>z</code>：调用gzip压缩命令进行压缩</li><li><code>c</code>：create，打包文件</li><li><code>v</code>：显示运行过程</li><li><code>f</code>：指定文件名</li></ul></li><li><code>tar -xvf xxx.tar.gz -C 位置</code><ul><li><code>x</code>：extract，解包</li><li><code>v</code>：显示允许过程</li><li><code>f</code>：指定文件名</li></ul></li></ul><h2 id="别名"><a href="#别名" class="headerlink" title="别名"></a>别名</h2><p>我们可以使用ll代替<code>ls -l</code>。但是对于<code>ls -a</code>，系统并没有提供<code>la</code>命令，不过我们可以使用<code>alias</code>定义<code>la</code>。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/别名.png"></div><p>取消别名使用<code>unalias 别名</code></p><h2 id="定时任务"><a href="#定时任务" class="headerlink" title="定时任务"></a>定时任务</h2><p><code>cron</code>工具允许用户配置要定期运行的任务，通过配置<code>crontab</code>的文件可以指定要运行哪些作业以及何时运行。配置<code>crontab</code>文件使用命令<code>crontab</code>。命令由6个用空白分隔的字段组成：</p><table><thead><tr><th>字段</th><th>minute</th><th>hour</th><th>day of month</th><th>month</th><th>day of week</th><th>command to run</th></tr></thead><tbody><tr><td>举例</td><td>45</td><td>16</td><td>*</td><td>*</td><td>*</td><td>date&gt;/tmp/date.txt</td></tr><tr><td>范围</td><td>0-59</td><td>0-23</td><td>1-31</td><td>1-12</td><td>0-7</td><td>*</td></tr></tbody></table><p>corntab命令的参数：</p><ul><li><code>-e</code>：编辑<code>crontab</code>的内容（会打开一个文件）；</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/crone.png"></div><ul><li>设置定期任务（16:45时把当前时间写入<code>/tmp/date.txt</code>文件中）：</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/设置定期任务.png"></div><ul><li><p>过一段时间之后查看<code>/tmp</code>文件夹：</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/查看定时任务.png"></div></li><li><p><code>-u</code>：只有root才能执行这个选项，帮助其他用户建立/删除<code>crontab</code>；</p></li><li><p><code>-l</code>：查看crontab的工作内容:</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/cronl.png"></div></li><li><p><code>-r</code>：删除crontab的工作内容；</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/cronr.png"></div></li></ul><h2 id="成组命令"><a href="#成组命令" class="headerlink" title="成组命令"></a>成组命令</h2><p>被成组命令约束的命令被认为是一条命令。</p><ul><li><code>{ 命令; }</code>：需要有空格和命令隔开，且命令后面需要“<code>;</code>”。不创建子进程。</li><li><code>(命令)</code>：不强制需要有空格和命令隔开，不强制需要“<code>;</code>”。创建子进程完成功能。</li></ul><p>例如下例把两条ls命令的值全部由管道输入给grep。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/成组命令.png"></div><h2 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h2><p>sort lines of text files，将文本文件内容加以排序，以行为单位来排序，但不改变文件原始内容。</p><ul><li><p>默认排序规则：从第每行一个字符开始，依次按照ASCII码值进行比较。</p></li><li><p><code>-n</code>：按数字的大小排序，默认情况下把数字看成字符。</p></li><li><p><code>-r</code>：反转排序效果。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/testsort.jpg"></div></li></ul><h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p>文件输出时，删除重复行或列。但如果重复的行不连续则不起作用。</p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><ul><li>-：普通文件</li><li>l：符号链接文件</li><li>d：目录</li><li>s：套接字文件（socket）</li><li>b：块设备文件</li><li>p：命名管道文件（pipe）</li><li>c：字符设备文件</li></ul><h2 id="ex1：用户管理"><a href="#ex1：用户管理" class="headerlink" title="ex1：用户管理"></a>ex1：用户管理</h2><h3 id="在系统中添加三个用户：Blondie、Prince和Madonna"><a href="#在系统中添加三个用户：Blondie、Prince和Madonna" class="headerlink" title="在系统中添加三个用户：Blondie、Prince和Madonna"></a>在系统中添加三个用户：Blondie、Prince和Madonna</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex11.png"></div><h3 id="他们都希望属于次要组music"><a href="#他们都希望属于次要组music" class="headerlink" title="他们都希望属于次要组music"></a>他们都希望属于次要组music</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex12.png"></div><h3 id="Blondie要求在他的条目中添加特殊备注“heart-of-glass”"><a href="#Blondie要求在他的条目中添加特殊备注“heart-of-glass”" class="headerlink" title="Blondie要求在他的条目中添加特殊备注“heart of glass”"></a>Blondie要求在他的条目中添加特殊备注“heart of glass”</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex13.png"></div><h3 id="Prince要求使用-bin-csh作为登录shell"><a href="#Prince要求使用-bin-csh作为登录shell" class="headerlink" title="Prince要求使用/bin/csh作为登录shell"></a>Prince要求使用/bin/csh作为登录shell</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex14.png"></div><h3 id="Madonna的使用期限为2020-12-1。"><a href="#Madonna的使用期限为2020-12-1。" class="headerlink" title="Madonna的使用期限为2020-12-1。"></a>Madonna的使用期限为2020-12-1。</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex15.png"></div><h3 id="Blondie决定加入摔跤俱乐部wrestle组。"><a href="#Blondie决定加入摔跤俱乐部wrestle组。" class="headerlink" title="Blondie决定加入摔跤俱乐部wrestle组。"></a>Blondie决定加入摔跤俱乐部wrestle组。</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex161.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex162.png"></div><h3 id="Prince要将他的用户名改为tafkap。"><a href="#Prince要将他的用户名改为tafkap。" class="headerlink" title="Prince要将他的用户名改为tafkap。"></a>Prince要将他的用户名改为tafkap。</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex17.png"></div><h3 id="Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。"><a href="#Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。" class="headerlink" title="Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。"></a>Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。</h3><ul><li><code>groupadd fengshui</code></li><li><code>usermod -a –G fengshui Madonna</code></li><li><code>usermod –u 888 Madonna</code></li></ul><h3 id="Prince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。"><a href="#Prince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。" class="headerlink" title="Prince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。"></a>Prince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。</h3><ul><li><code>usermod –L Prince</code></li></ul><h3 id="Blondie最近表现不好，我们决定将他踢出去。"><a href="#Blondie最近表现不好，我们决定将他踢出去。" class="headerlink" title="Blondie最近表现不好，我们决定将他踢出去。"></a>Blondie最近表现不好，我们决定将他踢出去。</h3><ul><li><code>userdel –r Blondie</code>（想把该用户所有信息都一起删除可以使用-r）</li></ul><h2 id="ex2：文件目录管理"><a href="#ex2：文件目录管理" class="headerlink" title="ex2：文件目录管理"></a>ex2：文件目录管理</h2><h3 id="Ventura同时属于次要组governor和wrestle。"><a href="#Ventura同时属于次要组governor和wrestle。" class="headerlink" title="Ventura同时属于次要组governor和wrestle。"></a>Ventura同时属于次要组governor和wrestle。</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex21.png"></div><h3 id="Ventura撰写了自己的摔跤计划plans-txt，并将它放到目录-tmp下。"><a href="#Ventura撰写了自己的摔跤计划plans-txt，并将它放到目录-tmp下。" class="headerlink" title="Ventura撰写了自己的摔跤计划plans.txt，并将它放到目录/tmp下。"></a>Ventura撰写了自己的摔跤计划plans.txt，并将它放到目录/tmp下。</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex22.png"></div><h3 id="Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。"><a href="#Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。" class="headerlink" title="Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。"></a>Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex22.png"></div><h3 id="用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？"><a href="#用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？" class="headerlink" title="用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？"></a>用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex24.png"></div><h3 id="用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？"><a href="#用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？" class="headerlink" title="用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？"></a>用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？</h3><p>不可以，只有root和文件主能修改文件访问权。</p><h2 id="vi-amp-vim"><a href="#vi-amp-vim" class="headerlink" title="vi &amp; vim"></a>vi &amp; vim</h2><p>这俩都是文本编辑器。vi是Linux默认的编辑器，类似于windows的记事本。vim是vi的拓展，比vi更强大。可以用于在Linux中编辑文件内容。笔记中使用vim。它有两种模式，命令模式和编辑模式，在命令模式中可以做一些检索、筛选等操作。在编辑模式中可以对文档进行修改。</p><h2 id="进入-amp-退出"><a href="#进入-amp-退出" class="headerlink" title="进入 &amp; 退出"></a>进入 &amp; 退出</h2><h3 id="进入命令模式"><a href="#进入命令模式" class="headerlink" title="进入命令模式"></a>进入命令模式</h3><p>方法：<code>vim &lt;文件名&gt;</code>。此时进入命令模式，不能对文件内容进行操作。对文档的检索是在这种模式下进行的。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/vima.png"></div><h3 id="进入编辑模式："><a href="#进入编辑模式：" class="headerlink" title="进入编辑模式："></a>进入编辑模式：</h3><h4 id="i：编辑位置在当前光标位置之前"><a href="#i：编辑位置在当前光标位置之前" class="headerlink" title="i：编辑位置在当前光标位置之前"></a><code>i</code>：编辑位置在当前光标位置之前</h4><p>按下<code>i</code>再按<code>_</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/i1.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/i2.png"></div><h4 id="I：在光标所在行的行首插入新增文本"><a href="#I：在光标所在行的行首插入新增文本" class="headerlink" title="I：在光标所在行的行首插入新增文本"></a>I：在光标所在行的行首插入新增文本</h4><p>按下<code>I</code>再按<code>_</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/I11.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/I22.png"></div><h4 id="a：在该命令之后输入的字符都插到光标之后"><a href="#a：在该命令之后输入的字符都插到光标之后" class="headerlink" title="a：在该命令之后输入的字符都插到光标之后"></a><code>a</code>：在该命令之后输入的字符都插到光标之后</h4><p>按下<code>a</code>再按<code>_</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/a1.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/a1.png"></div><h4 id="A：在光标所在行的行尾添加文本"><a href="#A：在光标所在行的行尾添加文本" class="headerlink" title="A：在光标所在行的行尾添加文本"></a>A：在光标所在行的行尾添加文本</h4><p>按下<code>A</code>再按<code>_</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/A11.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/a22.png"></div><h4 id="o：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行"><a href="#o：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行" class="headerlink" title="o：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行"></a><code>o</code>：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行</h4><p>按下<code>o</code>再按<code>_</code></p><div align="center"><img src="/03-vim/o1.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/o2.png"></div><h4 id="O：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上"><a href="#O：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上" class="headerlink" title="O：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上"></a><code>O</code>：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上</h4><p>按下<code>O</code>再按<code>_</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/o11.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/o2.png"></div><h4 id="r：替换光标所在的哪一个字符"><a href="#r：替换光标所在的哪一个字符" class="headerlink" title="r：替换光标所在的哪一个字符"></a><code>r</code>：替换光标所在的哪一个字符</h4><p>按下<code>r</code>再按<code>_</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/r1.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/r2.png"></div><h4 id="R：一直替换光标所在的文字，直到按下ESC为止"><a href="#R：一直替换光标所在的文字，直到按下ESC为止" class="headerlink" title="R：一直替换光标所在的文字，直到按下ESC为止"></a><code>R</code>：一直替换光标所在的文字，直到按下ESC为止</h4><p>按下<code>R</code>再按三次<code>_</code>再按<code>Esc</code></p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/r11.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/r22.png"></div><h3 id="退出编辑模式"><a href="#退出编辑模式" class="headerlink" title="退出编辑模式"></a>退出编辑模式</h3><p>在编辑模式下按 Esc 键。</p><h3 id="退出命令模式"><a href="#退出命令模式" class="headerlink" title="退出命令模式"></a>退出命令模式</h3><p>需要使用转义字符<code>:</code></p><ul><li><code>:q</code>：若未修改文件，此命令可以退出编辑器。</li><li><code>:wq</code>：把编辑缓冲区的内容写入文件中，退出编辑器，回到Shell下。</li><li><code>:ZZ</code>或<code>:x</code>：仅当作过修改时才将缓冲区内容写到文件上。</li><li><code>:q!</code>： 强行退出vi。告诉vi，无条件退出，丢弃缓冲区内容。</li></ul><h2 id="vim流程图"><a href="#vim流程图" class="headerlink" title="vim流程图"></a>vim流程图</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/vim流程图.png"></div><h2 id="命令模式下的光标跳转"><a href="#命令模式下的光标跳转" class="headerlink" title="命令模式下的光标跳转"></a>命令模式下的光标跳转</h2><ol><li>方向键和Backspace键的使用和正常情况下相同。</li><li>移动到上一行，列不变：<code>k</code></li><li>移动到上一行行头：<code>-</code></li><li>移动到下一行，列不变：<code>j</code></li><li>移动到下一行行头：<code>+</code></li><li>如果在相应命令的前面加上一个数字<code>n</code>，相应命令执行<code>n</code>次。如<code>2k</code>表示向上移动两行，列不变。</li><li>移至行首：<code>^</code>或<code>0</code></li><li>移至行尾：<code>$</code></li><li>移至指定行：行号<code>G</code>。如<code>2G</code>，移动到第二行行首。</li><li>移至指定列：列号<code>|</code>。如<code>2|</code>，移动到本行第2列。</li></ol><h2 id="文本删除"><a href="#文本删除" class="headerlink" title="文本删除"></a>文本删除</h2><ol><li>命令<code>x</code>（小写字母）删除光标所在的字符。</li><li>命令<code>X</code>（大写字母）删除光标前面的那个字符</li><li>命令<code>dd</code>删除光标所在的整行</li><li>命令<code>D</code>从光标位置开始删除到行尾</li><li><code>d&lt;光标移动命令&gt;</code>删除从光标位置开始至光标移动命令之间的所有字符。如：<ol><li><code>d0</code>：从光标位置（不包括光标位）删至行首。</li><li><code>d3l</code>：从光标位置（包括光标位）向右删3个字符。</li><li><code>d$</code>：从光标位置（包括光标位）删至行尾。与D相同。</li><li><code>d5G</code>：将光标所在行至第5行都删除。</li></ol></li></ol><h2 id="复原命令"><a href="#复原命令" class="headerlink" title="复原命令"></a>复原命令</h2><ol><li><code>u</code>：取消前面刚执行的插入或删除命令的效果，恢复到此前的情况。</li><li><code>U</code>：总是把当前行恢复成它被编辑之前的状态。</li></ol><h2 id="重复命令"><a href="#重复命令" class="headerlink" title="重复命令"></a>重复命令</h2><p><code>.</code>：在命令模式下，重复执行前一次插入命令或删除命令</p><h2 id="补充文本编辑"><a href="#补充文本编辑" class="headerlink" title="补充文本编辑"></a>补充文本编辑</h2><h3 id="命令方式下"><a href="#命令方式下" class="headerlink" title="命令方式下"></a>命令方式下</h3><ol><li><code>d0</code>：删至行首</li><li><code>d$</code>：删至行尾</li><li><code>ndd</code>：删除当前行及其后的n-1行</li><li><code>yy</code>：复制当前行的文本</li><li><code>10yy</code>：复制包括当前行及其后面9行文本</li><li><code>p</code>：在当前行后面插入一个空行，把缓冲区的内容粘贴过来</li><li><code>P</code>：在当前行前面插入一个空行，把缓冲区的内容粘贴过来</li></ol><h3 id="ex转移方式下"><a href="#ex转移方式下" class="headerlink" title="ex转移方式下"></a>ex转移方式下</h3><ol><li><code>:n1,n2 d</code>：将n1行到n2行的内容删除</li><li><code>:n1,n2 co n3</code>：将n1行到n2行的内容复制到n3行下</li><li><code>:n1,n2 m n3</code>：将n1行到n2行的内容移到n3行下</li></ol><h2 id="字符串检索"><a href="#字符串检索" class="headerlink" title="字符串检索"></a>字符串检索</h2><ul><li>向下检索：/模式〈Enter〉。例如：/int</li><li>向上检索：?模式〈Enter〉。例如：?flout</li></ul><h2 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h2><ol><li><code>:n1,n2s/word1/word2/g</code>：<code>n1</code>和<code>n2</code>为数字。在<code>n1</code>与<code>n2</code>行之间寻找<code>word1</code>这个字符串，并将该字符串替换为<code>word2</code>。例如<code>:100,200s/a/A</code>在100行到200行之间搜索a并替换成A。</li><li><code>:1,$s/word1/word2/gc</code>：全局搜索word1，替换成word2。<code>g</code>改成<code>gc</code>表示要用户确认。</li><li><code>:%s/$/s2/g</code>：在整个行的末尾添加s2。</li><li>全局替换命令g：<code>:g/模式/命令表</code>。</li><li><code>:g/s1/p</code>：打印文本中有s1的行。p命令表示打印。</li></ol><h2 id="块选择"><a href="#块选择" class="headerlink" title="块选择"></a>块选择</h2><p><code>ctrl+v</code>，然后使用方向键选择块。</p><ol><li><code>y</code>：复制反白的地方</li><li><code>d</code>：将反白的地方删除掉</li><li><code>p</code>：插入复制的内容</li></ol><p>参考：<a href="https://jingyan.baidu.com/article/84b4f565c6b9e560f6da3291.html。" target="_blank" rel="noopener">https://jingyan.baidu.com/article/84b4f565c6b9e560f6da3291.html。</a></p><h2 id="Linux的进程状态"><a href="#Linux的进程状态" class="headerlink" title="Linux的进程状态"></a>Linux的进程状态</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/Linux进程管理.png"></div><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><p><code>Process Status</code>。查看进程状态的最常用的命令，它可以提供关于进程的许多信息。</p><ul><li><p>直接用ps命令可以列出每个与你的当前Shell有关的进程的基本信息。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ps.png"></div></li><li><p><code>ps -ef</code>：显示系统中所有进程的全面信息。</p><ul><li><p><code>-e</code>：显示所有进程</p></li><li><p><code>-f</code>：全格式</p></li><li><p>用户ID、进程ID、父进程ID、CPU占用率、开始时间、开始此进程的终端设备、此进程运行的总时间、命令名。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/psef.png"></div></li></ul></li><li><p><code>ps aux</code>显示所有终端上所有用户的有关进程的所有信息。</p></li></ul><h2 id="终结进程"><a href="#终结进程" class="headerlink" title="终结进程"></a>终结进程</h2><ul><li>通常来说，终结一个前台进程可以使用<code>Ctrl+C</code>。</li><li>终结一个后台进程得使用<code>kill</code>命令。<code>kill &lt;进程号&gt;</code>。如果想强制杀掉一个进程需要使用-9：<code>kill -9 &lt;进程号&gt;</code></li></ul><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>使进程暂停由时间值所指定的秒数。此命令大多用于shell程序设计中，使两条命令执行之间停顿指定的时间。如：<code>sleep 100; who | grep &#39;root&#39;</code>。</p><h2 id="wait"><a href="#wait" class="headerlink" title="wait"></a>wait</h2><p><code>wait</code>是用来阻塞当前进程的执行，直至指定的子进程执行结束后，才继续执行。</p><ul><li><code>wait [进程号 或 作业号]</code>：eg：wait 23 or wait %1</li><li>如果<code>wait</code>后面不带任何的进程号或作业号，那么<code>wait</code>会阻塞当前进程的执行，直至当前进程的所有子进程都执行结束后，才继续执行。</li></ul><h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p>fork()函数会创建一个和原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事。但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。fork()调用一次，<strong>分别向父子进程返回</strong>，它可能有三种不同的返回值：</p><ul><li>在父进程中，fork()返回新创建子进程的进程ID；</li><li>在子进程中，fork()返回0；</li><li>如果出现错误，fork()返回一个负值；</li></ul><p>所以我们可以通过fork返回的值来判断当前进程是子进程还是父进程。同时每个进程都有一个互不相同的进程标识符（process ID），可以通过getpid()函数获得，还有一个记录父进程pid的变量，可以通过getppid()函数获得变量的值。</p><h2 id="题1"><a href="#题1" class="headerlink" title="题1"></a>题1</h2><h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t1代码.png"></div><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t1结果.png"></div><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>程序运行到第7行，创建一个新的进程，克隆一份当前进程。向父进程返回子进程的pid，向子进程返回0。所以执行后父进程进入第3个分支，子进程进入第2个分支。</p><h2 id="题2"><a href="#题2" class="headerlink" title="题2"></a>题2</h2><h3 id="源代码-1"><a href="#源代码-1" class="headerlink" title="源代码"></a>源代码</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t2代码.png"></div><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t2结果.png"></div><h3 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t2分析.png"></div><h2 id="题3"><a href="#题3" class="headerlink" title="题3"></a>题3</h2><h3 id="源代码-2"><a href="#源代码-2" class="headerlink" title="源代码"></a>源代码</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t3代码.png"></div><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t3结果.png"></div><h3 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t3分析.png"></div><h2 id="题4"><a href="#题4" class="headerlink" title="题4"></a>题4</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t4.jpg"></div><h3 id="分析-3"><a href="#分析-3" class="headerlink" title="分析"></a>分析</h3><p>执行第5行之后，向父进程返回真，向子进程返回假，但是没有任何影响，此时创建了一个进程，之后父子进程创建的进程个数相同，所以只分析一个再乘以2即可。第一个子进程分析结果如下图。注意，对于<code>A &amp;&amp; B || C</code>：</p><ul><li>表达式A为假，B不执行，C执行；</li><li>表达式A为真，B执行：<ul><li>B为真：C不执行；</li><li>B为假：C执行。</li></ul></li></ul><p>所以答案是<code>1+9*2=19</code>个。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/t4图.png"></div><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Shell是一个命令解释器，用户输入命令来获得自己想要的结果，但是终端中输入的命令很难进行高级语言的选择、循环等操作。不过Shell程序可以存放在文件上，称为Shell脚本（虽然Linux文件不以后缀名区分文件类型，但是一般编写Shell脚本时文件名会命名为以<code>.sh</code>结尾）。在脚本中可以较方便的进行类似高级语言的操作。</p><h2 id="最简单的Shell脚本"><a href="#最简单的Shell脚本" class="headerlink" title="最简单的Shell脚本"></a>最简单的Shell脚本</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/最简单shell脚本.jpg"></div><p>我们都知道，直接在终端输入<code>echo</code>命令是回显参数，把<code>echo</code>命令放在shell脚本中有相同的效果。</p><h2 id="设置成可执行文件"><a href="#设置成可执行文件" class="headerlink" title="设置成可执行文件"></a>设置成可执行文件</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/设置为可执行文件.png"></div><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>Shell脚本中的变量直接使用<code>=</code>便可创建，使用<code>$</code>解析变量名。<code>{}</code>是分组命令，表示<code>H</code>是一个变量，这里不加也可以。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/变量.jpg"></div><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><ul><li><code>$#</code>：除脚本名外，命令行上参数的个数。</li><li><code>$*</code>：表示在命令行上实际给出的所有实参。<ul><li>如：<code>exam3.sh A B C D E F G H I J K</code>。<code>$#</code>是11。<code>$*</code>是： A B C D E F G H I J K</li></ul></li><li><code>$n</code>：表示命令行上第n个参数<ul><li><code>$0</code>表示文件名 <code>$1</code>表示第一个参数 …</li></ul></li><li><code>$@</code>：表示在命令行上实际给出的所有实参。<ul><li>如：<code>exam3.sh A B C D E F G H I J K</code>。<code>$@</code>就是： “A” “B” “C” “D” “E” “F” “G” “H” “I” “J” “K”</li></ul></li><li><code>$$</code>：当前进程的进程号</li><li><code>$!</code>：上一个后台命令对应的进程号。</li><li><code>$?</code>：上一条前台命令执行后的返回值。</li></ul><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><p>执行算术运算需要使用let，如<code>let c=$a+$b</code>。可以使用<code>c=$(($a+$b))</code>代替。其中算术运算符及优先级等同于C语言。同时多了个<code>**</code>表示幂运算。（运算符前后不要有空格）</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/算术运算符.jpg"></div><h2 id="从命令行读入参数"><a href="#从命令行读入参数" class="headerlink" title="从命令行读入参数"></a>从命令行读入参数</h2><p>直接使用read，命令行中的参数会读到read后面跟的参数（相当于变量）里。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/read.jpg"></div><p>读入时输出提示信息：</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/readp.jpg"></div><h2 id="引号"><a href="#引号" class="headerlink" title="引号"></a>引号</h2><ul><li><p>双引号：由双引号引起来的字符（除<code>$</code>、<code>`和`\`）都被当做普通字符对待。</code></p><ul><li><code>$</code>表示变量替换；</li><li><code></code> `表示命令替换；</li><li><code>\</code>之后的字符只有是<code>$</code>、<code></code> <code>、</code>双引号<code>、</code>`或<code>换行符</code>之一时会成为转义字符。其他情况都是<code>\</code>本身。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/引号.jpg"></div></li><li><p>单引号：单引号引起来的字符都是普通字符。特殊字符也失效。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/单引号.jpg"></div></li><li><p>倒引号：被到引号引起来的字符被解释为命令。如上上图中所示。</p></li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>变量之间使用空格隔开各个元素。如果元素中有空格，使用双引号引起来。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/数组.jpg"></div><h2 id="测试条件"><a href="#测试条件" class="headerlink" title="测试条件"></a>测试条件</h2><p>任何命令都可以作为条件，shell会执行这个命令并检查返回值，如果命令成功（返回值为0），表示真。</p><ul><li><code>test &lt;条件&gt;</code>：如<code>test n1 -eq n2</code></li><li><code>[ 条件 ]</code>：如<code>[ n1 -eq n2 ]</code></li></ul><h3 id="有关文件方面的测试"><a href="#有关文件方面的测试" class="headerlink" title="有关文件方面的测试"></a>有关文件方面的测试</h3><ul><li><code>-r 文件名</code>：真 &lt;==&gt; 文件存在并且是用户可读</li><li><code>-w 文件名</code>：真 &lt;==&gt; 文件存在并且是用户可写</li><li><code>-x 文件名</code>：真 &lt;==&gt; 文件存在并且用户可执行</li><li><code>-f 文件名</code>：真 &lt;==&gt; 文件存在且是普通文件</li><li><code>-d 文件名</code>：真 &lt;==&gt; 文件存在且是目录文件</li><li><code>-s 文件名</code>：真 &lt;==&gt; 文件存在且长度大于0</li></ul><h3 id="有关字符串方面的测试"><a href="#有关字符串方面的测试" class="headerlink" title="有关字符串方面的测试"></a>有关字符串方面的测试</h3><ul><li><code>-z s1</code>：真 &lt;==&gt; 字符串长度为0</li><li><code>-n s1</code>：真 &lt;==&gt; 字符串长度大于0</li><li><code>s1</code>：真 &lt;==&gt; 字符串不是空字符串</li><li><code>s1 = s2</code>（在“=”前后应有空格）：真 &lt;==&gt; 字符串相等</li><li><code>s1 != s2</code>：真 &lt;==&gt; 字符串不等</li><li><code>s1 &lt; s2</code>：真 &lt;==&gt; 按字典顺序s1在s2之后</li><li><code>s1 &gt; s2</code>：真 &lt;==&gt; 按字典顺序s1在s2之前</li></ul><h3 id="数值方面的测试"><a href="#数值方面的测试" class="headerlink" title="数值方面的测试"></a>数值方面的测试</h3><ul><li><code>n1 -eq n2</code>：真 &lt;==&gt; 数值相等</li><li><code>n1 -ne n2</code>：真 &lt;==&gt; 数值不等</li><li><code>n1 -lt n2</code>：真 &lt;==&gt; n1小于n2</li><li><code>n1 -le n2</code>：真 &lt;==&gt; n1小于或等于n2</li><li><code>n1 -gt n2</code>：真 &lt;==&gt; n1大于n2</li><li><code>n1 -ge n2</code>：真 &lt;==&gt; n1大于或等于n2</li></ul><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ul><li><code>!</code>：逻辑非</li><li><code>-a</code>：逻辑与</li><li><code>-o</code>：逻辑或</li><li><code>(表达式)</code>：圆括号括起来表示为一条语句</li></ul><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/选择结构.jpg"></div><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/循环结构.png"></div><h2 id="break-amp-continue"><a href="#break-amp-continue" class="headerlink" title="break &amp; continue"></a>break &amp; continue</h2><p>和C语言一致。</p><h2 id="shift"><a href="#shift" class="headerlink" title="shift"></a>shift</h2><p>参数跳转命令：不跟数组默认跳转1位，跟了跳转n位。</p><table><thead><tr><th style="text-align:center">命令行</th><th style="text-align:center">ex.sh</th><th style="text-align:center">A</th><th style="text-align:center">B</th><th style="text-align:center">C</th><th style="text-align:center">D</th><th style="text-align:center">E</th><th style="text-align:center">F</th></tr></thead><tbody><tr><td style="text-align:center">原位置参数</td><td style="text-align:center">$0</td><td style="text-align:center">$1</td><td style="text-align:center">$2</td><td style="text-align:center">$3</td><td style="text-align:center">$4</td><td style="text-align:center">$5</td><td style="text-align:center">$6</td></tr><tr><td style="text-align:center">移位后参数</td><td style="text-align:center">$0</td><td style="text-align:center"></td><td style="text-align:center">$1</td><td style="text-align:center">$2</td><td style="text-align:center">$3</td><td style="text-align:center">$4</td><td style="text-align:center">$5</td></tr></tbody></table><p>还可以用于循环结构的done上面，表示每次选择指定参数。</p><h2 id="参数置换变量"><a href="#参数置换变量" class="headerlink" title="参数置换变量"></a>参数置换变量</h2><table><thead><tr><th style="text-align:center">格式</th><th style="text-align:center">var1为空</th><th style="text-align:center">var1不空</th></tr></thead><tbody><tr><td style="text-align:center"><code>var2=${var1:-str}</code></td><td style="text-align:center">var2=str。var1不变</td><td style="text-align:center">var2=$var1。var1不变</td></tr><tr><td style="text-align:center"><code>var2=${var1:=str}</code></td><td style="text-align:center">var2=var1=str</td><td style="text-align:center">var2=$var1。var1不变</td></tr><tr><td style="text-align:center"><code>var2=${var1:+str}</code></td><td style="text-align:center">var2为空。var1不变</td><td style="text-align:center">var2=str。var1不变</td></tr><tr><td style="text-align:center"><code>var2=${var1:?str}</code></td><td style="text-align:center">输出：“shell 脚本名:var1:str”并退出shell。var2不变</td><td style="text-align:center">var2=$var1。var1不变</td></tr></tbody></table><h2 id="ex1"><a href="#ex1" class="headerlink" title="ex1"></a>ex1</h2><p>编写ex1.sh，参数为一个大于 20 的正整数。先检查参数是否符合要求。如果不符合要求，请给出提示；如果符合要求，输出这个参数的平方。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex1.jpg"></div><h2 id="ex2"><a href="#ex2" class="headerlink" title="ex2"></a>ex2</h2><p>编写ex2.sh，首先显示当天日期，然后查找给定的用户是否在系统中工作（who 命令）。如果在系统中，就输出一条欢迎语句（例如 hello，xxxx！）；如果不在系统中，就输出一条语句（waiting for xxx！）</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex2.jpg"></div><h2 id="ex3"><a href="#ex3" class="headerlink" title="ex3"></a>ex3</h2><p>编写 ex3.sh，该脚本接受一个参数。若改参数不是目录，则给出提示信息；否则使用<code>ll</code>命令列出该目录下的内容，并输出有多少个子目录（<code>d</code>开头），多少个普通文件（<code>-</code>开头）。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex3.jpg"></div><h2 id="ex4"><a href="#ex4" class="headerlink" title="ex4"></a>ex4</h2><p>编写 ex4.sh，将第一个参数指定的内容 copy 到第二个参数指定地点。</p><ul><li>若第一个参数是目录，自动添加<code>-r</code>选项（即把目录下的所有内容都 copy 过去）；</li><li>若第一个参数是普通文件，则将其 copy 到指定地点；</li><li>若第一个参数指定的文件或目录不存在，则报错；</li><li>若第二个参数指定的文件或目录已经存在，则提示是否替换，若选择 yes，则先删除原来的文件或目录，然后再执行 copy 操作，否则放弃。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex41.png"></div><br><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex42.png"></div><h2 id="ex5"><a href="#ex5" class="headerlink" title="ex5"></a>ex5</h2><p>编写 ex5.sh。检查命令行的第一个参数是否是<code>-b</code>或者<code>-s</code>。</p><ul><li>如果是<code>-b</code>，则计算由第二个参数指定的文件中以 b 开头的行数。</li><li>如果是<code>-s</code>，则计算由第二个参数指定的文件中以 s 开头的行数。否则显示选择有错的信息。</li></ul><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex5.jpg"></div><h2 id="ex6"><a href="#ex6" class="headerlink" title="ex6"></a>ex6</h2><p>编写 ex6.sh。该脚本需要输入两个文件的名称，然后由用户选择相应的操作（若两个参数中任何一个不是普通文件，则报错）。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex61.png"></div><h3 id="cat：输出两个文件的内容"><a href="#cat：输出两个文件的内容" class="headerlink" title="cat：输出两个文件的内容"></a>cat：输出两个文件的内容</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex62.png"></div><h3 id="statistic：统计两个文件分别有多少行"><a href="#statistic：统计两个文件分别有多少行" class="headerlink" title="statistic：统计两个文件分别有多少行"></a>statistic：统计两个文件分别有多少行</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex63.png"></div><h3 id="merge：将第-1-个文件的内容合并到第-2-个文件后面"><a href="#merge：将第-1-个文件的内容合并到第-2-个文件后面" class="headerlink" title="merge：将第 1 个文件的内容合并到第 2 个文件后面"></a>merge：将第 1 个文件的内容合并到第 2 个文件后面</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex64.png"></div><h3 id="copy：将第-1-个文件的内容-copy-到第-2-个文件（覆盖原文件）"><a href="#copy：将第-1-个文件的内容-copy-到第-2-个文件（覆盖原文件）" class="headerlink" title="copy：将第 1 个文件的内容 copy 到第 2 个文件（覆盖原文件）"></a>copy：将第 1 个文件的内容 copy 到第 2 个文件（覆盖原文件）</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex65.png"></div><h3 id="bye：退出"><a href="#bye：退出" class="headerlink" title="bye：退出"></a>bye：退出</h3><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/ex66.png"></div><h2 id="1ex"><a href="#1ex" class="headerlink" title="1ex"></a>1ex</h2><p>编写 1ex.sh，利用 for 循环将当前目录下的.c 文件移动到指定的目录下，完成后显示指定目录下的文件内容，并按文件从小到大排序。(ll -r -S）</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/1ex.jpg"></div><h2 id="2ex"><a href="#2ex" class="headerlink" title="2ex"></a>2ex</h2><p>编写 2ex.sh，显示 Fibonacci 数列的前 10 项及其总和。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/2ex.jpg"></div><h2 id="3ex"><a href="#3ex" class="headerlink" title="3ex"></a>3ex</h2><p>编写 ex3.sh，判断给定的参数是否是素数。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/3ex.jpg"></div><h2 id="4ex"><a href="#4ex" class="headerlink" title="4ex"></a>4ex</h2><p>编写 ex4.sh，将给定的参数转换成二进制表示。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/4ex.jpg"></div><h2 id="5ex"><a href="#5ex" class="headerlink" title="5ex"></a>5ex</h2><p>ex5.sh假设存在一个<code>/homework</code>的文件夹，其中包含一个 studentlist.csv的文件，当中存放了若干学生的学号，每个一行。例如：150341101、150341102、150341105、150341106，编写 ex11.sh。查看/homework 文件夹下学生是否提交了作业，假设作业名的格式为：学号_homework.txt。最后输出没提交作业的学号名单。</p><div align="center"><img src="//isjinhao.github.io/2019/04-操作系统和Linux/5ex.jpg"></div></div><div><div><div style="text-align:center;color:#ccc;font-size:14px">-如果您有什么建议，推荐使用右下角的DaoVoice与我联系-</div><div style="text-align:center;color:#ccc;font-size:14px">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读！-------------</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div></div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/weichatpay.png" alt="ISJINHAO 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.jpg" alt="ISJINHAO 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/应届求职复习/" rel="tag"># 应届求职复习</a> <a href="/tags/面试/" rel="tag"># 面试</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/2019/03-IO流和网络/" rel="next" title="03-IO流和网络"><i class="fa fa-chevron-left"></i> 03-IO流和网络</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"><a href="/2019/05-JavaWeb和SSM/" rel="prev" title="05-JavaWeb和SSM">05-JavaWeb和SSM <i class="fa fa-chevron-right"></i></a></div></div></footer></div></article></div></div><div class="comments" id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80MjQ4NC8xOTAzMQ=="></div></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="ISJINHAO"><p class="site-author-name" itemprop="name">ISJINHAO</p><p class="site-description motion-element" itemprop="description">Living & Working</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">120</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">31</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">60</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/isjinhao" title="GitHub &rarr; https://github.com/isjinhao" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="https://blog.csdn.net/qq_38206090" title="CSDN &rarr; https://blog.csdn.net/qq_38206090" rel="noopener" target="_blank"><i class="fa fa-fw fa-heartbeat"></i>CSDN</a> </span><span class="links-of-author-item"><a href="mailto:isjinhao@163.com" title="E-Mail &rarr; mailto:isjinhao@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div><div class="links-of-blogroll motion-element links-of-blogroll-block"><div class="links-of-blogroll-title"><i class="fa fa-fw fa-link"></i> 友情链接</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><a href="http://http://59.110.143.226/qz/0.html" title="http://http://59.110.143.226/qz/0.html" rel="noopener" target="_blank">求职（Java后台开发）</a></li><li class="links-of-blogroll-item"><a href="http://http://59.110.143.226/Sharing-Your-Story" title="http://http://59.110.143.226/Sharing-Your-Story" rel="noopener" target="_blank">博客涉及到的软件</a></li></ul></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的定义"><span class="nav-number">1.</span> <span class="nav-text">操作系统的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的目标"><span class="nav-number">1.1.</span> <span class="nav-text">操作系统的目标</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#操作系统的作用"><span class="nav-number">1.2.</span> <span class="nav-text">操作系统的作用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#未配置操作系统的计算机系统"><span class="nav-number">2.</span> <span class="nav-text">未配置操作系统的计算机系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#批处理系统"><span class="nav-number">3.</span> <span class="nav-text">批处理系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基础概念"><span class="nav-number">3.1.</span> <span class="nav-text">基础概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#单道批处理系统"><span class="nav-number">3.2.</span> <span class="nav-text">单道批处理系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#多道批处理系统"><span class="nav-number">3.3.</span> <span class="nav-text">多道批处理系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举例证明资源利用率高和系统吞吐量大"><span class="nav-number">3.4.</span> <span class="nav-text">举例证明资源利用率高和系统吞吐量大</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分时系统"><span class="nav-number">4.</span> <span class="nav-text">分时系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分时系统与多道批处理系统的不同特性"><span class="nav-number">4.1.</span> <span class="nav-text">分时系统与多道批处理系统的不同特性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实时系统"><span class="nav-number">5.</span> <span class="nav-text">实时系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程和线程"><span class="nav-number">6.</span> <span class="nav-text">进程和线程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的基本特性"><span class="nav-number">7.</span> <span class="nav-text">操作系统的基本特性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#操作系统的结构"><span class="nav-number">8.</span> <span class="nav-text">操作系统的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#传统操作系统结构"><span class="nav-number">8.1.</span> <span class="nav-text">传统操作系统结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#程序的并发执行"><span class="nav-number">8.2.</span> <span class="nav-text">程序的并发执行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的定义"><span class="nav-number">8.3.</span> <span class="nav-text">进程的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的特点"><span class="nav-number">8.4.</span> <span class="nav-text">进程的特点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PCB"><span class="nav-number">9.</span> <span class="nav-text">PCB</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#PCB中保存的信息"><span class="nav-number">9.1.</span> <span class="nav-text">PCB中保存的信息</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PCB的组织方式"><span class="nav-number">9.2.</span> <span class="nav-text">PCB的组织方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#OS内核"><span class="nav-number">10.</span> <span class="nav-text">OS内核</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#系统态-amp-用户态"><span class="nav-number">10.1.</span> <span class="nav-text">系统态 &amp; 用户态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指令分类"><span class="nav-number">10.2.</span> <span class="nav-text">指令分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内核概念"><span class="nav-number">10.3.</span> <span class="nav-text">内核概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内核的功能"><span class="nav-number">10.4.</span> <span class="nav-text">内核的功能</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程的生命周期"><span class="nav-number">11.</span> <span class="nav-text">进程的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的创建"><span class="nav-number">11.1.</span> <span class="nav-text">进程的创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程的终止"><span class="nav-number">11.2.</span> <span class="nav-text">进程的终止</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三种基本状态"><span class="nav-number">11.3.</span> <span class="nav-text">三种基本状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#挂起"><span class="nav-number">11.4.</span> <span class="nav-text">挂起</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程同步"><span class="nav-number">12.</span> <span class="nav-text">进程同步</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#同步-amp-互斥"><span class="nav-number">12.1.</span> <span class="nav-text">同步 &amp; 互斥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#临界资源-amp-临界区"><span class="nav-number">12.2.</span> <span class="nav-text">临界资源 &amp; 临界区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#同步准则"><span class="nav-number">12.3.</span> <span class="nav-text">同步准则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#硬件同步机制"><span class="nav-number">13.</span> <span class="nav-text">硬件同步机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#关中断"><span class="nav-number">13.1.</span> <span class="nav-text">关中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用Test-and-Set指令实现互斥"><span class="nav-number">13.2.</span> <span class="nav-text">利用Test-and-Set指令实现互斥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用Swap指令实现互斥"><span class="nav-number">13.3.</span> <span class="nav-text">利用Swap指令实现互斥</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点"><span class="nav-number">13.4.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量机制"><span class="nav-number">14.</span> <span class="nav-text">信号量机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#整型信号量"><span class="nav-number">14.1.</span> <span class="nav-text">整型信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#记录型信号量"><span class="nav-number">14.2.</span> <span class="nav-text">记录型信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#AND型信号量"><span class="nav-number">14.3.</span> <span class="nav-text">AND型信号量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#信号量集"><span class="nav-number">14.4.</span> <span class="nav-text">信号量集</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管程"><span class="nav-number">14.5.</span> <span class="nav-text">管程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#信号量的应用"><span class="nav-number">15.</span> <span class="nav-text">信号量的应用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#互斥访问资源"><span class="nav-number">15.1.</span> <span class="nav-text">互斥访问资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#利用信号量实现前趋关系"><span class="nav-number">15.2.</span> <span class="nav-text">利用信号量实现前趋关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读者-写者问题"><span class="nav-number">15.3.</span> <span class="nav-text">读者-写者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#读者-写者问题拓展"><span class="nav-number">15.4.</span> <span class="nav-text">读者-写者问题拓展</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#理发师问题"><span class="nav-number">15.5.</span> <span class="nav-text">理发师问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进程通信"><span class="nav-number">16.</span> <span class="nav-text">进程通信</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#概念"><span class="nav-number">16.1.</span> <span class="nav-text">概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#共享存储器系统"><span class="nav-number">16.2.</span> <span class="nav-text">共享存储器系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#管道通信系统"><span class="nav-number">16.3.</span> <span class="nav-text">管道通信系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#消息传递系统"><span class="nav-number">16.4.</span> <span class="nav-text">消息传递系统</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#客户机-服务器系统"><span class="nav-number">16.5.</span> <span class="nav-text">客户机-服务器系统</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程"><span class="nav-number">17.</span> <span class="nav-text">线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程的由来"><span class="nav-number">17.1.</span> <span class="nav-text">线程的由来</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TCB（Thread-Control-Block）"><span class="nav-number">17.2.</span> <span class="nav-text">TCB（Thread Control Block）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程的实现"><span class="nav-number">18.</span> <span class="nav-text">线程的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#内核支持线程"><span class="nav-number">18.1.</span> <span class="nav-text">内核支持线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户级线程"><span class="nav-number">18.2.</span> <span class="nav-text">用户级线程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">19.</span> <span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#处理机调度的层次"><span class="nav-number">19.1.</span> <span class="nav-text">处理机调度的层次</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理机调度的目标"><span class="nav-number">19.2.</span> <span class="nav-text">处理机调度的目标</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#高级调度"><span class="nav-number">20.</span> <span class="nav-text">高级调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#作业"><span class="nav-number">20.1.</span> <span class="nav-text">作业</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作业控制块"><span class="nav-number">20.2.</span> <span class="nav-text">作业控制块</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#作业运行的三个阶段"><span class="nav-number">20.3.</span> <span class="nav-text">作业运行的三个阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#先来先服务算法"><span class="nav-number">20.4.</span> <span class="nav-text">先来先服务算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#短作业优先算法"><span class="nav-number">20.5.</span> <span class="nav-text">短作业优先算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#静态优先级调度算法"><span class="nav-number">20.6.</span> <span class="nav-text">静态优先级调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#高响应比算法"><span class="nav-number">20.7.</span> <span class="nav-text">高响应比算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#低级调度"><span class="nav-number">21.</span> <span class="nav-text">低级调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进程调度的任务和机制"><span class="nav-number">21.1.</span> <span class="nav-text">进程调度的任务和机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程调度机制"><span class="nav-number">21.2.</span> <span class="nav-text">进程调度机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举例"><span class="nav-number">21.3.</span> <span class="nav-text">举例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基于公平原则的调度算法"><span class="nav-number">22.</span> <span class="nav-text">基于公平原则的调度算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#保证调度算法"><span class="nav-number">22.1.</span> <span class="nav-text">保证调度算法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#公平调度算法"><span class="nav-number">22.2.</span> <span class="nav-text">公平调度算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实时调度"><span class="nav-number">23.</span> <span class="nav-text">实时调度</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实时算法的分类"><span class="nav-number">23.1.</span> <span class="nav-text">实时算法的分类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非抢占式调度算法"><span class="nav-number">23.1.1.</span> <span class="nav-text">非抢占式调度算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抢占式调度算法"><span class="nav-number">23.1.2.</span> <span class="nav-text">抢占式调度算法</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#优先级倒置"><span class="nav-number">24.</span> <span class="nav-text">优先级倒置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#优先级倒置的解决"><span class="nav-number">24.1.</span> <span class="nav-text">优先级倒置的解决</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#资源分类"><span class="nav-number">25.</span> <span class="nav-text">资源分类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#可重用资源和消耗性资源"><span class="nav-number">25.1.</span> <span class="nav-text">可重用资源和消耗性资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可抢占性资源和不可抢占性资源"><span class="nav-number">25.2.</span> <span class="nav-text">可抢占性资源和不可抢占性资源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁定义"><span class="nav-number">26.</span> <span class="nav-text">死锁定义</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁的起因"><span class="nav-number">27.</span> <span class="nav-text">死锁的起因</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#竞争不可抢占性资源引起死锁"><span class="nav-number">27.1.</span> <span class="nav-text">竞争不可抢占性资源引起死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#竞争可消耗性资源引起死锁"><span class="nav-number">27.2.</span> <span class="nav-text">竞争可消耗性资源引起死锁</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进程推进顺序非法"><span class="nav-number">27.3.</span> <span class="nav-text">进程推进顺序非法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁产生的必要条件"><span class="nav-number">28.</span> <span class="nav-text">死锁产生的必要条件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#死锁处理"><span class="nav-number">29.</span> <span class="nav-text">死锁处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预防死锁"><span class="nav-number">30.</span> <span class="nav-text">预防死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#破坏“请求和保持”条件"><span class="nav-number">30.1.</span> <span class="nav-text">破坏“请求和保持”条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#破坏“不可抢占”条件"><span class="nav-number">30.2.</span> <span class="nav-text">破坏“不可抢占”条件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#破坏“循环等待”条件"><span class="nav-number">30.3.</span> <span class="nav-text">破坏“循环等待”条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#避免死锁"><span class="nav-number">31.</span> <span class="nav-text">避免死锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#安全状态"><span class="nav-number">31.1.</span> <span class="nav-text">安全状态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#安全状态和死锁必要条件的区别"><span class="nav-number">31.2.</span> <span class="nav-text">安全状态和死锁必要条件的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#死锁的检测和解除"><span class="nav-number">31.3.</span> <span class="nav-text">死锁的检测和解除</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#死锁的检测"><span class="nav-number">31.3.1.</span> <span class="nav-text">死锁的检测</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#现代计算机运行过程"><span class="nav-number">31.4.</span> <span class="nav-text">现代计算机运行过程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连续分配存储管理方式"><span class="nav-number">32.</span> <span class="nav-text">连续分配存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单一连续分配"><span class="nav-number">32.1.</span> <span class="nav-text">单一连续分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#固定分区分配"><span class="nav-number">32.2.</span> <span class="nav-text">固定分区分配</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#动态分区分配"><span class="nav-number">32.3.</span> <span class="nav-text">动态分区分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数据结构"><span class="nav-number">32.3.1.</span> <span class="nav-text">数据结构</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分页存储管理方式"><span class="nav-number">33.</span> <span class="nav-text">分页存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#基本概念"><span class="nav-number">33.1.</span> <span class="nav-text">基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有效访问时间"><span class="nav-number">33.2.</span> <span class="nav-text">有效访问时间</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两级页表"><span class="nav-number">33.3.</span> <span class="nav-text">两级页表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#两级页表地址变换"><span class="nav-number">33.4.</span> <span class="nav-text">两级页表地址变换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#分段存储管理方式"><span class="nav-number">34.</span> <span class="nav-text">分段存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#分段地址"><span class="nav-number">34.1.</span> <span class="nav-text">分段地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#段表"><span class="nav-number">34.2.</span> <span class="nav-text">段表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址映射"><span class="nav-number">34.3.</span> <span class="nav-text">地址映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址变换"><span class="nav-number">34.4.</span> <span class="nav-text">地址变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分页和分段的主要区别"><span class="nav-number">34.5.</span> <span class="nav-text">分页和分段的主要区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#段页式存储管理方式"><span class="nav-number">35.</span> <span class="nav-text">段页式存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#原理"><span class="nav-number">35.1.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#映射"><span class="nav-number">35.2.</span> <span class="nav-text">映射</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址变换机构"><span class="nav-number">35.3.</span> <span class="nav-text">地址变换机构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#传统存储器的问题"><span class="nav-number">36.</span> <span class="nav-text">传统存储器的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#解决原理"><span class="nav-number">36.1.</span> <span class="nav-text">解决原理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#程序局部性原理"><span class="nav-number">36.1.1.</span> <span class="nav-text">程序局部性原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表现两个方面"><span class="nav-number">36.1.2.</span> <span class="nav-text">表现两个方面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#基于局部性原理"><span class="nav-number">36.1.3.</span> <span class="nav-text">基于局部性原理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#虚拟存储器定义"><span class="nav-number">36.2.</span> <span class="nav-text">虚拟存储器定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实现虚拟存储器的条件"><span class="nav-number">36.3.</span> <span class="nav-text">实现虚拟存储器的条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求分页存储管理方式"><span class="nav-number">37.</span> <span class="nav-text">请求分页存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#页表机制"><span class="nav-number">37.1.</span> <span class="nav-text">页表机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#内存分配"><span class="nav-number">37.2.</span> <span class="nav-text">内存分配</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最小物理块数的确定"><span class="nav-number">37.2.1.</span> <span class="nav-text">最小物理块数的确定</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内存分配策略"><span class="nav-number">37.2.2.</span> <span class="nav-text">内存分配策略</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#物理块分配算法"><span class="nav-number">37.2.3.</span> <span class="nav-text">物理块分配算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页面调入"><span class="nav-number">37.3.</span> <span class="nav-text">页面调入</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#何时调入页面"><span class="nav-number">37.3.1.</span> <span class="nav-text">何时调入页面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#从何处调入页面"><span class="nav-number">37.3.2.</span> <span class="nav-text">从何处调入页面</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页面调入过程"><span class="nav-number">37.3.3.</span> <span class="nav-text">页面调入过程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#缺页率"><span class="nav-number">37.3.4.</span> <span class="nav-text">缺页率</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#页面置换算法"><span class="nav-number">37.4.</span> <span class="nav-text">页面置换算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#最佳置换算法"><span class="nav-number">37.4.1.</span> <span class="nav-text">最佳置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#最少使用置换算法"><span class="nav-number">37.4.2.</span> <span class="nav-text">最少使用置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Clock置换算法"><span class="nav-number">37.4.3.</span> <span class="nav-text">Clock置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#改进Clock置换算法"><span class="nav-number">37.4.4.</span> <span class="nav-text">改进Clock置换算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#页面缓冲算法"><span class="nav-number">37.4.5.</span> <span class="nav-text">页面缓冲算法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#访问内存的有效时间"><span class="nav-number">37.5.</span> <span class="nav-text">访问内存的有效时间</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#抖动与工作集"><span class="nav-number">38.</span> <span class="nav-text">抖动与工作集</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#抖动"><span class="nav-number">38.1.</span> <span class="nav-text">抖动</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#工作集"><span class="nav-number">38.2.</span> <span class="nav-text">工作集</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#例"><span class="nav-number">38.2.1.</span> <span class="nav-text">例</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#抖动的预防方法"><span class="nav-number">38.3.</span> <span class="nav-text">抖动的预防方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求分段存储管理方式"><span class="nav-number">39.</span> <span class="nav-text">请求分段存储管理方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#请求段表机制"><span class="nav-number">39.1.</span> <span class="nav-text">请求段表机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址中断机构"><span class="nav-number">39.2.</span> <span class="nav-text">地址中断机构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分段的共享与保护"><span class="nav-number">39.3.</span> <span class="nav-text">分段的共享与保护</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#共享段表"><span class="nav-number">39.3.1.</span> <span class="nav-text">共享段表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#设备分配算法"><span class="nav-number">39.4.</span> <span class="nav-text">设备分配算法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户层的I-O软件"><span class="nav-number">40.</span> <span class="nav-text">用户层的I/O软件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#系统调用与库函数"><span class="nav-number">40.1.</span> <span class="nav-text">系统调用与库函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SPOOLing程序"><span class="nav-number">40.2.</span> <span class="nav-text">SPOOLing程序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲区"><span class="nav-number">41.</span> <span class="nav-text">缓冲区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单缓冲区"><span class="nav-number">41.1.</span> <span class="nav-text">单缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#双缓冲区"><span class="nav-number">41.2.</span> <span class="nav-text">双缓冲区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#环形缓冲区"><span class="nav-number">41.3.</span> <span class="nav-text">环形缓冲区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#磁盘存储器的性能和调度"><span class="nav-number">42.</span> <span class="nav-text">磁盘存储器的性能和调度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统的层次结构"><span class="nav-number">43.</span> <span class="nav-text">文件系统的层次结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的打开和关闭"><span class="nav-number">44.</span> <span class="nav-text">文件的打开和关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件的逻辑结构和物理结构"><span class="nav-number">45.</span> <span class="nav-text">文件的逻辑结构和物理结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑文件按结构分类"><span class="nav-number">45.1.</span> <span class="nav-text">逻辑文件按结构分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑文件按组织方式分类"><span class="nav-number">45.2.</span> <span class="nav-text">逻辑文件按组织方式分类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顺序文件"><span class="nav-number">45.3.</span> <span class="nav-text">顺序文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#索引文件"><span class="nav-number">45.4.</span> <span class="nav-text">索引文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#FAT"><span class="nav-number">45.5.</span> <span class="nav-text">FAT</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#FAT12"><span class="nav-number">45.5.1.</span> <span class="nav-text">FAT12</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FAT16"><span class="nav-number">45.5.2.</span> <span class="nav-text">FAT16</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#FAT32"><span class="nav-number">45.5.3.</span> <span class="nav-text">FAT32</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NTFS"><span class="nav-number">45.6.</span> <span class="nav-text">NTFS</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#索引组织方式"><span class="nav-number">46.</span> <span class="nav-text">索引组织方式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#单级索引组织方式"><span class="nav-number">46.1.</span> <span class="nav-text">单级索引组织方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux介绍"><span class="nav-number">47.</span> <span class="nav-text">Linux介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux安装"><span class="nav-number">48.</span> <span class="nav-text">Linux安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#连接服务器工具"><span class="nav-number">49.</span> <span class="nav-text">连接服务器工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux目录结构"><span class="nav-number">50.</span> <span class="nav-text">Linux目录结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Shell"><span class="nav-number">51.</span> <span class="nav-text">Shell</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bash命令"><span class="nav-number">52.</span> <span class="nav-text">Bash命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bash命令格式"><span class="nav-number">53.</span> <span class="nav-text">Bash命令格式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Bash举例"><span class="nav-number">54.</span> <span class="nav-text">Bash举例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uname解释"><span class="nav-number">55.</span> <span class="nav-text">uname解释</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输入"><span class="nav-number">56.</span> <span class="nav-text">输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#echo"><span class="nav-number">57.</span> <span class="nav-text">echo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#输出重定向"><span class="nav-number">58.</span> <span class="nav-text">输出重定向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pwd"><span class="nav-number">59.</span> <span class="nav-text">pwd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#历史命令"><span class="nav-number">60.</span> <span class="nav-text">历史命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#date"><span class="nav-number">61.</span> <span class="nav-text">date</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cal"><span class="nav-number">62.</span> <span class="nav-text">cal</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clear"><span class="nav-number">63.</span> <span class="nav-text">clear</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关机-amp-重启"><span class="nav-number">64.</span> <span class="nav-text">关机 &amp; 重启</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#帮助命令"><span class="nav-number">65.</span> <span class="nav-text">帮助命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切换路径命令"><span class="nav-number">66.</span> <span class="nav-text">切换路径命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#passwd"><span class="nav-number">67.</span> <span class="nav-text">passwd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux用户"><span class="nav-number">68.</span> <span class="nav-text">Linux用户</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看用户"><span class="nav-number">69.</span> <span class="nav-text">查看用户</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户组"><span class="nav-number">70.</span> <span class="nav-text">用户组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加用户"><span class="nav-number">71.</span> <span class="nav-text">添加用户</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除用户"><span class="nav-number">72.</span> <span class="nav-text">删除用户</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#添加-删除组"><span class="nav-number">73.</span> <span class="nav-text">添加/删除组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#etc-passwd-amp-etc-shadow"><span class="nav-number">74.</span> <span class="nav-text">/etc/passwd &amp; /etc/shadow</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查看用户所属的组"><span class="nav-number">75.</span> <span class="nav-text">查看用户所属的组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#etc-group-amp-etc-gshadow"><span class="nav-number">76.</span> <span class="nav-text">/etc/group &amp; /etc/gshadow</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#为用户添加备注"><span class="nav-number">77.</span> <span class="nav-text">为用户添加备注</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#usermod"><span class="nav-number">78.</span> <span class="nav-text">usermod</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#gpasswd"><span class="nav-number">79.</span> <span class="nav-text">gpasswd</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#切换用户"><span class="nav-number">80.</span> <span class="nav-text">切换用户</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件系统"><span class="nav-number">81.</span> <span class="nav-text">文件系统</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#查找文件"><span class="nav-number">82.</span> <span class="nav-text">查找文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#cat"><span class="nav-number">83.</span> <span class="nav-text">cat</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#touch"><span class="nav-number">84.</span> <span class="nav-text">touch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#grep"><span class="nav-number">85.</span> <span class="nav-text">grep</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#部分选项如下："><span class="nav-number">85.1.</span> <span class="nav-text">部分选项如下：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#举例如下："><span class="nav-number">85.2.</span> <span class="nav-text">举例如下：</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道命令"><span class="nav-number">86.</span> <span class="nav-text">管道命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#统计文件信息"><span class="nav-number">87.</span> <span class="nav-text">统计文件信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建目录"><span class="nav-number">88.</span> <span class="nav-text">创建目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除文件-目录"><span class="nav-number">89.</span> <span class="nav-text">删除文件/目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#列出文件"><span class="nav-number">90.</span> <span class="nav-text">列出文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拷贝文件"><span class="nav-number">91.</span> <span class="nav-text">拷贝文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#剪切文件"><span class="nav-number">92.</span> <span class="nav-text">剪切文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#修改文件名"><span class="nav-number">93.</span> <span class="nav-text">修改文件名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件结构"><span class="nav-number">94.</span> <span class="nav-text">文件结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链接"><span class="nav-number">95.</span> <span class="nav-text">链接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#用户和权限"><span class="nav-number">96.</span> <span class="nav-text">用户和权限</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chmod"><span class="nav-number">97.</span> <span class="nav-text">chmod</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#umask"><span class="nav-number">98.</span> <span class="nav-text">umask</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chown"><span class="nav-number">99.</span> <span class="nav-text">chown</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#chgrp"><span class="nav-number">100.</span> <span class="nav-text">chgrp</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件权限的理解"><span class="nav-number">101.</span> <span class="nav-text">文件权限的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#目录权限的理解"><span class="nav-number">102.</span> <span class="nav-text">目录权限的理解</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#压缩-amp-打包-amp-解压缩"><span class="nav-number">103.</span> <span class="nav-text">压缩 &amp; 打包 &amp; 解压缩</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#别名"><span class="nav-number">104.</span> <span class="nav-text">别名</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#定时任务"><span class="nav-number">105.</span> <span class="nav-text">定时任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#成组命令"><span class="nav-number">106.</span> <span class="nav-text">成组命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sort"><span class="nav-number">107.</span> <span class="nav-text">sort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#uniq"><span class="nav-number">108.</span> <span class="nav-text">uniq</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件类型"><span class="nav-number">109.</span> <span class="nav-text">文件类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ex1：用户管理"><span class="nav-number">110.</span> <span class="nav-text">ex1：用户管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#在系统中添加三个用户：Blondie、Prince和Madonna"><span class="nav-number">110.1.</span> <span class="nav-text">在系统中添加三个用户：Blondie、Prince和Madonna</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#他们都希望属于次要组music"><span class="nav-number">110.2.</span> <span class="nav-text">他们都希望属于次要组music</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Blondie要求在他的条目中添加特殊备注“heart-of-glass”"><span class="nav-number">110.3.</span> <span class="nav-text">Blondie要求在他的条目中添加特殊备注“heart of glass”</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prince要求使用-bin-csh作为登录shell"><span class="nav-number">110.4.</span> <span class="nav-text">Prince要求使用/bin/csh作为登录shell</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Madonna的使用期限为2020-12-1。"><span class="nav-number">110.5.</span> <span class="nav-text">Madonna的使用期限为2020-12-1。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Blondie决定加入摔跤俱乐部wrestle组。"><span class="nav-number">110.6.</span> <span class="nav-text">Blondie决定加入摔跤俱乐部wrestle组。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prince要将他的用户名改为tafkap。"><span class="nav-number">110.7.</span> <span class="nav-text">Prince要将他的用户名改为tafkap。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。"><span class="nav-number">110.8.</span> <span class="nav-text">Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Prince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。"><span class="nav-number">110.9.</span> <span class="nav-text">Prince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Blondie最近表现不好，我们决定将他踢出去。"><span class="nav-number">110.10.</span> <span class="nav-text">Blondie最近表现不好，我们决定将他踢出去。</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ex2：文件目录管理"><span class="nav-number">111.</span> <span class="nav-text">ex2：文件目录管理</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Ventura同时属于次要组governor和wrestle。"><span class="nav-number">111.1.</span> <span class="nav-text">Ventura同时属于次要组governor和wrestle。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ventura撰写了自己的摔跤计划plans-txt，并将它放到目录-tmp下。"><span class="nav-number">111.2.</span> <span class="nav-text">Ventura撰写了自己的摔跤计划plans.txt，并将它放到目录/tmp下。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。"><span class="nav-number">111.3.</span> <span class="nav-text">Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？"><span class="nav-number">111.4.</span> <span class="nav-text">用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？"><span class="nav-number">111.5.</span> <span class="nav-text">用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vi-amp-vim"><span class="nav-number">112.</span> <span class="nav-text">vi &amp; vim</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#进入-amp-退出"><span class="nav-number">113.</span> <span class="nav-text">进入 &amp; 退出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#进入命令模式"><span class="nav-number">113.1.</span> <span class="nav-text">进入命令模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#进入编辑模式："><span class="nav-number">113.2.</span> <span class="nav-text">进入编辑模式：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#i：编辑位置在当前光标位置之前"><span class="nav-number">113.2.1.</span> <span class="nav-text">i：编辑位置在当前光标位置之前</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#I：在光标所在行的行首插入新增文本"><span class="nav-number">113.2.2.</span> <span class="nav-text">I：在光标所在行的行首插入新增文本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#a：在该命令之后输入的字符都插到光标之后"><span class="nav-number">113.2.3.</span> <span class="nav-text">a：在该命令之后输入的字符都插到光标之后</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#A：在光标所在行的行尾添加文本"><span class="nav-number">113.2.4.</span> <span class="nav-text">A：在光标所在行的行尾添加文本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#o：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行"><span class="nav-number">113.2.5.</span> <span class="nav-text">o：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#O：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上"><span class="nav-number">113.2.6.</span> <span class="nav-text">O：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#r：替换光标所在的哪一个字符"><span class="nav-number">113.2.7.</span> <span class="nav-text">r：替换光标所在的哪一个字符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#R：一直替换光标所在的文字，直到按下ESC为止"><span class="nav-number">113.2.8.</span> <span class="nav-text">R：一直替换光标所在的文字，直到按下ESC为止</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#退出编辑模式"><span class="nav-number">113.3.</span> <span class="nav-text">退出编辑模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#退出命令模式"><span class="nav-number">113.4.</span> <span class="nav-text">退出命令模式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#vim流程图"><span class="nav-number">114.</span> <span class="nav-text">vim流程图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#命令模式下的光标跳转"><span class="nav-number">115.</span> <span class="nav-text">命令模式下的光标跳转</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文本删除"><span class="nav-number">116.</span> <span class="nav-text">文本删除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#复原命令"><span class="nav-number">117.</span> <span class="nav-text">复原命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重复命令"><span class="nav-number">118.</span> <span class="nav-text">重复命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#补充文本编辑"><span class="nav-number">119.</span> <span class="nav-text">补充文本编辑</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#命令方式下"><span class="nav-number">119.1.</span> <span class="nav-text">命令方式下</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ex转移方式下"><span class="nav-number">119.2.</span> <span class="nav-text">ex转移方式下</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串检索"><span class="nav-number">120.</span> <span class="nav-text">字符串检索</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符串替换"><span class="nav-number">121.</span> <span class="nav-text">字符串替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#块选择"><span class="nav-number">122.</span> <span class="nav-text">块选择</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux的进程状态"><span class="nav-number">123.</span> <span class="nav-text">Linux的进程状态</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ps"><span class="nav-number">124.</span> <span class="nav-text">ps</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#终结进程"><span class="nav-number">125.</span> <span class="nav-text">终结进程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sleep"><span class="nav-number">126.</span> <span class="nav-text">sleep</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#wait"><span class="nav-number">127.</span> <span class="nav-text">wait</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#fork"><span class="nav-number">128.</span> <span class="nav-text">fork()</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题1"><span class="nav-number">129.</span> <span class="nav-text">题1</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源代码"><span class="nav-number">129.1.</span> <span class="nav-text">源代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运行结果"><span class="nav-number">129.2.</span> <span class="nav-text">运行结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分析"><span class="nav-number">129.3.</span> <span class="nav-text">分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题2"><span class="nav-number">130.</span> <span class="nav-text">题2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源代码-1"><span class="nav-number">130.1.</span> <span class="nav-text">源代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结果"><span class="nav-number">130.2.</span> <span class="nav-text">结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分析-1"><span class="nav-number">130.3.</span> <span class="nav-text">分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题3"><span class="nav-number">131.</span> <span class="nav-text">题3</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源代码-2"><span class="nav-number">131.1.</span> <span class="nav-text">源代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结果-1"><span class="nav-number">131.2.</span> <span class="nav-text">结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分析-2"><span class="nav-number">131.3.</span> <span class="nav-text">分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#题4"><span class="nav-number">132.</span> <span class="nav-text">题4</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#题目"><span class="nav-number">132.1.</span> <span class="nav-text">题目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#分析-3"><span class="nav-number">132.2.</span> <span class="nav-text">分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#简介"><span class="nav-number">133.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#最简单的Shell脚本"><span class="nav-number">134.</span> <span class="nav-text">最简单的Shell脚本</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#设置成可执行文件"><span class="nav-number">135.</span> <span class="nav-text">设置成可执行文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">136.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊变量"><span class="nav-number">137.</span> <span class="nav-text">特殊变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#算术运算"><span class="nav-number">138.</span> <span class="nav-text">算术运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从命令行读入参数"><span class="nav-number">139.</span> <span class="nav-text">从命令行读入参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引号"><span class="nav-number">140.</span> <span class="nav-text">引号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">141.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#测试条件"><span class="nav-number">142.</span> <span class="nav-text">测试条件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#有关文件方面的测试"><span class="nav-number">142.1.</span> <span class="nav-text">有关文件方面的测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#有关字符串方面的测试"><span class="nav-number">142.2.</span> <span class="nav-text">有关字符串方面的测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数值方面的测试"><span class="nav-number">142.3.</span> <span class="nav-text">数值方面的测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#逻辑运算符"><span class="nav-number">142.4.</span> <span class="nav-text">逻辑运算符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择结构"><span class="nav-number">143.</span> <span class="nav-text">选择结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#循环结构"><span class="nav-number">144.</span> <span class="nav-text">循环结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#break-amp-continue"><span class="nav-number">145.</span> <span class="nav-text">break &amp; continue</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#shift"><span class="nav-number">146.</span> <span class="nav-text">shift</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数置换变量"><span class="nav-number">147.</span> <span class="nav-text">参数置换变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ex1"><span class="nav-number">148.</span> <span class="nav-text">ex1</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ex2"><span class="nav-number">149.</span> <span class="nav-text">ex2</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ex3"><span class="nav-number">150.</span> <span class="nav-text">ex3</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ex4"><span class="nav-number">151.</span> <span class="nav-text">ex4</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ex5"><span class="nav-number">152.</span> <span class="nav-text">ex5</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#ex6"><span class="nav-number">153.</span> <span class="nav-text">ex6</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cat：输出两个文件的内容"><span class="nav-number">153.1.</span> <span class="nav-text">cat：输出两个文件的内容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#statistic：统计两个文件分别有多少行"><span class="nav-number">153.2.</span> <span class="nav-text">statistic：统计两个文件分别有多少行</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#merge：将第-1-个文件的内容合并到第-2-个文件后面"><span class="nav-number">153.3.</span> <span class="nav-text">merge：将第 1 个文件的内容合并到第 2 个文件后面</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy：将第-1-个文件的内容-copy-到第-2-个文件（覆盖原文件）"><span class="nav-number">153.4.</span> <span class="nav-text">copy：将第 1 个文件的内容 copy 到第 2 个文件（覆盖原文件）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#bye：退出"><span class="nav-number">153.5.</span> <span class="nav-text">bye：退出</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1ex"><span class="nav-number">154.</span> <span class="nav-text">1ex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2ex"><span class="nav-number">155.</span> <span class="nav-text">2ex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3ex"><span class="nav-number">156.</span> <span class="nav-text">3ex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4ex"><span class="nav-number">157.</span> <span class="nav-text">4ex</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5ex"><span class="nav-number">158.</span> <span class="nav-text">5ex</span></a></li></ol></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">ISJINHAO</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">1.2m</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">17:59</span></div><div class="powered-by"><i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv"> 本站访客数：<span id="busuanzi_value_site_uv"></span></span></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">| 博客全站共475.4k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/src/utils.js?v=6.7.0"></script><script src="/js/src/motion.js?v=6.7.0"></script><script src="/js/src/schemes/muse.js?v=6.7.0"></script><script src="/js/src/scrollspy.js?v=6.7.0"></script><script src="/js/src/post-details.js?v=6.7.0"></script><script src="/js/src/bootstrap.js?v=6.7.0"></script><script>window.livereOptions={refer:"2019/04-操作系统和Linux/"},function(e,t){var n,r=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,r.parentNode.insertBefore(n,r))}(document,"script")</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: "AMS"
      }
    }
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });</script><script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><style>.MathJax_Display{overflow:auto hidden}</style></body></html><!-- rebuild by neat -->