<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[01.01-JavaSE-基础-1]]></title>
    <url>%2Fposts%2F46326.html%2F</url>
    <content type="text"><![CDATA[JVM &amp; JDK &amp; JREJVMJava虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。什么是字节码?采用字节码的好处是什么?在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。Java 程序从源代码到运行一般有下面3步：我们需要格外注意的是.class-&gt;机器码这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的（也就是所谓的热点代码），所以后面引进了 JIT 编译器，而JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。HotSpot采用了惰性评估（Lazy Evaluation）的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9引入了一种新的编译模式AOT（Ahead of Time Compilation），它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是 ，AOT编译器的编译质量是肯定比不上JIT编译器的。总结：Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows、Linux、macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是Java语言”一次编译，随处可以运行“的关键所在。JDK 和 JREJDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。JRE是Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括Java虚拟机（JVM），Java类库，Java命令和其他的一些基础构件。但是，它不能用于创建新程序。如果只是为了运行一下Java程序的话，那么只需要安装JRE。但如果需要进行一些Java编程方面的工作，那么就需要安装JDK了。但是，这不是绝对的。有时，即使不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要部署JSP-Web应用程序，需要JDK来将JSP编译成为Servlet。异常异常是程序在运行时出现的会导致程序运行终止的错误。这种错误是不能通过编译系统检查出来的。常见的异常的发生原因为系统资源错误和用户操所错误两种。Java把异常信息封装成一个类。当发生某种异常时将某种对应的类作为异常信息抛出。异常的根类时Throwable，其有两个直接子类 Error和Exception。Error是描述系统资源错误的类。Exception是描述用户操作错误的类。发生了Error就是必须修改代码或调整外部环境问题，程序肯定会终止。比如需要开辟一个内存大小为99999999个int的数组。所以一般来说Error很少发生。发生了Exception就要进行处理，使程序运行下去，如数组越界异常，文件不存在异常等。而Exception又可以分为两种，一种是程序本身存在的问题引发的异常（健壮性不够），即：RuntimeException；一种是程序本身可能没有问题，但遇到诸如文件不存在所导致的错误，Excption中除了RuntimeException外都是此种异常，此种异常被称为受查异常（受查异常在写代码的时候会提示抛出还是处理）。Error+RuntimeException构成了非受查异常。受查异常、非受查异常Java语言规范规定派生于Error类或RuntimeException类的异常都称为非受查异常，其余异常都被成为受查异常。受查异常就是必须告诉它的调用者可能会出现异常，让其调用者抛出或者捕获处理，这类异常如果没有在程序中进行异常处理，编译不通过。非受查异常则不需要。声明受查异常（throws）除了Error和RuntimeException的异常都是受查异常，这些异常如：IOException、SQLException等，在可能发生的方法中需要被声明。同时非受查异常最好不要被声明。需要使用throws声明异常后的情况如下：调用一个抛出受查异常的方法：public int read() throws IOException方法中使用throw语句抛出了受查异常。抛出异常（throw）throw可以用于抛出异常对象。格式如下例：123public static void demo() throws Exception&#123; throw new Exception("出现异常");&#125;常见的运行时异常java.lang.NullPointerException ：空指针异常；出现原因：调用了未经初始化的对象或者是不存在的对象。java.lang.ClassNotFoundException：指定的类找不到；出现原因：类的名称和路径加载错误；通常都是程序试图通过字符串来加载某个类时可能引发异常。java.lang.NumberFormatException：字符串转换为数字异常；出现原因：字符型数据中包含非数字型字符。java.lang.IndexOutOfBoundsException：数组角标越界异常，常见于操作数组对象时发生。java.lang.ClassCastException：数据类型转换异常SQLException：SQL 异常，常见于操作数据库时的 SQL 语句错误。finally和return的执行顺序finally在return语句执行后，return语句返回前执行。1234567891011121314151617181920212223242526272829public class Main &#123; public static void main(String[] args) &#123; int j = query(); System.out.println(j); &#125; public static int query() &#123; int i = 0; try &#123; System.out.print("try\n"); return i += 10; &#125; catch (Exception e) &#123; System.out.print("catch\n"); i += 20; &#125; finally &#123; System.out.print("finally-i:"+i + "\n"); i += 10; System.out.print("finally\n"); //return i; &#125; System.out.print("finish"); return 200; &#125;&#125;/** try finally-i:10 finally 10*/代码中try语句块中，return i+=10; 这个时候i已经是10了，这个可以从输出的打印结果看出来，因为进入到finally语句的时候，有一个打印语句，打印结果中i就是10，就说明了return语句中的i+=10是已经执行了。1234567891011121314151617181920212223242526public class Main &#123; public static void main(String[] args) &#123; int j = query(); System.out.println(j); &#125; public static int query() &#123; int i = 0; try &#123; System.out.print("try\n"); return i += 10; &#125; catch (Exception e) &#123; System.out.print("catch\n"); i += 20; &#125; finally &#123; System.out.print("finally-i:"+i + "\n"); System.out.print("finally\n"); return i += 10; &#125; &#125;&#125;/* try finally-i:10 finally 20*/try里return i+=10的i+=10被执行之后，return语句还没有返回，因为return语句返回代表该方法执行结束。在finally里return i+=10的i+=10被执行之后，i变成了20，此时的return会覆盖之前的return。由字节码执行顺序深入理解正常情况下指令异常情况下的处理12345Exception table: from to target type 2 15 58 Class java/lang/Exception 2 15 113 any 58 70 113 any如果2到15行指令出现了异常，会进入我们的catch中。final修饰类当用final修饰一个类时，表明这个类不能被继承。也就是说，如果一个类你永远不会让他被继承，就可以用final进行修饰。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。修饰方法只有在想明确禁止该方法在子类中被覆盖的情况下才将方法设置为final的。即父类的final方法是不能被子类所覆盖的。重写的前提是子类可以从父类中继承此方法，如果父类中final修饰的方法同时访问控制权限为private，将会导致子类中不能直接继承到此方法，因此，此时可以在子类中定义方法签名相同的方法，此时不再产生重写与final的矛盾，而是在子类中重新定义了新的方法。（注：类的private方法会隐式地被指定为final方法。）修饰变量final成员变量表示常量，只能被赋值一次，赋值后值不再改变。当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。final修饰一个成员变量，必须要显示初始化。这里有两种初始化方式，一种是在变量声明的时候初始化；第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。finalizeObject 类的一个方法，在垃圾回收器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源回收，例如关闭文件等。该方法更像是一个对象生命周期的临终方法，当该方法被系统调用则代表该对象即将“死亡”，但是需要注意的是，我们主动行为上去调用该方法并不会导致该对象“死亡”，这是一个被动的方法（其实就是回调方法），不需要我们调用。effective finalA variable is considered effective final if it is not modified after initialization in the local block. This means you can now use the local variable without final keyword inside an anonymous class or lambda expression, provided they must be effectively final.static静态方法不可以覆盖，但是可以被重新定义（注意，静态方法可以被继承）1234567891011public class Bks01 extends Dad &#123; public static void main(String[] args) &#123; test(); // son Dad.test(); // dad &#125; // static方法可以被重新定义 static void test() &#123; System.out.println("son"); &#125;&#125;class Dad &#123; static void test() &#123; System.out.println("dad"); &#125;&#125;static执行顺序静态先于普通父类先于子类12345678910111213141516171819202122232425public class Bsk02 &#123; static &#123; System.out.println("Bsk02 static"); &#125; public Bsk02() &#123; System.out.println("Bsk02 constructor"); &#125; public static void main(String[] args) &#123; new Son(); &#125;&#125;class Son extends Father &#123; Bsk02 bsk02 = new Bsk02(); static &#123; System.out.println("Son static"); &#125; public Son() &#123; System.out.println("Son constructor"); &#125;&#125;class Father &#123; static &#123; System.out.println("Father static"); &#125; public Father() &#123; System.out.println("Father constructor"); &#125;&#125;/** Bsk02 static Father static Son static Father constructor Bsk02 constructor Son constructor**/加载Bsk02类，执行静态代码块，执行main方法里的new Son()初始化子类之前先初始化父类Father，执行静态代码块初始化父类的静态变量/属性/代码块之后再执行子类Son的静态代码块再构建父类对象再初始化子类成员变量再构建子类对象重载和重写重写参数列表必须完全与被重写方法的相同（方法签名一致）返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类访问权限不能比父类中被重写的方法的访问权限更低父类的成员方法只能被它的子类重写声明为final的方法不能被重写声明为static的方法不能被重写，但是能够被再次声明子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。重写的方法（子类）不能抛出新的受查异常，或者比被重写方法（父类）声明的更广泛的受查异常。非受查异常没有约束。构造方法不能被重写。如果不能继承一个方法，则不能重写这个方法。重载被重载的方法必须改变参数列表（参数个数或类型或顺序不一样）；被重载的方法可以改变返回类型；被重载的方法可以改变访问修饰符；被重载的方法可以声明新的或更广的受查异常；方法能够在同一个类中或者在一个子类中被重载。无法以返回值类型作为重载函数的区分标准。区别区别点重载方法重写方法参数列表区分标准一定不能修改返回类型不是区分标准相同或者派生类受查异常不是区分标准可以缩小范围或删除，一定不能抛出新的或者更广的异常访问不是区分标准一定不能做更严格的限制（可以降低限制）抽象类 &amp; 接口抽象类抽象类中可以定义构造器可以有抽象方法和具体方法抽象类中可以定义成员变量有抽象方法的类必须被声明为抽象类，而抽象类未必要有抽象方法一个抽象类只能继承一个抽象类（和普通类一致）抽象类可以包含静态方法抽象方法抽象方法不能同时是静态的：抽象方法需要子类重写，而静态的方法是无法被重写的（只能被重新定义），因此二者是矛盾的。抽象方法不能同时是本地的：本地方法是由本地代码（如C代码）实现的方法，而抽象方法是没有实现的，也是矛盾的。抽象方法不能同时被synchronized修饰：synchronized加载普通方法上，拿的是对象的锁。但是抽象方法必须属于抽象类，抽象类本身不能存在实例。接口接口中不能定义构造器方法全部都是抽象方法抽象类中的成员可以是private、默认、protected、public接口中定义的成员变量实际上都是常量接口中不能有静态方法一个类可以实现多个接口接口和抽象类的区别是什么接口的方法默认是 public，接口中的方法不能有实现（Java 8开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。接口中除了static final变量，不能有其他变量，而抽象类中则不一定。一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口。接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）。备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。对象克隆多层浅拷贝1234567891011121314151617181920212223242526272829303132333435363738394041public class CloneTest&#123; public static void main(String[] args) throws CloneNotSupportedException &#123; Body body = new Body(new Head(new Face(new String("丑")))); Body body1 = (Body) body.clone(); System.out.println("body == body1 : " + (body == body1)); System.out.println("body.head == body1.head : " + (body.head == body1.head)); System.out.println(body.head.face == body1.head.face); System.out.println(body.head.face.name == body1.head.face.name); &#125;&#125;class Body implements Cloneable &#123; public Head head; public Body(Head head) &#123; this.head = head; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; Body newBody = (Body) super.clone(); newBody.head = (Head) head.clone(); return newBody; &#125;&#125;class Head implements Cloneable &#123; public Face face; public Head(Face face) &#123; this.face = face; &#125; @Override protected Object clone() throws CloneNotSupportedException &#123; Head newHead = (Head)super.clone(); newHead.face = (Face) face.clone(); return newHead; &#125;&#125;class Face implements Cloneable&#123; public Face(String name) &#123; this.name = name; &#125; public String name; @Override protected Object clone() throws CloneNotSupportedException &#123; Face newFace = (Face)super.clone(); newFace.name = new String(this.name); return newFace; &#125;&#125;序列化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class CloneTest &#123; public static void main(String[] args) &#123; try &#123; Person p1 = new Person("Hao LUO", 33, new Car("Benz", 300)); Person p2 = CloneUtils.clone(p1); // 深度克隆 p2.getCar().setBrand("BYD"); System.out.println(p1); System.out.println(p2); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125;class CloneUtils &#123; private CloneUtils() &#123; throw new AssertionError(); &#125; @SuppressWarnings("unchecked") public static &lt;T extends Serializable&gt; T clone(T obj) throws Exception &#123; ByteArrayOutputStream bout = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(bout); oos.writeObject(obj); ByteArrayInputStream bin = new ByteArrayInputStream(bout.toByteArray()); ObjectInputStream ois = new ObjectInputStream(bin); return (T) ois.readObject(); &#125;&#125;class Person implements Serializable &#123; private static final long serialVersionUID = -9102017020286042305L; private String name; // 姓名 private int age; // 年龄 private Car car; // 座驾 public Person(String name, int age, Car car) &#123; this.name = name; this.age = age; this.car = car; &#125; // ... getter方法和setter方法 @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + ", car=" + car + "]"; &#125;&#125;class Car implements Serializable &#123; private static final long serialVersionUID = -5713945027627603702L; private String brand; // 品牌 private int maxSpeed; // 最高时速 public Car(String brand, int maxSpeed) &#123; this.brand = brand; this.maxSpeed = maxSpeed; &#125; // ... getter和setter方法 @Override public String toString() &#123; return "Car [brand=" + brand + ", maxSpeed=" + maxSpeed + "]"; &#125;&#125;基本类型和包装类型1234567891011121314151617181920212223242526public static void testInter() &#123; Integer a = new Integer(200); Integer b = new Integer(200); Integer c = 200; Integer e = 200; int d = 200; Object o = 200; System.out.println("object和包装类型 " + (o == c)); System.out.println("两个new出来的对象 " + (a == b)); System.out.println("new出的对象和用int赋值的Integer " + (a == c)); System.out.println("两个用int赋值的Integer " + (c == e)); System.out.println("基本类型和new出的对象 " + (d == a)); System.out.println("基本类型和自动装箱的对象 " + (d == c)); Integer f = 100; Integer g = 100; System.out.println("-128到127之间 " + (f == g));&#125;/** object和包装类型 false 两个new出来的对象 false new出的对象和用int赋值的Integer false 两个用int赋值的Integer false 基本类型和new出的对象 true 基本类型和自动装箱的对象 true -128到127之间 true*/自动装箱发生的过程是：基本类型转换为包装类型。自动拆箱发生的过程是：包装类型转换为基本类型。123456789101112131415161718192021222324Integer i1 = 40;Integer i2 = 40;Integer i3 = 0;Integer i4 = new Integer(40);Integer i5 = new Integer(40);Integer i6 = new Integer(0);System.out.println("i1 = i2 " + (i1 == i2));System.out.println("i1 = i2+i3 " + (i1 == i2 + i3));System.out.println("i1 = i4 " + (i1 == i4));System.out.println("i4 = i5 " + (i4 == i5));System.out.println("i4 == i5+i6 " + (i4 == i5 + i6)); System.out.println("40 == i5+i6 " + (40 == i5 + i6)); /* i1 == i2 true i1 == i2+i3 true i1 == i4 false i4 == i5 false 语句i4 == i5 + i6，因为+这个操作符不适用于Integer对象，首先i5和i6进行自动拆箱操作，进行数 值相加，即i4 == 40。然后Integer对象无法与数值进行直接比较，所以i4自动拆箱转为int值40，最终 这条语句转为40 == 40进行数值比较。 i4 == i5+i6 true 40 == i5+i6 true*/Java基本类型的包装类中：Byte，Short，Integer，Long，Character，Boolean实现了常量池技术；Float，Double 并没有实现常量池技术。Character缓存了[0,127]之间的数据，Boolean缓存了true和false，其他4种包装类默认创建了数值[-128,127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。int的范围1234567// 补码会进行循环System.out.println(Integer.MAX_VALUE); // 2147483647System.out.println(Integer.MAX_VALUE + 1); // -2147483648System.out.println(Integer.MAX_VALUE + 2); // -2147483647System.out.println(Integer.MIN_VALUE); // -2147483648System.out.println(Integer.MIN_VALUE - 1); // 2147483647System.out.println(Integer.MIN_VALUE - 2); // 2147483646基本类型之间的转换byte、short、int、long：小范围向大范围的可以自动转，大范围向小范围需要强制转。char可以自动转换为int、long，可以强制转换为short、byte。byte、short、int、long都需要强制转换才能转为char。float自动转换为double，double强制转换为float。byte、short、int、long可以自动float和double。反之需要强制转换。+=和-=包含自动转换，即short s1 = 1; s1 += 1;不会报错。常量池三个关于池子的名词全局字符串池（string pool也有叫做string literal pool）全局字符串池里的内容是在类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用值存到string pool中（记住：string pool中存的是引用值而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的。）。在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串（也就是我们常说的用双引号括起来的）的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。（字符串常量池本身也是存在堆中的）class文件常量池（class constant pool）我们都知道，class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池（constant pool table），用于存放编译器生成的各种字面量（Literal）和符号引用（Symbolic References）。字面量就是我们所说的常量概念，如文本字符串、被声明为final且编译期能被确定的常量值等。符号引用是一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，直接引用一般是指向方法区的本地指针，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：类和接口的全限定名字段的名称和描述符方法的名称和描述符常量池的每一项常量都是一个表，一共有如下表所示的11种各不相同的表结构数据，这每个表开始的第一位都是一个字节的标志位（取值1-12），代表当前这个常量属于哪种常量类型。运行时常量池（runtime constant pool）当java文件被编译成class文件之后，也就是会生成class常量池。jvm在执行某个类的时候，必须经过加载、连接、初始化，而连接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中，由此可知，运行时常量池也是每个类都有一个。在上面我也说了，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，也就是我们上面所说的StringTable，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。JDK8的运行时常量池存放在堆中。String和字符串常量池String对象的两种创建方式12345678910// 直接使用双引号声明出来的 String 对象会直接存储在常量池中。// 使用双引号声明时会调用ldc命令，所以其检查的是字符串常量池。String str1 = "abcd";// 对于new String()则会在堆中创建一个String对象，并返回该对象的引用。// Initializes a newly created String object so that it represents the same sequence // of characters as the argument; in other words, the newly created string is a copy // of the argument string. Unless an explicit copy of original is needed, use of this // constructor is unnecessary since Strings are immutable.String str2 = new String("abcd");System.out.println(str1 == str2); //false上图中的常量池指的是运行时常量池。intern()String.intern() 是一个 Native 方法，JDK对它的解释是：A pool of strings, initially empty, is maintained privately by the class String. When the intern method is invoked, if the string pool already contains a string equal to this String object as determined by the equals(Object) method, then the string from the pool is returned. Otherwise, this String object is added to the string pool and a reference to this String object is returned.（笔者注：这里的添加到字符串常量池实际上是在首次解析发现字符串常量池中没有才会添加到字符串常量池中）It follows that for any two strings s and t, s.intern() == t.intern() is true if and only if s.equals(t) is true.All literal strings and string-valued constant expressions are interned.深入理解java虚拟机里面有一点解释的不是很规范，书里的解释字符串常量池里存的是“某个字符串实例首次出现的引用”，实际上应该说是“某个字符串实例首次被解析时的引用”，因为在类型的生命周期中，解析阶段需要将符号引用转为直接引用，这个阶段所使用到的字符串才符合书里说的“首次出现”这个概念，但问题是解析这个过程的发生只保证在new，invokespecial等12个指令出现之前。所以在面试题中，我一般将首次使用所为首次解析。题1123456String s1 = new String("计算机");String s2 = s1.intern();String s3 = "计算机";System.out.println(s2);System.out.println(s1 == s2); // falseSystem.out.println(s3 == s2); // true212345String s1 = "计算机";String s2 = new String("计算机");String s3 = new String("计算机").intern();System.out.println(s1 == s2); // falseSystem.out.println(s1 == s3); // true312String s3 = new String("1") + new String("2");System.out.println(s3 == s3.intern()); // true4123String str = "12"; // 首次解析 12String s3 = new String("1") + new String("2");System.out.println(s3 == s3.intern()); // false51234String s1 = new String("xy") + "z";String s2 = s1.intern(); // 首次解析xyzSystem.out.println(s1 == s1.intern()); // true System.out.println(s2 == s1.intern()); // true6123456String s1 = new String("xy") + "z";String s3 = new String("xyz"); // 首次解析xyzString s2 = s1.intern();System.out.println(s2 == s3); // falseSystem.out.println(s1 == s1.intern()); // falseSystem.out.println(s2 == s1.intern()); // true7123456String s1 = new String("xy") + "z";String s2 = s1.intern();String s3 = new String("xyz");System.out.println(s2 == s3); // falseSystem.out.println(s1 == s1.intern()); // trueSystem.out.println(s2 == s1.intern()); // true8123456789String s1 = new String("xy") + "z";String s2 = s1.intern();String s0 = "xyz";String s3 = new String(s0);System.out.println(s2 == s3); // falseSystem.out.println(s1 == s2); // trueSystem.out.println(s1 == s3); // falseSystem.out.println(s0 == s1); // trueSystem.out.println(s2 == s3); // false深入分析运行时常量池深入理解Java虚拟机第二版又这么一句话：JDK1.7（以及部分其他虚拟机，例如JRockit）的 intern 实现不会再复制实例，只是在常量池中记录首次出现的实例引用。刚开始看到这句话其实是有点迷的，因为笔者之前理解的常量池中存放的应该是对象，为何引用也能被放进去？不过分析一下之后发现其实在运行时常量池里面应该也是使用键值对形式来保存数据的。否则诸如ldc等指令从常量池中拿数据时就只能采用遍历的方式，这个时间复杂度是不能忍受的，所以笔者暂且将运行时常量池保存数据的结果画作下图。文件的表示File构造123456// public File(String filepath);// 绝对路径:以盘符开头的路径// 相对路径:相对当前项目的根目录public File(String parent, String child);public File(File parent,String child);public File(URI uri);1234567File aFile;try &#123; aFile = new File(new URI("file:///https://isjinhao.github.io/images/avatar.gif")); System.out.println(aFile.getName());&#125; catch (URISyntaxException e) &#123; e.printStackTrace();&#125;获取方法123456public String getAbsolutePath(); // 获取绝对路径public String getName(); // 获取当前File对象的名字public String getPath(); // 获取创建File对象时 传递的路径public long length();// 获取表示文件的File对象的占用的字节数// 如果是文件夹的File对象,返回目录本身的大小,不是目录及其所有孩子的大小创建文件1public boolean createNewFile(); // 创建一个新的文件（只能是文件，不能是文件夹），返回是否创建成功创建文件夹1public boolean mkdir(); // 创建一个新的文件夹，返回是否创建成功判断File对象所表示的文件在OS中是否存在1public boolean exists(); // 返回该File对象是否存在判断是否是文件1public boolean isFile(); // 返回是否是文件判断是否是文件夹1public boolean isDirectory(); // 返回是否是文件夹删除1public boolean delete(); // 删除文件或者文件夹。可以删除的是单个文件，或者空文件夹list和listFiles12public String[] list();public File[] listFiles(); // 只能列出当前文件夹下的一级子文件或者子文件夹文件过滤1234567891011121314151617181920public class Demo2 &#123; public static void main(String[] args) &#123; File fileDir = new File("D:\\blog\\isjinhao\\source\\_posts\\04-进程管理"); // 列出file下所有file对象 MyFileFilter ff = new MyFileFilter(); File[] files = fileDir.listFiles(ff); for (File file : files) &#123; System.out.println(file); &#125; &#125;&#125;class MyFileFilter implements FileFilter&#123; @Override public boolean accept(File pathname) &#123; String name = pathname.getName(); if(name.endsWith(".png") || name.endsWith(".PNG")) return true; return false; &#125;&#125;PathPath是JDK7中表达路径的一个新方式，在Path中，它把文件的路径看做几个部件组成的，比如/usr/develop/tomcat可以被看出两个部件组成：/usr和/develop/tomcat，当然也可以看做三个部件/usr、/develop和/tomcat组成的。以根部件开始的是绝对路径，在类Unix系统中是\，在Windows系统中是C:\等。获得Path通过Paths的静态方法：static Path get(String first, String ... more);public static Path get(URI uri);通过连接给定的字符串创建一个路径。按当前路径解析路径Path resolve(Path other);Path resolve(String other);如果other是绝对路径，那么返回other；否则，返回通过连接this和other获得路径。123456Path path1 = Paths.get("D:\\", "data.csv");Path path2 = Paths.get("test\\test", "选修课数据修改.csv");Path path3 = path1.resolve(path2);Path path4 = path2.resolve(path1);System.out.println(path3); // D:\data.csv\test\test\选修课数据修改.csvSystem.out.println(path4); // D:\data.csv按当前路径解析路径Path resolveSibling(Path other);Path resolveSibling(String other);如果other是绝对路径，那么返回other；否则，返回通过连接this的父路径和other获得路径。1234567//define the fixed path Path base = Paths.get("C:/rafaelnadal/tournaments/2009/BNP.txt"); //resolve sibling AEGON.txt file Path path = base.resolveSibling("AEGON.txt"); //output: C:\rafaelnadal\tournaments\2009\AEGON.txt System.out.println(path.toString());按相对路径进行解析12345678Path path01 = Paths.get("BNP.txt");Path path02 = Paths.get("AEGON.txt");System.out.println(path01); // BNP.txtPath path01_to_path02 = path01.relativize(path02); // ..\AEGON.txtSystem.out.println(path01_to_path02);System.out.println(path02); // AEGON.txtPath path02_to_path01 = path02.relativize(path01); // ..\BNP.txtSystem.out.println(path02_to_path01);其他API移除诸如.和..等的冗余元素：Path normalize();返回和当前路径相等价的绝对路径：Path toAbsolutePath();返回父路径（没有时返回null）：Path getParent();返回该路径的最后一个部件：Path getFileName();返回该路径的根部件（没有时返回null）：Path getRoot();由Path创建一个File对象：File toFile();Files处理小型文本文件public static byte[] readAllBytes(Path path) throws IOException12345678910public static void main(String[] args) &#123; try &#123; byte[] bytes = Files.readAllBytes(Paths.get("filestest")); String string = new String(bytes, "UTF-8"); System.out.println(string); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125;&#125;public static List&lt;String&gt; readAllLines(Path path) throws IOException123456public static void main(String[] args) throws Exception &#123; List&lt;String&gt; lines = Files.readAllLines(Paths.get("filestest")); Iterator&lt;String&gt; iterator = lines.iterator(); while(iterator.hasNext()) System.out.println(iterator.next());&#125;public static Path write(Path path, byte[] bytes, OpenOption... options) throws IOException1234public static void main(String[] args) throws Exception &#123; Files.write(Paths.get("filestest"), "深陷琪中，钰罢不能".getBytes(), StandardOpenOption.APPEND);&#125;获得IO流public static InputStream newInputStream(Path path, OpenOption... options)public static OutputStream newOutputStream(Path path, OpenOption... options)public static BufferedReader newBufferedReader(Path path, Charset cs)public static BufferedReader newBufferedReader(Path path)Files.exists()Files.exists()方法检查给定的Path在文件系统中是否存在。可以创建在文件系统中不存在的Path实例。例如，如果您计划创建一个新目录，您首先要创建相应的Path实例，然后创建目录。由于Path实例可能指向，也可能没有指向文件系统中存在的路径，你可以使用Files.exists()方法来确定它们是否存在（如果需要检查的话）。这里是一个Files.exists()的例子：12Path path = Paths.get("data/logging.properties");boolean pathExists = Files.exists(path, new LinkOption[]&#123; LinkOption.NOFOLLOW_LINKS &#125;);这个例子首先创建一个Path实例指向一个路径，我们想要检查这个路径是否存在。然后，这个例子调用Files.exists()方法，然后将Path实例作为第一个参数。注意Files.exists()方法的第二个参数。这个参数是一个选项数组，它影响Files.exists()如何确定路径是否存在。在上面的例子中的数组包含LinkOption.NOFOLLOW_LINKS，这意味着Files.exists()方法不应该在文件系统中跟踪符号链接，以确定文件是否存在。Files.createDirectory()Files.createDirectory()方法，用于根据Path实例创建一个新目录：123456789Path path = Paths.get("data/subdir");try &#123; Path newDir = Files.createDirectory(path);&#125; catch(FileAlreadyExistsException e)&#123; // 目录已经存在&#125; catch (IOException e) &#123; // 其他发生的异常 e.printStackTrace();&#125;第一行创建表示要创建的目录的Path实例。在try-catch块中，用路径作为参数调用Files.createDirectory()方法。如果创建目录成功，将返回一个Path实例，该实例指向新创建的路径。如果该目录已经存在，则是抛出一个java.nio.file.FileAlreadyExistsException。如果出现其他错误，可能会抛出IOException。例如，如果想要的新目录的父目录不存在，则可能会抛出IOException。父目录是您想要创建新目录的目录。因此，它表示新目录的父目录。Files.copy()Files.copy()方法从一个路径拷贝一个文件到另外一个目录，这里是一个Java Files.copy()例子：12345678910Path sourcePath = Paths.get("data/logging.properties");Path destinationPath = Paths.get("data/logging-copy.properties");try &#123; Files.copy(sourcePath, destinationPath);&#125; catch(FileAlreadyExistsException e) &#123; // 目录已经存在&#125; catch (IOException e) &#123; // 其他发生的异常 e.printStackTrace();&#125;首先，该示例创建一个源和目标Path实例。然后，这个例子调用Files.copy()，将两个Path实例作为参数传递。这可以让源路径引用的文件被复制到目标路径引用的文件中。如果目标文件已经存在，则抛出一个java.nio.file.FileAlreadyExistsException异常。如果有其他错误，则会抛出一个IOException。例如，如果将该文件复制到不存在的目录，则会抛出IOException。重写已存在的文件可以强制Files.copy()覆盖现有的文件。这里有一个示例，演示如何使用Files.copy()覆盖现有文件。12345678910Path sourcePath = Paths.get("data/logging.properties");Path destinationPath = Paths.get("data/logging-copy.properties");try &#123; Files.copy(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);&#125; catch(FileAlreadyExistsException e) &#123; // 目标文件已存在&#125; catch (IOException e) &#123; // 其他发生的异常 e.printStackTrace();&#125;请注意Files.copy()方法的第三个参数。如果目标文件已经存在，这个参数指示copy()方法覆盖现有的文件。Files.move()Files还包含一个函数，用于将文件从一个路径移动到另一个路径。移动文件与重命名相同，但是移动文件既可以移动到不同的目录，也可以在相同的操作中更改它的名称。是的，java.io.File类也可以使用它的renameTo()方法来完成这个操作，但是现在已经在java.nio.file.Files中有了文件移动功能。这里有一个Files.move()例子：12345678910111213141516171819202122Path sourcePath = Paths.get("data/logging-copy.properties");Path destinationPath = Paths.get("data/subdir/logging-moved.properties");try &#123; Files.move(sourcePath, destinationPath, StandardCopyOption.REPLACE_EXISTING);&#125; catch (IOException e) &#123; // 移动文件失败 e.printStackTrace();&#125;public enum StandardCopyOption implements CopyOption &#123; /** * Replace an existing file if it exists. */ REPLACE_EXISTING, /** * Copy attributes to the new file. */ COPY_ATTRIBUTES, /** * Move the file as an atomic file system operation. */ ATOMIC_MOVE;&#125;首先创建源路径和目标路径。源路径指向要移动的文件，而目标路径指向文件应该移动到的位置。然后调用Files.move()方法。这会导致文件被移动。请注意传递给Files.move()的第三个参数。这个参数告诉Files.move()方法来覆盖目标路径上的任何现有文件。这个参数实际上是可选的。如果移动文件失败，Files.move()方法可能抛出一个IOException。例如，如果一个文件已经存在于目标路径中，并且您已经排除了StandardCopyOption.REPLACE_EXISTING选项，或者被移动的文件不存在等等。Files.delete()Files.delete()方法可以删除一个文件或者目录。下面是一个Java Files.delete()例子：1234567Path path = Paths.get("data/subdir/logging-moved.properties");try &#123; Files.delete(path);&#125; catch (IOException e) &#123; // 删除文件失败 e.printStackTrace();&#125;首先，创建指向要删除的文件的Path。然后调用Files.delete()方法。如果Files.delete()由于某种原因不能删除文件（例如，文件或目录不存在），会抛出一个IOException。文件搜索Files.walkFileTree()Files.walkFileTree()方法包含递归遍历目录树的功能。walkFileTree()方法将Path实例和FileVisitor作为参数。Path实例指向您想要遍历的目录。FileVisitor在遍历期间被调用。在我解释遍历是如何工作之前，这里我们先了解FileVisitor接口:12345678910public interface FileVisitor&lt;T&gt; &#123; FileVisitResult preVisitDirectory(T dir, BasicFileAttributes attrs) throws IOException; FileVisitResult visitFile(T file, BasicFileAttributes attrs) throws IOException; FileVisitResult visitFileFailed(T file, IOException exc) throws IOException; FileVisitResult postVisitDirectory(T dir, IOException exc) throws IOException;&#125;您必须自己实现FileVisitor接口，并将实现的实例传递给walkFileTree()方法。在目录遍历过程中，您的FileVisitor实现的每个方法都将被调用。如果不需要实现所有这些方法，那么可以扩展SimpleFileVisitor类，它包含FileVisitor接口中所有方法的默认实现。这里是一个walkFileTree()的例子：1234567891011121314151617181920212223242526Files.walkFileTree(path, new FileVisitor&lt;Path&gt;() &#123; @Override public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException &#123; System.out.println("pre visit dir:" + dir); return FileVisitResult.CONTINUE; &#125; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123; System.out.println("visit file: " + file); return FileVisitResult.CONTINUE; &#125; @Override public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException &#123; System.out.println("visit file failed: " + file); return FileVisitResult.CONTINUE; &#125; @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException &#123; System.out.println("post visit directory: " + dir); return FileVisitResult.CONTINUE; &#125;&#125;);FileVisitor实现中的每个方法在遍历过程中的不同时间都被调用:在访问任何目录之前调用preVisitDirectory()方法。在访问一个目录之后调用postVisitDirectory()方法。调用visitFile()在文件遍历过程中访问的每一个文件。它不会访问目录-只会访问文件。在访问文件失败时调用visitFileFailed()方法。例如，如果您没有正确的权限，或者其他什么地方出错了。这四个方法中的每个都返回一个FileVisitResult枚举实例。FileVisitResult枚举包含以下四个选项:CONTINUE：继续，意味着文件的执行应该像正常一样继续。TERMINATE：终止，意味着文件遍历现在应该终止。SKIP_SIBLING：跳过同级，意味着文件遍历应该继续，但不需要访问该文件或目录的任何同级。SKIP_SUBTREE：意味着文件遍历应该继续，但是不需要访问这个目录中的子目录。这个值只有从preVisitDirectory()返回时才是一个函数。如果从任何其他方法返回，它将被解释为一个CONTINUE继续。通过返回其中一个值，调用方法可以决定如何继续执行文件。文件搜索这里是一个用于扩展SimpleFileVisitor的walkFileTree()，以查找一个名为README.txt的文件:12345678910111213141516171819Path rootPath = Paths.get("data");String fileToFind = File.separator + "README.txt";try &#123; Files.walkFileTree(rootPath, new SimpleFileVisitor&lt;Path&gt;() &#123; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123; String fileString = file.toAbsolutePath().toString(); // System.out.println("pathString = " + fileString); if(fileString.endsWith(fileToFind))&#123; System.out.println("file found at path: " + file.toAbsolutePath()); return FileVisitResult.TERMINATE; &#125; return FileVisitResult.CONTINUE; &#125; &#125;);&#125; catch(IOException e)&#123; e.printStackTrace();&#125;递归删除目录Files.walkFileTree()也可以用来删除包含所有文件和子目录的目录。Files.delete()方法只会删除一个目录，如果它是空的。通过遍历所有目录并删除每个目录中的所有文件(在visitFile())中，然后删除目录本身(在postVisitDirectory()中)，您可以删除包含所有子目录和文件的目录。下面是一个递归目录删除示例:1234567891011121314151617181920Path rootPath = Paths.get("data/to-delete");try &#123; Files.walkFileTree(rootPath, new SimpleFileVisitor&lt;Path&gt;() &#123; @Override public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException &#123; System.out.println("delete file: " + file.toString()); Files.delete(file); return FileVisitResult.CONTINUE; &#125; @Override public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException &#123; Files.delete(dir); System.out.println("delete dir: " + dir.toString()); return FileVisitResult.CONTINUE; &#125; &#125;);&#125; catch(IOException e)&#123; e.printStackTrace();&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.03-JavaSE-基础-3]]></title>
    <url>%2Fposts%2F5590.html%2F</url>
    <content type="text"><![CDATA[泛型泛型类1234567891011121314151617181920// 此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型// 在实例化泛型类时，必须指定T的具体类型public class Generic&lt;T&gt; &#123; // key这个成员变量的类型为T，T的类型由外部指定 private T key; // 泛型构造方法形参key的类型也为T，T的类型由外部指定 public Generic(T key) &#123; this.key = key; &#125; // 泛型方法getKey的返回值类型为T，T的类型由外部指定 public T getKey()&#123; return key; &#125; public static void main(String[] args) &#123; // 泛型的类型参数只能是类类型（包括自定义类），不能是简单类型 // 传入的实参类型需与泛型的类型参数类型相同，即为Integer Generic&lt;Integer&gt; genericInteger = new Generic&lt;Integer&gt;(123456); // 传入的实参类型需与泛型的类型参数类型相同，即为String Generic&lt;String&gt; genericString = new Generic&lt;String&gt;("key_vlaue"); System.out.println("key is " + genericInteger.getKey().getClass()); System.out.println("key is " + genericString.getKey().getClass()); &#125;&#125;泛型接口的实现1234// 定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125;当实现泛型接口的类，未传入泛型实参时：123456789/** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt; * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，会报错："Unknown class" */class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123; @Override public T next() &#123; return null; &#125;&#125;当实现泛型接口的类，传入泛型实参时：123456789101112131415/** * 传入泛型实参时： * 定义一个生产器实现这个接口，虽然我们只创建了一个泛型接口Generator&lt;T&gt; * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator&lt;T&gt;，public T next(); 中的的T都要替换成传入的String类型。 */public class FruitGenerator implements Generator&lt;String&gt; &#123; private String[] fruits = new String[]&#123;"Apple", "Banana", "Pear"&#125;; @Override public String next() &#123; Random rand = new Random(); return fruits[rand.nextInt(3)]; &#125;&#125;泛型方法泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型 。12345678910111213141516/** * 泛型方法的基本介绍 * @param tClass 传入的泛型实参 * @return T 返回值为T类型 * 说明： * 1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。 * 2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。 * 3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。 * 4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。 * 5）如果泛型类也声明了一个T，泛型方法的T会覆盖泛型类的T */public &lt;T&gt; T genericMethod(Class&lt;T&gt; tClass) throws InstantiationException, IllegalAccessException&#123; T instance = tClass.newInstance(); return instance;&#125;泛型”方法”的详细举例1234567891011121314151617181920212223242526272829303132333435363738394041public class GenericTest &#123; // 这个类是个泛型类，在上面已经介绍过 public class Generic&lt;T&gt; &#123; private T key; public Generic(T key) &#123; this.key = key; &#125; // 我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。 // 这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。 // 所以在这个方法中才可以继续使用 T 这个泛型。 public T getKey()&#123; return key; &#125; /** * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E" * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。 public E setKey(E key)&#123; this.key = keu &#125; */ &#125; /** * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个 * 如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; * ... * &#125; */ public &lt;T&gt; T showKeyName(Generic&lt;T&gt; container)&#123; System.out.println("container key :" + container.getKey()); // 当然这个例子举的不太合适，只是为了说明泛型方法的特性。 T test = container.getKey(); return test; &#125; /** * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' " * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。 * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。 public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container) &#123; ... &#125; */&#125;类中的泛型方法1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Generic &#123; class Fruit &#123; public String toString() &#123; return "fruit"; &#125; &#125; class Apple extends Fruit &#123; public String toString() &#123; return "apple"; &#125; &#125; class Person &#123; public String toString() &#123; return "Person"; &#125; &#125; class GenerateTest&lt;T&gt; &#123; // 方法中的T和类上声明的T一致 public void show_1(T t)&#123; System.out.println(t.toString()); &#125; // 泛型类中声明了一个泛型方法，使用泛型E，泛型E可以为任意类型。可以类型与T相同，也可以不同。 // 由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识 // 别泛型方法中识别的泛型。 public &lt;E&gt; void show_3(E t) &#123; System.out.println(t.toString()); &#125; // 泛型类中声明了一个泛型方法，使用泛型T，这个T是一种全新的类型，即泛型方法的T覆盖了泛型类的T // 编译器会报警告：The type parameter T is hiding the type T public &lt;T&gt; void show_2(T t) &#123; System.out.println(t.toString()); &#125; &#125; public static void main(String[] args) &#123; Apple apple = new Generic().new Apple(); Person person = new Generic().new Person(); GenerateTest&lt;Fruit&gt; generateTest = new Generic().new GenerateTest&lt;Fruit&gt;(); // apple是Fruit的子类，所以这里可以，此时实际上是多态的性质 generateTest.show_1(apple); // 编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person // generateTest.show_1(person); // 使用这两个方法都可以成功 generateTest.show_2(apple); generateTest.show_2(person); // 使用这两个方法也都可以成功 generateTest.show_3(apple); generateTest.show_3(person); &#125;&#125;静态方法与泛型类中的静态方法使用泛型：静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。12345678910public class StaticGenerator&lt;T&gt; &#123; /** * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法） * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。 * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息： * "StaticGenerator cannot be refrenced from static context" */ public static &lt;T&gt; void show(T t)&#123; &#125;&#125;为什么要有这样的限定呢？其实是因为Java中的泛型是在编译期实现的，也就是说如果我们有一个泛型类，如Stream&lt;T&gt;，它里面有一个静态方法of(T ... t)，我们不能使用Stream&lt;String&gt;.of(...)，因为压根就没有Stream&lt;String&gt;这个类型，只能使用Stream.of()，这样一来我们就无法给参数T实例化一个类型。也就是说类中的静态属性和静态方法中的T没有办法被实例化的。泛型通配符泛型类和泛型方法都是定义了一个类或者方法的模板。能构造不同类型的属性或不同参数类型的方法。我们假设：1234567891011121314151617181920212223242526272829303132333435abstract class Fruit &#123; abstract int getPrice(); abstract int getNumber();&#125;class Apple extends Fruit &#123; @Override int getPrice() &#123; return 1; &#125; @Override int getNumber() &#123; return 10; &#125;&#125;class Orange extends Fruit &#123; @Override int getPrice() &#123; return 2; &#125; @Override int getNumber() &#123; return 20; &#125;&#125;public class Goods&lt;T&gt; &#123; private T t; private int number;&#125;class Shopping&#123; void payMoney(Goods&lt;Fruit&gt; fruitGoods)&#123; &#125; public static void main(String[] args) &#123; Shopping shopping = new Shopping(); shopping.payMoney(new Goods&lt;Apple&gt;()); &#125;&#125;上面代码的33行会出错。本来我们的想法是计算应该付多少钱，所以使用了抽象类Fruit。但是虽然Apple是Fruit的子类，但是Goods&lt;Apple&gt;却不是Goods&lt;Fruit&gt;的子类，所以这里会报错。怎么解决呢？便是使用通配符?，将上面代码的30行换为void payMoney(Goods&lt;?&gt; fruitGoods){ }便不会报错。通配符是一种类型，一种可以代表多种类型的类型。它和T不一样，T是为了声明此类有一个类型参数需要去实例化，而?是一种实例化T的类型。上下界通配符下面代码就是“上界通配符（Upper Bounds Wildcards）”：1Goods&lt;? extends Fruit&gt;上界通配符表示传入的只能是Fruit的子类及自己。相对应的，“下界通配符（Lower Bounds Wildcards）”：1Plate&lt;? super Fruit&gt;下界通配符表示传入的只能是Fruit的父类及自己。通配符在实例T时的限制假如我们有两个方法：1234567891011public class Goods&lt;T&gt; &#123; private T t; private int number; public void set(T t)&#123; &#125; public T get()&#123; return null; &#125; public static void main(String[] args) &#123; Goods&lt;? extends Fruit&gt; fruitGoods = new Goods&lt;&gt;(); fruitGoods.set(new Orange()); // 这段代码会出错 Fruit fruit = fruitGoods.get(); &#125;&#125;我们分析一下，第7行代码中? extends Fruit替换了T，这个时候编译器知道T是Fruit或者其子类，但是它却不知道具体是哪一个，假如它编译器设置为了Apple，那么传入Orange对象在编译期是不会出错的，因为Orange是符合? extends Fruit的，但是我们知道Apple的引用根本无法引用Orange的对象，就会出错。所以编译器就拒绝传递它不确定的类型（null 除外，因为任何对象都能引用null）。第9行不会出错，因为返回的类型是Fruit或者其子类，这样我们在接收的时候使用Fruit接收就行了。这里有人会问，那为什么不会将private T t的T设置为Fruit呢，其实这是由于在第9行中的Fruit是我们认为确定的，对于编译器来说这是不可变得，而private T t不是我们能确定的，它是一个不确定的值，编译器为了防止出现我们刚才的问题拒绝传递不确定的值。1234567891011public class Goods&lt;T&gt; &#123; private T t; private int number; public void set(T t)&#123; &#125; public T get()&#123; return null; &#125; public static void main(String[] args) &#123; Goods&lt;? super Fruit&gt; fruitGoods = new Goods&lt;&gt;(); fruitGoods.set(new Orange()); Object fruit = fruitGoods.get(); &#125;&#125;如果使用了下界通配符，我们就可以传入Orange对象，因为T会被实例化为Fruit或其父类，而无论是Fruit还是其父类都能接收Orange对象，但是不能接受Fruit的父类。而在返回的时候只能用Object接收，因为在super定义的类型区间内只有Object可以接收所有的类型。泛型的缺陷运行时类型查询只适用于原始类型123if(a instanceof Pair&lt;String&gt;); // errorPair&lt;String&gt; p = (Pair&lt;String&gt;) a; // errorArrayList&lt;String&gt;.class == ArrayList&lt;Integer&gt; // true不能创建一个确切的泛型类型的数组也就是说下面的这个例子是不可以的：1List&lt;String&gt;[] ls = new ArrayList&lt;String&gt;[10];而使用通配符创建泛型数组是可以的，如下面这个例子：1List&lt;?&gt;[] ls = new ArrayList&lt;?&gt;[10];这样也是可以的：1List&lt;String&gt;[] ls = new ArrayList[10];下面使用Sun的一篇文档的一个例子来说明这个问题：12345678910List&lt;String&gt;[] lsa = new List&lt;String&gt;[10]; // Not really allowed. Object o = lsa;Object[] oa = (Object[]) o; List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;(); li.add(new Integer(3)); oa[1] = li; // Unsound, but passes run time store check String s = lsa[1].get(0); // Run-time error: ClassCastException./**这种情况下，由于JVM泛型的擦除机制，在运行时JVM是不知道泛型信息的，所以可以给oa[1]赋上一个ArrayList而不会出现异常，但是在取出数据的时候却要做一次类型转换，所以就会出现ClassCastException，如果可以进行泛型数组的声明，上面说的这种情况在编译期将不会出现任何的警告和错误，只有在运行时才会出错。而对泛型数组的声明进行限制，对于这样的情况，可以在编译期提示代码有类型安全问题，比没有任何提示要强很多。*/下面采用通配符的方式是被允许的:数组的类型不可以是类型变量，除非是采用通配符的方式，因为对于通配符的方式，最后取出数据是要做显式的类型转换的。1234567List&lt;?&gt;[] lsa = new List&lt;?&gt;[10]; // OK, array of unbounded wildcard type. Object o = lsa;Object[] oa = (Object[]) o;List&lt;Integer&gt; li = new ArrayList&lt;Integer&gt;();li.add(new Integer(3));oa[1] = li; // Correct.Integer i = (Integer) lsa[1].get(0); // OK可变参参数警告1234public static &lt;T&gt; void addAll(Collection&lt;T&gt; coll, T... ts) &#123; for (T : ts) coll. add(t);&#125;应该记得，实际上参数ts是一个数组，包含提供的所有实参，现在考虑一下调用：1234Collection&lt;Pair&lt;String&gt;&gt; table ...;Pair&lt;String&gt; pairl = ...;Pair&lt;String&gt; pair2 = ...;addAll(table, pairl, pair2);为了调用这个方法，Java虚拟机必须建立一个Pair &lt;String&gt;数组,这就违反了前面的规则。不过，对于这种情况,规则有所放松，你只会得到一个警告，而不是错误。可以采用两种方法来抑制这个警告。一种方法是为包含addA1调用的方法增加注解@Suppress Warnings(&quot;unchecked&quot;)或者在Java SE7中，还可以用@Safe Varargs直接标注addAll方法：12@SafeVarargspublic static &lt;T&gt; void addAl1 (Collection&lt;T&gt; coll, T... ts)现在就可以提供泛型类型来调用这个方法了。对于只需要读取参数数组元素的所有方法，都可以使用这个注解。不能实例化类型变量不能使用像new T(...)，new T[...]或T.class这样的表达式中的类型变量。例如，下面的Pair&lt;T&gt;构造器就是非法的：1public Pair &#123; first= new T(); second = new T(); &#125; // Error反射解决12345678910111213141516public class Pair&lt;T&gt; &#123; public T first; public T second; public Pair(T first, T second) &#123; this.first = first; this.second = second; &#125; public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cla)&#123; try &#123; return new Pair&lt;&gt;(cla.newInstance(), cla.newInstance()); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125;不能实例化类型数组1// T [] ts = new T[100]; error反射解决12345678910public class Pair&lt;T&gt; &#123; T[] ts; public Pair(T[] ts) &#123; this.ts = ts; &#125; public static &lt;T&gt; Pair&lt;T&gt; makePair(T... a) &#123; return new Pair&lt;&gt;((T[]) Array.newInstance(a.getClass().getComponentType(), 2)); &#125; public static void main(String[] args) &#123; Pair&lt;String&gt; p = Pair.makePair(value -&gt; new String[value]); &#125;&#125;数组作为类的私有实例域如果数组仅仅作为一个类的私有实例域，就可以将这个数组声明为Object []，并且在取元素时进行类型转换。 例如ArrayList类这样实现：123456789101112131415transient Object[] elementData;public E get(int index) &#123; rangeCheck(index); return elementData(index);&#125;@SuppressWarnings("unchecked")E elementData(int index) &#123; return (E) elementData[index];&#125;public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue;&#125;不能抛出或捕获泛型类的实例既不能抛出也不能捕获泛型类对象。 实际上，甚至泛型类扩展Throwable都是不合法的。例如，以下定义就不能正常编译：1public class Problem &lt;T&gt; extends Exception &#123; /*...*/ &#125; // Error can't extend Throwablecatch 子句中不能使用类型变量。 例如，以下方法将不能编译：1234567public static &lt;T extends Throwable&gt; void doWork(Class&lt;T&gt; t) &#123; try &#123; // do work &#125; catch (T e) &#123; // Error can't catch type variable // ... &#125;&#125;不过，在异常规范中使用类型变量是允许的。以下方法是合法的：1234567public static &lt;T extends Throwable&gt; void doWork(T t) throws T &#123; // OK try &#123; // do work &#125; catch (Throwable realCause) &#123; throw t ; &#125;&#125;可以消除对受查异常的检查Java 异常处理的一个基本原则是，必须为所有受查异常提供一个处理器。不过可以利用泛型消除这个限制。关键在于以下方法：1234@SuppressWamings("unchecked")public static &lt;T extends Throwable&gt; void throwAs(Throwable e) throws T &#123; throw (T) e ;&#125;假设这个方法包含在类Block中 ， 如果调用Block.&lt;RuntimeException&gt; throwAs(t);，编译器就会认为t是一个非受查异常。以下代码会把所有异常都转换为编译器所认为的非受查异常：12345try &#123; // do work&#125; catch (Throwable t) &#123; Block.&lt;RuntimeException&gt; throwAs(t);&#125;下面把这个代码包装在一个抽象类中。用户可以覆盖body方法来提供一个具体的动作。调用toThread时，会得到Thread类的一个对象，它的run方法不会介意受查异常。123456789101112131415161718public abstract class Block &#123; public abstract void body() throws Exception; public Thread toThread() &#123; return new Thread()&#123; public void run()&#123; try &#123; body(); &#125; catch (Throwable t) &#123; Block.&lt;RuntimeException&gt; throwAs(t); &#125; &#125; &#125;; &#125; @SuppressWamings("unchecked") public static &lt;T extends Throwable&gt; void throwAs(Throwable e) throws T &#123; throw (T) e; &#125;&#125;例如，以下程序运行了一个线程，它会拋出一个受查异常。1234567891011public class Test &#123; public static void main(String []args) &#123; new Block() &#123; public void body() throws Exception &#123; Scanner in = new Scanner(new File("ququx"), "UTF-8"); while(in.hasNext()) System.out.println(in.next()); &#125; &#125;.toThread().start(); &#125;&#125;运行这个程序时，会得到一个栈轨迹，其中包含一个FileNotFoundException。这有什么意义呢？正常情况下，你必须捕获线程run方法中的所有受查异常 ， 把它们“包装”到非受查异常中，因为run方法声明为不抛出任何受查异常。不过在这里并没有做这种“包装”。我们只是抛出异常，并“哄骗”编译器，让它认为这不是一个受查异常。通过使用泛型类、 擦除和@SuppressWamings注解，就能消除 Java 类型系统的部分基本限制。&lt;T extends Comparable&lt;? super T&gt;&gt;123456789101112131415161718192021222324252627282930public class Test &#123; // 第一种声明：简单，灵活性低 public static &lt;T extends Comparable&lt;T&gt;&gt; void mySort1(List&lt;T&gt; list) &#123; Collections.sort(list); &#125; // 第二种声明：复杂，灵活性高 public static &lt;T extends Comparable&lt;? super T&gt;&gt; void mySort2(List&lt;T&gt; list) &#123; Collections.sort(list); &#125; public static void main(String[] args) &#123; //主函数中将分别创建Animal和Dog两个序列，然后调用排序方法对其进行测试 //main函数中具体的两个版本代码将在下面具体展示 &#125;&#125;class Animal implements Comparable&lt;Animal&gt; &#123; protected int age; public Animal(int age) &#123; this.age = age; &#125; // 使用年龄与另一实例比较大小 @Override public int compareTo(Animal other) &#123; return this.age - other.age; &#125;&#125;class Dog extends Animal &#123; public Dog(int age) &#123; super(age); &#125;&#125;对mySort1()进行测试，main方法代码如下所示1234567891011// 创建一个 Animal ListList&lt;Animal&gt; animals = new ArrayList&lt;Animal&gt;();animals.add(new Animal(25));animals.add(new Dog(35));// 创建一个 Dog ListList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;();dogs.add(new Dog(5));dogs.add(new Dog(18));// 测试 mySort1() 方法mySort1(animals);mySort1(dogs); // error结果编译出错，报错信息为：1The method mySort1(List&lt;T&gt;) in the type TypeParameterTest is not applicable for the arguments (List&lt;Dog&gt;)如果传入的是List&lt;Animal&gt;程序将正常执行，因为Animal实现了接口Comparable&lt;Animal&gt;。但是，如果传入的参数是List&lt;Dog&gt;程序将报错，因为Dog类中没有实现接口Comparable&lt;Dog&gt;，它只从Animal继承了一个Comparable&lt;Animal&gt;接口。对mySort12()进行测试，main方法代码如下所示1234567891011// 创建一个 Animal ListList&lt;Animal&gt; animals = new ArrayList&lt;Animal&gt;();animals.add(new Animal(25));animals.add(new Dog(35));// 创建一个 Dog ListList&lt;Dog&gt; dogs = new ArrayList&lt;Dog&gt;();dogs.add(new Dog(5));dogs.add(new Dog(18));// 测试 mySort2() 方法mySort2(animals);mySort2(dogs);这时候我们发现该程序可以正常运行。它不但能够接受Animal implements Comparable&lt;Animal&gt;这样的参数，也可以接收Dog implements Comparable&lt;Animal&gt;这样的参数。在添加animals时，T是Animal，Comparable的泛型是Animal，Animal super Animal成立。在添加dogs时，T是Dog，Comparable的泛型是Animal，Animal super Dog成立。ThreadLocalThreadLocal使用ThreadLocal是一个线程局部变量，我们都知道全局变量和局部变量的区别，拿Java举例就是定义在类中的是全局的变量，各个方法中都能访问得到（静态方法不能获得实例属性），而局部变量定义在方法中，只能在方法内访问。那线程局部变量（ThreadLocal）就是每个线程都会有一个局部变量，独立于变量的初始化副本，而各个副本是通过线程唯一标识相关联的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class TaskThread extends Thread &#123; private UniqueThreadIdGenerator t; public TaskThread(String threadName, UniqueThreadIdGenerator t) &#123; this.setName(threadName); this.t = t; &#125; @Override public void run() &#123; for (int i = 0; i &lt; 4; i++) &#123; try &#123; int value = t.getUniqueId(); System.out.println("thread[ " + Thread.currentThread().getName() + " ] --&gt; uniqueId[ " + value + " ]"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; &#125; public static void main(String[] args) &#123; UniqueThreadIdGenerator uniqueThreadId = new UniqueThreadIdGenerator(); // 为每个线程生成一个唯一的局部标识 TaskThread t1 = new TaskThread("custom-thread-1", uniqueThreadId); TaskThread t2 = new TaskThread("custom-thread-2", uniqueThreadId); TaskThread t3 = new TaskThread("custom-thread-3", uniqueThreadId); t1.start(); t2.start(); t3.start(); &#125;&#125;class UniqueThreadIdGenerator &#123; // 线程局部整型变量 private final ThreadLocal&lt;Integer&gt; uniqueNum = new ThreadLocal&lt;Integer&gt;() &#123; @Override protected Integer initialValue() &#123; return 0; &#125; &#125;; // 变量值 public int getUniqueId() &#123; uniqueNum.set(uniqueNum.get() + 1); return uniqueNum.get(); &#125;&#125;// thread[ custom-thread-2 ] --&gt; uniqueId[ 1 ]// thread[ custom-thread-1 ] --&gt; uniqueId[ 1 ]// thread[ custom-thread-3 ] --&gt; uniqueId[ 1 ]// thread[ custom-thread-1 ] --&gt; uniqueId[ 2 ]// thread[ custom-thread-2 ] --&gt; uniqueId[ 2 ]// thread[ custom-thread-1 ] --&gt; uniqueId[ 3 ]// thread[ custom-thread-3 ] --&gt; uniqueId[ 2 ]// thread[ custom-thread-1 ] --&gt; uniqueId[ 4 ]// thread[ custom-thread-2 ] --&gt; uniqueId[ 3 ]// thread[ custom-thread-3 ] --&gt; uniqueId[ 3 ]// thread[ custom-thread-2 ] --&gt; uniqueId[ 4 ]// thread[ custom-thread-3 ] --&gt; uniqueId[ 4 ]// 每个线程之间的uniqueId是互不干扰的ThreadLocal源码分析每个线程内部有一个ThreadLocalMap，get()的时候就是获得当前线程的ThreadLocalMap，并且将当前ThreadLocal对象传入map.getEntry(this);get()1234567891011121314151617181920212223242526272829303132333435363738394041424344// ThreadLocal.javapublic T get() &#123; Thread t = Thread.currentThread(); // 拿到每个线程内部的ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) &#123; // this指的是这个ThreadLocal对象，每个ThreadLocalMap可以有多个ThreadLocal对象 ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings("unchecked") T result = (T)e.value; return result; &#125; &#125; return setInitialValue();&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125;// 默认初始化为nullprotected T initialValue() &#123; return null;&#125;void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125;// ThreadLocalMap.javaThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; table = new Entry[INITIAL_CAPACITY]; int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); table[i] = new Entry(firstKey, firstValue); size = 1; setThreshold(INITIAL_CAPACITY);&#125;set()12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;remove()123456// 从当前线程的ThreadLocalMap中删除当前的ThreadLocalpublic void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125;ThreadLocalMapThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立的方式实现了Map的功能，其内部的Entry也独立实现。在ThreadLocalMap中，也是用Entry来保存K-V结构数据的。但是Entry中key只能是ThreadLocal对象，这点被Entry的构造方法已经限定死了。Entry继承自WeakReference（弱引用，生命周期只能存活到下次GC前），但只有Key是弱引用类型的，Value并非弱引用。123456789// Entry.javastatic class Entry extends WeakReference&lt;ThreadLocal&gt; &#123; /** The value associated with this ThreadLocal. */ Object value; Entry(ThreadLocal k, Object v) &#123; super(k); value = v; &#125;&#125;Hash冲突怎么解决和HashMap的最大的不同在于，ThreadLocalMap结构非常简单，没有next引用，也就是说ThreadLocalMap中解决Hash冲突的方式并非链表的方式，而是采用线性探测的方式，所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。ThreadLocalMap解决Hash冲突的方式就是简单的步长加1或减1，寻找下一个相邻的位置。123456789101112/** * Increment i modulo len. */private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0);&#125;/** * Decrement i modulo len. */private static int prevIndex(int i, int len) &#123; return ((i - 1 &gt;= 0) ? i - 1 : len - 1);&#125;显然ThreadLocalMap采用线性探测的方式解决Hash冲突的效率很低，如果有大量不同的ThreadLocal对象放入map中时发送冲突，或者发生二次冲突，则效率很低。所以这里引出的良好建议是：每个线程只存一个变量，需要多个变量 这个时候需要把这些对象封装成变量对象。内存泄漏ThreadLocal在ThreadLocalMap中是以一个弱引用身份被Entry中的Key引用的，因此如果ThreadLocal没有外部强引用来引用它，那么ThreadLocal会在下次JVM垃圾收集时被回收。这个时候就会出现Entry中Key已经被回收，出现一个null Key的情况，外部读取ThreadLocalMap中的元素是无法通过null Key来找到Value的。因此如果当前线程的生命周期很长（比如线程池中的线程），一直存在，那么其内部的ThreadLocalMap对象也一直生存下来，这些null key就存在一条强引用链的关系一直存在：Thread –&gt; ThreadLocalMap–&gt;Entry–&gt;Value，这条强引用链会导致Entry不会回收，Value也不会回收，但Entry中的Key却已经被回收的情况，造成内存泄漏。但是JVM团队已经考虑到这样的情况，并做了一些措施来保证ThreadLocal尽量不会内存泄漏：在ThreadLocal的get()、set()、remove()方法调用的时候会清除掉线程ThreadLocalMap中所有Entry中Key为null的Value，并将整个Entry设置为null，利于下次内存回收。ThreadLocal的get()方法在调用map.getEntry(this)时，内部会判断key是否为null1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private Entry getEntry(ThreadLocal key) &#123; int i = key.threadLocalHashCode &amp; (table.length - 1); Entry e = table[i]; if (e != null &amp;&amp; e.get() == key) return e; else return getEntryAfterMiss(key, i, e);&#125;private Entry getEntryAfterMiss(ThreadLocal key, int i, Entry e) &#123; Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal k = e.get(); if (k == key) return e; if (k == null) expungeStaleEntry(i); // 清除空结点的方法 else i = nextIndex(i, len); e = tab[i]; &#125; return null;&#125;private int expungeStaleEntry(int staleSlot) &#123; Entry[] tab = table; int len = tab.length; // expunge entry at staleSlot（意思是，删除value，设置为null便于下次回收） tab[staleSlot].value = null; tab[staleSlot] = null; size--; // Rehash until we encounter null // 将当前Entry删除后，会继续循环往下检查是否有key为null的节点，如果有则一并删除，防止内存泄漏。 Entry e; int i; for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal k = e.get(); if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; int h = k.threadLocalHashCode &amp; (len - 1); if (h != i) &#123; tab[i] = null; // Unlike Knuth 6.4 Algorithm R, we must scan until // null because multiple entries could have been stale. while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; return i;&#125;但这样也并不能保证ThreadLocal不会发生内存泄漏，例如：使用static的ThreadLocal，延长了ThreadLocal的生命周期，可能导致的内存泄漏。分配使用了ThreadLocal又不再调用get()、set()、remove()方法，那么就会导致内存泄漏为什么使用弱引用？有一些文章说内存泄漏是因为key的弱引用，但是实际上key使用弱引用不仅不是内存泄漏的原因，反而可以减少内存泄漏的发生。官方文档的说法：To help deal with very large and long-lived usages, the hash table entries use WeakReferences for keys.为了处理非常大和生命周期非常长的线程，哈希表使用弱引用作为 key。下面我们分两种情况讨论：key 使用强引用：引用的ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏。key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set，get，remove的时候会被清除。比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障：弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set，get，remove的时候会被清除。因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key的value就会导致内存泄漏，而不是因为弱引用。所以：每次使用完ThreadLocal，都调用它的remove()方法，清除数据。尤其是在使用线程池的情况下，没有及时清理ThreadLocal，不仅是内存泄漏的问题，更严重的是可能导致业务逻辑出现问题。所以，使用ThreadLocal就跟加锁完要解锁一样，用完就清理。匿名内部类不能修改外部变量想必这个问题也曾经困扰过很多人，在讨论这个问题之前，先看下面这段代码：12345678public class Outer &#123; public Outer test(int x) &#123; int y = 100; return new Outer() &#123; int z = y; &#125;; &#125;&#125;从反编译的结果来看，我们会创建一个内部类，并且执行构造方法。我们再反编译一个Outer$1.class从构造方法我们可以看出了这个构造方法有两个参数，一个是外部类的引用，一个是一个int。从字段结果中可以看到，有三个字段：z、final y和Outer。也就是说我们虽然没有把y声明为final的，在传递到内部类中的时候也会是final的，这时候就知道为什么在内部类中不能修改y了，因为内部类中的y实际上是外部类数据的一份拷贝，这份拷贝在传递到内部类后会变成一个final的值。而且即使不是final的，我们把内部类的值进行修改实际上对外部类也没有任何影响。深入分析JDK动态代理123public interface Subject &#123; void request();&#125;123456public class RealSubject implements Subject &#123; @Override public void request() &#123; System.out.println("request is called"); &#125;&#125;12345678910111213public class DynamicSubject implements InvocationHandler &#123; private Object object; public DynamicSubject(Object object) &#123; this.object = object; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("before calling: "+ method); method.invoke(this.object, args); System.out.println("after calling: " + method); return null; &#125;&#125;1234567891011121314151617181920212223public class Client &#123; public static void main(String[] args) &#123; RealSubject rs = new RealSubject(); InvocationHandler ds = new DynamicSubject(rs); Class&lt;? extends RealSubject&gt; aClass = rs.getClass(); Subject subject = (Subject)Proxy.newProxyInstance( aClass.getClassLoader(), aClass.getInterfaces(), ds); subject.request(); System.out.println(subject.getClass()); System.out.println(subject.getClass().getSuperclass()); System.out.println(subject.getClass().getSuperclass().getSuperclass()); System.out.println(Arrays.toString(subject.getClass().getInterfaces())); &#125;&#125;/* before calling: public abstract void two.jvm.bytecodes.Subject.request() request is called after calling: public abstract void two.jvm.bytecodes.Subject.request() class com.sun.proxy.$Proxy0 class java.lang.reflect.Proxy class java.lang.Object [interface two.jvm.bytecodes.Subject]*/从上面的输我们可以看到subject的类型是运行期动态生成的字节码对象。返回字节码对象的方法是Client的第7行，所以我们进入此方法。1234567891011121314151617public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; Objects.requireNonNull(h); final Class&lt;?&gt;[] intfs = interfaces.clone(); final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. */ // ...&#125;在此方法中，我们会发现，获得生成Class对象的是滴14行。12345678910111213private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; // 限制接口数量不能多于65535，因为在字节码中使用两个字节表示接口数量 if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException("interface limit exceeded"); &#125; // If the proxy class defined by the given loader implementing // the given interfaces exists, this will simply return the cached copy; // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces);&#125;进入WeakCache.get()方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public V get(K key, P parameter) &#123; Objects.requireNonNull(parameter); expungeStaleEntries(); Object cacheKey = CacheKey.valueOf(key, refQueue); // lazily install the 2nd level valuesMap for the particular cacheKey ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey); if (valuesMap == null) &#123; ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap&lt;&gt;()); if (oldValuesMap != null) &#123; valuesMap = oldValuesMap; &#125; &#125; // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that // subKey from valuesMap Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); Supplier&lt;V&gt; supplier = valuesMap.get(subKey); Factory factory = null; while (true) &#123; if (supplier != null) &#123; // supplier might be a Factory or a CacheValue&lt;V&gt; instance V value = supplier.get(); if (value != null) &#123; return value; &#125; &#125; // else no supplier in cache // or a supplier that returned null (could be a cleared CacheValue // or a Factory that wasn't successful in installing the CacheValue) // lazily construct a Factory if (factory == null) &#123; factory = new Factory(key, parameter, subKey, valuesMap); &#125; if (supplier == null) &#123; supplier = valuesMap.putIfAbsent(subKey, factory); if (supplier == null) &#123; // successfully installed Factory supplier = factory; &#125; // else retry with winning supplier &#125; else &#123; if (valuesMap.replace(subKey, supplier, factory)) &#123; // successfully replaced // cleared CacheEntry / unsuccessful Factory // with our Factory supplier = factory; &#125; else &#123; // retry with current supplier supplier = valuesMap.get(subKey); &#125; &#125; &#125;&#125;在这个方法中，我们可以发现最终返回value的是第30行。但value的值是通过函数式接口Supplier获得的，而supplier的赋值是在第46行完成的而factory对象是在第39行被构建的。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private final BiFunction&lt;K, P, V&gt; valueFactory;public WeakCache(BiFunction&lt;K, P, ?&gt; subKeyFactory, BiFunction&lt;K, P, V&gt; valueFactory) &#123; this.subKeyFactory = Objects.requireNonNull(subKeyFactory); this.valueFactory = Objects.requireNonNull(valueFactory);&#125;// Factory是WeakCache的一个内部类private final class Factory implements Supplier&lt;V&gt; &#123; private final K key; private final P parameter; private final Object subKey; private final ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap; Factory(K key, P parameter, Object subKey, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) &#123; this.key = key; this.parameter = parameter; this.subKey = subKey; this.valuesMap = valuesMap; &#125; @Override public synchronized V get() &#123; // serialize access // re-check Supplier&lt;V&gt; supplier = valuesMap.get(subKey); if (supplier != this) &#123; // something changed while we were waiting: // might be that we were replaced by a CacheValue // or were removed because of failure -&gt; // return null to signal WeakCache.get() to retry // the loop return null; &#125; // else still us (supplier == this) // create new value V value = null; try &#123; value = Objects.requireNonNull(valueFactory.apply(key, parameter)); &#125; finally &#123; if (value == null) &#123; // remove us on failure valuesMap.remove(subKey, this); &#125; &#125; // the only path to reach here is with non-null value assert value != null; // wrap value with CacheValue (WeakReference) CacheValue&lt;V&gt; cacheValue = new CacheValue&lt;&gt;(value); // put into reverseMap reverseMap.put(cacheValue, Boolean.TRUE); // try replacing us with CacheValue (this should always succeed) if (!valuesMap.replace(subKey, this, cacheValue)) &#123; throw new AssertionError("Should not reach here"); &#125; // successfully replaced us with new CacheValue -&gt; return the value // wrapped by it return value; &#125;&#125;而Factory是Supplier的一个实现类，对于Factory的key和parameter，我们传入的是ClassLoader loader和Class&lt;?&gt;... interfaces。在get()方法中给value赋值的是第33行的apply()方法，而valueFactory是一个函数式接口BiFunction，此接口传入两个参数，获得一个结果。现在我们传入的就是loader和interfaces，而apply的具体实现是在构建WeakCache传入的。所以我们再回到Proxy类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());/** * A factory function that generates, defines and returns the proxy class given * the ClassLoader and array of interfaces. */private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; &#123; // prefix for all proxy class names private static final String proxyClassNamePrefix = "$Proxy"; // next number to use for generation of unique proxy class names private static final AtomicLong nextUniqueNumber = new AtomicLong(); @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); for (Class&lt;?&gt; intf : interfaces) &#123; /* * Verify that the class loader resolves the name of this * interface to the same Class object. */ Class&lt;?&gt; interfaceClass = null; try &#123; interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + " is not visible from class loader"); &#125; /* * Verify that the Class object actually represents an * interface. */ if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + " is not an interface"); &#125; /* * Verify that this interface is not a duplicate. */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( "repeated interface: " + interfaceClass.getName()); &#125; &#125; String proxyPkg = null; // package to define proxy class in int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? "" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( "non-public interfaces from different packages"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // if no non-public proxy interfaces, use com.sun.proxy package proxyPkg = ReflectUtil.PROXY_PACKAGE + "."; &#125; /* * Choose a name for the proxy class to generate. */ long num = nextUniqueNumber.getAndIncrement(); String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125;&#125;再第90行是真正的生成字节码对象的字节数组的地方。123456789101112131415161718192021222324252627private static final boolean saveGeneratedFiles = (Boolean)AccessController.doPrivileged(new GetBooleanAction("sun.misc.ProxyGenerator.saveGeneratedFiles"));public static byte[] generateProxyClass(final String var0, Class&lt;?&gt;[] var1, int var2) &#123; ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2); final byte[] var4 = var3.generateClassFile(); if (saveGeneratedFiles) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; try &#123; int var1 = var0.lastIndexOf(46); Path var2; if (var1 &gt; 0) &#123; Path var3 = Paths.get(var0.substring(0, var1).replace('.', File.separatorChar)); Files.createDirectories(var3); var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + ".class"); &#125; else &#123; var2 = Paths.get(var0 + ".class"); &#125; Files.write(var2, var4, new OpenOption[0]); return null; &#125; catch (IOException var4x) &#123; throw new InternalError("I/O exception saving generated file: " + var4x); &#125; &#125; &#125;); &#125; return var4;&#125;可以看见在第6行有个开关，这个开关为true会将字节数组写入文件中。所以我们Client的main方法中加入：1System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");这样在根目录的com/sun/proxy文件下就会生成一个class文件，在IDEA中双击点开：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public final class $Proxy0 extends Proxy implements Subject &#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; public $Proxy0(InvocationHandler var1) throws &#123; super(var1); &#125; public final boolean equals(Object var1) throws &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; public final String toString() throws &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final void request() throws &#123; try &#123; super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; public final int hashCode() throws &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; static &#123; try &#123; m1 = Class.forName("java.lang.Object").getMethod("equals", Class.forName("java.lang.Object")); m2 = Class.forName("java.lang.Object").getMethod("toString"); m3 = Class.forName("two.jvm.bytecodes.Subject").getMethod("request"); m0 = Class.forName("java.lang.Object").getMethod("hashCode"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125;我们会发现这个类继承了Proxy类，实现了Subject。然后从第33行便可以发现代理对象的request执行的便是InvocationHandler的invoke方法。传入的方法是two.jvm.bytecodes.Subject类中的request方法，也就是最终执行到了DynamicSubject中的invoke方法：123456public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("before calling: "+ method); method.invoke(this.object, args); System.out.println("after calling: " + method); return null;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.02-JavaSE-基础-2]]></title>
    <url>%2Fposts%2F17734.html%2F</url>
    <content type="text"><![CDATA[内部类成员内部类成员内部类是最普通的内部类，它的定义为位于另一个类的内部，形如下面的形式：1234567891011class Circle &#123; double radius = 0; public Circle(double radius) &#123; this.radius = radius; &#125; class Draw &#123; // 内部类 public void drawSahpe() &#123; System.out.println("drawshape"); &#125; &#125;&#125;这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。12345678910111213141516171819202122public class Outer &#123; private double radius = 0; private int test = 1; public static int count =1; public Outer(double radius) &#123; this.radius = radius; &#125; class Draw &#123; // 内部类 private int test = 2; public void drawSahpe() &#123; System.out.println(radius); // 外部类的private成员 System.out.println(count); // 外部类的静态成员 System.out.println(Outer.this.test); &#125; &#125; public static void main(String[] args) &#123; Draw draw = new Outer(20).new Draw(); draw.drawSahpe(); &#125;&#125;不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：12外部类.this.成员变量外部类.this.成员方法虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：12345678910111213141516class Circle &#123; private double radius = 0; public Circle(double radius) &#123; this.radius = radius; getDrawInstance().drawSahpe(); // 必须先创建成员内部类的对象，再进行访问 &#125; private Draw getDrawInstance() &#123; return new Draw(); &#125; class Draw &#123; // 内部类 public void drawSahpe() &#123; System.out.println(radius); // 外部类的private成员 &#125; &#125;&#125;成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：12345678910111213141516171819202122232425public class Test &#123; public static void main(String[] args) &#123; // 第一种方式： Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); // 必须通过Outter对象来创建 // 第二种方式： Outter.Inner inner1 = outter.getInnerInstance(); &#125;&#125; class Outter &#123; private Inner inner = null; public Outter() &#123; &#125; public Inner getInnerInstance() &#123; if(inner == null) inner = new Inner(); return inner; &#125; class Inner &#123; public Inner() &#123; &#125; &#125;&#125;内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。如上面的例子：private：则只能在外部类的内部访问；public：则任何地方都能访问；protected：只能在同一个包下或者继承外部类的情况下访问；默认访问权限：则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。局部内部类局部内部类是定义在一个方法或者一个作用域里面的类，它和成员内部类的区别在于局部内部类的访问仅限于方法内或者该作用域内。12345678910111213class People&#123; public People() &#123; &#125;&#125; class Man&#123; public Man()&#123; &#125; public People getWoman()&#123; class Woman extends People&#123; // 局部内部类 int age =0; &#125; return new Woman(); &#125;&#125;匿名内部类匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。匿名内部类的语法：123new ClassName()&#123; // 匿名内部类的body&#125;下面这段代码是一段线程代码：123456789101112public static void main(String[] args) &#123; System.out.println(Thread.currentThread()); new Thread("匿名内部类")&#123; &#123; System.out.println("匿名内部类的body"); &#125; @Override public void run() &#123; System.out.println(this); &#125; &#125;.start();&#125;匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$数字.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。但是匿名内部类也是可以书写其他方法的，因为本质上他就是继承或实现。静态内部类静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。1234567891011121314public class Test &#123; public static void main(String[] args) &#123; // 静态内部类是不依赖于外部类的，也就说可以在不创建外部类对象的情况下创建内部类的对象。 Outter.Inner inner = new Outter.Inner(); &#125;&#125; class Outter &#123; public Outter() &#123; &#125; static class Inner &#123; public Inner() &#123; &#125; &#125;&#125;枚举和switch123456789public class Test &#123; public static void main(String[] args) &#123; System.out.println(TestEnum.FRI.getClass()); // class TestEnum System.out.println(TestEnum.FRI); // FRI &#125;&#125;enum TestEnum &#123; MON, TUE, WED, THU, FRI, SAT, SUN;&#125;switch中可以跟的类型有byte、short、char、int、String、枚举。没有long。123456789101112131415161718192021String str = "200";switch (str) &#123; default: // default 只能定义一次 System.out.println(100); case "100": System.out.println(1000); case "1000": System.out.println(1000);&#125;//str = 200;//输出：// 100// 1000// 1000//因为不能匹配100或1000，所以从defalut口进入。////str = 100;//输出：// 1000// 1000//因为可以匹配100，从第二个口进入。随机数和round1234567// 获得随机数：greater than or equal to 0.0 and less than 1.0double iRandom = Math.random();System.out.println(iRandom);// 获得区间在[0, n)之间的随机整数Random random2 = new Random();int nextInt = random2.nextInt(10);System.out.println(nextInt);123456// 负数：加0.5之后向小的取整System.out.println(Math.round(-11.6));System.out.println(Math.round(-11.5));// 正数：加0.5之后向大的取整System.out.println(Math.round(11.6));System.out.println(Math.round(11.5));String、StringBuilder &amp; StringBuffer可变性简单的来说：String类中使用final关键字修饰字符数组来保存字符串，private final char value[]，所以String对象是不可变的。而StringBuilder与StringBuffer都继承自AbstractStringBuilder类，在 AbstractStringBuilder中也是使用字符数组保存字符串char[]value 但是没有用final关键字修饰，所以这两种对象都是可变的。StringBuilder与StringBuffer的构造方法都是调用父类构造方法也就是AbstractStringBuilder实现的。AbstractStringBuilder.java123456789abstract class AbstractStringBuilder implements Appendable, CharSequence &#123; char[] value; int count; AbstractStringBuilder() &#123; &#125; AbstractStringBuilder(int capacity) &#123; value = new char[capacity]; &#125;&#125;线程安全性String中的对象是不可变的，也就可以理解为常量，线程安全。AbstractStringBuilder是StringBuilder与StringBuffer的公共父类，定义了一些字符串的基本操作，如expandCapacity、append、insert、indexOf等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。StringBuilder并没有对方法进行加同步锁，所以是非线程安全的。性能每次对String类型进行改变的时候，都会生成一个新的String对象，然后将指针指向新的String对象。StringBuffer每次都会对StringBuffer对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用StringBuilder相比使用StringBuffer仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。对于三者使用的总结：操作少量的数据: 适用String单线程操作字符串缓冲区下操作大量数据: 适用StringBuilder多线程操作字符串缓冲区下操作大量数据: 适用StringBufferJava中字符串相加，编译的时候会创建StringBuilder类，然后利用StringBuilder的append()方法相加。所以不能在循环里使用+，需要在循环外面使用创建StringBuilder的对象，在循环内进行append()操作。日期类LocalDate12345678910111213141516171819// 当前日期LocalDate today = LocalDate.now();System.out.println("Current Date=" + today);// 根据年、月、日创建日期LocalDate firstDay_2014 = LocalDate.of(2014, Month.JANUARY, 1);System.out.println("Specific Date=" + firstDay_2014);// 不合法的参数会报 java.time.DateTimeException// LocalDate feb29_2014 = LocalDate.of(2014, Month.FEBRUARY, 29);// Current date in "Asia/Kolkata", you can get it from ZoneId javadocLocalDate todayKolkata = LocalDate.now(ZoneId.of("Asia/Kolkata"));System.out.println("Current Date in IST=" + todayKolkata);// java.time.zone.ZoneRulesException: Unknown time-zone ID: IST// LocalDate todayIST = LocalDate.now(ZoneId.of("IST"));// Getting date from the base date: 01/01/1970LocalDate dateFromBase = LocalDate.ofEpochDay(365);System.out.println("365th day from base date= " + dateFromBase);// 得到某年的多少天LocalDate hundredDay2014 = LocalDate.ofYearDay(2014, 100);System.out.println("100th day of 2014=" + hundredDay2014);LocalTime123456789101112131415161718// Current TimeLocalTime time = LocalTime.now();System.out.println("Current Time = " + time);// Creating LocalTime by providing input argumentsLocalTime specificTime = LocalTime.of(12, 20, 25, 40);System.out.println("Specific Time of Day = " + specificTime);// Try creating time by providing invalid inputs// LocalTime invalidTime = LocalTime.of(25,20);// Exception in thread "main" java.time.DateTimeException:// Invalid value for HourOfDay (valid values 0 - 23): 25// Current date in "Asia/Kolkata", you can get it from ZoneId javadocLocalTime timeKolkata = LocalTime.now(ZoneId.of("Asia/Kolkata"));System.out.println("Current Time in IST = " + timeKolkata);// java.time.zone.ZoneRulesException: Unknown time-zone ID: IST// LocalTime todayIST = LocalTime.now(ZoneId.of("IST"));// Getting time from the base date: 00:00:00LocalTime specificSecondTime = LocalTime.ofSecondOfDay(10000);System.out.println("10000th second time = " + specificSecondTime);LocalDateTime123456789101112131415161718192021// Current DateLocalDateTime today = LocalDateTime.now();System.out.println("Current DateTime1 = " + today);// Current Date using LocalDate and LocalTimetoday = LocalDateTime.of(LocalDate.now(), LocalTime.now());System.out.println("Current DateTime2 = " + today);// Creating LocalDateTime by providing input argumentsLocalDateTime specificDate = LocalDateTime.of(2014, Month.JANUARY, 1, 10, 10, 30);System.out.println("Specific Date = " + specificDate);// Try creating date by providing invalid inputs// LocalDateTime feb29_2014 = LocalDateTime.of(2014, Month.FEBRUARY, 28, 25, 1, 1);// Exception in thread "main" java.time.DateTimeException:// Invalid value for HourOfDay (valid values 0 - 23): 25// Current date in "Asia/Kolkata", you can get it from ZoneId javadocLocalDateTime todayKolkata = LocalDateTime.now(ZoneId.of("Asia/Kolkata"));System.out.println("Current Date in IST = " + todayKolkata);// java.time.zone.ZoneRulesException: Unknown time-zone ID: IST// LocalDateTime todayIST = LocalDateTime.now(ZoneId.of("IST"));// Getting date from the base date: 01/01/1970LocalDateTime dateFromBase = LocalDateTime.ofEpochSecond(10000, 0, ZoneOffset.UTC);System.out.println("10000th second time from 01/01/1970= " + dateFromBase);Instant123456// Current timestampInstant timestamp = Instant.now();System.out.println("Current Timestamp = " + timestamp);// 转换为 milliseconds from 01/01/1970long epochMilli = timestamp.toEpochMilli();System.out.println(epochMilli);Date &amp; SimpleDateFormat123SimpleDateFormat oldFormatter = new SimpleDateFormat("yyyy/MM/dd");Date date1 = new Date();System.out.println(oldFormatter.format(date1));相互转换12345678910111213141516171819202122Date now = new Date();LocalDateTime localDateTime = now.toInstant().atZone(ZoneId.systemDefault()).toLocalDateTime();LocalTime localTime = now.toInstant().atZone(ZoneId.systemDefault()).toLocalTime();LocalDate localDate = now.toInstant().atZone(ZoneId.systemDefault()).toLocalDate();System.out.println(localDateTime);System.out.println(localTime);System.out.println(localDate);// LocalTime 和 LocalDate 没有atZone方法Date oldLocalDateTime = Date.from(localDateTime.atZone(ZoneId.systemDefault()).toInstant());System.out.println(oldLocalDateTime);long millis = localDateTime.atZone(ZoneId.systemDefault()).toInstant().toEpochMilli();long time = now.getTime();System.out.println(millis);System.out.println(time);LocalDateTime parseLocalDateTime = Instant.ofEpochMilli(millis).atZone(ZoneId.systemDefault()).toLocalDateTime();LocalDate parseLocalDate = Instant.ofEpochMilli(millis).atZone(ZoneId.systemDefault()).toLocalDate();System.out.println(parseLocalDateTime);System.out.println(parseLocalDate);获取年月日时钟秒1234567LocalDateTime dt = LocalDateTime.now();System.out.println(dt.getYear());System.out.println(dt.getMonthValue()); // 1 - 12System.out.println(dt.getDayOfMonth());System.out.println(dt.getHour());System.out.println(dt.getMinute());System.out.println(dt.getSecond());获得某月第一天/最后一天1234567LocalDate today = LocalDate.now();//本月的第一天LocalDate firstday = LocalDate.of(today.getYear(), today.getMonth(), 1);//本月的最后一天LocalDate lastDay =today.with(TemporalAdjusters.lastDayOfMonth());System.out.println("本月的第一天 " + firstday);System.out.println("本月的最后一天 " + lastDay);格式化日期1234567891011121314DateTimeFormatter dtf1 = DateTimeFormatter.ofPattern("yyyy/MM/dd HH:mm:ss");DateTimeFormatter dtf2 = DateTimeFormatter.ofPattern("yyyy/MM/dd");LocalDateTime ldt = LocalDateTime.now();LocalDate ld = LocalDate.now();System.out.println(ldt);System.out.println(ld);String format1 = ldt.format(dtf1); // 日期格式化为字符串String format2 = ld.format(dtf2); // 日期格式化为字符串System.out.println(format1);System.out.println(format2);LocalDateTime parse1 = LocalDateTime.parse(format1, dtf1); LocalDate parse2 = LocalDate.parse(format2, dtf2);System.out.println(parse1); // 字符串转化为日期System.out.println(parse2); // 字符串转化为日期BigInteger&amp;BigDecimalBigInteger理论上可以表示无限大的数字。常用方法：12345678910111213141516171819202122232425BigInteger abs() 返回大整数的绝对值BigInteger add(BigInteger val) 返回两个大整数的和BigInteger and(BigInteger val) 返回两个大整数的按位与的结果BigInteger andNot(BigInteger val) 返回两个大整数与非的结果BigInteger divide(BigInteger val) 返回两个大整数的商double doubleValue() 返回大整数的double类型的值float floatValue() 返回大整数的float类型的值BigInteger gcd(BigInteger val) 返回大整数的最大公约数int intValue() 返回大整数的整型值long longValue() 返回大整数的long型值BigInteger max(BigInteger val) 返回两个大整数的最大者BigInteger min(BigInteger val) 返回两个大整数的最小者BigInteger mod(BigInteger val) 用当前大整数对val求模BigInteger multiply(BigInteger val) 返回两个大整数的积BigInteger negate() 返回当前大整数的相反数BigInteger not() 返回当前大整数的非BigInteger or(BigInteger val) 返回两个大整数的按位或BigInteger pow(int exponent) 返回当前大整数的exponent次方BigInteger remainder(BigInteger val) 返回当前大整数除以val的余数BigInteger leftShift(int n) 将当前大整数左移n位后返回BigInteger rightShift(int n) 将当前大整数右移n位后返回BigInteger subtract(BigInteger val)返回两个大整数相减的结果byte[] toByteArray(BigInteger val)将大整数转换成二进制反码保存在byte数组中String toString() 将当前大整数转换成十进制的字符串形式BigInteger xor(BigInteger val) 返回两个大整数的异或BigDecimal浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals 来判断。具体原理和浮点数的编码方式有关。12345float a = 1.0f - 0.9f;float b = 0.9f - 0.8f;System.out.println(a);// 0.100000024System.out.println(b);// 0.099999964System.out.println(a == b);// false具有基本数学知识的我们很清楚的知道输出并不是我们想要的结果（精度丢失），我们如何解决这个问题呢？一种很常用的方法是：使用使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。123456BigDecimal a = new BigDecimal("1.0");BigDecimal b = new BigDecimal("0.9");BigDecimal c = new BigDecimal("0.8");BigDecimal x = a.subtract(b);// 0.1BigDecimal y = b.subtract(c);// 0.1System.out.println(x.equals(y));// trueAPI12345678910111213BigDecimal(int) 创建一个具有参数所指定整数值的对象。 BigDecimal(double) 创建一个具有参数所指定双精度值的对象。 BigDecimal(long) 创建一个具有参数所指定长整数值的对象。 BigDecimal(String) 创建一个具有参数所指定以字符串表示的数值的对象。add(BigDecimal) BigDecimal对象中的值相加，然后返回这个对象。subtract(BigDecimal) BigDecimal对象中的值相减，然后返回这个对象。multiply(BigDecimal) BigDecimal对象中的值相乘，然后返回这个对象。divide(BigDecimal) BigDecimal对象中的值相除，然后返回这个对象。toString() 将BigDecimal对象的数值转换成字符串。 doubleValue() 将BigDecimal对象中的值以双精度数返回。 floatValue() 将BigDecimal对象中的值以单精度数返回。 longValue() 将BigDecimal对象中的值以长整数返回。 intValue() 将BigDecimal对象中的值以整数返回。我们在使用BigDecimal时，为了防止精度丢失，推荐使用它的 BigDecimal(String) 构造方法来创建对象。123456789BigDecimal a = new BigDecimal(1.01);BigDecimal b = new BigDecimal(1.02);BigDecimal c = new BigDecimal("1.01");BigDecimal d = new BigDecimal("1.02");System.out.println(a.add(b));System.out.println(c.add(d));输出：2.03000000000000002664535259100375697016716003417968752.03整型包装类值的比较所有整形包装类对象值得比较必须使用equals方法。1234567Integer x = 3;Integer y = 3;System.out.println(x == y);// trueInteger a = new Integer(3);Integer b = new Integer(3);System.out.println(a == b);//falseSystem.out.println(a.equals(b));//false序列化把变量从内存中变成可存储或传输的过程称之为序列化，把字节序列恢复为Java对象的过程称为对象的反序列化。对象的序列化主要有两种用途：把对象的字节序列永久的保存到硬盘上，通常存放在一个文件中。在网络上传送对象的字节序列。默认序列化1234567891011121314151617181920212223242526272829303132333435363738public class Server &#123; public static void main(String[] args) throws Exception &#123; Path path = Paths.get("test"); Person temp = new Person("陈钰琪", 19, "411x2x19xx1x2x6x1x", 20000d); ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path.toFile())); out.writeObject(temp); ObjectInputStream in = new ObjectInputStream(new FileInputStream(path.toFile())); Person readObject = (Person)in.readObject(); System.out.println(readObject); &#125;&#125;class Person implements Serializable&#123; private static final long serialVersionUID = -485348963313276072L; private String name; private Integer age; private String id; private Double money; public Person(String name, Integer age, String id, Double money) &#123; this.name = name; this.age = age; this.id = id; this.money = money; &#125; // getter和setter @Override public String toString() &#123; return "Person [name=" + name + ", age=" + age + ", id=" + id + ", money=" + money + "]"; &#125;&#125;版本号版本号是为了控制对象的版本而存在的，版本号一致才可认为可以进行对应的序列化和反序列化。比如我们使用上面的代码把一个Person写入temp文件了，然后修改serialVersionUID = 485348963313276072L;，会发现爆出java.io.InvalidClassException。单例的处理1234567891011121314public final class MySingleton implements Serializable&#123; private static final long serialVersionUID = 1L; private MySingleton() &#123; &#125; private static final MySingleton INSTANCE = new MySingleton(); public static MySingleton getInstance() &#123; return INSTANCE; &#125; private Object readResolve() throws ObjectStreamException &#123; // instead of the object we're on, return the class variable INSTANCE return INSTANCE; &#125;&#125;反序列化”组装”一个新对象时，就会自动调用这个readResolve方法来返回我们指定好的对象了，单例规则也就得到了保证。序列化与类加载器1234567891011121314151617181920protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException &#123; String name = desc.getName(); try &#123; return Class.forName(name, false, latestUserDefinedLoader();()); &#125; catch (ClassNotFoundException ex) &#123; Class&lt;?&gt; cl = primClasses.get(name); if (cl != null) &#123; return cl; &#125; else &#123; throw ex; &#125; &#125;&#125;/**latestUserDefinedLoader();Returns first non-privileged class loader on the stack (excluding reflection generated frames) or the extension class loader if only class loaded by the boot class loader and extension class loader are found on the stack. This method is also called via reflection by the following RMI-IIOP class: com.sun.corba.se.internal.util.JDKClassLoader This method should not be removed or its signature changed without corresponding modifications to the above class.返回堆栈上的第一个非特权类加载器（不包括反射生成的帧）或扩展类加载器（如果堆栈上只找到引导类加载器和扩展类加载器加载的类）。此方法也由以下RMI-IIOP类通过反射调用：com.sun.corba.se.internal.util.JDKClassLoader在没有对上述类进行相应修改的情况下，不应删除此方法或更改其签名。**/默认序列化的时候采用的是一个XXX类加载器。这个类加载器是笔者并不知道是什么。不过可以确定它使用的不是当前类的加载器（本人踩过坑）。如果需要采用自定义的类加载器，比如当前类的类加载器，可以继承ObjectInputStream来覆盖resolveClass(ObjectStreamClass desc)方法。123456789101112131415public class CurrentThreadLoaderObjectInputStream extends ObjectInputStream &#123; public CurrentThreadLoaderObjectInputStream(InputStream in) throws IOException &#123; super(in); &#125; protected CurrentThreadLoaderObjectInputStream() throws IOException, SecurityException &#123; &#125; // 覆盖原有的加载类的机制，从当前线程的loader进行加载 @Override protected Class&lt;?&gt; resolveClass(ObjectStreamClass desc) throws IOException, ClassNotFoundException &#123; String name = desc.getName(); return Thread.currentThread().getContextClassLoader().loadClass(name); &#125;&#125;反射通常能够分析类能力的程序称为反射（reflective）。程序员通过反射库（包括Class类，Constructor类等）完成业务功能，便是使用到了反射技术。反射的主要功能是在程序运行时分析类。运用反射技术来实现功能一般分为四步：获得Class对象、获得构造器、获得类的实例、运行。反射技术甚至可以获得私有信息。获得Class对象Class对象是在类加载时由Java虚拟机创建的封装某类型信息的对象。有三种获得方式：123456789101112131415public class TestClazz &#123; @SuppressWarnings("rawtypes") public static void main(String[] args) throws ClassNotFoundException &#123; // 1、通过Object类的getClass()方法 TestClazz tc = new TestClazz(); Class clazz1 = tc.getClass(); // 2、通过类的静态class属性。 Class clazz2 = TestClazz.class; // 3、通过Class类中的方法构造。这种可拓展性更强，根本不需要知道类型，通过字符串就能获得。 // 但是也正是这个原因，可能发生ClassNotFoundException（main函数的此异常与前两者无关） Class clazz3 = Class.forName("com.first.TestClazz"); &#125;&#125;获得构造器获得所有公共权限的构造方法（包括继承的）：clazz.getConstructors();1234567891011121314151617public class TestClazz &#123; public TestClazz(String msg) &#123; System.out.println(msg); &#125; public TestClazz() &#123; &#125; private TestClazz(int i) &#123; System.out.println(i); &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Constructor[] constructors = clazz.getConstructors(); for(Constructor e:constructors) System.out.println(e); /*Console： public com.first.TestClazz(java.lang.String) public com.first.TestClazz() */ &#125;&#125;获得指定参数的公共构造器（可以获得继承的）：clazz.getConstructor(Class... parameterTypes);123456789101112131415161718public class TestClazz &#123; public TestClazz(String msg) &#123; System.out.println(msg); &#125; public TestClazz() &#123; &#125; private TestClazz(int i) &#123; System.out.println(i); &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Constructor con1 = clazz.getConstructor(); Constructor con2 = clazz.getConstructor(String.class); System.out.println(con1); System.out.println(con2); /*Console: public com.first.TestClazz() public com.first.TestClazz(java.lang.String) */ &#125;&#125;获得所有的构造器（不包括继承的）：clazz.getDeclaredConstructors();1234567891011121314151617public class TestClazz &#123; private TestClazz(int i) &#123; System.out.println(i); &#125; public TestClazz(String msg) &#123; System.out.println(msg); &#125; public TestClazz() &#123; &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Constructor []cons = clazz.getDeclaredConstructors(); for(Constructor e : cons) System.out.println(e); /*Console: public com.first.TestClazz() public com.first.TestClazz(java.lang.String) private com.first.TestClazz(int) */ &#125;&#125;获得指定的构造器（不包括继承的）：clazz.getDeclaredConstructor((Class... parameterTypes);123456789101112131415public class TestClazz &#123; private TestClazz(int i) &#123; System.out.println(i); &#125; public TestClazz(String msg) &#123; System.out.println(msg); &#125; public TestClazz() &#123; &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Constructor con = clazz.getDeclaredConstructor(int.class); System.out.println(con); /*Console: private com.first.TestClazz(int) */ &#125;&#125;创建对象通过公共构造器创建对象：constructor.newInstance(Class... parameterTypes)方法。传入的参数类型和构造器的参数类型一致。1234567891011121314151617181920212223public class TestClazz &#123; private TestClazz(int i) &#123; System.out.println(i); &#125; public TestClazz(String msg) &#123; System.out.println(msg); &#125; public TestClazz() &#123; &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Constructor con1 = clazz.getConstructor(String.class); Object obj1 = con1.newInstance("HelloWorld!"); System.out.println(obj1); System.out.println("-----------------------"); Constructor con2 = clazz.getConstructor(); Object obj2 = con2.newInstance(); System.out.println(obj2); /*Console: HelloWorld! com.first.TestClazz@7852e922 ----------------------- com.first.TestClazz@4e25154f */ &#125;&#125;通过当前类不可访问的构造器创建对象：constructor.setAccessible(true);123456789101112131415161718public class TestClazz &#123; private TestClazz(int i) &#123; System.out.println(i); &#125; public TestClazz(String msg) &#123; System.out.println(msg); &#125; TestClazz() &#123; &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Constructor constructor = clazz.getDeclaredConstructor(int.class); //在本例中不写这句也能执行，因为被反射的类和当前类是同一个类，private的构造方法是可以被访问的 //如果某个构造器是当前类不可访问的，此方法可以使其变成可访问的类型 constructor.setAccessible(true); Object object = constructor.newInstance(1); System.out.println(object); /*Console: 1 com.first.TestClazz@7852e922 */ &#125;&#125;快速获得对象如果被反射的类有被当前类可访问的无参构造函数，可以直接使用clazz.newInstance();123456789101112131415public class TestClazz &#123; private TestClazz(int i) &#123; System.out.println(i); &#125; public TestClazz(String msg) &#123; System.out.println(msg); &#125; TestClazz() &#123; &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Object object = clazz.newInstance(); System.out.println(object); /*Console: com.first.TestClazz@7852e922 */ &#125;&#125;获得成员变量获得所有公共类型的属性（包括继承的）：clazz.getFields();12345678910111213public class TestClazz &#123; public String msg; private int i; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Field[] fields = clazz.getFields(); for(Field f : fields) System.out.println(f); /*Console: public java.lang.String com.first.TestClazz.msg */ &#125;&#125;获得指定公共类型的属性（包括继承的）：clazz.getField(String name);123456789101112public class TestClazz &#123; public String msg; private int i; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Field field = clazz.getField("msg"); System.out.println(field); /*Console: public java.lang.String com.first.TestClazz.msg */ &#125;&#125;获得所有的属性（不包括继承的）：clazz.getDeclaredFields();1234567891011121314public class TestClazz &#123; public String msg; private int i; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Field []fields = clazz.getDeclaredFields(); for(Field f : fields) System.out.println(f); /*Console: public java.lang.String com.first.TestClazz.msg private int com.first.TestClazz.i */ &#125;&#125;获得指定的属性（不包括继承的）：clazz.getDeclaredField(String name);123456789101112public class TestClazz &#123; public String msg; private int i; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Field field = clazz.getDeclaredField("i"); System.out.println(field); /*Console: private int com.first.TestClazz.i */ &#125;&#125;设置成员变量的值设置可访问的变量的值：field.set(Object obj, Object value);12345678910111213141516public class TestClazz &#123; public String msg; private int i; TestClazz() &#123; &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); TestClazz object = (TestClazz)clazz.newInstance(); Field field = clazz.getDeclaredField("msg"); field.set(object, "HelloWorld!"); System.out.println(object.msg); /*Console: HelloWorld! */ &#125;&#125;设置不可访问的变量的值：field.setAccessible(true);12345678910111213141516171819public class TestClazz &#123; public String msg; private int i; TestClazz() &#123; &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); TestClazz object = (TestClazz)clazz.newInstance(); Field field = clazz.getDeclaredField("i"); // 在本例中不写这句也能执行，因为被反射的类和当前类是同一个类，private的属性是可以被访问的 // 如果某个属性是当前类不可访问的，此方法可以使其变成可访问的类型 field.setAccessible(true); field.set(object, 65535); System.out.println(object.i); /*Console: 65535 */ &#125;&#125;获得成员方法获得所有公共的方法（包括继承的和构造器）：clazz.getMethods();1234567891011121314151617181920212223public class TestClazz &#123; private int getI() &#123; return i; &#125; TestClazz() &#123; &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Method[] methods = clazz.getMethods(); for(Method m : methods) System.out.println(m); /*Console: public static void com.first.TestClazz.main(java.lang.String[]) throws java.lang.Exception public final void java.lang.Object.wait() throws java.lang.InterruptedException public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException public boolean java.lang.Object.equals(java.lang.Object) public java.lang.String java.lang.Object.toString() public native int java.lang.Object.hashCode() public final native java.lang.Class java.lang.Object.getClass() public final native void java.lang.Object.notify() public final native void java.lang.Object.notifyAll() */ &#125;&#125;获得指定的公共方法（包括继承的，不包括构造器）：clazz.getMethod(String name, Class&lt;?&gt;... parameterTypes);12345678910111213public class TestClazz&#123; public void show(String msg) &#123; System.out.println(msg); &#125; TestClazz() &#123; &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Method m = clazz.getMethod("show", String.class); System.out.println(m); /*Console: public void com.first.TestClazz.show(java.lang.String) */ &#125;&#125;获得所有的方法（不包括继承的，不包括构造器）：clazz.getDeclaredMethods();123456789101112131415public class TestClazz&#123; private int getI() &#123; return i; &#125; TestClazz() &#123; &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Method[] methods = clazz.getDeclaredMethods(); for(Method m : methods) System.out.println(m); /*Console: public static void com.first.TestClazz.main(java.lang.String[]) throws java.lang.Exception private int com.first.TestClazz.getI() */ &#125;&#125;获得指定的方法（不包括继承的，不包括构造器）：clazz.getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes);12345678910111213public class TestClazz&#123; private void show(String msg) &#123; System.out.println(msg); &#125; TestClazz() &#123; &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Method m = clazz.getDeclaredMethod("show", String.class); System.out.println(m); /*Console: public void com.first.TestClazz.show(java.lang.String) */ &#125;&#125;执行方法执行公共方法：method.invoke(Object obj, Object... args);12345678910111213public class TestClazz&#123; public void show(String msg) &#123; System.out.println(msg); &#125; TestClazz() &#123; &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Object object = clazz.newInstance(); Method m = clazz.getDeclaredMethod("show", String.class); m.invoke(object, "HelloWorld!"); /*Console: HelloWorld */ &#125;&#125;执行私有方法：method.invoke(Object obj, Object... args);1234567891011121314public class TestClazz&#123; private void show(String msg) &#123; System.out.println(msg); &#125; TestClazz() &#123; &#125; @SuppressWarnings("rawtypes") public static void main(String[] args) throws Exception &#123; Class clazz = Class.forName("com.first.TestClazz"); Object object = clazz.newInstance(); Method m = clazz.getDeclaredMethod("show", String.class); m.setAccessible(true); m.invoke(object, "HelloWorld!"); /*Console: HelloWorld */ &#125;&#125;正则表达式正则表达式（regular expression）描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。但是上面的叙述，对于之前没有接触过正则表达式的人还是很迷，我们打个比方，有一串字符：123xyz234和一个模式：*^*，我们假设*表示任意长度的由数字组成的字符串，^表示任意长度的由英文字符表示的字符串，那么我们就可以说这个字符串能匹配上这个模式。因为123可以匹配上*，xyz可以匹配上^，234可以匹配上*。同样的，假如我们再有一个模式：*^，我们用这个模式在字符串中提取，可以提取出来：123、123x、123xyz、234 等等，但是不能提取出来z234、123xyz234。因为我们能提取出来的都是符合这个模式的，这个模式就是正则表达式。不同的语言在正则表达式上的语法是有差距的，但是相同点远远大于不同点。我们在这使用Java语言中正则表达式。不过正则表达式的语法非常难记，在这也是举例出一些常用的语法，具体使用还是得查API文档。最简单的正则表达式在我们刚才的举例中可以看出正则表达式其实就是一种匹配规则，那么每个字符串也都是一种匹配规则。比如下面的split()方法是按照正则表达式把字符串分割，我们传入的一个字符串就是一个正则表达式。123456789101112public class RegTest &#123; public static void main(String[] args) &#123; String testStr = "1234567890"; /** * Splits this string around matches of the given regular expression. */ String[] split = testStr.split("67"); System.out.println(Arrays.deepToString(split)); &#125;&#125;和正则表达式有关的类虽然上个例子我们并没有使用到正则表达式相关的类，但这并不表明正则表达式就是一个字符串这么简单，在split()方法的内部还是调用了正则表达式相关的方法。Pattern类：Pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。该方法接受一个正则表达式作为它的第一个参数。Matcher类：Matcher 对象是对输入字符串进行解释和匹配操作的引擎。与Pattern 类一样，Matcher 也没有公共构造方法。你需要调用 Pattern 对象的 matcher 方法来获得一个 Matcher 对象。PatternSyntaxException：PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。现在我们使用正则表达式有关的类来完成上面的例子：12345678910public class RegTest &#123; public static void main(String[] args) &#123; String testStr = "1234567890"; Pattern pattern = Pattern.compile("67"); String[] split = pattern.split(testStr); System.out.println(Arrays.deepToString(split)); &#125;&#125;PatternSyntaxException 式一个异常类，但是不强制处理正则表达式的异常，所以这里可加可不加。Matcher的用法请继续看下去。匹配在上面我们测试的是正则表达式的分割作用，但是这并不是一个很好的学习正则表达式的例子。所以下面我们将采用匹配方法来学习正则表达式，先给一个小例子。12345678public class RegTest &#123; public static void main(String[] args) &#123; String testStr = "1234567890"; boolean matches = Pattern.matches("67", testStr); System.out.println(matches); &#125;&#125;这里的输出结果肯定是false了，因为12345和890都无法在模式中被匹配。字符类[abc] ：a、b 或 c（简单类）[^abc] ：任何字符，除了 a、b 或 c（否定）[a-zA-Z] ：a 到 z 或 A 到 Z，两头的字母包括在内（范围）[a-d[m-p]] ：a 到 d 或 m 到 p：[a-dm-p]（并集）[a-z&amp;&amp;[def]] ：d、e 或 f（交集）[a-z&amp;&amp;[^bc]] ：a 到 z，除了 b 和 c：[ad-z]（减去）[a-z&amp;&amp;[^m-p]] ：a 到 z，而非 m 到 p：[a-lq-z]（减去）123456789public class RegTest &#123; public static void main(String[] args) &#123; String testStr = "123"; Pattern.matches("[123][123][123]", testStr); //true Pattern.matches("[^123][123][123]", testStr); //false &#125;&#125;预定义字符类. ：任何字符（与行结束符可能匹配也可能不匹配）\d ：数字：[0-9]\D ：非数字： [^0-9]\s ：空白字符：[ \t\n\x0B\f\r]\S ：非空白字符：[^\s]\w ：单词字符：[a-zA-Z_0-9]\W ：非单词字符：[^\w]12345678public class RegTest &#123; public static void main(String[] args) &#123; String testStr = "123"; System.out.println(Pattern.matches("\\d\\d\\d", testStr)); //true System.out.println(Pattern.matches("\\w\\w\\w", testStr)); //true &#125;&#125;数量词X?： X存在一次或一次也没有X* ：X存在零次或多次X+ ：X存在一次或多次X{n} ：X存在恰好 n 次X{n,} ：X存在至少 n 次X{n,m} ：X存在至少 n 次，但是不超过 m 次123456789public class RegTest &#123; public static void main(String[] args) &#123; String testStr = "123"; boolean matches = Pattern.matches("[123]&#123;3&#125;", testStr); //true System.out.println(matches); &#125;&#125;查找子串查找子串需要使用到Pattern和Mather[flid=1415279, ffid=BK-2898-20180922-A, frtt=20180922210700, frlt=20180923000300][flid=1417032, ffid=OD-689-20180923-D, fatt=2401, stat=BOR, ista=BOR]123456789101112public class RegTest &#123; public static final String FFID = "((ffid=)&#123;1&#125;)\\w&#123;2&#125;-\\w&#123;3,6&#125;-\\d&#123;8&#125;-\\w"; public static void main(String[] args) &#123; String str = "[flid=1415279, ffid=BK-2898-20180922-A, frtt=20180922210700, frlt=20180923000300][flid=1417032, ffid=OD-689-20180923-D, fatt=2401, stat=BOR, ista=BOR]"; Pattern pattern = Pattern.compile(FFID); Matcher matcher = pattern.matcher(str); //循环找出全部的匹配子串 while(matcher.find()) &#123; System.out.println(matcher.group(0)); &#125; &#125;&#125;group方法group是针对正则表达式中的()来说的，group(0)就是指的整个串，group(1)指的是第一个括号里的东西，group(2)指的第二个括号里的东西。123456789101112131415161718public static void main(String[] args) throws Exception &#123; String regEx = "count(\\d+)(df)"; String s = "count000dfdfsdffaaaa1"; Pattern pat = Pattern.compile(regEx); Matcher mat = pat.matcher(s); if (mat.find()) &#123; System.out.println(mat.group()); System.out.println(mat.group(0)); System.out.println(mat.group(1)); System.out.println(mat.group(2)); &#125;&#125;/* count000df count000df 000 df*/Reference强引用Java中默认声明的就是强引用，比如：12Object obj = new Object(); // 只要obj还指向Object对象，Object对象就不会被回收obj = null; // 手动置null只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，也不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了。软引用软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。表示软引用的类是java.lang.ref.SoftReference。下面以一个例子来进一步说明强引用和软引用的区别：首先先来测试一下强引用，在限制了 JVM 内存的前提下，下面的代码运行正常：1234567891011// -Xms2M -Xmx3M，将 JVM 的初始内存设为2M，最大可用内存为 3M。public class TestOOM &#123; public static void main(String[] args) &#123; testStrongReference(); &#125; private static void testStrongReference() &#123; // 当 new byte为 1M 时，程序运行正常 // 当 new byte为 1M 时，程序报异常 OutOfMemoryError byte[] buff = new byte[1024 * 1024 * 3]; &#125;&#125;接着来看一下软引用会有什么不一样，在下面的示例中连续创建了 10 个大小为 1M 的字节数组，并赋值给了软引用，然后循环遍历将这些对象打印出来。1234567891011121314151617181920212223public class TestOOM &#123; private static List&lt;Object&gt; list = new ArrayList&lt;&gt;(); public static void main(String[] args) &#123; testSoftReference(); &#125; private static void testSoftReference() &#123; for (int i = 0; i &lt; 5; i++) &#123; SoftReference&lt;byte[]&gt; sr = new SoftReference&lt;&gt;(new byte[1024 * 1024]); list.add(sr); &#125; for(int i=0; i &lt; 5; i++)&#123; Object obj = ((SoftReference) list.get(i)).get(); System.out.println(obj); &#125; &#125;&#125;/* null null null null [B@12a3a380*/我们发现无论循环创建多少个软引用对象，打印结果总是只有最后一个对象被保留，其他的obj全都被置空回收了。这里就说明了在内存不足的情况下，软引用将会被自动回收。弱引用弱引用的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。123456789101112131415161718private static void testWeakReference() &#123; for (int i = 0; i &lt; 5; i++) &#123; WeakReference&lt;byte[]&gt; sr = new WeakReference&lt;&gt;(new byte[1024 * 1024]); list.add(sr); &#125; System.gc(); //主动通知垃圾回收 for(int i=0; i &lt; 5; i++)&#123; Object obj = ((WeakReference) list.get(i)).get(); System.out.println(obj); &#125;&#125;/* null null null null null*/可以发现所有被弱引用关联的对象都被垃圾回收了。虚引用虚引用并不会影响对象的生命周期。虚引用的作用为：跟踪垃圾回收器收集对象这一活动的情况。当GC一旦发现了虚引用对象，则会将PhantomReference对象插入ReferenceQueue队列，而此时PhantomReference对象并没有被垃圾回收器回收，而是要等到ReferenceQueue被你真正的处理后才会被回收。注意：PhantomReference必须要和ReferenceQueue联合使用，SoftReference和WeakReference可以选择和ReferenceQueue联合使用也可以不选择。ReferenceQueue12345678910111213141516171819202122232425262728293031323334353637383940public class RefTest &#123; private static ReferenceQueue&lt;byte[]&gt; rq = new ReferenceQueue&lt;&gt;(); private static int _1M = 1024 * 1024; public static void main(String[] args) &#123; Object value = new Object(); Map&lt;Object, Object&gt; map = new HashMap&lt;&gt;(); Thread thread = new Thread(() -&gt; &#123; try &#123; int cnt = 0; PhantomReference&lt;byte[]&gt; k; // Removes the next reference object in this queue // blocking until one becomes available. while ((k = (PhantomReference&lt;byte[]&gt;) rq.remove()) != null) &#123; System.out.println((cnt++) + "回收了: " + k); &#125; &#125; catch (InterruptedException e) &#123; //结束循环 &#125; &#125;); thread.setDaemon(true); thread.start(); for (int i = 0; i &lt; 10; i++) &#123; byte[] bytes = new byte[_1M]; PhantomReference&lt;byte[]&gt; weakReference = new PhantomReference&lt;&gt;(bytes, rq); map.put(weakReference, value); &#125; try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("gc........"); System.gc(); try &#123; Thread.sleep(5000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;先输出6次表示在加入第6个加入后触发了GC操作，然后在停住的5秒里没有任何操作表示没有触发GC，所以不会加入到队列中，然后我们手动触发一次GC，对象都被加入到队列中了。System.gc()Runs the garbage collector. Calling this method suggests that the Java virtual machine expend effort toward recycling unused objects in order to make the memory they currently occupy available for quick reuse. When control returns from the method call, the virtual machine has made its best effort to recycle all discarded objects.The name gc stands for “garbage collector”. The virtual machine performs this recycling process automatically as needed, in a separate thread, even if the gc method is not invoked explicitly.The method System.gc() is the conventional and convenient means of invoking this method.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.06-JavaSE-Java8-3]]></title>
    <url>%2Fposts%2F65180.html%2F</url>
    <content type="text"><![CDATA[分割迭代器An object for traversing and partitioning elements of a source. The source of elements covered by a Spliterator could be, for example, an array, a Collection, an IO channel, or a generator function.A Spliterator may traverse elements individually (tryAdvance()) or sequentially in bulk （散装的）(forEachRemaining()).tryAdvance()If a remaining element exists, performs the given action on it, returning true; else returns false. If this Spliterator is ORDERED the action is performed on the next element in encounter order. Exceptions thrown by the action are relayed to the caller. （为了更好的解释，我们顺便看一下Collection的实现，下同）1234567891011121314private final Collection&lt;? extends T&gt; collection; // null OKprivate Iterator&lt;? extends T&gt; it;public boolean tryAdvance(Consumer&lt;? super T&gt; action) &#123; if (action == null) throw new NullPointerException(); if (it == null) &#123; it = collection.iterator(); est = (long) collection.size(); &#125; if (it.hasNext()) &#123; action.accept(it.next()); return true; &#125; return false;&#125;forEachRemaining()Performs the given action for each remaining element, sequentially in the current thread, until all elements have been processed or the action throws an exception. If this Spliterator is ORDERED, actions are performed in encounter order. Exceptions thrown by the action are relayed to the caller.123456789101112private final Collection&lt;? extends T&gt; collection; // null OKprivate Iterator&lt;? extends T&gt; it;private long est; // size estimatepublic void forEachRemaining(Consumer&lt;? super T&gt; action) &#123; if (action == null) throw new NullPointerException(); Iterator&lt;? extends T&gt; i; if ((i = it) == null) &#123; i = it = collection.iterator(); est = (long)collection.size(); &#125; i.forEachRemaining(action);&#125;A Spliterator may also partition off some of its elements (using trySplit) as another Spliterator, to be used in possibly-parallel operations. Operations using a Spliterator that cannot split, or does so in a highly imbalanced or inefficient manner, are unlikely to benefit from parallelism. Traversal and splitting exhaust elements; each Spliterator is useful for only a single bulk computation.estimateSize()Returns an estimate of the number of elements that would be encountered by a forEachRemaining traversal, or returns Long.MAX_VALUE if infinite, unknown, or too expensive to compute.If this Spliterator is SIZED and has not yet been partially traversed or split, or this Spliterator is SUBSIZED and has not yet been partially traversed, this estimate must be an accurate count of elements that would be encountered by a complete traversal. Otherwise, this estimate may be arbitrarily inaccurate, but must decrease as specified across invocations of trySplit.12345678@Overridepublic long estimateSize() &#123; if (it == null) &#123; it = collection.iterator(); return est = (long)collection.size(); &#125; return est;&#125;trySplit()If this spliterator can be partitioned, returns a Spliterator covering elements, that will, upon return from this method, not be covered by this Spliterator.If this Spliterator is ORDERED, the returned Spliterator must cover a strict prefix of the elements.Unless this Spliterator covers an infinite number of elements, repeated calls to trySplit() must eventually return null. Upon non-null return:the value reported for estimateSize() before splitting, must, after splitting, be greater than or equal to estimateSize() for this and the returned Spliterator; andif this Spliterator is SUBSIZED, then estimateSize() for this spliterator before splitting must be equal to the sum of estimateSize() for this and the returned Spliterator after splitting.This method may return null for any reason, including emptiness, inability to split after traversal has commenced, data structure constraints, and efficiency considerations.Returns: a Spliterator covering some portion of the elements, or null if this spliterator cannot be split123456789101112131415161718192021222324252627282930static final int BATCH_UNIT = 1 &lt;&lt; 10; // batch array size incrementstatic final int MAX_BATCH = 1 &lt;&lt; 25; // max batch array size;private long est; // size estimateprivate int batch; // batch size for splitspublic Spliterator&lt;T&gt; trySplit() &#123; Iterator&lt;? extends T&gt; i; long s; // collection 的 size if ((i = it) == null) &#123; i = it = collection.iterator(); s = est = (long) collection.size(); &#125; else s = est; if (s &gt; 1 &amp;&amp; i.hasNext()) &#123; int n = batch + BATCH_UNIT; if (n &gt; s) n = (int) s; if (n &gt; MAX_BATCH) n = MAX_BATCH; Object[] a = new Object[n]; int j = 0; do &#123; a[j] = i.next(); &#125; while (++j &lt; n &amp;&amp; i.hasNext()); batch = j; if (est != Long.MAX_VALUE) est -= j; return new ArraySpliterator&lt;&gt;(a, 0, j, characteristics); &#125; return null;&#125;对于Collection里面trySplit()的实现，第一次调用返回的分割迭代器覆盖$2^{10}$个元素，第二次调用返回的覆盖$2^{11}$个元素，第三次调用返回的覆盖$2^{12}$个元素，第n次调用返回的覆盖$2^{9+n}$的元素。构建&amp;执行流我们下面通过一个例子来剖析，JDK是怎么构建&amp;执行流的。1234567891011public static void main(String[] args) &#123; List&lt;String&gt; strings = new ArrayList&lt;&gt;(); strings.add("A123"); strings.add("A12345"); strings.add("B123"); strings.add("B1234"); strings.stream() .filter(s -&gt; s.startsWith("A")) .map(item -&gt; item.length()) .forEach(System.out::println);&#125;对于这个例子，他是调用Collection的stream()生成一个流：1234567default Spliterator&lt;E&gt; spliterator() &#123; return Spliterators.spliterator(this, 0);&#125;default Stream&lt;E&gt; stream() &#123; // &lt;T&gt; Stream&lt;T&gt; stream(Spliterator&lt;T&gt; spliterator, boolean parallel) &#123; return StreamSupport.stream(spliterator(), false);&#125;分割迭代器方法负责将一个源的数据划分开来。123456public static &lt;T&gt; Stream&lt;T&gt; stream(Spliterator&lt;T&gt; spliterator, boolean parallel) &#123; Objects.requireNonNull(spliterator); return new ReferencePipeline.Head&lt;&gt;(spliterator, StreamOpFlag.fromCharacteristics(spliterator), parallel);&#125;在这段代码中我们会发现，最终我们获得的流是ReferencePipeline的内部类Head。再深入去看，我们会发现有一个这样的继承体系，图片来自。这个继承体系不是很难，很多都是在使用流的时候会被使用的类。我们之前说过，一个流由一个源，0个或多个中间操作，以及一个终止操作构成。这个体系里的XXXPipeline便是中间操作。他们构成了一个管道。在管道中，Head，StatelssOp，StatefulOp三个是真正的代表中间操作的类。其中我们刚才看到的Head便表示管道的第一个操作，因为在其他的中间操作中，都有前驱和后继，但是对于Head，是只有后继，没有前驱，所以被单独列出来。我们常用的Stream中的方法实际上是在XXXPipeline中被实现的，由于我们的例子是使用ReferencePipeline，所以我们下面就去看看这个类中是如何实现filter、map和forEach的。1234567891011121314151617181920public final Stream&lt;P_OUT&gt; filter(Predicate&lt;? super P_OUT&gt; predicate) &#123; Objects.requireNonNull(predicate); return new StatelessOp&lt;P_OUT, P_OUT&gt;(this, StreamShape.REFERENCE, StreamOpFlag.NOT_SIZED) &#123; @Override Sink&lt;P_OUT&gt; opWrapSink(int flags, Sink&lt;P_OUT&gt; sink) &#123; return new Sink.ChainedReference&lt;P_OUT, P_OUT&gt;(sink) &#123; @Override public void begin(long size) &#123; downstream.begin(-1); &#125; @Override public void accept(P_OUT u) &#123; if (predicate.test(u)) downstream.accept(u); &#125; &#125;; &#125; &#125;;&#125;123456789101112131415public final &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super P_OUT, ? extends R&gt; mapper) &#123; Objects.requireNonNull(mapper); return new StatelessOp&lt;P_OUT, R&gt;(this, StreamShape.REFERENCE, StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123; @Override Sink&lt;P_OUT&gt; opWrapSink(int flags, Sink&lt;R&gt; sink) &#123; return new Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123; @Override public void accept(P_OUT u) &#123; downstream.accept(mapper.apply(u)); &#125; &#125;; &#125; &#125;;&#125;123public void forEach(Consumer&lt;? super P_OUT&gt; action) &#123; evaluate(ForEachOps.makeRef(action, false));&#125;很明显可以看到，中间操作和终止操作的实现有很大的不同。至此，我们可以画一个图来表示这个过程。但是我们现在还不知道这个流管道是怎么被串联起来的。所以我们接着分析。我们进入StatelessOp的构造方法中，一路向下跟进：12345678910111213141516171819202122StatelessOp(AbstractPipeline&lt;?, E_IN, ?&gt; upstream, StreamShape inputShape, int opFlags) &#123; super(upstream, opFlags); assert upstream.getOutputShape() == inputShape;&#125;ReferencePipeline(AbstractPipeline&lt;?, P_IN, ?&gt; upstream, int opFlags) &#123; super(upstream, opFlags);&#125;AbstractPipeline(AbstractPipeline&lt;?, E_IN, ?&gt; previousStage, int opFlags) &#123; if (previousStage.linkedOrConsumed) throw new IllegalStateException(MSG_STREAM_LINKED); previousStage.linkedOrConsumed = true; previousStage.nextStage = this; this.previousStage = previousStage; this.sourceOrOpFlags = opFlags &amp; StreamOpFlag.OP_MASK; this.combinedFlags = StreamOpFlag.combineOpFlags(opFlags, previousStage.combinedFlags); this.sourceStage = previousStage.sourceStage; if (opIsStateful()) sourceStage.sourceAnyStateful = true; this.depth = previousStage.depth + 1;&#125;跟到了AbstractPipeline的构造方法中，我们才发现，AbstractPipeline中有三个属性：12345678910private final AbstractPipeline sourceStage;/** * The "upstream" pipeline, or null if this is the source stage. */private final AbstractPipeline previousStage;/** * The next stage in the pipeline, or null if this is the last stage. * Effectively final at the point of linking to the next pipeline. */private AbstractPipeline nextStage;看到这里我们就会发现，管道和管道之间的链接是使用双向链表的方式进行的。同时，每个非Head管道，都有一个指向Head的引用。这样我们就可以将上面的图再具体一些：看到这里我们就知道中间操作的流管道是怎么被串联起来的，但是终止操作是怎么和中间操作联系到一起的呢？所以我们需要看forEach方法：1234@Overridepublic void forEach(Consumer&lt;? super P_OUT&gt; action) &#123; evaluate(ForEachOps.makeRef(action, false));&#125;在这个方法中，我们先看内部的方法：12345public static &lt;T&gt; TerminalOp&lt;T, Void&gt; makeRef(Consumer&lt;? super T&gt; action, boolean ordered) &#123; Objects.requireNonNull(action); return new ForEachOp.OfRef&lt;&gt;(action, ordered);&#125;这个方法是一个工厂方法，负责构建一个TerminalOp类的对象，这个类一看类名就知道他是一个终止操作。我们再向下跟进一层：1234567891011static final class OfRef&lt;T&gt; extends ForEachOp&lt;T&gt; &#123; final Consumer&lt;? super T&gt; consumer; OfRef(Consumer&lt;? super T&gt; consumer, boolean ordered) &#123; super(ordered); this.consumer = consumer; &#125; @Override public void accept(T t) &#123; consumer.accept(t); &#125;&#125;我么会发现，OfRef这个类中保存我们传递给forEach的行为参数，也就是一个Consumer。然后我们再看evaluate()123456789final &lt;R&gt; R evaluate(TerminalOp&lt;E_OUT, R&gt; terminalOp) &#123; assert getOutputShape() == terminalOp.inputShape(); if (linkedOrConsumed) throw new IllegalStateException(MSG_STREAM_LINKED); linkedOrConsumed = true; return isParallel() ? terminalOp.evaluateParallel(this, sourceSpliterator(terminalOp.getOpFlags())) : terminalOp.evaluateSequential(this, sourceSpliterator(terminalOp.getOpFlags()));&#125;这个方法接收一个TerminalOp。从他返回的结果来看，我们知道，这里是并行流和串行流执行的分叉的地方。并行流的分析很困难，作为理解Stream的原理，而不是真正从性能等角度考虑并行流和串行流的差异，我们便去看看串行流是怎么执行的，进而来理解Stream。1&lt;P_IN&gt; R evaluateSequential(PipelineHelper&lt;E_IN&gt; helper, Spliterator&lt;P_IN&gt; spliterator);这个方法是未被实现的方法，它需要TerminalOp的子类来决定它的行为到底是什么。同时可以看一下evaluateParallel()，这个方法被提供了一个默认实现，同时默认实现就是调用了一下串行的方法。1234567default &lt;P_IN&gt; R evaluateParallel(PipelineHelper&lt;E_IN&gt; helper, Spliterator&lt;P_IN&gt; spliterator) &#123; if (Tripwire.ENABLED) Tripwire.trip(getClass(), "&#123;0&#125; triggering TerminalOp.evaluateParallel serial default"); return evaluateSequential(helper, spliterator);&#125;在找到evaluateSequential()的实现之前，我们先去看看PipelineHelper，这个类的注释如下：Helper class for executing stream pipelines, capturing all of the information about a stream pipeline (output shape, intermediate operations, stream flags, parallelism, etc) in one place.A PipelineHelper describes the initial segment of a stream pipeline, including its source, intermediate operations, and may additionally incorporate information about the terminal (or stateful) operation which follows the last intermediate operation described by this PipelineHelper. The PipelineHelper is passed to the TerminalOp.evaluateParallel(PipelineHelper, Spliterator), TerminalOp.evaluateSequential(PipelineHelper, Spliterator), and AbstractPipeline.opEvaluateParallel(PipelineHelper, Spliterator, IntFunction), methods, which can use the PipelineHelper to access information about the pipeline such as head shape, stream flags, and size, and use the helper methods such as wrapAndCopyInto(Sink, Spliterator), copyInto(Sink, Spliterator), and wrapSink(Sink) to execute pipeline operations.注释中说，这个类捕获中间操作、流的flags、是否并行等。但是仅仅看注释其实我们是看不懂的，不过从后面的我们的分析可以得到，它封装了关于求值的方法。同时AbstractPipeline继承了PipelineHelper。这个类的命名个人很难接受，因为感觉类的功能和类名完全没有联系，如果改为computeHelper反而更好理解。不过这已无关紧要。我们下面来寻找evaluateSequential()的实现类。在上面的分析中，我们知道，传递给evaluate()方法的实际上是OfRef类，而OfRef又继承了ForEachOp，同时在其中有如下的实现：123public &lt;S&gt; Void evaluateSequential(PipelineHelper&lt;T&gt; helper, Spliterator&lt;S&gt; spliterator) &#123; return helper.wrapAndCopyInto(this, spliterator).get();&#125;很显然，直接跟进去wrapAndCopyInto()又是一个待实现的方法。所以我们又要回溯，一致回溯到evaluate()，可以发现，我们传递进去的helper是AbstractPipeline的对象。在这个类中，我们找到了如下实现：1234final &lt;P_IN, S extends Sink&lt;E_OUT&gt;&gt; S wrapAndCopyInto(S sink, Spliterator&lt;P_IN&gt; spliterator) &#123; copyInto(wrapSink(Objects.requireNonNull(sink)), spliterator); return sink;&#125;在这里我们遇到了之前见过但是没有分析的接口Sink。在哪见得呢？在filter()和map()的实现中。123456789101112131415public final &lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super P_OUT, ? extends R&gt; mapper) &#123; Objects.requireNonNull(mapper); return new StatelessOp&lt;P_OUT, R&gt;(this, StreamShape.REFERENCE, StreamOpFlag.NOT_SORTED | StreamOpFlag.NOT_DISTINCT) &#123; @Override Sink&lt;P_OUT&gt; opWrapSink(int flags, Sink&lt;R&gt; sink) &#123; return new Sink.ChainedReference&lt;P_OUT, R&gt;(sink) &#123; @Override public void accept(P_OUT u) &#123; downstream.accept(mapper.apply(u)); &#125; &#125;; &#125; &#125;;&#125;在创建StatelessOp的对象时，我们覆盖了opWrapSink()方法，这个方法返回一个Sink。什么是Sink？1interface Sink&lt;T&gt; extends Consumer&lt;T&gt; &#123;....&#125;从定义上来看，它是继承了Consumer的一个接口。我们一般管道的每一段称为一个Stage。从我们上一张图中可以看见，Stage之间是通过双向链表连接起来的，但是我们却没有说每一段的行为是怎么被保存的。而怎么保存以及后续怎么调用便是由Sink来完成。Sink它也是一个Consumer，但是比普通的Comsumer多了一些功能，JDK注释如下：An extension of Consumer used to conduct values through the stages of a stream pipeline, with additional methods to manage size information, control flow, etc. Before calling the accept() method on a Sink for the first time, you must first call the begin() method to inform it that data is coming (optionally informing the sink how much data is coming), and after all data has been sent, you must call the end() method. After calling end(), you should not call accept() without again calling begin(). Sink also offers a mechanism by which the sink can cooperatively signal that it does not wish to receive any more data (the cancellationRequested() method), which a source can poll before sending more data to the Sink.A sink may be in one of two states: an initial state and an active state. It starts out in the initial state; the begin() method transitions it to the active state, and the end() method transitions it back into the initial state, where it can be re-used. Data-accepting methods (such as accept() are only valid in the active state.看到这里，我们知道了Sink的作用是进行流中元素的控制的，比如将一个Consumer转为两个阶段：初始阶段和激活阶段。但是总感觉还是很迷，这种操作有什么用呢？直接使用Consumer不行吗？在我们继续分析之前，我们将上面的那张图再做一下更新。在图中，向下的箭头表示包含的意思。到了这里，我们便可以继续分析wrapAndCopyInto()。同时我们在ForEachOp中发现在调用这个方法的时候传的参数是this。这个this指的是OfRef的对象，也就是一个终止操作的对象。再向下跟进，我们就进入了wrapSink()1234567final &lt;P_IN&gt; Sink&lt;P_IN&gt; wrapSink(Sink&lt;E_OUT&gt; sink) &#123; Objects.requireNonNull(sink); for (AbstractPipeline p=AbstractPipeline.this; p.depth &gt; 0; p=p.previousStage) &#123; sink = p.opWrapSink(p.previousStage.combinedFlags, sink); &#125; return (Sink&lt;P_IN&gt;) sink;&#125;其中的AbstractPipeline.this就是我们最后一个ReferencePipeline，这个对象有指针指向前面的Stage。此时我们就可以分析一下opWrapSink()，它是每一个Stream里面供我们使用的操作都会去覆盖的方法，它返回一个ChainedReference，这个类里面有一个属性Sink，他是下游的Sink，也就是说在每个Sink里都会存在一个指向下游Sink的引用。当我们第一次执行上面的代码的时候sink是终止操作，p是MapSink；当我们第而次执行上面的代码的时候sink是MapSink，p是FileterSink。所以当这段代码执行完成的时候我们上面的所以Sink对象会被关联起来，按照我们的例子，应该有下图：Sink组装好了之后便会调用copyInto()：12345678910final &lt;P_IN&gt; void copyInto(Sink&lt;P_IN&gt; wrappedSink, Spliterator&lt;P_IN&gt; spliterator) &#123; Objects.requireNonNull(wrappedSink); if (!StreamOpFlag.SHORT_CIRCUIT.isKnown(getStreamAndOpFlags())) &#123; wrappedSink.begin(spliterator.getExactSizeIfKnown()); spliterator.forEachRemaining(wrappedSink); wrappedSink.end(); &#125; else &#123; copyIntoWithCancel(wrappedSink, spliterator); &#125;&#125;在这段代码中我们可以看到，如果不包含短路操作，便执行spliterator.forEachRemaining(wrappedSink);，我们以Collection的spliterator为例，看看最终是怎么执行的。123456789public void forEachRemaining(Consumer&lt;? super T&gt; action) &#123; if (action == null) throw new NullPointerException(); Iterator&lt;? extends T&gt; i; if ((i = it) == null) &#123; i = it = collection.iterator(); est = (long)collection.size(); &#125; i.forEachRemaining(action);&#125;123456789101112public boolean tryAdvance(Consumer&lt;? super T&gt; action) &#123; if (action == null) throw new NullPointerException(); if (it == null) &#123; it = collection.iterator(); est = (long) collection.size(); &#125; if (it.hasNext()) &#123; action.accept(it.next()); return true; &#125; return false;&#125;如果我们有一个元素，设置item。item首先会进入FilterSink，在其中执行：1234public void accept(P_OUT u) &#123; if (predicate.test(u)) downstream.accept(u);&#125;如果test为真，调用下游的Sink；下游的Sink是MapSink，此时执行：123public void accept(P_OUT u) &#123; downstream.accept(mapper.apply(u));&#125;这段代码中先执行mapper.apply(u)，然后执行downstream.accept，而此时的downstream是ForEachSink；然后就会执行OfRef的：123public void accept(T t) &#123; consumer.accept(t);&#125;此时的consumer是System.out.println，最终输出结果。至此，流的执行分解完成。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.05-JavaSE-Java8-2]]></title>
    <url>%2Fposts%2F53021.html%2F</url>
    <content type="text"><![CDATA[初识Stream在最开始接触到这个名词的时候，我们应该都是有一个问题，此流和IO流有什么关系？实际上它俩一点关系都没有，IO流描述的是对IO的操作如同流水线操作一样，比如我们读一个字节处理一个字节或者读一行处理一行。而Stream这个流也是这个意思，它将对数据源的处理也描述的向流水线操作一样。一个Stream包含一个源、0个或多个中间操作和一个终止操作。由于Stream遵循惰性求值的规范，所以中间操作不会产生任何结果，只有遇到终止操作才会产生结果。123456// 构建源public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of("hello", "world", "hello world"); Stream&lt;String&gt; stream1 = Arrays.stream(new String[]&#123;"hello", "world", "hello world"&#125;); Stream&lt;String&gt; stream2 = Arrays.asList("hello", "world", "hello world").stream();&#125;1234567891011// 构建源public static void main(String[] args) &#123; IntStream intStream = IntStream.of(new int[]&#123;5, 6, 7&#125;); intStream.forEach(System.out::println); System.out.println("-------------------"); // 输出 [3,8)返回的数据 IntStream.range(3, 8).forEach(System.out::println); System.out.println("-------------------"); // 输出 [3,8]返回的数据 IntStream.rangeClosed(3, 8).forEach(System.out::println);&#125;12345678910111213141516public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arays.asList(1, 2, 3, 4, 5, 6, 7); // System.out.println(list.stream().map(new Function&lt;Integer, Integer&gt;() &#123; // @Override // public Integer apply(Integer integer) &#123; // return integer * 2; // &#125; // &#125;).reduce(0, new BinaryOperator&lt;Integer&gt;() &#123; // @Override // public Integer apply(Integer integer, Integer integer2) &#123; // return integer + integer2; // &#125; // &#125;)); System.out.println(list.stream().map(i -&gt; i * 2).reduce(0, Integer::sum)); // map是中间过程，reduce是终止操作&#125;123456789101112131415// 通过源构建数组和集合public static void main(String[] args) &#123; Stream&lt;String&gt; stream = Stream.of("hello", "world", "hello world"); // Returns an array containing the elements of this stream, // using the provided generator function to allocate the returned array, // as well as any additional arrays that might be required for a partitioned // execution or for resizing. This is a terminal operation.s String[] strings = stream.toArray(length -&gt; new String[length]); System.out.println(Arrays.deepToString(strings)); // 相同的效果，但是不能在这里和上面的的代码同时出现，因为toArray是一个终止操作，stream已经终止了// 这里就像一个IO流被关闭了就不能再使用一样// List&lt;String&gt; collect = stream.collect(Collectors.toList());// System.out.println(collect);&#125;123456789101112131415161718// Returns an infinite sequential unordered stream where each element is generated // by the provided Supplier. This is suitable for generating constant streams, // streams of random elements, etc.Stream&lt;String&gt; generate = Stream.generate(UUID.randomUUID()::toString);Stream&lt;String&gt; limit = generate.limit(3);List&lt;String&gt; collect = limit.collect(Collectors.toList());System.out.println(collect);// Returns an infinite sequential ordered Stream produced by iterative application of a // function f to an initial element seed, producing a Stream consisting of seed, f(seed), // f(f(seed)), etc. The first element (position 0) in the Stream will be the provided seed. // For n &gt; 0, the element at position n, will be the result of applying the function f to // the element at position n - 1.Stream&lt;Integer&gt; iterate = Stream.iterate(5, (item) -&gt; item + item);Stream&lt;Integer&gt; limit1 = iterate.limit(10);List&lt;Integer&gt; collect1 = limit1.collect(Collectors.toList());System.out.println(collect1);// [70e641b3-75d7-4561-ad54-fefe77fa6d63, 70e641b3-75d7-4561-ad54-fefe77fa6d63, 70e641b3-75d7-4561-ad54-fefe77fa6d63]// [5, 10, 20, 40, 80, 160, 320, 640, 1280, 2560]基础API流具有如下特点：不存储数据。流是基于数据源的对象，它本身不存储数据元素，而是通过管道将数据源的元素传递给操作。函数式编程。流的操作不会修改数据源，例如filter不会将数据源中的数据删除。延迟操作。流的很多操作如filter，map等中间操作是延迟执行的，只有到终点操作才会将操作顺序执行。可以解绑。对于无限数量的流，有些操作是可以在有限的时间完成的，比如limit(n) 或 findFirst()，这些操作可是实现”短路”（Short-circuiting），访问到有限的元素后就可以返回。纯消费。流的元素只能访问一次，类似Iterator，操作没有回头路，如果你想从头重新访问流的元素，对不起，你得重新生成一个新的流。forEach()方法签名为void forEach(Consumer action)，作用是对容器中的每个元素执行action指定的动作。123// 使用Stream.forEach()迭代Stream&lt;String&gt; stream = Stream.of("I", "love", "you", "too");stream.forEach(str -&gt; System.out.println(str));filter()函数原型为Stream filter(Predicate predicate)，作用是返回一个只包含满足predicate条件元素的Stream。123// 保留长度等于3的字符串Stream&lt;String&gt; stream= Stream.of("I", "love", "you", "too");stream.filter(str -&gt; str.length()==3).forEach(str -&gt; System.out.println(str));distinct()函数原型为Stream distinct()，作用是返回一个去除重复元素之后的Stream。123// 去掉一个too之后的其余字符串Stream&lt;String&gt; stream= Stream.of("I", "love", "you", "too", "too");stream.distinct().forEach(str -&gt; System.out.println(str));sorted()排序函数有两个，一个是用自然顺序排序，一个是使用自定义比较器排序，函数原型分别为Stream sorted()和Stream sorted(Comparator comparator)。123// 输出按照长度升序排序后的字符串Stream&lt;String&gt; stream= Stream.of("I", "love", "you", "too");stream.sorted((str1, str2) -&gt; str1.length()-str2.length()).forEach(System.out::println);map()函数原型为Stream map(Function mapper)，作用是返回一个对当前所有元素执行执行mapper之后的结果组成的Stream。直观的说，就是对每个元素按照某种操作进行转换，转换前后Stream中元素的个数不会改变，但元素的类型取决于转换之后的类型。123// 输出原字符串的大写形式Stream&lt;String&gt; stream = Stream.of("I", "love", "you", "too");stream.map(str -&gt; str.toUpperCase()).forEach(str -&gt; System.out.println(str));flatMap()函数原型为Stream flatMap(Function&gt; mapper)，作用是对每个元素执行mapper指定的操作，并用所有mapper返回的Stream中的元素组成一个新的Stream作为最终返回结果。说起来太拗口，通俗的讲flatMap()的作用就相当于把原stream中的所有元素都”摊平”之后组成的Stream，转换前后元素的个数和类型都可能会改变。1234// 原来的stream中有两个元素，分别是两个List，执行flatMap()之后，将每个List都“摊平”成了一个个的数字，// 所以会新产生一个由5个数字组成的Stream。所以最终将输出1~5这5个数字Stream&lt;List&lt;Integer&gt;&gt; stream = Stream.of(Arrays.asList(1,2), Arrays.asList(3, 4, 5));stream.flatMap(list -&gt; list.stream()).forEach(i -&gt; System.out.println(i));peekpeek 操作接收的是一个 Consumer 函数。会按照 Consumer 函数提供的逻辑去消费流中的每一个元素，但是返回的流还是包含原来的流中的元素。123456// peek操作一般用于不想改变流中元素本身的类型或者只想操作元素的内部状态时；而map则用于改变流中元素本身// 类型，即从元素中派生出另一种类型的操作。这是他们之间的最大区别。 String[] arr = new String[]&#123;"a","b","c","d"&#125;;Arrays.stream(arr) .peek(System.out::println) // a,b,c,d .count();匹配123public boolean allMatch(Predicate&lt;? super T&gt; predicate)public boolean anyMatch(Predicate&lt;? super T&gt; predicate)public boolean noneMatch(Predicate&lt;? super T&gt; predicate)allMatch只有在所有的元素都满足断言时才返回true，否则false，流为空时总是返回trueanyMatch只有在任意一个元素满足断言时就返回true，否则falsenoneMatch只有在所有的元素都不满足断言时才返回true，否则false123456System.out.println(Stream.of(1,2,3,4,5).allMatch( i -&gt; i &gt; 0)); // trueSystem.out.println(Stream.of(1,2,3,4,5).anyMatch( i -&gt; i &gt; 0)); // trueSystem.out.println(Stream.of(1,2,3,4,5).noneMatch( i -&gt; i &gt; 0)); // falseSystem.out.println(Stream.&lt;Integer&gt;empty().allMatch( i -&gt; i &gt; 0)); // trueSystem.out.println(Stream.&lt;Integer&gt;empty().anyMatch( i -&gt; i &gt; 0)); // falseSystem.out.println(Stream.&lt;Integer&gt;empty().noneMatch( i -&gt; i &gt; 0)); // truereducereduce操作符是及早求值操作符，接受一个元素序列为输入，反复使用某个合并操作，把序列中的元素合并成一个汇总的结果，其生成的值不是随意的，而是根据指定的计算模型。reduce方法有三个override的方法。12345Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);第一种形式1Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator);Performs a reduction on the elements of this stream, using an associative accumulation function, and returns an Optional describing the reduced value, if any. This is equivalent to:123456789101112&gt; boolean foundAny = false;&gt; T result = null;&gt; for (T element : this stream) &#123;&gt; if (!foundAny) &#123;&gt; foundAny = true;&gt; result = element;&gt; &#125;&gt; else&gt; result = accumulator.apply(result, element);&gt; &#125;&gt; return foundAny ? Optional.of(result) : Optional.empty();&gt;but is not constrained to execute sequentially. The accumulator function must be an associative function. This is a terminal operation.123456789public static void main(String[] args) &#123; Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).reduce((sum, item) -&gt; &#123; System.out.println(sum); return sum - item; &#125;).ifPresent(System.out::println);&#125;// 1 -1 -4 -8 -13 -19 -26 -34 -43 -53// 第一轮的sum是索引为0位置的数据，item是索引为1位置的数据。// 后面轮次的sum是上一轮次计算的结果。item的索引依次加一。第二种形式1T reduce(T identity, BinaryOperator&lt;T&gt; accumulator);Performs a reduction on the elements of this stream, using the provided identity value and an associative accumulation function, and returns the reduced value. This is equivalent to:12345&gt; T result = identity;&gt; for (T element : this stream)&gt; result = accumulator.apply(result, element)&gt; return result;&gt;but is not constrained to execute sequentially. The identity value must be an identity for the accumulator function. This means that for all t, accumulator.apply(identity, t) is equal to t. The accumulator function must be an associative function. This is a terminal operation.12345678910public static void main(String[] args) &#123; Integer reduce = Stream.of(1, 2, 3, 4, 5, 6, 7, 8, 9, 10).reduce(1, (sum, item) -&gt; &#123; System.out.println(sum); return sum - item; &#125;); System.out.println(reduce);&#125;// 1 0 -2 -5 -9 -14 -20 -27 -35 -44 -54// 第一轮的sum是identity，item是索引为0位置的数据。// 后面轮次的sum是上一轮次计算的结果。item的索引依次加一。第三种形式123&lt;U&gt; U reduce(U identity, BiFunction&lt;U, ? super T, U&gt; accumulator, BinaryOperator&lt;U&gt; combiner);Performs a reduction on the elements of this stream, using the provided identity, accumulation and combining functions. This is equivalent to:12345&gt; U result = identity;&gt; for (T element : this stream)&gt; result = accumulator.apply(result, element)&gt; return result;&gt;but is not constrained to execute sequentially. The identity value must be an identity for the combiner function. This means that for all u, combiner(identity, u) is equal to u. Additionally, the combiner function must be compatible with the accumulator function; for all u and t, the following must hold:12&gt; combiner.apply(u, accumulator.apply(identity, t)) == accumulator.apply(u, t)&gt;This is a terminal operation.第三种形式相对于第二种形式多了一个参数，这个参数是BinaryOperator接收两个参数，返回一个值，这三个数据是相同类型的。实际上这个参数是用于支持并发操作的。collectAPI介绍reduce()擅长的是生成一个值，如果想要从Stream生成一个集合或者Map等复杂的对象该怎么办呢？就需要用到collect()了，也就是说它可以把Stream中的要有元素收集到一个结果容器中。其有两种重载的方法：123&lt;R&gt; R collect(Supplier&lt;R&gt; supplier, BiConsumer&lt;R, ? super T&gt; accumulator, BiConsumer&lt;R, R&gt; combiner);Performs a mutable reduction operation on the elements of this stream. A mutable reduction is one in which the reduced value is a mutable result container, such as an ArrayList, and elements are incorporated（合并） by updating the state of the result rather than by replacing the result. This produces a result equivalent to:12345&gt; R result = supplier.get();&gt; for (T element : this stream)&gt; accumulator.accept(result, element);&gt; return result;&gt;Like reduce(Object, BinaryOperator), collect operations can be parallelized without requiring additional synchronization. This is a terminal operation.1&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector);Performs a mutable reduction operation on the elements of this stream using a Collector. A Collector encapsulates the functions used as arguments to collect(Supplier, BiConsumer, BiConsumer), allowing for reuse of collection strategies and composition of collect operations such as multiple-level grouping or partitioning.在不使用API之前我们先考虑一下将一个Stream转换成一个容器（或者Map）需要做哪些工作？至少需要两样东西吧：目标容器是什么？是ArrayList还是HashSet，或者是个TreeMap。新元素如何添加到容器中？是List.add()还是Map.put()。如果并行的进行规约，还需要告诉collect()多个部分结果如何合并成一个。结合以上分析，collect()方法定义为R collect(Supplier supplier, BiConsumer accumulator, BiConsumer combiner)，三个参数依次对应上述三条分析。不过每次调用collect()都要传入这三个参数太麻烦，收集器Collector就是对这三个参数的简单封装，所以collect()的另一定义为R collect(Collector collector)。Collectors工具类可通过静态方法生成各种常用的Collector。举例来说，如果要将Stream规约成List可以通过如下两种方式实现：123456// 将Stream规约成ListStream&lt;String&gt; stream = Stream.of("I", "love", "you", "too");List&lt;String&gt; list = stream.collect(ArrayList::new, ArrayList::add, ArrayList::addAll); // 方式１// List&lt;String&gt; list = stream.collect(Collectors.toList()); // 方式2System.out.println(list);通常情况下我们不需要手动指定collect()的三个参数，而是调用collect(Collector collector)方法，并且参数中的Collector对象大都是直接通过Collectors工具类获得。实际上传入的收集器的行为决定了collect()的行为。使用collect()生成Collection前面已经提到通过collect()方法将Stream转换成容器的方法，这里再汇总一下。将Stream转换成List或Set是比较常见的操作，所以Collectors工具已经为我们提供了对应的收集器，通过如下代码即可完成：1234// 将Stream转换成List或SetStream&lt;String&gt; stream = Stream.of("I", "love", "you", "too");List&lt;String&gt; list = stream.collect(Collectors.toList()); // 1Set&lt;String&gt; set = stream.collect(Collectors.toSet()); // 2上述代码能够满足大部分需求，但由于返回结果是接口类型，我们并不知道类库实际选择的容器类型是什么，有时候我们可能会想要人为指定容器的实际类型，这个需求可通过Collectors.toCollection(Supplier collectionFactory)方法完成。123// 使用toCollection()指定规约容器的类型ArrayList&lt;String&gt; arrayList = stream.collect(Collectors.toCollection(ArrayList::new)); // 3HashSet&lt;String&gt; hashSet = stream.collect(Collectors.toCollection(HashSet::new)); // 4上述代码第2行处指定规约结果是ArrayList，而第三行处指定规约结果为HashSet。一切如你所愿。我们下面看一个笛卡尔积的例子。123456789101112131415public static void main(String[] args) &#123; List&lt;String&gt; list1 = Arrays.asList("Hi", "Hello"); List&lt;String&gt; list2 = Arrays.asList("zhangsan", "lisi", "wangwu"); List&lt;String&gt; result = list1.stream() .flatMap(item -&gt; list2.stream().map(item2 -&gt; item + " " + item2)) .collect(Collectors.toList()); result.forEach(System.out::println);&#125;// Hi zhangsan// Hi lisi// Hi wangwu// Hello zhangsan// Hello lisi// Hello wangwu分析这个例子我们先看map和flatMap的区别：1234Stream&lt;Stream&lt;String&gt;&gt; streamStream = list1.stream().map(item -&gt; list2.stream().map(item2 -&gt; item + " " + item2));Stream&lt;String&gt; stream = list1.stream().flatMap(item -&gt; list2.stream().map(item2 -&gt; item + " " + item2));我们会发现，flatMap()的作用就是我们刚才说的将多个Stream摊平。然后我们再分析就会发现，其实这就是一个双层循环，我们再内层循环中，返回了一个Stream，在外层循环中将多个Stream合在一起。我们类比着，做一个三层循环：12345678910111213141516171819List&lt;String&gt; result = list1.stream() .flatMap(item1 -&gt; list2.stream() .flatMap(item2 -&gt; list3.stream() .map(item3 -&gt; item1 + "" + item2 + " " + item3))) .collect(Collectors.toList());result.forEach(System.out::println);// Hizhangsan a// Hizhangsan b// Hilisi a// Hilisi b// Hiwangwu a// Hiwangwu b// Hellozhangsan a// Hellozhangsan b// Hellolisi a// Hellolisi b// Hellowangwu a// Hellowangwu b使用collect()生成Map前面已经说过Stream背后依赖于某种数据源，数据源可以是数组、容器等，但不能是Map。反过来从Stream生成Map是可以的，但我们要想清楚Map的key和value分别代表什么，根本原因是我们要想清楚要干什么。通常在三种情况下collect()的结果会是Map：使用Collectors.toMap()生成的收集器，用户需要指定如何生成Map的key和value。使用Collectors.partitioningBy()生成的收集器，对元素进行二分区操作时用到。使用Collectors.groupingBy()生成的收集器，对元素做group操作时用到。12345678910111213141516171819202122232425262728293031323334353637383940public class Student &#123; private String name; private int score; private int age; public Student(String name, int score) &#123; this.name = name; this.score = score; &#125; public Student(String name, int score, int age) &#123; this.name = name; this.score = score; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getScore() &#123; return score; &#125; public void setScore(int score) &#123; this.score = score; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", score=" + score + ", age=" + age + '&#125;'; &#125;&#125;情况1：使用toMap()生成的收集器，这种情况是最直接的，这是和Collectors.toCollection()并列的方法。如下代码展示将学生列表转换成由&lt;学生，分数&gt;组成的Map。非常直观，无需多言。1234// 使用toMap()统计学生成绩Map&lt;Student, Integer&gt; studentToScore = students.stream().collect(Collectors.toMap(Function.identity(), // 如何生成key student -&gt; student.getScore())); // 如何生成value情况2：使用partitioningBy()生成的收集器，这种情况适用于将Stream中的元素依据某个二值逻辑（满足条件，或不满足）分成互补相交的两部分，比如男女性别、成绩及格与否等。12345678910111213141516Student student1 = new Student("zhangsan", 80);Student student2 = new Student("lisi", 90);Student student3 = new Student("wangwu", 100);Student student4 = new Student("zhaoliu", 90);Student student5 = new Student("zhaoliu", 90);List&lt;Student&gt; students = Arrays.asList(student1, student2, student3, student4);Map&lt;Boolean, List&lt;Student&gt;&gt; map = students.stream(). collect(Collectors.partitioningBy(student -&gt; student.getScore() &gt;= 90));// 对于结果为真部分的数据再次进行分区Map&lt;Boolean, Map&lt;Boolean, List&lt;Student&gt;&gt;&gt; map3 = students.stream().collect(partitioningBy(student -&gt; student.getScore() &gt; 80, partitioningBy(student -&gt; student.getScore() &gt; 90)));// &#123;false=&#123;false=[Student&#123;name='zhangsan', score=80, age=0&#125;], // true=[]&#125;, // true=&#123;false=[Student&#123;name='lisi', score=90, age=0&#125;, Student&#123;name='zhaoliu', score=90, age=0&#125;, Student&#123;name='zhaoliu', score=90, age=0&#125;], // true=[Student&#123;name='wangwu', score=100, age=0&#125;]&#125;&#125;情况3：使用groupingBy()生成的收集器，这是比较灵活的一种情况。跟SQL中的group by语句类似，这里的groupingBy()也是按照某个属性对数据进行分组，属性相同的元素会被对应到Map的同一个key上。1234Map&lt;String, List&lt;Student&gt;&gt; map = students.stream(). collect(Collectors.groupingBy(Student::getName));Map&lt;Integer, List&lt;Student&gt;&gt; map = students.stream(). collect(Collectors.groupingBy(Student::getScore));以上只是分组的最基本用法，有些时候仅仅分组是不够的。在SQL中使用group by是为了协助其他查询，比如先将员工按照部门分组然后统计每个部门员工的人数Java类库设计者也考虑到了这种情况，增强版的groupingBy()能够满足这种需求。增强版的groupingBy()允许我们对元素分组之后再执行某种运算，比如求和、计数、平均值、类型转换等。这种先将元素分组的收集器叫做上游收集器，之后执行其他运算的收集器叫做下游收集器(downstream Collector)。123456Map&lt;String, Long&gt; map = students.stream(). collect(Collectors.groupingBy(Student::getName, Collectors.counting())); // 下游收集器Map&lt;String, Double&gt; map = students.stream().collect(Collectors.groupingBy( Student::getName, Collectors.averagingDouble(Student::getScore))); // 下游收集器上面代码的逻辑是不是越看越像SQL？高度非结构化。还有更狠的，下游收集器还可以包含更下游的收集器。1234567Map&lt;Integer, Map&lt;String, List&lt;Student&gt;&gt;&gt; map = students.stream(). collect(groupingBy(Student::getScore, groupingBy(Student::getName)));// &#123;80=&#123;zhangsan=[Student&#123;name='zhangsan', score=80, age=0&#125;]&#125;, // 100=&#123;wangwu=[Student&#123;name='wangwu', score=100, age=0&#125;]&#125;, // 90=&#123;lisi=[Student&#123;name='lisi', score=90, age=0&#125;], // zhaoliu=[Student&#123;name='zhaoliu', score=90, age=0&#125;, Student&#123;name='zhaoliu', score=90, // age=0&#125;]&#125;&#125;使用collect()做字符串join这个肯定是大家喜闻乐见的功能，字符串拼接时使用Collectors.joining()生成的收集器，从此告别for循环。Collectors.joining()方法有三种重写形式，分别对应三种不同的拼接方式。无需多言，代码过目难忘。12345// 使用Collectors.joining()拼接字符串Stream&lt;String&gt; stream = Stream.of("I", "love", "you");//String joined = stream.collect(Collectors.joining()); // "Iloveyou"//String joined = stream.collect(Collectors.joining(",")); // "I,love,you"String joined = stream.collect(Collectors.joining(",", "&#123;", "&#125;")); // "&#123;I,love,you&#125;"collectingAndThen123456789// 获得每个姓名下的最低分，返回的是Optional，但实际上此时的最低分一定不为空Map&lt;String, Optional&lt;Student&gt;&gt; collect = students.stream().collect(groupingBy( Student::getName, minBy(Comparator.comparingInt(Student::getScore))));// 所以可以只用collectingAndThen，传入一个 FunctionMap&lt;String, Student&gt; map5 = students.stream().collect(groupingBy(Student::getName, collectingAndThen(minBy(Comparator.comparingInt(Student::getScore)), Optional::get)));// &#123;lisi=Student&#123;name='lisi', score=90, age=0&#125;, // zhaoliu=Student&#123;name='zhaoliu', score=90, age=0&#125;, // zhangsan=Student&#123;name='zhangsan', score=80, age=0&#125;, // wangwu=Student&#123;name='wangwu', score=100, age=0&#125;&#125;CollectorA mutable reduction operation that accumulates input elements into a mutable result container, optionally transforming the accumulated result into a final representation after all input elements have been processed. Reduction operations can be performed either sequentially or in parallel.Examples of mutable reduction operations include: accumulating elements into a Collection; concatenating strings using a StringBuilder; computing summary information about elements such as sum, min, max, or average; computing “pivot table” summaries such as “maximum valued transaction by seller”, etc. The class Collectors provides implementations of many common mutable reductions.A reduction operation (also called a fold) takes a sequence of input elements and combines them into a single summary result by repeated application of a combining operation, such as finding the sum or maximum of a set of numbers, or accumulating elements into a list.A mutable reduction operation accumulates input elements into a mutable result container, such as a Collection or StringBuilder, as it processes the elements in the stream.A Collector is specified by four functions that work together to accumulate entries into a mutable result container, and optionally perform a final transform on the result. They are:creation of a new result container (supplier())incorporating a new data element into a result container (accumulator())combining two result containers into one (combiner())performing an optional final transform on the container (finisher())对于函数combiner()，JDK对其注释如下：A function that accepts two partial results and merges them. The combiner function may fold state from one argument into the other and return that, or may return a new result container.我们举个例子来看这个函数：假如有四个线程同时执行一次聚合，此次聚合的结果是生成一个集合，那么四个线程就会产生四个结果集合。此时这个函数便要发挥作用，他需要将四个结果集合合并成为一个，那么此时可以有两种做法，一是再生成一个新的集合，将四个结果集合都加入这个集合，再返回。二是将第二个结果集合加入第一个结果集合，然后返回第一个集合再去，然后再去和第三个集合合并，此时我们就说第二个结果集合被fold了。这个方法会在线程安全的情况下被调用，即使开发者没有执行并发安全操作。它的核心用处就是在并行流的环境中将多个部分结果合成一个结果返回。Collectors also have a set of characteristics, such as Collector.Characteristics.CONCURRENT, that provide hints that can be used by a reduction implementation to provide better performance.A sequential implementation of a reduction using a collector would create a single result container using the supplier function, and invoke the accumulator function once for each input element. A parallel implementation would partition the input, create a result container for each partition, accumulate the contents of each partition into a subresult for that partition, and then use the combiner function to merge the subresults into a combined result.To ensure that sequential and parallel executions produce equivalent results, the collector functions must satisfy an identity and an associativity constraints.The identity constraint says that for any partially accumulated result, combining it with an empty result container must produce an equivalent result. That is, for a partially accumulated result a that is the result of any series of accumulator and combiner invocations, a must be equivalent to combiner.apply(a, supplier.get()).identity可以翻译为”同一性“，这个性质就是说对于任何一个中间结果，当combiner.apply(a, supplier.get())被调用后时必须等价于a（等价于可能是=，也可能是equal，需要根据业务来算）。The associativity constraint says that splitting the computation must produce an equivalent result. That is, for any input elements t1 and t2, the results r1 and r2 in the computation below must be equivalent:1234567891011&gt; A a1 = supplier.get();&gt; accumulator.accept(a1, t1);&gt; accumulator.accept(a1, t2);&gt; R r1 = finisher.apply(a1); // result without splitting&gt; &gt; A a2 = supplier.get();&gt; accumulator.accept(a2, t1);&gt; A a3 = supplier.get();&gt; accumulator.accept(a3, t2);&gt; R r2 = finisher.apply(combiner.apply(a2, a3)); // result with splitting&gt;上面的代码就是在说将一系列的操作串行执行和将操作分割执行之后再合并应该保持一致。For collectors that do not have the UNORDERED characteristic, two accumulated results a1 and a2 are equivalent if finisher.apply(a1).equals(finisher.apply(a2)). For unordered collectors, equivalence is relaxed to allow for non-equality related to differences in order. (For example, an unordered collector that accumulated elements to a List would consider two lists equivalent if they contained the same elements, ignoring order.)两个结果a1，a2是否等价的逻辑值应该和finisher.apply(a1).equals(finisher.apply(a2))一致。但是对于具有无序特征的情况下，不考虑容器中的元素顺序。Libraries that implement reduction based on Collector, such as Stream.collect(Collector), must adhere to the following constraints:The first argument passed to the accumulator function, both arguments passed to the combiner function, and the argument passed to the finisher function must be the result of a previous invocation of the result supplier, accumulator, or combiner functions.这个实际上是在说累加器的第一个参数是容器的类型，组合器参数的类型是容器的类型。The implementation should not do anything with the result of any of the result supplier, accumulator, or combiner functions other than to pass them again to the accumulator, combiner, or finisher functions, or return them to the caller of the reduction operation.这个实际上是在说在collect的执行过程中所有的操作都应该来自supplier、accumulator、combiner。If a result is passed to the combiner or finisher function, and the same object is not returned from that function, it is never used again.Once a result is passed to the combiner or finisher function, it is never passed to the accumulator function again.这个又有点fold的意思了，也就是旧的对象如果不作为返回值返回，他们的状态就会被折叠。For non-concurrent collectors, any result returned from the result supplier, accumulator, or combiner functions must be serially thread-confined. This enables collection to occur in parallel without the Collector needing to implement any additional synchronization. The reduction implementation must manage that the input is properly partitioned, that partitions are processed in isolation, and combining happens only after accumulation is complete.For concurrent collectors, an implementation is free to (but not required to) implement reduction concurrently. A concurrent reduction is one where the accumulator function is called concurrently from multiple threads, using the same concurrently-modifiable result container, rather than keeping the result isolated during accumulation. A concurrent reduction should only be applied if the collector has the Collector.Characteristics.UNORDERED characteristics or if the originating data is unordered.这两条很绕，分析之后会发现。它是在说非并发的收集器需要保证收三个函数的结果不被其他线程调用，这样就可以在并发的条件下无须额外的同步就可以使用。对于并发的收集器，并发操作应该是使用线程安全的容器在调用累加操作的时候保证的，而不是在累加操作的内部实现中保证的。In addition to the predefined implementations in Collectors, the static factory methods of(Supplier, BiConsumer, BinaryOperator, Characteristics…) can be used to construct collectors. For example, you could create a collector that accumulates widgets into a TreeSet with:1234&gt; Collector&lt;Widget, ?, TreeSet&lt;Widget&gt;&gt; intoSet =&gt; Collector.of(TreeSet::new, TreeSet::add,&gt; (left, right) -&gt; &#123; left.addAll(right); return left; &#125;);&gt;(This behavior is also implemented by the predefined collector Collectors.toCollection(Supplier)).apiNote：Performing a reduction operation with a Collector should produce a result equivalent to:12345&gt; R container = collector.supplier().get();&gt; for (T t : data)&gt; collector.accumulator().accept(container, t);&gt; return collector.finisher().apply(container);&gt;However, the library is free to partition the input, perform the reduction on the partitions, and then use the combiner function to combine the partial results to achieve a parallel reduction. (Depending on the specific reduction operation, this may perform better or worse, depending on the relative cost of the accumulator and combiner functions.)Collectors are designed to be composed; many of the methods in Collectors are functions that take a collector and produce a new collector. For example, given the following collector that computes the sum of the salaries of a stream of employees:123&gt; Collector&lt;Employee, ?, Integer&gt; summingSalaries&gt; = Collectors.summingInt(Employee::getSalary))&gt;If we wanted to create a collector to tabulate the sum of salaries by department, we could reuse the “sum of salaries” logic using Collectors.groupingBy(Function, Collector):123&gt; Collector&lt;Employee, ?, Map&lt;Department, Integer&gt;&gt; summingSalariesByDept&gt; = Collectors.groupingBy(Employee::getDepartment, summingSalaries);&gt;自定义收集器自定义一个收集器，我们需要实现Collector接口。Collector接口的三个泛型参数分别表示集合中元素的类型，集合的类型和返回值的类型。我们再看五个待实现的方法。12345Supplier&lt;A&gt; supplier();BiConsumer&lt;A, T&gt; accumulator();BinaryOperator&lt;A&gt; combiner();Function&lt;A, R&gt; finisher();Set&lt;Characteristics&gt; characteristics();supplier、accumulator、combiner之前已经介绍的很详细了。finisher的作用是将中间容器的类型转为最终的结果类型。中间容器的类型也就是三个泛型中的集合的类型，结果类型也就是三个泛型中的返回值的类型。而对于characteristics是标识这个收集器的特性。它是使用枚举来做的。12345678910111213141516171819202122232425enum Characteristics &#123; /** * Indicates that this collector is &lt;em&gt;concurrent&lt;/em&gt;, meaning that * the result container can support the accumulator function being * called concurrently with the same result container from multiple * threads. * * &lt;p&gt;If a &#123;@code CONCURRENT&#125; collector is not also &#123;@code UNORDERED&#125;, * then it should only be evaluated concurrently if applied to an * unordered data source. */ CONCURRENT, /** * Indicates that the collection operation does not commit to preserving * the encounter order of input elements. (This might be true if the * result container has no intrinsic order, such as a &#123;@link Set&#125;.) */ UNORDERED, /** * Indicates that the finisher function is the identity function and * can be elided. If set, it must be the case that an unchecked cast * from A to R will succeed. */ IDENTITY_FINISH&#125;UNORDERED：如果流中输入的元素和最终返回的元素顺序不一致，需要标志上这个特性。比如讲一个List转为一个Set，Set中元素的顺序不保证和List一致。IDENTITY_FINISH：如果中间结果的类型和最终返回的类型一致，标志上这个特性之finisher就不会被调用，而是使用强制转换的方式来将中间结果的容器转为最终结果。下面是一个使用自定义收集器将List转为Set的案例，中间容器的类型和结果容器的类型一致。123456789101112131415161718192021222324252627282930313233343536public class MySetCollector&lt;T&gt; implements Collector&lt;T, Set&lt;T&gt;, Set&lt;T&gt;&gt;&#123; @Override public Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123; System.out.println("supplier invoked!"); return HashSet::new; &#125; @Override public BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123; System.out.println("accumulator invoked!"); return Set::add; &#125; @Override public BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123; System.out.println("combiner invoked!"); return (set1, set2) -&gt; &#123; set1.addAll(set2); return set1; &#125;; &#125; @Override public Function&lt;Set&lt;T&gt;, Set&lt;T&gt;&gt; finisher() &#123;// System.out.println("finisher invoked!");// return Function.identity(); throw new UnsupportedOperationException(); &#125; @Override public Set&lt;Characteristics&gt; characteristics() &#123; System.out.println("characteristics invoked!"); return Collections.unmodifiableSet(EnumSet.of(IDENTITY_FINISH, UNORDERED)); &#125; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList("hello", "world", "welcome", "hello"); Set&lt;String&gt; set = list.stream().collect(new MySetCollector&lt;&gt;()); System.out.println(set); &#125;&#125;下面是一个中间容器和最终结果容器不一致的情况：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class MySetCollector2&lt;T&gt; implements Collector&lt;T, Set&lt;T&gt;, Map&lt;T, T&gt;&gt; &#123; @Override public Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123; System.out.println("supplier invoked!"); return HashSet&lt;T&gt;::new; &#125; @Override public BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123; System.out.println("accumulator invoked!"); return (set, item) -&gt; &#123; set.add(item); &#125;; &#125; @Override public BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123; System.out.println("combiner invoked!"); return (set1, set2) -&gt; &#123; set1.addAll(set2); return set1; &#125;; &#125; @Override public Function&lt;Set&lt;T&gt;, Map&lt;T, T&gt;&gt; finisher() &#123; System.out.println("finisher invoked!"); return set -&gt; &#123; Map&lt;T, T&gt; map = new TreeMap&lt;&gt;(); set.stream().forEach(item -&gt; map.put(item, item)); return map; &#125;; &#125; @Override public Set&lt;Characteristics&gt; characteristics() &#123; System.out.println("characteristics invoked!"); return Collections.unmodifiableSet(EnumSet.of(Characteristics.UNORDERED)); &#125; public static void main(String[] args) &#123; System.out.println(Runtime.getRuntime().availableProcessors()); for(int i = 0; i &lt; 1; ++i) &#123; List&lt;String&gt; list = Arrays.asList( "hello", "world", "welcome", "hello", "a", "b", "c", "d", "e", "f", "g"); Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.addAll(list); System.out.println("set: " + set); Map&lt;String, String&gt; map = set.stream().collect(new MySetCollector2&lt;&gt;()); System.out.println(map); &#125; &#125;&#125;对于CONCURRENT，是指在并行流的情况下多个结果会去操作一个容器。如果不加上这个特性，并行流的情况下是多个线程各自操作一个容器。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class MySetCollector2&lt;T&gt; implements Collector&lt;T, Set&lt;T&gt;, Map&lt;T, T&gt;&gt; &#123; @Override public Supplier&lt;Set&lt;T&gt;&gt; supplier() &#123; System.out.println("supplier invoked!"); return () -&gt; &#123; System.out.println("-----------"); return new HashSet&lt;T&gt;(); &#125;; &#125; @Override public BiConsumer&lt;Set&lt;T&gt;, T&gt; accumulator() &#123; System.out.println("accumulator invoked!"); return (set, item) -&gt; &#123; System.out.println("accumulator: " + set + ", " + Thread.currentThread().getName()); set.add(item); &#125;; &#125; @Override public BinaryOperator&lt;Set&lt;T&gt;&gt; combiner() &#123; System.out.println("combiner invoked!"); return (set1, set2) -&gt; &#123; System.out.println("set1: " + set1); System.out.println("set2: " + set2); set1.addAll(set2); return set1; &#125;; &#125; @Override public Function&lt;Set&lt;T&gt;, Map&lt;T, T&gt;&gt; finisher() &#123; System.out.println("finisher invoked!"); return set -&gt; &#123; Map&lt;T, T&gt; map = new TreeMap&lt;&gt;(); set.stream().forEach(item -&gt; map.put(item, item)); return map; &#125;; &#125; @Override public Set&lt;Characteristics&gt; characteristics() &#123; System.out.println("characteristics invoked!"); return Collections.unmodifiableSet( EnumSet.of(Characteristics.UNORDERED, Characteristics.CONCURRENT)); &#125; public static void main(String[] args) &#123; for(int i = 0; i &lt; 1; ++i) &#123; List&lt;String&gt; list = Arrays.asList( "hello", "world", "welcome", "hello", "a", "b", "c", "d", "e", "f", "g"); Set&lt;String&gt; set = new HashSet&lt;&gt;(); set.addAll(list); System.out.println("set: " + set); Map&lt;String, String&gt; map = set.parallelStream().collect(new MySetCollector2&lt;&gt;()); System.out.println(map); &#125; &#125;&#125;所以在并行流的环境中如果加上了CONCURRENT，只会生成一个容器，而且此时后期不需要调用combiner，上面的代码在不抛出并行修改异常的时候会作如下输出：123456789101112131415161718198set: [a, b, world, c, d, e, f, g, hello, welcome]characteristics invoked!supplier invoked!-----------accumulator invoked!accumulator: [], mainaccumulator: [hello], mainaccumulator: [hello], ForkJoinPool.commonPool-worker-1accumulator: [hello, welcome], ForkJoinPool.commonPool-worker-4accumulator: [hello, welcome], ForkJoinPool.commonPool-worker-3accumulator: [hello, welcome], mainaccumulator: [a, b, d, f, hello, welcome], mainaccumulator: [a, b, d, hello, welcome], ForkJoinPool.commonPool-worker-3accumulator: [d, hello, welcome], ForkJoinPool.commonPool-worker-1accumulator: [a, b, world, d, f, g, hello, welcome], ForkJoinPool.commonPool-worker-3characteristics invoked!finisher invoked!&#123;a=a, b=b, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome, world=world&#125;如果不加上CONCURRENT，由于操作的是多个容器，会调用多次combiner。1234567891011121314151617181920212223242526272829303132333435363738394041428set: [a, b, world, c, d, e, f, g, hello, welcome]characteristics invoked!supplier invoked!accumulator invoked!combiner invoked!characteristics invoked!--------------------------------------------accumulator: [], mainaccumulator: [], ForkJoinPool.commonPool-worker-3-----------accumulator: [], ForkJoinPool.commonPool-worker-4accumulator: [], ForkJoinPool.commonPool-worker-1----------------------accumulator: [], ForkJoinPool.commonPool-worker-5accumulator: [b], ForkJoinPool.commonPool-worker-3accumulator: [f], ForkJoinPool.commonPool-worker-5set1: []accumulator: [], ForkJoinPool.commonPool-worker-4-----------accumulator: [d], ForkJoinPool.commonPool-worker-1set1: [welcome]set2: []set2: [hello]accumulator: [b, world], ForkJoinPool.commonPool-worker-3set1: [hello]set1: [d, e]set2: [welcome]set1: [a]set2: [f, g]set2: [b, world, c]set1: [a, b, world, c]set2: [d, e, f, g]set1: [a, b, world, c, d, e, f, g]set2: [hello, welcome]characteristics invoked!finisher invoked!&#123;a=a, b=b, c=c, d=d, e=e, f=f, g=g, hello=hello, welcome=welcome, world=world&#125;从结果中可以看出，生成了多个中间容器，执行了多次combiner。StreamA sequence of elements supporting sequential and parallel aggregate operations. The following example illustrates an aggregate operation using Stream and IntStream:12345&gt; int sum = widgets.stream()&gt; .filter(w -&gt; w.getColor() == RED)&gt; .mapToInt(w -&gt; w.getWeight())&gt; .sum();&gt;In this example, widgets is a Collection&lt;Widget&gt;. We create a stream of Widget objects via Collection.stream(), filter it to produce a stream containing only the red widgets, and then transform it into a stream of int values representing the weight of each red widget. Then this stream is summed to produce a total weight.In addition to Stream, which is a stream of object references, there are primitive specializations for IntStream, LongStream, and DoubleStream, all of which are referred to as “streams” and conform to the characteristics and restrictions described here.To perform a computation, stream operations are compose d into a stream pipeline. A stream pipeline consists of a source (which might be an array, a collection, a generator function, an I/O channel, etc), zero or more intermediate operations (which transform a stream into another stream, such as filter(Predicate)), and a terminal operation (which produces a result or side-effect, such as count() or forEach(Consumer)). Streams are lazy; computation on the source data is only performed when the terminal operation is initiated, and source elements are consumed only as needed.side-effect指的是在流执行过程中可对源数据的状态做出修改。side-effect是不被推荐使用的。123ArrayList&lt;String&gt; results = new ArrayList&lt;&gt;();stream.filter(s -&gt; pattern.matcher(s).matches()) .forEach(s -&gt; results.add(s)); // Unnecessary use of side-effects!Collections and streams, while bearing some superficial similarities, have different goals. Collections are primarily concerned with the efficient management of, and access to, their elements. By contrast, streams do not provide a means to directly access or manipulate their elements, and are instead concerned with declaratively describing their source and the computational operations which will be performed in aggregate on that source. However, if the provided stream operations do not offer the desired functionality, the iterator() and spliterator() operations can be used to perform a controlled traversal.JDK8的Collection中多了一个方法：Spliterator&lt;E&gt; spliterator()。翻译为分割迭代器，顾名思义，这个方法是获得一个迭代器，而为什么不是返回iterator，而是要新创建一个类呢？这是为流的并行做准备，如果使用iterator，它是使用hasNext和next顺序遍历的，不方便我们将流直接分割成差不多的两部分。所以就引入了Spliterator。A stream pipeline, like the “widgets” example above, can be viewed as a query on the stream source. Unless the source was explicitly designed for concurrent modification (such as a ConcurrentHashMap), unpredictable or erroneous behavior may result from modifying the stream source while it is being queried.Most stream operations accept parameters that describe user-specified behavior, such as the lambda expression w -&gt; w.getWeight() passed to mapToInt in the example above. To preserve correct behavior, these behavioral parameters:must be non-interfering (they do not modify the stream source); andin most cases must be stateless (their result should not depend on any state that might change during execution of the stream pipeline).如果源数据不是支持并发的容器，不要在流的执行期间修改源数据。否则会导致异常。但是在流执行之前修改是可以的。1234List&lt;String&gt; l = new ArrayList(Arrays.asList("one", "two"));Stream&lt;String&gt; sl = l.stream();l.add("three");String s = sl.collect(joining(" "));Such parameters are always instances of a functional interface such as Function, and are often lambda expressions or method references. Unless otherwise specified these parameters must be non-null.A stream should be operated on (invoking an intermediate or terminal stream operation) only once. This rules out, for example, “forked” streams, where the same source feeds two or more pipelines, or multiple traversals of the same stream. A stream implementation may throw IllegalStateException if it detects that the stream is being reused. However, since some stream operations may return their receiver rather than a new stream object, it may not be possible to detect reuse in all cases.Streams have a close() method and implement AutoCloseable, but nearly all stream instances do not actually need to be closed after use. Generally, only streams whose source is an IO channel (such as those returned by Files.lines(Path, Charset)) will require closing. Most streams are backed by collections, arrays, or generating functions, which require no special resource management. (If a stream does require closing, it can be declared as a resource in a try-with-resources statement.)Stream pipelines may execute either sequentially or in parallel. This execution mode is a property of the stream. Streams are created with an initial choice of sequential or parallel execution. (For example, Collection.stream() creates a sequential stream, and Collection.parallelStream() creates a parallel one.) This choice of execution mode may be modified by the sequential() or parallel() methods, and may be queried with the isParallel() method.]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.04-JavaSE-Java8-1]]></title>
    <url>%2Fposts%2F24220.html%2F</url>
    <content type="text"><![CDATA[初识Lambda在Java中，我们只能传递和返回值，而无法将函数作为参数传递给一个方法，也无法声明返回一个函数的方法。所以在代码中，我们不能传递一个行为，只能将行为包装成为一个对象来进行传递。比如下面的Swing：1234567891011121314public static void main(String[] args) &#123; JFrame jFrame = new JFrame("My JFrame"); JButton jButton = new JButton("JButton"); jButton.addActionListener(new ActionListener() &#123; @Override public void actionPerformed(ActionEvent e) &#123; System.out.println("Button Pressed! "); &#125; &#125;); jFrame.add(jButton); jFrame.pack(); jFrame.setVisible(true); jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#125;对于上面的代码，我们实际上不需要new ActionListener()、actionPerformed等等，我们只需要sout这个行为。传统的匿名内部类却必须需要构建一个对象传入。而Lambda表达式便可以直接的传递一个行为进去。123456789101112public static void main(String[] args) &#123; JFrame jFrame = new JFrame("My JFrame"); JButton jButton = new JButton("JButton"); // 单行直接写，多行使用花括号&#123;&#125;括起来 // event 全写是 ActionEvent envent，即全写：(ActionEvent event) -&gt; sout // 这里只写event是因为Java的编译系统能推断出来这个地方的event就是Action Event jButton.addActionListener(event -&gt; System.out.println("Button Pressed! ")); jFrame.add(jButton); jFrame.pack(); jFrame.setVisible(true); jFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);&#125;函数式接口一个接口中只有一个抽象方法就被叫做抽象接口。如果一个接口只有一个抽象方法，他就是一个函数式接口。如果我们在接口上声明了@FunctionalInterface，编译期会按函数式接口的定义来要求他，如果不满足函数式接口的定义，编译期会报错。如果某个接口只有一个函数式接口，即使没有加@FunctionalInterface，编译器也将其看成函数式接口。如果某个接口覆盖了Object中的方法，那么此接口的抽象方法不会加一，如以下代码：1234567@FunctionalInterfacepublic interface MyTest2 &#123; void test(); // 不会报错， @Override boolean equals(Object obj);&#125;注意：在函数作为一等公民的语言中，函数被看做类型，而在Java中，Lambda表达式是对象，他们必须依附一类特别的对象类型 - 函数式接口。Lambda的一个小例子12345678910111213141516171819// 使用Lambda完成集合的遍历public class MyTest1 &#123; public static void main(String[] args) &#123; List&lt;String&gt; list = Arrays.asList("abc", "test", "hello"); // 匿名内部类完成遍历 list.forEach(new Consumer&lt;String&gt;() &#123; @Override public void accept(String string) &#123; System.out.println(string); &#125; &#125;); // lambda expressions list.forEach(item -&gt; System.out.println(item)); // method references list.forEach(System.out::println); &#125;&#125;Lambda基本语法Lambda 表达式的语法格式如下：123(parameters) -&gt; expression或(parameters) -&gt;&#123; statements; &#125;以下是lambda表达式的重要特征：可选类型声明：不需要声明参数类型，编译器可以统一识别参数值。可选的参数圆括号：一个参数无需定义圆括号，但多个参数需要定义圆括号。可选的大括号：如果主体包含了一个语句，就不需要使用大括号。可选的返回关键字：如果主体只有一个表达式返回值则编译器会自动返回值，如果使用了大括号需要指定表达式返回了一个数值。1234567891011121314151617181920212223242526272829303132public static void main(String args[]) &#123; Java8Tester tester = new Java8Tester(); // 类型声明 MathOperation addition = (int a, int b) -&gt; a + b; // 不用类型声明 MathOperation subtraction = (a, b) -&gt; a - b; // 大括号中的返回语句 MathOperation multiplication = (int a, int b) -&gt; &#123; return a * b; &#125;; // 没有大括号及返回语句 MathOperation division = (int a, int b) -&gt; a / b; System.out.println("10 + 5 = " + tester.operate(10, 5, addition)); System.out.println("10 - 5 = " + tester.operate(10, 5, subtraction)); System.out.println("10 x 5 = " + tester.operate(10, 5, multiplication)); System.out.println("10 / 5 = " + tester.operate(10, 5, division)); // 不用括号 GreetingService greetService1 = message -&gt; System.out.println("Hello " + message); // 用括号 GreetingService greetService2 = (message) -&gt; System.out.println("Hello " + message); greetService1.sayMessage("Runoob"); greetService2.sayMessage("Google");&#125;interface MathOperation &#123; int operation(int a, int b);&#125;interface GreetingService &#123; void sayMessage(String message);&#125;private int operate(int a, int b, MathOperation mathOperation) &#123; return mathOperation.operation(a, b);&#125;变量作用域Lambda 表达式只能引用标记了 final 的外层局部变量，这就是说不能在 Lambda 内部修改定义在域外的局部变量，否则会编译错误。1234567891011121314151617181920212223public class Java8Tester &#123; final static String salutation = "Hello! "; public static void main(String args[]) &#123; GreetingService greetService1 = message -&gt; System.out.println(salutation + message); greetService1.sayMessage("Runoob"); int num = 1; Converter&lt;Integer, String&gt; s = (param) -&gt; String.valueOf(param + num); System.out.println(s.convert(2));// num = 5; // 此行导致上面的Lambda表达式报错，因为Lambda表达式引用的外面的变量必须是effective final的// 在 Lambda 表达式当中不允许声明一个与局部变量同名的参数或者局部变量 String first = "";// Comparator&lt;String&gt; comparator = (first, second) -&gt; // Integer.compare(first.length(), second.length()); // 编译会出错 &#125; interface GreetingService &#123; void sayMessage(String message); &#125; public interface Converter&lt;T1, T2&gt; &#123; String convert(int i); &#125;&#125;四个重要的函数式接口JDK8提供了四个重要的函数式接口：函数型接口、断言型接口、消费型接口、提供型接口。Function&lt;T, R&gt;Represents a function that accepts one argument and produces a result. This is a functional interface whose functional method is R apply(T t).apply(Object)1234567891011121314public class FunctionTest &#123; private static FunctionTest functionTest = new FunctionTest(); public static void main(String[] args) &#123; // 传入的是一个行为，这个行为就是一个映射，从输入参数到返回值的映射 System.out.println(functionTest.compute(1, integer -&gt; integer + 1)); System.out.println(functionTest.convert(1, integer -&gt; String.valueOf(integer))); &#125; int compute(int a, Function&lt;Integer, Integer&gt; function) &#123; return function.apply(a); &#125; public String convert(int a, Function&lt;Integer, String&gt; function) &#123; return function.apply(a); &#125;&#125;compose &amp; andThen1234default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v));&#125;Returns a composed function that first applies the before function to its input, and then applies this function to the result. If evaluation of either function throws an exception, it is relayed to the caller of the composed function.1234default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) &#123; Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t));&#125;Returns a composed function that first applies this function to its input, and then applies the after function to the result. If evaluation of either function throws an exception, it is relayed to the caller of the composed function.测试代码：123456789101112131415public class FunctionTest2 &#123; static FunctionTest2 functionTest2 = new FunctionTest2(); public static void main(String[] args) &#123; System.out.println(functionTest2.compute1 (2, value -&gt; value * 3, value -&gt; value * value)); // 12 System.out.println(functionTest2.compute2 (2, value -&gt; value * 3, value -&gt; value * value)); // 36 &#125; int compute1(int a, Function&lt;Integer, Integer&gt; f1, Function&lt;Integer, Integer&gt; f2) &#123; return f1.compose(f2).apply(a); &#125; int compute2(int a, Function&lt;Integer, Integer&gt; f1, Function&lt;Integer, Integer&gt; f2)&#123; return f1.andThen(f2).apply(a); &#125;&#125;compose分析：123456// 我们先把这个扩充一下compose方法扩充一下default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); // 我们先把这个扩充一下，这样便可以清楚的看见，先调用before的apply，再调用自身的apply return (V v) -&gt; Function.this.apply(before.apply(v));&#125;123456789101112131415161718// 我们再改写一下调用方public static void main(String[] args) &#123; System.out.println(functionTest2.compute1 (2, value -&gt; value * 3, value -&gt; value * value));&#125;int compute1(int a, Function&lt;Integer, Integer&gt; f1, Function&lt;Integer, Integer&gt; f2) &#123; System.out.println("f1: " + f1); System.out.println("f2: " + f2); Function&lt;Integer, Integer&gt; compose = f1.compose(f2); System.out.println("compose: " + compose); return compose.apply(a);&#125;// f1: jdk8.FunctionTest2$$Lambda$1/471910020@816f27d// f2: jdk8.FunctionTest2$$Lambda$2/303563356@87aac27// compose: jdk8.Function$1@3e3abc88// 我们最终应用的是apply是compose里面的apply方法// 而apply方法是由compose方法获得的：return (V v) -&gt; Function.this.apply(before.apply(v));// 这个before很明显就是f2，但是Function.this是什么？compose还是f1？1234567891011121314151617181920212223// 我们改写一个Functionpublic interface Function&lt;T, R&gt; &#123; R apply(T t); default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) &#123; Objects.requireNonNull(before); System.out.println(this); // Lambda表达式可以由内部类替换 return new Function&lt;V, R&gt;() &#123; @Override public R apply(V v) &#123; System.out.println(this); System.out.println(Function.this); return Function.this.apply(before.apply(v)); &#125; &#125;; &#125;&#125;// jdk8.FunctionTest2$$Lambda$1/471910020@816f27d// jdk8.Function$1@3e3abc88// jdk8.FunctionTest2$$Lambda$1/471910020@816f27d// 从输出中可以看到Function.this是我们的f1// new Function的时候创建的是一个内部类，而Function.this是一个外部类对象// 实际上，new Function的外部类对象就是第8行的this，也就是f112345return (V v) -&gt; apply(before.apply(v));// 如果上面的expression形式的Lambda表达式太绕，换成下面statements形式的的就好理解了。return (V v) -&gt; &#123; return apply(before.apply(v));&#125;;andThen方法的分析和compose一致。BiFunction\&lt;T, U, R>Represents a function that accepts two arguments and produces a result. R apply(T t, U u);T表示第一个输入的参数的类型，U表示第二个输入的参数的类型。R表示返回类型。12345678910111213141516public class BiFunctionTest &#123; public static void main(String[] args) &#123; System.out.println(compute1(2, 1, (a, b) -&gt; a + b)); // 3 System.out.println(compute1(2, 1, (a, b) -&gt; a - b)); // 1 System.out.println(compute1(2, 1, (a, b) -&gt; a * b)); // 2 System.out.println(compute1(2, 1, (a, b) -&gt; a / b)); // 2 System.out.println(compute2(2, 3, (a, b) -&gt; a + b, a -&gt; a * a)); // 25 &#125; static int compute1(int a, int b, BiFunction&lt;Integer, Integer, Integer&gt; bf) &#123; return bf.apply(a, b); &#125; static int compute2(int a, int b, BiFunction&lt;Integer, Integer, Integer&gt; bf, Function&lt;Integer, Integer&gt; f) &#123; return f.apply(bf.apply(a, b)); &#125;&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class BiFunctionTest &#123; public static void main(String[] args) &#123; Person p1 = new Person("zhangsan", 12); Person p2 = new Person("lisi", 13); Person p3 = new Person("wangwu", 14); List&lt;Person&gt; list = Arrays.asList(p1, p2, p3); // 过滤年龄等于13的 System.out.println(getPersonList(13, list, (age, persons) -&gt; persons.stream().filter( person -&gt; age == person.getAge()).collect(Collectors.toList()))); // 过滤年龄大于13的 System.out.println(getPersonList(13, list, (age, persons) -&gt; persons.stream().filter( person -&gt; age &lt; person.getAge()).collect(Collectors.toList()))); // 过滤年龄小于13的 System.out.println(getPersonList(13, list, (age, persons) -&gt; persons.stream().filter( person -&gt; age &gt; person.getAge()).collect(Collectors.toList()))); &#125; static List&lt;Person&gt; getPersonList( int age, List&lt;Person&gt; persons, BiFunction&lt;Integer, List&lt;Person&gt;, List&lt;Person&gt;&gt; bf)&#123; return bf.apply(age, persons); &#125;&#125;class Person &#123; private String name; private int age; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person&#123;" + "name='" + name + '\'' + ", age=" + age + '&#125;'; &#125;&#125;// person = Person&#123;name='wangwu', age=34&#125;// [Person&#123;name='lisi', age=13&#125;, Person&#123;name='wangwu', age=14&#125;]// [Person&#123;name='lisi', age=13&#125;]// [Person&#123;name='wangwu', age=14&#125;]// [Person&#123;name='zhangsan', age=12&#125;]BinaryOperator\&lt;T> extends BiFunction\&lt;T,T,T>Represents an operation upon two operands of the same type, producing a result of the same type as the operands. This is a specialization of BiFunction for the case where the operands and the result are all of the same type.&lt;T&gt; BinaryOperator&lt;T&gt; minBy(Comparator&lt;? super T&gt; comparator)：Returns a BinaryOperator which returns the lesser of two elements according to the specified Comparator.&lt;T&gt; BinaryOperator&lt;T&gt; maxBy(Comparator&lt;? super T&gt; comparator)：Returns a BinaryOperator which returns the greater of two elements according to the specified Comparator.1234567891011121314151617181920212223242526public class BinaryOperatorTest &#123; public static void main(String[] args) &#123; System.out.println(getShort("hello123", "world", (a, b) -&gt; a.length() - b.length())); System.out.println(getShort("hello123", "world", (a, b) -&gt; a.charAt(0) - b.charAt(0))); System.out.println("--------------------"); System.out.println(getBig("hello123", "world", (a, b) -&gt; a.length() - b.length())); System.out.println(getBig("hello123", "world", (a, b) -&gt; a.charAt(0) - b.charAt(0))); &#125; static String getShort(String a, String b, Comparator&lt;String&gt; c)&#123; // c的结果小于0返回a，否则返回b return BinaryOperator.minBy(c).apply(a, b); &#125; static String getBig(String a, String b, Comparator&lt;String&gt; c)&#123; // c的结果大于0返回a，否则返回b return BinaryOperator.maxBy(c).apply(a, b); &#125;&#125;// world// hello123// --------------------// hello123// worldPredicate\&lt;T>Represents a predicate (boolean-valued function) of one argument. boolean test(T t);12345678910111213141516171819202122232425public class PredicateTest &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9); conditionFilter(list, item -&gt; item % 2 == 0); System.out.println("-----------"); conditionFilter(list, item -&gt; item % 2 != 0); System.out.println("-----------"); conditionFilter(list, item -&gt; item &gt; 5); System.out.println("-----------"); conditionFilter(list, item -&gt; true); &#125; static void conditionFilter(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; pd) &#123; list.forEach(integer -&gt; &#123; if (pd.test(integer)) System.out.println(integer); &#125;); &#125;&#125;// 2 4 6 8// -----------// 1 3 5 7 9// -----------// 6 7 8 9// -----------// 1 2 3 4 5 6 7 8 9与或非123456789101112131415161718192021222324252627282930313233343536public class PredicateTest &#123; public static void main(String[] args) &#123; List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9); conditionFilterAnd(list, item -&gt; item % 2 == 0, item -&gt; item &gt; 5); System.out.println("-------------"); conditionFilterOr(list, item -&gt; item % 2 == 0, item -&gt; item &gt; 5); System.out.println("-------------"); conditionFilterNegate(list, item -&gt; item % 2 == 0); &#125; static void conditionFilterAnd( List&lt;Integer&gt; list, Predicate&lt;Integer&gt; pd1, Predicate&lt;Integer&gt; pd2) &#123; list.forEach(integer -&gt; &#123; if (pd1.and(pd2).test(integer)) System.out.println(integer); &#125;); &#125; static void conditionFilterOr( List&lt;Integer&gt; list, Predicate&lt;Integer&gt; pd1, Predicate&lt;Integer&gt; pd2) &#123; list.forEach(integer -&gt; &#123; if (pd1.or(pd2).test(integer)) System.out.println(integer); &#125;); &#125; static void conditionFilterNegate( List&lt;Integer&gt; list, Predicate&lt;Integer&gt; pd1) &#123; list.forEach(integer -&gt; &#123; if (pd1.negate().test(integer)) System.out.println(integer); &#125;); &#125;&#125;// 6 8// -------------// 2 4 6 7 8 9// -------------// 1 3 5 7 9Consumer\&lt;T>Represents an operation that accepts a single input argument and returns no result. Unlike most other functional interfaces, Consumer is expected to operate via side-effects. void accept(T t);andThenReturns a composed Consumer that performs, in sequence, this operation followed by the after operation. If performing either operation throws an exception, it is relayed to the caller of the composed operation. If performing this operation throws an exception, the after operation will not be performed.123456789101112131415161718192021222324252627282930public class ConsumerTest &#123; public static void main(String[] args) &#123; testConsumer(); testAndThen(); &#125; public static void testConsumer() &#123; Consumer&lt;Integer&gt; square = x -&gt; System.out.println("print square : " + x * x); square.accept(2); &#125; public static void testAndThen() &#123; Consumer&lt;Integer&gt; consumer1 = x -&gt; System.out.println("first x : " + x); Consumer&lt;Integer&gt; consumer2 = x -&gt; &#123; System.out.println("second x : " + x); throw new NullPointerException("throw exception test"); &#125;; Consumer&lt;Integer&gt; consumer3 = x -&gt; System.out.println("third x : " + x); consumer1.andThen(consumer2).andThen(consumer3).accept(1); &#125;&#125;/*print square : 4first x : 1second x : 1Exception in thread "main" java.lang.NullPointerException: throw exception test at jdk8.ConsumerTest.lambda$testAndThen$2(ConsumerTest.java:21) at java.util.function.Consumer.lambda$andThen$0(Consumer.java:65) at java.util.function.Consumer.lambda$andThen$0(Consumer.java:65) at jdk8.ConsumerTest.testAndThen(ConsumerTest.java:25) at jdk8.ConsumerTest.main(ConsumerTest.java:9)*/Consumer的应用Consumer在经典应用是java.lang.Iterable里面的forEach方法。123456default void forEach(Consumer&lt;? super T&gt; action) &#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125;&#125;12345678910Person p1 = new Person("zhangsan", 12);Person p2 = new Person("lisi", 13);Person p3 = new Person("wangwu", 14);List&lt;Person&gt; list = Arrays.asList(p1, p2, p3);List&lt;Person&gt; list2 = new ArrayList&lt;&gt;();list.forEach(person -&gt; &#123; if(person.getAge() &gt; 12) list2.add(person);&#125;);// [Person&#123;name='lisi', age=13&#125;, Person&#123;name='wangwu', age=14&#125;]BiConsumer\&lt;T, U>Represents an operation that accepts two input arguments and returns no result. This is the two-arity specialization of Consumer. Unlike most other functional interfaces, BiConsumer is expected to operate via side-effects. void accept(T t, U u);12345678Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;();map.put(1, "one");map.put(2, "two");map.put(3, "three");map.forEach((k, v) -&gt; System.out.println(k + "=" + v));// 1=one// 2=two// 3=threeSupplier\&lt;T>Represents a supplier of results. There is no requirement that a new or distinct result be returned each time the supplier is invoked. T get();12345678910public static void testConsumerToSupplier() &#123; Consumer&lt;Person&gt; consumer = person -&gt; &#123; person.setName("wangwu"); person.setAge(34); &#125;; Person person = new Person("lisi", 40); consumer.accept(person); System.out.println("person = " + person);&#125;// person = Person&#123;name='wangwu', age=34&#125;Lambda不是语法糖Lambda表达式看上去就是匿名内部类的一个语法糖，但是实际上其它的实现方式不和匿名内部类一致，匿名内部类在编译后会生成两个字节码文件，而Lambda只是在原有的类中增加一个私有的方法：12345public class MainLambda &#123; public static void main(String[] args) &#123; new Thread(() -&gt; System.out.println("Lambda Thread run()")).start(); &#125;&#125;this引用的意义既然Lambda表达式不是内部类的简写，那么Lambda内部的this引用也就跟内部类对象没什么关系了。在Lambda表达式中this的意义跟在表达式外部完全一样。因此下列代码将输出四遍Hello。1234567891011121314151617181920public class Hello &#123; public Hello()&#123; System.out.println(this); &#125; Runnable r1 = () -&gt; System.out.println(this); Runnable r2 = () -&gt; System.out.println(toString()); public static void main(String[] args) &#123; new Hello().r1.run(); System.out.println("-----------"); new Hello().r2.run(); &#125; public String toString() &#123; return "Hello"; &#125;&#125;// Hello// Hello// -----------// Hello// HelloOptionalA container object which may or may not contain a non-null value. If a value is present, isPresent() will return true and get() will return the value.Additional methods that depend on the presence or absence of a contained value are provided, such as orElse() (return a default value if value not present) and ifPresent() (execute a block of code if the value is present).This is a value-based class; use of identity-sensitive operations (including reference equality (==), identity hash code, or synchronization) on instances of Optional may have unpredictable results and should be avoided.Value-based ClassesSome classes, such as java.util.Optional and java.time.LocalDateTime, are value-based. Instances of a value-based class:are final and immutable (though may contain references to mutable objects);have implementations of equals, hashCode, and toString which are computed solely from the instance’s state and not from its identity or the state of any other object or variable;make no use of identity-sensitive operations such as reference equality (==) between instances, identity hash code of instances, or synchronization on an instances’s intrinsic lock;are considered equal solely based on equals(), not based on reference equality (==);do not have accessible constructors, but are instead instantiated through factory methods which make no commitment as to the identity of returned instances;are freely substitutable when equal, meaning that interchanging any two instances x and y that are equal according to equals() in any computation or method invocation should produce no visible change in behavior.A program may produce unpredictable results if it attempts to distinguish two references to equal values of a value-based class, whether directly via reference equality or indirectly via an appeal to synchronization, identity hashing, serialization, or any other identity-sensitive mechanism. Use of such identity-sensitive operations on instances of value-based classes may have unpredictable effects and should be avoided.123456public class Employee &#123; private String name; public Employee(String name) &#123; this.name = name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125;&#125;1234567public class Company &#123; private String name; private List&lt;Employee&gt; employees; public Company(String name) &#123; this.name = name; &#125; public List&lt;Employee&gt; getEmployees() &#123; return employees; &#125; public void setEmployees(List&lt;Employee&gt; employees) &#123; this.employees = employees; &#125;&#125;123456789Employee e1 = new Employee("zhangsan");Employee e2 = new Employee("lisi");Company company = new Company("test");List&lt;Employee&gt; employees = Arrays.asList(e1, e2);company.setEmployees(employees); // 注释掉此句，最终输出的是[]。不是nullOptional&lt;Company&gt; optional = Optional.ofNullable(company);System.out.println( optional.map(comp -&gt; comp.getEmployees()).orElse(Collections.emptyList()));// [jdk8.Employee@53d8d10a, jdk8.Employee@e9e54c2]需要注意，Optional是一个未实现序列化的类，不应当将其作为函数的参数或者类的属性。方法引用方法引用是Lambda的一个语法糖。我们可以将其看作是一个函数指针。方法引用有四种：类名::静态方法名对象::实例方法名类名::实例方法名构造方法引用123456789101112131415161718192021222324252627282930public class Student &#123; private String name; private int score; public Student(String name, int score) &#123; this.name = name; this.score = score; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getScore() &#123; return score; &#125; public void setScore(int score) &#123; this.score = score; &#125; // 此方法违背了面向对象的设计原则，实际使用中不推荐 public static int compareByScore1(Student s1, Student s2) &#123; return s1.score - s2.score; &#125; // 此方法违背了面向对象的设计原则，实际使用中不推荐 public int compareByName2(Student s1, Student s2) &#123; return s1.name.compareTo(s2.name); &#125; public int compareByScore3(Student s)&#123; return this.score - s.score; &#125; @Override public String toString() &#123; return "Student&#123;" + "name='" + name + '\'' + ", score=" + score + '&#125;'; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class MethodReferenceTest &#123; public static void main(String[] args) &#123; Student s1 = new Student("zhangsan", 10); Student s2 = new Student("lisi", 20); Student s3 = new Student("wangwu", 30); Student s4 = new Student("zhaoliu", 40); List&lt;Student&gt; students = Arrays.asList(s1, s2, s4, s3); // sort方法需要一个Comparator，Comparator的抽象方法是：int compare(T o1, T o2); // 我们传入的参数是两个Student类型的对象，返回的是一个int型数据// students.sort((s1p, s2p) -&gt; Student.compareByScore(s1p, s2p)); // compareByScore这个方法接收两个Student类型的对象， // 返回一个int型数据，可以满足我们的需要，所以编译器能识别成功 students.sort(Student::compareByScore1); // forEach方法需要一个Consumer，Consumer的抽象方法是：void accept(T t); // System.out.println(...) 满足一个参数，没有返回值的要求，所以可以被编译器识别 students.forEach(System.out::println); System.out.println("----------------"); students.sort(s1::compareByName2); students.forEach(System.out::println); System.out.println("----------------"); // Comparator的抽象方法是：int compare(T o1, T o2); // 在这种写法中，第一个参数会去调用compareByScore3，将第二个参数传入 // 如果函数式接口的抽象方法有三个以上的参数，第一个参数用于调用方法，后面的参数都会用于传入 students.sort(Student::compareByScore3); students.forEach(System.out::println); System.out.println("----------------"); // 调用String的无参构造方法，返回一个String对象 System.out.println(getString(String::new)); // 调用public String(String original) 构造方法 System.out.println(getString("123", String::new)); &#125; static String getString(Supplier&lt;String&gt; s)&#123; return s.get() + "abc"; &#125; static String getString(String str, Function&lt;String, String&gt; f)&#123; return f.apply(str); &#125;&#125;// Student&#123;name='zhangsan', score=10&#125;// Student&#123;name='lisi', score=20&#125;// Student&#123;name='wangwu', score=30&#125;// Student&#123;name='zhaoliu', score=40&#125;// ----------------// Student&#123;name='lisi', score=20&#125;// Student&#123;name='wangwu', score=30&#125;// Student&#123;name='zhangsan', score=10&#125;// Student&#123;name='zhaoliu', score=40&#125;// ----------------// Student&#123;name='zhangsan', score=10&#125;// Student&#123;name='lisi', score=20&#125;// Student&#123;name='wangwu', score=30&#125;// Student&#123;name='zhaoliu', score=40&#125;// ----------------// abc// 123Lambda and Collections由于引入了 Lambda 表达式，Java8新增了java.util.funcion包，里面包含常用的函数接口，这是Lambda表达式的基础，Java集合框架也新增部分接口，以便与Lambda表达式对接。我们等下也会介绍其中的一部分方法。List中的新方法forEach()该方法的签名为void forEach(Consumer action)，作用是对容器中的每个元素执行action指定的动作，其中Consumer是个函数接口，里面只有一个待实现方法void accept(T t)（后面我们会看到，这个方法叫什么根本不重要，你甚至不需要记忆它的名字）。需求：假设有一个字符串列表，需要打印出其中所有长度大于3的字符串.Java7及以前我们可以用增强的for循环实现：123456// 使用曾强for循环迭代ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList("I", "love", "you", "too"));for(String str : list)&#123; if(str.length()&gt;3) System.out.println(str);&#125;现在使用forEach()方法结合匿名内部类，可以这样实现：123456789// 使用forEach()结合匿名内部类迭代ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList("I", "love", "you", "too"));list.forEach(new Consumer&lt;String&gt;()&#123; @Override public void accept(String str)&#123; if(str.length()&gt;3) System.out.println(str); &#125;&#125;);上述代码调用forEach()方法，并使用匿名内部类实现Comsumer接口。到目前为止我们没看到这种设计有什么好处，但是不要忘记Lambda表达式，使用 Lambda 表达式实现如下：123456// 使用forEach()结合Lambda表达式迭代ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList("I", "love", "you", "too"));list.forEach( str -&gt; &#123; if(str.length()&gt;3) System.out.println(str); &#125;);上述代码给forEach()方法传入一个 Lambda 表达式，我们不需要知道accept()方法，也不需要知道Consumer接口，类型推导帮我们做了一切。removeIf()该方法签名为boolean removeIf(Predicate filter)，作用是删除容器中所有满足filter指定条件的元素，其中Predicate是一个函数接口，里面只有一个待实现方法boolean test(T t)，同样的这个方法的名字根本不重要，因为用的时候不需要书写这个名字。需求：假设有一个字符串列表，需要删除其中所有长度大于3的字符串。我们知道如果需要在迭代过程冲对容器进行删除操作必须使用迭代器，否则会抛出ConcurrentModificationException，所以上述任务传统的写法是：1234567// 使用迭代器删除列表元素ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList("I", "love", "you", "too"));Iterator&lt;String&gt; it = list.iterator();while(it.hasNext()) &#123; if(it.next().length()&gt;3) // 删除长度大于3的元素 it.remove();&#125;现在使用removeIf()方法结合匿名内部类，我们可是这样实现：12345678// 使用removeIf()结合匿名名内部类实现ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList("I", "love", "you", "too"));list.removeIf(new Predicate&lt;String&gt;()&#123; // 删除长度大于3的元素 @Override public boolean test(String str)&#123; return str.length()&gt;3; &#125;&#125;);上述代码使用removeIf()方法，并使用匿名内部类实现Precicate接口。相信你已经想到用Lambda表达式该怎么写了：123// 使用removeIf()结合Lambda表达式实现ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList("I", "love", "you", "too"));list.removeIf(str -&gt; str.length()&gt;3); // 删除长度大于3的元素使用Lambda表达式不需要记忆Predicate接口名，也不需要记忆test()方法名，只需要知道此处需要一个返回布尔类型的Lambda表达式就行了。replaceAll()该方法签名为void replaceAll(UnaryOperator operator)，作用是对每个元素执行operator指定的操作，并用操作结果来替换原来的元素。其中UnaryOperator是一个函数接口，里面只有一个待实现函数T apply(T t)。需求：假设有一个字符串列表，将其中所有长度大于3的元素转换成大写，其余元素不变。Java7及之前似乎没有优雅的办法：1234567// 使用下标实现元素替换ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList("I", "love", "you", "too"));for(int i=0; i&lt;list.size(); i++)&#123; String str = list.get(i); if(str.length()&gt;3) list.set(i, str.toUpperCase());&#125;使用replaceAll()方法结合匿名内部类可以实现如下：12345678910// 使用匿名内部类实现ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList("I", "love", "you", "too"));list.replaceAll(new UnaryOperator&lt;String&gt;()&#123; @Override public String apply(String str)&#123; if(str.length()&gt;3) return str.toUpperCase(); return str; &#125;&#125;);上述代码调用replaceAll()方法，并使用匿名内部类实现UnaryOperator接口。我们知道可以用更为简洁的Lambda表达式实现：1234567// 使用Lambda表达式实现ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList("I", "love", "you", "too"));list.replaceAll(str -&gt; &#123; if(str.length()&gt;3) return str.toUpperCase(); return str;&#125;);sort()该方法定义在List接口中，方法签名为void sort(Comparator c)，该方法根据c指定的比较规则对容器元素进行排序。Comparator接口我们并不陌生，其中有一个方法int compare(T o1, T o2)需要实现，显然该接口是个函数接口。需求：假设有一个字符串列表，按照字符串长度增序对元素排序。由于Java7以及之前sort()方法在Collections工具类中，所以代码要这样写：12345678// Collections.sort()方法ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList("I", "love", "you", "too"));Collections.sort(list, new Comparator&lt;String&gt;()&#123; @Override public int compare(String str1, String str2)&#123; return str1.length()-str2.length(); &#125;&#125;);现在可以直接使用List.sort()方法，结合Lambda表达式，可以这样写：123// List.sort()方法结合Lambda表达式ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(Arrays.asList("I", "love", "you", "too"));list.sort((str1, str2) -&gt; str1.length()-str2.length());Map中的新方法forEach()该方法签名为void forEach(BiConsumer action)，作用是对Map中的每个映射执行action指定的操作，其中BiConsumer是一个函数接口，里面有一个待实现方法void accept(T t, U u)。BinConsumer接口名字和accept()方法名字都不重要，请不要记忆他们。需求：假设有一个数字到对应英文单词的Map，请输出Map中的所有映射关系．Java7以及之前经典的代码如下：12345678// Java7以及之前迭代MapHashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();map.put(1, "one");map.put(2, "two");map.put(3, "three");for(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123; System.out.println(entry.getKey() + "=" + entry.getValue());&#125;使用Map.forEach()方法，结合匿名内部类，代码如下：1234567891011// 使用forEach()结合匿名内部类迭代MapHashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();map.put(1, "one");map.put(2, "two");map.put(3, "three");map.forEach(new BiConsumer&lt;Integer, String&gt;()&#123; @Override public void accept(Integer k, String v)&#123; System.out.println(k + "=" + v); &#125;&#125;);上述代码调用forEach()方法，并使用匿名内部类实现BiConsumer接口。当然，实际场景中没人使用匿名内部类写法，因为有Lambda表达式：123456// 使用forEach()结合Lambda表达式迭代MapHashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();map.put(1, "one");map.put(2, "two");map.put(3, "three");map.forEach((k, v) -&gt; System.out.println(k + "=" + v));replaceAll()该方法签名为replaceAll(BiFunction function)，作用是对Map中的每个映射执行function指定的操作，并用function的执行结果替换原来的value，其中BiFunction是一个函数接口，里面有一个待实现方法R apply(T t, U u)．不要被如此多的函数接口吓到，因为使用的时候根本不需要知道他们的名字．需求：假设有一个数字到对应英文单词的Map，请将原来映射关系中的单词都转换成大写．Java7以及之前经典的代码如下：12345678// Java7以及之前替换所有Map中所有映射关系HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();map.put(1, "one");map.put(2, "two");map.put(3, "three");for(Map.Entry&lt;Integer, String&gt; entry : map.entrySet())&#123; entry.setValue(entry.getValue().toUpperCase());&#125;使用replaceAll()方法结合匿名内部类，实现如下：1234567891011// 使用replaceAll()结合匿名内部类实现HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();map.put(1, "one");map.put(2, "two");map.put(3, "three");map.replaceAll(new BiFunction&lt;Integer, String, String&gt;()&#123; @Override public String apply(Integer k, String v)&#123; return v.toUpperCase(); &#125;&#125;);上述代码调用replaceAll()方法，并使用匿名内部类实现BiFunction接口。更进一步的，使用Lambda表达式实现如下：123456// 使用replaceAll()结合Lambda表达式实现HashMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();map.put(1, "one");map.put(2, "two");map.put(3, "three");map.replaceAll((k, v) -&gt; v.toUpperCase());简洁到让人难以置信．merge()该方法签名为merge(K key, V value, BiFunction remappingFunction)，作用是：如果Map中key对应的映射不存在或者为null，则将value（不能是null）关联到key上；否则执行remappingFunction，如果执行结果非null则用该结果跟key关联，否则在Map中删除key的映射．1234567891011121314default V merge( K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) &#123; Objects.requireNonNull(remappingFunction); Objects.requireNonNull(value); V oldValue = get(key); V newValue = (oldValue == null) ? value : remappingFunction.apply(oldValue, value); if(newValue == null) &#123; remove(key); &#125; else &#123; put(key, newValue); &#125; return newValue;&#125;merge()方法虽然语义有些复杂，但该方法的用方式很明确，让我们从最基本的例子开始：计算唯一的单词出现次数。在Java8之前的时候，代码非常混乱，实际的实现其实已经失去了本质层面的设计意义。123456789Map map = new HashMap&lt;String, Integer&gt;();words.forEach(word -&gt; &#123; var prev = map.get(word); if (prev == null) &#123; map.put(word, 1); &#125; else &#123; map.put(word, prev + 1); &#125;&#125;);在Java8中实现就优雅很多了1234Map map = new HashMap&lt;String, Integer&gt;();words.forEach(word -&gt; map.merge(word, 1, (prev, one) -&gt; prev + one));实际上如果给定的key不存在，它就变成了put(key, value)。如果key已经存在，我们 remappingFunction 可以选择合并的方式。这个功能是完美契机上面的场景：只需返回新值即可覆盖旧值： (old, new) -&gt; new只需返回旧值即可保留旧值：(old, new) -&gt; old以某种方式合并两者，例如：(old, new) -&gt; old + new甚至删除旧值：(old, new) -&gt; nullcomputeIfAbsent()该方法签名为V computeIfAbsent(K key, Function mappingFunction)，作用是：只有在当前Map中不存在key值的映射或映射值为null时，才调用mappingFunction，并在mappingFunction执行结果非null时，将结果跟key关联。12345678910111213default V computeIfAbsent( K key, Function&lt;? super K, ? extends V&gt; mappingFunction) &#123; Objects.requireNonNull(mappingFunction); V v; if ((v = get(key)) == null) &#123; V newValue; if ((newValue = mappingFunction.apply(key)) != null) &#123; put(key, newValue); return newValue; &#125; &#125; return v;&#125;示例代码：123456String ret;Map&lt;String, String&gt; map = new HashMap&lt;&gt;();ret = map.putIfAbsent("a", "aaa"); //ret 为"aaa", map 为 &#123;"a":"aaa"&#125;ret = map.putIfAbsent("a", "bbb"); //ret 为 "aaa", map 还是 &#123;"a":"aaa"&#125;map.put("b", null);ret = map.putIfAbsent("b", "bbb"); //ret 为 "bbb", map 为 &#123;"a":"aaa","b":"bbb"&#125;computeIfPresent()该方法签名为V computeIfPresent(K key, BiFunction remappingFunction)，作用跟computeIfAbsent()相反，即，只有在当前Map中存在key值的映射且非null时，才调用remappingFunction，如果remappingFunction执行结果为null，则删除key的映射，否则使用该结果替换key原来的映射．1234567891011121314151617default V computeIfPresent( K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; Objects.requireNonNull(remappingFunction); V oldValue; if ((oldValue = get(key)) != null) &#123; V newValue = remappingFunction.apply(key, oldValue); if (newValue != null) &#123; put(key, newValue); return newValue; &#125; else &#123; remove(key); return null; &#125; &#125; else &#123; return null; &#125;&#125;示例代码：12345678910String ret;Map&lt;String, String&gt; map = new HashMap&lt;&gt;();ret = map.computeIfPresent("a", (key, value) -&gt; key + value); // ret null, map 为 &#123;&#125;map.put("a", null); // map 为 ["a":null]ret = map.computeIfPresent("a", (key, value) -&gt; key + value); // ret null, map为 &#123;"a":null&#125;map.put("a", "+aaa");// ret "a+aaa", map 为 &#123;"a":"a+aaa"&#125;ret = map.computeIfPresent("a", (key, value) -&gt; key + value); // ret 为 null, map 为 &#123;&#125;，计算出的 null 把 key 删除了ret = map.computeIfPresent("a", (key, value) -&gt; null);compute()该方法签名为compute(K key, BiFunction remappingFunction)，作用是把remappingFunction的计算结果关联到key上，如果计算结果为null，则在Map中删除key的映射．123456789101112131415161718192021default V compute( K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) &#123; Objects.requireNonNull(remappingFunction); V oldValue = get(key); V newValue = remappingFunction.apply(key, oldValue); if (newValue == null) &#123; // delete mapping if (oldValue != null || containsKey(key)) &#123; // something to remove remove(key); return null; &#125; else &#123; // nothing to do. Leave things as they were. return null; &#125; &#125; else &#123; // add or replace old mapping put(key, newValue); return newValue; &#125;&#125;示例如下：12345String ret;Map&lt;String, String&gt; map = new HashMap&lt;&gt;() ;ret = map.compute("a", (key, value) -&gt; "a" + value); // ret="anull", map=&#123;"a":"anull"&#125;ret = map.compute("a", (key, value) -&gt; "a" + value); // ret="aanull", map=&#123;"a":"aanull"&#125;ret = map.compute("a", (key, value) -&gt; null); // ret=null, map=&#123;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.07-JavaSE-集合-1]]></title>
    <url>%2Fposts%2F17059.html%2F</url>
    <content type="text"><![CDATA[集合概览ListArraylist： Object数组Vector： Object数组，线程安全。LinkedList： 双向链表MapHashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间LinkedHashMap： LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。TreeMap： 红黑树SetHashSet（无序，唯一）: 基于 HashMap 实现的，底层采用 HashMap 来保存元素LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。TreeSet（有序，唯一）： 红黑树（自平衡的排序二叉树)ArrayList分析ArrayList有三种方式来初始化，构造方法源码如下：12345678910111213141516171819202122232425262728293031323334353637383940/** * 默认初始容量大小 */private static final int DEFAULT_CAPACITY = 10;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * 默认构造函数，使用初始容量10构造一个空列表(无参数构造) */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;/** * 带初始容量参数的构造函数。（用户自己指定容量） */public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; // 初始容量大于0 // 创建initialCapacity大小的数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; // 初始容量等于0 //创建空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; // 初始容量小于0，抛出异常 throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;/*** 构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回* 如果指定的集合为null，throws NullPointerException。 */public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125;细心的同学一定会发现 ：以无参数构造方法创建 ArrayList 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。 下面在我们分析 ArrayList 扩容时会讲到这一点内容！add12345678910/** * 将指定的元素追加到此列表的末尾。 */public boolean add(E e) &#123; // 添加元素之前，先调用ensureCapacityInternal方法 ensureCapacityInternal(size + 1); // Increments modCount!! // 这里看到ArrayList添加元素的实质就相当于为数组赋值 elementData[size++] = e; return true;&#125;ensureCapacityInternal()12345678910111213141516// 获得容量private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity;&#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;当我们要 add 进第1个元素到 ArrayList 时，minCapacity为1，在Math.max()方法比较后，minCapacity 为10。elementData.length 为0 （因为还是一个空的 list），因为执行了 ensureCapacityInternal() 方法 ，所以 minCapacity 此时为10。此时，minCapacity - elementData.length &gt; 0成立，所以会进入 grow(minCapacity) 方法。当add第2个元素时，minCapacity 为2，此时e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，minCapacity - elementData.length &gt; 0不成立，所以不会进入 （执行）grow(minCapacity) 方法。添加第3、4···到第10个元素时，依然不会执行grow方法，数组容量都为10。直到添加第11个元素，minCapacity(为11)比elementData.length（为10）要大。进入grow方法进行扩容。grow()1234567891011121314151617181920212223private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) &#123; // oldCapacity为旧容量，newCapacity为新容量 int oldCapacity = elementData.length; // 将oldCapacity 右移一位，其效果相当于oldCapacity /2， // 我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 若新容量大于MAX_ARRAY_SIZE，执行hugeCapacity()方法来比较minCapacity和MAX_ARRAY_SIZE， // 若minCapacity大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 // MAX_ARRAY_SIZE 即为Integer.MAX_VALUE - 8。 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125;所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍！“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除2，右移n位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了1位所以相当于oldCapacity /2。对于大数据的2进制运算，位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已，不去计算，这样提高了效率，节省了资源我们再来通过例子探究一下grow() 方法 ：当add第1个元素时，oldCapacity 为0，经比较后第一个if判断成立，newCapacity = minCapacity(为10)。但是第二个if判断不会成立，即newCapacity 不比 MAX_ARRAY_SIZE大，则不会进入 hugeCapacity 方法。数组容量为10，add方法中 return true,size增为1。当add第11个元素进入grow方法时，newCapacity为15，比minCapacity（为11）大，第一个if判断不成立。新容量没有大于数组最大size，不会进入hugeCapacity方法。数组容量扩为15，add方法中return true，size增为11。以此类推······如果新容量大于 MAX_ARRAY_SIZE,进入(执行) hugeCapacity() 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果minCapacity大于最大容量，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 Integer.MAX_VALUE - 8。这里补充一点比较重要，但是容易被忽视掉的知识点：java 中的 length属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.java 中的 length() 方法是针对字符串说的,如果想看这个字符串的长度则用到 length() 这个方法.java 中的 size() 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!System.arraycopy()123456789101112131415/** * 在此列表中的指定位置插入指定的元素。 * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证 * capacity足够大；再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。 */public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! // arraycopy()方法实现数组自己复制自己 // elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的 // 起始位置； size - index：要复制的数组元素的数量； System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++;&#125;Arrays.copyOf()1234567891011public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass());&#125;public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125;个人觉得使用 Arrays.copyOf()方法主要是为了给原有数组扩容。ensureCapacityArrayList 源码中有一个 ensureCapacity 方法不知道大家注意到没有，这个方法 ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？123456789101112131415/** * 如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。 * @param minCapacity 所需的最小容量 */public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125;&#125;最好在 add 大量元素之前用 ensureCapacity 方法，以减少增量重新分配的次数我们通过下面的代码实际测试以下这个方法的效果：1234567891011121314151617181920public class EnsureCapacityTest &#123; public static void main(String[] args) &#123; ArrayList&lt;Object&gt; list = new ArrayList&lt;Object&gt;(); final int N = 10000000; long startTime = System.currentTimeMillis(); for (int i = 0; i &lt; N; i++) &#123; list.add(i); &#125; long endTime = System.currentTimeMillis(); System.out.println("使用ensureCapacity方法前："+(endTime - startTime)); list = new ArrayList&lt;Object&gt;(); long startTime1 = System.currentTimeMillis(); list.ensureCapacity(N); for (int i = 0; i &lt; N; i++) &#123; list.add(i); &#125; long endTime1 = System.currentTimeMillis(); System.out.println("使用ensureCapacity方法后："+(endTime1 - startTime1)); &#125;&#125;运行结果：12使用ensureCapacity方法前：4637使用ensureCapacity方法后：241通过运行结果，我们可以很明显的看出向 ArrayList 添加大量元素之前最好先使用ensureCapacity 方法，以减少增量重新分配的次数。LinkedList分析LinkedList是一个实现了List接口和Deque接口的双端链表。 LinkedList底层的链表结构使它支持高效的插入和删除操作，另外它实现了Deque接口，使得LinkedList类也具有队列的特性；LinkedList不是线程安全的，如果想使LinkedList变成线程安全的，可以调用静态类Collections类中的synchronizedList方法：1List list = Collections.synchronizedList(new LinkedList(...));内部结构分析12345678910private static class Node&lt;E&gt; &#123; E item;//节点值 Node&lt;E&gt; next;//后继节点 Node&lt;E&gt; prev;//前驱节点 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125;这个类就代表双端链表的节点Node。这个类有三个属性，分别是前驱节点，本节点的值，后继结点。构造方法空构造方法：1public LinkedList() &#123; &#125;用已有的集合创建链表的构造方法：1234public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125;add方法add(E e) 方法：将元素添加到链表尾部123456789101112131415161718public boolean add(E e) &#123; linkLast(e); // 这里就只调用了这一个方法 return true;&#125;/*** 链接使e作为最后一个元素。*/void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; // 新建节点 if (l == null) first = newNode; else l.next = newNode; // 指向后继元素也就是指向下一个元素 size++; modCount++;&#125;add(int index,E e)：在指定位置添加元素1234567public void add(int index, E element) &#123; checkPositionIndex(index); // 检查索引是否处于[0-size]之间 if (index == size) // 添加在链表尾部 linkLast(element); else // 添加在链表中间 linkBefore(element, node(index));&#125;linkBefore方法需要给定两个参数，一个插入节点的值，一个指定的node，所以我们又调用了Node(index)去找到index对应的nodeaddAll(Collection c )：将集合插入到链表尾部123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c);&#125;addAll(int index, Collection c)： 将集合从指定位置开始插入123456789101112131415161718192021222324252627282930313233343536373839404142434445public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; // 1:检查index范围是否在size之内 checkPositionIndex(index); // 2:toArray()方法把集合的数据存到对象数组中 Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; // 3：得到插入位置的前驱节点和后继节点 Node&lt;E&gt; pred, succ; // 如果插入位置为尾部，前驱节点为last，后继节点为null if (index == size) &#123; succ = null; pred = last; &#125; // 否则，调用node()方法得到后继节点，再得到前驱节点 else &#123; succ = node(index); pred = succ.prev; &#125; // 4：遍历数据将数据插入 for (Object o : a) &#123; @SuppressWarnings("unchecked") E e = (E) o; //创建新节点 Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); //如果插入位置在链表头部 if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; //如果插入位置在尾部，重置last节点 if (succ == null) &#123; last = pred; &#125; //否则，将插入的链表与先前链表连接起来 else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true;&#125;上面可以看出addAll方法通常包括下面四个步骤：检查index范围是否在size之内toArray()方法把集合的数据存到对象数组中得到插入位置的前驱和后继节点遍历数据，将数据插入到指定位置addFirst(E e)： 将元素添加到链表头部12345678910111213141516 public void addFirst(E e) &#123; linkFirst(e); &#125;private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); // 新建节点，以头节点为后继节点 first = newNode; // 如果链表为空，last节点也指向该节点 if (f == null) last = newNode; // 否则，将头节点的前驱指针指向新节点，也就是指向前一个元素 else f.prev = newNode; size++; modCount++;&#125;addLast(E e)： 将元素添加到链表尾部，与 add(E e) 方法一样123public void addLast(E e) &#123; linkLast(e);&#125;根据位置取数据的方法get(int index)： 根据指定索引返回数据123456public E get(int index) &#123; //检查index范围是否在size之内 checkElementIndex(index); //调用Node(index)去找到index对应的node然后返回它的值 return node(index).item;&#125;获取头节点（index=0）数据方法:1234567891011121314151617public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125;public E element() &#123; return getFirst();&#125;public E peek() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125;public E peekFirst() &#123; final Node&lt;E&gt; f = first; return (f == null) ? null : f.item;&#125;区别： getFirst()，element()，peek()，peekFirst() 这四个获取头结点方法的区别在于对链表为空时的处理，是抛出异常还是返回null，其中getFirst() 和element() 方法将会在链表为空时，抛出异常element()方法的内部就是使用getFirst()实现的。它们会在链表为空时，抛出NoSuchElementException获取尾节点（index=-1）数据方法:12345678910public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125;public E peekLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : l.item;&#125;两者区别： getLast() 方法在链表为空时，会抛出NoSuchElementException，而peekLast() 则不会，只是会返回 null。根据对象得到索引的方法int indexOf(Object o)： 从头遍历找12345678910111213141516171819public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; // 从头遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; // 从头遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1;&#125;int lastIndexOf(Object o)： 从尾遍历找12345678910111213141516171819public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; // 从尾遍历 for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; // 从尾遍历 for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1;&#125;检查链表是否包含某对象的方法contains(Object o)： 检查对象o是否存在于链表中123public boolean contains(Object o) &#123; return indexOf(o) != -1;&#125;删除方法remove() ,removeFirst(),pop(): 删除头节点123456789101112public E pop() &#123; return removeFirst();&#125;public E remove() &#123; return removeFirst();&#125;public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;removeLast(),pollLast(): 删除尾节点12345678910public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125;public E pollLast() &#123; final Node&lt;E&gt; l = last; return (l == null) ? null : unlinkLast(l);&#125;区别： removeLast()在链表为空时将抛出NoSuchElementException，而pollLast()方法返回null。remove(Object o): 删除指定元素12345678910111213141516171819202122232425public boolean remove(Object o) &#123; // 如果删除对象为null if (o == null) &#123; // 从头开始遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; // 找到元素 if (x.item == null) &#123; // 从链表中移除找到的元素 unlink(x); return true; &#125; &#125; &#125; else &#123; //从头开始遍历 for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; //找到元素 if (o.equals(x.item)) &#123; //从链表中移除找到的元素 unlink(x); return true; &#125; &#125; &#125; return false;&#125;当删除指定对象时，只需调用remove(Object o)即可，不过该方法一次只会删除一个匹配的对象，如果删除了匹配对象，返回true，否则false。unlink(Node x) 方法：123456789101112131415161718192021222324E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; // 得到后继节点 final Node&lt;E&gt; prev = x.prev; // 得到前驱节点 // 删除前驱指针 if (prev == null) &#123; first = next; // 如果删除的节点是头节点,令头节点指向该节点的后继节点 &#125; else &#123; prev.next = next; // 将前驱节点的后继节点指向后继节点 x.prev = null; &#125; // 删除后继指针 if (next == null) &#123; last = prev; // 如果删除的节点是尾节点,令尾节点指向该节点的前驱节点 &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125;remove(int index)：删除指定位置的元素123456public E remove(int index) &#123; // 检查index范围 checkElementIndex(index); // 将节点删除 return unlink(node(index));&#125;LinkedList类常用方法测试123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117public class LinkedListDemo &#123; public static void main(String[] srgs) &#123; // 创建存放int类型的linkedList LinkedList&lt;Integer&gt; linkedList = new LinkedList&lt;&gt;(); /************************** linkedList的基本操作 ************************/ linkedList.addFirst(0); // 添加元素到列表开头 linkedList.add(1); // 在列表结尾添加元素 linkedList.add(2, 2); // 在指定位置添加元素 linkedList.addLast(3); // 添加元素到列表结尾 System.out.println("LinkedList（直接输出的）: " + linkedList); System.out.println("getFirst()获得第一个元素: " + linkedList.getFirst()); // 返回此列表的第一个元素 System.out.println("getLast()获得第最后一个元素: " + linkedList.getLast()); // 返回此列表的最后一个元素 System.out.println("removeFirst()删除第一个元素并返回: " + linkedList.removeFirst()); // 移除并返回此列表的第一个元素 System.out.println("removeLast()删除最后一个元素并返回: " + linkedList.removeLast()); // 移除并返回此列表的最后一个元素 System.out.println("After remove:" + linkedList); System.out.println("contains()方法判断列表是否包含1这个元素:" + linkedList.contains(1)); // 判断此列表包含指定元素，如果是则返回真 System.out.println("该linkedList的大小 : " + linkedList.size()); // 返回此列表的元素个数 /************************** 位置访问操作 ************************/ System.out.println("-----------------------------------------"); linkedList.set(1, 3); // 将此列表中指定位置的元素替换为指定的元素 System.out.println("After set(1, 3):" + linkedList); System.out.println("get(1)获得指定位置（这里为1）的元素: " + linkedList.get(1)); // 返回此列表中指定位置处的元素 /************************** Search操作 ************************/ System.out.println("-----------------------------------------"); linkedList.add(3); System.out.println("indexOf(3): " + linkedList.indexOf(3)); // 返回此列表中首次出现的指定元素的索引 System.out.println("lastIndexOf(3): " + linkedList.lastIndexOf(3));// 返回此列表中最后出现的指定元素的索引 /************************** Queue操作 ************************/ System.out.println("-----------------------------------------"); System.out.println("peek(): " + linkedList.peek()); // 获取但不移除此列表的头 System.out.println("element(): " + linkedList.element()); // 获取但不移除此列表的头 linkedList.poll(); // 获取并移除此列表的头 System.out.println("After poll():" + linkedList); linkedList.remove(); System.out.println("After remove():" + linkedList); // 获取并移除此列表的头 linkedList.offer(4); System.out.println("After offer(4):" + linkedList); // 将指定元素添加到此列表的末尾 /************************** Deque操作 ************************/ System.out.println("-----------------------------------------"); linkedList.offerFirst(2); // 在此列表的开头插入指定的元素 System.out.println("After offerFirst(2):" + linkedList); linkedList.offerLast(5); // 在此列表末尾插入指定的元素 System.out.println("After offerLast(5):" + linkedList); System.out.println("peekFirst(): " + linkedList.peekFirst()); // 获取但不移除此列表的第一个元素 System.out.println("peekLast(): " + linkedList.peekLast()); // 获取但不移除此列表的第一个元素 linkedList.pollFirst(); // 获取并移除此列表的第一个元素 System.out.println("After pollFirst():" + linkedList); linkedList.pollLast(); // 获取并移除此列表的最后一个元素 System.out.println("After pollLast():" + linkedList); linkedList.push(2); // 将元素推入此列表所表示的堆栈（插入到列表的头） System.out.println("After push(2):" + linkedList); linkedList.pop(); // 从此列表所表示的堆栈处弹出一个元素（获取并移除列表第一个元素） System.out.println("After pop():" + linkedList); linkedList.add(3); linkedList.removeFirstOccurrence(3); // 移除第一次出现的指定元素（从头到尾遍历） System.out.println("After removeFirstOccurrence(3):" + linkedList); linkedList.removeLastOccurrence(3); // 移除最后一次出现的指定元素（从尾到头遍历） System.out.println("After removeFirstOccurrence(3):" + linkedList); /************************** 遍历操作 ************************/ System.out.println("-----------------------------------------"); linkedList.clear(); for (int i = 0; i &lt; 100000; i++) &#123; linkedList.add(i); &#125; // 迭代器遍历 long start = System.currentTimeMillis(); Iterator&lt;Integer&gt; iterator = linkedList.iterator(); while (iterator.hasNext()) &#123; iterator.next(); &#125; long end = System.currentTimeMillis(); System.out.println("Iterator：" + (end - start) + " ms"); // 顺序遍历(随机遍历) start = System.currentTimeMillis(); for (int i = 0; i &lt; linkedList.size(); i++) &#123; linkedList.get(i); &#125; end = System.currentTimeMillis(); System.out.println("for：" + (end - start) + " ms"); // 另一种for循环遍历 start = System.currentTimeMillis(); for (Integer i : linkedList) ; end = System.currentTimeMillis(); System.out.println("for2：" + (end - start) + " ms"); // 通过pollFirst()或pollLast()来遍历LinkedList LinkedList&lt;Integer&gt; temp1 = new LinkedList&lt;&gt;(); temp1.addAll(linkedList); start = System.currentTimeMillis(); while (temp1.size() != 0) &#123; temp1.pollFirst(); &#125; end = System.currentTimeMillis(); System.out.println("pollFirst()或pollLast()：" + (end - start) + " ms"); // 通过removeFirst()或removeLast()来遍历LinkedList LinkedList&lt;Integer&gt; temp2 = new LinkedList&lt;&gt;(); temp2.addAll(linkedList); start = System.currentTimeMillis(); while (temp2.size() != 0) &#123; temp2.removeFirst(); &#125; end = System.currentTimeMillis(); System.out.println("removeFirst()或removeLast()：" + (end - start) + " ms"); &#125;&#125;Arrays.asListArrays.asList()将数组转换为集合后,底层其实还是数组。传递的数组必须是对象数组，而不是基本类型。Arrays.asList()是泛型方法，传入的对象必须是对象数组。1234567int[] myArray = &#123; 1, 2, 3 &#125;;List myList = Arrays.asList(myArray);System.out.println(myList.size()); // 1System.out.println(myList.get(0)); // 数组地址值System.out.println(myList.get(1)); // 报错：ArrayIndexOutOfBoundsExceptionint [] array=(int[]) myList.get(0);System.out.println(array[0]); // 1当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组，这也就解释了上面的代码。我们使用包装类型数组就可以解决这个问题。1Integer[] myArray = &#123; 1, 2, 3 &#125;;使用集合的修改方法:add()、remove()、clear()会抛出异常。Arrays.asList() 方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类,这个内部类并没有实现集合的修改方法或者说并没有重写这些方法。1234567891011121314151617181920212223242526272829303132private static class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements RandomAccess, java.io.Serializable &#123; ... @Override public E get(int index) &#123; ... &#125; @Override public E set(int index, E element) &#123; ... &#125; @Override public int indexOf(Object o) &#123; ... &#125; @Override public boolean contains(Object o) &#123; ... &#125; @Override public void forEach(Consumer&lt;? super E&gt; action) &#123; ... &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; ... &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; ... &#125;&#125;我们再看一下java.util.AbstractList的remove()方法，这样我们就明白为啥会抛出UnsupportedOperationException。123public E remove(int index) &#123; throw new UnsupportedOperationException();&#125;正确的数组转集合的方法：List list = new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))Comparable &amp; ComparatorComparableThis interface imposes a total ordering on the objects of each class that implements it. This ordering is referred to as the class’s natural ordering, and the class’s compareTo method is referred to as its natural comparison method.Lists (and arrays) of objects that implement this interface can be sorted automatically by Collections.sort (and Arrays.sort). Objects that implement this interface can be used as keys in a sorted map or as elements in a sorted set, without the need to specify a comparator.compareTo 方法的返回值有三种情况：e1.compareTo(e2) &gt; 0 即 e1 &gt; e2e1.compareTo(e2) = 0 即 e1 = e2e1.compareTo(e2) &lt; 0 即 e1 &lt; e2满足上述规则的是升序排序，与上诉规则相反则是降序排序。1234567891011121314151617181920212223242526public class Test &#123; public static void main(String[] args) throws IOException &#123; Set&lt;Person&gt; set = new TreeSet&lt;&gt;(); set.add(new Person(50)); set.add(new Person(30)); set.add(new Person(90)); Iterator&lt;Person&gt; iterator = set.iterator(); while(iterator.hasNext()) System.out.println(iterator.next()); &#125; &#125;class Person implements Comparable&lt;Person&gt;&#123; private Integer age; public Person(Integer age) &#123; this.age = age; &#125; @Override public int compareTo(Person o) &#123; if(o == null) throw new NullPointerException(); if(age &gt; o.age) return 1; else if(age &lt; o.age) return -1; return 0; &#125; public String toString() &#123; return "Person [age=" + age + "]"; &#125;&#125;Note that null is not an instance of any class, and e.compareTo(null) should throw a NullPointerException even though e.equals(null) returns false.The natural ordering for a class C is said to be consistent with equals if and only if e1.compareTo(e2) == 0 has the same boolean value as e1.equals(e2) for every e1 and e2 of class C. It is strongly recommended (though not required) that natural orderings be consistent with equals. This is so because sorted sets (and sorted maps)without explicit comparators behave “strangely” when they are used with elements (or keys) whose natural ordering is inconsistent with equals. In particular, such a sorted set (or sorted map) violates（违反） the general contract for set (or map), which is defined in terms of（依据） the equals method.For example, if one adds two keys a and b such that (!a.equals(b) &amp;&amp; a.compareTo(b) == 0) to a sorted set that does not use an explicit comparator, the second add operation returns false (and the size of the sorted set does not increase) because a and b are equivalent from the sorted set’s perspective.这段话的意思是如果compareTo规则和equals规则不同就会发生奇怪的问题，即在!a.equals(b) &amp;&amp; a.compareTo(b) == 0这种情况下，不能插入集合中，因为从排序集合判断是否相等使用compareTo的规则。1234567891011121314151617181920212223242526272829303132333435363738394041public class Test &#123; public static void main(String[] args) throws IOException &#123; Set&lt;Person&gt; set = new TreeSet&lt;&gt;(); set.add(new Person(50)); set.add(new Person(50)); set.add(new Person(90)); Iterator&lt;Person&gt; iterator = set.iterator(); while(iterator.hasNext()) System.out.println(iterator.next()); &#125;&#125;class Person implements Comparable&lt;Person&gt;&#123; private Integer age; public Person(Integer age) &#123; this.age = age; &#125; @Override public int compareTo(Person o) &#123; if(o == null) throw new NullPointerException(); if(age == o.age) // 模仿 a.compareTo(b) == 0 return 0; if(age &gt; o.age) return 1; return -1; &#125; @Override public String toString() &#123; return "Person [age=" + age + "]"; &#125; @Override public boolean equals(Object obj) &#123; if(obj == null || !(obj instanceof Person)) return false; Person p = (Person)obj; if(this.age == 50 || p.age == 50) &#123; // 模仿 !a.equals(b) return false; &#125; return (this.age == p.age) ? true : false; &#125; @Override public int hashCode() &#123; return age.hashCode(); &#125;&#125;// Person [age=50]// Person [age=90]Comparator使用自然排序需要类实现 Comparable，并且在内部重写 comparaTo 方法。而 Comparator 则是在外部制定排序规则，然后作为排序策略参数传递给某些类，比如 Collections.sort(), Arrays.sort(), 或者一些内部有序的集合（比如 SortedSet，SortedMap 等）。同时存在时采用 Comparator（定制排序）的规则进行比较。使用方式主要分三步：创建一个 Comparator 接口的实现类，并赋值给一个对象。在 compare 方法中针对自定义类写排序规则。将 Comparator 对象作为参数传递给 排序类的某个方法向排序类中添加 compare 方法中使用的自定义类1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) throws IOException &#123; Comparator&lt;Person&gt; com = new Comparator&lt;Person&gt;() &#123; @Override public int compare(Person o1, Person o2) &#123; if(o1.getAge() &gt; o2.getAge()) return 1; else if(o1.getAge() &lt; o2.getAge()) return -1; return 0; &#125; &#125;; Set&lt;Person&gt; set = new TreeSet&lt;&gt;(com); set.add(new Person(50)); set.add(new Person(20)); set.add(new Person(90)); Iterator&lt;Person&gt; iterator = set.iterator(); while(iterator.hasNext()) System.out.println(iterator.next()); &#125; &#125;class Person&#123; private Integer age; public Person(Integer age) &#123; this.age = age; &#125; @Override public String toString() &#123; return "Person [age=" + age + "]"; &#125; public Integer getAge() &#123; return age; &#125; public void setAge(Integer age) &#123; this.age = age; &#125;&#125;需要注意的一点是，compare的相等规则需要个equals相同。Collections和Arrays常见方法Collections排序操作123456void reverse(List list) //反转void shuffle(List list) //随机排序void sort(List list) //按自然排序的升序排序void sort(List list, Comparator c) //定制排序，由Comparator控制排序逻辑void swap(List list, int i , int j) //交换两个索引位置的元素void rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。查找，替换操作1234567891011int binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的 int max(Collection coll)//根据元素的自然顺序，返回最大的元素。int min(Collection coll)int max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)void fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。int frequency(Collection c, Object o)//统计元素出现次数int indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1int lastIndexOfSubList(List source, list target)boolean replaceAll(List list, Object oldVal, Object newVal) //用新元素替换旧元素Arrays排序 : sort()12345678910111213141516171819202122232425262728293031323334int a[] = &#123; 1, 3, 2, 7, 6, 5, 4, 9 &#125;;// sort(int[] a)方法按照数字顺序排列指定的数组。Arrays.sort(a);System.out.println("Arrays.sort(a):");for (int i : a) &#123; System.out.print(i);&#125;// 换行System.out.println();// sort(int[] a,int fromIndex,int toIndex)按升序排列数组的指定范围int b[] = &#123; 1, 3, 2, 7, 6, 5, 4, 9 &#125;;Arrays.sort(b, 2, 6);System.out.println("Arrays.sort(b, 2, 6):");for (int i : b) &#123; System.out.print(i);&#125;// 换行System.out.println();int c[] = &#123; 1, 3, 2, 7, 6, 5, 4, 9 &#125;;// parallelSort(int[] a) 按照数字顺序排列指定的数组(并行的)。同sort方法一样也有按范围的排序Arrays.parallelSort(c);System.out.println("Arrays.parallelSort(c)：");for (int i : c) &#123; System.out.print(i);&#125;// 换行System.out.println();// parallelSort给字符数组排序，sort也可以char d[] = &#123; 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' &#125;;Arrays.parallelSort(d);System.out.println("Arrays.parallelSort(d)：");for (char d2 : d) &#123; System.out.print(d2);&#125;查找 : binarySearch()1234567char[] e = &#123; 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' &#125;;// 排序后再进行二分查找，否则找不到Arrays.sort(e);System.out.println("Arrays.sort(e)" + Arrays.toString(e));System.out.println("Arrays.binarySearch(e, 'c')：");int s = Arrays.binarySearch(e, 'c');System.out.println("字符c在数组的位置：" + s);比较: equals()1234567char[] e = &#123; 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' &#125;;char[] f = &#123; 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' &#125;;/** 元素数量相同，并且相同位置的元素相同。 另外，如果两个数组引用都是null，则它们被认为是相等的 。*/// 输出trueSystem.out.println("Arrays.equals(e, f):" + Arrays.equals(e, f));填充 : fill()123456789101112131415161718int[] g = &#123; 1, 2, 3, 3, 3, 3, 6, 6, 6 &#125;;// 数组中所有元素重新分配值Arrays.fill(g, 3);System.out.println("Arrays.fill(g, 3)：");// 输出结果：333333333for (int i : g) &#123; System.out.print(i);&#125;// 换行System.out.println();int[] h = &#123; 1, 2, 3, 3, 3, 3, 6, 6, 6, &#125;;// 数组中指定范围元素重新分配值Arrays.fill(h, 0, 2, 9);System.out.println("Arrays.fill(h, 0, 2, 9);：");// 输出结果：993333666for (int i : h) &#123; System.out.print(i);&#125;转列表 asList()12345678/** 返回由指定数组支持的固定大小的列表。* （将返回的列表更改为“写入数组”。）该方法作为基于数组和基于集合的API之间的桥梁，与Collection.toArray()相结合 。* 返回的列表是可序列化的，并实现RandomAccess 。* 此方法还提供了一种方便的方式来创建一个初始化为包含几个元素的固定大小的列表如下：*/List&lt;String&gt; stooges = Arrays.asList("Larry", "Moe", "Curly");System.out.println(stooges);转字符串 toString()12345/** 返回指定数组的内容的字符串表示形式。*/char[] k = &#123; 'a', 'f', 'b', 'c', 'e', 'A', 'C', 'B' &#125;;System.out.println(Arrays.toString(k));// [a, f, b, c, e, A, C, B]复制 copyOf()12345678910111213141516171819// copyOf 方法实现数组复制,h为数组，6为复制的长度int[] h = &#123; 1, 2, 3, 3, 3, 3, 6, 6, 6, &#125;;int i[] = Arrays.copyOf(h, 6);System.out.println("Arrays.copyOf(h, 6);：");// 输出结果：123333for (int j : i) &#123; System.out.print(j);&#125;// 换行System.out.println();// copyOfRange将指定数组的指定范围复制到新数组中int j[] = Arrays.copyOfRange(h, 6, 11);System.out.println("Arrays.copyOfRange(h, 6, 11)：");// 输出结果66600(h数组只有9个元素这里是从索引6到索引11复制所以不足的就为0)for (int j2 : j) &#123; System.out.print(j2);&#125;// 换行System.out.println();]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.09-JavaSE-集合-3]]></title>
    <url>%2Fposts%2F57414.html%2F</url>
    <content type="text"><![CDATA[红黑树二叉搜索树由于红黑树是二叉查找树的平衡模式，所以在了解红黑树之前，咱们先来看下二叉查找树。二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree），排序二叉树（sorted binary tree），是指一棵空树或者具有下列性质的二叉树：若任意结点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；若任意结点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；任意结点的左、右子树也分别为二叉查找树。没有键值相等的结点（no duplicate nodes）。因为，一棵由n个结点，随机构造的二叉查找树的高度为lgn，一般操作的执行时间为O（lgn）。但二叉树若退化成了一棵具有n个结点的线性链后，则此些操作最坏情况运行时间为O（n）。性质红黑树是一颗平衡二叉树，平衡二叉树的概念：每课树的左右子树高度差都不超过1。每个结点都有颜色，红色或者黑色根结点是黑色的每个叶结点是黑色的（设叶结点是NIL，但它不是一个空节点，是一个哨兵）如果一个结点是红色的，则它的两个子结点都是黑色的对每个结点，从该结点到其所有后代结点的简单路径上，均包含相同数目的黑色结点图中的NIL其实可以用一个哨兵（T.nil）替代，但在画图时往往其实不画NIL结点。旋转对红黑树的增加和删除会破坏红黑树原本的性质，旋转是用来使其恢复到红黑树的手段。左旋1234567891011121314// LEFT-ROTATE(T, x) 设x是图中的pivoty = x.rightx.right = y.leftif y.left != T.nil y.left.p = xy.p = x.pif x.p == T.nil T.root = yelse if x == x.p.left // 判断应该放在P的左子树还是右子树上 x.p.left = yelse x.p.right = yy.left = xx.p = y右旋1234567891011121314// RIGHT-ROTATE(T, x) 设x是图中的pivoty = x.leftx.left = y.rightif y.right != T.nil y.right.p = xy.p = x.pif x.p == T.nil T.root = yelse if x == x.p.right // 判断应该放在P的左子树还是右子树上 x.p.right = yelse x.p.lrft = yy.right = xx.p = y二叉查找树的插入如果要在二叉查找树中插入一个结点，首先要查找到结点插入的位置，然后进行插入，假设插入的结点为z的话，插入的伪代码如下：12345678910111213141516// TREE-INSERT(T, z)y = T.nilx = T.rootwhile x != NIL y = x if z.key &lt; x.key x = x.left else x = x.rightz.p = yif y == NIL T.root = z // Tree T was emptyelse if z.key &lt; y.key y.left = zelse y.right = z红黑树的插入如果我们插入的是黑色节点，会违反了性质五，需要进行大规模调整，如果我们插入的是红色节点，那就只有在要插入节点的父节点也是红色的时候违反性质四或者是当插入的节点是根节点时，违反性质二，所以，我们把要插入的节点的颜色变成红色。仍然设被插入结点是z：1234567891011121314151617181920// RB-INSERT(T, z)y = T.nilx = T.rootwhile x != T.nil y = x if z.key &lt; x.key x = x.left else x = x.rightz.p = yif y == T.nil T.root = zelse if z.key &lt; y.key y.left = zelse y.right = zz.left = T.nilz.right = T.nilz.color = REDRB-INSERT-FIXUP(T, z)我们把上面这段红黑树的插入代码，跟我们之前看到的二叉查找树的插入代码，可以看出，RB-INSERT(T, z)前面的16行代码基本就是二叉查找树的插入代码，然后第17-18行代码把z的左孩子、右孩子都赋为叶结点nil，第19行再把z结点着为红色，最后为保证红黑性质在插入操作后依然保持，调用一个辅助程序RB-INSERT-FIXUP来对结点进行重新着色，并旋转。 换言之：如果插入的是根结点，因为原树是空树，此情况只会违反性质2，所以直接把此结点涂为黑色。如果插入的结点的父结点是黑色，由于此不会违反性质2和性质4，红黑树没有被破坏，所以此时也是什么也不做。但当遇到下述3种情况时需要修复：插入修复情况1：如果当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色插入修复情况2：当前结点的父结点是红色，叔叔结点是黑色，当前结点是其父结点的右子插入修复情况3：当前结点的父结点是红色，叔叔结点是黑色，当前结点是其父结点的左子修复1234567891011121314151617181920212223242526RB-INSERT-FIXUP(T, z)while z.p.color == RED if z.p == z.p.p.left y = z.p.p.right // 指向叔叔结点 if y.color == RED z.p.color = BLACK y.color = BLACK z.p.p.color = RED else if z == z.p.right z = z.p LEFT-ROTATE(T, z) z.p.color = BLACK z.p.p.color = RED RIGHT-ROTATE(T, z.p.p) else // 与 if 对称，等下只分析if，不分析else y = z.p.p.left if y.color == RED z.p.color = BLACK z.p.p.color = RED else if z == z.p.left z = z.p RIGHT-ROTATE(T, z) z.p.color = BLACK z.p.p.color = RED LEFT-ROTATE(T, z.p.p)T.root.color = BLACK下面，咱们来分别处理上述3种插入修复情况。插入修复情况1：当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色。上诉代码中第5行至第8行是处理这种情况：将父结点和叔叔结点涂黑，将爷爷结点涂红。插入修复情况2：当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的右子上诉代码中第9行至第11行是处理这种情况：当前结点的父结点做为新的当前结点，以新当前结点为支点左旋。插入修复情况3：当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的左子上述代码中的12-14行处理此种情况：父结点变为黑色，祖父结点变为红色，在祖父结点为支点右旋。二叉查找树的后继12345678// TREE-SUCCESSOR(x)if x.right != T.nil return TREE-MINIMUM(x.right)y = x.pwhile y != T.nil and x == y.right x = y y = y.preturn y$x$是待查找结点，右子树不为空，右子树的最小值所在的节点是后继。解释第4-8行代码需要证明一个定理：对于一棵二叉搜索树T，其关键字各不相同，如果T中一个节点$x$的右子树为空，且$x$有一个后继$y$，那么$y$一定是$x$的最底层祖先，并且其左孩子也是$x$的祖先。（每个结点都是其自身的祖先）证明对于给定结点$x$，若其后继$y$存在，则$y &gt; x$。考虑结点$x$，对于$x$的左子树，显然其中任意结点值都小于$x$，所以$y$必定不在其左子树中。$x$的右子树，其中任意结点值都大于$x$,但是根据题设，其右子树为空。所以，$y$必定为$x$的祖先或其祖先的右子树。又因为$y$是其中大于$x$且最小的一个，则$y$不可能是其祖先的右子树，那么我们可以将范围缩小至$y$必定为$x$的某一祖先，又根据$y&gt;x$，则$x$必定在$y$的左子树中，即$y$的左孩子也是$x$的祖先（$x$也是$x$的祖先）对于所有满足条件的，假设有$p_0,p_1 \dots p_n$共$n+1$个，且$p_0 &lt; p_1 &lt; p_2 &lt; \dots &lt; p_n$。显然，$x$的前驱结点$y$必定是其中的最小一个，即$y=p_0$。又因为$y$是$x$的祖先，则$y$必然是$x$的最底层祖先。结论这个定理实际的意义是，对于二叉搜索树中的一个节点（$x$），如果其不存在右子树且还有后继（$y$），则$y$是$x$祖先节点中有左子树的最底层祖先。如下图中13的后继是15。二叉查找树的前驱前驱的代码和后继对应。12345678TREE-PREDECESSOR(x)if x.left != null return TREE-MAXNUM(x.left);y = x.pwhile y != null and x == y.left x = y y = y.preturn y3-7行代码的意思是，对于二叉搜索树中的一个节点（$x$），如果其不存在左子树且还有前驱（$y$），则$y$是$x$祖先节点中有右子树的最底层祖先。如图中17的前驱是15。二叉查找树的删除讨论删除之前需要证明一个定理：如果一个二叉搜索树中的一个节点有两个孩子，那么它的后继没有左孩子，它的前驱没有右孩子。证明如果一棵二叉搜索树中的一个结点有两个孩子，那么它的后继为它的右子树中的最小值，所以它的后继没有左孩子，它的前驱为它的左子树中的最大值，所以它的前驱没有右孩子。删除时有三种情况：如果被删除节点（$z$）没有孩子节点，直接删除，修改父节点相应指针指向空。如果$z$只有一个孩子，把孩子提到树中$z$所在的位置，并修改$z$的父节点，用$z$的孩子来替换。如果$z$有两个孩子，那么找$z$的后继$y$（一定在$z$的右子树中）。如果$y$是$z$的右孩子，用$y$替换$z$，同时留下$y$的右孩子。如果$y$不是$z$的右孩子，有之上定理可知，$y$是没有左孩子的，此时用$y$的右孩子替换$y$，用$y$替换$z$，不留下$y$的右孩子。TRANSPLANT123456789// TRANSPLANT(T, u, v)if u.p == T.nil T.root = velse if u == u.p.left u.p.left = velse u.p.right = vif v != T.nil v.p = u.pTRANSPLANT的功能是在树$T$中用一棵以$v$为根的子树来替换一棵以$u$为根的子树。2-3行：当$u$是树根的时候，直接让$T$的根指向$v$。4-5行：当$u$是一个左孩子的时候，将$v$放在$u$的左孩子的位置。6行：当$u$是一个右孩子的时候，将$v$放在$u$的右孩子的位置。7-8行：更新$v$的父节点。TREE-DELETE1234567891011121314TREE-DELETE(T, z)if z.left == T.nil TRANSPLANT(T, z, z.right)else if z.right == T.nil TRANSPLANT(T, z, z.left)else y = TREE-MINIMUM(z.right) if y.p != z TRANSPLANT(T, y, y.right) y.right = z.right y.right.p = y TRANSPLANT(T, z, y) y.left = z.left y.left.p = y2-5行：如果$z$没有左孩子，那么用其右孩子替换$z$。如果$z$没有右孩子，那么用其左孩子替换$z$。12-14行：如果$y$是$z$的右孩子，用$y$替换$z$，同时留下$z$的左孩子。7-11行：如果如果$z$有两个孩子，且$y$不是$z$的右孩子，用$y$的右孩子替换$y$，用$y$替换$z$。红黑树的删除红黑树的删除和二叉查找树的删除有类似的结构。RB-TRANSPLANT12345678// RB-TRANSPLANT(T, u, v)if u.p == T.nil T.root = velse if u == u.p.left u.p.left = velse u.p.right = vv.p = u.p过程RB-TRANSPLANT与TRANSPLANT有一点不同，即第8行无条件赋值，因为红黑树中的哨兵不是空。RB-DELETE12345678910111213141516171819202122232425// RB-DELETE(T, z)y = zy-original-color = y.color // 删除的结点的颜色if z.left == T.nil // 左子树为空，右子树直接上去 x = z.right // x指向被删除结点的右孩子 RB-TRANSPLANT(T, z, z.right)else if z.right == T.nil // 右子树为空，右子树直接上去 x = z.left RB-TRANSPLANT(T, z, z.left)else y = TREE-MINIMUM(z.right) // 右子树中最小的 y-original-color = y.color // 删除的节点的颜色 x = y.right if y.p == z x.p = y else RB-TRANSPLANT(T, y, y.right) // 和二叉搜索树删除时第2、3点一致 y.right = z.right y.right.p = y RB-TRANSPLANT(T, z, y) y.left = z.left y.left.p = y y.color = z.colorif y-original-color == BLACK //当删除的是黑色时需要调整，红色不需要 RB-DELETE-FIXUP(T, x)我们从被删结点后来顶替它的那个结点开始调整，并认为它有额外的一重黑色。这里额外一重黑色是什么意思呢，我们不是把红黑树的结点加上除红与黑的另一种颜色，这里只是一种假设，我们认为我们当前指向它，因此空有额外一种黑色，可以认为它的黑色是从它的父结点被删除后继承给它的，它现在可以容纳两种颜色，如果它原来是红色，那么现在是红+黑，如果原来是黑色，那么它现在的颜色是黑+黑。有了这重额外的黑色，原红黑树性质5就能保持不变。现在只要恢复其它性质就可以了，做法还是尽量向根移动和穷举所有可能性。12345678910111213141516171819202122232425// RB-DELETE-FIXUP(T, x)while x != T.root and x.color == BLACK if x == x.p.left w = x.p.right // 兄弟结点 if w.color == RED w.color = BLACK x.p.color = RED LEFT-ROTATE(T, x.p) w = x.p.right if w.left.color == BLACK and w.right.color == BLACK w.color = RED x = x.p else if w.right.color == BLACK w.left.color = BLACK w.color= RED RIGHT-RATATE(T, w) w = x.p.right w.color = x.p.color x.p.color = BLACK w.right.color = BLACK LEFT-ROTATE(T, x.p) x = T.root else same as then clause with "right" and "left" exchangedx.color = BLACK（y是被删除的结点，x是怼上去的结点，即x占据了y的位置）如果y的颜色是RED，则y不可能为红黑树的根，所以不管x的颜色是什么，都不会影响到红黑树的性质。所以只考虑y的颜色为BLACK的情况。在y的颜色是BLACK的情况下，如果x的颜色为RED的话，删除y之后，结点y所在的分支的黑高就会减1，所以，只需要将x的颜色变为BLACK，则该分支的黑高会加1，则会保持住红黑树的颜色性质。所以最终要考虑的情况就是：y颜色为BLACK，x的颜色为BLACK的情况。因把y删除后，x顶替y的位置，y所在分支的黑高减1，所以，假设x节点的颜色为BLACK-BLACK，简称BB，也就是原来y的BLACK增加到x上了，这样就保证了该分支的黑高不变，接下来要做的就是调整x所在的分支，使红黑树的性质保持不变，又分为下面的几种情况（只考虑x为左孩子的情况，右孩子的情况是对称的）删除修复情况1：当前结点是黑+黑且兄弟结点为红色(此时父结点和兄弟结点的子结点为黑)。解法：把父结点染成红色，把兄弟结点染成黑色，左旋，之后重新进入算法。此变换后原红黑树性质5不变，而把问题转化为兄弟结点为黑色的情况(注：变化前，原本就未违反性质5，只是为了把问题转化为兄弟结点为黑色的情况)。 即第5行至第9行。删除修复情况2：当前结点是黑加黑且兄弟是黑色且兄弟结点的两个子结点全为黑色。解法：把当前结点和兄弟结点中抽取一重黑色追加到父结点上，把父结点当成新的当前结点，重新进入算法。（此变换后性质5不变），即第10-12行代码操作。删除修复情况3：当前结点颜色是黑+黑，兄弟结点是黑色，兄弟的左子是红色，右子是黑色。解法：把兄弟结点染红，兄弟左子结点染黑，之后再以兄弟结点为支点解右旋，之后重新进入算法。此是把当前的情况转化为情况4，而性质5得以保持，即第13-17行代码：删除修复情况4：当前结点颜色是黑-黑色，它的兄弟结点是黑色，但是兄弟结点的右子是红色，兄弟结点左子的颜色任意。解法：把兄弟结点染成当前结点父结点的颜色，把当前结点父结点染成黑色，兄弟结点右子染成黑色，之后以当前结点的父结点为支点进行左旋，此时算法结束，红黑树所有性质调整正确，即第18-22行代码，如下所示：TreeMap分析123public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable在此分析一下Map的体系结构：AbstractMap是一个实现Map接口的抽象类，它实现了一个Map的骨架，方便开发者来实现一个自己的Map。如果开发者需要实现一个自己的不可变的Map，只需要继承它再实现entrySet方法。如果开发者想需要实现一个自己的可变的Map，在不可变Map的基础上还需要实现put方法，并且在其的iterator上实现remove方法。SortedMap是一个键有序的Map，存在Comparator时使用其规则，否则使用Comparable的规则。NavigableMap是一个导航Map，它含有的方法可以帮助寻找一个键的上一个键，下一个键，或者按键值逆序等。旋转左旋1234567891011121314151617private void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125;&#125;右旋123456789101112131415private void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125;&#125;增加1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; if (t == null) &#123; // 如果实体不支持自然排序，有没有传入排序器，报异常。此行代码只做类型检查 compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) // key &lt; t.key t = t.left; else if (cmp &gt; 0) // key &gt; t.key t = t.right; else return t.setValue(value); // key和t.key相等时覆盖 &#125; while (t != null); &#125; else &#123; if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; // t为空时会走到此步，parent为最后一个经过的有数据的节点 Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null; // 返回的是旧的 value&#125;123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; // y是x的叔叔结点 Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); // 当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色 // 将父结点和叔叔结点涂黑，将爷爷结点涂红 if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); // 当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的右子 // 当前结点的父结点做为新的当前结点，以新当前结点为支点左旋 &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; // 当前结点的父结点是红色，叔叔结点是黑色，当前结点是其父结点的左子 // 父结点变为黑色，祖父结点变为红色，在祖父结点为支点右旋 setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); // 当前结点的父结点是红色且祖父结点的另一个子结点（叔叔结点）是红色 // 将父结点和叔叔结点涂黑，将爷爷结点涂红 if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); // 当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的左子 // 当前结点的父结点做为新的当前结点，以新当前结点为支点右旋 &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; // 当前结点的父结点是红色,叔叔结点是黑色，当前结点是其父结点的左子 // 父结点变为黑色，祖父结点变为红色，在祖父结点为支点左旋 setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; root.color = BLACK;&#125;删除123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public V remove(Object key) &#123; Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; V oldValue = p.value; deleteEntry(p); return oldValue; // 返回旧的value&#125;private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; // If strictly internal, copy successor's element to p and then make p // point to successor. if (p.left != null &amp;&amp; p.right != null) &#123; // s 是后继 Entry&lt;K,V&gt; s = successor(p); // p 拷贝到 s p.key = s.key; p.value = s.value; // p 现在指向需要被删除的结点 p = s; &#125; // p has 2 children // 到了这里，无论原始的p有无孩子，p都是被即将被删除的结点 // Start fixup at replacement node, if it exists. Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); // replacement指向有数据的子树，设为R子树，此子树会替代原始的子树 if (replacement != null) &#123; // 有孩子 // Link replacement to parent // R子树的父亲指向即将被删除的结点的父亲 replacement.parent = p.parent; // 如果即将被删除的结点没有父亲（有孩子） if (p.parent == null) root = replacement; // 把R子树挂上去 else if (p == p.parent.left) p.parent.left = replacement; // 把R子树挂上去 else p.parent.right = replacement; // 到了这步，p已经被替换掉了。将其的连接结点都置空 // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; // Fix replacement // R子树上去后，如果是删除的结点是黑色，需要调整 if (p.color == BLACK) fixAfterDeletion(replacement); // 和第39行的区别是：第39行的情况p是一个根结点，而此种情况就p这一个结点 &#125; else if (p.parent == null) &#123; // return if we are the only node. root = null; // 没有孩子，有父亲，是个叶结点 &#125; else &#123; // No children. Use self as phantom replacement and unlink. if (p.color == BLACK) // 转下去分析修复 fixAfterDeletion(p); if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125;&#125;12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879// x 是上一步的R子树private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; // 真正要修复的情况是：被删除的结点是黑色且升上去的结点也是黑色（此时黑高会减1） // 算法的目的是让x指向的那棵树是红结点且整棵树不违反红黑树的性质 while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; // 总共有四种违反红黑树性质的情况。 // 若被删除的结点树红色，直接删除，无任何影响 // 若被删除的结点是黑色，但是上来的结点是红色，直接将其染黑就行了 if (x == leftOf(parentOf(x))) &#123; // 当前结点是黑+黑且兄弟结点为红色（此时父结点和兄弟结点的子结点为黑） Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); // 把父结点染成红色，把兄弟结点染成黑色，左旋 if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); // 旋转不改变x的指向 rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); &#125; // ---到了这步，x仍然指向这一轮迭代初的结点，sib会转为黑色 // 兄弟结点的两个子结点全为黑色，兄弟结点染红 if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); // 走到此步，退出循环，x此时为红色 x = parentOf(x); &#125; else &#123; // 兄弟结点是黑色，兄弟的左子是红色，右子是黑色 // 把兄弟结点染红，兄弟左子结点染黑，之后再以兄弟结点为支点解右旋 if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); // 调整兄弟结点的指向 sib = rightOf(parentOf(x)); &#125; // 到了这步，兄弟结点是黑色，兄弟结点的右子是红色 // 把兄弟结点染成当前结点父结点的颜色，把当前结点父结点染成黑色， // 兄弟结点右子染成黑色，之后以当前结点的父结点为支点进行左旋 setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; &#125; &#125; else &#123; // symmetric Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; &#125; &#125; &#125; setColor(x, BLACK);&#125;2-3树红黑树是目前在工程应用中被证实综合性能最好的平衡树，但是为什么它就是那么好的？实际上红黑树吸收了AVL树和2-3树的特点。对于AVL树，是历史上第一个被创造的平衡二叉树，也是一颗绝对符合平衡二叉树性质的树。红黑树吸收了它的旋转思想来调整红黑树的状态。对于2-3树，红黑树其实就等价于等价于2-3树。我们下面就分析2-3树。树的定义2-3 树要么为空要么如下：对于 2- 节点，和普通的 BST 节点一样，有一个数据域和两个子节点指针，两个子节点要么为空，要么也是一个2-3树，当前节点的数据的值要大于左子树中所有节点的数据，要小于右子树中所有节点的数据。对于 3- 节点，有两个数据域 a 和 b 和三个子节点指针，左子树中所有的节点数据要小于a，中子树中所有节点数据要大于 a 而小于 b ，右子树中所有节点数据要大于 b 。性质：对于每一个结点有 1 或者 2 个关键码。当节点有一个关键码的时，节点有 2 个子树。当节点有 2 个关键码时，节点有 3 个子树。所有叶子点都在树的同一层。2-3树查找2-3 树的查找类似二叉搜索树的查找过程，根据键值的比较来决定查找的方向。2-3树插入对于非空树插入主要分为 4 种情况：向2-节点中插入新节点向一棵只含3-节点的树中插入新节点向一个父节点为2-节点的3-节点中插入新节点向一个父节点为3-节点的3-节点中插入新节点向2-节点中插入新节点操作步骤：如果未命中查找结束于一个2-节点，直接将2-节点替换为一个3-节点，并将要插入的键保存在其中。向一棵只含3-节点的树中插入新节点操作步骤：先临时将新键存入唯一的3-节点中，使其成为一个4-节点，再将它转化为一颗由3个2- 节点组成的2-3 树，分解后树高会增加1。向一个父节点为2-节点的3-节点中插入新节点操作步骤：先构造一个临时的4-节点并将其分解，分解时将中键移动到父节点中（中键移动后，其父节点中的位置由键的大小确定）向一个父节点为3-节点的3-节点中插入新节点操作步骤：插入节点后一直向上分解构造的临时4-节点并将中键移动到更高层双亲节点，直到遇到一个2-节点并将其替换为一个不需要继续分解的3-节点，或是到达树根（3-节点）。分解根节点操作步骤：如果从插入节点到根节点的路径上全是3-节点（包含根节点在内），根节点将最终被替换为一个临时的4-节点，将临时的4-节点分解为3个2-节点，分解后树高会增加1。2-3树删除删除之前，先要对2-3树进行一次命中的查找，查找成功才可以进行删除操作。删除节点大概分为3种情形删除非叶子节点。删除不为2-节点的叶子节点。删除为2-节点的叶子节点。删除非叶子节点操作步骤：使用中序遍历下的直接后继节点key来覆盖当前待删除节点key，再删除用来覆盖的后继节点key。删除不为2-节点的叶子节点操作步骤：删除不为2-节点的叶子节点，直接删除节点即可。删除节点为2-节点，父节点为2-节点，兄弟节点为3-节点操作步骤：当前待删除节点的父节点是2-节点、兄弟节点是3-节点，将父节点移动到当前待删除节点位置，再将兄弟节点中最接近当前位置的key移动到父节点中。删除节点为2-节点，父节点为2-节点，兄弟节点为2-节点操作步骤：当前待删除节点的父节点是2-节点、兄弟节点也是2-节点，先通过移动兄弟节点的中序遍历直接后驱到兄弟节点，以使兄弟节点变为3-节点。删除节点为2-节点，父节点为3-节点操作步骤：当前待删除节点的父节点是3-节点，拆分父节点使其成为2-节点，再将再将父节点中最接近的一个拆分key与中孩子合并，将合并后的节点作为当前节点。2-3树为满二叉树，删除叶子节点操作步骤：若2-3树是一颗满二叉树，将2-3树层树减少，并将当前删除节点的兄弟节点合并到父节点中，同时将父节点的所有兄弟节点合并到父节点的父节点中，如果生成了4-节点，再分解4-节点。如何理解红黑树对红黑树的每个结点，从该结点到其所有后代结点的简单路径上，均包含相同数目的黑色结点。也就是说其黑节点是一个绝对平衡的二叉树。所以整个树是不是平衡其实是看红色节点是不是产生了倾斜，但是有规定红节点的子节点是黑节点，确保整棵树不会偏的最狠，即使是红黑节点交叉的情况，双方的最大高度差值也是2倍，不会降为线性。为什么红节点的子节点全都是黑节点呢，因为如果不是，会产生红节点的儿子是红节点，红儿子的节点还是红节点的情况，最终一路红到底，破坏了性质5。分析我们前面的代码会发现红黑树在插入删除的时候不需要进行递归，所以对红黑树的插入删除操作可以在O(1)的复杂度内完成。而AVL树最差的情况是O(lgn)。部分转至https://www.itcodemonkey.com/article/13495.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.08-JavaSE-集合-2]]></title>
    <url>%2Fposts%2F45270.html%2F</url>
    <content type="text"><![CDATA[HashMap分析HashMap 主要用来存放键值对，它基于哈希表的Map接口实现，是常用的Java集合之一。JDK8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK8 以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。底层数据结构分析JDK8之前JDK8 之前 HashMap 底层是数组和链表结合在一起使用也就是链表散列。HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。JDK 8 HashMap 的 hash 方法源码:JDK 8 的 hash方法 相比于 JDK 7 hash 方法更加简化，但是原理不变。12345678public class LinkedListDemo &#123; static final int hash(Object key) &#123; int h; // key.hashCode()：返回散列值也就是hashcode // ^ ：按位异或 // &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐 return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125;对比一下 JDK7的 HashMap 的 hash 方法源码.1234567static int hash(int h) &#123; // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default load factor). h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4);&#125;相比于 JDK8 的 hash 方法 ，JDK7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。所谓 “拉链法” 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。JDK8之后相比于之前的版本，JDK8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。类的属性：12345678910111213141516171819202122232425262728public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; // 序列号 private static final long serialVersionUID = 362498820763181265L; // 默认的初始容量是16 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // 最大容量 static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; // 默认的填充因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; // 当桶(bucket)上的结点数大于这个值时会转成红黑树 static final int TREEIFY_THRESHOLD = 8; // 当桶(bucket)上的结点数小于这个值时树转链表 static final int UNTREEIFY_THRESHOLD = 6; // 桶中结构转化为红黑树对应的table的最小大小 static final int MIN_TREEIFY_CAPACITY = 64; // 存储元素的数组，总是2的幂次倍 transient Node&lt;k,v&gt;[] table; // 存放具体元素的集 transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet; // 存放元素的个数，注意这个不等于数组的长度。 transient int size; // 每次扩容和更改map结构的计数器 transient int modCount; // 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容 int threshold; // 加载因子 final float loadFactor;&#125;loadFactor加载因子loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor 越趋近于1，那么 数组中存放的数据（entry）也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于0，数组中存放的数据（entry）也就越少，也就越稀疏。loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。给定的默认容量为 16，负载因子为 0.75。Map 在使用过程中不断的往里面存放数据，当数量达到了 16 * 0.75 = 12 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。thresholdthreshold = capacity * loadFactor，当Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。Node节点类源码1234567891011121314151617181920212223242526272829303132333435363738// 继承自 Map.Entry&lt;K,V&gt;static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash;// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较 final K key;//键 V value;//值 // 指向下一个节点 Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + "=" + value; &#125; // 重写hashCode()方法 public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; // 重写 equals() 方法 public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125;&#125;树节点类源码123456789101112131415161718static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // 父 TreeNode&lt;K,V&gt; left; // 左 TreeNode&lt;K,V&gt; right; // 右 TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; // 判断颜色 TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; // 返回根节点 final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125; &#125;&#125;HashMap源码分析构造方法123456789101112131415161718192021222324// 默认构造函数。public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;// 包含另一个“Map”的构造函数public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);//下面会分析到这个方法&#125;// 指定“容量大小”的构造函数public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;// 指定“容量大小”和“加载因子”的构造函数public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;putMapEntries方法：123456789101112131415161718192021222324final void putMapEntries(Map&lt;? extends K, ? extends V&gt; m, boolean evict) &#123; int s = m.size(); if (s &gt; 0) &#123; // 判断table是否已经初始化 if (table == null) &#123; // pre-size // 未初始化，s为m的实际元素个数 float ft = ((float)s / loadFactor) + 1.0F; int t = ((ft &lt; (float)MAXIMUM_CAPACITY) ? (int)ft : MAXIMUM_CAPACITY); // 计算得到的t大于阈值，则初始化阈值 if (t &gt; threshold) threshold = tableSizeFor(t); &#125; // 已初始化，并且m元素个数大于阈值，进行扩容处理 else if (s &gt; threshold) resize(); // 将m中的所有元素添加至HashMap中 for (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123; K key = e.getKey(); V value = e.getValue(); putVal(hash(key), key, value, false, evict); &#125; &#125;&#125;put方法HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。对putVal方法添加元素的分析如下：如果定位到的数组位置没有元素 就直接插入。如果定位到的数组位置有元素就和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)将元素添加进入。如果不是就遍历链表插入(插入的是链表尾部)。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; // table未初始化或者长度为0，进行扩容 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; // (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中) if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); // 桶中已经存在元素 else &#123; Node&lt;K,V&gt; e; K k; // 比较桶中第一个元素(数组中的结点)的hash值相等，key相等 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) // 将第一个元素赋值给e，用e来记录 e = p; // hash值不相等，即key不相等；为红黑树结点 else if (p instanceof TreeNode) // 放入树中 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); // 为链表结点 else &#123; // 在链表最末插入结点 for (int binCount = 0; ; ++binCount) &#123; // 到达链表的尾部 if ((e = p.next) == null) &#123; // 在尾部插入新结点 p.next = newNode(hash, key, value, null); // 结点数量达到阈值，转化为红黑树 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); // 跳出循环 break; &#125; // 判断链表中结点的key值与插入的元素的key值是否相等 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) // 相等，跳出循环 break; // 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表 p = e; &#125; &#125; // 表示在桶中找到key值、hash值与插入元素相等的结点 if (e != null) &#123; // 记录e的value V oldValue = e.value; // onlyIfAbsent为false或者旧值为null if (!onlyIfAbsent || oldValue == null) //用新值替换旧值 e.value = value; // 访问后回调 afterNodeAccess(e); // 返回旧值 return oldValue; &#125; &#125; // 结构性修改 ++modCount; // 实际大小大于阈值则扩容 if (++size &gt; threshold) resize(); // 插入后回调 afterNodeInsertion(evict); return null;&#125;get方法123456789101112131415161718192021222324252627public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; // 数组元素相等 if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; // 桶中不止一个节点 if ((e = first.next) != null) &#123; // 在树中get if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); // 在链表中get do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125;resize方法进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; // 超过最大值就不再扩充了，就只好随你碰撞去吧 if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; // 没超过最大值，就扩充为原来的2倍 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; // 计算新的resize上限 if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; // 把每个bucket都移动到新的buckets中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; // 原索引 if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; // 原索引+oldCap else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); // 原索引放到bucket里 if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; // 原索引+oldCap放到bucket里 if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125;HashMap常用方法测试1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class HashMapDemo &#123; public static void main(String[] args) &#123; HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;(); // 键不能重复，值可以重复 map.put("san", "张三"); map.put("si", "李四"); map.put("wu", "王五"); map.put("wang", "老王"); map.put("wang", "老王2");// 老王被覆盖 map.put("lao", "老王"); System.out.println("-------直接输出hashmap:-------"); System.out.println(map); /** * 遍历HashMap */ // 1.获取Map中的所有键 System.out.println("-------foreach获取Map中所有的键:------"); Set&lt;String&gt; keys = map.keySet(); for (String key : keys) &#123; System.out.print(key+" "); &#125; System.out.println();//换行 // 2.获取Map中所有值 System.out.println("-------foreach获取Map中所有的值:------"); Collection&lt;String&gt; values = map.values(); for (String value : values) &#123; System.out.print(value+" "); &#125; System.out.println();//换行 // 3.得到key的值的同时得到key所对应的值 System.out.println("-------得到key的值的同时得到key所对应的值:-------"); Set&lt;String&gt; keys2 = map.keySet(); for (String key : keys2) &#123; System.out.print(key + "：" + map.get(key)+" "); &#125; /** * 另外一种不常用的遍历方式 */ // 当我调用put(key,value)方法的时候，首先会把key和value封装到 // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取 // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来 // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了 Set&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet(); for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123; System.out.println(entry.getKey() + "--" + entry.getValue()); &#125; /** * HashMap其他常用方法 */ System.out.println("after map.size()："+map.size()); System.out.println("after map.isEmpty()："+map.isEmpty()); System.out.println(map.remove("san")); System.out.println("after map.remove()："+map); System.out.println("after map.get(si)："+map.get("si")); System.out.println("after map.containsKey(si)："+map.containsKey("si")); System.out.println("after containsValue(李四)："+map.containsValue("李四")); System.out.println(map.replace("si", "李四2")); System.out.println("after map.replace(si, 李四2):"+map); &#125;&#125;equals()和hashCode()Java 对于 eqauls 方法和 hashCode 方法是这样规定的：如果两个对象相同（equals 方法返回 true），那么它们的 hashCode 值一定要相同；如果两个对象的 hashCode 相同，它们并不一定相同。equals()需要满足的性质自反性：x.equals(x)必须返回 true对称性：x.equals(y)返回 true 时，y.equals(x)也必须返回 true传递性：x.equals(y)和 y.equals(z)都返回 true 时，x.equals(z)也必须返回 true一致性：当x 和 y 引用的对象信息没有被修改时，多次调用 x.equals(y)应该得到同样的返回值，对于任何非 null 值的引用 x，x.equals(null)必须返回 false。实现高质量的 equals ()使用==操作符检查”参数是否为这个对象的引用”；使用 instanceof 操作符检查”参数是否为正确的类型”；对于类中的关键属性，检查参数传入对象的属性是否与之相匹配；编写完 equals 方法后，问自己它是否满足对称性、传递性、一致性和空值返回false；重写 equals 时总是要重写 hashCode；不要将 equals 方法参数中的 Object 对象替换为其他的类型，在重写时不要忘掉@Override注解。正确使用equals方法推荐使用：Objects.equals(o1, o2)，此方法的底层实现：1234public static boolean equals(Object a, Object b) &#123; // 可以避免空指针异常。如果a==null的话此时a.equals(b)就不会得到执行，避免出现空指针异常。 return (a == b) || (a != null &amp;&amp; a.equals(b));&#125;两者的关系在使用到哈希机制的集合时需要同时重写equles方法和hashCode方法。即重写对象的散列码是为了更好的支持基于哈希机制的Java集合类，例如 Hashtable, HashMap, HashSet 等，如果不重写hashCode()，在使用哈希机制的集合类时会出错。当把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他已经加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals()方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。但不同对象的hashCode可能重复，所以哈希机制的集合会在判断hashCode之后再判断一次equals。1234567891011121314151617181920212223242526272829303132333435363738public class Demo&#123; public static void main(String[] args) &#123; Person p1 = new Person("eee", 100); Person p2 = new Person("eee", 100); Person p3 = new Person("aaa", 200); Person p4 = new Person("EEE", 100); HashSet set = new HashSet(); set.add(p1); set.add(p2); set.add(p3); // 打印set System.out.printf("set:%s\n", set); &#125; private static class Person &#123; int age; String name; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; @Override public int hashCode()&#123; return name.hashCode() ^ age; &#125; @Override public String toString() &#123; return "Person [age=" + age + ", name=" + name + "]"; &#125; @Override public boolean equals(Object obj)&#123; if(obj == null) return false; if(this == obj) return true; // 如果是同一个对象返回true，反之返回false if(this.getClass() != obj.getClass()) return false; // 判断是否类型相同 Person person = (Person)obj; return name.equals(person.name) &amp;&amp; age==person.age; &#125; &#125;&#125;HashMap面试题HashMap的实现原理你看过HashMap源码嘛，知道原理嘛针对这个问题，嗯，当然是必须看过HashMap源码。至于原理：数组+链表+红黑树。HashMap采用Entry数组来存储key-value对，每一个键值对组成了一个Entry实体，Entry类实际上是一个单向的链表结构，它具有Next指针，可以连接下一个Entry实体。为什么用数组+链表数组是用来确定桶的位置，利用元素的key的hash值对数组长度取模得到。链表是用来解决hash冲突问题，当出现hash值一样的情形，就在数组上的对应位置形成一条链表。hash冲突你还知道哪些解决办法比较出名的有四种：开放定址法、链地址法、再哈希法、公共溢出区域法我用LinkedList代替数组结构可以吗这里我稍微说明一下，此题的意思是，源码中是这样的1Entry[] table = new Entry[capacity];那我用下面这样表示：1List&lt;Entry&gt; table = new LinkedList&lt;Entry&gt;();是否可行？答案很明显，必须是可以的。既然是可以的，为什么HashMap不用LinkedList，而选用数组？因为用数组效率最高！在HashMap中，定位桶的位置是利用元素的key的哈希值对数组长度取模得到。此时，我们已得到桶的位置。显然数组的查找效率比LinkedList大。那ArrayList，底层也是数组，查找也快啊，为啥不用ArrayList？因为采用基本数组结构，扩容机制可以自己定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率高。而ArrayList的扩容机制是1.5倍扩容，那ArrayList为什么是1.5倍扩容这就不在本文说明了。HashMap在什么条件下扩容HashMap在什么条件下扩容如果bucket满了（超过load factor*current capacity），就要resize。默认load factor为0.75，为了最大程度避免哈希冲突。（current capacity为当前数组大小。为什么扩容是2的次幂减少碰撞HashMap为了存取高效，要尽量较少碰撞，就是要尽量把数据分配均匀，每个链表长度大致相同，这个实现就在把数据存到哪个链表中的算法；这个算法实际就是取模，hash%length。但是，大家都知道这种运算不如位移运算快。因此，源码中做了优化hash &amp; (length-1)。也就是说hash%length==hash&amp;(length-1)。那为什么是2的n次方呢？因为2的n次方实际就是1后面n个0，2的n次方-1，实际就是n个1。如果length不为2的幂，比如15。那么length-1的2进制就会变成1110。在h为随机数的情况下，和1110做&amp;操作。尾数永远为0。那么0001、1001、1101等尾数为1的位置就永远不可能被entry占用。这样会造成浪费，不随机等问题。 length-1 二进制中为1的位数越多，那么分布就平均。扩容时减少消耗以下图为例，其中图（a）表示扩容前的key1和key2两种key确定索引位置的示例，图（b）表示扩容后key1和key2两种key确定索引位置的示例，n代表length。元素在重新计算hash之后，因为n变为2倍，那么n-1的mask范围在高位多1bit(红色)，因此新的index就会发生这样的变化：resize过程中不需要像JDK1.7的实现那样重新计算hash，只需要看看原来的hash值新增的那个bit是1还是0就好了，是0的话索引没变，是1的话索引变成“原索引+oldCap“。hash方法为什么为什么要先高16位异或低16位再取模运算1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;hashmap这么做，只是为了降低hash冲突的几率。打个比方，当我们的length为16的时候，哈希码对16-1做与操作，对于多个key生成的hashCode，只要哈希码的后4位为0，不论高位怎么变化，最终的结果均为0。而加上高16位异或低16位的“扰动函数”后，结果如下：可以看到: 扰动函数优化前：1954974080 % 16 = 1954974080 &amp; (16 - 1) = 0 扰动函数优化后：1955003654 % 16 = 1955003654 &amp; (16 - 1) = 6 很显然，减少了碰撞的几率。讲讲hashmap的get/put的过程知道hashmap中put元素的过程是什么样么对key的hashCode()做hash运算，计算index如果没碰撞直接放到bucket里；如果碰撞了，以链表的形式存在buckets后；如果碰撞导致链表过长(大于等于TREEIFY_THRESHOLD)，就把链表转换成红黑树如果节点已经存在就替换old value(保证key的唯一性)如果bucket满了(超过load factor*current capacity)，就要resize。知道hashmap中get元素的过程是什么样么对key的hashCode()做hash运算，计算index;如果在bucket里的第一个节点里直接命中，则直接返回；如果有冲突，则通过key.equals(k)去查找对应的Entry;若为树，则在树中通过key.equals(k)查找，O(logn)；若为链表，则在链表中通过key.equals(k)查找，O(n)。你还知道哪些hash算法先说一下hash算法干嘛的，Hash函数是指把一个大范围映射到一个小范围。把大范围映射到一个小范围的目的往往是为了节省空间，使得数据容易保存。比较出名的有MurmurHash、MD4、MD5等等。说说String中hashcode的实现1234567891011public int hashCode() &#123; int h = hash; if (h == 0 &amp;&amp; value.length &gt; 0) &#123; char val[] = value; for (int i = 0; i &lt; value.length; i++) &#123; h = 31 * h + val[i]; &#125; hash = h; &#125; return h;&#125;就是以31为权，每一位为字符的ASCII值进行运算。哈希计算公式可以计为s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]那为什么以31为质数呢？主要是因为31是一个奇质数，所以31*i=32*i-i=(i&lt;&lt;5)-i，这种位移与减法结合的计算相比一般的运算快很多。hashmap的在链表元素数量超过8时改为红黑树知道jdk1.8中hashmap改了啥么由数组+链表的结构改为数组+链表+红黑树。优化了高位运算的hash算法：h ^ (h&gt;&gt;&gt;16)扩容后，元素要么是在原位置，要么是在原位置再移动2次幂的位置，且链表顺序不变。为什么转红黑树的阈值是8红黑树和链表相比，红黑树在增加时的成本很高，但查询时的成本低，链表查询的成本高，增加的成本低，所以链表转红黑树最好的时机是当转为红黑树后基本不再发生增加操作。为了求在什么时候应当把链表转为红黑树，我们先把问题转换一下，原始的问题应当是：单位桶里插入多少个节点时应该由链表转为红黑树？转化后的问题是：单位桶里插入$k$个节点后再插入节点的概率是多少？进一步转化这个问题可得：单位桶里插入的节点的个数小于等于$k$时的概率是多少？而这个问题又可以转为：单位桶里插入$k$个节点的概率为多少（$q = 1, 2, 3 …$）？假设插入3个数据，每个桶的插入过程抽象为一根线段，把这段时间用$T$来表示：我们把$T$分为4个时间段：此时，在每一个时间段上，要不没有插入，要不有插入。这样$T$内插入3个数据的概率就符合二项分布。我们再假设每个时间段上发生插入的概率是$p$，可得：$C_{4}^{3}p^3(1-p)^1$。我们把$T$划分的越来越细时（设为$n$），插入$k$个数据的概率为：$\lim\limits_{n \to \infty}C_{n}^{k}p^k(1-p)^{n-k}$。而$p$实际上等于发生插入的次数（$\mu$）除以总次数，即$p=\mu/n$。$n$趋近于无穷大时可得：$$\begin{aligned} \lim _{n \rightarrow \infty}\left(\begin{array}{c}{n} \ {k}\end{array}\right)\left(\frac{\mu}{n}\right)^{k}\left(1-\frac{\mu}{n}\right)^{n-k} &amp;=\lim _{n \rightarrow \infty} \frac{n(n-1)(n-2) \cdots(n-k+1)}{k !} \frac{\mu^{k}}{n^{k}}\left(1-\frac{\mu}{n}\right)^{n-k} \ &amp;=\lim _{n \rightarrow \infty} \frac{\mu^{k}}{k !} \frac{n}{n} \cdot \frac{n-1}{n} \cdots \frac{n-k+1}{n}\left(1-\frac{\mu}{n}\right)^{-k}\left(1-\frac{\mu}{n}\right)^{n} \end{aligned}$$其中：$$\lim _{n \rightarrow \infty} \frac{n}{n} \cdot \frac{n-1}{n} \cdots \frac{n-k+1}{n}\left(1-\frac{\mu}{n}\right)^{-k}=1$$$$\lim _{n \rightarrow \infty}\left(1-\frac{\mu}{n}\right)^{n}=e^{-\mu}$$所以：$$\lim _{n \rightarrow \infty}\left(\begin{array}{l}{n} \ {k}\end{array}\right)\left(\frac{\mu}{n}\right)^{k}\left(1-\frac{\mu}{n}\right)^{n-k}=\frac{\mu^{k}}{k !} e^{-\mu}$$上面就是泊松分布的概率密度函数，正好对应了JDK里的注释。即单位桶里插入$k$个元素的概率符合泊松分布。这个时候我们需要求得就的就是$\mu$了。而$\mu$就是发生插入的次数。假设HashMap的大小为$x$，LOAD_FACTOR为$k$，容量的最小值约为$x/k$。 容量的最大值约为$2x/k$（容量必须为2的幂，所以大约为2）。因此容量的平均值为$3x/2k$。 泊松分布的期望值为$x/(3x/2k)=2k/3$。当LOAD_FACTOR为DEFAULT_LOAD_FACTOR = 0.75时。 预期值为2 0.75 / 3 = 0.5。所以每个桶里插入$k$个数据的概率符合参数为0.5的泊松分布。即可以得到如下的结果：1234567890: 0.606530661: 0.303265332: 0.075816333: 0.012636064: 0.001579525: 0.000157956: 0.000013167: 0.000000948: 0.00000006所以当插入8个数据后再插入到此桶的概率基本为0。符合转为红黑树后基本不再发生增加操作这个条件。当链表转为红黑树后，什么时候退化为链表为6的时候退转为链表。中间有个差值7可以防止链表和树之间频繁的转换。假设一下，如果设计成链表个数超过8则链表转换成树结构，链表个数小于8则树结构转换成链表，如果一个HashMap不停的插入、删除元素，链表个数在8左右徘徊，就会频繁的发生树转链表、链表转树，效率会很低。HashMap的key键可以为null值么必须可以，key为null的时候，hash算法最后的值以0来计算，也就是放在数组的第一个位置。1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;你一般用什么作为HashMap的key一般用Integer、String这种不可变类当HashMap当key，而且String最为常用。因为字符串是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。这就使得字符串很适合作为Map中的键，字符串的处理速度要快过其它的键对象。这就是HashMap中的键往往都使用字符串。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的,这些类已经很规范的覆写了hashCode()以及equals()方法。我用可变类当HashMap的key有什么问题hashcode可能发生改变，导致put进去的值，无法get出，如下所示：12345678HashMap&lt;List&lt;String&gt;, Object&gt; changeMap = new HashMap&lt;&gt;();List&lt;String&gt; list = new ArrayList&lt;&gt;();list.add("hello");Object objectValue = new Object();changeMap.put(list, objectValue);System.out.println(changeMap.get(list));list.add("hello world");//hashcode发生了改变System.out.println(changeMap.get(list));如果让你实现一个自定义的class作为HashMap的key该如何实现此题考察两个知识点重写hashcode和equals方法注意什么?如何设计一个不变类针对问题一，记住下面四个原则即可两个对象相等，hashcode一定相等两个对象不等，hashcode不一定不等hashcode相等，两个对象不一定相等hashcode不等，两个对象一定不等针对问题二，记住如何写一个不可变类类添加final修饰符，保证类不被继承。如果类可以被继承会破坏类的不可变性机制，只要继承类覆盖父类的方法并且继承类可以改变成员变量值，那么一旦子类以父类的形式出现时，不能保证当前类是否可变。保证所有成员变量必须私有，并且加上final修饰。通过这种方式保证成员变量不可改变。但只做到这一步还不够，因为如果是对象成员变量有可能再外部改变其值。所以第4点弥补这个不足。不提供改变成员变量的方法，包括setter避免通过其他接口改变成员变量的值，破坏不可变特性。通过构造器初始化所有成员，进行深拷贝(deep copy)，如果构造器传入的对象直接赋值给成员变量，还是可以通过对传入对象的修改进而导致改变内部变量的值。例如：123456public final class ImmutableDemo &#123; private final int[] myArray; public ImmutableDemo(int[] array) &#123; this.myArray = array; // wrong &#125; &#125;这种方式不能保证不可变性，myArray和array指向同一块内存地址，用户可以在ImmutableDemo之外通过修改array对象的值来改变myArray内部的值。为了保证内部的值不被修改，可以采用深度copy来创建一个新内存保存传入的值。正确做法：123456public final class MyImmutableDemo &#123; private final int[] myArray; public MyImmutableDemo(int[] array) &#123; this.myArray = array.clone(); &#125; &#125;在getter方法中，不要直接返回对象本身，而是克隆对象，并返回对象的拷贝，这种做法也是防止对象外泄，防止通过getter获得内部可变成员对象后对成员变量直接操作，导致成员变量发生改变。LOAD_FACTORY为什么是0.75在源码中只说了0.75是空间和时间的一个折中，越低则空间利用率越低，比如我们把值设置为0.5，起始的时候有16个桶，使用到8个桶的时候就扩充为32个桶，当使用到16个桶的时候扩充到64个桶…JDK7 中put会发生死循环的问题1234567891011121314151617181920void transfer(Entry[] newTable) &#123; Entry[] src = table; int newCapacity = newTable.length; for (int j = 0; j &lt; src.length; j++) &#123; Entry&lt;K,V&gt; e = src[j]; if (e != null) &#123; src[j] = null; do &#123; Entry&lt;K,V&gt; next = e.next; int i = indexFor(e.hash, newCapacity); // 计算新的索引位置 e.next = newTable[i]; newTable[i] = e; e = next; &#125; while (e != null); &#125; &#125;&#125;// 这段代码会将一个旧的哈希表映射到新的哈希表上，每个节点的key都会进行重新的Hash// 但是在遍历的时候会从一个桶向后做next。即新插入的在resize的时候后插入到新桶中// 这种转了个圈的方法在并发的时候会产生死循环]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04.01-网络-绪论&物理层]]></title>
    <url>%2Fposts%2F52199.html%2F</url>
    <content type="text"><![CDATA[计算机网络计算机网络就是互联的、自治的计算机集合。自治指的是所有的计算机直接没有主从关系；互联指的是互联互通，能进行数据交换。计算机网络的本质是一种通信网络，只不过信源和信宿都是主机。它是计算机技术和通信技术的结合。信道信道是数据交换的载体。狭义上说人和人之间交流所承载信息的空气就是信道。广义上说它还可以包括有关的变换装置，这样的话信道往往被分成信道编码器、信道本身和信道译码器。简易通信系统模型如下：计算机网络基本原理分组交换技术，也就是拆分分组、传输分组、合并分组的技术。这个技术的优点就是便宜，因为把数据打包成分组和分组拆分都在计算机中进行，网络上只进行分组的转发，就使得网络的结构很简单，路由器设计也很简单。这一中原则被叫做“端到端的原则”，即能在端系统做的事情不在网络上实现。主机（host）诸如手机、电脑、服务器等端系统（end systems）。交换机如果想实现多个计算机之间的互联，按照之前的想法是每两台计算机进行连接，但这样太麻烦，一个好的做法是把这个计算机连接在某一中心上，这个中心把所有连接上来的计算机进行互联，在链路层这个中心叫做交换机。分组分组是带有地址信息的信息小片，可以理解成是计算机把一个文件切片后打成的包裹，由两部分构成：地址信息和真正传输的东西。路由器是计算机网络的一种专用计算机，它只有一个功能，就是转发分组。可以简单的理解为路由器是电子化的邮局，全国所有的邮局之间互联，是包裹能够传递，路由器之间互联，是分组能够正确转发。路由器和交换机的区别是：交换机将计算机连在一起，构成局域网；路由器将局域网连在一起，形成互联网。分组交换技术一个主机至少连接一个路由器：数据最终是通过路由器进行转发的，所以一个主机至少得连接一个路由器。分组存储转发：分组完全进入路由器后，路由器按照地址信息检索转发表。注意不是第一个bit或Byte进入时就开始转发，是全部进入才转发。分组独立选择路径：一个文件被分成多个分组，但这些分组之间是独立的，路由器给他们看成相互独立的数据。分组的组装是通过接收方进行的，和网络无关。InternetISPISP，全称为Internet Service Provider，因特网服务提供商，即指提供互联网服务的公司。能提供拨号上网服务、网上浏览、下载文件、收发电子邮件等服务。不同角度看Internet组成细节角度：ISP网络互联形成的网络之网络。由运行各种网路应用的计算设备，光纤、铜缆、无线电等通信链路、路由器和交换机等组成的分组交换设备组成。服务角度：是为网络应用提供通信服务的通信基础设施和为网络应用提供的应用编程接口。Internet结构一级ISP包含：网通、电信等商业ISP，还包含谷歌、微软等内容提供商网络。IXP：全称：Internet eXchange Point，即互联网交换中心。互联网Internet是由众多的网络互相连接而形成的全球性网络，互联网交换中心负责这些不同的网络之间互相通信的交换点，是互联网的关键基础设施。网络的结构网络边缘：位于“网络边缘”运行网络应用程序的端系统。接入网络、物理介质：有线或无线的通信链路。网络核心：互联的路由器（或分组转发设备）。构成“网络之网络”的关键。接入网络接入网络是一种用户网络，它连接用户到特定的服务提供商并通过承载网络到达其他网络。两个被用户关心的特征：带宽（数据传输速率，bps）、独占/共享（独占是带宽为某用户独用，共享是多个用户分用同一带宽）。家庭接入机构（企业）接入无线局域网广域局域网网络核心网络核心的功能是：路由（routing）：确定分组从源到目的传输路径；转发（forwarding）：将分组从路由器的输入端口交换至正确的输出端口。数据交换方式电路交换包含三个阶段：建立连接、通信、释放连接。最显著的特点是独占电路资源。最典型的是电话网络。（下图的中继线上可以存在多组用户通信，详见复用技术）报文交换报文交换是指把信息整个打包，然后经过存储转发送到目的地。分组交换分组交换是把信息拆分成不同的分组，然后把所有的分组相继发送给路由器，路由器通过路由&amp;转发把数据传输到目的地。和报文交换的区别是：报文交换不拆分信息。和电路交换的区别是：如果把每个分组看成原子单位，区别就是各分组走不同的路径，不需要独占资源。分组交换的优势和报文交换相比：速度快，因为在报文交换时，同一时间只有一个路由器在工作，其他路由器在等待。路由器的存储空间小，最低存储空间和分组大小差不多。和电路交换相比：分组交换允许更多用户同时使用网络，让网络资源充分共享。分组交换的劣势可能产生拥塞（congestion）：分组延迟和丢失。需要协议处理可靠数据传输和拥塞控制。图解三种交换网络性能参数速率 &amp; 带宽速率：又称数据率，数据传输速率或比特率。单位bps、kbps、Mbps、Gbps。带宽：数字信道所能传输的最大数据率。单位bps等。丢包如果路由器的缓存满了，再到达的分组会被路由器丢弃，即造成丢包现象。丢包率 = 丢包数 / 已发分组数。分组延迟结点处理延迟：差错检测、确定输出链路；排队延迟：等待输出链路可用、取决于路由器拥塞程度；传输延迟：分组长度/链路带宽；传播延迟：物理链路长度/信号传输速度。流量强度设链路带宽为R(bps)，分组长度为L(bits)，平均每组到达速率为v。则：$L \ast v / R \longrightarrow 0 $时：平均排队延迟很小；$L \ast v / R \longrightarrow 1$时：平均排队延迟很大；$L \ast v / R &gt; 1$时：超出服务能力，延迟 趋向于 无限大。时延带宽积$时延带宽积 = 传播时延 \ast 带宽$，单位：bit。实际意义是：从我们向某一信道上发送第一个bit，到这个bit被接收方接受这个时间里，发送方总共向信道上发送了多少bit。也可以称为以比特为单位的链路长度，比如某段链路长度为n比特。吞吐率/量（Throughput）发送端与接收端之间的传送数据率（b/s）。端到端的吞吐量取决于瓶颈链路。网络协议network protocol。为进行网络中的数据交换而建立的规则、标准或约定。其中规定了通信实体之间所交换的消息的格式、意义、顺序以及针对收到的消息或发生的事件而产生的动作。也可以说网络协议规定了网络中所有信息的发送和接受过程。协议三要素语义：语义是解释控制信息每个部分的意义。它规定了需要发出何种控制信息，以及完成的动作与做出什么样的响应。语法：语法是用户数据与控制信息的结构与格式，以及数据出现的顺序。时序：时序是对事件发生顺序的详细说明。（也可称为“同步”）。总结：语义表示要做什么，语法表示要怎么做，时序表示做的顺序。网络体系结构指通信系统的整体设计，它为网络硬件、软件、协议、存取控制和拓扑提供标准。计算机网络是一个非常复杂的系统，需要解决的问题很多并且性质各不相同。所以，在设计时使用了“分层”的思想，即将庞大而复杂的问题分为若干较小的易于处理的局部问题。各层之间是按照功能进行分层的，同时每层遵循相应的网络协议完成本层功能。各层的主要功能应用层：为用户提供具体的网络应用服务。运输层：通过中间网络，两个主机中进程之间的通信服务。包含有可靠通信的协议TCP和无可靠性的协议UDP。网络层：两台主机间的通信。分组交换网上的两台主机间的通信，选择合适的路由，构建互联网络，这些是同一件事的不同说法。数据链路层：两个相邻结点之间，数据的可靠传输。物理层：透明地传送比特流。各层传输数据的叫法协议数据单元PDU（Protocol Data Unit）：对等层之间传送数据的单位。服务数据单元SDU（Service Data Unit）：层与层之间交换数据的单位。即：PDU=首部+SDU=下一层的SDU。码元假如基带信号是101011000110111010...，如果直接发送，则每个码元携带一个比特的信息（每个码元只有2种状态），但是如果将信号中的三个比特编为一组，即101，011，000，110，111，010…，三个比特共有8种不同的排列，我们可以用不同的调制方法来表示这种信，如8种不同的振幅，频率，相位等，如果采用相位调制，相位$\phi_0$表示000，$\phi_1$表示001，以此类推，那么接收端如果收到相位是$\phi_0$的信号就知道表示的是000，以此类推，这样一个码元就不知不觉的传输了三个比特位的信号，此时每个码元有8种状态。一个码元可表示的比特数越多，则在接收端进行解调时要正确识别每一种状态就越困难。编码级别如果把n个比特编码成一个码元，则此时编码状态$M=2^n$，其表示当前传输时有多少不同的状态，如8级编码，会有：000、001、010 …，共计8种状态。信道的极限容量数据通信中很自然很重要的一个问题：在一个通道中，能够以多快的速率发送数据，即每秒钟能发送多少比特？比特是由电磁信号携带的，所以这个问题要再拆分一下：问题1：在一个通道中，能够以多快的速率发送信号？问题2：一个信号能携带多少个比特？奈斯准则码间串扰码元的传输速率是有限制的，超过某上限就会出现码间串扰问题。这是由于在真正传输中，信号在传输时都不是理想化的，如下图就是理想化的高低电平和真实传输时的高低电平。假如此时速度太快，就可能把低电平和高电平弄混。而最高的码元传输速率被奈斯准则限制。奈斯准则内容理想低通信道（能通过信号频率在某值之下）的最高码元传输速率为：$2W Baud$。理想带通信道（能通过信号频率在某范围之内）的最高码元传输速率为：$1W Baud$。W是理想低通信道的带宽，单位为赫(Hz)。Baud 是波特，是码元传输速率的单位，1 波特为每秒传送 1 个码元。波特率：单位时间内数据通信系统所传输的码元个数（信号个数），单位是波特（Baud）。比特率：表示单位时间内数据通信系统传输的比特数，单位是比特/秒（b/s或bps）。$比特率 = 波特率 * log_2M$香农公式编码级数限制虽然码元传输速率有限制，但是如果我们能尽可能提高编码级数不就能提升信息传输速率了吗？但事实上信号传输速率不受限于调制技术，而是受限于信噪比。举个例子，如果我们是在天气晴朗的一天出门，我们穿任意颜色衣服都能被分辨出来，但是如果我们在沙尘暴天气出门，穿橘黄和橙黄两种颜色的衣服别人自然就认不出来了。在这个比喻中衣服的颜色代表码元，确定衣服的颜色代表信息，沙尘暴就是噪声。香农公式内容带宽受限且有高斯白噪声干扰的信道的极限信息传输速率$C=W \ast log_2(1+PS/PN)（b/s）$。其中$W$是信道的带宽。$PS$是信号的能量。$PN$是噪声的能量。信噪比：$S/N=10lg{PS/PN}$。举例：带宽是1MHz，信噪比是24dB，则信道的最高信息传输速率：$C=1M \ast log_2{(1+(10^{2.4}))}=7.98Mbps$。奈氏准则vs香农公式多路复用电路交换中独占电路资源，并不是指用户线和中继线都被此次交换所独占，而是说在两个用户建立连接之后，除非连接中断，否则他们当前所拥有的资源不会被释放，即使他们之间不传输信息。而如何在中继线上实现多组用户通信就是多路复用技术。产生多路复用的物理基础是：传输媒体的带宽或容量往往会大于传输单一信号的需求，使用多路复用，为了有效地利用通信线路，希望一个信道同时传输多路信号。这种技术会将链路/网络资源（如带宽）划分为“资源片”，将资源片分配给各路“呼叫”（calls），每路呼叫独占分配到的资源片进行通信，资源片可能“闲置”常见的复用技术有：频分多路复用、时分多路复用、波分多路复用、码分多路复用。频分多路复用FMD：Frequency-division multiplexing，是指载波带宽被划分为多种不同频带的子信道，每个子信道可以并行传送一路信号的一种多路复用技术。也就是说信道的可用频带被分成若干个互不交叠的频段，每路信号用其中一个频段传输，因而可以用滤波器将它们分别滤出来，然后分别解调接收。时分多路复用TDM：time division multiplexing，它使不同的信号在不同的时间内传送，将整个传输时间分为许多时间间隔（Time Slot，TS，又称为时隙），每个时间片被一路信号占用。TDM就是通过在时间上交叉发送每一路信号的一部分来实现一条电路传送多路信号的。电路上的每一短暂时刻只有一路信号存在。因数字信号是有限个离散值，所以TDM多应用于数字通信系统。波分多路复用将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器（亦称合波器，Multiplexer）汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术；在接收端，经解复用器（亦称分波器或称去复用器，Demultiplexer）将各种波长的光载波分离，然后由光接收机作进一步处理以恢复原信号。码分多路复用为每个用户分配一个唯一的mbit的码片序列（chipping sequence），二进制下的0用-1表示，二进制下的1用+1表示。在信道上传输的信号 = 原始数据 码片序列，比如码片序列是：(-1, 1, 1)，需要传一个0，应该是 -1 (-1, 1, 1)，所以传输的就是(1, -1, -1)。同时为了保证数据之间不相互影响，被共享的用户所占有的码片应该相互正交的。即：$\frac{1}{m}S_i \cdot S_j = 0 (i \neq j)$。而信道上真正传输的数据是各用户发送数据的叠加值。数字信号在模拟信道传输数字信号需要编码后才能传输。常见的三种编码：NRZ编码：进制数字0、1分别用两种电平来表示。常用-5V表示1，+5V表示0。曼切斯特编码：用电压的变化表示0和1：高→低 &lt;=&gt; 0，低→高 &lt;=&gt; 1。差分曼切斯特编码：在码元开始处有无跳变来表示0和1：有 &lt;=&gt; 0，无 &lt;=&gt; 1。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>课内学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04.03-网络-网络层]]></title>
    <url>%2Fposts%2F12139.html%2F</url>
    <content type="text"><![CDATA[网络层分为两分布，网络构建和网络通信自治系统Autonomous System，AS。每个AS由一组通常处在相同管理控制下的路由器组成。一个ISP中的路由器以及连接他们的线路可以构成一个AS，一个ISP也可以将他们的网络划分成多个AS。每个AS由一个唯一的ASN来标识。所以在构建网络的时候，我们需要对 AS 内的网络和 AS 之外的网络进行区分。这两个统称为路由协议。内部网关协议Interior Gateway Protocol （IGP），用于自治系统（AS）内部的路由交换也叫做域内路由选择（intradomain routing），如 RIP 和 OSPF 协议外部网关协议Exterior Gateway Protocol （EGP），用于不同自治系统（AS）之间的路由交换，也叫做域间路由选择（interdomain routing），目前使用最多的是 BGP-4。路由选择算法分类常用的分类是：每个路由器知道的是全局的信息还是分散的信息？全局的所有的路由器具有完整的拓扑和链路费用信息“链路状态(L-S)”算法应用于RIP协议分散的路由器只知道物理连接的邻居和到邻居的链路费用迭代的计算过程，与邻居交换信息“距离向量(D-V)”算法应用于OSPF协议RIP协议基于距离向量的分布式路由选择协议，规定：“距离”为到目的网络所经过的路由器数。从一路由器到直接连接的网络的距离定义为 1。RIP允许一个通路最多包含15个路由器，多于15个路由器时不可达。RIP不能在两个网络之间同时使用多条路由，它选择一个具有最少路由器的路由，具有相同路径长度的路规定先入为主。特点仅和相邻路由器交换信息。交换的信息是当前本路由器所知道的全部信息，即自己的路由表。按固定的时间间隔交换路由信息，例如，每隔 30 秒。距离向量算法收到相邻路由器（其地址为 X）的一个 RIP 报文：先修改此 RIP 报文中的所有项目：将“下一跳”字段中的地址都改为 X，并将所有的“距离”字段的值加 1。对修改后的 RIP 报文中的每一个项目，重复以下步骤：若项目中的目的网络不在路由表中，则将该项目加到路由表中。否则若下一跳字段给出的路由器地址是同样的，则将收到的项目替换原路由表中的项目否则若收到项目中的距离小于路由表中的距离，则进行更新否则，什么也不做。若 3 分钟还没有收到相邻路由器的更新路由表，则将此相邻路由器记为不可达的路由器，即将距离置为16（距离为16表示不可达）。返回。举例一开始，各路由表只有到相邻路由器的信息：路由器 B 收到相邻路由器 A 和 C 的路由表：修改 A 的路由表，将 RIP 报文中的所有项目下一跳的字段都改成 A ，距离增加 1。| 目的网络 | 距离 | 下一跳 || :——: | :–: | :—-: || 1 | 2 | A || 2 | 3 | A || 3 | 3 | A |修改 C 的路由表，将 RIP 报文中的所有项目下一跳的字段都改成 C ，距离增加 1。| 目的网络 | 距离 | 下一跳 || :——: | :–: | :—-: || 4 | 2 | C || 6 | 2 | C |将 B 原来不可达的项目加入到B的路由表中，加入后B的路由表：| 目的网络 | 距离 | 下一跳 || :——: | :–: | :—-: || 3 | 1 | - || 4 | 1 | - || 1 | 2 | A || 2 | 2 | A || 6 | 2 | C |修改 收到的目的网络原本在B路由器中且下一跳的字段和原B路由表项目中的字段一致 的项目，发现不用修改。修改 B 可达，A和C也可达的项目，发现收到项目中的距离小于路由表中的距离，则进行更新，否则不更新。则修改后B的路由表是：| 目的网络 | 距离 | 下一跳 || :——: | :–: | :—-: || 3 | 1 | - || 4 | 1 | - || 1 | 2 | A || 2 | 2 | A || 6 | 2 | C |RIP 协议的优缺点RIP 存在的一个问题是当网络出现故障时，要经过比较长的时间才能将此信息传送到所有的路由器。即好消息传播得快，而坏消息传播得慢。RIP 协议最大的优点就是实现简单，开销较小。RIP 限制了网络的规模，它能使用的最大距离为 15（16 表示不可达）。路由器之间交换的路由信息是路由器中的完整路由表，因而随着网络规模的扩大，开销也就增加。好消息传播得快，坏消息传播得慢在正常情况下，R1中项目表示到网1距离为1，R2中项目表示到网1距离为2。R2收到 R1 的项目后修改R2的项目为：1 2 R1，R2发现到网1的下一跳为R1，和原路由表一致，修改原路由表该项目为：1 2 R1。R1 说：“我到网 1 的距离是 16 （表示无法到达），是直接交付”。但 R2 在收到 R1 的更新报文之前，还发送原来的报文，因为这时 R2 并不知道 R1 出了故障。我们列出一个网1出现故障后的交换表：| | R1 | R2 || :—: | :—–: | :—–: || 正常 | 1 1 - | 1 2 R1 || 故障 | 1 16 - | 1 2 R1 || 第1次 | 1 3 R2 | 1 16 R1 || 第2次 | 1 16 R2 | 1 4 R1 || 第3次 | 1 5 R2 | 1 16 R1 || … | … | … |这样不断更新下去，直到 R1 和 R2 到网 1 的距离都增大到 16 时，R1 和 R2 才知道网1是不可达的。RIP协议的位置RIP 协议使用运输层的用户数据报 UDP进行传送（使用 UDP 的端口 520）。因此 RIP 协议的位置应当在应用层。但转发 IP 数据报的过程是在网络层完成的。这时有一个困惑，RIP是网络层协议，可是为什么用UDP封装？因为路由器虽然是网络层设备，但并不代表他只具备物理层、链路层、网络层功能，他还具备一些应用层的功能，当遇到RIP报文这类应用层的协议，他也能够解封。然后读取RIP报文中的下一跳路由。RIP2 协议的报文格式RIP2由RIP而来，属于RIP协议的补充协议，提升装载的信息量，增加安全性。OSPF协议开放最短路径优先协议OSPF （Open Shortest Path First）。RIP 协议的问题以跳数评估的路由并非最优路径最大跳数16导致网络尺度小收敛速度慢更新发送全部路由表浪费网络资源要点向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”（metric）。只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。链路状态数据库由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个链路状态数据库。这个数据库实际上就是全网的拓扑结构图，它在全网范围内是一致的（这称为链路状态数据库的同步）。OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。OSPF 的更新过程收敛得快是其重要优点。Dijkstra 算法123456初始化10261+无穷+无穷第1步02412+无穷第2步023124第3步023126路径：1 -&gt; 4 -&gt; 5 -&gt; 2 -&gt; 3 -&gt; 6OSPF 的区域(area)为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫作区域。每一个区域都有一个 32 bit 的区域标识符（用点分十进制表示）。区域也不能太大，在一个区域内的路由器最好不超过 200 个。 同时 OSPF 划分为两种不同的区域：划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。OSPF 使用层次结构的区域划分。在上层的区域叫作主干区域(backbone area)。主干区域的标识符规定为0.0.0.0。主干区域的作用是用来连通其他在下层的区域。 图中的R3、R4、R6、R7是主干路由器。OSPF 载体OSPF 不用 UDP 而是直接用 IP 数据报传送。OSPF 构成的数据报很短。这样做可减少路由信息的通信量。数据报很短的另一好处是可以不必将长的数据报分片传送。分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。OSPF 的五种分组类型类型1，问候（Hello）分组。类型2，数据库描述（Database Description）分组。类型3，链路状态请求（Link State Request）分组。类型4，链路状态更新（Link State Update）分组，用洪泛法对全网更新链路状态。类型5，链路状态确认（Link State Acknowledgment）分组。BGP协议BGP 是不同自治系统的路由器之间交换路由信息的协议。 BGP 较新版本是 2006 年 1 月发表的 BGP-4，可以将 BGP-4 简写为 BGP。每一个自治系统的管理员要选择至少一个路由器作为该自治系统的“BGP 发言人” 。一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 TCP 连接，然后在此连接上交换 BGP 报文以建立 BGP 会话（session），利用 BGP 会话交换路由信息。使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的邻站或对等站。BGP报文打开（Open）报文，用来与相邻的另一个BGP发言人建立关系。更新（Update）报文，用来发送某一路由的信息，以及列出要撤消的多条路由。保活（Keepalive）报文，用来确认打开报文和周期性地证实邻站关系。通知（Notificaton）报文，用来发送检测到的差错。ICMPIP协议只有一种报文格式：IP报文功能：传递上层数据缺乏：应付可能出现差错的能力网际控制报文协议 ICMP (Internet Control Message Protocol)IP的辅助协议为IP提供差错报告机制同时为其它层（TCP/UDP、应用）提供辅助功能ICMP 报文的种类有两种，即 ICMP 差错报告报文和 ICMP 询问报文。格式差错报告报文终点不可达源点抑制(Source quench)时间超过参数问题改变路由（重定向）(Redirect)询问报文回送请求和回答报文时间戳请求和回答报文PINGPing发送一个ICMP 报文；回声请求消息给目的地并报告是否收到所希望的ICMPecho （ICMP回声应答）。它是用来检查网络是否通畅或者网络连接速度的命令。此上是网络层-网络构建部分此下是网络层-网络通信部分网络通信分类不同主机间的数据通信可以分为三种：两个主机属于同一个网、两个主机属于相邻的两个网中、两个主机属于不相邻的两个网络中。其中第一类是链路层所解决的问题，而后两类都是网络需要解决的问题，图示如下。为了叙述方便，博主将第二类情况简称“两个网”，第三类情况简称“三个网”，但实际上“三个网”的理论可以推广到“n个网”中。传统的IP地址划分传统的IP地址划分规则中，地址由两个部分组成：网络号 + 主机号。具有相同网络号的IP地址属于同一个网络。同时网络被划分为5类：但是并不是所有的主机号都能被用来标识主机，主机号全为0的IP地址被称为网络地址，标识一个网络。主机号全为1的地址被称为广播地址，用于向某个网络的所有主机广播。例：主机 212.111.44.136 所在网络的广播地址为212.111.44.255。而对于任意一个主机若想向其所在的网络中广播都可以使用255.255.255.255。按照这个划分我们可以得到各类地址的特性：A类地址前1字节标识网络地址，后3字节标识主机地址每个网络最多可容纳（$2^{24} －2$）台主机从高位起，前1位为“0”，第1字节用十进制表示的取值范围为“0～127”具有A类地址特征的网络总数为126个B类地址前2字节标识网络地址，后2字节标识主机地址每个网络最多可容纳（$2^{16} －2$）台主机从高位起，前2位为“10”，第1字节用十进制表示的取值范围为“128～191”具有B类地址特征的网络总数为 $2^{14} －1$ 个C类地址前3字节标识网络地址，后1字节标识主机地址每个网络最多可容纳254台主机从高位起，前3位为“110”，第1字节用十进制表示的取值范围为“192～223”具有C类地址特征的网络总数为 $2^{21} －1$个D类地址多播通信地址（multicast address）从高位起，前4位为“1110”，第1字节用十进制表示的取值范围为“224－239”，用于标识multicast通信地址后28位用于区分不同的multicast组E类地址从高位起，前4位为“1111”，第1字节用十进制表示的取值范围为“240－255”，用于标识E类地址后28位留作它用划分子网早期的 IP 地址的设计确实不够合理。会存在如下问题：IP 地址空间的利用率有时很低。给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。两级的 IP 地址不够灵活。网络很快就被分配完了。所以从 1985 年起在 IP 地址中又增加了一个“子网号字段”，使两级的 IP 地址变成为三级的 IP 地址。但划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。其实现思路就是从主机号借用若干个比特作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个比特。CIDR划分子网后仍然没有解决IP V4的问题，1992年互联网的三大危机：B类地址耗尽路由表爆炸IP地址整体耗尽无分类域间路由选择，Classless Inter-Domain Routing，是为解决上述危机而开发的一种方案。在CIDR技术中，IP 地址由两部分组成，网络前缀 + 主机号。CIDR 还使用“斜线记法”(slash notation)，它又称为CIDR记法，即在IP地址后面加上一个斜线“/”，然后写上网络前缀所占的比特数（这个数值对应于三级编址中子网掩码中比特 1 的个数）。CIDR 将网络前缀都相同的连续的 IP 地址组成“CIDR地址块”。128.14.32.0/20 表示的地址块共有 212 个地址（因为斜线后面的 20 是网络前缀的比特数，所以主机号的比特数是 12）。这个地址块的起始地址是 128.14.32.0。在不需要指出地址块的起始地址时，也可将这样的地址块简称为“/20 地址块”。128.14.32.0/20 地址块的最小地址：128.14.32.0。128.14.32.0/20 地址块的最大地址：128.14.47.255全 0 和全 1 的主机号地址一般不使用。路由聚合一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为路由聚合，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由，减少了路由器之间的路由信息交换。路由聚合也称为构成超网。（super netting）。这个 ISP 共有 6 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每一个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，只需用路由聚合后的 1 个项目 206.0.64.0/18 就能找到该 ISP。 需要注意的是若是因特网中某路由器想标识该ISP，只需要记录206.0.64.0/18，但是对于ISP内的路由器还是会将各子地址块的网络地址记录。最长前缀匹配使用 CIDR 时，路由表中的每个项目由“网络前缀”和“下一跳地址”组成。在查找路由表时可能会得到不止一个匹配结果。应当从匹配结果中选择具有最长网络前缀的路由：最长前缀匹配（longest-prefix matching）。网络前缀越长，其地址块就越小，因而路由就越具体。最长前缀匹配又称为最长匹配或最佳匹配。网关如果把计算机网络与快递网络做类比，假设东北大学是一个网络，西南大学是一个网络，东北大学想向西南大学寄点东西那么它需要通过自己学校的驿站寄到西南大学的驿站。网络之间进行通信的时候也需要有一个这种“驿站”。这便是网关。默认网关就是为主机转发分组的路由器网络接口，就是主机的第一跳路由器，网关就是你邮信时需要找到的校园邮筒的地址，即默认网关是在网关中选一个。主机 H1 的默认网关是路由器的 E0 接口。“两个网”时，需要正确配置网关。网关是主机的第一跳路由器。举例：假设主机 H2 的 E0 接口 IP 地址 100.16.0.1，掩码 255.255.0.0，E1 接口 IP 地址 100.17.0.1，掩码 255.255.0.0：主机 H1 本地连接 IP 地址 100.16.0.2，掩码 255.255.0.0，默认网关 100.16.0.1。主机 H3 的默认网关是什么呢？100.16.0.1。主机 H5 的默认网关又是什么？是100.17.0.1。在“多个网”时，多个网络如何互联？我们看下面的网络拓扑图，这是 3 个路由器连接了 4 个网络。假设网 1 内部有一个主机 H1，网 1 内部只有一个路由器 R1，因此默认网关只能设为 R1 的 15.0.0.4，再配置好 IP 地址，就可以与外网通信了。假设网 2 内部有一个主机 H3，在网 2 内有两个路由器 R1 和 R2，可以任选一个做默认网关，假设选 R2，默认网关设为 20.0.0.9，再配置好 IP 地址，就可以与外网通信了。再讨论如何配置路由器。路由器不傻，只要配置好路由器接口的 IP 地址，路由器会从接口的 IP 地址计算出网络地址，也就是说路由器能看清自己身边的网络。至于路由器是怎么看到的，在网络层-网络构建中会解释。数据转发之前说了这么多都是在做铺垫，本篇博文主要想介绍的一点是路由器是如何转发不同网络中的数据包。算法如下：从收到的分组的首部提取目的 IP 地址 D。先用各网络的子网掩码和 D 逐位相“与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行3。若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行4。对路由表中的每一行的子网掩码和 D 逐位相“与”，若其结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行5。若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行6。报告转发分组出错。R1的路由表：| 目的网络地址 | 子网掩码 | 下一跳 || :———–: | :————-: | :—-: || 128.30.33.0 | 255.255.255.128 | 接口0 || 128.30.33.128 | 255.255.255.128 | 接口1 || 128.30.36.0 | 255.255.255.0 | R2 |R2的路由表：| 目的网络地址 | 子网掩码 | 下一跳 || :———–: | :————-: | :—-: || 128.30.33.0 | 255.255.255.128 | R1 || 128.30.33.128 | 255.255.255.128 | 接口0 || 128.30.36.0 | 255.255.255.0 | 接口1 |在上图中，若H1（128.30.33.13）想给H3（128.30.36.12）发送数据，我们来分析一下具体的过程：主机 H1 首先将本子网的子网掩码 255.255.255.128与分组的 IP 地址 128.30.36.12 逐位相“与”（AND 操作）。即255.255.255.128 AND 128.30.36.12 得到 128.30.36.0，发现不等于128.30.33.0，所以他要将数据报发送到它的默认网关（128.30.33.1）上。R1收到这个地址后，会遍历所有的子网掩码，进行按位与后再和对应的网络地址做比对。可以得到转发给R2计算过程如下：255.255.255.128 AND 128.30.36.12 = 128.30.36.0 不等于 128.30.33.0255.255.255.128 AND 128.30.36.12 = 128.30.36.0 不等于 128.30.33.128、255.255.255.0 AND 128.30.36.12 等于 128.30.36.0R1收到这个地址后，会遍历所有的子网掩码，进行按位与后再和对应的网络地址做比对。可以得到转发给接口1。然后便是链路层需要解决的问题。ARP深入只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址。可以分为四种情况：发送方是主机，要把IP数据报发送到本网络上的另一个主机。这时用 ARP 找到目的主机的硬件地址。发送方是主机，要把 IP 数据报发送到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。发送方是路由器，要把 IP 数据报转发到本网络上的一个主机。这时用 ARP 找到目的主机的硬件地址。发送方是路由器，要把 IP 数据报转发到另一个网络上的一个主机。这时用 ARP 找到本网络上的一个路由器的硬件地址。剩下的工作由这个路由器来完成。IP数据报的格式版本：占 4 位，指 IP 协议的版本目前的 IP 协议版本号为 4 （即 IPv4）。首部长度：占 4 位，可表示的最大数值是 15 个单位（一个单位为 4 字节）因此 IP 的首部长度的最大值是 60 字节。区分服务：占 8 位，用来获得更好的服务在旧标准中叫做服务类型，但实际上一直未被使用过。1998 年这个字段改名为区分服务。只有在使用区分服务（DiffServ）时，这个字段才起作用。在一般的情况下都不使用这个字段。总长度——占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。标识（identification）：占 16 位，它是一个计数器，用来产生数据报的标识。标志（flag）：占 3 位，目前只有前两位有意义。标志字段的最低位是 MF（More Fragment）。MF = 1 表示后面“还有分片”。MF = 0 表示最后一个分片。标志字段中间的一位是 DF（Don’t Fragment）。只有当 DF=0 时才允许分片。片偏移(13 位)指出：较长的分组在分片后某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。生存时间（8 位）记为 TTL（Time To Live）：数据报在网络中可通过的路由器数的最大值。协议（8 位）：指出此数据报携带的数据使用何种协议，即运输层协议。首部检验和（16 位）字段只检验数据报的首部不检验数据部分。源地址和目的地址都各占 4 字节。NAT在现在的网络中，IP地址分为公网IP地址和私有IP地址。公网IP是在Internet使用的IP地址，而私有IP地址则是在局域网中使用的IP地址。私有IP地址是一段保留的IP地址。只使用在局域网中，无法在Internet上使用。A类私有地址：10.0.0.0～10.255.255.255B类私有地址：172.16.0.0～172.31.255.255C类私有地址：192.168.0.0～192.168.255.255这些地址可以在任何组织或企业内部使用，和其他Internet地址的区别就是，仅能在内部使用，不能作为全球路由地址。这就是说，出了组织的管理范围这些地址就不再有意义，无论是作为源地址，还是目的地址。对于一个封闭的组织，如果其网络不连接到Internet，就可以使用这些地址而不用向 IANA（The Internet Assigned Numbers Authority，互联网数字分配机构，是负责协调一些使Internet正常运作的机构） 提出申请，而在内部的路由管理和报文传递方式与其他网络没有差异。对于有Internet访问需求而内部又使用私有地址的网络，就要在组织的出口位置部署NAT网关，在报文离开私网进入Internet时，将源IP替换为公网地址，通常是出口设备的接口地址。一个对外的访问请求在到达目标以后，表现为由本组织出口设备发起，因此被请求的服务端可将响应由Internet发回出口网关。出口网关再将目的地址替换为私网的源主机地址，发回内部。这样一次由私网主机向公网服务端的请求和响应就在通信两端均无感知的情况下完成了。依据这种模型，数量庞大的内网主机就不再需要公有IP地址了。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>课内学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04.04-网络-运输层]]></title>
    <url>%2Fposts%2F22725.html%2F</url>
    <content type="text"><![CDATA[传输服务网络层完成了“主机到主机”的通信，但主机间的通信并不是最后的结果，产生和消耗数据的并不是主机，而是某项网络应用，真正通信的是两个应用“进程”。“进程”就是“正在进行的程序”。而“进程到进程的通信”正是传输层的功能。但这不是全部，更重要的，传输层的任务是为从源主机到目的主机提供可靠的，低价格的数据传输。可靠性，低价格是两个关键词，或者为了更明显一些，可以有第三个关键词，拥塞控制。其实可靠性与拥塞控制本质上是一个词。可靠性、低价格、拥塞控制使传输层成为整个协议体系的核心与灵魂。如果没有传输层，就没有可靠的数据传输，网络层也将失去意义。传输层的服务与网络层服务很相似，为何要分为两个层呢？答案就是“可靠性”。网络层并不提供可靠性，路由器可以丢失分组，用户无法控制中间的网络设备，用户不能选择性能更好的路由器或质量更好的数据链路，那么如何保证数据可以正常传输呢？添加一个传输层，传输层应该检测到各种问题，并采取补救措施，从而提供可靠的数据传输。传输层就是要弥补网络层技术、设计的各种缺陷。用个不恰当的比方，传输层就是“填坑的”，将网络层与应用层之间的坑、沟填平。传输层服务前，是遍布坑、沟的公路，传输层服务后，是平坦的公路。再谈谈“低价格”这个关键词。如果在设计网络时，由网络层提供可靠性，会如何呢？如果由网络层提供可靠性，就要在中间网络的千万个路由器上添加可靠性的功能，系统的复杂性会提高数据传输的成本，那就与电话通信网的成本差别不大。可靠性由通信网提供还是由端计算机提供，二者的价格差别可太大了。可靠性由端计算机提供，才有了低成本的数据传输，低价格才是计算机网络将其他通信技术淘汰的本质。要低价格，可靠性就要放置在端计算机内部。显然放置在操作系统内部更加合理，直接由操作系统对应用程序提供可靠的数据传输服务，是非常自然的选择。传输层封装在端计算机的操作系统内，用个不恰当的比方，如同封装在房间内的电线，在装修时已经埋好了，只是提供了许多插座，这个插座接洗衣机，那个插座接冰箱，那个插座接电视，等等。对计算机网络来说，“可靠性”的关键是什么？或者反过来，造成数据传输不可靠的最主要的原因是什么？是网络拥塞，当网络拥塞时，路由器就会丢弃数据包。传输层需要具有“调控网络”的功能。我们说，传输层在端主机内，而端主机是无法控制中间的网络设备的，“调控网络”从何谈起呢？后面会说到网络拥塞如同现实生活的堵车，根本的解决办法是不让车上路，所有的车都不上路，路就不堵了。“调控网络”是说所有端计算机内的传输层要能感知到网络的状态，能感知到当前通信网的态势，网络拥塞，就少发数据，网络通畅，就多发数据。尤其是网络拥塞时，要少发数据，让中间网络尽快恢复传输能力。端口最常用的进程到进程的通信方式是客户机与服务器模式。我们这里说的客户机与服务器都是指一个应用进程，而不是机器。客户机，请求服务，主动发起呼叫的进程。服务器，提供服务，被动等待的进程。总是客户机呼叫服务器，绝不可能是服务器呼叫客户机。在生活中，总是你给消防队打电话，绝不可能是消防队给你打电话。某一项服务，就是一项网络应用。端主机完全可以同时有多项网络应用，如同时打开浏览器浏览网页，打开 QQ 聊天。标识不同的网络应用进程的标识符称为协议端口号 (protocol port number)，简称为端口 (port)。端口是一个 16 位的标识符。客户机用一个临时端口号定义自己。客户机可以随机选择一个端口号使用。服务器也需要用一个端口号来定义自己，但是服务器不能随机选用一个端口号。为什么呢？假设消防队随机使用一个电话号码，当发生火灾时，人们向哪打电话呢？服务器必须使用一个预先定义的，众所周知的端口号，就如同消防队使用119，急救中心使用 120 一样。端口范围划分熟知端口，端口号范围是 0~1023。由 ICANN 分配和控制。注册端口，端口号范围是 1024~49151，ICANN 不分配也不控制，但必须在 ICANN 登记以防止重复。通常为没有熟知端口号的应用程序使用的。动态端口，端口号范围是 49152~65535，这范围的端口号即不用指派，也不需注册，可以由任何进程使用。最初的建议是客户机使用的临时端口号应该在这个范围，但许多程序员可没有遵守这个建议。注意：端口号只具有本地意义，只是为了标志本计算机应用层中的各进程。复用与分用某台主机中可能有多个应用进程同时分别和网络上的许多其他主机中的某个或多个应用进程通信。这表明运输层有一个很重要的功能：复用（multiplexing）和分用（demultiplexing）。当一个实体接受来自多个源的输入时，就称为复用（multiplexing） （多到一）。而当一个实体将数据交到多个源时，就称为分用（demultiplexing）（一到多）。UDP用户数据报协议 UDP（User Datagram Protocol）是无连接不可靠的传输层协议。它只在 IP 的数据报服务之上增加了很少一点的功能，即端口的功能和校验和的功能。校验和功能是可选的，如果不选择校验功能，就全填入 0。UDP 缺点是不可靠，优点是开销小。发送数据之前不需要建立连接。这对某些实时应用是很重要的。网络出现拥塞时，不调整，不降低发送速率。UDP 用户数据报首部如下图：源端口和目的端口号，各占 16 位，标志应用进程，总长度为 UDP 的总长度，UDP 首部加 UDP 数据的长度，校验和计算下面介绍。校验和UDP 的校验和功能是可选的，如果不选择校验和功能，就全填入 0，否则，计算校验和。计算时包含三个部分，伪首部，首部，数据部分，注意计算校验和是包含了数据部分的。如下图：计算 UDP 检验和的例子二进制反码计算规则：0 + 0 = 10；0 + 1 = 1； 1 + 1 = 0TCPTCP格式一个 TCP 报文段分为首部和数据两部分，首部的前 20 个字节是固定的，后面有 4n 字节是根据需要而增加的选项 (n 是整数)。因此 TCP 首部的最小长度是 20 字节。而 TCP 的全部功能都体现在它首部中各字段的作用：源端口和目的端口字段：各占 2 字节。端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现。序号字段：占 4 字节。TCP 连接中传送的数据流中的每一个字节都编上一个序号。序号字段的值则指的是本报文段所发送的数据的第一个字节的序号。确认号字段：占 4 字节，是期望收到对方的下一个报文段的数据的第一个字节的序号。窗口字段：占 2 字节，用来让对方设置发送窗口的依据，单位为字节。数据偏移（即首部长度）：占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。“数据偏移”的单位是 32 位字（以 4 字节为计算单位）。保留：占 6 位，保留为今后使用。控制：占 6 位，定义了 6 种不同的控制位或标志。在同一时间可设置位或多位标志位。分别是 URG、ACK、PSH、RST、SYN、FIN。检验和：占 2 字节。检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。紧急指针字段：占 16 位，指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）。选项字段：长度可变。TCP 最初只规定了一种选项，即最大报文段长度 MSS。MSS 告诉对方 TCP：“我的缓存所能接收的报文段的数据字段的最大长度是 MSS 个字节。”差错控制TCP 是可靠的传输层协议。就是说 TCP 向应用层交付的是按顺序的，没有差错的，没有丢失的数据。TCP 通过 2 种机制进行差错控制：检验和、确认和超时。检验和TCP 规定每个报文段都必须使用 16 位的检验和。TCP 检验计算时包含三个部分，伪首部，首部，数据部分，注意计算校验和是包含了数据部分的。计算方 法同 UDP 一样。确认和超时TCP 采用确认的方式来证实收到报文。接收方可以在合适的时候单独发送确 认报文，也可以在自己有数据要发送时把确认信息捎带上。TCP 使用肯定的累积确认。先解释“肯定”，ACK 就是“肯定”的意思。就是只在正确的情况下才发送确认。当发生丢弃，丢失，重复这些错误时，就什么也不做。“报喜不报忧”，注意，当发生错误时，不发送确认。这样，对方收不到确认，重传定时器就会超时，触发重传。 再解释“累积”，就是表示的累积效果，确认号字段值表示的是希望接收的下一个字节的序号。例如确认号为 301，是表示 301 号字节之前的数据都正确接收了，希望接收的下一个字节是 301 号字节。重传定时器差错控制的核心就是重传机制。TCP 使用确认-超时重传机制。具体说，TCP 每发送一个报文段，就设置一个重传定时器，当重传时间到，但还没有收到确认，就要重传这一报文段。重传定时器的值怎么设是 TCP 最复杂的事情之一。后面我们会解释原因，现在我们只要知道，重传定时器的值的估算要尽可能的准确，定时器的值不像加班费，越大越好，也不是越小越好，是越准确越好。首先，很自然的想法，重传定时器的值应该是“一个往返时延再多一点”。“一个往返时延”如何确定？举例，8 点测了一次往返时延，8:05 又测一次，间隔 5 分钟，测了 10 次，往返时延应该用哪次测量的值呢？显然，用哪一次的也不合适，应该是某种“平均值”。下面介绍的这个算法的目标是使估计值更加“平滑”，我们将往返时延估计值记作 RTTs。这个算法中，历史的累积效应权重更大一些，占比 7/8，新测量值的权重小，占比1/8。下图是 RTT 样本与 RTT 估计值示意图，蓝色的是各次的测量值，红色的是RTT 的估计值。说完“一个往返时延”，再说“多一点”。这一点Δ怎么算呢？取样本值到平滑线的距离为Δ，|RTTs-新样本|，显然，每个样本点到平滑线都有一个Δ，就是Δ1，Δ2，Δ3，Δ4，···，取哪个Δ合适呢？显然，用哪一个Δ也不合适，还应该是某种“平均值”。算法也是给出一种“平滑平均值”，记作 RTTD。这个算法中，历史的累积效应权重更大一些，占比 3/4，新测量值的权重小，占比 1/4。总的RTO计算公式：$RTO=RTTs + 4 \ast RTTD$流量控制TCP 是全双工通信，TCP 为每个方向的数据传输使用两个窗口，发送窗口和接收窗口。双向通信就有四个窗口，为简化讨论，只讨论单向数据传输。发送窗口下图是一发送窗口例子，TCP 中的窗口以字节为单位。TCP 的传输实际是一个一个的报文段，但控制窗口的变量是以字节为单位。TCP 中只使用一个重传计时器。为方便说明，字节编号取得很小。发送窗口的后沿（left wall）只能向前移动（关闭 closes），前沿可向前移动（opens），也可收缩（shrinks），但 TCP 标准不赞成收缩。接收窗口下图是一接收窗口例子。实际上，接收窗口永远不会收缩。通常，接收方 TCP 等待应用进程来取数据。就是说，分配给接收方的缓存可能包含已接收且确认的数据字节，它们在正等待应用进程将它们拉走。接收窗口总是小于缓冲区的大小。接收窗口通常称为 rwnd，rwnd = 缓冲区大小 – 正在等待被拉走的字节数，如下图：rwnd = 40 。窗口如何滑动TCP 通过滑动窗口机制实现流量控制。我们先忽略差错、拥塞等其他因素，且只简化讨论一个方向的数据传输。下图描述了一个例子，总是客户端发送数据，服务器确认。客户端是发送方，发送窗口，使用序号字段，服务器是接收方，接收窗口，使用确认号和窗口两个字段，窗口字段值是 rwnd 的值。假设发送方的缓冲区与接收方的缓冲区大小都是 800 字节。第 1 个报文段，客户端发给服务器，SYN 报文段，seq=100。三次握手建立连接的第一个报文，请求连接，并通告初始序号是 seq=100。第 2 个报文段，服务器发给客户端，SYN+ACK 报文段，ack=101，rwnd=800。三次握手建立连接的第二个报文，窗口值通告 rwnd=800。第3个报文段，客户端发给服务器，ACK报文段。客户端通告rwnd=2000，表示客户端的接收缓冲区的大小，我们忽略这个值，只讨论单向传输。第 4 个报文段，客户端发给服务器，数据报文段，seq=101。客户端发送一数据报文段，携带 200 字节数据，数据字节编号 101~300，序号字段填写第 1个数据字节的编号 seq=101。发送窗口前沿在 901，后沿在 101，显示已发送 200字节数据，正等待确认。第 5 个报文段，服务器发给客户端，ACK 报文段，ack=301，rwnd=600。服务器收到 101~300 号字节，共 200 字节数据，接收窗口调整，后沿向前滑动 200 字节，表示已收好 200 字节。向客户端发送 ACK 确认，确认字段值 ack=301，表示 301 号之前数据收好，下一个希望接收的字节是 301 号字节。注意，此刻 200 字节数据仍在接收缓冲区内，服务器的应用进程还没将它们拉走，接收窗口的大小 rwnd= 800 – 200 = 600。报文段中通告的窗口值为 600。第 6 个报文段，客户端发给服务器，数据报文段，seq=301。客户端收到确认 ack=301，rwnd=600。客户端知道服务器已经收好 101~300 号字节，就可以删除这些数据，发送窗口调整，后沿向前滑动 200 字节，至01 处。但前沿不能向前滑动，因为现在接收方通告的 rwnd=600，前沿=301+600=901。客户端发送数据报文段，携带 300 字节数据，数据字节编号 301~600，序号字段eq=301。第 7 个报文段，服务器发给客户端，ACK 报文段，ack=601，rwnd=400。服务器收到第二次的 301~600 号字节数据，共 300 字节数据。接收窗口调整，后沿向前滑动 300 字节，至 601 处。因 TCP 使用累积确认，向客户端发送的确认为 ack=601，表示 601 号之前所有数据收好，下一个希望接收的字节是 601 号字节。注意，此刻 200+300=500 字节数据仍在接收缓冲区内。这时，服务器的应用进程拉走 100 字节数据，接收缓冲区的 101~200 号字节空间被释放，但 201~601的 400 字节数据滞留在接收缓冲区内。接收窗口的大小 wnd= 800 – 400 = 400。通告窗口值为 rwnd=400。客户端收到确认 ack=601，rwnd=400。客户端知道服务器已经收好 601 号之前的数据，就可以删除这些数据，发送窗口调整，后沿向前滑动至 601 处。因为现在接收方通告的 rwnd=400，前沿=601+400=1001。前沿向前滑动至 1001 处。第 8 个报文段，服务器发给客户端，ACK 报文段，ack=601，rwnd=600。服务器的应用进程又拉走 200 字节数据，接收缓冲区的 201~400 号字节空间被释放，但 401~601 的 200 字节数据仍滞留在接收缓冲区内。接收窗口的大小 rwnd= 800 – 200 = 600。通告窗口值为 400。对于确认来说，服务器现在收好的是 601 号字节之前的数据，确认为 ack=601，表示希望接收的下一个字节是 601 号字节。客户端收到确认 ack=601，wnd=600。客户端知道服务器已经收好 601 号之前的数据，发送窗口的后沿就在 601 处，不需滑动。因为现在接收方通告的rwnd=600，前沿=601+600=1201。前沿向前滑动至 1201 处。糊涂窗口综合症假如 TCP 发送的报文段只含有 1 个字节的数据，那么意味着为发送 1 字节的数据，而发送了 41 个字节的报文段，20 个字节的 TCP 首部和 20 个字节的 IP首部。此时的效率是 1/41。这一现象称为糊涂窗口综合症（Silly Window Syndrome）。糊涂窗口综合症是怎样产生的呢?由发送方产生的糊涂窗口综合症（Syndrome Created by the Sender）如果发送方 TCP 正在为一个产生数据很缓慢的应用程序服务，例如一次产生 1 字节数据，就有可能产生糊涂窗口综合症。解决方法是使用 Nagle 算法。Nagle 算法发送方 TCP 把它从应用进程收到的第一块数据发送出去，即使只有 1 字节。在发送一个报文段后，发送方 TCP 就在输出缓存中累积数据并等待，直至收到接收方发来的确认，或者已积累了足够的数据已达到报文段的最大长度时，就立即发送一个报文段。重复步骤 2。Nagle 算法之巧妙，在于其巧妙地平衡了应用程序产生数据速度和网络传输速度。如果应用程序比网络速度快，报文段就大（最大报文段长度），如果应用程序比网络速度慢，报文段就小。由接收方产生的糊涂窗口综合症（Syndrome Created by the Receiver）如果接收方 TCP 正在为一个消耗数据很缓慢的应用程序服务，例如一次消耗 1 字节数据，接收方每次发送 rwnd=1 的通告，就有可能产生糊涂窗口综合症。解决方法的是推迟确认。报文到达时，不立即发送确认，接收方等待一段时间，直到输入缓存有足够的空间（或者接收缓存已有一个最长报文段的空间，或者接收缓存已有一半空闲的空间），就发送确认报文。但推迟确认不能超过 500ms。拥塞控制拥塞控制是 TCP 协议中最重要的一部分。理解 TCP 的拥塞控制，关键在于真正理解网络拥塞这一现象，理解了拥塞，以后的内容都会顺理成章的很好理解。拥塞概述两个主机，通过中间的一个传输网，连接在一起。正是因为中间有网络，就有了网络拥塞问题。谈网络拥塞之前，先回忆一下路由器的原理。网络层的路由器是一种“尽力而为”的机制。当超过路由器的能力时，路由器就将会丢弃数据报。假设路由器每秒能转发 1000 个数据报，此刻来了 1200 个数据报，路由器就将后 200 个数据报丢弃。注意：当没有超过路由器的负载能力时，路由器是不会丢弃数据报的。换一句话说，就是某个路由节点拥塞了，才会丢弃数据报。怎么解决拥堵呢？很明显有两种方案，用公路网来打比方就是增加路的数量和减少驶入公路网的车。从协议的角度考虑，自然是做不到增加路的数量，所以我们就要控制发送到网络中的数据量。传输网络当网络拥塞时，如同城市交通堵塞，南城的人去不了北城，北城的人一样也去不了南城，路都堵死了，谁也走不了。也就是说，拥塞时，网络外围的所有主机，发送的数据包都会被丢掉，所以一定不会有返回的 ACK 确认，超时定时器一定会闹响。也就是说，网络拥塞时，所有主机都会超时。这样问题就解决了，简单归纳为一句话，超时就表示网络拥塞。超时就表示网络全拥塞。因为 TCP 协议中以超时做为网络拥塞的判断依据，重传定时器的值需要估算合适，这很重要。值估算小了，实际网络不拥塞，确产生了超时重传，误判为拥塞，就不能充分使用网络的传输能力。值估算大了，实际网络已经拥塞，确没有产生超时重传，误判为通畅，就会使拥塞更加恶化，最终通信崩溃。在日常的生活中，城市的交通堵塞一定是渐渐堵死的，绝无可能在前一分钟，全城都是通畅的，后一分钟，全城所有的道路都堵死。总是开始时某些路段堵死，然后慢慢扩大，最后全部堵死。如果在某些路段堵死的时候，就开始疏导，有可能不会演变为全堵死。同理在计算机网络中，也很难相信，在前一分钟，所有的路由器都负载很轻，后一分钟，所有的路由器都超负载。应该是，某些路由器超负载了，其他路由器正常，这时后续的数据包就会自动绕路。假设某主机，连续发送了 2，3，4，5号数据包，2 号数据包碰到超负荷的路由器，被路由器丢弃，3，4，5 号数据包绕路到达目的主机，目的主机发送了 3 个 ACK 确认，请求 2 号数据包。当发送方收到 3 个重复 ACK 时，就会判断，网络是部分拥塞的，前面的数据包堵死在路上，后面的数据包绕路走了，已经到达目的地。简单归纳为一句话，3 个重复ACK 就表示网络部分拥塞，我称为半拥塞。3 个重复 ACK 就表示网络半拥塞。至此，外围的主机有了推测中间传输网络状态的办法，这两个事件就标志着网络的两种状态。用两个事件标志两种网络状态的方法，需要认真领会。TCP 的拥塞控制不能算闭环，没有一个具体的设备发出一个网络拥塞的信号，因为拥塞是全网的状态，不是某一个路由器的状态。一个路由器超载，可以绕其他路由器。TCP 的拥塞控制也不能算开环，“超时”与“3ACK”这两个事件确实反馈了中间传输网络的状态，为决策提供了依据。了解了网络现在的状态，就好办了。全拥塞有全拥塞的处理办法，半拥塞有半拥塞的处理办法。拥塞窗口在上文中，讨论过 TCP 的流量控制，发送方窗口大小是由接收方的可用缓存空间（rwnd）决定的，就是由接收方指示发送方应当使用多大的窗口，这当然可以保证接收方不会溢出。但是，这个方法没考虑网络的存在，上文说过，要调控网络拥塞，就要根据当前网络的状态，调整发送到网络中的数据量。也就是说，TCP 需要一个控制变量，即TCP 发送方使用拥塞窗口 cwnd （Congestion Window）作为控制变量，根据当前网络的拥塞程度，拥塞窗口的大小动态地变化，调整发送的数据量。这样一来发送窗口大小不仅取决于接收方通告的接收窗口 rwnd，还取决于网络的拥塞状况 cwnd，进而 实际的发送窗口 = min（ rwnd , cwnd ）拥塞检测TCP 的发送方使用两个事件作为判断网络全拥塞和半拥塞的依据。超时表示网络全拥塞。3 次重复 ACK 表示网络半拥塞。超时上文已经解释过拥塞的现象，我们现在简单理解为：发送方的超时事件就表示中间网络全部堵死了。发送方 TCP 在整个连接期间，只维护一个 RTO 计时器。发送方发送段 1 和 段 2，计时器启动，接收方发回 ACK，发送方收到 ACK 后，计时器清零。在启动计时器，发送段 3，段 4，段 3 丢失，段 4 到达，接收方将段 4 存储下来，因为段 3 丢失，接收方留出一个间隙，表明数据是不连续的，接收方只能再发送对段 2 的确认 ACK。发送方收到确认，但因为不是对段 3，段 4 的确认，计时器不能清零，计时器超时，就会重传段 3，并重启计时器，这次段 3 正常到达，接收方发送 ACK，发送方收到，将计时器清零。三次重复 ACK（3dupACKs）三次重复 ACK，也称做“快重传”（Fast retransmission）。如下图：发送方发送 2 个段后，正常收到 ACK，这个 ACK 是原始的 ACK，超时计时器清零。发送方再发送 4 个段，并再次启动超时计时器，段 3 丢失，段 4，5，6 到达。当接收方收到失序的数据段时，立即发送 ACK。接收方会发出 3 个重复的 ACK。发送方收到三个重复的 ACK，就立即重传丢失的报文段，而不等待计时器超时，并重启计时器。这一规则称为“快重传”，目前的 TCP 都遵守这规则。三次重复 ACK，显然是某个报文段丢失了，后面的报文段正常到达。这就表示网络有堵死的地方，造成丢失，其他部分通畅，后面的报文段绕行了通畅的路径。我们现在简单理解为：发送方收到三次重复 ACK，就表示中间网络半堵死。拥塞控制策略TCP 拥塞策略基于两个阶段，慢启动（slow-start，SS）阶段和拥塞避免（congestion avoidance，CA）阶段。在慢启动阶段，发送方从非常慢的速率开始，很快达到一个门限值。当到达门限值，进入拥塞避免阶段。慢启动（SS, Slow start）指数增大，拥塞窗口 cwnd 从 1 个最大报文段 MSS 开始。每收到一个 ACK 确认，拥塞窗口增加一个 MSS。慢启动算法开始很慢，但它是以指数增大的。按 ACK 计算， cwnd = cwnd + 1。如图，从 cwnd=1 开始，第 1 个 ACK 到达后，cwnd 加 1，就是 2。这时，就可发送 2 个段，相应的回来 2 个 ACK，对于每个 ACK，cwnd 加 1，就是 4 了。是按指数增大的。慢启动不能无限制的指数增大，有一个门限值来终止慢启动。发送方有一个慢开始门限 ssthresh（slow-start threshold）的变量，当拥塞窗口大小达到阈值时，慢启动停止，开始拥塞避免阶段。拥塞避免（CA，Congestion avoidance）加法增大，在慢启动阶段，当拥塞窗口达到慢开始门限 ssthresh 的值时，慢启动停止，进入拥塞避免阶段。此时，拥塞窗口按加法增大。每次整个“窗口”的所有段都被确认后，拥塞窗口增加 1。举例，发送方以 cwnd=4 开始，此刻发送方只能发 4 个段，在 4 个 ACK 到达后，拥塞窗口才加 1。如果按往返时延 RTT 观察，拥塞窗口是每一轮次加 1。按 ACK 计算， cwnd = cwnd + ( 1 / cwnd )按 RTT 计算， cwnd = cwnd + 1拥塞控制策略的转换在拥塞避免阶段，拥塞窗口加法增大。拥塞避免阶段会一直持续下去吗？继续下去，会是什么情况？显然，拥塞避免阶段继续下去，网络只会有处于通畅，半拥塞，全拥塞三种状态中的一种。就如同城市交通一样，只会是不堵车，部分堵死，全部堵死这三种情况之一。通畅标志是无事件发生。拥塞避免阶段继续，拥塞窗口继续按加法增大。半拥塞标志事件是：发送方收到三次重复 ACK（3dupACKs）。处理办法是：ssthresh 门限值设为此刻 cwnd 的一半 ssthresh = cwnd / 2将拥塞窗口设为门限值。 cwnd = ssthresh进入拥塞避免阶段。全拥塞标志事件是：发送方超时。处理办法是：ssthresh 门限值设为此刻 cwnd 的一半 ssthresh = cwnd / 2将拥塞窗口重新设置设为 1。 cwnd = 1进入慢启动阶段拥塞举例连接管理TCP 是一种面向连接的协议。TCP 以全双工方式传送数据。在 TCP 中，面向连接的传输需要经过三个阶段：连接建立，数据传输，连接断开。TCP 连接采用客户服务器方式。主动发起连接建立的应用进程叫做客户（client），被动等待连接建立的应用进程叫做服务器（server）。TCP 连接管理的三规则规则 1：TCP 规定，SYN 报文段不能携带数据，但要消耗掉一个序号规则 2：TCP 的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号。规则 3：TCP 规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。连接建立TCP 建立连接的过程叫做三次握手（three-way handshaking）。服务器首先打开一个端口，端口处于监听态，称为被动打开。客户端发起连接请求，连接到服务器的打开的端口上，连接就建立了。客户端发送第 1 个报文段，SYN 标志置 1，SYN 是请求同步的意思，SYN 报文段是控制报文，只在每个方向的第 1 个报文里出现。客户随机选择一个数字作为初始序号，假设为 x。TCP协议规定：SYN 报文段不能携带数据，但要消耗掉一个序号。服务器发送第 2 个报文段，SYN，ACK 置 1。SYN 标志表示服务器方的请求同步，并且服务器设置自己的初始序号，假设为 y。ACK 置 1 表示包含确认，这个确认是对客户端 SYN 报文的确认，所以确认号=x+1，表示序号 x+1 之前的报文都收好了，希望收到序号为 x+1 的报文段。客户端发送第 3 个报文段，ACK 标志置 1。这个报文段仅仅是一个 ACK 段，通常不携带数据。这个段是客户端发出的，序号就是 x+1。ACK 置 1 表示包含确认，这是对服务器 SYN 报文的确认，确认号=y+1，表示服务器发送的序号 y+1 之前的报文都收好了，希望收到服务器发送的序号为 y+1 的报文段。要特别注意教材中的这句话，并需要真正理解。TCP 的标准规定，ACK 报文段可以携带数据。但如果不携带数据则不消耗序号。举例：客户端发送的第 1 个 SYN 报文段，序号为 8000，服务器发送的第 2 个 SYN+ACK 报文段，序号为 15000，此后，客户端发送了第 3 个报文段，未携带数据，第 4 个报文段，携带 100 字节数据，问客户端发送的第 3，4 个报文段的序号是什么？解析：第 3 个报文段，序号为 8001，因为序号 8000 已经被 SYN 报用掉了。 第 4 个报文段，序号仍然是 8001，注意不是 8002，因为第 3 个报文段是一个 ACK 报文段，并且没携带数据，所以不消耗序号，就是说第 3 个报文的序号 8001 没有被用掉，在第 4 个报文中继续使用。数据传输连接建立后，可进行双向的数据传输。客户端和服务器都可以发送数据和确认。TCP 连接使用了序号和确认号的机制。序号TCP 把要发送的数据都按字节编上号。两个方向的编号是相互独立的。编号并不是从 0 开始，而是使用一个随机数作为初始编号，初始编号在建立连接的第一个 SYN 报文段里通告给对方。每个 TCP 报文段都有序号字段，序号字段值是这个报文段中第一个数据字节的编号。TCP 报文的序号字段值是这个报文段中第一个数据字节的编号。确认号TCP 使用确认机制。当报文段中 ACK 标志置 1，报文的确认号字段有效，TCP 的确认是累计确认，确认号字段值是完全接收好的数据的最后一个字节的编号+1，表示此值前的数据已收好，期望接收的下一字节是此值。举例，确认号是5644，表示从开始到 5643 号字节的数据都已收好，希望接收 5644 号字节。TCP 是累积确认。确认号字段值是期望接收的下一个字节的编号。举例：客户端发送一报文段，序号 8001，确认号 15001，携带 1000 字节数据。服务器发送的下一个报文段，序号，确认号是多少？服务器的回复携带 2000 字节数据，则客户端发送的再下一个报文，序号，确认号是多少？解析：因第 1 个报文的确认号 15001，是期望接收的下一个报文段的序号，所以，服务器发送的下一个报文段的序号是 15001。因第 1 个报文的序号 8001，携带 1000 字节数据，服务器收到了 8001-9000 编号的 1000 字节数据，确认号是9001，表示 9001 号字节之前的数据已经收好，希望接收的下一个字节是 9001号字节。同理，第 3 个报文，序号为 9001，确认号是 17001。连接断开数据传输结束后，客户端和服务器任一方都可以发起断开连接。一般来说客户端发起断开连接。TCP 连接释放过程是四次握手。正常情况下，客户端发起连接断开的请求。客户端发送第 1 个报文段，FIN 标志置 1，FIN 是请求结束的意思，表示客户端方向数据传输结束。假设这个段的序号是 u，在此图中，FIN 报文段值只是控制报文，没携带数据。TCP 规定，FIN 报文段即使不携带数据，它也消耗掉一个序号。服务器发送第 2 个报文段，ACK 报文段，确认它收到了客户端的 FIN 报文段，假设其序号为 v，确认号= u+1。服务器发送第 3 个报文段，FIN 报文段，两个标志 FIN，ACK 置 1，FIN 表示服务器方向数据传输结束，确认仍是对第 1 个报文段的确认，确认号= u+1。注意，其序号仍然是 v，原因是第 2 个报文段运用了下述的规则 2，其序号 v 没有消耗，继续使用。客户端发送第 4 个报文段，ACK 报文段，ACK 标志置 1，确认是对服务器 FIN 报文段的确认，确认号= v+1。其序号是 u+1，原因第 1 个报文段运用了规则 3，序号 u 被消耗掉了，所以现在序号是 u+1。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>课内学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04.05-网络-网络安全]]></title>
    <url>%2Fposts%2F46574.html%2F</url>
    <content type="text"><![CDATA[网络安全威胁拟人模型在网络通信中，数据肯定有发送方和接收方，在全双工通信的时候双方既为发送者也为接受者，这便是图上的Alice和Bob，而Trudy可以指破坏通信的软件，也可以指破坏通信的主机。如：病毒（virus）蠕虫（worm）间谍软件（spyware）：记录键盘输入、web站点访问、向收集站点上传信息等Trudy可以做什么映射（Mapping）在任何网络攻击发起之前都会有一个映射，这是发起攻击前的“探路”（case the joint），即找出网络上在运行什么服务：利用ping命令确定网络上主机的地址端口扫描（Port-scanning）：获得主机地址后依次尝试与每个端口建立TCP连接对策（Countermeasures）记录到达的网络流量分析、识别出可疑活动（IP地址和端口被依次扫描）分组“嗅探”（sniffing）广播介质（共享式以太网，无线网络）混杂（promiscuous）模式网络接口可以接收/记录所有经过的分组/帧可以读到所有未加密数据（例如账户密码）不一定所有的嗅探都是有害的，Wireshark就是一个典型免费的分组嗅探软件对策组织中的所有主机都运行软件，周期性监测网络接口是否工作在混杂模式每段广播介质连接一台主机（如交换式以太网）IP欺骗（Spoofing）：直接由应用生成“原始”IP分组，可以设置分组的源IP地址字段为任意值接收方无法判断源地址是否被欺骗e.g.: C冒充B对策入口过滤（ingress filtering），即路由器不转发源IP地址无效的IP分组（例如当源IP地址不属于所连接网络时）。这是很有效的对策！但是不能强制所有网络都执行入口过滤。拒绝服务DOS（Denial of service）向接收方恶意泛洪（flood）分组，淹没（swamp）接收方带宽耗尽资源耗尽分布式拒绝服务攻击（DDOS）：多个源主机协同淹没接收方，例如C与另一个远程主机协同对A进行SYN攻击。SYN 攻击利用TCP连接的三次握手过程，Trudy向服务器发送第一次握手，服务器给建立TCP连接分配资源，发送第二次握手，但是Trudy在发送第一次握手之后不再做任何响应，服务器接收不到三次握手信号，一直发送第二次握手信息。大量的类似TCP连接产生后，服务器会陷于拒绝服务的状态。对策：在接收到第一次握手信号后不立即分配资源，而是将源IP、目的IP、源端口、目的端口、随机数构成的五元组哈希成服务器的序列号y，并且发送二次握手信号。此时服务器不进行超时重传等机制。如果再接收到ACK为y+1第三次握手信号才去分配资源。所以在接收到第一次握手后服务器可以保留一份y到五元组的映射，这样的话在接收到ACK为y+1第三次握手信号之后就可以查一下y是否在哈希表中，如果在便可以为为客户端分配资源。密码学名词在我们现今的密码学体系中，加密结果的影响因素有两个，加密算法和加密秘钥，而加密算法一般是公开的，因为创建一个加密算法是非常困难的事情。所以密文可以被表示为：$K_A(m)$，解密后的密文：$m=K_B(K_A(m))$。对称秘钥加密对称密码是我们最容易被理解的密码算法，其对应上图就是$K_B == K_A$，也就是说对于一次加密过程，我们进行一次逆过程就可以完成解密。DESData Encryption Standard。IBM公司研制。DES的部分部分是保密的。1972年，美国国家标准局开始实施计算机数据保护标准的开发计划。1973年5月13日，NBS征集在传输和存贮数据中保护计算机数据的密码算法。1975年3月17日，首次公布DES算法描述。1977年1月15日，正式批准为加密标准，当年7月1日正式生效。1994年1月的评估后决定1998年12月以后不再将DES作为数据加密标准。AESAdvanced Encryption Standard，1997年美国国家标准技术研究所NIST宣布征集AES算法，要求：可公开加密方法分组加密，分组长度为128位至少像3DES一样安全更加高效、快可提供128/192/256位密钥比利时学者Joan Daemen和Vincent Rijmen提出的Rijndael加密算法最终被选为AES算法。NIST在2001年12月正式颁布了基于Rijndael算法AES标准公钥密码学公钥密码也是非对称密码。公钥加密算法一般由五个部分组成：原文（Message）：需要加密的信息，可以是数字、文字、视频、音频等，用$M$表示。密文（Ciphertext）：加密后得到的信息，用$C$表示。公钥（Public Key）和私钥（Private Key），用$PU$和$PR$表示。加密算法（Encryption）：若$E(x)$为加密算法，加密过程可以理解为$C=E(m)$，根据原文和加密算法得到密文。解密算法（Decryption）：若$D(x)$为解密算法，解密过程可以理解为$M=D(c)$，根据密文和解密算法得到原文。对于公钥密码学，我们不去探究他们的数学原理是什么，但是需要了解算法的特性和用途。我们先看算法的特性，在下面的其他部分再看算法的用处。我们先不考虑公钥和私钥，将秘钥设为秘钥A和秘钥B，使用密钥A加密数据得到的密文，只有密钥B可以进行解密操作（即使密钥A也无法解密），对应的，使用了密钥B加密数据得到的密文，只有密钥A可以解密。此时我们把一个秘钥公开出去，一个秘钥自己掌握，便区分为公钥和私钥。而根据不同用途，对数据进行加密所使用的密钥也不相同，即有时用公钥加密，私钥解密；有时则相反，用私钥加密，公钥解密。数字签名消息完整性报文/消息完整性（message integrity），也称为报文/消息认证（或报文鉴别），指在传输、存储信息或数据的过程中，确保信息或数据不被未授权的篡改或在篡改后能够被迅速发现。它有几个核心目标：证明报文确实来自声称的发送方验证报文在传输过程中没有被篡改预防报文的时间、顺序被篡改预防报文持有期被修改预防抵赖发送方否认接收方否认密码散列函数密码散列函数（Cryptograph ic Hash Function）的特点：散列算法公开H(m)能够快速计算对任意长度报文进行映射，均产生定长输出对于任意报文无法预知其散列值不同报文不能产生相同的散列值单向性：无法根据散列值倒推出报文，即对于给定散列值h，无法计算找到满足h = H(m)的报文m抗弱碰撞性（Weak Collision Resistence-WCR），即对于给定报文x，计算上不可能找到y且y≠x，使得H(x)=H(y)。抗强碰撞性（Strong Collision Resistence-SCR），在计算上，不可能找到任意两个不同报文x和y(x≠y)，使得H(x)=H(y)。散列函数算法MD5：被广泛应用的散列函数（RFC 1321）。对任意长度的报文输入，计算输出128位的散列值。但是MD5不是足够安全，1996年，Dobbertin找到了两个不同的512-bit块，在MD5计算下产生了相同的散列值SHA-1：Secure Hash Algorithm，SHA-1要求输入消息长度$&lt;2^{64}$，SHA-1的散列值为160位。其速度慢于MD5，安全性优于MD5。报文摘要Message digests，对报文m应用散列函数H，得到一个固定长度的散列码，称为报文摘要（message digest），记为H(m)。可以作为报文m的数字指纹（fingerprint）。报文认证简单的报文认证在不知道散列的情况下，简单的报文认证什么都不能保证，因为在简单的报文认证中修改了报文，只要顺便修改了报文摘要就无法检测报文的正确性。报文认证码MACMessage Authentication Code。在简单报文的基础上，加上认证密钥（对称秘钥）。加上认证秘钥之后，只要能保证秘钥的安全性（后面会介绍如何保证对称秘钥的安全性）。但是此时仍然不能解决如下问题：否认发送方不承认自己发送过某一份报文接收方不承认自己接收过某一份报文伪造：接收方自己伪造一份报文，并声称来自发送方篡改：接收方对收到的信息进行篡改数字签名使用数字签名后，假设Alice收到报文m以及签名，Alice利用Bob的公 解密 ，并检验来证实报文m是Bob签名的。如果成立，则签名m的一定是Bob的私钥，于是，Alice可以证实：Bob签名了m。没有其他人签名m的可能。即这份报文只能是来自Bob。Bob签名的是m而不是其他报文m。因为只有Bob知道他自己的私钥。同时，Alice没有Bob的私钥，不可能伪造，篡改Bob发来的报文。数字签名相比于MAC又能解决更多的问题，但是数字签名不能解决“接收方不承认自己接收过某一份报文”的问题，想要解决这个问题必须采用其他的协议。秘钥分发KDCKey Distribution Center。对称秘钥的问题便是如何建立共享秘钥。即在Alice和Bob通信过程中，如何保证双方接收到的会话秘钥都是正确的且没有被Trudy接收到。而解决办法就是设立一个可信任的密钥分发中心作为中介。密钥分发中心是一种运行在物理安全服务器上的服务，KDC维护着领域中所有安全主体账户信息数据库。与每一个安全主体的其他信息一起，KDC存储了仅安全主体和KDC知道的加密密钥，这个密钥也称长效密钥（主密钥），用于在安全主体和KDC之间进行交换。而用于Alice和Bob相互认证的会话密钥就是由KDC分发的。KDC的工作方式如下：Alice使用自己和KDC共享的那一份秘钥加密自己和Bob的信息。表示自己想和Bob通信。KDC使用Bob和KDC共享的那份秘钥加密Alice的信息和给本地通信颁发的会话秘钥R1。设为E。KDC将E用Alice的秘钥加密，发送给Alice。Alice用自己的秘钥解密后，可以获得E。Alice将E发送给Bob，Bob用其有KDC共享的秘钥解密E后就可以知道自己需要和Alice使用R1通信。使用KDC进行通信加密的时候有个破绽，就是Alice和Bob与KDC之间共享的那份秘钥CACertification Authority。公钥通信的问题就是如何保证接收方接到的是发送方的公钥。即如何避免中间人攻击。中间人攻击Bob给Alice发送自己公钥，这个消息被Trudy接收到了。此时Trudy有了Bob的公钥。Trudy将自己的公钥发送给了Alice，此时Alice有的是Trudy的公钥。Bob给Alice发送消息，消息被Trudy截获，Trudy有Bob的公钥能解密Bob的报文。Trudy给Alice发送假消息，Alice用第二步获得的Bob的公钥解密，以为是Bob给自己发送的消息。可信任的认证中心中间人攻击的解决方案就是寻找一个可信任的认证中心。实现特定实体E与其公钥的绑定每个E（如人、路由器等）在CA上注册其公钥。需要Bob的个人信息和Bob的公钥。CA创建绑定E及其公钥的证书（certificate）证书包含由CA签名的E的公钥 – CA声明：“这是E的公钥”可信赖的认证中心可以解决很多问题，但是还有一个缺陷，就是Bob怎么获得CA的公钥？如果Bob通过网络获取CA的公钥，那么仍然会被中间人攻击，所以在现在的浏览器、操作系统中已经内置了一些认证中心的公钥。这样的话，Bob发送给CA的信息就不可能被劫持。Alice也能使用内置的公钥解密CA签发的公钥证书。HTTPS数字证书https基本原理回放攻击的抵御我们上面的https能够抵御中间人攻击，但是却无法抵御回放攻击。什么是回放攻击呢？假如Alice想向Bob转10块钱。Alice发送一个报文个给支付宝，Alice和支付宝之间的通信使用https进行加密，此时Trudy通过嗅探的方式获得了这个数据包，虽然Trudy无法知道这个报文的内容是什么，但是如果Trudy将这个报文多次发送给支付宝，Alice就相当于转了好多次钱给Bob。那么该如何解决呢？一次性随机数Alice在向服务器发送转账报文之前，先向服务器申请一个一次性随机数，服务器在生成这个随机数R后一边将其存储在服务器上（设为表X），一边再将其发送给Alice。然后在发送转账报文的时候将R+1附在报文上，服务器收到报文后解密报文再减一得到便可以得到R，然后再查表X，此时服务器就知道R没有被使用过，在处理完此次请求后，服务器将R从表X中删除。如果Trudy伪造了一份报文发送给服务器，服务器在表中查不到R，便不会处理此次请求。过期时间一次性随机数可以抵御回访攻击，但是还有点缺陷，就是如果Alice在获得R后不发送转账报文，表X中的R永远不会被删除，就会造成内存泄漏。此时可以将表中的每个随机数设置一个过期时间，便可以很好的解决这个问题。SSHSSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。SSH使用的加密方式也是公钥加密技术，所以其和https面临相同的问题，就是中间人攻击。但是和https寻找CA认证不同，SSH采用用户自行确认的方式进行认证。所以在第一次登录到对方主机的时候，系统会出现类似下面的提示：1234$ ssh user@hostThe authenticity of host &apos;host (12.18.429.21)&apos; can&apos;t be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)?很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对。如果用户经过核对（或者不核对）之后确定是对方主机，就可以和对方主机建立连接。然后便是输入用户名密码的环节了。参考哈尔滨工业大学mooc码农翻身https://www.ruanyifeng.com/blog/2011/12/ssh_remote_login.html]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>课内学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04.06-网络-面试题]]></title>
    <url>%2Fposts%2F329.html%2F</url>
    <content type="text"><![CDATA[TCP 对比 UDP对比TCP提供面向连接的、可靠的数据流传输，TCP传输单位称为TCP报文段。UDP提供的是非面向连接的、不可靠的数据流传输。UDP传输单位称为用户数据报。应用层协议TCP对应的协议FTP：定义了文件传输协议，使用21端口。SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。UDP对应的协议DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。TCP的可靠传输差错控制TCP保证差错控制使用的方式是：校验和 &amp; 确认与重传校验和校验和的目的是为了保证接收端接收到的数据不会因为网络的不稳定导致数据出错。确认与重传确认和重传机制是为了保证报文段在传输的时候没有发生丢失。流量控制流量控制的目的是为了保证传输两端之间速率的匹配。即不能由于发送方发送的速度太快而导致接收在接收到数据后来不及处理而被迫丢弃进而引起发送方重传。使用GBN协议或者选择重传协议来控制。即使用发送-确认的机制来协调点到点之间传输的速率。接收方窗口在流量控制阶段接收方会分配一段内存空间做为接收缓冲区。通常情况，接收方的缓存中包含已接收且确认的数据字节，它们在正等待应用进程将它们拉走，称为未交付数据。接收缓冲区剩余的空间，即可用来接收新数据的空间，称为接收窗口（通常记为rwnd）。若应用进程迟迟不讲缓存区中的数据取走，随着不断接收新数据，接收窗口（可用的接收缓存）会越来越小，直到为零。而对于任何时刻：rwnd(接收窗口)=缓冲区大小-未交付数据字节数。拥塞控制拥塞控制作用于网络，它防止过多的数据注入到网络中，避免出现网络负载过大的情况。阻塞的检测全阻塞：超时表示网络全阻塞。半阻塞：三次重复ACK表示网络半阻塞。拥塞控制策略慢开始，指数增大到达慢开始门限值（ssthresh）的时候进行加法增大（起始的慢开始门限值是人为设置的）当发生全阻塞时ssthresh门限值设为此刻cwnd的一半，ssthresh=cwnd/2将拥塞窗口重新设置设为1。cwnd =1进入慢启动阶段。当发生半阻塞时ssthresh门限值设为此刻cwnd的一半，ssthresh=cwnd/2将拥塞窗口设为门限值。 cwnd=ssthresh进入拥塞避免阶段。TCP的三次握手和四次挥手三次握手客户端向服务器发送建立连接请求，并且携带一个客户端起始序列号。服务器向客户端确认已收到客户端的序列号，并且将服务器起始序列号发送给客户端。客户端收到服务器的序列号之后，客户端向服务器确认已收到服务器序列号。客户端状态：SYN_SENT：客户端发送请求给服务器后的状态ESTABLISHED：客户端进入连接建立状态服务器状态：SYN_RECV：服务端被动打开后,接收到了客户端的SYN并且发送了ACK时的状态ESTABLISHED：服务器进入连接建立状态二次握手的缺陷二次挥手不能防止已失效的连接请求又传送到服务器端。客户端发送第一个请求给服务器（第一次第一次握手），如果这个请求在网络上迷失，客户端在超时之后会再发一次请求给服务器（第二次第一次握手）服务器收到第一次握手的这个连接之后会发送ACK给客户端（第二次握手）。在二次握手的情况下，客户端不发送ACK，此时可以进行通信。此时若我们第一次发送的第一次握手信号达到了服务器，那么服务器以为是新的连接，就会发确认报文到客户端确认并建立连接，但发送端可能已经关闭，接收端可能就这样等待，这在网络中就浪费了资源。但是有了第三次握手不一样了，服务器在接收到了滞留在网络中的信息后，会发送确认信息给客户端，但是当客户端没有理会的时候，服务器在超时之后就会自动关闭这次连接。四次挥手连接断开时可以先由服务器发起，也可以先由客户端发起。下面假设是客户端发起的连接断开。客户端向服务器发送一个FIN报文段；此时，服务器进入FIN_WAIT_1状态。这表示客户端没有数据要发送给服务器了。服务器收到了客户端发送的FIN报文段，向客户端回一个ACK报文段，服务器进入CLOSE_WAIT状态。表示服务器知道客户端没有数据要传送过来了，服务器自己进入等待关闭状态，表示发完手上的数据就进行关闭。服务器发完手上的数据后向客户端发送FIN报文段来请求关闭连接。这表示客户端服务器已经没有数据要传给客户端了。客户端收到服务器发送的FIN报文段，向服务器发送ACK报文段。服务器收到客户端的ACK报文段以后，就关闭连接。此时服务器关闭连接完成。如果客户端等待2MSL后依然没有收到回复，客户端的定时器关闭，表示客户端关闭连接完成。客户端状态：FIN_WAIT_1：客户端发送FIN报文段后的状态FIN_WAIT_2：客户端接收到服务器的ACK报文段之后的状态TIME_WAIT：客户端接收到服务器发送的最后一个ACK之后，进入一个2MSL的等待期。服务器状态：CLOSE_WAIT：服务器接收到客户端请求关闭的报文之后进入关闭等待期LAST_ACK：服务器发送完关闭连接报文段后（FIN）等待接收客户端的确认的状态。为什么四次挥手后需要等待一段时间为了保证客户端发送的最后一个ACK报文能够到达服务器。这个ACK的报文有可能丢失，这样处于LAST-ACK状态的服务器如果收不到客户端的ACK报文，会再次发送第三次挥手信号，而客户端在2MSL的时间内收到这个重传的信号。接着客户端重传一次确认，重新启动2MSL计时器。如果客户端不在TIME-WAIT状态下等待一段时间，而是在发送完ACK报文后立即释放连接，那么就无法收到重传的第三次挥手报文，因而也不会再一次的发送确认报文，那么服务器就会永远进行重传。避免新旧连接混淆。等待2MSL可以让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接请求不会出现旧的连接请求报文。我们假设TCP连接是A(1.2.3.4:8888)-B(6.7.8.9:9999)，这就是一个TCP四元组。当TCP连接关闭后，四元组释放。后面的新连接可能会重用到这个四元组，那么问题就来了：新四元组和旧四元组完全一致，他们的网络包会产生混乱。所以等待一段时间可以让旧四元组对应的所有网络包都消失，避免新旧连接混淆。网络模型各层的功能应用层（application layer）是体系结构中的最高。直接为用户的应用进程（例如电子邮件、文件传输和终端仿真）提供服务。协议：HTTP协议、SMTP协议、FTP协议、DNS、POP3、SNMP、Telnet运输层（transport layer）负责向两个主机中进程之间的通信提供服务。由于一个主机可同时运行多个进程，因此运输层有复用和分用的功能复用，就是多个应用层进程可同时使用下面运输层的服务。分用，就是把收到的信息分别交付给上面应用层中相应的进程。协议：UDP协议、TCP协议网络层(network layer）网络层(network layer)主要包括以下两个任务：负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组或包进行传送。在TCP/IP体系中，由于网络层使用IP协议，因此分组也叫做IP数据报，或简称为数据报。选中合适的路由，使源主机运输层所传下来的分组，能够通过网络中的路由器找到目的主机。协议：IP、ICMP、IGMP、ARP、RARP数据链路层（data link layer）将网络层交下来的IP数据报组装成帧（framing），在两个相邻结点之间的链路上“透明”地传送帧中的数据。每一帧包括数据和必要的控制信息（如同步信息、地址信息、差错控制等）。协议：GBN协议、选择重传协议物理层（physical layer）物理层的任务就是透明地传送比特流。HTTPS]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>课内学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04.02-网络-链路层]]></title>
    <url>%2Fposts%2F24372.html%2F</url>
    <content type="text"><![CDATA[相邻计算机网络中链路层的功能是“相邻节点间的数据传输”。这句话什么意思呢？我们先讨论“相邻”一词，再讨论“数据传输”。两台主机，用一根网线相连是相邻。多台主机，用一根网线相连，仍然是相邻。这根线缆退化成一个节点，这样的设备称为集线器。通过集线器相连的多台主机也是相邻。集线器没有任何智能，等同于线缆。在集线器上增加简单的智能控制功能，就是交换机。通过交换机相连的多台主机也是相邻。交换机将计算机互联在一起，构成局域网。所以“相邻节点间的数据传输”换一种说法就是“构建局域网”，再换一种说法就是“局域网内的主机都是邻居关系”。链路层的功能就是构建局域网。相邻这一概念很重要，主机间的数据传输可以分为两种情况，一种是两个主机在同一个局域网内，两主机是相邻关系，简称内网通信，另一种是两个主机在两个不同的网络里，可称外网通信，两种数据传输原理完全不同。本篇文章只关注内网通信。链路层解决的问题数据传输就是将一台主机内的数据传输到另一台主机，物理层解决了比特转换为电磁信号传输的问题，但这不是数据传输的全部问题，还有一些问题，例如：物理层传输中的数据有可能出错，如何处理？发送方与接收方的速度可能不匹配，如何调节？数据如何封装成数据帧，然后传输，如何传输封装？发生碰撞该怎么办？针对这些问题制定的解决方案称为数据链路层的通信协议。物理链路+通信协议构成了我们要研究的数据链路。循环冗余码循环冗余码（CRC）在很多地方都被用来校验传输的数据是否出错，至于其如何证明，笔者也未曾探究，下文介绍冗余码的思想和计算方法。如果发送方只传输 87，接收方收到 82，接收方是无法判断 82 是不是发送方发送的数据，就是说无法判断 82 是对还是错。怎么办？发送方与接收方事先商量好一个数，例如 15，发送时先计算 87 除 15 的余数，为 12，将这个余数与 87 一起发送，即 8712，接收时先计算 82 除 15 的余数，为 7，不等于 12，就认为传输的数据出错，这样检错的概率并非百分之百，例如87 错成 72 就检测不出来，但总体来说，检错概率已经非常高了。CRC 计算方法第一，CRC 有一个生成多项式 P(x)，其作用等同于除数 15，将其写成比特串，转化规则如图：第二，如果 P(x) 的比特串是 n 位，在发送数据后补 n-1 个 0。例如 P(x)为 1101，就要补 000。第三，做模2除法。注意模二除法不是二进制除法。第四，用余数替换补的 0，形成发送数据，101001001。第五，接收方用接收数据 101001001 除以 P(x)1101，如果能整除，就表示没有错（等同与原理中的余数相同），如果不能整除，就表示出错了（等同与原理中的余数不相等）。停止等待协议（Stop-and-Wait protocol）如果两个主机间数据传输时，接收方的速度永远不会低于发送方的速度；传输的数据帧不会出错，也不会丢失，完全理想化的数据传输，那就没有什么问题，当然也不需要解决问题的办法，也就不需要协议。现在假设，没有差错，但是接收方的速度低于发送方的速度，怎么办？显然控制的思路只能是快的一方牵就慢的一方，就是由慢的一方指挥快的一方。具体来说，就是发送方每发送一帧就停下来，等待；收到 ACK 发送下一帧，接收方则是等待，收到数据帧，发送 ACK（确认 Acknowledgment ），等待下一帧。停下来，等待就是停止等待协议的由来。停止等待协议当然不仅仅需要这一个问题，其需要解决的问题如下：接收方的速度低于发送方的速度；传输的数据帧可能出错；数据帧可能丢失，确认帧 ACK 也可能丢失；确认号接收方收到一个数据帧，并校验正确，给发送方一个确认 ACKn，ACKn 表示“第 n-1 号帧已经收到，现在期望接收第 n 号帧”。确认号是接收方预期接收的下一帧的序号。差错数据帧出错时，接收方收到一个数据帧，校验时发现数据帧出错，接收方丢弃此数据帧，此外不做任何事，即不发送 ACK。发送方发送完数据帧后在停止等待 ACK，然而此时不会有 ACK，发送方就等死在这里了。重传定时器发送方设计一个重传定时器的机制，发送方每发送一个数据帧，就启动一个倒计时的重传定时器，如果在超时 timeout 之前收到确认，就关闭定时器并发送下一帧。如果超时，就重传之前的帧。丢失接收方收到一个数据帧，校验正确发送 ACK，等待接收下一帧，如果确认帧丢失，发送方收不到确认，超时后重传旧帧，而接收方在等待新帧，此刻发送方与接收方的状态不同步，如何区分新帧与重传的帧？帧编号停等协议使用序号和确认号，以区分重传的数据帧。发送方发送帧时使用序号，接收方使用确认号。信道利用率停止等待协议的优点是简单，但缺点是信道利用率太低。信道利用率公式：$U=\frac{T_D}{T_D+RTT+T_A}$，其中：$T_D$：数据帧传输时延$RTT$：数据帧+确认帧传播时延$T_A$：确认帧传输时延举例：假设主机甲与主机乙使用停等协议传输数据，若甲乙之间的单向传播延迟是 15ms，数据帧长为 1000 字节，信道宽带为 100Mbps，乙每收到一个数据帧立即利用一个短帧（忽略其发送时延）进行确认，则信道利用率为：发送一个数据帧到 100Mbps 链路所需时间为：$T_D = \frac{1000 \ast 8bits}{100 \ast 10^6bit/s }= 80\mu s$。发送方在 t=0 时刻发送，15ms 后第 1 个比特到达主机乙，15.08ms 时主机乙收到最后一比特，开始发送确认帧，由于确认帧很短，我们忽略其发送时延，在30.08ms 时，确认帧到达主机甲，总时间周期为T𝐷 + RTT + T𝐴(忽略) = 30.08ms，信道利用率为0.0027。信道利用率为 0.27%，就是说发送方只有百分之0.27的时间是忙的。停止等待协议信道利用率太低了。GBN 协议我们讨论一个可以获得较高信道利用率的协议：连续 ARQ 协议(Go-back-NProtocol)，或称 GBN 协议，也称为滑动窗口协议（Sliding Window Protocol）。发送方在接收到确认之前，发送一组数据帧，而不是发送一个数据帧就停止等待确认。确认号在 GBN 协议中，采用累积确认的方式，确认号是希望接收的下一个分组序号。举例，ACK7 表示序号 6 以内的所有帧都已正确收到了，等待接收 7 号帧。发送窗口在 GBN 协议中，发送一组帧，然后停止等待确认。发送窗口定义了最多可以发送多少个数据帧。举例如下图：一个大小为 7 的窗口，窗口左侧是已确认，已丢弃的帧，窗口内有色的是已发送的，尚未收到确认的帧，0，1，2，3 号帧，发送方需要等待，可称为未完成帧，窗口内无色的是可发送还未发送的帧，是 4，5，6 号帧，窗口右侧是不能发送的帧。描述发送窗口需 3 个变量：$S_f$：发送窗口，第一个未完成分组。完成指的是发送方接收到确认方的确认帧。$S_n$：发送窗口，下一个待发送分组。$S_{size}$：发送窗口，大小。当 ackNo 大于等于 $S_f$ 且小于 $S_n$ 的无错 ACK 到达时，发送窗口可以滑动一个或多个槽。举例，当发送方收到 $ACK_6$，表示 4，5 号帧已正确接收，窗口滑动，状态如下图。接收窗口在 GBN 协议中，接收窗口大小总是 1。只有序号在接收窗口内的数据帧才接收。任何失序的分组都会被丢弃，需要重发。描述接收窗口控制只需 1 个变量 $R_n$，表示其期待下一次接收的帧，重传定时器在 GBN 协议中，只使用一个计时器。接收窗口大小总是 1。当定时器超时，发送方重发所有未完成分组。例如，假设发送方已经发送了分组 6（$S_n=7$），但是唯一的计时器终止。如果 $S_f=3$，这意味着分组 3、4、5 和 6 没有被确认；发送方回退并重发分组 3、4、5 和 6。发送方发送分组。发送方会开启唯一的计时器。$S_n$ 的值增长，（$S_n=S_n+1$）如果达到窗口值进入阻塞状态。如果 ACK 到达，其 ackNo 与一个未完成分组有关，那么发送方滑动窗口（令 $S_f=ackNo$），并且如果所有未完成分组都被确认（$ackNo=S_n$），那么关闭计时器。如果并不是所有未完成分组都被确认，那么重新开启计时器。如果超时发生，发送方重发所有未完成分组并重新开启计时器。接收方如果 $seqNo=R_n$ 的无错分组到达，之后窗口滑动，$R_n=（R_n+1）$。$ackNo=R_n$的 ACK 被发送。如果 seqNo 在窗口之外的无错分组到来，分组被丢弃，但是 $ackNo=R_n$的 ACK 被发送。发送窗口的最大值当用 n 个比特进行帧编号时，接收窗口的大小为 1，则只有在发送窗口的大小$W_T ≤ 2^n − 1$时，连续 ARQ 协议才能正确运行。例如，当采用 2bit 编码时，发送窗口的最大值是 3 而不是 4。下图比较 4 与 3 两种情况。如果窗口的大小是 4 并且所有确认都丢失，发送方将会重传旧的所有 4 个帧。但是接收方等待接收的是新的 0 号帧，由于窗口匹配，接收 0 号帧，接收方认为接收的是新的 0 号帧，这是一个错误。如果窗口大小为 3 并且所有三个确认都丢失，那么超时并且重发所有 3 个分组，接收方现在期待 3 号帧，而不是 0 号帧，因此重传分组被正确丢弃。不会产生错误。为能正确区分重传的帧，应保证在$W_T+W_R$的窗口内不出现重复序号，即$W_T + W_R ≤ 2^n$，我们将 WT 和 WR 拼接在一起，在$W_T + W_R$窗口内如果出现重复序号，就会发生上述的错误，如果不出现重复的序号，就不会发生上述的错误。GBN 协议的接收窗口为 1，所以发送窗口最大为$2^n − 1$CSMA/CD共享信道有一个基本问题，碰撞 （Collision）。若某时刻两帧同时发出，会相互重叠，结果使信号无法辨认，称为碰撞。如下图便是碰撞：碰撞的结果是两个帧都变得无用。解决碰撞的思路大致有两类：一类思路是将工作做在前面，预防碰撞，即受控接入：各主机不能任意发送数据，必须服从一定的控制。如令牌环网，拥有令牌的主机可发送数据，没有令牌的主机只能接收数据，令牌如击鼓传花般依次传递。另一类思路是将工作做在后面，撞就撞吧，做好事故的处理，即随机接入：所有主机都可以根据自己的意愿随机地发送数据。CSMA/CD（Carrier Sense Multiple Access with Collision Detection）载波监听多点接入/碰撞检测。载波监听（Carrier Sense）指监测信道上有无数据信号传输，监测方法是判断基带上是否有脉冲二进制 0 或 1。多点接入（Multiple Access）同时有多个站点连接在信道上。显然，使用随机接入的方式是无法避免碰撞的。在随机接入的情况下，需要完成几项工作：尽量减少碰撞是否碰撞有明确结论碰撞之后的事故处理CSMA/CD 协议完成这些工作的原理，简缩为三句口诀。先听后发边发边听冲突重发先听后发我们当然希望尽量减少碰撞，想个什么办法呢？就是在发送数据帧之前，先监听信道。“载波监听”就是“发送前先监听”，如果信道上有数据帧，当然就先不发送数据帧，否则一发送数据帧就产生碰撞，碰撞了就毫无意义。当监听信道时，如果信道忙有数据帧，站点回去睡一段随机时间，然后再回来监听信道，这种策略称非坚持型 CSMA。当监听信道时，如果信道忙有数据帧。站点不是回去睡一会，而是蹲守在这儿，继续监听直到信道空闲，这种策略称坚持型 CSMA。当监听到信道空闲下来时，站点立即就发送数据，称 1-坚持型 CSMA。当监听到信道空闲下来时，站点并不立即发送数据，先抛一次硬币，如果是字就发，如果是花就不发，就是说以概率 p 发送数据，称 p-坚持型 CSMA。边发边听站点发出数据帧后，是否碰撞需要有明确的结论。就需要“碰撞检测”（Collision Detection）。如何检测呢？站点检测信道上的信号电压大小，当几个站同时在总线上发送数据时，总线上的信号电压摆动值将会增大（互相叠加）。当检测到的信号电压摆动值超过一定的门限值时，就认为总线上至少有两个站同时在发送数据，表明产生了碰撞，“碰撞检测”也称为“冲突检测”。假设 A 站点与 B 站点是网络最远的两端，从 A 站点发出一数据帧，到达 B站点的所花费的时间为$\tau$，A 站点发出一数据帧，就在即将到达 B 站的时刻，B站发出一数据帧，立即发生碰撞，碰撞信号继续到达 A 站，A 站在经过时间 $2\tau$（两倍的端到端传播时延）发现碰撞。所以，$发送站点监听时间&gt;2\tau$，就可以得到是否碰撞的明确结论。$2\tau$ 也即称为争用期，或碰撞窗口。所以为得到是否碰撞的明确结论，只需要$监听时间&gt;2\tau$就可以了。冲突重发发生碰撞，两个数据帧都损坏，当然需要重发。但是如果两个站点都立即重发数据帧，又会再次碰撞，两个站点发送时刻最好能够错开一些。CSMA/CD 协议使用截断二进制指数退避算法，发生碰撞的站在停止发送数据后，要推迟（退避）一个随机时间才能再发送数据。重传次数 k，$k=Min[重传次数,10]$从整数集合$[0,1,…,(2^k-1)]$中随机地取出一个数，记为 r。重传所需的时延就是 r 倍的基本退避时间。基本退避时间一般是取为争用期。当重传达 16 次仍不能成功时即丢弃该帧，并向高层报告。使用 CSMA/CD 协议后不能进行全双工通信而只能进行双向交替通信（半双工通信）。每个站在发送数据之后的一小段时间内，存在着遭遇碰撞的可能性。这种发送的不确定性使整个以太网的平均通信量远小于以太网的最高数据率。10BASE-T 以太网10Base-T以太网使用的是1-坚持型CSMA / CD。10BASE-T 以太网不用同轴电缆而用无屏蔽双绞线，降低了成本，还增加了一种可靠性非常高的设备，叫做集线器（hub）。正是这两个原因，使得 10BASE-T以太网拥有很低的成本和很高的可靠性，迅速在局域网中占据了统治地位。10BASE-T 以太网定义：争用期的长度为 51.2 us，而$监听时间 &gt; 2 \tau$ 便等价于$发送数据帧的时间 &gt; 2\tau$。可得：$\frac{帧长L}{10Mbps}&gt;51.2 \mu s$，即$L &gt; 512bit$。最短帧长 64 字节。帧间最小间隔为 9.6us，因为要给双方留下缓冲时间。站点到集线器的距离不超过 100m，为了保证双绞线上的信号不会出错。如果数据帧太长就会出现有的主机长时间不能发送数据，而且有的发送数据可能超出接收端的缓冲区大小，造成缓冲溢出。为避免单一主机占用信道时间过长，规定了以太网帧的数据部分最大长度为1500。网卡在主机内部，需要 10BASE-T 的网络接口板又称为通信适配器（adapter）或网络接口卡 NIC(Network Interface Card)，或“网卡”。网络适配器的重要功能：对数据进行串行/并行传输的转换编码与译码即曼彻斯特编码与译码。链路管理主要是 CSMA/CD 协议的实现。数据的封装与解封封装以太网帧。网卡的第一，第二项功能属于物理层的功能。第三项 CSMA/CD 协议的原理上文也介绍了，在此主要介绍一下以太网帧，也称 MAC 帧。网络适配器工作在数据链路层和物理层。生产网卡时，在网卡的 ROM 固化了 6 字节的 MAC 地址，因此 MAC 地址也叫做硬件地址(hardware address)或物理地址。MAC 地址唯一标识了一块网卡。MAC 地址字段是 6 字节（48 位），前三个字节（即高位 24 位），是生产厂家标识，称为组织唯一标识符，后三个字节（即低位 24 位）由厂家自行指派的产品串号，称为扩展唯一标识符，必须保证串号没有重复。网卡将上一层交下来的数据加上首部和尾部，成为以太网的帧。接收时将以太网的帧剥去首部和尾部，然后送交上一层。常用的以太网 MAC 帧格式有两种标准：DIXEthernetV2 标准和 IEEE 的 802.3 标准，最常用的 MAC 帧是以太网 V2 的格式。网卡工作要点适配器从网络层获得一个分组，加上以太网的首部和尾部，组成以太网帧，放入适配器的缓存中，准备发送。若适配器检测到信道空闲，就发送这个帧。若检测到信道忙，则继续检测并等待信道转为空闲（加上 96 比特时间），然后发送这个帧。在发送过程中继续检测信道，若一直未检测到碰撞，就顺利把这个帧成功发送完毕。若检测到碰撞，则中止数据的发送，并发送人为干扰信号。在中止发送后，适配器就执行指数退避算法，等待 r 倍 512 比特时间后，返回到步骤 2。对于检查出的无效 MAC 帧就简单地丢弃。以太网不负责重传丢弃的帧。早期以太网采用无源的总线结构。现在采用以太网交换机的星形结构成为以太网的首选拓扑。总线以太网使用 CSMA/CD 协议，以半双工方式工作。以太网交换机以全双工方式工作，不使用共享总线，没有碰撞问题，因此不使用CSMA/CD 协议。但仍然采用以太网的帧结构。网桥与交换机我们看下面一个拓扑，某学院有三个系，各自有一个以太网，三个以太网是三个独立的碰撞域，如果用集线器连成一个更大的以太网，同时也形成一个更大的碰撞域。连接的范围扩大了，但碰撞也多了，能不能只扩大范围，不扩大碰撞呢？网桥有一种网络设备，称为网桥（bridge），能只扩大范围，不扩大碰撞。网桥工作在数据链路层，其内部维护一张转发表，根据 MAC 地址转发数据帧。当网桥收到一个帧时，根据此帧的目的 MAC 地址，检索转发表，然后再转发帧到接口。我们看下面的一个拓扑图，先不考虑网桥的转发表是怎么来的，先看一下网桥 B1 和网桥 B2 的转发表的最终形态，可以看出，转发表的本质就是拓扑图的描述，推想一下，这是必然的，网桥若要正确转发数据帧，就需要知道各主机与其的位置关系。那么，这张转发表又是怎么来的呢？网桥 B1 和网桥 B2 刚上电时，其内部转发表都是空表，这时，主机 A 给主机 B 发送一数据帧，网桥 B1 的接口 1 收到这帧，网桥 B1 能判断出主机 A 在它的接口 1 侧，但判断不出主机 B 在哪侧，首先转发，把帧向网桥除接口 1 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“A 接口 1”填入转发表，网桥 B1 就学到 1 个条目。网桥 B2 收到网桥 B1 的转发帧，网桥 B2 也能判断出主机 A 在它的接口 1 侧，但判断不出主机 B 在哪侧，首先转发，把帧向网桥除接口 1 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“A 接口 1”填入转发表，网桥 B2 也学到 1 个条目。接下来，第二个数据帧是主机 F 给主机 C 发送的，网桥 B2 的接口 2 收到这帧，网桥 B2 能判断出主机 F 在它的接口 2 侧，但判断不出主机 C 在哪侧，首先转发，把帧向网桥除接口 2 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“F 接口 2”填入转发表，网桥 B2 就学到 2 个条目。网桥 B1 收到网桥 B2 的转发帧，网桥 B1 也能判断出主机 F 在它的接口 2 侧，但判断不出主机 C 在哪侧，首先转发，把帧向网桥除接口 2 以外的所有接口转发此帧（这样做可保证找到目的站）。第二，将“F 接口 2”填入转发表，网桥 B1 也学到 2 个条目。第三个数据帧是主机 B 给主机 A 发送的，网桥 B1 的接口 1 收到这帧，网桥B1 能判断出主机 B 在它的接口 1 侧，由于已经学到 2 个条目，网桥 B1 由前 2个条目，知道主机 A 在接口 1 侧的，所以不转发。第二，将“B 接口 1”填入转发表，网桥 B2 就学到 3 个条目。因为网桥 1 没转发，网桥 B2 没收到任何数据帧，网桥 B2 仍维持着 2 个条目。经过一段时间，各主机发送了很多数据帧，网桥 B1 和网桥 B2 就学习到了完整的转发表。但是需要注意，在下图中三个碰撞域内是可以进行通信，但是跨碰撞域之后还是会产生碰撞。如A给D发消息时，B和C不能进行通信。交换机网桥只有 2 个接口，可是谁规定网桥只能有 2 个接口呢，网桥也可以有更多接口，这就是以太网交换机，以太网交换机（switch）实质上就是一个多接口的网桥。通常都有十几个或更多的接口。每个接口都直接与一个单台主机或另一个以太网交换机相连，工作在全双工方式。以太网交换机工作原理也是按转发表转发数据帧，工作在数据链路层，是第二层交换机，其内部的帧交换表（又称为地址表）是通过自学习算法自动地逐渐建立起来的。我们看下面的一个拓扑图，先不考虑交换机的转发表是怎么来的，先看一下交换机的转发表的最终形态，可以看出，转发表的本质就是拓扑图的描述，推想一下，这是必然的，交换机若要正确转发数据帧，就需要知道哪个接口与哪个主机相连。那么，这张转发表又是怎么来的呢？交换机启动时，其内部转发表是空表。A 先向 B 发送一帧，交换机收到帧后，先执行转发功能。查找交换表，如果没有查到，洪泛，交换机向除接口 1 以外的所有的接口广播这个帧。再执学习发功能，把这个帧的源地址 A 和接口 1 写入交换表中。当所有主机都发送过数据帧后，交换机就将交换表学完整了。考虑到可能有时要在交换机的接口更换主机，或者主机要更换其网络适配器，这就需要更改交换表中的项目。为此，在交换表中每个项目都设有一定的有效时间。过期的项目就自动被删除。以太网交换机的这种自学习方法使得以太网交换机能够即插即用，不必人工进行配置，因此非常方便。交换机工作原理是按转发表（MAC 表）转发数据帧，转发表的本质就是拓扑图的描述。要把交换机转发表的本质牢固的记住：交换机就是要知道哪个接口与哪个主机相连。MAC 表抖动与广播风暴网桥和交换机的使用可能会发生一下问题，我们以网桥举例：会发生 MAC 表抖动（flapping）的问题：就是说同一个MAC地址在一台交换机上的两个及以上接口都学习到，导致MAC地址表中关于此MAC地址与交换机的端口对应不断改变。数据帧会循环兜圈子，形成广播风暴。在拓扑图上，我们可以看到 帧F 到 网桥1 的时候将 F 转发出去，设为 F1，此时 网桥1 学习 到MACA（主机A的MAC地址）在下方接口。F1 到 F2 是 网桥2 学习到 MACA 在 上方接口，但是 帧F 到达 网桥2 的时候网桥2学习到MACA在下方接口，这便是MAC表抖动。同样的 F2 到 网桥1 的时候 网桥1 学习到 MACA 在上方接口，也会发生抖动。（注意：F、F1、F2的MAC地址一致）如果数据帧按照我们上面所述的方式运行，他们会在网桥1和网桥2之间不停的转圈。至于交换机自然也会出现上述的问题。解决的办法，就是在逻辑上将环打断，环打断就是棵树。一句话，就是将环打断生成树，简称为“生成树”。在网桥或交换机上运行生成树协议 STP（Spanning Tree Protocol）。生成树协议的要点是：不改变网络的实际拓扑，但在逻辑上则切断某些链路，使得从一台主机到所有其他主机的路径是无环路的树状结构，从而消除了兜圈子现象。无线局域网与 CSMA/CAIEEE802.11是一个有固定基础设施的无线局域网WLAN（Wireless Local Area Network）的国际标准。简单地说，802.11 就是无线以太网的标准：使用星形拓扑，其中心叫做接入点 AP(Access Point)，在 MAC 层使用 CSMA/CA 协议，802.11 无线局域网又称为 Wi-Fi（Wireless-Fidelity，意思是“无线保真度”）。以下讨论都是这种无线局域网。无线局域网最小构件是基本服务集 BSS（Basic Service Set），基本服务集里面的基站叫做接入点 AP（AccessPoint，AP 的逻辑功能等同与以太网的集线器），一个基本服务集通过接入点 AP 连接到一个主干分配系统 DS（Distribution System），然后再接入到另一个基本服务集，构成了一个扩展的服务集 ESS。无线局域网没有碰撞检测无线局域网逻辑上也是共享信道，采用的也是随机接入的思路。但是，无线局域网与有线局域网有一个重要的差异，无线局域网没有碰撞检测（Collision Detection）。“碰撞检测”要求一个站点在发送本站数据的同时，还必须不间断地检测信道，但接收到的信号强度往往会远远小于发送信号的强度，在无线局域网的设备中要实现这种功能就花费过大。隐蔽站问题，如下图，有 ABCD 四个站，但 A 只知道有 B，不知道有 CD。A 和 C 互相检测不到对方的无线信号时，都以为 B 是空闲的，都向 B 发送数据，结果发生碰撞。隐蔽站问题使“碰撞检测”失去意义。由于以上两个原因，无线局域网没有碰撞检测。为什么没有碰撞检测就成为问题了呢？因为没有碰撞检测引发了两个问题：怎么确定发出的数据帧是否发生碰撞，是否碰撞要有明确的结论，这个结论怎么下？在碰撞发生时，就没有感觉，撞了发送方也不会停止发送数据，仍发送数据，直到发送完才停止。不是“撞-停”的情况，而是“撞撞撞撞撞撞···”的情况，碰撞的损失过大。这两个问题都需要解决。先说第一个问题，是否碰撞的结论怎么下？无线网使用了停止等待协议，由接收方发送 ACK 帧来表示正确收到数据帧，否则引发超时重传。再说第二个问题，对于这个问题的解决办法，当然就是“尽量不碰撞”。无线网为了“尽量不碰撞”，设计了一个复杂的协议 CSMA/CA。注意，CSMA/CA协议只能做到“尽量少碰撞”，做不到“完全不碰撞”。第一个问题仍需解决，无线网的 CSMA/CA 替代不了无线网的停等协议。CSMA/CA 协议无线局域网没有碰撞检测，所以有线的 CSMA/CD 就被阉割为 CSMA，可不甘心，还想进一步的减少碰撞，就又加了一个 CA（Collision Avoidance 碰撞避免）功能。802.11 就使用 CSMA/CA 协议。而在使用 CSMA/CA 的同时，还增加使用停止等待协议。帧间间隔 IFS所有的站在完成发送后，必须再等待一段很短的时间（继续监听）才能发送下一帧。这段时间的通称是帧间间隔 IFS（Inter Frame Space）。SIFS，即短（Short）帧间间隔，长度为 28us，使用 SIFS 的帧类型有：ACK 帧、CTS 帧。DIFS，即分布协调功能帧间间隔，长度为 128us。DIFS 用来发送数据帧和管理帧。争用窗口（二进制指数退避）信道从忙态变为空闲时，任何一个站要发送数据帧时，不仅都必须等待一个DIFS 的间隔，而且还要进入争用窗口，各站就要执行退避算法。802.11 使用二进制指数退避算法。这样做就减少了发生碰撞的概率。但其避退算法和CSMA/CD的有区别。第i次退避就在$2^{2+i}$个时隙中随机地选择一个。这就是说，第1次退避是在8个时隙（而不是2个）中随机选择一个，而第2次退避是在16个时隙（而不是4个）中随机选择一个。 这样做的目的是减少碰撞。发送算法如下：如果某站点检测到信道空闲，会等待一个DIFS发送该帧。否则该站点选取一个随机值进行避退，并且在检测到信道忙的时候递减该值。当检测不忙的时候计数值保持不变。当计数值减为0的时候（此时信道一定为空闲），该站点发送整个数据帧并等待确认。如果发送方收到确认，发送站点知道他的帧被目的站正确接收了，如果该站点要发送另一帧它需要从第二步开始进行。如果未收到，执行回退算法，此次会在一个更大的范围里选取。需要注意，上图中的退避区间内退避算法得到的计数值不一定在减少。冻结指的就是再次检测到信道忙的时候不再减少计数值。信道预约为了更好地解决隐蔽站带来的碰撞问题，802.11 允许要发送数据的站对信道进行预约。有线与无线的对比无线局域网与有线局域网都是使用随机接入的方式，都是无法绝对避免碰撞的。在这种情况下，都需要考虑以下问题：尽量减少碰撞、是否碰撞要有明确结论、碰撞之后的事故处理。简单做一对比：无线网中碰撞造成的损失更大，就需要在减少碰撞的方面做更多的工作，精心设计了 CSMA/CA 协议，包含帧间间隔，争用窗口（二进制指数退避），信道预约三种机制，但仍无法完全避免碰撞。由于没有碰撞检测，是否碰撞的明确结论，由接收方发送 ACK 确认帧机制。碰撞事故处理是空，是因为将重发中的二进制指数退避已经融合到 CSMA/CA 协议中。802.11 局域网的 MAC 帧802.11 帧共有三种类型：控制帧、数据帧和管理帧。只简单讨论数据帧。数据帧的三大部分，MAC 首部，共 30 字节。帧的复杂性都在帧的首部。帧主体，数据部分不超过 2312 字节，通常都是小于 1500 字节。帧检验序列 FCS 是尾部，共 4 字节。802.11 数据帧最特殊的地方就是有四个地址字段。地址 4 用于自组网络（博主暂未接触）。我们在这里只讨论前三种地址。地址 1 总是帧将访问的下一个设备的地址，地址 2 总是帧离开的前一个设备的地址，如果地址 1 没有定义最后的目的地址，地址 3 就是最后的目的站点的地址，如果地址 2 没有定义原始源地址，地址 3 就是原始源站点地址。站点 A 向 B 发送数据帧，但这个数据帧必须经过 AP 转发。首先站点 A 发送数据帧到 AP1，然后 AP1 把数据帧发送给 B。举例：A-&gt;AP1 时：ARPARP（Address Resolution Protocol），根据 IP 地址查询MAC 地址。ARP 协议的工作原理如下图，有 ARP 请求（Request）和 ARP 回答（Reply）两个报文。ARP 报文封装成 Mac 帧，是 Mac 帧的负载，mac 帧类型值 0806 指示 mac 帧的数据部分是 ARP 报文。ARP 请求（Request）是广播，ARP 回答（Reply）是单播，见下图：ARP 请求报文所封装的 Mac 帧，目的 Mac 地址是 FF-FF-FF-FF-FF-FF，这 个地址是广播地址，交换机就会广播这个帧。ARP 请求报文和校园广播的大喇叭是不是很像呢？如果目的主机也在你的网络里，你用大喇叭喊它，要来它的mac 地址，就可以封装 mac 帧了。注意，ARP 直接封装为 MAC 帧，不是封装为 IP 报。从这点看，我个人更赞同将 ARP 理解为链路层协议。报文格式：RARPARP 是设备通过自己知道的IP地址来获得自己不知道的物理地址的协议。假如一个设备不知道它自己的IP地址，但是知道自己的物理地址，应该怎么办呢？RARP（逆地址解析协议）正是针对这种情况的一种协议。RARP以与ARP相反的方式工作。RARP发出要反向解析的物理地址并希望返回其对应的IP地址，应答包括由能够提供所需信息的RARP服务器发出的IP地址。虽然发送方发出的是广播信息，RARP规定只有RARP服务器能产生应答。许多网络指定多个RARP服务器，这样做既是为了平衡负载也是为了作为出现问题时的备份。]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>课内学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06.01-操作系统引论]]></title>
    <url>%2Fposts%2F2543.html%2F</url>
    <content type="text"><![CDATA[操作系统的定义操作系统（Operating System，简称OS）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是管理硬件设备来提高利用率和吞吐量，同时为用户和应用系统提供易于使用的接口。提高利用率：使系统中各设备的空闲时间尽可能短。提高吞吐量：使单位时间内完成的业务更多。提供易于使用的接口：即是方便使用计算机资源。例如没有操作系统，操纵计算机可能需要用户输入二进制代码，有了操作系统，用户可以点击图标，操作系统就会将其转换成二进制代码。操作系统的目标方便性：即对用户和应用程序提供易于使用的接口。有效性：提高利用率和吞吐量。可扩充性：计算机硬件和体系结构等都在不断发展中，OS需要有好的可扩充性来满足不断发展的需求。开放性：为了使计算机的应用环境从单机转换成网络，OS需要满足相应的软硬件标准来实现设备的互联。操作系统的作用提供易于使用的接口，如Shell、图形界面等。管理计算机所有的资源，负责计算机系统全部资源的分配、控制、调度和回收。隐蔽硬件特性，如计算2*3，某些机器的实现是使用加法器做2+2+2，而有的机器是乘法器实现2*3。操作系统屏蔽这些细节，用户只需要输入2*3就能完成。未配置操作系统的计算机系统人工操作：程序员把程序和数据通过穿孔的方式记录在纸带上，再启动机器读入纸带，运行完成并取走计算结果后，才允许下一个用户上机。缺点：用户独占整机：计算机上的资源为上机用户独占。设备空闲率高：用户装卡，卸卡等人工操作时，设备资源是空闲的。脱机输入/输出（Off-Line I/O）：为了解决人机矛盾及CPU、I/O等设备之间速度的不匹配。它是先把纸带通过输入设备在外围机（与主机相比处于次要地位的计算机）的控制下输入到磁带上，当CPU需要这些信息时再从磁带上高速地调取。类似的，在输出时把信息输出到磁盘中，在外围机的控制下通过输出设备输出。也就是说主机直接对磁盘进行操作，输入输出和程序运行脱离。減少了CPU的空闲时间：主机不必依赖输入输出，可以从磁盘中读取数据。提升了I/O速度：主机读取信息不再是从卡片中读取，从磁盘读取速度较快。批处理系统为了提升计算机资源的利用率和提升计算机的吞吐量研发出了批操作系统。基础概念作业：程序+数据+作业说明书（系统根据说明书来对程序的运行进行控制）。周转时间：从作业进入系统到作业完成退出系统所用的时间。平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NT_i]$带权周转时间：作业的周转时间（$T$）和系统为它提供服务的时间（$T_S$）。$W=\frac{T}{T_s}$平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NW_i]$单道批处理系统设计一个常驻内存的程序（监督程序），操作员有选择地把若干作业合成一批，安装输入设备上，并启动监督程序，然后由监督程序自动控制这批作业运行，从而减少部分人工干预，有效地缩短了作业运行前的准备时间，相对的提高CPU的利用率。同一时刻只有一个硬件在运行。特点：自动性、顺序性、单道性。缺点：I/O的慢速与CPU 的高速不匹配，且输入时需要CPU等待。用户交互性差。作业安装输入后，就不能再交互。多道批处理系统把一个以上的作业存放在主存中，并且同时处于运行状态，使这些作业共享处理机和外部设备等其它系统资源。对于一个单处理机系统来说，作业同时处于运行状态只是宏观的概念，其含义是指每个作业都已开始运行，但尚未完成。就微观而言，在任意特定时刻，处理机上运行的作业只有一个。特点：多道性、无序性、调度性。优缺点：优点：资源利用率高、系统吞吐量大。缺点：作业仍然要排队处理，所以平均周转时间长、无交互能力。此时如何调度程序已经不是再用一张简单的流程图能说明了。下图只是说明处理器利用率高。举例证明资源利用率高和系统吞吐量大设内存中有三道程序 A、B、C，它们的计算和I/O操作的时间如下表所示：| 程序操作 | A | B | C || :——: | :–: | :–: | :–: || 计算 | 30 | 60 | 20 || I/O | 40 | 30 | 40 || 计算 | 10 | 10 | 20 |单道多道分时系统批处理系统中，作业一旦提交就不能进行更改，所以人机交互性很差。为了满足人机交互的需求诞生分时系统。每一个用户通过一台终端与计算机相连，以交互式的命令使用系统，采用分享CPU的方法，由于CPU的速度比人在终端输入指令的时间快得多，所以用户感到自己独占了整个计算机系统。系统规定一个称之为“时间片”的时间单位，所有终端用户轮流享用一个时间片的CPU。需要解决的问题：及时接受：所有终端用户输入的信息都要能够被及时的送到处理器上。所以主机会以很快的速度循环扫描各个终端。每个终端也要拥有缓存区来保存输入的信息。及时处理：用户需要能对自己的作业及其允许及时地实施控制。所以所有的作业必须驻留在内存中，因此批作业系统不能被使用。它采用的方式是：作业直接进入内存。但每个用户只连续使用一个“时间片”的时间，对所有用户进行循环。这样每个用户都能及时地与自己的作业进行交互。分时系统与多道批处理系统的不同特性多路性：允许多个用户共享一台计算机，提高资源利用率。独立性：每个用户之间互不干扰，感觉就是一个人在独占一台计算机。及时性：用户的请求能在很短的时间内得到回应。交互性：用户可以通过终端和计算机进行及时交互。实时系统指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。实时系统强调程序运行的时间，它需对接收到的某些信号做出及时地反应。大多数的实时系统是专用系统，如：工业（武器）控制系统、信息查询系统、多媒体系统、嵌入式系统等。最大的特点就是可靠性：系统必须高度可靠，因为任何可能的差错都可能带来灾难性后果，所以系统一般都有多级容错措施。按是否周期执行分类：周期性实时任务：如外部设备周期性地发出状态信号给计算机使其状态能被实时感知。非周期性实时任务：提交给系统时需要指定开始截止时间和完成截止时间。硬实时任务&amp;软实时任务：硬实时任务（Hard Real-time Task）：截止时间到达时任务必须完成，比如武器控制系统。软实时任务（Soft Real-time Task）：截止时间到达时任务没有完成没有太大影响，比如多媒体系统。进程和线程进程：在系统中能独立运行并作为资源分配的基本单位。线程：独立运行的基本单位，比进程更小，基本上不拥有系统资源。通常在一个进程中包含了若干个线程。操作系统的基本特性并发：宏观上是多个进程同时运行，微观上是每一时刻只有一道进程在执行。共享：系统中的资源可供内存中多个并发执行的进程（线程）共同使用。有两种共享方式：互斥共享方式，如打印机；同时访问方式，如共享文件夹、网络资源。虚拟：通过某种技术把一个物理实体变为若干个逻辑上的对应物。这样可以避免一个进程单独占用某个物理设备，一个物理设备被分配给多个进程便可以提升物理设备的使用率。不确定性（异步性）：进程以人们不可预知的速度向前推进，即为进程的不确定性。这样的话很可能是先进入内存的作业后完成；而后进入内存的作业先完成。尽管如此，但只要有合理的进程同步方式且运行环境相同，作业经多次运行，都会获得完全相同的结果。因此，异步运行方式是允许的。操作系统的结构传统操作系统结构无结构OS：关注功能的实现和获得高的效率操作系统是为数众多的一组过程的集合，各过程之间可以相互调用，在操作系统内部不存在任何结构。程序设计的技巧，只是如何编制紧凑的程序，以便于有效地利用内存。操作系统既庞大又杂乱，缺乏清晰的程序结构。程序错误很多，给调试工作带来很多困难；另一方面也使程序难以阅读和理解，增加了维护人员的负担。模块化结构OS模块化程序设计技术，是最早（20世纪60年代）出现的一种程序设计技术。该技术是基于“分解”和“模块”原则来控制大型软件的复杂度的。将OS按其功能划分为若干个具有一定独立性和大小的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口， 使各模块之间能通过该接口实现交互，然后再进一步将各模块细分为若干个具有一定管理功能的子模块。（会导致模块之间的依赖关系很重，OS结构不清晰）若子模块较大时，再进一步将它细分。分层式结构OS：改进设计方式，使每一步设计都是建立在可靠的基础上一层一层地自底向上增添软件层，每一层都实现若干功能，最后总能构成一个能满足需要的OS。每一层都仅使用其底层所提供的功能和服务，这样可使系统的调试和验证都变得容易。一旦发现错误后，通常该错误只会局限于某一层，因为它与所有其高层的软件无关，而此层以下的各层软件，又都经过仔细的调试，bug修复较为容易。客户/服务器结构为了提高OS的灵活性和可扩充性而将OS划分为两部分。一部分是用于提供各种服务的一组服务器（进程），所有这些服务器（进程）都运行在用户态。当有一用户进程（现在称为客户进程）要求读文件的一个盘块时，该进程便向文件服务器（进程）发出一个请求；当服务器完成了该客户的请求后，便给该客户回送一个响应。另一部分是内核，用来处理客户和服务器之间的通信， 即由内核来接收客户的请求，再将该请求送至相应的服务器；同时它也接收服务器的应答， 并将此应答回送给请求客户。此外，在内核中还应具有其它一些机构，用于实现与硬件紧密相关的和一些较基本的功能。面向对象结构（20世纪80年代）该技术是基于“抽象”和“隐蔽”原则来控制大型软件的复杂度的。所谓对象，是指在现实世界中具有相同属性、服从相同规则的一系列事物的抽象，而把其中的具体事物称为对象的实例。OS中的各类实体如进程、线程、消息、存储器等，都使用了对象这一概念，相应地，便有进程对象、线程对象、 存储器对象等。由于隐蔽了表示实体的数据和操作，因而可以改变对象的表示而不会影响其它部分， 从而可以方便地改变老的对象和增加新的对象。继承性。继承性是面向对象技术所具有的重要特性。继承性是指子对象可以继承父对象的属性，这样，在创建一个新的对象时， 便可减少大量的时空开销。正确性和可靠性。由于对象是构成操作系统的基本单元，可以独立地对它进行测试，这样，比较易于保证其正确性和可靠性，从而比较容易保证整个系统的正确性和可靠性。微服务结构（20世纪90年代）能有效支持多处理机，适用于分布式系统环境。以微内核为操作系统核心，以客户/服务器为基础，采用了面向对象的程序设计方法。所谓微内核技术，是指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS（程序）不同， 它更小更精炼，它不仅运行在核心态，而且开机后常驻内存， 它不会因内存紧张而被换出内存。微内核并非是一个完整的OS， 而只是为构建通用OS提供一个重要基础。在微内核OS结构中，通常都采用了客户/服务器模式，因此OS的大部分功能和服务，都是由若干服务器来提供的， 如文件服务器、作业服务器和网络服务器等。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>课内学习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06.02-进程调度]]></title>
    <url>%2Fposts%2F58.html%2F</url>
    <content type="text"><![CDATA[进程概念前趋图数据结构中的有向无环图。箭头表示进程之间执行的先后关系。结点表示一个程序或一个进程，甚至一条语句。程序的并发执行不存在前趋关系的程序之间才有可能并发执行。特征：间断性：程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系，进而导致并发程序具有“执行-暂停-执行”这种间断性的活动规律。失去封闭性：由于资源共享，所以当某程序的运行影响资源的状态时，其他程序的运行环境就会被破坏。不可再现性：计算结果与并发程序各自执行速度有关。即同一程序，使用相同输入、在相同环境下运行，却可能获得完全不同的结果。进程的定义在多道程序环境下，程序的执行属于并发执行，此时他们将失去其封闭性，并具有间断性，以及运行结果的不可再现性。由此，决定了通常的程序是不能参与并发执行的。为了能使程序并发执行，引入了进程。进程实体：程序+数据+进程控制块（Process Control Block，PCB）。进程：运行态的进程实体是就是进程，是系统进行资源分配和调度的一个独立单位。PCB是为了使程序能并发执行而诞生的一种数据结构，它用来控制和管理进程。由于数据和程序本来就存在，所以创建/撤销进程也就是创建/撤销PCB。至于如何并发执行，见下面的进程同步。区别于作业：进程是程序在数据集上的一次作执行，作业是用户提交给系统的一个任务，包含一个或多个进程。进程的特点动态性：由创建而产生，由调度而执行，由撤销而消亡。并发性：进程的重要特征，操作系统的重要特征。独立性：独立运行、独立分配资源、独立接受调度。异步性：按各自独立、不可预知的速度向前推进。PCBPCB中保存的信息进程标识符。用于唯一的标识某个进程。外部标识符：不仅可以标识进程，还指明其父进程、子进程以及拥有该进程的用户。内部标识符：方便系统使用进程，仅能标识进程。处理机状态。用于在进程切换时保存处理机中各个寄存器的内容。以便在该进程重新调度时能再从断点执行。进程调度信息。进程状态：指明进程的状态，方便进程调度和对换时的依据。进程优先级：进程优先级高的更容易获得处理机。进程调度所需信息：保存的内容和进程调度算法有关，如进程等待了多久CPU，使用了多长CPU。事件：进程因何由执行状态转变为阻塞状态，即阻塞原因。进程控制信息。程序和数据的地址。进程同步的通信机制。资源清单。进程已分配到的除处理机之外的资源。链接指针。用于指向下一个PCB的首地址。用于进程调度。PCB的组织方式线性方式：所有的PCB都保存在一张表中，每次寻找PCB都在表中查找。效率低。链接方式：把具有相同状态的PCB链接起来。索引方式：把具有相同状态的PCB保存在相应的表中。OS内核系统态 &amp; 用户态对于处理机来说，根据其执行的指令不同，可以将其分成系统态（管态、内核态）和用户态。处理机处于系统态时可以执行任意的指令，访问所有的寄存器和存储区，而处于用户态的时候会受到相应的限制。所以计算机中的程序可以分成系统程序和用户程序，用户程序运行在用户态，这样就可以防止用户程序对操作系统进行破坏。指令分类操作系统把CPU指令分成两类：特权指令：在系统态执行的指令。执行几乎不受限制，如启动外部设备、设置系统时钟等。非特权指令：在用户态执行的指令。限制较多，比如不能操作硬件等。内核概念现代操作系统采用分层设计模式，不同权重的程序分别设置在不同的层次中。通常与硬件紧密相关的程序、设备驱动程序和运行频率高的程序等放置在高级别层次中，操作系统会将它们常驻内存，这些程序便被称为OS内核。OS内核运行在系统态中。内核的功能不同操作系统的内核在功能上有一定的差异，但是一般都包含两类功能：支撑功能中断处理：是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，且处理完毕后又返回原被暂停的程序继续运行。人机交互、设备驱动和进程调度等都需要依赖中断处理。时钟管理：系统中很多活动都需要用到时钟，如定时任务、时间片轮转调度算法等。原语操作：原语是若干条机器指令构成的，用以完成特定功能的一段程序。而原语操作便是原语的执行，其在执行期间是不可分割的。资源管理功能进程管理：进程的创建、撤销、调度等操作。存储器管理：空间的分配、撤销、逻辑地址转换为物理地址等。设备管理：进行设备分配、缓和CPU和I/O速度不匹配矛盾的缓冲管理等。进程的生命周期进程的创建为新进程申请内部标识符，同时从PCB集合中索取一个空白的PCB。为新进程分配其运行所需的资源。这些资源直接来自操作系统或者父进程。初始化PCB。如处理机状态信息、标识符和进程优先级等。若就绪队列还能接受进程，则插入就绪队列。不能接受则执行相应处理机制。进程的终止从PCB集合中获得某进程的PCB，并读出该进程的状态。若进程正处于执行状态，应立即终止该进程的执行。若此进程有子进程则一并终止，防止其成为不可控进程。将进程拥有的所有资源归还给其父进程或操作系统。将被终止的进程从所在队列或链表（指PCB的组织方式）中移出，等待其他程序收集信息，释放空间等。三种基本状态就绪状态：分配到出处理机之外的其他所有必要资源。此时可运行，但其他进程正在占用CPU。执行状态：就绪状态的进程获得CPU，正在执行的状态。阻塞状态：进程发出的请求没有及时得到满足而无法继续执行的状态，此时会引起进程调度，OS把处理机分配给其他就绪进程，原进程暂停。挂起进程暂停执行或不接受调度的状态。原因有如下几点：用户的需要：用户想暂停正在的进程，观察其状态或修改程序等。父进程请求：父进程为了完成某项任务，协调其各子进程间的活动。负荷调节的需要：系统压力过大或实时操作系统不能很好的满足可靠性时会挂起一些进程。操作系统的需要：操作系统挂起某些进程来更方便的检查系统资源。挂起和阻塞不同在于阻塞是客观条件不能得到满足，即资源不足引起暂停。挂起是主观需要引起暂停。进程同步进程同步的主要任务是使并发执行的诸进程之间能有效的共享资源和相互合作，从而使程序的执行具有可再现性。同步 &amp; 互斥并发执行的诸进程之间既有独立性又有制约性。独立性：各进程都可独立地向前推进；制约性：由于资源共享和进程合作引起的进程之间的相互依赖和相互制约的关系。可归结为互斥和同步。同步：两个或多个事件的发生有着某种时序上的关系。按照这种时序关系进行能保证各任务安全的完成。互斥：资源的使用要排它使用，防止冲突（不同时使用，但无先后次序。一种特殊同步）。临界资源 &amp; 临界区临界资源：需要被各进程互斥访问的资源。临界区：各进程中访问临界资源的代码。若能保证各进程互斥地进入自己的临界区，便可以保证互斥地访问临界资源，进而保证进程同步。常用的方式有硬件同步机制和信号量机制。同步准则空闲让进：当无进程处于临界区时，应当允许一个进程进入自己的临界区。忙则等待：当有进程处于临界区时其他请求就如临界区的进程必须等待。有限等待：对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区。让权等待：当进程不能进入临界区时，应立即释放处理机避免进程陷入“忙等”的状态。硬件同步机制关中断当进程在临界区执行期间，计算机系统不响应中断，因此不会引发调度，临界资源只会被一个进程占据，这样就不会发生进程同步问题。利用Test-and-Set指令实现互斥指令的描述如下：123456boolean TS(boolean *lock)&#123; boolean old; old = *lock; *lock = true; return old;&#125;为临界资源设置一个布尔变量lock = false。在进程进入临界区之前利用TS指令测试，如果得到的值为false表示资源未被使用，如果得到的值为true，则一直测试到结果为false。使用TS指令实现互斥描述如下：1234567do&#123; ... while (TS(&amp;lock)); ... lock = false; ...&#125;while(true);利用Swap指令实现互斥指令描述如下：123456void swap(boolean *a, boolean *b)&#123; boolean temp; temp = *a; *a = *b; *b = temp;&#125;为每个临界资源设置一个全局变量lock=false。每个进程设置一个局部变量key。实现互斥的描述如下：12345678910do&#123; ... key = true; do&#123; swap(&amp;lock, &amp;key); &#125;while(key != false) critical section; lock = false; ...&#125;缺点关中断：效率低下且不适用于多处理机系统。且其他进行会”忙等“，不符合让权等待。TS指令 &amp; Swap指令：其他进行会”忙等“，不符合让权等待。信号量机制整型信号量整型信号量是一个用于描述资源数目的整型量（S）。但除了初始化以外，仅能通过两个原子操作来访问。wait(S)：P操作1234wait(S)&#123; while(S &lt;= 0); S--;&#125;signal(S)：V操作123signal(S)&#123; S++;&#125;P操作用于分配资源，V操作用于释放资源。记录型信号量整型信号量未遵循让权等待原则。只要S &lt;= 0就会不断的循环。此时需要增加一个进程链表指针链接等待进程。数据结构的描述：1234typedef struct&#123; int value; // 资源数 struct process_control_block *list; // 阻塞队列&#125; semaphore;wait(S)：12345wait(semaphore *S)&#123; S-&gt;value--; if(S-&gt;value &lt; 0) block(S-&gt;list);&#125;signal(S)：12345signal(semaphore *S)&#123; S-&gt;value++; if(S-&gt;value &lt;= 0) wakeup(S-&gt;list);&#125;当进程被阻塞时会被加入阻塞对列，资源被满足时唤醒阻塞对列中的某个资源。AND型信号量记录型信号量只能解决共享一个临界资源的情况，若有多个临界资源则需要使用多个记录型信号量。但是信号量越多，系统死锁的概率越大，且大量的同步操作会给系统的管理带来麻烦。AND型信号量的思想是一次性分配进程所需的全部资源，如果有一个没有分配成功，则其他所有可能为之分配的资源亦不分配。Swait(S)：1234567891011Swait(S1, S2, ..., Sn) &#123; if(Si &gt;= 1 &amp;&amp; ... &amp;&amp; Sn &gt;= 1) &#123; for(i = 1; i &lt;= n; i++) Si--; break; &#125; else &#123; // 把进程阻塞在请求第一次未能得到满足的资源Si所对应的阻塞队列里，同时把进程的程序计数器 // （放置CPU下一条要执行的指令地址）放置在本操作的开始处（下一次再调度到此进程，需要再次 // 检查所有的资源）。 &#125;&#125;Ssignal(S)：123456Ssignal(S1, S2, ..., Sn) &#123; for(i = 1; i &lt;= n; i++) &#123; Si++; // 唤醒等待Si资源的阻塞队列。 &#125;&#125;信号量集之前的信号量都是一次申请或释放某资源一份，若申请或释放N份资源需要进行N次操作，效率比较低下。此外，当资源数量低于某一下限值时，为了系统安全，就不能再予以分配。所以产生信号量集解决以上问题。描述如下：12345678910111213Swait(S1, t1, d1, ..., Sn, tn, dn)&#123; if (S1 &gt;= t1 &amp;&amp; ... &amp;&amp; Sn &gt;= tn) for(i = 1; i &lt;= n; i++)&#123; Si -= di; &#125; else &#123; // 把进程阻塞在请求第一次未能得到满足的资源Si所对应的阻塞队列里，同时把进程的程序计数器 // （放置CPU下一条要执行的指令地址）放置在本操作的开始处（下一次再调度到此进程，需要再次 // 检查所有的资源）。 &#125;&#125;// 这里有个问题，就是 Si &gt; ti 之后，能保证Si &gt; di吗？我个人的理解是di和ti的资源量是动态的，比如di为4，// 原始ti为2，那程序在运行到Swait之前，si会被修改为6。123456Ssignal(S1, S2, ..., Sn) &#123; for(i = 1; i &lt;= n; i++) &#123; Si += di; // 唤醒等待Si资源的阻塞队列。 &#125;&#125;特殊的信号量集Swait(S1, d, d)：每次申请d份资源，资源少于d时不分配。Swait(S, 1, 1)：退化成一般的记录型信号量。Swait(S, 1, 0)：S &gt;= 1时运行多个进行进入特定区。S &lt;= 0时禁止进程进入特定区。管程直接使用信号量机制会把大量的同步操作分散在各个进程中，这会增加系统死锁的概率并且不方便系统的管理。而管程就是把代表共享资源的数据结构和对共享数据结构的操作（包括同步机制）封装起来以更好的为进程使用。这时所有请求访问共享资源的进程都只能通过管程间接访问，同时管程每次只允许一个进程进入管程。此时的管程可以使用面相对象的操作来完成整型信号量的功能。但是此时无法解决“让权等待”的问题，所以再按照面相对象的思想将block和wakeup操作封装起来来解决这个问题，即构成条件变量。条件变量的操作如下：condition.wait()：使进程在因某条件不能满足时阻塞在其所对应的条件变量上。condition.signal()：唤醒因某条件不能满足而阻塞的进程。可以很容易看出来，设置不同的条件变量能使由不同原因等待的进程阻塞在不同的队列中。使用时把signal()操作放在函数/过程的最后，这样保证在唤醒其他进程后本进程能直接退出而不再产生冲突。管程的描述如下：123456789101112131415161718/* 1、局部数据和条件变量组成管程内的数据结构。 2、过程/函数1~过程/函数k组成管程内的一组过程对管程内的数据结构进行操作。 3、初始化代码：对管程内的数据结构进行初始化。*/Monitor monitor_name&#123; share variable declartions; //共享变量说明 condition declarations; //条件变量说明 &#123; //管程主体 initialization code; //初始化代码 ... &#125; public: //能被进程调用的过程 void P1(...)&#123;...&#125; void P2(...)&#123;...&#125; ... void Pn(...)&#123;...&#125;&#125;信号量的应用互斥访问资源设某共享资源的信号量是mutex，PA和PB进程并发时需互斥访问。12345678910111213141516171819semaphore mutex = 1;PA()&#123; while(1)&#123; ... wait(mutex); ... signal(mutex); ... &#125;&#125;PB()&#123; while(1)&#123; ... wait(mutex); ... signal(mutex); ... &#125;&#125;利用信号量实现前趋关系123456789101112P1（）&#123;...V(f1);V(f1);V(f1);&#125;P2（）&#123;P(f1)；... V(f2);&#125;P3（）&#123;P(f1)；... V(f3);&#125;P4（）&#123;P(f1)；... V(f4);&#125;P5（）&#123;P(f2)；... V(f5);&#125;P6（）&#123;P(f3);P(f4);P(f5);...;&#125;main()&#123; semaphore f1=f2=f3=f4=f5=0； Cobegin P1(); P2();P3(); P4();P5(); P6(); Coend&#125;在并发时，如果P1的功能代码未执行完，f1为0，每次对f1进行V操作能使P2、P3、P4运行一个。其他亦然。生产者—消费者问题问题描述多个生产者进程生产产品以供多个消费者消费。通过由n个环形缓冲区构成的缓冲池（循环队列），把多个生产者和多个消费者联系起来。不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未取走的缓冲区中投放产品。分析任何时刻，只能有一个进程在缓冲区中操作。对于“生产者”而言，缓冲区满则应等待。对于“消费者”而言，缓冲区空则应等待。利用记录型信号量解决问题12345678910111213141516171819202122232425262728293031int in = 0, out = 0; // in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。item buffer[n]; // 缓存区大小为n，地址为[0, n-1]。semaphore mutex = 1, empty = n, full = 0; // mutex用于互斥访问缓存区void producer()&#123; do&#123; produce an item nextproducer; ... wait(empty); //消耗一个empty，当empty&lt;=0时等待 wait(mutex); buffer[in] = nextproducer; in = (in+1) % n; signal(mutex); signal(full); //增加一个full &#125;while(true);&#125;void consumer()&#123; do&#123; wait(full); //消耗一个full，当full&lt;=0时等待 wait(mutex); nextconsumer = buffer[out]; out = (out+1) % n; signal(mutex); signal(empty); //增加一个empty ... &#125;while(true);&#125;void main()&#123; ConcurrentBegin produce();consumer(); ConcurrentEnd;&#125;互斥信号量 &amp; 资源信号量互斥使用的资源设置一个互斥信号量，资源数为1。资源信号量的资源数和资源的意义有关。资源信号量的资源为1时退化成互斥信号量。在使用时互斥信号量的P操作需要紧邻其对应共享资源的临界区使用，否则可能造成同步问题。比如互换上面代码的第8行和第9行之后，若生产者进程和消费者进程都只有一个，且生产者通过了P(mutex)，阻塞在P(empty)，消费者通过了P(full)，阻塞在P(mutex)，此时生产者等待消费者的V(empty)，消费者等待生产者的V(mutex)，发生死锁。而V操作不需要注意顺序。利用AND型信号量解决问题123456789101112131415161718192021222324252627int in = 0, out = 0;//in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。item buffer[n];//缓存区大小为n，地址为[0, n-1]。semaphore mutex = 1, empty = n, full = 0; //mutex用于互斥访问缓存区void producer()&#123; do&#123; produce an item nextproducer; ... Swait(empty, mutex); //消耗一个empty，当empty&lt;=0时等待 buffer[in] = nextproducer; in = (in+1) % n; signal(empty, mutex); //增加一个full &#125;while(true);&#125;void consumer()&#123; do&#123; wait(full, mutex); //消耗一个full，当full&lt;=0时等待 nextconsumer = buffer[out]; out = (out+1) % n; signal(full, mutex); //增加一个empty ... &#125;while(true);&#125;void main()&#123; ConcurrentBegin produce();consumer(); ConcurrentEnd;&#125;利用管程解决问题12345678910111213141516171819202122232425262728293031323334353637383940414243Monitor monitor&#123; item buffer[n]; int in = 0, out = 0, count = 0; condition notfull, notempty; public: void static put(item x)&#123; if(count &gt;= n) cwait(notfull); //阻塞在队列满的条件下 buffer[in] = x; in = (in+1) % n; count++; csignal(notempty); &#125; void static get(item &amp;x)&#123; if(count &lt;= 0) cwait(notempty); //阻塞在队列空的条件下 x = buffer[out]; out = (out+1) % n; count--; csignal(notfull); &#125;&#125;void producer()&#123; item x; while(true)&#123; ... produce an item in nextproducer; monitor.put(x); &#125;&#125;void consumer()&#123; item x; while(true)&#123; monitor.get(x); consume the item in nextconsumer; ... &#125;&#125;void main()&#123; ConcurrentBegin produce();consumer(); ConcurrentEnd;&#125;哲学家进餐问题问题描述五个哲学家坐在圆桌前，每人一份饭，每个哲学家两侧各有一支筷子,只有拿到左右两只筷子才能进餐，哲学家处于吃饭和思考两种状态。分析同一时刻一只筷子只能有一个哲学家拿起。只有获得两个筷子后才能进餐。如果每个哲学家都拿起一只筷子，都饿死。并行程度：五只筷子允许两人同时进餐。利用AND型信号量解决问题每次必须拿到两只筷子才能拿起，否则不拿起筷子。12345678semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;do&#123; ... Swait(chopstick[i], chopstick[(i+1) % 5]); ... Ssignal(chopstick[i], chopstick[(i+1) % 5]); ...&#125;读者-写者问题问题描述写者向共享数据区放数据，读者从共享数据区读数据。多个读者可同时读取数据，多个写者不能同时写数据。分析读者进入共享数据区，写者必须等待。读者进入共享数据区，读者可以进入。写者进入共享数据区，读者必须等待。利用记录型信号量解决问题1234567891011121314151617181920212223242526272829semaphore readmutex = 1, writemutex = 1;int readcount = 0;void reader()&#123; do&#123; wait(readmutex); if(readcount == 0) wait(writemutex); readcount++; signal(readmutex); ... //read opreation wait(readmutex); readcount--; if(readcount == 0) signal(writemutex); signal(readmutex); &#125;while(true);&#125;void writer()&#123; do&#123; wait(writemutex); //当写者进入共享数据区，reader会阻塞在 ... //write operation signal(writemutex); &#125;while(true);&#125;void main()&#123; ConcurrentBegin reader();writer(); ConcurrentEnd;&#125;代码分析最开始并发的时候：假如读者先抢到资源，readcount == 0，P(writemutex)，writer()会阻塞在第20行，但其他reader()仍可以运行，只是不会再P(writemutex)。同时每个reader()都readcount++，直到readcount == 0时V(writemutex)，然后writer()才有可能能进入。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。假如写者先抢到资源，P(writemutex)，此时readcount == 0，所有reader()阻塞在第7行。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。综上，完成了要求。读者-写者问题拓展问题描述拓展就是又增加一个条件，最多只允许RN个读者同时读。利用信号量集解决问题123456789101112131415161718192021semaphore L = RN, mx = 1; //L用来控制访问数，mx控制写者访问时所有读者阻塞void reader()&#123; do&#123; Swait(L, 1, 1); //第RN+1个读者进入时会阻塞 Swait(mx, 1, 0);//mx &gt;= 1时才可以进入 ... //read operation Ssignal(L, 1); &#125;while(true);&#125;void writer()&#123; do&#123; Swait(mx, 1, 1; L, RN, 0); //mx &gt;= 1 &amp;&amp; L &gt;= RN时进入 ... //write operation Ssignal(mx, 1); &#125;while(true);&#125;void main()&#123; ConcurrentBegin reader();writer(); ConcurrentEnd;&#125;代码分析最开始并发的时候：假如读者先抢到资源，L = L - 1，写者阻塞在第12行，但其他reader()仍可以运行，直至没有读者进程在访问共享数据区。当所有的读者进程都退出时，共享数据区中停留的个进程数都为0，即重新开始。假如写者先抢到资源，mx = mx - 1，所有读者进程和其他写者进程都要被阻塞，写者进程退出时，共享数据区中停留的个进程数都为0，即重新开始。理发师问题问题描述一把理发椅，N把等待座位。理发师为理发椅上的顾客理发，没有顾客就在理发椅上睡觉，有一个顾客时需要叫醒理发师，多个顾客时需要在等待座位上等候。分析理发椅上只能有一位顾客。等待座位是有限缓冲区。只要存在顾客，理发师就不能睡觉。利用记录型信号量解决问题123456789101112131415161718192021222324semaphore customer = 0, barber = 0, mutex = 1; //barber使理发师只能为一个顾客服务int waiting = 0;void barber()&#123; while(true)&#123; wait(customer); //没有顾客的时候理发师睡觉 wait(mutex); waiting –= 1; //等待的人少一个 signal(mutex); signal(barber); ...//获得被激活进程的信息并给相应的顾客剪发 &#125;&#125;void customer()&#123; wait(mutex); if(waiting &lt; CHAIRS)&#123; //顾客到来的时候，还有座位就进去等待 waiting += 1; signal(mutex); signal(customer); wait(barber); ... //将被激活进程的信息发送给barber() &#125;else&#123; signal(mutex); &#125;&#125;代码分析在最开始并发的时候barber()会等待到有顾客时才醒来。顾客一来就需要访问waiting，所以获得mutex。如果位置不够就立即释放mutex。如果位置够，就让等待的人加1，再释放mutex。然后顾客人数customer += 1来激活理发师进程。理发师进程激活后会V(barber)，然后等待着的customer()进程争夺资源，争夺到P(barber)的进程将被激活进程的信息发送给barber()，barber()获得被激活进程的信息并给相应的顾客剪发。进程通信概念进程之间合作完成工作不仅仅需要有时序关系，还需要进程信息交互，比如刚才的理发师问题中就设计到了信息交互。从概念上说进程通信是指进程之间的信息交换，所以信号量机制本身就涉及到了信息交换，不过我们把这种信息交换叫做低级进程通信，因为其效率低且需要用户大量的干预。真正的进程通信需要满足使用方便且能高效传输大量数据的需求。共享存储器系统基于共享数据结构的通信方式：诸进程公用某些数据结构来实现进行通信 ，如生产者—消费者问题中的有界缓冲区，属于低级通信方式。基于共享存储区的通信方式：在存储器中划出一块共享存储区，诸进程通过对共享存储区中数据的读或写实现通信，此时数据的形式、位置和访问控制仍是进程实现。适用于传输大量数据，属于高级通信。管道通信系统所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件。向管道提供输入的发送进程（即写进程）以字符流形式将大量的数据送入管道，而接收进程（即读进程），可从管道中接收数据。管道通信系统必须满足以下三个要求：互斥：管道的使用必须互斥。因为存数据和取数据可归于写文件的添加和删除。同步：写进程把一定数量的数据写入管道后去睡眠，读进程读完后将其唤醒。读进程读空的管道时需要睡眠。确定对方存在：如果写进程不存在，读进程就会一直等待。如果读进程不存在，写进程写完数据后也会一直等待，所以通信双方必须同时存在。消息传递系统指进程可以利用一组通信命令（原语）把数据封装在消息中传送，不需要显示的指定共享存储区或数据结构等。它隐藏了通信的细节，也是目前使用最广泛的进程间通信机制。通常有两种实现方式：直接通信方式：OS提供原语给进程使用。间接通信方式：借助共享中间实体（称为邮箱）完成进程间的通信。和共享存储器系统的区别是进程不再需要指定数据的形式、位置和访问控制等，信箱内部自有实现。客户机-服务器系统前三种都是单机下的通信机制，这种是网络环境中的通信机制。主要有套接字和RPC两种方式。套接字：一个套接字是一个通信标识类型的数据结构，包含了通信目的地址、通信端口号、通信的网络协议、进程自身的地址以及对外提供的系统调用等。使用套接字可以在不同主机上的进程建立连接进而进行通信。RPC：Remote Procedure Call，它是一个通信协议，可以使本地进程调用其他主机的进程对程序员表现为常规方法调用。线程线程的由来进程解决了程序不能并发执行的问题，但是由于进程是拥有资源的基本单位，所以在创建、撤销和切换时所需的时空开销很大，因为处理机势必要付出更大的代价来保存现场。所以把拥有资源和独立运行两项功能分开，让线程作为独立运行的基本单位，进程作为拥有资源的基本单位。不过线程也拥有一些能保证其独立运行的资源，如TCB。TCB（Thread Control Block）所有用于控制和管理线程的信息都会被记录在线程控制块中，通常包含：线程标识符：每个线程都有唯一的线程标识符。处理机信息：包括程序计数器、状态寄存器、通用寄存器的内容。线程运行状态：线程和进程一样也有多种运行状态，就绪、阻塞、运行等。详见103-网络编程。优先级：和调度算法有关，优先级越高，得到处理机的机会越大。线程专有存储区：用于在线程切换时保存现场状态和保存线程的统计信息。信号屏蔽：屏蔽某些发送给线程的信号。堆栈指针：线程调用别的过程时需要保存局部变量和返回地址等来供返回时能继续执行。线程的实现线程是为了解决进程调度时过于笨重的问题，所以在不同的环境中实现线程的方式不同。根据内核能否感知到线程的存在可分为内核支持线程（Kernel Supported Threads，KST）和用户级线程（User Level Threads，ULT）。它俩的区别是能否直接调用系统服务，前者可以而后者需要借助中间系统。内核支持线程若线程是由内核直接调度，线程资源也是保存在内核空间，就可以说此类线程为内核支持线程。此类线程的创建、撤销和切换等操作都是在内核空间完成的，此时线程可以直接调用系统服务。一种可能的实现方式是在创建进程时分配一个任务数据区（Per Task Data Area，PTDA），各个线程的TCB保存在其中即可。不过仅实现内核支持线程的系统对用户进程创建的线程很不友好，每次线程调度处理机都要从用户态转换到核心态。用户级线程用户级线程是指线程虽客观存在但对内核来说是透明的，此时不能再直接调用系统服务，间接调用系统服务需要有中间系统的支持，通常的中间系统有运行时系统和内核控制线程。运行时系统：把创建线程、撤销线程和线程同步等只能由OS内核完成的操作封装起来作为运行时系统，而运行时系统停留在用户空间供其他进程调用来实现线程调度。内核控制线程：这种线程又被称作轻量进程（Light Weight Process，LWP），它既可以共享进程的资源，又可以使用内核提供的服务。虽然下图中LWP和用户线程是1对1关系，但实际上多个用户级线程可以复用一个LWP，但每个轻型线程都要连接到一个内核线程中。所以此种方式系统需要同时实现内核支持线程。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>课内学习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06.03-处理机调度]]></title>
    <url>%2Fposts%2F21854.html%2F</url>
    <content type="text"><![CDATA[概述处理机调度是指通过对处理机资源进程的合理分配来提升系统资源的利用率、降低作业周转时间等。但是由于不同操作系统的目标不同，所以处理机调度的策略和目标也不相同。处理机调度的层次高级调度：又称作业调度或长程调度。它的主要功能是根据某种算法决定把外存上处于后备队列中的哪些作业调入内存，并为他们创建进程、分配资源等，然后放入就绪进程队列。主要用于批处理系统，分时系统的实时系统中不设置高级调度。低级调度：又称进程调度或断层调度。它的主要功能是根据某种算法决定让哪些就绪队列获得处理机，并由分配程序将处理机分配给被选中的进程。在批处理系统、实时系统和分时系统中都设置低级调度。中级调度：又称内存调度。它的主要功能是根据某种算法决定将哪些暂时不能运行的进程调至外存等待，当它们具备运行条件且内存又有空闲时再调入内存。这实际上是存储器管理中的对换功能，在下一章再展开介绍，处理机调度的目标共同目标提升资源利用率：$ CPU的利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}$。公平：每个进程都应获得合理的CPU时间，不发生进程饥饿现象。平衡：进程可以分成多个类型，如计算型、I/O型等等。平衡是指系统中不同的设备都能处于忙碌状态。策略强制执行：指某些强制型任务，比如安全策略等，即使会造成其他工作的延迟。批处理系统的目标平均周转时间短：周转时间：从作业进入系统到作业完成退出系统所用的时间。平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$ T=\frac{1}{n}[\sum_{i=1}^NT_i]$带权周转时间：作业的周转时间（$ T$）和系统为它提供服务的时间（$T_S$）。$W=\frac{T}{T_s}$平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$ T=\frac{1}{n}[\sum_{i=1}^NW_i]$系统吞吐量高：单位时间内系统完成的作业数尽量多。处理机利用率高。分时系统的目标响应时间快：指终端提交一个请求到主机返回结果至终端的时间短。均衡：不同请求的复杂度不同，所以响应时间必定不同，均衡是指响应时间应和请求复杂度相适应。实时系统的目标截止时间的保证：对于HRT任务截止时间必须满足要求，SRT也要尽可能满足。可预测性：如在观看电影时一般都会连续播放帧，所以请求是可预测的，假如采用双缓冲实现第i帧和第i+1帧并行处理就能提高实时性。高级调度作业作业：比程序更为广泛的概念，不仅包含了通常的程序和数据，还有一份作业说明书。在批处理系统中，是以作业为基本单位从外存调入内存的。作业步：在作业运行期间，每个作业都必须经过若干个相对独立。又相互关联的顺序加工步骤才能得到结果。期中每一个加工步骤成为一个作业步。作业控制块Job Control Block，JCB。是作业在系统中存在的标志。保存了系统对作业进行管理和调度所需的全部信息。如：作业标识、用户名称、用户账号、作业类型（CPU繁忙型、I/O繁忙型、批量型、终端型等）、作业状态、调度信息（优先级、作业运行时间）、资源需求（预计运行时间、要求内存大小等）、已申请到资源的使用情况。作业运行的三个阶段收容阶段：每一个作业进入系统时（即输入到硬盘），便由“作业注册”程序为该作业建立一个作业控制块JCB并把它放入作业后备队列中。运行阶段：后备队列中的作业被选中后，系统会为其分配必要的资源和建立进程，然后将其放入就绪队列。一个作业从第一次进入就绪状态开始到它运行结束前都是处于运行阶段。完成阶段：当作业完成或发生异常而终止时，作业便处于完成阶段，此时系统会撤销进程和资源，并将运行结果通过某种方式输入，如输出到文件中。先来先服务算法First-Come First-served，FCFS。每次调度都是选择一个或多个最先进入队列的作业或进程，为它们分配资源，创建进程和分配CPU，使之投入运行。它是最简单的调度算法，同时也可用于进程调度。效率不高，所以一般不作为主调度算法。适用于CPU繁忙型而不适用于I/O繁忙型。因为CPU繁忙型长时间占用CPU很少有I/O操作，一旦获得CPU，就会运行很长时间，就是会长时间占用CPU，而I/O繁忙型由于要频繁访问IO端口，每次访问都要放弃CPU，等I/O访问完后要重新等待下一次调度（此时排到了就绪队列的队尾），所以要等待很久才能重新被调度。因此先来先服务有利于CPU繁忙型而不利于I/O繁忙型。短作业优先算法Short Job First，SJF。指对短作业优先调度的算法，它从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。此种算法对长作业非常不利而且实际使用上很难预估每个作业的运行时间。静态优先级调度算法为照顾紧迫性作业，使之进入系统后获得优先处理，引入优先级调度算法。按照进程的优先级大小来调度，使高优先级进程得到优先处理的策略称为优先权调度算法。静态优先级调度算法是指在输入前作业为其赋予优先级且一直保持不变。虽然可以照顾紧迫性作业，但是没有考虑到作业本身的运行时间和作业的等待时间等，所以产生了更好的动态优先级算法。高响应比算法高响应比算法是动态优先级算法的一种，其中$ 优先级 = \frac{响应时间}{要求服务时间} = \frac{等待时间+要求服务时间}{要求服务时间}$。这样可以得到：对于短作业：其要求服务时间短，优先级相对较高。对于长作业：在等待一段时间之后，其优先级会增长，直至够高而能获得服务。对于先来作业：假如在某一时刻其仍未获得服务，和后来的作业相比其优先级相对较高。相应时间与周转时间的对比，假如作业运行完了，两者相等，假如没有则 $响应时间&lt;周转时间$周转时间：从作业进入系统到作业完成退出系统所用的时间。响应时间：等待时间+要求服务时间。低级调度进程调度的任务保存处理机的现场信息：比如程序计数器、通用寄存器里的内容。按某种算法选取进程。把处理机分配给进程：把选中进程的PCB中的有关处理机调度的信息装入处理器的寄存器中，把处理器的控制权交给进程使其能从上次的断点处恢复运行。进程调度机制排队器：每当有进程转入就绪状态时，排队器会将它插入到相应的就绪队列。分派器：分派器依据进程调度程序（更直接的说，进程调度算法）所选定的进程，将其从就绪队列中取出。上下文切换器：会产生两次上下文切换：旧进程和分配程序之间的切换；分配程序和新进程之间的切换。排队器、分派器、上下文切换器本身也是程序，但是它们是处于系统态的程序，而被调度的进程一般是用户态的程序，从系统态到用户态进行上下文切换需要很大的耗费，所以一般采用两组（或多组）寄存器，一组用于处理机在系统态时使用，一组用于系统在用户态时使用，这样在系统态和用户态之间切换时就可以只改变指针（用于从寄存器中存取数据和指令）使其指向指定寄存器就行。进程调度方式非抢占方式一旦某进程获得处理机，就会一直运行下去，直至该进程完成或者因发生某种事件而被阻塞其他进程才能获得处理机。此时引起进程调度的因素：正在执行的进程运行完毕。外部环境的改变使其不能再继续运行，如程序运行发生异常。进程通信或进程同步时执行了某种原语，如Block。正在执行的进程发出I/O请求。抢占方式允许调度程序根据某种原则去暂停某个正在执行的进程，将处理机分配给其他进程。这些原则一般有三种：高优先级原则短进程优先原则时间片原则我们后面所提到的进程调度算法其实都是抢占方式下的策略。轮转调度算法将CPU的处理时间分成固定大小的时间片q， q的大小从几ms到几百ms。系统将所有就绪进程按先来先服务的原则排成队列。每次调度时，把CPU分配给队首进程，令其执行一个时间片，时间片用完后若进程未结束，则送回就需队列尾部重新调度，在一给定的时间内，就绪进程均能获得一时间片的执行时间。此时时间片大小是关键问题，一般来说时间片q正比于响应时间，反比于就绪进程数目。计算机的处理能力。速度快，q可小些。通常q值是这样决定的：批处理系统:80%的CPU周期在一个时间片内完成分时系统：$ q=T/N_{max}$，（$T-响应时间上限，N_{max}-最大进程数$）优先级调度算法抢占式/非抢占式非抢占式优先级调度算法即一旦某个高优先级的进程占有了处理机，就一直运行下去，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件）才让另一高优先级进程运行。主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。抢占式优先级调度算法任何时刻都严格按照高优先级进程在处理机上运行的原则进行进程的调度。常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。静态/动态优先权静态优先权静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，这些整数被称为优先数。确定优先权大小的依据：进程类型；进程对资源的需求；用户要求。动态优先权动态优先权是指，在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。例如，我们可以规定，在就绪队列中的进程，随其等待时间的增长，其优先权以速率a提高。若所有的进程都具有相同的优先权初值，则显然是最先进入就绪队列的进程，将因其动态优先权变得最高而优先获得处理机，此即FCFS算法。若所有的就绪进程具有各不相同的优先权初值，那么，对于优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机。当采用抢占式优先权调度算法时，如果再规定当前进程的优先权以速率b下降，则可防止一个长作业长期地垄断处理机。多队列调度算法之前介绍的调度算法都是用一个算法来解决所有的进程调度，这样无法满足系统中不同用户对进程调度策略的不同要求。而多队列调度算法就是将就绪队列从一个分成多个，将不同性质或类型的进程放在不同的就绪队列，这样不同的队列之间设置优先级，和队列内部也可以设置优先级，能更好的满足用户的需求。同时在多处理机系统中，可以方便的给每个处理机设置单独的就绪队列。多级反馈队列调度算法设置多个就绪队列，每个队列赋予不同的优先级，一个队列的优先级最高，第二个队列次之，其余各队列的优先级逐个降低，各队列内部使用FCFS原则排列。优先级越高的进程时间片越短。当一个进程进入内存后，首先放在第一队列的尾部，按FCFS的原则调度，如果该时间片内未结束，进程调度时将此进程转入第二队列队尾，直至第N个对列，若进程仍未结束，在第N个对列上采用时间片轮转算法。仅当第i队列空闲时才调度第i+1队列，如果有新进程进入优先级较高的队列，剥夺CPU执行新进程，旧进程放入原队列尾部。此算法不必事先知道各进程执行的所需时间，可满足各种进程需要，是目前公认较好的进程调度算法。举例第i个对列的时间片为$ 2^{i-1}$。基于公平原则的调度算法保证调度算法保证每个进程都获得相同的处理机时间：跟踪计算每个进程自创建以来已经执行的时间。计算每个进程应该获得的处理机时间，即自创建以来的时间除以n。比较各进程获得处理机时间的比率，即实际执行时间除以应获得的处理机时间。比较各进程获得处理机时间的比率，如A：0.5；B：0.9；C：1.2。调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率，然后把处理机让给此时比率最小的进程。公平调度算法在上个算法中，如果用户A有4个进程，用户B有1各进程，那用户A获得处理机的时间是用户B的四倍。而公平调度算法的目标是保证每个用户都获得相同的处理机时间。实时调度实时调度必须能满足实时任务对截止时间的要求。所以实时任务的算法和优先级算法有些区别。实时算法的分类非抢占式调度算法非抢占式轮转调度算法非抢占式优先调度算法抢占式调度算法基于时钟中断的抢占式优先级调度算法：在某实时任务到达后，如果它的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断发生时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先级任务。立即抢占式优先级调度算法：一旦出现外部中断，只要当前任务未处于临界区，便立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。最早截止时间优先算法Earliest Deadline First，EDF。可用于非抢占式算法，也可用于抢占式算法。非抢占式抢占式有两个周期任务，A、B的周期分别是20ms，50ms。A、B的执行时间分别是10ms和25ms。最低松弛度优先即算法Least Laxity First，LLF。$ 松弛度=截止时间-当前时间-任务执行时间$。主要用于抢占式调度。例有两个周期任务，A、B的周期分别是20ms，50ms。A、B的执行时间分别是10ms和25ms。优先级倒置即高优先级进程（或线程）被低优先级（或线程）延迟或阻塞。例，假如有三个完全独立的进程P1、P2和P3，优先级P1&gt;P2&gt;P3。P1和P3通过共享一个临界资源进行交互。123P1：...P(mutex); CS-1; V(mutex);... P2: ...Program2...;P3：...P(mutex); CS-3; V(mutex);...假如P3最先执行，在执行了P(mutex)操作后，进入临界区CS-3。在时刻a，P2就绪，因为它比P3的优先级高，P2抢占了P3的处理机而运行，在时刻b，P1就绪，因为它比P2的优先级高，抢占处理机执行，但P1执行P(mutex)之后被阻塞，处理机被P2获得，P2执行结束后，P1仍不能进入临界区，处理机被P3获得，等P3退出临界区，P1才能获得处理机。所以本应该高优先级的P1优先执行，但是由于存在临界资源而导致优先级倒置。优先级倒置的解决遵循动态优先级继承原则：当高优先级进程P1要进入临界区去使用临界资源，如果已经有一个低优先级进程P3正在使用该资源，此时一方面P1被阻塞，一方面P3继承P1的优先级并一直保持到P3退出临界区。这样做就能保证不会有比P3优先级高但比P1优先级低的进程插进来。死锁资源分类可重用资源和消耗性资源可重用性资源：可供用户重复使用多次的资源。特点：互斥访问系统中此资源数目相对固定系统中大多数资源属于此类可消耗性资源：临时性资源由进程动态创建和消耗，数目是可以不断变化的，比如信号量、进程通信的信息等。可抢占性资源和不可抢占性资源可抢占性资源：CPU和主存，不会引起死锁。不可抢占性资源：只能进程自行释放。如打印机，因为如果打印到一半，打印机被抢占，造成的结果只能是此次打印作废，所以它是不可抢占资源。死锁定义如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。死锁的起因竞争不可抢占性资源引起死锁一个资源只能同时被一个进程使用，但是下图P1在获得R1后还去申请R2，同时P2获得R2后还去申请R1，陷入僵局，引发死锁。竞争可消耗性资源引起死锁123P1：receive(p3,m3)； send(p2,m1)；P2：receive(p1,m1)； send(p3,m2)；P3：receive(p2,m2)； send(p1,m3)；如上代码，P1在等待P3给P1发消息，P2在等待P1给它P2发消息，P3在等待P2给P3发消息。造成一个死循环。进程推进顺序非法在下图中，X轴表示进程P1推进图，Y轴表示进程P2推进图。如果按照4号路线推进，可以看出P1在经过b、d段的执行之后，获得R1，P2在进过a、c、e段的执行之后获得R2。此时如果不加以处理，系统一定会进入死锁状态，因为接下来P1在拥有R1后又去申请R2，P2在拥有R2后又去申请R1。死锁产生的必要条件互斥条件：某段时间内，某资源只能由一个进程使用；请求和保持条件：进程因请求资源而阻塞时，对已分配给它的资源保持不放；不可抢占条件 ：资源在未使用完前，不能被剥夺，由使用进程释放；循环等待条件 ：发生死锁时，有向图必构成一环路。死锁处理共有三类做法：第一类是预防死锁，也就是破坏死锁产生的条件（破坏其中一个就可以），这样系统就永远不会产生死锁。第二类是死锁避免，死锁产生的根本原因是系统资源分配出现问题，如果能进行合理的资源分配就能避免死锁的发生。第三类是死锁发生后的检测和解除。预防死锁预防死锁是给系统施加一个条件使其永远不可能满足死锁产生的必要条件，但是互斥条件是不能被破坏的条件，所以预防死锁有三类做法：破坏“请求和保持”条件即进程在请求资源时，它不能持有不可抢占资源。有两种做法：所有进程在开始运行之前，一次性的申请其在整个运行过程中的全部资源，如果申请成功，进程便陷入等待。这样进程在运行的时候就不会再发出请求。进程在只获得运行初期所需的资源后便开始运行，但是进程在运行过程中需要逐步释放以分配给自己的资源，等初期获得所有资源都被释放后才能请求其他资源。破坏“不可抢占”条件当进程保持了某些不可被抢占资源，且提出的新需求又不能被满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这种预防策略的代价非常昂贵，比如进程请求的打印机被强制剥夺后，之前的工作等于作废。破坏“循环等待”条件常见的方法是“资源有序分配”。其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号升序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程，在拥有大编号资源再申请小编号资源时需要释放和小资源编号相等及以上的编号。避免死锁避免死锁讲道理是属于死锁的预防，但是它和预防死锁不同，预防死锁是破坏死锁产生的条件，避免死锁是防止系统进入不安全状态。所以我们就要明白什么是安全状态，它和死锁产生的必要条件有什么区别。安全状态安全状态指的是系统能按某种进程推进顺序(P1, P2, …, Pn)为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。此时，序列(P1, P2, …, Pn)为安全序列。如果系统无法找到这样一个序列，则称系统处于不安全状态。为什么能找到这样的序列系统就是安全的呢？其实它是一个递推的关系，假如系统在时刻i发起申请资源请求，其此时状态为a，系统会判断它申请成功后是否还能寻找到一个安全序列，如果能找到便可以分配，否则便是系统不安全状态。假如系统申请到了资源，还想发出申请请求，便会再次判断请求成功之后能否找到安全序列，由此递推下去可保证整个系统能避免死锁。安全状态和死锁必要条件的区别仍以此图为例。假如我们采用的是预防死锁策略中的破坏“请求和保持”条件里的第一个做法，那么推进顺序就不可能为4，因为进程P1在执行的时候需要获取全部资源才能执行。但对于避免死锁来说，系统可以按照4号推进顺序推进到e段和阴影区的交界处，然后进程P2在申请资源R2的时候会去判断分配R2给P2之后系统能否找到安全序列，事实上是找不到的，所以R2便不会分配给P2，这样系统就进入不了阴影区，从而可以避免死锁。所以预防死锁和避免死锁的区别是：预防死锁是每个进程在执行之前确保其自身不陷入死锁状态，如果每个进程都能不陷入死锁状态，系统便能永远安全。即从单个进程角度静态解决问题。但避免死锁是在每一次进行资源分配时判断分配之后是否系统处于安全状态，如果处于安全状态便可分配，否则便不能分配。即从系统整体角度动态解决问题。银行家算法数据结构可利用资源向量$Available$：是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果$Available[j]=K$，则表示系统中现有$R_j$类资源K个。最大需求矩阵$Max$：这是一个$n×m$的矩阵，它定义了系统中$n$个进程中的每一个进程对$m$类资源的最大需求。如果$Max[i, j]=K$，则表示进程$i$需要$R_j$类资源的最大数目为K。分配矩阵$Allocation$：这也是一个$n×m$的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果$Allocation[i,j]=K$，则表示进程i当前已分得$R_j$类资源的 数目为K。需求矩阵$Need$：这也是一个$n×m$的矩阵，用以表示每一个进程尚需的各类资源数。如果$Need[i,j]=K$，则表示进程$i$还需要$R_j$类资源K个，方能完成其任务。可得：$Need[i,j]=Max[i,j]-Allocation[i,j]$算法设进程$cusneed$提出请求$REQUEST[i]$，则银行家算法按如下规则进行判断。如果$REQUEST[cusneed] [i]&lt;= Need[cusneed][i]$，则转2；否则，出错。如果$REQUEST [cusneed] [i]&lt;= Available[i]$，则转3；否则，等待。系统试探分配资源，修改相关数据：$Available[i]-=REQUEST[cusneed][i]$;$Allocation[cusneed][i]+=REQUEST[cusneed][i]$;$Need[cusneed][i]-=REQUEST[cusneed][i]$;系统执行安全性检查算法，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。安全性算法设置两个工作向量$Work=Available$、$Finish=false$。从进程集合中找到一个满足下述条件的进程$i$，$Finish[i]==false;$$Need[i, j]&lt;=Work[j];$，如找到，执行3；否则，执行4。设进程获得资源，可顺利执行，直至完成，从而释放资源。$Work[i]=Work[i]+Allocation[i,j];$，$Finish[i]=true;$，循环2。如所有的进程$Finish= true$，则表示安全；否则系统不安全。举例假定系统中有五个进程$\lbrace P0, P1, P2, P3, P4\rbrace$和三类资源$\lbrace A,B, C\rbrace$，各种资源的数量分别为10、5、7，在$T0$时刻的资源分配情况如图所示。$T0$时刻的安全性$P1$请求资源：$P1$发出请求向量$Request1(1,0,2)$，系统按银行家算法进行检查。$Request_1(1, 0, 2)≤Need_1(1, 2, 2)$$Request_1(1, 0, 2)≤Available_1(3, 3, 2)$系统先假定可为$P1$分配资源，并修改$Available,Allocation_1和Need_1$向量。由此得到的资源变换情况如上上图括号所示。再利用安全性算法检查此时系统是否安全。$P4$请求资源：$P4$发出请求向量$Request_4(3,3,0)$，系统按银行家算法进行检查。$Request_4(3, 3, 0)≤Need_4(4, 3, 1);$。$Request_4(3, 3, 0)&gt;Available(2, 3, 0)$，让$P4$等待。$P0$请求资源：$P0$发出请求向量$Requst_0(0,2,0)$，系统按银行家算法进行检查。$Request_0(0, 2, 0)≤Need_0(7, 4, 3);$$Request_0(0, 2, 0)≤Available(2, 3, 0);$系统暂时先假定可为$P0$分配资源，并修改有关数据，如下图所示。进行安全性检查：此时可用资源$Available(2,1,0)$已经不能满足任何进程的需要，进入不安全状态，因此系统不分配资源。死锁的检测和解除死锁的检测在图中找一既非阻塞又非独立的进程节点$P_i$，如顺利，$P_i$可获得所有资源直至运行完毕。消去$P_i$所有的请求边和分配边，即释放占有的所有资源，同理再选下一进程节点$P_{i+1}, …, $若能消去所有的边，那么该图是可完全简化的，否则该图是不可完全简化的。具体做法如下：可利用资源向量$Available[]$，它表示了m类资源中每一类资源的可用数目。把不占用资源的进程（向量$Allocation[i]∶= 0$）记入L表中，即$L_i \bigcup L$。从进程集合中找到一个$Request_i≤Work$的进程，做如下处理：将其资源分配图简化，释放出资源，增加工作向量$Work∶ =Work+Allocation_i$。将它记入L表中。若不能把所有进程都记入L表中， 便表明系统状态S的资源分配图是不可完全简化的。 因此，该系统状态将发生死锁。死锁的解除死锁解除有多种做法，如下是按代价递减排序的几种。撤销所有死锁的进程。将每个进程回退到先前定义的某个检查点，再重新启动所有进程。逐个撤销死锁进程，直至死锁不存在。撤销进程的顺序应是基于某种最小代价原则，每次撤销后，死锁检测算法应该重新检测死锁是否依然存在。剥夺进程P的资源交给进程Q，P同时会退到获得此资源的节点上。对于3和4，选择的标准可以如下：以占用处理器的时间最小；以产生的输出少；所估计的剩余运行时间最长；所占用的资源最少；优先权最低。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>课内学习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06.05-输入输出系统]]></title>
    <url>%2Fposts%2F3774.html%2F</url>
    <content type="text"><![CDATA[概述输入输出系统和OS中的其他部分有很大区别，因为其他部分都是在说计算机接受任务后该怎么运行能又快又可靠的完成任务并把结果输出。而输入输出系统是怎么快速稳定的将任务的需求输入和任务的结果输出。又由于输入输出设备种类繁多，比如输入设备中的键盘、鼠标、网卡、摄像头，输出设备中的打印机、音频等。所以输入输出系统被划分很多层次来尽可能屏蔽物理细节。IO系统的基本功能隐藏物理设备的细节：只需要使用简单的命令就能操作各种具有不同实现的硬件完成相应需求。与设备的无关性：用户不需要指定哪些设备完成功能，只需要描述需求，OS会选择一个设备完成功能。提高处理机和IO设备的利用率：IO设备之间一般是相互独立的，因此设备之间能够并行操作，所以OS应让处理机和设备之间能并行操作。对IO设备进行控制：轮询的可编程IO方式。采用中断你的可编程IO方式。直接存储器访问方式。IO通道方式。确保对设备的正确共享。错误处理。IO软件的层次结构用户层软件：提供设备与用户交互的接口，用户可以使用该层提供的功能直接控制设备。设备独立性软件：设备分配，设备保护，设备分配，设备回收，数据缓存等。设备驱动软件：发出控制设备的命令。中断处理程序：保存被中断的进程的CPU环境，转入相应的中断处理程序仅需处理，处理完毕后再恢复被中断进程的现场，返回到被中断的进程。IO系统各模块层次视图块设备：输入输出以数据块为单位的设备。如磁盘。流设备：字符设备的输入输出，如键盘。网络通信接口：网卡。IO设备和设备控制器直接和IO设备对接的是设备控制器。作用接收和识别命令（控制寄存器、命令译码器）：设备控制器将CPU送来的命令写入控制器寄存器中，并进行译码。数据交换（数据寄存器）。设备状态的了解和报告（状态寄存器）。地址识别（地址译码器）：系统中的每个设备都有自己的地址段，设备接口电路中有多个寄存器，一个寄存器有唯一的一个地址，每个地址为I/O端口，该地址称为I/O端口地址。设备控制器必须能识别每个设备的地址。数据缓冲：缓冲器。差错控制：差错检测码。组成设备控制器和处理机的接口：用于实现CPU与设备控制器之间的通信。设备控制器和设备的接口。IO逻辑：在一个设备控制器上，可以连一个或多个设备。相应的，在控制器中就有一个或多个设备接口，一个接口连一台设备，控制器中的I/O逻辑根据处理机发来的地址信号，去选择一个设备接口。控制器中的I/O逻辑用来实现对设备的控制。通过接收CPU 发来的命令和地址信息，对所选设备进行控制CPU如何控制设备控制器CPU控制内存时需要指定指令地址、数据地址等。控制设备控制器亦如此，一般有两种控制方式：利用特定IO指令：利用特殊的IO指令控制设备控制器。内存映像IO：不再区分内存和控制器中的寄存器地址。假如有一个地址K，当0&lt;=K&lt;N时被认为是内存地址，K&gt;=N时被认为是寄存器地址。IO通道有了设备控制器之后，CPU便可以操作控制器完成对IO设备的控制，但是此时数据交换仍然需要CPU的全程参与，所以引入IO通道来使数据传送、IO设备的组织管理等都独立于CPU。通道是独立于CPU的专门负责数据输入/输出传输工作的处理机，对外部设备实现统一管理，代替CPU对输入/输出操作进行控制，从而使输入，输出操作可与CPU并行操作。通道执行通道程序来控制IO操作。与CPU的区别：通道程序指令类型单一通道没有自己的内存，通道程序在主机的内存中，即通道与CPU共享内存。字节多路通道主要连接以字节为单位的低速IO设备。如打印机，终端。按字节交叉方式工作的通道。通常含有许多非分配型子通道，其数量从几十个到数百个，每一个子通道连接一台I/O设备。这些子通道按时间片轮转方式共享主通道。字节多路通道以字节为单位传输信息，它可以分时地执行多个通道程序。当一个通道程序控制某台设备传送一个字节后，通道硬件就控制转去执行另一个通道程序，控制另一台设备传送信息。数组选择通道主要连接磁盘，磁带等高速I/O设备选择通道是按数组方式进行数据传送，每次传送一批数据，故传送速度很高。选择通道在一段时间内只能执行一个通道程序，只允许一台设备进行数据传输。当这台设备数据传输完成后，再选择与通道连接的另一台设备，执行它的相应的通道程序。这种独占性又使得通道利用率很低。数组多路通道主要连接高速设备。结合了数组选择通道传送速度高和字节多路通道能进行分时并行操作的优点。它先为一台设备执行一条通道指令，然后自动转接，为另一台设备执行一条通道指令。它含有多个非分配型的子通道，既有很高的数据传输率，又能获得令人满意的通道利用率对通道程序采用多道程序设计的硬件实现可以连接多台高速设备，数据传输按数组方式，一段时间内可以执行多道通道程序解决瓶颈通道执行通道程序，向控制器发出命令，并具有向CPU发中断信号的功能。一旦CPU发出指令，启动通道，则通道独立于CPU工作。但是，由于通道价格贵，通道数量少，往往使之成为IO的“瓶颈”。解决办法是在不增加通道的前提下，增加设备到主机间的通路，一个通道可连接多个控制器，一个控制器可连接多个设备，形成树形交叉连接。中断机构中断的理解说到中断还不得不从现代操作系统的特性说起，无论是桌面PC操作系统还是嵌入式都是多任务的操作系统，而很遗憾，处理器往往是单个的，即使在硬件成本逐渐下降，但处理器的数量依然不可能做到每个任务一个CPU，所以CPU必须作为一种全局的资源让所有任务共享。即什么时候给任务A用，什么时候给任务B用……这就是进程调度，具体的安排就由调度算法决定了。进程如何去调度？现代操作系统一般都是采用基于时间片的优先级调度算法，把CPU的时间划分为很细粒度的时间片，一个任务每次只能时间这么多的时间，时间到了就必须交出使用权，即换其他的任务使用。这种要看操作系统的定时器机制了。那么时间片到之后，系统做了什么呢？这就要用到我们的中断了，时间片到了由定时器触发一个软中断，然后进入相应的处理历程。当然这一点不足以表明中断的重要，计算机操作系统自然离不开外部设备：鼠标、键盘、网卡、磁盘等等。就拿网卡来讲，我计算机并不知道时候数据包会来到，我能保证的就是数据来了我能正常接收就行了。但是我又不可能一直等着接收数据包，要是这样其他任务就死完了。所以合理的办法是，你数据包来到之后，通知我，然后我再对你处理，怎么通知呢？？答：中断！键盘、鼠标亦是如此！中断的定义指处理机处理程序运行中出现的紧急事件的整个过程。程序运行过程中，系统外部、系统内部或者现行程序本身若出现紧急事件，处理机立即中止现行程序的运行，自动转入相应的处理程序（中断服务程序），待处理完后，再返回原来的程序运行，这整个过程称为程序中断。可分为两类：硬中断（Hardware Interrupt）外部中断：一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断是可屏蔽的。内部中断是指因硬件出错（如突然掉电、奇偶校验错等）,或运算出错（除数为零、运算溢出、单步中断等）所引起的中断，内部中断是不可屏蔽的。软中断（Software Interrupt）软中断是利用硬中断的概念，用软件方式进行模拟，实现宏观上的异步执行效果。很多情况下，软中断和”信号”有些类似，同时，软中断又是和硬中断相对应的，硬中断是外部设备对CPU的中断，软中断通常是硬中断服务程序（模拟硬件发出中断的程序）对内核的中断，信号则是由内核（或其他进程）对某个进程的中断。时钟中断在Linux的0号中断是一个定时器中断。在固定的时间间隔都发生一次中断，也是说每秒发生该中断的频率都是固定的。该频率是常量HZ，该值一般是在100 ~ 1000之间。该中断的作用是为了定时更新系统日期和时间，使系统时间不断地得到跳转。另外该中断的中断处理函数除了更新系统时间外，还需要更新本地CPU统计数。若进程的时间片递减到0，进程则被调度出去而放弃CPU使用权。Linux的OS时钟的物理产生原因是可编程定时/计数器产生的输出脉冲，这个脉冲送入CPU，就可以引发一个中断请求信号，我们就把它叫做时钟中断。时钟中断是特别重要的一个中断，因为整个操作系统的活动都受到它的激励。系统利用时钟中断维持系统时间、促使环境的切换，以保证所有进程共享CPU；利用时钟中断进行记帐、监督系统工作以及确定未来的调度优先级等工作。可以说，时钟中断是整个操作系统的脉搏。设备驱动程序功能接受设备独立性软件发来的命令和参数，将接收到的抽象要求转换为具体要求检查用户IO请求的合法性，了解IO设备的状态，传递有关参数，设置设备的工作方式发出IO命令，如果设备空闲，启动IO设备完成指定的IO操作；如果设备忙碌，则将请求挂在设备队列上等待及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。对于设置有通道的计算机系统，驱动程序还应能够根据用户的IO请求，自动地构成通道程序。特点驱动程序主要是在设备无关性软件和设备控制器之间的一个通信程序驱动程序与IO设备特性密切相关：通常由硬件厂商提供驱动程序与I/O控制方式密切相关:中断驱动和DMA方式驱动程序与硬件相关,部分代码需用汇编语言编写驱动程序应允许可重入处理过程将抽象要求转换为具体要求通常设备控制器中都有若干个寄存器，分别用于暂存命令、数据和参数等；用户及上层软件对设备控制器的具体情况毫无了解，因而只能向它们发出抽象的要求(命令)，但不能直接传送给设备控制器。需要将抽象要求转换为具体要求(命令码，数据，参数)。例如，将抽象要求中的盘块号转换为磁盘的盘面、磁道号及扇区。这一转换工作只能由驱动程序来完成；在OS中只有驱动程序才同时了解抽象要求和设备控制器中的寄存器情况；也只有它才知道命令、数据和参数应分别送往哪个寄存器。检查IO请求的合法性读出和检查设备的状态传送必要的参数，设置工作方式启动I/O设备在完成上述准备工作后，驱动程序可以向控制器中的命令寄存器传送相应的控制命令对于字符设备，若发出的是写命令，驱动程序将把一个数据传送给控制器；若发出的是读命令，则驱动程序等待接收数据，并通过从控制器中的状态寄存器读入状态字的方法，来确定数据是否到达。驱动程序发出IO命令后，基本的IO是在设备控制器的控制下进行的，通常IO操作所要完成的工作较多，需要一定的时间，如读/写一个盘块中的数据，此时，驱动程序进程把自己阻塞起来，直至中断到来时才将它唤醒。对IO设备的控制方式使用轮询的可编程I/O方式CPU发出启动外设的I/O指令，同时将忙/闲标志置为1。如果外设的工作没有完成，则标志一直为1，CPU不断循环检测该标志，直到标志为不忙为止。使用中断的可编程I/O方式CPU设定I/O设备的初始值，然后不再忙等待，运行其他进程，当前进程阻塞；I/O设备完成对当前数据的处理后，向CPU发出中断，I/O中断处理程序将负责传送剩余数据。直接存储器访问(DMA)方式采用中断驱动IO方式时的CPU，是以字为单位进行干预的。如果将这种方式用于块设备的I／O，是极其低效的。如：为了从磁盘中读出1KB的数据块；需要中断1K次CPU。而DMA方式使用独立的DMA控制器代替CPU的工作，I/O设备与DMA通信，DMA在传输完成一个数据缓冲区之后再向CPU发中断。数据传输的基本单位是数据块，即CPU与IO设备之间，每次传送至少是一个数据块，主要用在块设备的IO操作中。在DMA方式中，利用总线直接连接外设和内存，由DMA控制机构窃取总线占有权，完成外设与内存间的成批数据交换。所传送的数据是从设备直接送入内存的，或者相反。仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的，不再需要CPU进行干预。I/O通道控制方式使用DMA方式，CPU每发出一条I/O指令，只能读写一个连续的数据块。如果需要一次去读多个离散的数据块且将它们分别送到不同的内存区域，则需要CPU分别发出多条I/O指令及进行多次中断处理，才能完成。而IO通道可实现CPU、通道和I/O设备三者的并行操作，进一步提高CPU与外设之间的并行工作能力，使I/O操作形成独立于CPU的体系，减少CPU的负担，使外设与内存的数据交换更加灵活，从而更有效地提高整个系统的资源利用率。与设备无关的I/O软件为了便于对外设进行管理，系统对每台进入计算机系统中的设备都给定一个对应的编号，作为调用时识别和区分设备用。这种编号无任何重复，一般被称为设备的绝对号（或物理设备名）。早期操作系统，应用程序直接使用物理设备名称，非常不灵活。所以引入逻辑设备名，规定用户申请外设时，只需要向系统说明所需用的某类设备真正在实际中使用哪台设备，由系统根据这类设备的应用情况作出分配。设备分配在多道程序环境下，设备不允许用户自行使用，而必须由系统分配。对于进程的IO请求，只要是安全（无死锁），设备分配程序便按照一定的策略进行设备分配。数据结构：系统设备表SDT（System Device Table）整个系统中只有一张，全面反映了系统中的外设资源的类型、数量、占用情况等。在SDT表中，每个接入系统中的外围设备都占有一个表目项。登录了该设备的名称、标识、设备控制表DCT的入口地址、设备驱动程序的入口地址及占用设备的进程名称等相关信息。设备控制表DCT（Device Control Table）每台设备都有一张设备控制表DCT，用于记录本设备的情况。Type：设备类型Deviceid:设备标识符设备队列队首指针设备状态：标识设备忙或者空闲；与设备连接的控制器表指针。重复执行次数控制器控制表COCT（Controller Control Table）每个控制器都有一张，用于记录某控制器的使用分配情况及与该控制器相连的通道的情况。控制器号：控制器的内部标识符。控制器状态：控制器忙/闲，好/坏的状态标志。通道指针：指向与该控制器相联的通道控制表CHCT，当控制器与若干通道连接时该项内含多个指针。等待队列指针：指向等待该控制器的I/O进程队列通道控制表CHCT（Channel Control Table）反映了通道的情况，系统中的每个通道一张CHCT。通道号：通道内部标识符通道状态：通道的各种状态（好/坏，已分/未分等）的反映等待队列指针：等待该通道的I/O进程队列的首位置设备分配算法用户层的I/O软件系统调用与库函数用户层软件必须使用一组系统调用来取得操作系统服务，在高级语言中都提供了相应的库函数来完成此功能。SPOOLing程序多道程序技术将一台CPU虚拟为多台CPU，从而可以提高CPU的利用率。而SPOOLing系统是模拟脱机输入输出系统来实现多个用户共享一台物理IO设备。脱机输入输出系统的IO处理机 对应 SPOOLing程序。脱机输入输出系统的高速缓冲 对应 内存。缓冲区单缓冲区双缓冲区为输入或输出分配两个缓冲区，让两个缓冲区交替工作，形成并行操作的方式。环形缓冲区空缓冲区R：用于存放数据（指针：Nexti）已装满数据的缓冲区G：其中的数据提供给进程使用。（指针：Nextg）现行工作缓冲区C：当前进程使用的缓冲区。（指针：Current）磁盘存储器的性能和调度当磁盘驱动器执行读/写功能时。盘片装在一个主轴上，并绕主轴高速旋转，当磁道在读/写头（又叫磁头）下通过，就可以进行数据的读/写了。一般磁盘分为固定头盘（磁头固定）和活动头盘。固定头盘的每一个磁道上都有独立的磁头，它是固定不动的，专门负责这一磁道上数据的读/写。活动头盘 （如上图）的磁头是可移动的。每一个盘面上只有一个磁头（磁头是双向的，因此正反盘面都能读写）。它可以从该面的一个磁道移动到另一个磁道。所有磁头都装在同一个动臂上，因此不同盘面上的所有磁头都是同时移动的（行动整齐划一）。当盘片绕主轴旋转的时候，磁头与旋转的盘片形成一个圆柱体。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。磁盘访问时间寻道时间$T_s$：$T_s = s$旋转延迟时间$T_τ$：$T_t = \frac{1}{2r}$磁盘访问时间 ：$T_t=\frac{b}{rN}$$s$是指磁头从当前位置定位到开始点的时间，$b$是传输的字节数，$r$是每秒的转数，$N$是一条磁道上的字节数。$总时间 = T_s + \frac{1}{2r} + \frac{b}{rN}$磁盘调度算法假设磁盘访问序列：98，183，37，122，14，124，65，67，读写头起始位置：53。先来先服务按访问请求到达的先后次序服务。最短寻道时间优先扫描算法当设备无访问请求时，磁头不动；当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复。循环扫描算法CSCAN算法规定磁头单向移动，例如由里向外移动，当磁头移到最外的磁道并访问后磁头立即返回到最里的欲访问磁道，即最小磁道号紧接最大磁道号构成循环，进行循环扫描。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>课内学习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06.04-内存管理]]></title>
    <url>%2Fposts%2F19078.html%2F</url>
    <content type="text"><![CDATA[存储器的层次我们都知道存储器的容量和速度是限制计算机发展的一大原因，人们对存储器的要求需要既快又大，但是这样带来的结果就是存储器的造价非常昂贵，所以不可能在计算机中全部配置既快又大的存储器。所以现代的计算机系统中都配置了多层结构的存储器系统来平衡速度差异问题。存储器一般被分成六层，不过在只有前四层属于内存，所以此篇只介绍前四层。主存储器用于保存进程运行时的程序和数据。对于微机系统和大中型机，容量为数十MB到数GB；对于嵌入式系统，容量为数十KB到数MB。CPU从主存读取指令和数据。CPU与外设交换信息要依托主存。为缓解CPU执行指令速度和主存访问速度的矛盾，引入寄存器和高速缓冲。寄存器访问速度做快，完全与CPU协调工作，价格十分昂贵，容量不可能很大。长度一般以字为单位。对于微机系统和大中型机，可能有几十个甚至上百个；对于嵌入式系统，仅有几个到几十个。高速缓冲容量大于或远大于寄存器，比内存小两到三个数量级左右，从几十KB到几MB。访问速度快于主存。将主存中经常访问的信息存放在高速缓冲，减少访问主存次数。磁盘缓冲将一部分频繁使用的磁盘数据和信息，暂时存放在磁盘缓冲中，减少访问磁盘次数。不是实际存在的存储介质，利用主存的存储空间，暂存从磁盘读出或写入的信息。总结一下：磁盘缓冲是为了解决内存和外存的速度差异而在内存中开辟的一块用于暂存磁盘数据的存储介质。主存储器是保存进程运行时的程序和数据的。寄存器是和CPU速度匹配的存储器，直接给CPU提供数据。虽然CPU是直接从寄存器去取指令和数据，但是寄存器的数据来源最终还是主存储器，所以为了减少访问CPU的次数，产生了高速缓冲来缓和寄存器和主存储器的矛盾。至于为什么能缓和呢？这是由于程序局部性原理。程序局部性原理指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。 局部性原理又表现为：时间局部性和空间局部性。时间局部性：如果程序中的某条指令一旦执行，则不久之后该指令可能再次被执行；如果某数据被访问，则不久之后该数据可能再次被访问。空间局部性：一旦程序访问了某个存储单元，则不久之后。其附近的存储单元也将被访问。另外，根据程序的局部性理论，Denning提出了工作集理论。所谓工作集是指进程运行时被频繁访问的页面集合。显然我们知道只要使程序的工作集全部集中在内存中，就可以大大减少进程的缺页次数；否则会使进程在运行过程中频繁出现缺页中断，从而出现频繁的页面调入/调出现象，造成系统性能的下降，甚至出现“抖动”。划分工作集可以按定长时间或定长页面两种方法进行划分。当颠簸现象发生时，说明系统的负荷过大，通常采用处理器均衡调度。另一种是控制缺页率，当缺页率达到上限时，则增加内存分配量；当缺页率达到下限时，就减少内存的分配量。程序的装入和链接用户程序要在系统中运行，必须将它装入内存，其中有三个过程。编译：由编译程序（Complier）将用户源代码编译成若干个目标模块（Object Module）；链接：由链接程序（Linker）将编译后形成的目标模块以及它们所需要的库函数，链接在一起，形成一个装入模块（Load Module）；装入：由装入程序(Loader)将装入模块装入内存。链接链接程序的功能是将经过编译后得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块。静态链接方式生成可执行文件时进行链接。主要有两步。修改相对地址。变换外部调用符号。装入时动态链接目标模块是在装入内存时，边装入边链接的。装入时动态链接方式有以下优点：便于修改和更新。便于实现对目标模块的共享。运行时动态链接将对某些模块的链接推迟到执行时才执行，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存， 把它链接到调用者模块上。凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。装入装入是将一个具有执行资格的模块加载进内存。绝对装入方式在可执行文件中指定内存地址，装入时直接定位在上述（即文件中记录的地址）内存地址。逻辑地址和物理地址完全相同。可重定位装入方式编译程序所生成的目标模块中采用逻辑地址，根据当前内存情况，将装入模块装入到适当位置。地址映射是在装入模块装入内存时一次性进行的，即是静态重定位。动态运行时装入方式静态重定位时程序装入内存后不能移动，而且通常需要占用连续的内存空间。所以与其对应的动态重定位是将地址映射工作推迟到程序真正执行时才进行。现代计算机运行过程预处理把存储在不同文件中的源程序聚合在一起。把被称为宏的缩写语句转换为原始语句。编译：将高级语言翻译成汇编语言或机器语言。链接将多个可重定位的机器代码文件（包括库文件）连接到一起。解决外部内存地址（一个文件中的代码会引用其他文件中的数据对象或过程，这些数据对象或过程的地址对于此文件来说就是外部地址）问题。装入确定程序在内中的绝对地址（即修改程序起始地址），将修改后的指令和数据放到内存中适当的位置。连续分配存储管理方式连续分配是指为一个用户程序分配空间的时候，将所有程序装入到一段连续的物理内存中。在早期（20世纪60-80年代）的操作系统中，这种分配内存的方式曾经被广泛的使用。单一连续分配这是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。内存分为以下两个分区：系统区和用户区。操作系统使用系统区；应用程序装入到用户区，可使用用户区全部空间。固定分区分配固定分区式分配，是最早使用的一种可运行多道程序的存储管理方式。它将内存空间划分为若干个固定大小的区域，每个分区大小可相同，也可不同。OS占一区，其余每个分区中可以装入一道作业。为了便于内存分配，系统需建立一张分区使用表。当有一用户程序要装入时，从表中找出一个能满足要求的、尚未分配的分区分配给该程序，然后修改分区使用表。动态分区分配数据结构空闲分区表每个空闲分区占用一个表项。分区表的表项中包含分区号、分区始址及分区大小等表目。表长不易确定。占用额外内存。空闲分区链表利用各空闲分区自身的单元组成双向链表。操作速度较慢。分区分配分区回收如果回收区的前后有空闲区，可分为图示三种情况。回收时将空闲区和回收区合并。如果回收区的前后无空闲区，新建一个表项，填写信息插入。分区检索算法顺序检索算法首次适应算法：按各空闲分区首址的升序的方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从头查找，找到符合要求的第一个分区。循环首次适应算法：分配空闲空间时，不是从链首（或表头）开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找。最佳适应算法：按空闲区大小的升序方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从头查找，找到符合要求的第一个分区。就说明它是最适合的（即最佳的）。最坏适应算法：按空闲区大小的降序方法组织，分配时总是取空闲分区表（或空闲分区链）中的第一项，若大小不能满足申请者的要求，则表示系统中无满足要求的空闲区，分配失败；否则分配。索引检索算法快速适应算法：将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应一种空闲分区类型，并记录其表头指针。空闲分区的分类是根据进程常用的空间大小进行划分，对于其他大小的分区，可以放在一个特殊的空闲区链表中。伙伴系统：分区大小均为2的K次幂。假设系统可利用空间容量为$2^m$个字，系统运行过程中，不断划分，将空闲分区根据大小分类。为长度为n的进程分配分区时，首先计算$i$值使得$2^{i-1}≦n≦2^i$。先找大小为$2^i$的分区分配，否则找大小为$2^{i+1}$的分区分配，把$2^{i+1}$分区分成两个$2^i$分区（互称伙伴），一个分配，另一个加入$2^i$的空闲分区链表。分配可能经过多次分割，回收可能进行多次合并。哈希算法：根据空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最近分配策略。紧凑可变式分区也有零头问题。在系统不断地分配和回收中，必定会出现一些不连续的小的空闲区，称为外零头。虽然可能所有零头的总和超过某一个作业的要求，但是由于不连续而无法分配。解决零头的方法是拼接（或称紧凑），即向一个方向（例如向低地址端）移动已分配的作业，使那些零散的小空闲区在另一方向连成一片。分区的拼接技术，一方面是要求能够对作业进行重定位，另一方面系统在拼接时要耗费较多的时间。分页存储管理方式基本概念页面将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。物理块把内存空间分成与页面相同大小的若干个存储块，称为（物理）块或页框（frame）。页面碎片由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。页面大小每一页可进行编址的地址数目。页面大小应该满足2的n此幂。方便计算：如果要将（线性）地址转换为page：offset，则需要将地址除以页面大小，并将整数答案作为页面，将余数作为偏移量。 这是使用编程语言中的整数除法和模数运算符完成的。 计算机将地址表示为数字，存储为二进制位。 这是一个示例地址：12是二进制1100。 如果页面大小为3，那么我们需要计算12/3和12%3来查找页面和偏移量（分别为4、0）。 但是，如果页面大小为4（2的幂），则二进制中的4为100，此时使用特殊的“快捷方式”计算整数除法和模数：右移进行除法，按位与进行取模。所以： 12/4 == 12&gt;&gt;2（右移两位） 12%4 == 12&amp;(4-1)（1100和11按位与）。同时页面大小转为2进制可以使用左移，可以减小时间开销。充分利用空间：如果页面大小不满足2的n次幂，假如是5，则页内偏移地址，采用2位则每页有一个地址不能使用，采用3位则111、110、101未被使用。怎么做都不能完全利用地址空间。逻辑地址页表系统为每个进程建一张页表，其在内存的起始地址和长度记录在该进程的PCB中。页表的每一行是一个页表项。页表项长度每个页表项占用的编址个数。从逻辑地址那里我们可以看到页号占用了20位，对应的块号也要占用20位，当然块号本身可能不止$2^{20}$个。又由于为了控制对物理块的读写等操作，会在页表项中加上控制字段。如果内存按字节编址，即每个编址可以存储8个二进制位，那么页表项占用的二进制位总数大于内存的字长度。我们需要把一个页表项拆开存放在多个编址后的空间中。地址变换普通地址变换$物理地址=块号+块内地址=F(逻辑地址的页号*页表项长度+页表始址)+业内地址$。每次进行地址变换需要访问两次内存，内存速度较慢，所以影响计算机整体性能。具有快表的地址变换根据程序局部性原理，把最近使用的页表项存放在快表中，下次再进行地址变换时先去快表中查找对应项，如果没找到再去内存中查找，然后把新找到的页表项存放在快表中，如果快表已满，采用某种算法淘汰一份。有效访问时间设t是访问内存的时间，a是快表命中率，λ是查找快表所需的时间。普通地址变换时间：t+t具有快表的地址变换时间：$ a \ast \lambda + (1-a) \ast (t+\lambda)$。两级页表对于两级页表，是将页表再进行分页，页面的大小与内存物理块的大小相同。逻辑地址结构可描述如下：两级页表地址变换可推广至N级页表。反置页表页表是按每个进程的页号排序，指示出物理块号的位置，反置页表是按物理块号排序，指示出每个页隶属的进程和页号。此方法需要为每个进程创建一个外部页表，即将页表建立在外存中。进程进行地址变换时先从反置页表里查找，如果查找不到则去外村中查找，再将查找到的页表项调入内存。分段存储管理方式之前的分区管理都是为了更好的利用内存。为了满足程序员在编程上的要求引入了分段管理方式。方便编程通常，用户把自己的作业按照逻辑关系划分为若干个段，每个段都是从0开始编址，并有自己的名字和长度。因此，希望要访问的逻辑地址是由段名（段号）和段内偏移量（段内地址）决定的。例如，下述的两条指令便是使用段名和段内地址：其中，前一条指令的含义是将分段A中D单元内的值读入寄存器1；后一条指令的含义是将寄存器1的内容存入B分段的C单元中。12LOAD 1，[A] |〈D〉；STORE 1，[B] |〈C〉；信息共享在实现对程序和数据的共享时，是以信息的逻辑单位为基础的。比如，共享某个例程和函数。分页系统中的“页”只是存放信息的物理单位（块），并无完整的意义，不便于实现共享；然而段却是信息的逻辑单位。由此可知，为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适应。信息保护信息保护同样是对信息的逻辑单位进行保护，因此，分段管理方式能更有效和方便地实现信息保护功能。动态增长在实际应用中，往往有些段，特别是数据段，在使用过程中会不断地增长，而事先又无法确切地知道数据段会增长到多大。前述的其它几种存储管理方式，都难以应付这种动态增长的情况，而分段存储管理方式却能较好地解决这一问题。动态链接动态链接是指在作业运行之前，并不把几个目标程序段链接起来。要运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段（目标程序）调入内存并进行链接。可见，动态链接也要求以段作为管理的单位。分段地址段表地址映射地址变换分页和分段的主要区别页是信息的物理单位，段则是信息的逻辑单位；页的的大小固定且由系统决定，而段的长度不固定，由用户所编写的程序决定；分页的地址空间是一维的，而分段的地址空间是二维的。分页是系统管理的需要；分段是为了更好满足用户的需要。段页式存储管理方式分段结构具有逻辑上清晰的优点，但它的一个致命弱点是每个段必须占据主存储器的连续区域，于是，要装入一个分段时可能要移动已在主存储器中的信息，为了克服这个缺点，可兼用分段和分页的方法，构成段页式存储管理。每个作业仍按逻辑分段，但对每一段不是按单一的连续整体存放到存储器中，而是把每个段再分成若干个页面，每一段不必占据连续的主存空间，可把它按页存放在不连续的主存块中。原理逻辑地址空间分段，段内分页，内存分块（页框），存储管理的分配单位是：物理块（页框）地址结构：段号，页号，页内偏移地址。每个作业一张段表，每段一张页表。地址变换：先查段表，再查该段的页表。映射地址变换机构传统存储器的问题传统的内存管理方式要求将一个作业全部装入内存才可以运行，由此造成了以下两种情况：大作业对内存的要求超出物理内存总容量，致使其无法运行。内存由于容量的限制，只能装入少量的作业使其运行，而其它大量作业留在外存。解决原理程序局部性原理程序执行时， 除了少部分的转移和过程调用指令外，在大多数情况下仍是顺序执行的。过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域， 但经研究看出，过程调用的深度在大多数情况下都不超过5。程序中存在许多循环结构， 这些虽然只由少数指令构成， 但是它们将多次执行。程序中还包括许多对数据结构的处理， 如对数组进行操作， 它们往往都局限于很小的范围内。表现两个方面时间局限性。如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环。空间局限性。一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。基于局部性原理在程序装入时，不必将其全部读入到内存，而只需将当前需要执行的部分页或段读入到内存，就可让程序开始执行。在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统，将相应的页或段调入到内存，然后继续执行程序。虚拟存储器定义所谓虚拟存储器， 是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、 中、 小型机器和微型机中。实现虚拟存储器的条件由于一个作业被分成多次地调入内存运行，所以在内存分配时必须采用离散分配方式。同时需要解决以下问题：页表（段表）的设计（软件支持）程序不在内存时去外存调度需要中断（硬件支持）逻辑地址转换为物理地址（软件硬件支持）如何给每个进程分配物理块一个页（段）进入内存时，淘汰哪个页（段）请求分页存储管理方式页表机制用于将用户逻辑地址空间变换为内存的物理地址空间。在页表中增加若干项，以便于标志程序或数据的状态。状态位（存在位）P：表示该页是否调入内存。访问字段A：用于记录该页在某段时间内被访问的次数。修改位M：表示该页在调入内存后是否被修改过。未修改过不必写回外存，修改要写回外存。外存地址：该页在外存上的地址，通常是物理块号。缺页中断机构在地址映射过程中，在页表中发现所要访问的页不在内存，则产生缺页中断。操作系统接到此中断信号后，就调出缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使进程继续运行下去。如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应页表项目的状态位及相应的内存块号。若此时内存中没有空闲块，则要淘汰某页，若该页在内存期间被修改过，则要将其写回外存。缺页中断发生在指令执行期间，而通常情况下，CPU是在一条指令执行完后，才检查是否有中断请求到达；一条指令在执行期间，可能产生多次缺页中断。所以硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处，继续执行。地址转换机构内存分配最小物理块数的确定最小物理块数：保证进程正常运行所需的最小物理块数。与计算机的硬件机构有关，取决于指令的格式、功能和寻址方式。内存分配策略在请求分页中，可采取两种分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置换和局部置换（置换范围不同）。于是组合出三种适用的策略：固定分配局部置换：分配固定数目的内存空间，在整个运行期间都不改变。如果缺页，则先从该进程在内存的页面中选中一页，进行换出操作，然后再调入一页。可变分配全局置换：每个进程预先分配一定数目的物理块，同时OS也保持一个空闲物理块队列。当缺页时，首先将对OS所占有的空闲块进行分配，从而增加了各进程的物理块数。当OS的空闲块全部用完，将引起换出操作。可变分配局部置换：系统根据缺页率动态调整各进程占有的物理块数目，使其保持在一个较低的缺页率状态。物理块分配算法平均分配算法：将系统中所有可供分配的物理块，平均分配给各个进程。按比例分配算法：按照进程的大小比例分配物理块。考虑优先权的分配算法：为了对于紧迫的作业，能够尽快完成。可以将内存的物理块分成两部分，一部分按照比例分配给各进程，另一部分根据进程优先级，适当增加其相应的份额，分配给各进程。页面调入何时调入页面提前取页：预先装入主存一页或几页（提前页）。请求取页：当用到某页而不在主存时即缺页时取页。从何处调入页面外存有两个部分：文件区和对换区。对换区I/O操作速度比文件区相对快一些，因此一般应当尽量使用对换区来调入页面。对于不同情况，采用不同的策略：系统有足够的对换空间：全部从对换区调入。系统对换空间不足：未修改的从文件区调入，修改的从对换区调入。UNIX的调入方式：未运行过的从文件区调入，运行过的放在对换区，允许页面共享。页面调入过程进程需要的页面不在内存，引起缺页中断中断处理程序保留现场环境，转入缺页中断处理程序中断处理程序查找页表，得到对应的外存物理块号。如果内存有空闲，则启动磁盘操作，将所缺的页面读入，并修改页表。否则，到4。执行置换算法，选出要换出的页面，如果该页修改过，应将其写入磁盘，然后将所缺页调入内存，修改相应表项，将其存在位置为1，并放入快表。利用修改后的页表，形成物理地址，访问内存数据。缺页率假设进程逻辑空间为n页，系统为其分配物理块数为m。如果进程运行过程中，访问页面成功次数为S，访问页面失败次数为F，总页面访问次数A=S+F，则进程运行过程中 缺页率f=F/A。影响缺页率的主要因素：页面大小：页面越大，缺页率越小进程所分配物理块数：物理块越多，缺页率越小页面置换算法：合理的置换算法能更少将页面调入调出程序固有特性：比如做循环操作时，缺页率较低，因为执行的命令都是一系列大致相同的指令。页面置换算法最佳置换算法所选择的被淘汰页面，将是以后永不使用的， 或许是在最长（未来）时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。这是一种理想情况，是实际执行中无法预知的，因而不能实现。可用作性能评价的依据。例：假定系统为某进程分配了三个物理块， 并考虑有以下的页面号引用串17，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1进程运行时， 先将7，0，1三个页面装入内存。 以后， 当进程要访问页面2时， 将会产生缺页中断。此时OS根据最佳置换算法， 将选择页面7予以淘汰。先进先出页面置换算法选择装入最早的页面被置换。可以通过链表来表示各页的建立时间先后。最近最久未使用置换算法选择内存中最久未使用的页面被置换。这是局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。硬件支持寄存器每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，于是寄存器数值最小的是最久未使用页面。栈一个特殊的栈，每当进程访问某页面时，便把被访问的页面移到栈顶，于是栈底的是最久未使用页面。最少使用置换算法选择到当前时间为止被访问次数最少的页面被置换。实现方法1：每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，这样，在最近一段时间内时用最少的页面将是$\sum_{R_i}$最小的页。实现方法2：每页设置访问计数器，每当页面被访问时，该页面的访问计数器加1；发生缺页中断时，淘汰计数值最小的页面，并将所有计数清零。Clock置换算法也称最近未使用算法（NRU, Not Recently Used），它是LRU（最近最久未使用算法）和FIFO的折衷。内存中所有页面通过链接指针形成一个循环队列，每页有一个使用访问位，若该页被访问则置1。置换时采用一个指针，从当前指针位置开始按地址先后检查各页，寻找访问位为0的页面作为被置换页。指针经过的访问位为1的页都修改0，最后指针停留在被置换页的下一个页。改进Clock置换算法由于Clock算法不考虑换出页面时，页面是否修改过的问题。这样在换出的页面如果被修改过的话，则必须做拷回磁盘处理，开销比较大。于是，改进型的Clock算法为每个页又增加了一个修改位。选择页面时，尽量选择既未使用又没有修改的页面。访问位A，修改位M有四种不同情形：1类(A=0，M=0）既未访问，又没有修改，最佳淘汰页2类(A=0，M=1）未访问，但是有修改，效率低的淘汰页3类(A=1，M=0）被访问，但没有修改4类(A=1，M=1）既被访问，又有修改算法：指针从当前位置开始，开始第一轮扫描循环队列，寻找A=0且M=0的页面，找到则可换出。如果找不到，则开始第二轮扫描，寻找A=0且M=1的页面，并且每经过一个页面时，将其访问位A设置为0。如果找到一个第2类页面，则可换出。如果仍旧未找到合适的换出页面，则此时指针回到初始位置，且所有页面其访问位A为0。再转回1继续工作。页面缓冲算法在请求分页系统中，进程在运行的时候经常会发生页面换进换出的情况。而影响换进换出效率的原因如下：页面置换算法：好的页面置换算法能使进程运行中具有较低的缺页率，从而可以减少换进换出的开销。写会磁盘的频率。读入内存的频率。而页面缓存算法就是降低读写磁盘的频率来降低开销。做法如下：空闲页面链表：当有一个未被修改的页要换出时，实际上并不将其换出到外存，而是把它们所在的物理块挂在空闲链表的末尾。如果以后某进程请求此页时，便将其从空闲页面链表上取下。修改页面链表：和空闲页面链表的功能一样，只是说此链表是存放已修改页面的。当链表上挂有足够多的页面时，将它们一齐写入磁盘，这样可以降低读写磁盘的频率。访问内存的有效时间被访问页在主存，且相应页表项在快表：$EAT= \lambda +t$查找快表+访问实际物理地址被访问页在主存，但相应页表项不在快表：$ EAT= \lambda +t + t + \lambda$查找快表+读取页表+读取数据+更新快表被访问页不在主存：$EAT= \lambda + t + \varepsilon + t + \lambda$查找快表+读取页表+缺页中断处理+读取数据+等新快表内存的有效访问时间为：$EAT= \lambda + t + (1 - a ) \ast [f \ast ( \varepsilon + \lambda + t)+(1-f) \ast(\lambda+t)]$a为命中率，f为缺页率。查找快表+访问内存一次+未命中不需要请求缺页访问快表+未命中时不需要请求缺页访问内存+未命中需要请求缺页访问快表+未命中时需要请求缺页访问内存+未命中时需要请求缺页开销。抖动与工作集抖动由于只装入一个进程的部分程序和数据便可开始运行，故希望运行更多进程，增加多道程序度。但在多道程序环境下，并不是多道程序的度越高，系统吞吐量越大。当CPU的利用率达到某一峰值后，若继续增加多道程度，将产生“抖动”。抖动是指同时运行进程太多，分配给每个进程物理块太少，进程在运行时频繁缺页，必须请求调页，等待页面调进调出的进程增多，磁盘访问时间急剧增加，进程大部分时间用于页面换进换出，处理机利用率急剧下降并趋于0。工作集基于程序运行的局部性原理，程序运行时，对页面的访问并不均匀，一段时间仅局限于较少的页面；另一段时间，有可能局限于另一些较少的页面，如果能预知这些页面，并提前调入，将大大减少缺页率工作集，是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。定义：是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。工作集$ \omega (t, \Delta) $是二元函数。某进程在时间t的工作集记为$ \omega (t, \Delta) $，其中，$\Delta$为工作集的窗口尺寸。例窗口大小$\Delta$选择得过小，频繁产生缺页中断。窗口大小$\Delta$选择得很大，失去了虚拟存储器的意义抖动的预防方法采取局部置换策略：仅允许进程在自身范围内进行置换，不影响其他进程在CPU调度程序中引入工作集算法：调入新作业时，应该检查每个进程在内存中的驻留集是否足够大L=S准则：产生缺页的平均时间L=系统处理进程缺页的平均时间S选择暂停的进程：使某些低优先级的进程进程挂起，从而腾出内存空间请求分段存储管理方式请求分页系统建立的虚拟存储器，是以页面为单位进行换入、换出操作的。在请求分段系统中实现的虚拟存储器，以分段为单位进行换入和换出。程序在运行之前，只需要装入必要的若干个分段即可运行。当访问的分段不在内存时，可由OS将所缺少的段调入内存。使用请求分段存储管理方式可以对动态链接有很好的支持。请求段表机制存取方式：标记本段存取属性。如读R，写W，执行X访问字段A：记录本段使用的频繁程度修改位：是否在调入内存后做过修改存在位：本段是否装入内存增补位：该段是否动态增长过缺段中断机构要有专门的缺段中断处理程序。特点：指令和操作数必定不会跨越在段边界上。由于段的长度是不固定的，处理比缺页系统复杂。调入一个段可能要淘汰几个内存中的段。请求中断处理地址中断机构分段的共享与保护共享段表共享进程计数：多少进程在使用此段。存取控制手段：每个共享段，应为不同进程赋予不同的存取权限。断号：同一个共享段在不同进程那有不同的断号。分配第一个请求的进程，由系统分配一物理块，调入共享段，设置相关表项信息，并置count=1； 以后的进程，在自己的段表中增加一项，填入共享段的信息，在共享段表项中做count=count+1，填写进程相关信息。回收做count=count-1；若count=0 ，则该共享段被回收。分段保护越界检查：在进行存储访问时，要将逻辑地址的段号与段表长度进行比较，如果超出则发生越界中断信号；其次，将段内地址与段表中该段的长度进行比较，如果有效才进行转换，否则产生越界中断信号。存取控制检查：用于规定对该段的访问权限。通常的访问方式有：读：允许用户对该段/页内任何信息或其副本进行读操作。写：允许用户修改该段/页内任何信息直至撤消整个段/页。执行：用户可以执行该段/页程序，数据段/页除外。增加：用户可在段/页的末尾添加信息，但不允许修改已存在于段/页中的信息。环保护检查：是一种功能较完善的保护机制。思想：将所有的程序分成不同的级别，分别放置在不同的环上。内环（编号小，在内侧）的程序具有高优先权，外环的程序优先权低。操作系统核心安排在0环内；重要程序和操作系统服务安排在中间环；一般应用程序安排在外环。一个程序可以直接访问在相同环或低优先级环（比自身相对靠外的环）上的数据。一个程序访问高优先级（比自己靠内的环）时，通过系统调用方式实现。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>课内学习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06.07-外存管理]]></title>
    <url>%2Fposts%2F43988.html%2F</url>
    <content type="text"><![CDATA[外存管理分成两块，文件系统和磁盘管理文件管理概述计算机中有很多的程序和数据都是保存在外存中，在需要使用的时候才调入内存中。而如何保存这些信息是很重要的问题，因为不同类型的文件存储的数据格式不同，但这些格式却必须“迎合”硬件只能存储二进制数据的硬性条件。所以操作系统提供了文件管理的功能，让使用者能在不了解文件特性和外存特性的情况下完成文件的存储和查找等功能。同时还提供了文件共享和安全管理等功能。文件系统 &amp; 文件操作系统中负责管理和存储文件信息的软件称为文件管理系统，简称文件系统。包含：文件系统的接口，对对象操纵和管理的软件集合，对象及属性三部分。它负责对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。包含创建文件、删除文件等功能。文件是指具有文件名的若干相关元素的集合，可以分成有结构文件和无结构文件，无结构文件可以看成一个字符流。有结构文件是由一组记录的集合，记录又是一组数据项的集合。数据项：用来描述一个对象的某种属性的字符集。例如学生的学号、姓名等。记录：一组数据项的集合，用来描述一个对象在某方面的属性，例如学生的成绩。能唯一标识一个记录的一个或多个数据项叫做关键字。文件类型不同的文件类型由于本身存储的信息具有不同的结构，在管理的时候也是不同。所以文件会被分成很多类型，下面是常用的文件分类方法：按用途分类：系统文件、库文件、用户文件。按文件中数据的形式分类：源文件、目标文件、可执行文件。按存储控制属性分类：可读、可写、可执行文件。按组织形式和处理方法分类：普通文件、目录文件、特殊文件。剖析文件和目录我们刚才在定义中说道，文件是指具有文件名的若干相关元素的集合，在有结构文件中这些元素是数据项集合的集合，在无结构文件指的是字符流。所以文件的概念中本身是：文件系统的层次结构文件系统从底层到高层可分成三部分：对象及其属性、对对象操纵和管理的软件集合、文件系统接口：对象及其属性文件管理系统管理的文件如下：文件：在文件管理系统中有着各种不同类型的文件，它们都作为文件管理的直接对象。目录：用于对文件的存储和检索，目录的每个目录项包含了一个文件或目录的信息。磁盘存储空间：文件和目录必定占用存储空间，对这部分空间的有效管理不仅能提高外存的利用率，而且能提高对文件的存取速度。对对象操纵和管理的软件集合该层是文件管理系统的核心部分。文件系统的功能大多是在这一层实现的。如：文件存储的管理、文件目录的管理、将文件的逻辑地址转换为物理地址的机制、文件读写控制的管理、文件的共享和保护等功能。这些功能被可分为四层：I/O控制层：文件系统的最底层、主要由磁盘驱动程序等组成。基本文件系统层：主要用于处理内存和磁盘之间数据块的交换。基本I/O管理程序：完成与磁盘I/O有关的事务，如将文件的逻辑块号转换为物理块号、管理磁盘中的空闲盘块、I/O缓冲的指定等。逻辑文件系统：管控对文件的操作，如控制用户或应用程序对文件的读写等。文件系统的接口操作系统提供给用户或应用程序用来使用文件系统的接口：命令接口：用户与文件系统直接交互的接口，如Shell命令。程序接口：应用程序可以通过一系列命令调用文件系统的服务。文件的打开和关闭当用户要求对一个文件实施多次读/写操作时，如果每次都检索目录效率较低，所以为了避免多次重复的检索目录，OS提供了“打开（Open）”操作，当此操作被执行时，OS会把被打开文件的信息存为“打开文件表”的一个条目，然后把这个条目编号返回用户，这样用户就可以通过这个编号和文件之间建立一个连接，也就可以进行文件的读写等操作。当用户再次向系统发出请求时，把这个编号提交给OS，OS通过这个编号在打开文件表中查找文件信息就可以减少检索时间。而关闭就是OS从“打开文件表”上删除此条目，这样断开了用户和文件之间的连接。文件的逻辑结构和物理结构逻辑结构：从用户的角度来看，文件是能被存取的基本单位。物理结构：文件在磁盘上存储时的组织形式。逻辑文件按结构分类有结构文件：每个文件用于描述实体集中的一个实体。每个记录的长度对OS来说都是可知的。但记录之间可以分为定长和变长两种。定长记录：所有记录的长度都是相同的、所有记录中的各数据项都处在记录中相同的位置具有相同的顺序和长度。变长记录：各记录的长度不相同。比如论文的摘要可能长度差距很大，不能在存储之前估计出所需要的空间。无结构文件：系统中运行的大量的源程序、可执行文件、文本文件等都是无结构文件，即流式文件。其文件长度是以字节为单位的。逻辑文件按组织方式分类组织方式指的是文件中记录的组织方式。只对有结构文件有效。可以分成：顺序文件、索引文件、索引顺序文件。顺序文件指由一系列记录按某种顺序排列所形成的的文件。串结构：按存入时间的先后顺序排列。所以检索时必须从头挨个查找，效率低。顺序结构：用户指定一个字段作为关键字，他可以是任意类型的变量。如sql文件。索引文件为变长记录文件创建一张索引表，索引表是定长记录文件，检索时，先查找索引表，再根据指针所指的地址读取记录。可以解决变长文件记录较难直接存取的问题。索引顺序文件将顺序文件的所有记录分成若干组，为顺序文件建立一张索引表，索引表中为每组的第一个记录建立一个索引项。检索时，先检索索引表，找到记录所在记录组的第一个记录的表项，再顺序查找主文件，得到要求的记录。文件目录文件控制块包含三类信息基本信息类：文件名、文件物理位置、文件逻辑结构、文件物理结构控制信息类：各类用户的读、写、可执行文件等。使用信息类：文件的建立时间，当前的使用信息，上一次修改的时间，是否被进程锁住等。索引节点为了唯一确定外存中的一个文件，必须要把文件的FCB加载进内存，而每次加载的数据大小是一定的，所以为了一次能多加载进内存一个文件标识。将FCB分成两部分：磁盘索引节点文件主标识符文件类型文件存取权限文件物理地址文件长度文件连接计数：本人理解为硬链接计数文件存取时间内存索引节点。索引节点编号状态访问计数文件所属文件系统的逻辑设备号：不明白链接指针：不明白树形结构目录在树形结构目录中，目录应该保存文件的信息。同时目录的目录项要能既作为目录文件的FCB，又作为数据文件的FCB。文件共享基于有向无循环图实现文件共享此种方法存在问题：比如对于文件F8，D5:p、D6:e、D3:p都保存了F8的物理地址，即从某个盘块开始，总长度多少等。此时如果D6:e对F8进行了删除操作，D5:p和D3:P都无法察觉，仍然会认为在它们存储的位置上有文件，即一个目录项对文件的操作对其他目录项来说是不可见的。利用索引节点引入索引结点，将文件的物理地址和其他的属性放在索引结点中，只在目录项中存放文件名和指向索引结点的指针。由任何用户对文件进行Append操作或修改，引起相应索引结点内容的改变。此种方法即Linux中的硬链接。利用符号链接实现文件共享建立符号链接文件，它是一种特殊类型的文件，其内容是被链接文件的路径名。建立符号链接文件，并不影响原文件，实际上它们各是一个文件。可以建立任意的别名关系，甚至原文件是在其他计算机上。只有文件主才有指向索引结点的指针，而其他共享用户只有该文件的路径名。文件保护访问权&amp;保护域访问权：一个进程能对某对象执行操作的权利，用&lt;对象名，权集&gt;表示，如&lt;F1, {R/W}&gt;表示进程对F1有读和写的权利。保护域：进程对一组对象访问权的集合，进程只能在域内进行操作。进程和域的联系方式进程和域之间是一对多的关系，即一个进程可以联系多个域。此时进程的运行分为多个阶段，每个阶段联系一个域，这样就可以根据运行的实际需要规定进程每个阶段所能访问的对象。访问矩阵R：在域内运行的进程对文件具有读权限W：在域内运行的进程对文件具有写权限$R^\ast$：在域内运行的进程能把其对文件的读权限扩展到其他域中，但在其他域中是R权限，不再是$R^\ast$。$W^\ast$：在域内运行的进程能把其对文件的写权限扩展到其他域中，但在其他域中是W权限，不再是$W^\ast$。S：在域Di中运行的进程能转移到域Dj中运行，如图中在域D3运行的进程能转移到域D2中运行。O：在域中运行的进程能增加或删除对某文件的访问权。Control：在域Di中运行的进程能删除在域Dj中运行进程对各对象的访问权。如图中在D2中运行的进程能删除在D3中运行进程的访问权。访问矩阵的实现访问控制表将访问对象按列划分，为每一列建立一张访问控制表，在该表中把属于对象的所有空项都删除。此时表中的每一项都是一个有序对&lt;域，权集&gt;构成。访问权限表将访问矩阵按行划分，每一行是一个访问权限表，表中的每一项表示该域对某对象的访问权限。文件管理的目标是管理文件的组织方式，管理文件的访问权等。而磁盘存储器的管理是管理存储器的使用，如何高效利用存储器。他俩是棋与棋盘的关系。连续组织方式文件的信息存放在若干连续的物理块中。优点简单支持顺序存取和随机存取顺序存取速度快，所需的磁盘寻道次数和寻道时间最少缺点文件不能动态增长（预留空间：浪费、重新分配和移动）不利于文件插入和删除外部碎片问题链接组织方式隐式链接在文件的目录中记录该文件的第一和最后一个盘块的指针，每一个盘块的指针指向文件的下一物理块号。优点文件可动态增长有利于文件的插入和删除提高了磁盘空间利用率,不存在外部碎片问题缺点存取速度慢，不适于随机存取可靠性问题，如指针出错更多的寻道次数和寻道时间链接指针占用一定的空间显示链接将链接文件各物理块的指针显示地放在内存的一张链接表（文件分配表，File Allocation Table）中。在FCB的物理地址中填写其首指针所对应的盘块号。由于文件分配表示存储在内存中的，可以大大减少访问磁盘的次数。FAT微软公司早、中期推出的操作系统一直都是采用的FAT技术，即利用文件分配表FAT来记录每个文件中所有盘块之间的链接。FAT中引入了“卷”的概念，支持将一个物理磁盘分成四个逻辑磁盘，每个逻辑磁盘就是一个卷（也称为分区），每个卷都可以被单独格式化和使用。把盘块作为基本分配单位，同时每个分区中都配有两张相同的文件分配表FAT1和FAT2。FAT技术的发展有三个阶段：FAT12、FAT16和FAT32FAT12FAT表的每个表项占用12个bit。所以最多有$2^{12}$个表项，每个盘块的大小是512B，则每个磁盘分区的容量是2MB，能处理的磁盘最大容量是8MB。为了增大FAT能管理的最大容量，引入了“簇”的概念，每个簇是一组相邻的扇区，这样如果分配时以簇为单位进行分配就能管理更大的磁盘容量，但是相应的簇内零头也会更大，降低磁盘的利用率。FAT16FAT表的每个表项占用16个bit。最多有$2^{16}$个表项。FAT32FAT表的每个表项占用32个bit。最多有$2^{32}$个表项。同时每个簇固定为4KB。所以最大可管理$4 \ast 2^{10} \ast 2^{32} = 2TB$大小的空间。索引组织方式单级索引组织方式一个文件的信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构索引表，并将这些块的块号存放在一个索引表中。一个索引表就是磁盘块地址数组，其中第i个条目指向文件的第i块。·### 多级索引组织方式增量式索引组织方式可以更好的满足大、中、小文件的组织。文件存储空间的管理文件存储空间的管理包括空闲块的组织分配和回收。空闲表法把一个连续未分配区域称为“空闲文件”，系统为所有空闲文件单独建立一个目录。表目内容：序号，第一个空白块号，空白块个数。分配算法：内存管理中的首次适应算法、循环首次适应算法。合并：空闲区邻接合并空闲链表法空闲盘块链：所有空闲盘块拉成一条链，分配时从头分配，回收时链接在尾部。空闲盘区链：每个连续的盘块组成一个盘区，每个盘区包含本盘区的大小和下一个盘区的地址。位示图法用一串二进制位反映磁盘空间中分配使用情况，每个物理块对应一位，分配物理块为1，否则为0。申请物理块时，可以在位示图中查找为0的位，返回对应物理块号；归还时；将对应位转置0。成组链接法（重点）把所有的空闲盘块按每n个一组分成m个组。最后一个组放在内存的空闲盘块号栈中，其他组存在外存上。空闲盘块号栈是一个临界资源，只允许一个进程同时访问。数据结构，一个size为n+1的栈。图上是一个倒着的的栈（栈底在上方，栈顶在下方）一个n+1的栈实际可用盘块只有n（图上只有99个可用盘块），因为栈底是一个计数器，指示当前有多少个可用盘块，但是可用盘块中有一个是指向下一个组，即stack[1]指向下一个组。如果stack[1]==0表示此时是最后一组。分配时从栈顶开始向下分配，直至分配出n-1个盘块，此时如果再想分配一个块就需要把下一个组调入空闲盘块号栈。调入后新组覆盖旧组。然后把新组在外存中占用的盘块分配出去。回收时从栈底向上回收，如果计数器==100时还有空闲盘块（设这个盘块编号为p）要回收，就把空闲盘块号栈内的组取出来存在p中，在空闲盘块号栈内新开辟一个组，新组的stack[1]指向p。例此题题目及来源：https://blog.csdn.net/ajay666/article/details/73569654分配3个盘块后，回收它所占的5个盘块，回收的盘块号依次为700、711、703、788、701，画出分配回收过程。第一次分配第二次分配注意：300号盘块中存储的组信息调入空闲盘块号栈之后其自己也可以被分配。第三次分配第一次回收第二次回收第三次&amp;第四次&amp;第五次回收]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>课内学习</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5_handle_camera_image]]></title>
    <url>%2Fposts%2F1237.html%2F</url>
    <content type="text"><![CDATA[H5启用默认摄像头1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="bootstrap/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="bootstrap/css/bootstrap.min.css"&gt;&lt;/script&gt; &lt;script src="bootstrap/holder.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;script type="application/javascript"&gt; window.onload=function() &#123; let video = document.getElementById("video"); /** * constraints：打开摄像头时约束，下面的约束对video没有约束，它选择设备的默认摄像头，但是禁止了音频 */ let constraints = &#123; video: &#123;&#125;, audio : false &#125;; let promise; if(navigator.mediaDevices.getUserMedia)&#123; //最新标准API promise = navigator.mediaDevices.getUserMedia(constraints); &#125; else if (navigator.webkitGetUserMedia)&#123; //webkit内核浏览器 promise = navigator.webkitGetUserMedia(constraints); &#125; else if (navigator.mozGetUserMedia)&#123; //Firefox浏览器 promise = navagator.mozGetUserMedia(constraints); &#125; else if (navigator.getUserMedia)&#123; //旧版API promise = navigator.getUserMedia(constraints); &#125; promise.then(function (MediaStream) &#123; video.srcObject = MediaStream; video.play(); &#125;); &#125; &lt;/script&gt; &lt;body&gt; &lt;video class="myvideo" style="border-radius: 10%;" id="video" autoplay="autoplay" &gt;&lt;/video&gt; &lt;/body&gt;&lt;/html&gt;分析上面的代码只能打开设备默认摄像头，在手机上会是前置摄像头。此博文代码测试时间为2019.4.7。在开启摄像头这一块，不同的浏览器兼容性很差，而且标准进年来改动过大，很多的API都被弃用，所以不能使用时请勿喷。H5启用手机后置摄像头12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="bootstrap/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="bootstrap/css/bootstrap.min.css"&gt;&lt;/script&gt; &lt;script src="bootstrap/holder.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;script type="application/javascript"&gt; window.onload=function() &#123; let video = document.getElementById("video"); // 此API请求可用媒体输入和输出设备的列表，例如麦克风，摄像头，耳机等。 let promoseDevs = navigator.mediaDevices.enumerateDevices(); var exArray = []; promoseDevs.then(function(devices) &#123; devices.forEach(function (dv) &#123; var kind = dv.kind; //我们需要的是摄像头，所以匹配video if (kind.match(/^video.*/)) &#123; exArray.push(dv.deviceId); console.log(dv); &#125; &#125;); &#125;).then(function()&#123; alert("摄像头个数：" + exArray.length); // 设置启用摄像头时的约束，在手机端约束摄像头为后置 let constraints = &#123; video: &#123; // 如果电脑插入了多个摄像头，在这里可以进行选择 deviceId: exArray[exArray.length - 1] &#125;, audio : false &#125;; let promise; if (navigator.mediaDevices.getUserMedia) &#123; //最新的标准API promise = navigator.mediaDevices.getUserMedia(constraints); &#125; else if (navigator.webkitGetUserMedia) &#123; //webkit核心浏览器 promise = navigator.webkitGetUserMedia(constraints, success, error) &#125; else if (navigator.mozGetUserMedia) &#123; //firfox浏览器 promise = navigator.mozGetUserMedia(constraints, success, error); &#125; else if (navigator.getUserMedia) &#123; //旧版API promise = navigator.getUserMedia(constraints, success, error); &#125; promise.then(function (MediaStream) &#123; video.srcObject = MediaStream; video.play(); &#125;) &#125;) &#125; &lt;/script&gt; &lt;body&gt; &lt;video class="myvideo" style="border-radius: 10%;" id="video" autoplay="autoplay" &gt;&lt;/video&gt; &lt;/body&gt;&lt;/html&gt;H5实现图片预览12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="bootstrap/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="bootstrap/css/bootstrap.min.css"&gt;&lt;/script&gt; &lt;script src="bootstrap/holder.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;script type="application/javascript"&gt; function select_file(fileid)&#123; document.getElementById(fileid).click(); &#125; //预览图片并获得图片的base64编码 function imgPreview(fileDom)&#123; //判断是否支持FileReader /** * FileReader 对象允许Web应用程序异步读取存储在用户计算机上的文件 */ if (window.FileReader) &#123; var reader = new FileReader(); &#125; else &#123; alert("请更新您的浏览器！"); return; &#125; //获取文件 var file = fileDom.files[0]; var imageType = /^image\//; //是否是图片 if (!imageType.test(file.type)) &#123; alert("请选择图片文件！"); return; &#125; /* * readAsDataURL 方法会读取指定的 Blob 或 File 对象。返回文件的base64编码 */ reader.readAsDataURL(file); /** * 当文件读取完成的时候会回调此函数，e就是获取的文件 */ reader.onload = function(e) &#123; //获取图片dom var img = document.getElementById("img"); //e是获取的文件，reader.readAsDataURL(file);读取的Base64编码存放在target.result中 img.src = e.target.result; &#125;; &#125; &lt;/script&gt; &lt;body&gt; &lt;div class="row"&gt; &lt;div class="panel-title" style="text-align: center;"&gt; &lt;input type="file" class="hidden" id="image" onchange="imgPreview(this)"&gt; &lt;img style="height: 200px; border-radius: 50%;" src="holder.js/300x300" onclick="select_file('image');" id="img" /&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;canvas把摄像头拍摄到的视频保存为图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="bootstrap/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="bootstrap/css/bootstrap.min.css"&gt;&lt;/script&gt; &lt;script src="bootstrap/holder.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;script type="application/javascript"&gt; window.onload=function() &#123; let video = document.getElementById("video"); /** * constraints：打开摄像头时约束，下面的约束对video没有约束，它选择设备的默认摄像头，但是禁止了音频 */ let constraints = &#123; video: &#123;&#125;, audio : false &#125;; let promise; if(navigator.mediaDevices.getUserMedia)&#123; //最新标准API promise = navigator.mediaDevices.getUserMedia(constraints); &#125; else if (navigator.webkitGetUserMedia)&#123; //webkit内核浏览器 promise = navigator.webkitGetUserMedia(constraints); &#125; else if (navigator.mozGetUserMedia)&#123; //Firefox浏览器 promise = navagator.mozGetUserMedia(constraints); &#125; else if (navigator.getUserMedia)&#123; //旧版API promise = navigator.getUserMedia(constraints); &#125; promise.then(function (MediaStream) &#123; video.srcObject = MediaStream; video.play(); &#125;); &#125; &lt;/script&gt; &lt;body&gt; &lt;video class="myvideo" style="border-radius: 10%;" id="video" autoplay="autoplay" &gt;&lt;/video&gt; &lt;button id="b"&gt;画图&lt;/button&gt; &lt;canvas id="myCanvas"&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; var btn = document.getElementById("b"); btn.onclick =function()&#123; var c=document.getElementById("myCanvas"); ctx=c.getContext('2d'); ctx.drawImage(video, 0, 0, 270, 135); &#125; &lt;/script&gt;&lt;/html&gt;转化为file此标题中说的file是表单中&lt;input type=&quot;file&quot; name=&quot;&quot; id=&quot;&quot; value=&quot;&quot; /&gt;。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8" /&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="bootstrap/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;link rel="stylesheet" href="bootstrap/css/bootstrap.min.css"&gt;&lt;/script&gt; &lt;script src="bootstrap/holder.min.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;script type="application/javascript"&gt; window.onload=function() &#123; let video = document.getElementById("video"); /** * constraints：打开摄像头时约束，下面的约束对video没有约束，它选择设备的默认摄像头，但是禁止了音频 */ let constraints = &#123; video: &#123;&#125;, audio : false &#125;; let promise; if(navigator.mediaDevices.getUserMedia)&#123; //最新标准API promise = navigator.mediaDevices.getUserMedia(constraints); &#125; else if (navigator.webkitGetUserMedia)&#123; //webkit内核浏览器 promise = navigator.webkitGetUserMedia(constraints); &#125; else if (navigator.mozGetUserMedia)&#123; //Firefox浏览器 promise = navagator.mozGetUserMedia(constraints); &#125; else if (navigator.getUserMedia)&#123; //旧版API promise = navigator.getUserMedia(constraints); &#125; promise.then(function (MediaStream) &#123; video.srcObject = MediaStream; video.play(); &#125;); &#125; function getBase64() &#123; //获得Canvas对象 var cas = document.getElementById("myCanvas"); var ctx = cas.getContext("2d"); let video = document.getElementById("video"); ctx.drawImage(video, 0, 0, 500, 400); var data = cas.toDataURL('image/png', 0.1); //1表示质量(无损压缩) return data; &#125; //'file' 等价于 浏览本地文件上传时本地文件的名字 function dataURLtoFile(dataurl, filename = 'file')&#123; dataurl = dataurl + ""; var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while(n--)&#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new File([u8arr], filename, &#123;type:mime&#125;); &#125; &lt;/script&gt; &lt;body&gt; &lt;video id="video" autoplay="autoplay" &gt;&lt;/video&gt; &lt;button id="b"&gt;画图&lt;/button&gt; &lt;canvas id="myCanvas" width="500px" height="500px"&gt;&lt;/canvas&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; var btn = document.getElementById("b"); btn.onclick =function()&#123; console.log(dataURLtoFile(getBase64())); &#125; &lt;/script&gt;&lt;/html&gt;源码https://github.com/isjinhao/html5-handle-img]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[opencv实现人脸识别、人脸打框、人脸剪切]]></title>
    <url>%2Fposts%2F38658.html%2F</url>
    <content type="text"><![CDATA[Opencv在各平台上的配置https://opencv-java-tutorials.readthedocs.io/en/latest/01-installing-opencv-for-java.html。下面的代码使用opencv3.4.5测试图片人脸识别代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.util.Arrays;import java.util.List;import org.opencv.core.Core;import org.opencv.core.Mat;import org.opencv.core.MatOfRect;import org.opencv.core.Rect;import org.opencv.imgcodecs.Imgcodecs;import org.opencv.objdetect.CascadeClassifier;public class GetImgFace &#123; private static String classifier = "D:/opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml"; static &#123; // 必须要加载Opencv的Library System.loadLibrary(Core.NATIVE_LIBRARY_NAME); &#125; public static void main(String[] args) &#123; //图片路径不能有中文... GetImgFace.getImgFace("C:\\Users\\ISJINHAO\\Desktop\\test.jpg"); &#125; public static List&lt;Rect&gt; getImgFace(String imgPath)&#123; /* * 加载分类器，选择已经训练好的opencv分类器，训练器路径：%OPENCV_HOME%/sources/data/haarcascades/ * 分类器包含眼睛，人脸，人体，微笑等等，其中对于仅仅识别人脸来说，最好的训练器是： * haarcascade_frontalface_default.xml * haarcascade_frontalface_alt.xml * haarcascade_frontalface_alt2.xml * */ // 分类器路径不要有中文... CascadeClassifier faceDetector = new CascadeClassifier(classifier); if (faceDetector.empty()) &#123; System.out.println("请选择正确的分类器！"); return null; &#125; // 创建Mat，Mat是用来保存图片信息的类。Imgcodecs是用来读取图片的工具类 Mat image = Imgcodecs.imread(imgPath); // 检测人脸，检测结果存在faceDetections中 MatOfRect faceDetections = new MatOfRect(); faceDetector.detectMultiScale(image, faceDetections); List&lt;Rect&gt; faceList = Arrays.asList(faceDetections.toArray()); System.out.println(faceList); return faceList; &#125;&#125;结果人脸打框代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.File;import java.util.Iterator;import java.util.List;import java.util.UUID;import org.opencv.core.Mat;import org.opencv.core.Point;import org.opencv.core.Rect;import org.opencv.core.Scalar;import org.opencv.imgcodecs.Imgcodecs;import org.opencv.imgproc.Imgproc;public class FaceRect &#123; public static void main(String[] args) &#123; String imgPath = "C:\\Users\\ISJINHAO\\Desktop\\test.jpg"; List&lt;Rect&gt; faceRects = GetImgFace.getImgFace(imgPath); //把识别出来的图片分别打框 Iterator&lt;Rect&gt; iterator1 = faceRects.iterator(); while(iterator1.hasNext()) &#123; Rect rect = iterator1.next(); FaceRect.imageMark(imgPath, "D:\\test\\" + UUID.randomUUID() + ".jpg", rect); &#125; //在一张图片中把所有识别出来的人脸都打框 Mat image = Imgcodecs.imread(imgPath); Iterator&lt;Rect&gt; iterator2 = faceRects.iterator(); while(iterator2.hasNext()) &#123; Rect rect = iterator2.next(); Imgproc.rectangle(image, new Point(rect.x, rect.y), // 左上点 new Point(rect.x + rect.width, rect.y + rect.height), // 右下点 new Scalar(0, 255, 0), 2); // 框的颜色和粗细 &#125; Imgcodecs.imwrite("D:\\test\\" + UUID.randomUUID() + ".jpg", image); &#125; public static File imageMark(String imagePath, String outFilePath, Rect rect) &#123; Mat image = Imgcodecs.imread(imagePath); // 原始图片 //Imgproc.rectangle的作用是在修改image中的数据，把相应的位置打上框 Imgproc.rectangle(image, new Point(rect.x, rect.y), // 左上点 new Point(rect.x + rect.width, rect.y + rect.height), // 右下点 new Scalar(0, 255, 0), 2); // 框的颜色和粗细 // 把mat写入图片 Imgcodecs.imwrite(outFilePath, image); return new File(outFilePath); &#125;&#125;结果人脸剪切代码123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.File;import java.util.Iterator;import java.util.List;import java.util.UUID;import org.opencv.core.Mat;import org.opencv.core.Rect;import org.opencv.core.Size;import org.opencv.imgcodecs.Imgcodecs;import org.opencv.imgproc.Imgproc;public class FaceCut &#123; public static void main(String[] args) &#123; String imgPath = "C:\\Users\\ISJINHAO\\Desktop\\test.jpg"; List&lt;Rect&gt; faceRects = GetImgFace.getImgFace(imgPath); //把识别出来的图片分别打框 Iterator&lt;Rect&gt; iterator1 = faceRects.iterator(); while(iterator1.hasNext()) &#123; Rect rect = iterator1.next(); FaceCut.imageCut(imgPath, "D:\\test\\" + UUID.randomUUID() + ".jpg", rect); &#125; &#125; public static File imageCut(String imagePath, String outFilePath, Rect rect) &#123; Mat image = Imgcodecs.imread(imagePath); // 按照原始图片中的人脸提取出来 Mat sub = image.submat(rect); Mat mat = new Mat(); Size size = new Size(rect.width, rect.height); // 修改提取出来的人脸信息sub在坐标轴的位置。 Imgproc.resize(sub, mat, size); // 将截图保存 Imgcodecs.imwrite(outFilePath, mat); return new File(outFilePath); &#125;&#125;结果]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态代理]]></title>
    <url>%2Fposts%2F41590.html%2F</url>
    <content type="text"><![CDATA[理解代理代理这个词对于广告满天飞的现代社会应该是很常见了，和它具有相同意义还有中介、经纪人等词。我们就以找影视明星拍片为例来理解代理。假如你有一个很好的剧本，现在想找A明星来做主角，可以两种方式：第一种是直接找A明星本人，第二种是找A明星的经纪人。但是明星的主要功能是拍戏，如果诸如报酬、档期、宣传等工作也让A明星来负责，势必会减少他/她的拍戏时间，所以更好的方式是去寻求他/她的经纪人，让经纪人来做这些拍戏以外的工作。但同时经济人也得有和明星A一样的功能，比如A会演戏、唱歌、跳舞，那么经纪人也得有这些功能，只不过经纪人的功能是让明星A去完成的，经纪人本身只提供这种服务的接口。而我们所说的明星A便是目标对象，经纪人便是代理对象。对于Java中的代理，假如有一个方法（设为M1）的功能是把UTF-8编码下的字符转化成GBK编码下的字符。那么这个方法的功能就是进行转化、对于判断传入的是不是UTF-8编码下的字符这种事情应该传入之前就处理完成，所以这时候就要有一个代理方法（设为M2）在M1执行之前做个处理。当然M1执行完毕之后也可能存在M3进行一些处理。代理对象的要点代理对象存在的价值主要用于拦截对目标对象的访问。代理对象应该具有和目标对象相同的方法。动态代理在我们刚才的解释中，每个目标对象都要有一个实在的代理对象，这在实际开发中是很耗费精力的一件事，但如果说能在程序运行期间给我们动态生成一个代理对象可以大大减小编写的代码的压力。所以动态代理的概念就是：不用手动编写一个代理对象，不需要编写与目标对象相同的方法，运行时在内存中动态生成代理对象（字节码对象级别的代理对象）。JDK提供的动态代理JDK1.5之后为我们提供了用于专用于动态生成代理对象的类：java.lang.reflect.Proxy。有一个很重要的静态方法：12static Object newProxyInstance (ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHander h)在解释参数之前，我们先看一个接口InvocationHander，JDK对它的解释是：Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the method of its invocation handler.（每个代理实例都有一个关联的调用处理程序。当在代理实例上调用方法时，将方法调用编码并调度到其调用处理程序的方法。） 它只有一个invoke()方法。我们之后执行时真正起作用的也是这个方法。public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;对newProxyInstance()方法参数的解释在下面的例子中。明星接口12345public interface BrightStar &#123; public void sing(); public String dancing(); public String ShootFilm(String filmName);&#125;A明星类1234567891011121314public class StarA implements BrightStar&#123; @Override public void sing() &#123; System.out.println("A is singing..."); &#125; @Override public String dancing() &#123; return "Hai cao wu"; &#125; @Override public String ShootFilm(String filmName) &#123; return filmName; &#125;&#125;测试动态代理123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class Test &#123; public static void main(String[] args) &#123; StarA starA = new StarA(); BrightStar newProxyInstance = (BrightStar)Proxy.newProxyInstance( //代理类的类加载器，获取目标类加载器即可 StarA.class.getClassLoader(), //代理类应该实现的接口，由于代理类和目标类需要继承相同的接口，使用目标类的接口即可 StarA.class.getInterfaces(), //使用匿名内部类传入InvocationHandler的实例 new InvocationHandler() &#123; /* * proxy：传入代理对象。 * method：被执行的方法。 * args：传入的参数。 * 例子： newProxyInstance.ShootFilm("我不是药神"); * proxy：newProxyInstance； method：ShootFilm； args："我不是药神" */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //执行前的操作 System.out.println("before"); Object invoke = method.invoke(starA, args); //执行后的操作 System.out.println("after"); return invoke; &#125; &#125;); //调用方法 newProxyInstance.sing(); System.out.println("------------------------------------"); String dancing = newProxyInstance.dancing(); System.out.println(dancing); System.out.println("------------------------------------"); String film = newProxyInstance.ShootFilm("我不是药神"); System.out.println(film); /* Console : before A is singing... after ------------------------------------ before after Hai cao wu ------------------------------------ before after 我不是药神 */ &#125;&#125;下面介绍一个经典案例，使用动态代理解决Web工程的全局编码问题。前端代码1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt; &lt;title&gt;Insert_Title_Here&lt;/title&gt; &lt;/head&gt; &lt;style&gt; &lt;/style&gt; &lt;body&gt; &lt;!--主体部分--&gt; &lt;h2&gt;get方式&lt;/h2&gt; &lt;form action="/ProxySolveCoding/test" method="get"&gt; &lt;input name="name" type="text"/&gt; &lt;input type="submit" value="提交"/&gt; &lt;/form&gt; &lt;h2&gt;post方式&lt;/h2&gt; &lt;form action="/ProxySolveCoding/test" method="post"&gt; &lt;input name="name" type="text"/&gt; &lt;input type="submit" value="提交"/&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt;Servlet1234567891011@WebServlet("/test")public class Test extends HttpServlet &#123; private static final long serialVersionUID = 1L; public void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; String name = request.getParameter("name"); System.out.println(name); &#125; public void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125;filter12345678910111213141516171819202122232425262728293031@WebFilter(urlPatterns="/*")public class FilterCoding implements Filter &#123; public void init(FilterConfig filterConfig) throws ServletException &#123; &#125; public void destroy() &#123; &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; final HttpServletRequest req = (HttpServletRequest)request; HttpServletRequest proReq = (HttpServletRequest)Proxy.newProxyInstance( req.getClass().getClassLoader(), req.getClass().getInterfaces(), new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if(method.getName().equalsIgnoreCase("getParameter")) &#123; String gm = req.getMethod(); if(gm.equalsIgnoreCase("get")) &#123; //处理get方式的请求 String before = (String) method.invoke(req, args); System.out.println(before); String after = new String(before.getBytes("iso-8859-1"), "utf-8"); return after; &#125;else &#123; //处理post形式的请求 req.setCharacterEncoding("utf-8"); &#125; &#125; return method.invoke(req, args); &#125; &#125;); chain.doFilter(proReq, response); &#125;&#125;JDK动态代理的特点能被代理的对象必须存在接口，否则会报错。且被增强的方法一定是在接口中有相同的方法签名。因为它生成代理对象的方式是拿到类的所有接口，然后根据这些接口和我们实现的InvocationHandler中的invoke()动态创建一个对象。Cglib概述是一个强大的，高性能，高质量的Code生成类库，它可以在运行期扩展Java类与实现Java接口。它是第三方实现的，所以需要导入jar包。特点和JDK提供的动态代理相比，Cglib更加灵活，不需要类上存在接口，因为它生成代理对象是通过现有的类派生出一个子类，在子类中加入我们新的条件。所以被代理的类不能使用final修饰。使用的例子123public interface UserDao &#123; void save();&#125;123456789101112import org.springframework.beans.factory.annotation.Value;public class UserDaoImpl implements UserDao &#123; @Value("HelloWorld") private String name; public void save() &#123; System.out.println("保存..."); &#125; public void talk() &#123; System.out.println("接口中没有我"); &#125; public String toString() &#123; return "UserDaoImpl [name=" + name + "]"; &#125;&#125;1234567891011121314151617181920212223242526272829303132333435363738import java.lang.reflect.Method;import com.spring.secondday.UserDao;import com.spring.secondday.UserDaoImpl;import net.sf.cglib.proxy.Enhancer;import net.sf.cglib.proxy.MethodInterceptor;import net.sf.cglib.proxy.MethodProxy;public class CglibProxy &#123; private UserDao ud; public CglibProxy(UserDao ud) &#123; this.ud = ud; &#125; public UserDaoImpl getProxy()&#123; Enhancer en = new Enhancer(); en.setSuperclass(ud.getClass()); en.setCallback(new MethodInterceptor() &#123; //proxy：被代理的对象 m：被增强的方法 args：方法所需的参数 methodProxy：增强后的方法 public Object intercept(Object proxy, Method m, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println("before"); Object super1 = methodProxy.invokeSuper(proxy, args); System.out.println("after"); return super1; &#125; &#125;); UserDaoImpl proxy = (UserDaoImpl)en.create(); return proxy; &#125; public static void main(String[] args) &#123; UserDaoImpl ud = new UserDaoImpl(); UserDaoImpl proxy = new CglibProxy(ud).getProxy(); /*Console: before 接口中没有我 after */ proxy.talk(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仅使用Servlet3完成文件上传下载]]></title>
    <url>%2Fposts%2F36072.html%2F</url>
    <content type="text"><![CDATA[上传文件的html界面1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;单文件上传&lt;/h2&gt; &lt;form action="/servlet3-upload-and-download/uploadone" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file"&gt; &lt;input type="submit" name="upload"&gt; &lt;/form&gt; &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;h2&gt;多文件上传&lt;/h2&gt; &lt;form action="/servlet3-upload-and-download/uploadmany" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file1"&gt; &lt;input type="file" name="file2"&gt; &lt;input type="submit" name="upload"&gt; &lt;/form&gt; &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;h2&gt;文件下载&lt;/h2&gt; &lt;a href="/servlet3-upload-and-download/download"&gt;点击下载&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;下载123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package download;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet("/download")public class download extends HttpServlet&#123; private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType("text/html;charset=utf-8"); //filepath String filePath = "D:\\我.jpg"; try( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath)); BufferedOutputStream bos = new BufferedOutputStream(resp.getOutputStream()); ) &#123; long fileLength = new File(filePath).length(); resp.setHeader("Content-disposition", "attachment; filename=" + new String(new File(filePath).getName().getBytes("utf-8"), "ISO8859-1")); resp.setHeader("Content-Length", String.valueOf(fileLength)); byte[] buff = new byte[2048]; int bytesRead; while (-1 != (bytesRead = bis.read(buff, 0, buff.length))) &#123; bos.write(buff, 0, bytesRead); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125; &#125;上传单文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package upload;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.MultipartConfig;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.Part;@WebServlet("/uploadone")@MultipartConfig //Servlet3中处理multipart/form-data类型请求的注解public class UploadOne extends HttpServlet&#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; this.doPost(request, response); &#125; protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; //说明输入的请求信息采用UTF-8编码方式 request.setCharacterEncoding("utf-8"); response.setContentType("text/html; charset=UTF-8"); PrintWriter out = response.getWriter(); //Servlet3.0中新引入的方法，用来处理multipart/form-data类型编码的表单 Part part = request.getPart("file"); //获取HTTP头信息headerInfo=（form-data; name="file" filename="文件名"） String headerInfo = part.getHeader("content-disposition"); System.out.println("headinfo ==&gt; " + headerInfo); //从HTTP头信息中获取文件名fileName=（文件名） String fileName = headerInfo.substring(headerInfo.lastIndexOf("=") + 2, headerInfo.length() - 1); //获得存储上传文件的文件夹路径 String fileSavingFolder = this.getServletContext().getRealPath("/upload"); //获得存储上传文件的完整路径（文件夹路径+文件名） //文件夹位置固定，文件夹采用与上传文件的原始名字相同 String fileSavingPath = fileSavingFolder + File.separator + fileName; System.out.println("filePath ==&gt; " + fileSavingPath); //如果存储上传文件的文件夹不存在，则创建文件夹 File f = new File(fileSavingFolder + File.separator); if(!f.exists())&#123; f.mkdirs(); &#125; //将上传的文件内容写入服务器文件中 part.write(fileSavingPath); //输出上传成功信息 out.println("文件上传成功~！"); &#125;&#125;多文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970package upload;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import java.util.Collection;import java.util.Iterator;import javax.servlet.ServletException;import javax.servlet.annotation.MultipartConfig;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.Part;@WebServlet("/uploadmany")@MultipartConfig //Servlet3中处理multipart/form-data类型请求的注解public class UploadMany extends HttpServlet&#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; this.doPost(request, response); &#125; protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; //说明输入的请求信息采用UTF-8编码方式 request.setCharacterEncoding("utf-8"); response.setContentType("text/html; charset=UTF-8"); PrintWriter out = response.getWriter(); //Servlet3.0中新引入的方法，用来处理multipart/form-data类型编码的表单 Collection&lt;Part&gt; parts = request.getParts(); Iterator&lt;Part&gt; iterator = parts.iterator(); //获得存储上传文件的文件夹路径 String fileSavingFolder = this.getServletContext().getRealPath("/upload"); while(iterator.hasNext()) &#123; Part next = iterator.next(); //获得文件大小 long size = next.getSize(); System.out.println(size); //获取HTTP头信息headerInfo=（form-data; name="file" filename="文件名"） String headerInfo = next.getHeader("content-disposition"); System.out.println("headinfo ==&gt; " + headerInfo); //从HTTP头信息中获取文件名fileName=（文件名） String fileName = headerInfo.substring(headerInfo.lastIndexOf("=") + 2, headerInfo.length() - 1); //获得存储上传文件的完整路径（文件夹路径+文件名） //文件夹位置固定，文件夹采用与上传文件的原始名字相同 String fileSavingPath = fileSavingFolder + File.separator + fileName; System.out.println("filePath ==&gt; " + fileSavingPath); //如果存储上传文件的文件夹不存在，则创建文件夹 File f = new File(fileSavingFolder + File.separator); if(!f.exists())&#123; f.mkdirs(); &#125; //将上传的文件内容写入服务器文件中 next.write(fileSavingPath); &#125; //输出上传成功信息 out.println("文件上传成功~！"); &#125;&#125;demo下载：https://github.com/isjinhao/servlet3-upload-and-download。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于winpcap的cpp控制台网络协议分析]]></title>
    <url>%2Fposts%2F38170.html%2F</url>
    <content type="text"><![CDATA[环境搭建软件版本winpcap4.1.3vs2015创建项目新建项目-&gt;Visual C++项目-&gt;Win32控制台项目，在Win32应用程序向导窗口中的应用程序设置-&gt;附加选项选中空项目。将WinPcap开发包中的Include和Lib两个文件夹复制到新建项目所在文件夹下。点击项目，右击，然后点击属性C/C++-&gt;常规-&gt;附加包含目录：如 ..\include链接器-&gt;常规-&gt;附加库目录：如 ..\lib链接器-&gt;输入-&gt;附加依赖项：wpcap.lib（winpcap的包），ws2_32.lib（windows的socket）数据结构12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#ifdef _MSC_VER#define _CRT_SECURE_NO_WARNINGS#endif#include "pcap.h"typedef struct eth_address&#123; u_char byte1; u_char byte2; u_char byte3; u_char byte4; u_char byte5; u_char byte6;&#125;eth_address;/* 4 bytes IP address */typedef struct ip_address&#123; u_char byte1; u_char byte2; u_char byte3; u_char byte4;&#125;ip_address;/* IPv4 header */typedef struct ip_header&#123; u_char ver_ihl; // Version (4 bits) + Internet header length (4 bits) u_char tos; // Type of service u_short tlen; // Total length u_short identification; // Identification u_short flags_fo; // Flags (3 bits) + Fragment offset (13 bits) u_char ttl; // Time to live u_char proto; // Protocol u_short crc; // Header checksum ip_address saddr; // Source address ip_address daddr; // Destination address u_int op_pad; // Option + Padding&#125;ip_header;/* UDP header*/typedef struct udp_header&#123; u_short sport; // Source port u_short dport; // Destination port u_short len; // Datagram length u_short crc; // Checksum&#125;udp_header;/* MAC header*/typedef struct eth_header&#123; eth_address daddr; eth_address saddr; u_short type;&#125;eth_header;typedef struct arp_header&#123; u_short hardtype; //硬件类型字段 u_short prototype; //协议类型字段 u_char htlen; //硬件地址的长度,以字节为单位.对于以太网上IP地址的ARP请求或应答来说,它们的值为6 u_char ptlen; //协议地址的长度,以字节为单位.对于以太网上IP地址的ARP请求或应答来说,它们的值为4 u_short op; //操作字段 eth_address arp_esa; //发送端MAC地址 ip_address arp_isa; //发送端IP地址 eth_address arp_eda; //目的端MAC地址 ip_address arp_ida; //目的端IP地址&#125;arp_header;typedef struct icmp_header&#123; u_char type; //ICMP报文类型 u_char code; //代码 u_short checksum; //校验和 u_short identifier; //标识符 u_short sequence_number; //序列号&#125;icmp_header;/* TCP header */typedef struct tcp_header&#123; u_short sport; //源端口 u_short dport; //目的端口 u_long sequence_number; //序号（4字节ntohl） u_long acknowlegement_number; //确认号 u_short hlen_bl_flags; //数据偏移+保留+控制位 u_short window_size; //窗口（发送方自己的接收窗口） u_short checksum; //检验和（首部+数据） u_short urg; //紧急指针 u_long option; //可选+填充&#125;tcp_header;typedef struct dns_packet //报文head+data&#123; u_short id; //每一个占2个字节，共12个字节 u_short flags; //标志第一个为0代表查询报文 u_short ques; u_short answer; u_short author; u_short addition; u_char dns_data; //查询问题部分&#125;dns_packet;运行代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459#ifdef _MSC_VER#define _CRT_SECURE_NO_WARNINGS#endif#include "pcap.h"#include "headers.c"#define DNSPORT 53//输出基本信息void myPrintBaseInfo(const struct pcap_pkthdr *header)&#123; struct tm *ltime; char timestr[16]; time_t local_tv_sec; local_tv_sec = header-&gt;ts.tv_sec; ltime=localtime(&amp;local_tv_sec); strftime(timestr, sizeof timestr, "%H:%M:%S", ltime); printf("\n\n\n\n监听到Mac帧的时间：%s MAC帧长度:%d Byte(s)\n", timestr, header-&gt;len * 4); /* 以四字节为单位 */&#125;//输出硬件地址void myPrintEthAddress(eth_address eth)&#123; printf("%02X:%02X:%02X:%02X:%02X:%02X", eth.byte1, eth.byte2, eth.byte3, eth.byte4, eth.byte5, eth.byte6 );&#125;//输出IP地址void myPrintIPAddress(ip_address ia)&#123; printf("%d.%d.%d.%d", ia.byte1, ia.byte2, ia.byte3, ia.byte4 );&#125;//输出网络层协议类型void myPrintNetType(u_short type)&#123; printf("网络层协议： "); if(type==0x0800) printf("IP协议"); else if(type==0x0806) printf("ARP协议"); else if(type==0x8035) printf("RARP协议"); else printf("接收到非本程序能处理的网络层协议类型！"); printf("\n");&#125;/* 分析Mac帧： 输出： 网络层协议类型：源MAC -&gt; 目的MAC 返回： 网络层协议类型*/u_short handleMac(eth_header *eth)&#123; u_short type=ntohs(eth-&gt;type); printf("Mac地址： "); myPrintEthAddress(eth-&gt;saddr); printf("-&gt;"); myPrintEthAddress(eth-&gt;daddr); printf("\n\n"); return type;&#125;void handleARPAndRARP(arp_header *ah)&#123; u_short arp_ht; //硬件地址的类型.它的值为1即表示以太网地址 u_short arp_pt; //要映射的协议地址类型.它的值为0x0800，即表示IP地址 u_short arp_op; //四种操作类型,它们是ARP请求(值为1)、ARP应答(值为2)、RARP请求(值为3)和RARP应答(值为4) arp_ht=ntohs(ah-&gt;hardtype); //硬件地址的类型.它的值为1即表示以太网地址 arp_pt=ntohs(ah-&gt;prototype); //要映射的协议地址类型.它的值为0x0800，即表示IP地址 arp_op=ntohs(ah-&gt;op); printf("硬件地址类型为：%d\t\t\t",arp_ht); printf("协议地址类型为：0x%04X\n",arp_pt); printf("硬件地址长度为：%d\t\t\t",ah-&gt;htlen); printf("协议地址长度为：%d\n",ah-&gt;ptlen); if (arp_op == 1)&#123; printf("操作类型为：ARP请求报文。\n本机Mac地址："); myPrintEthAddress(ah-&gt;arp_esa); printf("\t正在请求"); myPrintIPAddress(ah-&gt;arp_ida); printf("的Mac地址\n"); &#125; if (arp_op == 2)&#123; printf("操作类型为：ARP应答报文。\n应答方的Mac地址："); myPrintEthAddress(ah-&gt;arp_eda); printf("\t应答方的IP地址"); myPrintIPAddress(ah-&gt;arp_ida); printf("\n"); &#125; if (arp_op == 3) printf("操作类型为：RARP请求报文\n"); if (arp_op == 4) printf("操作类型为：RARP应答报文\n");&#125;int all_ip_len = 20;u_short handleIP(ip_header *ih)&#123; u_int ip_ver; //版本 u_int ip_len; //首部长度 u_short ip_tlen; //总长度 u_short ip_ident; //标识 u_short ip_flag_fo; //标志和片偏移 u_int ip_flag; //标志（3位，值为2还有分片且允许分片,1不能分片,0没有分片且允许分片） u_int ip_fo; //片偏移 u_short ip_type; //协议 u_short ip_crc; //首部检验和 u_long ip_op_pad; //可选项 /* retireve the position of the ip header *///检索IP首部的位置 ip_ver = (ih-&gt;ver_ihl &gt;&gt; 4); //版本 ip_len = (ih-&gt;ver_ihl &amp; 0xf) * 4; //首部长度，与运算，可以只取ip头部的版本长度字段的后4位 ip_tlen=ntohs(ih-&gt;tlen); //总长度 ip_ident=ntohs(ih-&gt;identification); //标识 ip_flag_fo = ntohs(ih-&gt;flags_fo); //2字节存放，会有字节序问题 ip_flag = (ip_flag_fo &gt;&gt; 13); //标志 ip_fo = (ip_flag_fo &amp; 0x1fff); //片偏移 ip_type = ih-&gt;proto; //上层协议类型 ip_crc = ntohs(ih-&gt;crc); //首部校验和 /*打印IP数据报首部*/ printf("版本：%d\t\t\t",ip_ver); printf("首部长度：%d\n",ip_len); printf("区分服务：%d\t\t", ih-&gt;tos); printf("总长度：%d\n", ip_tlen); printf("标识：%d\t\t", ip_ident); if (ip_flag == 2) printf("标志：DF=1（不能分片），MF=0（没有后续分片）\n"); if (ip_flag == 1) printf("标志：DF=0（允许分片），MF=1（还有后续分片）\n"); if (ip_flag == 0) printf("标志：DF=0（允许分片），MF=0（没有后续分片）\n"); printf("片偏移：%d\t\t",ip_fo*8);//片偏移以8字节为单位 printf("生存时间：%d\n",ih-&gt;ttl); printf("协议：%d\t\t\t",ih-&gt;proto); printf("首部校验和：%d\n",ip_crc); printf("IP地址： "); myPrintIPAddress(ih-&gt;saddr); printf(" -&gt; "); myPrintIPAddress(ih-&gt;daddr); printf("\n"); if (ip_len == 20)//IP首部长度&gt;20时才有 printf("首部长度为20，IP报文首部没有可选字段。\n"); else&#123; ip_op_pad = ntohl(ih-&gt;op_pad); printf("可选自段内容为：%u\n", ip_op_pad); &#125; all_ip_len = ip_len; return ip_type;&#125;void handleICMP(icmp_header *ich)&#123; u_short icmp_checksum; //校验和 u_short icmp_ident; //标识符 u_short icmp_seqnum; //序列号 icmp_checksum = ntohs(ich-&gt;checksum); //校验和 icmp_ident = ntohs(ich-&gt;identifier); //标识符 icmp_seqnum = ntohs(ich-&gt;sequence_number); printf("\n运输层协议： ICMP协议\n"); /*打印ICMP报文首部*/ if (ich-&gt;type == 0) printf("ICMP类型：回显应答\n"); else if (ich-&gt;type == 8) printf("ICMP类型：回显请求\n"); else printf("ICMP类型：其他\n"); printf("代码：%d\t\t",ich-&gt;code); printf("校验和：%d\n",icmp_checksum); printf("标识符：%d\t\t",icmp_ident); printf("序列号：%d\n",icmp_seqnum);&#125;u_int udp_len;bool handleUDP(udp_header *uh)&#123; u_short sport, dport;//端口 u_short uh_len; //长度 u_short uh_crc; //校验和 sport = ntohs( uh-&gt;sport );//源端口 dport = ntohs( uh-&gt;dport );//目的端口 uh_len = ntohs(uh-&gt;len); //长度 uh_crc = ntohs(uh-&gt;crc); //校验和 printf("\n运输层协议： UDP协议\n"); printf("端口号：%d -&gt; %d\n", sport, dport); printf("长度：%d\t\t", uh_len); printf("校验和：%d\n", uh_crc); udp_len = uh_len; if(sport == DNSPORT || dport == DNSPORT) return true; return false;&#125;void handleTCP(tcp_header *th)&#123; u_short tcp_sport; //源端口 u_short tcp_dport; //目的端口 u_long tcp_seqnum; //序号（4字节ntohl） u_long tcp_acknum; //确认号 u_short tcp_hlen_bl_flags; //数据偏移+保留+控制位 u_short tcp_hlen; u_short tcp_bl; u_short tcp_flags_urg; //紧急1有效 u_short tcp_flags_ack; //确认=1时，确认号有效 u_short tcp_flags_psh; //推送1有效，可以不用填满缓存就发报 u_short tcp_flags_rst; //复位1有效，重新建立连接 u_short tcp_flags_syn; //同步syn=1,ack=0时，表明这是一个连接请求报文；syn=1,ack=1,接受连接请求 u_short tcp_flags_fin; //释放连接=1时，表示数据报 u_short tcp_window_size; //窗口（发送方自己的接收窗口） u_short tcp_checksum; //检验和（首部+数据） u_short tcp_urg; //紧急指针 u_long tcp_option; tcp_sport=ntohs(th-&gt;sport); //源端口 tcp_dport=ntohs(th-&gt;dport); //目的端口 tcp_seqnum=ntohl(th-&gt;sequence_number); //序号（4字节ntohl） tcp_acknum=ntohl(th-&gt;acknowlegement_number);//确认号 tcp_hlen_bl_flags=ntohs(th-&gt;hlen_bl_flags); //数据偏移4+保留6+控制位6 tcp_hlen=(tcp_hlen_bl_flags &gt;&gt; 12)*4; //以4字节为单位 tcp_bl=(tcp_hlen_bl_flags &amp; 0x0fc0); //保留 tcp_flags_urg=(tcp_hlen_bl_flags &amp; 0x0020); //紧急1有效 ----- tcp_flags_ack=(tcp_hlen_bl_flags &amp; 0x0010); //确认=1时，确认号有效 tcp_flags_psh=(tcp_hlen_bl_flags &amp; 0x0008); //推送1有效，可以不用填满缓存就发报 tcp_flags_rst=(tcp_hlen_bl_flags &amp; 0x0004); //复位1有效，重新建立连接 tcp_flags_syn=(tcp_hlen_bl_flags &amp; 0x0002); //同步syn=1,ack=0时，表明这是一个连接请求报文；syn=1,ack=1,接受连接请求 tcp_flags_fin=(tcp_hlen_bl_flags &amp; 0x0001); //释放连接=1时，表示数据报 tcp_window_size=ntohs(th-&gt;window_size); //窗口（发送方自己的接收窗口） tcp_checksum=ntohs(th-&gt;checksum); //检验和（首部+数据） tcp_urg=ntohs(th-&gt;urg); printf("\n运输层协议： TCP协议\n"); /*打印TCP数据报首部*/ printf("端口号：%d -&gt; %d\n",tcp_sport,tcp_dport); printf("序号：%u\t",tcp_seqnum); printf("确认号：%u\n",tcp_acknum); printf("数据偏移：%d\t\t",tcp_hlen);//首部长度// printf("保留：%d\n",tcp_bl); /*控制字段,标志位*/ if (tcp_flags_urg == 1) printf("标志：URG\n"); if (tcp_flags_ack == 1) printf("标志：ACK\n"); if (tcp_flags_psh == 1) printf("标志：PSH\n"); if (tcp_flags_rst == 1) printf("标志：RST\n"); if (tcp_flags_syn == 1) printf("标志：SYN\n"); if (tcp_flags_fin == 1) printf("标志：FIN\n"); printf("窗口：%d\t\t",tcp_window_size); printf("检验和：%d\n",tcp_checksum); printf("紧急指针：%d\t\t",tcp_urg);//URG=1时才有用，窗口大小为0也能发送 if(tcp_hlen == 20)//数据偏移(TCP首部长度)&gt;20时才有 printf("首部长度为20字节，没有填充字段。\n"); else &#123; tcp_option = ntohl(th-&gt;option); printf("填充字段:%u\n", tcp_option); &#125;&#125;/* Callback function invoked by libpcap for every incoming packet */void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data) //param 无用&#123; eth_header *eth; u_short macType; myPrintBaseInfo(header); eth=(eth_header *) (pkt_data); //过滤以太网头部 pkt_data += 14; //HandleMac macType=handleMac(eth); myPrintNetType(macType); // 处理ARP 和 RARP if(macType==0x0806 || macType==0x8035) &#123; arp_header *ap; ap = (arp_header *)(pkt_data); handleARPAndRARP(ap); &#125; // 处理IP if(macType==0x0800) &#123; u_short ip_type; ip_header *ih; ih = (ip_header *) (pkt_data); ip_type = handleIP(ih); if (ip_type == 1) &#123; icmp_header *ich; ich = (icmp_header *)((u_char*)ih + all_ip_len); handleICMP(ich); &#125;else if(ip_type == 17)&#123; udp_header *uh; uh = (udp_header *) ((u_char*)ih + all_ip_len); if(handleUDP(uh)) &#123; /* struct dns_packet *pdns; pdns = (struct dns_packet *)(pkt_data + all_ip_len + udp_len); // sport+dport+length+checksum,DNS头指针 u_char *query=&amp;(pdns-&gt;dns_data);//定位到查询部分头部 printf("QueryDomain="); u_char domainname[100]=&#123;0&#125;; u_int i=0; //query++;//把点去了 while(*query) &#123; printf("%d", *query); if(*query &lt; 0x10)//48以后出现数字和英文字母 printf("."); else printf("%c", *query); query++; i++; &#125; printf("\n"); */ &#125; &#125;else if(ip_type == 6)&#123; tcp_header *th; th=(tcp_header *) ((u_char*)ih + all_ip_len); handleTCP(th); &#125; &#125;&#125;int main()&#123; pcap_if_t *alldevs; pcap_if_t *d; int inum; int i=0; pcap_t *adhandle; char errbuf[PCAP_ERRBUF_SIZE]; u_int netmask; char packet_filter[100]; int i; scanf("%d", &amp;i); printf("分析IP数据报输入：\t1\n"); printf("分析ARP数据报输入：\t2\n"); printf("分析TCP数据报输入：\t3\n"); printf("分析UDP数据报输入：\t4\n"); printf("分析ICMP数据报输入：\t5\n"); printf("分析MAC、IP、ARP、TCP、UDP、IMCP输入\t6\n"); if(i == 1) packet_filter = "ip"; else if(i == 2) packet_filter = "arp"; else if(i == 3) packet_filter = "ip and tcp"; else if(i == 4) packet_filter = "ip and udp"; else if(i == 5) packet_filter = "ip and icmp"; else if(i == 6) packet_filter = ""; else&#123; printf("InputError : check the number you input! exit(1)"); exit(1); &#125; struct bpf_program fcode; if(pcap_findalldevs(&amp;alldevs, errbuf) == -1) &#123; fprintf(stderr,"Error in pcap_findalldevs: %s\n", errbuf); exit(1); &#125; for(d=alldevs; d; d=d-&gt;next) &#123; printf("%d. %s", ++i, d-&gt;name); if (d-&gt;description) printf(" (%s)\n", d-&gt;description); else printf(" (No description available)\n"); &#125; if(i==0) &#123; printf("\nNo interfaces found! Make sure WinPcap is installed.\n"); return -1; &#125; printf("Enter the interface number (1-%d):",i); scanf("%d", &amp;inum); /* Check if the user specified a valid adapter */ if(inum &lt; 1 || inum &gt; i) &#123; printf("\nAdapter number out of range.\n"); pcap_freealldevs(alldevs); return -1; &#125; /* Jump to the selected adapter */ for(d=alldevs, i=0; i&lt; inum-1 ;d=d-&gt;next, i++); /* Open the adapter */ if ((adhandle= pcap_open_live(d-&gt;name, // name of the device 65536, // portion of the packet to capture. // 65536 grants that the whole packet will be captured on all the MACs. 1, // promiscuous mode (nonzero means promiscuous) 1000, // read timeout errbuf // error buffer )) == NULL) &#123; fprintf(stderr,"\nUnable to open the adapter. %s is not supported by WinPcap\n"); pcap_freealldevs(alldevs); return -1; &#125; /* Check the link layer. We support only Ethernet for simplicity. */ if(pcap_datalink(adhandle) != DLT_EN10MB) &#123; fprintf(stderr,"\nThis program works only on Ethernet networks.\n"); pcap_freealldevs(alldevs); return -1; &#125; if(d-&gt;addresses != NULL) /* Retrieve the mask of the first address of the interface */ netmask=((struct sockaddr_in *)(d-&gt;addresses-&gt;netmask))-&gt;sin_addr.S_un.S_addr; else /* If the interface is without addresses we suppose to be in a C class network */ netmask=0xffffff; //compile the filter if (pcap_compile(adhandle, &amp;fcode, packet_filter, 1, netmask) &lt;0 ) &#123; fprintf(stderr,"\nUnable to compile the packet filter. Check the syntax.\n"); pcap_freealldevs(alldevs); return -1; &#125; //set the filter if (pcap_setfilter(adhandle, &amp;fcode)&lt;0) &#123; fprintf(stderr,"\nError setting the filter.\n"); pcap_freealldevs(alldevs); return -1; &#125; printf("\nlistening on %s...\n", d-&gt;description); /* At this point, we don't need any more the device list. Free it */ pcap_freealldevs(alldevs); /* start the capture */ pcap_loop(adhandle, 0, packet_handler, NULL); return 0;&#125;分析听到网卡上Mac帧时的回调函数12void packet_handler(u_char *param, const struct pcap_pkthdr *header, const u_char *pkt_data);输出基本信息：包括监听到帧的时间，帧的长度1void myPrintBaseInfo(const struct pcap_pkthdr *header);输出硬件地址，格式：xx:xx:xx:xx:xx:xx1void myPrintEthAddress(eth_address eth);输出IP地址，格式：xx.xx.xx.xx1void myPrintIPAddress(ip_address ia);输出网络层协议类型，格式：网络层协议：xxxx1void myPrintNetType(u_short type);分析Mac帧：1u_short handleMac(eth_header *eth);分析ARP和RARP帧1void handleARPAndRARP(arp_header *ah);分析IP数据报1u_short handleIP(ip_header *ih);分析ICMP数据报1void handleICMP(icmp_header *ich);分析UDP数据报1bool handleUDP(udp_header *uh);分析TCP数据报1void handleTCP(tcp_header *th);]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>cpp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[电子邮件&Java完成发送]]></title>
    <url>%2Fposts%2F65368.html%2F</url>
    <content type="text"><![CDATA[电子邮件邮件服务器邮件服务器的功能是发送和接收邮件，邮件服务器按照客户服务器方式工作。邮件服务器需要使用发送和读取两个不同的协议。发送时使用了两次SMTP协议（简单邮件传送协议SMTP），负责发送邮件的SMTP进程就是SMTP客户，而负责接收邮件的SMTP进程就是SMTP服务器。电子邮件发送和接收的流程发信人使用用户代理（例如：Outlook）编辑要发送的信件。发件人的 Outlook 软件使用SMTP协议，把邮件“推送”给发送方邮件服务器，SMTP服务器把邮件临时存放在缓冲区内,等待发送。发送方邮件服务器的SMTP客户与接收方邮件服务器的SMTP服务器建立TCP连接，然后发送邮件。运行在接收方邮件服务器中的SMTP服务器进程收到邮件后，把邮件放入收件人的邮箱中，等待收件人进行读取。收件人在打算收信时，就打开自己PC机中的软件, Outlook 使用POP3（或IMAP）协议，将自己邮箱内的邮件“拉取”回来。注意：当张三给李四发电子邮件时，李四的电脑可能是关机的，这时就没办法联通。所以电子邮件的客户/服务器编程的思想有一点另类，使用了一些中间计算机，就是邮件服务器，邮件服务器始终运行，当要发信或收信时，需先连接到邮件服务器上。邮件协议电子邮件需要在邮件客户端和邮件服务器之间，以及两个邮件服务器之间进行邮件传递，那就必须要遵守一定的规则，这个规则就是邮件传输协议：SMTP协议：全称为 Simple Mail Transfer Protocol，简单邮件传输协议。它定义了邮件客户端软件和SMTP邮件服务器之间，以及两台SMTP邮件服务器之间的通信规则。POP3协议：全称为 Post Office Protocol，邮局协议。它定义了邮件客户端软件和POP3邮件服务器的通信规则。IMAP协议：全称为 Internet Message Access Protocol，Internet消息访问协议，它是对POP3协议的一种扩展，也是定义了邮件客户端软件和IMAP邮件服务器的通信规则。邮件的格式一个邮件含有这么几个部分：收件人、发件人、抄送人、密送人、主题、内容（现在很多邮箱服务器的内容都支持富文本）、附件。收件人、主题就不说了。内容和附件的话我们等下看怎么用代码把文字&amp;图片&amp;附件发出去。我们现在解释抄送和密送：如果A 发送邮件给B、C，抄送给D、E，密送给F、G，那么：B、C、D、E、F、G都能收到这封邮件。B知道这是A发送给他和C的邮件，并且抄送给了D、E，但不知道密送给了F、G。D知道这是A发送给B、C的邮件，并且抄送给了他和E，但也不知道密送给了F、G。F知道这是A发送给B、C的邮件，并且抄送给了D、E，密送给了他，但不知道同时还密送给了G。Java完成发送jar包引入这个工具的jar包非常乱，为了避免问题，请严格使用下面的依赖。12345&lt;dependency&gt; &lt;groupId&gt;com.sun.mail&lt;/groupId&gt; &lt;artifactId&gt;javax.mail&lt;/artifactId&gt; &lt;version&gt;1.6.0&lt;/version&gt;&lt;/dependency&gt;类分析发送文本文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class SendMailText &#123; //发件人地址 public static String senderAddress = "@163.com"; //收件人地址 public static String recipientAddress = "@qq.com"; //发件人账户名 public static String senderAccount = "@163.com"; //发件人账户密码 public static String senderPassword = ""; public static void main(String[] args) throws Exception &#123; //1、连接邮件服务器的参数配置 Properties props = new Properties(); //设置用户的认证方式 props.setProperty("mail.smtp.auth", "true"); //设置传输协议 props.setProperty("mail.transport.protocol", "smtp"); //设置发件人的SMTP服务器地址 props.setProperty("mail.smtp.host", "smtp.163.com"); //2、创建定义整个应用程序所需的环境信息的 Session 对象 Session session = Session.getInstance(props); //设置调试信息在控制台打印出来 session.setDebug(true); //3、创建邮件的实例对象 Message msg = getMimeMessage(session); //4、根据session对象获取邮件传输对象Transport Transport transport = session.getTransport(); //设置发件人的账户名和密码 transport.connect(senderAccount, senderPassword); //发送邮件，并发送到所有收件人地址，message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 transport.sendMessage(msg, msg.getAllRecipients()); //如果只想发送给指定的人，可以如下写法 //transport.sendMessage(msg, new Address[]&#123;new InternetAddress("xxx@qq.com")&#125;); //5、关闭邮件连接 transport.close(); &#125; /** * 获得创建一封邮件的实例对象 * * @param session * @return * @throws MessagingException * @throws AddressException */ public static MimeMessage getMimeMessage(Session session) throws Exception &#123; //创建一封邮件的实例对象 MimeMessage msg = new MimeMessage(session); //设置发件人地址 msg.setFrom(new InternetAddress(senderAddress)); /** * 设置收件人地址（可以增加多个收件人、抄送、密送），即下面这一行代码书写多行 * MimeMessage.RecipientType.TO：发送 * MimeMessage.RecipientType.CC：抄送 * MimeMessage.RecipientType.BCC：密送 */ msg.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(recipientAddress)); // 为了防止邮箱服务器认定为垃圾邮件，抄送一份给自己，会大大降低失效概率 msg.setRecipient(MimeMessage.RecipientType.CC, new InternetAddress(senderAddress)); //设置邮件主题 msg.setSubject("邮件主题", "UTF-8"); //设置邮件正文，邮件正文可以支持html msg.setContent("&lt;h1&gt;简单的纯文本邮件！&lt;/h1&gt;", "text/html;charset=UTF-8"); //设置邮件的发送时间,默认立即发送 msg.setSentDate(new Date()); return msg; &#125;&#125;发送带附件和图片的邮件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101public class SendMailText_Picture_Enclosure &#123; //发件人地址 public static String senderAddress = "@163.com"; //收件人地址 public static String recipientAddress = "@qq.com"; //发件人账户名，账户名和密码一般是一样的，至于Sun公司为什么给他分开，需要去看smtp、pop3协议的了 public static String senderAccount = "@163.com"; //发件人账户密码 public static String senderPassword = ""; public static void main(String[] args) throws Exception &#123; //1、连接邮件服务器的参数配置 Properties props = new Properties(); //设置用户的认证方式 props.setProperty("mail.smtp.auth", "true"); //设置传输协议 props.setProperty("mail.transport.protocol", "smtp"); //设置发件人的SMTP服务器地址 props.setProperty("mail.smtp.host", "smtp.163.com"); //2、创建定义整个应用程序所需的环境信息的 Session 对象 Session session = Session.getInstance(props); //设置调试信息在控制台打印出来 session.setDebug(true); //3、创建邮件的实例对象 Message msg = getMimeMessage(session); //4、根据session对象获取邮件传输对象Transport Transport transport = session.getTransport(); //设置发件人的账户名和密码 transport.connect(senderAccount, senderPassword); //发送邮件，并发送到所有收件人地址，message.getAllRecipients() 获取到的是在创建邮件对象时添加的所有收件人, 抄送人, 密送人 transport.sendMessage(msg, msg.getAllRecipients()); //5、关闭邮件连接 transport.close(); &#125; /** * 获得创建一封邮件的实例对象 * * @param session * @return * @throws MessagingException * @throws AddressException */ public static MimeMessage getMimeMessage(Session session) throws Exception &#123; //1.创建一封邮件的实例对象 MimeMessage msg = new MimeMessage(session); //2.设置发件人地址 msg.setFrom(new InternetAddress(senderAddress)); /** * 3.设置收件人地址（可以增加多个收件人、抄送、密送），即下面这一行代码书写多行 * MimeMessage.RecipientType.TO：发送 * MimeMessage.RecipientType.CC：抄送 * MimeMessage.RecipientType.BCC：密送 */ msg.setRecipient(MimeMessage.RecipientType.TO, new InternetAddress(recipientAddress)); msg.setRecipient(MimeMessage.RecipientType.CC, new InternetAddress(senderAddress)); //4.设置邮件主题 msg.setSubject("毕业设计答辩论文", "UTF-8"); //下面是设置邮件正文 //msg.setContent("简单的纯文本邮件！", "text/html;charset=UTF-8"); // 5. 创建图片"节点" MimeBodyPart image = new MimeBodyPart(); // 读取本地文件 File file = new File("C:\\Users\\ISJINHAO\\Desktop\\3.jpg"); DataHandler dh = new DataHandler(new FileDataSource(file)); // 将图片数据添加到"节点" image.setDataHandler(dh); // 为"节点"设置一个唯一编号（在文本"节点"将引用该ID） image.setContentID("mailTestPic"); // 6. 创建文本"节点" MimeBodyPart text = new MimeBodyPart(); // 这里添加图片的方式是将整个图片包含到邮件内容中, 实际上也可以以http链接的形式添加网络图片 text.setContent("这是一张图片&lt;br/&gt;&lt;a href='http://www.cnblogs.com/ysocean/p/7666061.html'&gt;&lt;img src='cid:mailTestPic'/&gt;&lt;/a&gt;", "text/html;charset=UTF-8"); // 7. （文本+图片）设置 文本 和 图片"节点"的关系（将 文本 和 图片"节点"合成一个混合"节点"） MimeMultipart mm_text_image = new MimeMultipart(); mm_text_image.addBodyPart(text); mm_text_image.addBodyPart(image); mm_text_image.setSubType("related"); // 关联关系 // 8. 将 文本+图片 的混合"节点"封装成一个普通"节点" // 最终添加到邮件的 Content 是由多个 BodyPart 组成的 Multipart, 所以我们需要的是 BodyPart, // 上面的 mailTestPic 并非 BodyPart, 所有要把 mm_text_image 封装成一个 BodyPart MimeBodyPart text_image = new MimeBodyPart(); text_image.setContent(mm_text_image); // 9. 创建附件"节点" MimeBodyPart attachment = new MimeBodyPart(); // 读取本地文件 DataHandler dh2 = new DataHandler(new FileDataSource(new File("C:\\Users\\ISJINHAO\\Desktop\\4.jpg"))); // 将附件数据添加到"节点" attachment.setDataHandler(dh2); // 设置附件的文件名（需要编码） attachment.setFileName(MimeUtility.encodeText(dh2.getName())); // 10. 设置（文本+图片）和 附件 的关系（合成一个大的混合"节点" / Multipart ） MimeMultipart mm = new MimeMultipart(); mm.addBodyPart(text_image); mm.addBodyPart(attachment); // 如果有多个附件，可以创建多个多次添加 mm.setSubType("mixed"); // 混合关系 // 11. 设置整个邮件的关系（将最终的混合"节点"作为邮件的内容添加到邮件对象） msg.setContent(mm); //设置邮件的发送时间,默认立即发送 msg.setSentDate(new Date()); return msg; &#125;&#125;部分转至https://www.cnblogs.com/ysocean/p/7666061.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[方法功能的增强]]></title>
    <url>%2Fposts%2F18731.html%2F</url>
    <content type="text"><![CDATA[引言方法功能的增强是开发时常做的事情，当官方或者第三方提供的API不能满足我们的需要时，可以在原有API的基础上加上我们自定义的功能来实现需求。常见的功能增强的方式有三种：继承、装饰者模式、动态代理。准备工作现在有一个很火的概念：无人驾驶。假设无人驾驶的标准是Oracle公司制定的，Google想使用Java语言来开发无人驾驶系统，那么首先它需要创建一个类实现Oracle公司提供的无人驾驶的接口（接口为AIDriving，类为GoogleAIDriving）。AIDriving1234public interface AIDriving &#123; public void start(); //无人驾驶汽车启动的方法 public void stop(); //无人驾驶汽车停止的方法&#125;GoogleAIDriving12345678public class GoogleAIDriving implements AIDriving &#123; public void start() &#123; System.out.println("Google汽车启动了..."); &#125; public void stop() &#123; System.out.println("Google汽车停止了..."); &#125;&#125;继承这个时候国内某汽车制造公司（设为A公司）想使用Google提供的无人驾驶系统。但是Google提供的系统不太适合我国国情，所以A公司的工程师就想在Google系统的基础上进行定制。他们选择的方式是继承GoogleAIDriving，创建一个自己的类：A1GoogleAIDriving。12345678910public class A1GoogleAIDriving extends GoogleAIDriving&#123; public void start() &#123; System.out.println("在中国启动汽车"); super.start(); &#125; public void stop() &#123; System.out.println("在中国停止汽车"); super.stop(); &#125;&#125;装饰者模式但理想很美好，现实很残忍。GoogleAIDriving被定义为一个final类（不能被继承），这个是可以理解的，因为如果GoogleAIDriving不是一个final类，任何继承GoogleAIDriving的类都可以对其start()、stop()方法进行覆盖，如果覆盖时出现bug就可能会出现大问题。所以像启动、停止这种核心功能是不允许汽车制造商随意修改的。A公司的工程师就想到了使用装饰者模式来增强功能（设类为A2GoogleAIDriving）。装饰者模式该怎么做呢？首先，装饰类得和被装饰类实现相同的接口，即AIDriving；第二，在装饰类中定义一个AIDriving类型的属性，即AIDriving car；第三，有一个参数为AIDriving类型的构造函数，即A2GoogleAIDriving(AIDriving car)；第四，装饰类的每个方法都要调用被装饰类相应的方法；第五，使用第三步中的构造函数创建装饰类；第六，在装饰类的方法中自定义功能。创建装饰类1234567891011121314public class A2GoogleAIDriving implements AIDriving &#123; private AIDriving car; public A2GoogleAIDriving(AIDriving car) &#123; this.car = car; &#125; public void start() &#123; System.out.println("在中国启动汽车..."); car.start(); &#125; public void stop() &#123; System.out.println("在中国停止汽车..."); car.stop(); &#125;&#125;调用装饰类12345678910public class Test &#123; public static void main(String[] args) &#123; GoogleAIDriving car = new GoogleAIDriving(); A2GoogleAIDriving aCar = new A2GoogleAIDriving(car); aCar.start(); /* Console : 在中国启动汽车... Google汽车启动了... */ &#125;&#125;动态代理A公司工程师正沉浸在胜利到来前的喜悦中，突然他们发现AIDriving接口有1000个方法，所以在装饰类中其他不需要加入自定义动能的998个方法我们也要调用。这一看就不是一个好的解决方案，A公司的某大佬就想起来动态代理。动态代理中可以使用反射技术得到方法的信息，如果是start()或者stop()方法就加上自定义的功能，其他方法直接执行。A3GoogleAIDriving123456789101112131415161718192021222324252627public class A3GoogleAIDriving&#123; private AIDriving car; public A3GoogleAIDriving(AIDriving car) &#123; this.car = car; &#125; public AIDriving getIns() &#123; AIDriving a3GoogleAIDriving = (AIDriving)Proxy.newProxyInstance( GoogleAIDriving.class.getClassLoader(), GoogleAIDriving.class.getInterfaces(), new InvocationHandler() &#123; public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; if(method.getName().equals("start") &amp;&amp;method.getParameterTypes().length == 0) &#123; System.out.println("在中国启动汽车..."); return method.invoke(car, args); &#125;else if (method.getName().equals("stop") &amp;&amp;method.getParameterTypes().length == 0) &#123; System.out.println("在中国停止汽车..."); return method.invoke(car, args); &#125; return method.invoke(car, args); &#125; &#125;); return a3GoogleAIDriving; &#125;&#125;执行A3GoogleAIDriving123456789101112public static void main(String[] args) throws Exception &#123; GoogleAIDriving car = new GoogleAIDriving(); A3GoogleAIDriving a3GoogleAIDriving = new A3GoogleAIDriving(car); AIDriving ins = a3GoogleAIDriving.getIns(); ins.start(); ins.stop(); /* Console : 在中国启动汽车... Google汽车启动了... 在中国停止汽车... Google汽车停止了... */&#125;三种方式总结分析了三种方式的功能增强，各位大腿是不是被博主带入了一个误区：后者比前者更好？按照存在即合理的解释，肯定不是这样的。相反，三种方法中继承却是最常见的增强方式，因为它结构简单、易于理解。而后两种都是设计模式，一般在大型软件开发时才会用到。而且对于装饰者模式和动态代理的区别是：装饰者模式一般用于增强功能，动态代理一般用于拦截对方法的请求。装饰者模式解决Web开发乱码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162/** * @ClassName: RequestEncodingUtils * @Description: TODO(解决request乱码的工具类) * @author 詹金浩 * @date 2018年3月11日 下午2:27:04 */public class RequestEncodingUtils extends HttpServletRequestWrapper &#123; private HttpServletRequest request; private Boolean isEncoded = false; public RequestEncodingUtils(HttpServletRequest request) &#123; super(request); this.request = request; &#125; @Override public Map&lt;String, String[]&gt; getParameterMap() &#123; String method = request.getMethod(); Map&lt;String, String[]&gt; parameterMap = request.getParameterMap(); //处理Post请求 if(method.equalsIgnoreCase("post")) &#123; try &#123; request.setCharacterEncoding("utf-8"); parameterMap = request.getParameterMap(); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125;else if (method.equalsIgnoreCase("get")) &#123; //处理Get请求 //保证编码只被执行一次 if(!isEncoded) &#123; for(String key : parameterMap.keySet()) &#123; String []values = parameterMap.get(key); if(values != null) &#123; for(int i = 0; i &lt; values.length; i++) &#123; try &#123; values[i] = new String(values[i].getBytes("ISO-8859-1"),"utf-8"); &#125; catch (UnsupportedEncodingException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; isEncoded = true; &#125; return parameterMap; &#125; @Override public String[] getParameterValues(String name) &#123; Map&lt;String, String[]&gt; parameterMap = this.getParameterMap(); String []values = parameterMap.get(name); return values; &#125; @Override public String getParameter(String name) &#123; String []values = getParameterValues(name); return values!=null?values[0]:null; &#125;&#125;123456789101112131415161718192021222324252627282930313233343536/** * @ClassName: GlobalEncoding * @Description: TODO(解决全局编码的filter) * @author 詹金浩 * @date 2018年3月10日 下午10:26:09 */@WebFilter("/*")public class GlobalEncoding implements Filter &#123; /** * Default constructor. */ public GlobalEncoding() &#123; // TODO Auto-generated constructor stub &#125; public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; response.setContentType("text/html;charset=UTF-8"); RequestEncodingUtils myRequest = new RequestEncodingUtils((HttpServletRequest)request); chain.doFilter(myRequest, response); &#125; /** * @see Filter#destroy() */ public void destroy() &#123; // TODO Auto-generated method stub &#125; /** * @see Filter#doFilter(ServletRequest, ServletResponse, FilterChain) */ /** * @see Filter#init(FilterConfig) */ public void init(FilterConfig fConfig) throws ServletException &#123; // TODO Auto-generated method stub &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件开发文档用图]]></title>
    <url>%2Fposts%2F14908.html%2F</url>
    <content type="text"><![CDATA[系统流程图表达的是数据在系统各部件之间流动的情况，但不表达对数据进行加工处理的控制过程。基本思想：用图形符号以黑盒子形式描绘组成系统的每个部件（程序，文档，数据库，人工过程等），表达数据在系统各部件之间流动的情况。符号装配厂供货流程图某装配厂有一座存放零件的仓库，仓库中现有的各种零件的数量以及每种零件的库存量临界值等数据记录在库存清单主文件中。当仓库中零件数量有变化时，应该及时修改库存清单主文件，如果哪种零件的库存量少于它的库存量临界值，则应该报告给采购部门以便订货，规定每天向采购部门送一次订货报告。该装配厂使用一台小型计算机处理更新库存清单主文件和产生订货报告的任务。零件库存量的每一次变化称为一个事务，由放在仓库中的CRT终端输入到计算机中；系统中的库存清单程序对事务进行处理，更新存储在磁盘上的库存清单主文件，并且把必要的订货信息写在磁带上。最后，每天由报告生成程序读一次磁带，并且打印出订货报告。人工销售教材流程图计算机售书系统流程图数据流图符号通过图形的方法，从数据传递和数据处理的角度，刻画数据流从输入到输出的移动变换过程。数据流三个重要属性：数据流名字数据组成流向银行取款过程的数据流图数据流程图分层顶层流图仅包含一个数据处理，它代表被开发系统。它的输入流是该系统的输入数据，输出流是系统所输出数据底层流图是指其数据处理不需再做分解的数据流图，它处在最底层中间层流图则表示对其上层父图的细化。它的每一数据处理可能继续细化，形成子图商场业务处理系统的分层数据流图商场进货时，先发订货单给供应商，供应商收到订货单，将商品发给商场，商场货到付款，供应商收款后，将收据发给商场；当顾客到商场采购商品时，先下购物订单，商场查询库存中是否有此种商品，若有则发货给顾客；若没有，则向供应商订货，货到之后再销售给顾客；顾客收到货物之后付款，商场开收据给顾客；商场对货物的管理方面要求知道每种货物详细的销售情况。绘制L0层数据流图首先从问题的描述中提取数据流图中的源（终）点、数据处理、数据流和数据存储四种成份。分析源（终）点：将商场的购、销业务系统看成一个整体，外部的与这个系统有交往的对象（机构、人员、或外部系统）是“供应商，和“顾客”，二者是商场购销系统源点和终点。分析数据处理：在顶层数据流图的处理中，用一个整体来表示分析数据流：供应商方 $\rightarrow$ 商场：发货单、货款收据顾客 $\rightarrow$ 商场：订单、货款商场 $\rightarrow$ 供货商：订货单、货款商场 $\rightarrow$ 顾客：货物、收据分析数据存储库存信息暂存订单（缺货订单）采购订单商品销售历史资金帐目绘制L1层数据流图商店业务处理的主要数据处理是销售、采购、会计三大数据处理，三者之间的数据流：销售 $\rightarrow$ 采购：订货通知销售 $\rightarrow$ 会计：收款单会计 $\rightarrow$ 销售：收据采购 $\rightarrow$ 销售：到货通知采购 $\rightarrow$ 会计：付款单绘制L2层数据流图销售细化采购细化教务管理系统某校准备开发一个学生成绩管理系统。在该系统中，教务人员录入学生信息、课程信息和成绩信息，学生可以随时查询自己所选课程的成绩。由于学生成绩属于敏感信息，系统必须提供必要的安全措施以防非法存取。绘制L0层数据流图源点终点：教务人员（源点）；学生（终点）数据处理：将系统当成一个整体“学生成绩管理”数据流：学生信息、课程信息和成绩；（教务人员录入时）查询请求、查询结果（学生查询时）数据文件：成绩文件、学生文件、课程文件。教务人员维护学生信息和课程信息，并登录学生的选课成绩；学生查询自己的成绩单。绘制L1层数据流图“学生信息”是教务人员需要录入的一个信息，因此加入一个加入“录入学生信息” ；同样得到“录入课程信息”、“登记成绩”两个数据处理。另外，数据流“查询请求”和“查询结果”应该由数据处理“查询成绩”来完成。对第 0 层 DFD 的加工“学生成绩管理“进行展开。数据处理：录入学生信息录入课程信息登记学生成绩查询学生成绩数据存储：增加这些数据流对应的数据存储，即“学生”、“课程”和“成绩” ，最后得到如图所示的第 1 层 DFD 。绘制L2层数据流图继续分解第 1 层 DFD 中的加工“查询学生成绩”数据处理：分解为“合法性检查”和“查询成绩”数据文件：合法的查询条件状态转换图语法在状态图中：初态用实心圆表示；终态用一对同心圆（内圆为实心圆）表示。中间状态用圆角矩形表示，可以用两条水平横线把它分成上、中、下3个部分。上面部分为状态的名称（必须）；中间部分为状态变量的名字和值（可选）；下面部分是活动表（可选）。活动表的语法格式事件名(参数表)/动作表达式。在活动表中经常使用下述3种标准事件：entry, exit和do。entry事件指定进入该状态的动作；exit事件指定退出该状态的动作；do事件则指定在该状态下的动作。活动表中的动作表达式描述应做的具体动作。事件表达式的语法事件说明［守卫条件］／动作表达式其中事件说明的语法为：事件名(参数表)。举例结构图模块关系一个方框表示一个模块；一个模块指向另一个模块的箭头或直线，表示前一模块对后一模块的调用；调用直线边的小箭头，表示调用时从一个模块传给另一个模块的数据，也指出了传送方向。四种模块从下属模块取得数据，经过处理，再传入上级模块从上级模块获得数据，经过处理，再传送给下属模块加工模块。从上级模块获得数据，经过处理，转换成其他形式，再送回上级模块对所有下属模块进行协调和管理的模块医院管理系统选择/循环调用变换型SCDFD第一级分解后 SC 的数据流传入分支的分解传出分支的分解中心加工分支的分解事务型SCDFD分解系统设置控制器分解密码处理控制器程序流程图符号(a) 选择(分支)； (b) 注释； (c) 预先定义的处理； (d) 多分支； (e) 开始或停止； (f) 准备； (g) 循环上界限； (h) 循环下界限； (i) 虚线； (j) 省略符； (k) 并行方式； (l) 处理； (m) 输入输出； (n) 连接； (o) 换页连接； (p) 控制流例子盒图符号例子PAD图符号顺序(先执行P1后执行P2)；选择(IF C THEN P1 ELSE P2);CASE型多分支；WHILE型循环(WHILE C DO P);UNTIL型循环(REPEAT P UNTIL C)；语句标号；定义PAD 描述的示例判定表例子检查发货单判定表判定树程序图从流程图导出程序图]]></content>
      <categories>
        <category>课内学习</category>
      </categories>
      <tags>
        <tag>课内学习</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计算机体系结构]]></title>
    <url>%2Fposts%2F60393.html%2F</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>课内学习</category>
      </categories>
      <tags>
        <tag>课内学习</tag>
        <tag>计算机体系结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高德API使用-查询市内公交]]></title>
    <url>%2Fposts%2F23418.html%2F</url>
    <content type="text"><![CDATA[POJOlocation.java12345678910111213141516171819202122232425262728package pojo;public class Location &#123; private String key; private String location; private String city; public String getLocation() &#123; return location; &#125; public void setLocation(String location) &#123; this.location = location; &#125; public String getCity() &#123; return city; &#125; public void setCity(String city) &#123; this.city = city; &#125; public String getKey() &#123; return key; &#125; public void setKey(String key) &#123; this.key = key; &#125; @Override public String toString() &#123; return "Location [key=" + key + ", location=" + location + ", city=" + city + "]"; &#125;&#125;RoutePojo.java1234567891011121314151617181920212223242526272829package pojo;import java.util.List;public class RoutePojo &#123; private long time; // 秒 private double cost; // 元 private List&lt;SegmentPojo&gt; segments; // 分段信息 public long getTime() &#123; return time; &#125; public void setTime(long time) &#123; this.time = time; &#125; public double getCost() &#123; return cost; &#125; public void setCost(double cost) &#123; this.cost = cost; &#125; public List&lt;SegmentPojo&gt; getSegments() &#123; return segments; &#125; public void setSegments(List&lt;SegmentPojo&gt; segments) &#123; this.segments = segments; &#125; @Override public String toString() &#123; return "RoutePojo [time=" + time + ", cost=" + cost + ", segments=" + segments + "]"; &#125;&#125;SegmentPojo.java12345678910111213141516171819202122232425262728293031323334353637383940414243444546package pojo;/** * 一段路径。RoutePojo的一段，有步行、公交、地铁 * @author ISJINHAO */public class SegmentPojo &#123; private String type; private String start; private String end; private String vias; private String name; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getType() &#123; return type; &#125; public void setType(String type) &#123; this.type = type; &#125; public String getStart() &#123; return start; &#125; public void setStart(String start) &#123; this.start = start; &#125; public String getEnd() &#123; return end; &#125; public void setEnd(String end) &#123; this.end = end; &#125; public String getVias() &#123; return vias; &#125; public void setVias(String vias) &#123; this.vias = vias; &#125; @Override public String toString() &#123; return "SegmentPojo [type=" + type + ", start=" + start + ", end=" + end + ", vias=" + vias + "]"; &#125;&#125;查询经纬度，由经纬度查询市内公交123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211package test;import java.util.ArrayList;import java.util.List;import org.apache.http.HttpEntity;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClientBuilder;import org.apache.http.util.EntityUtils;import com.alibaba.fastjson.JSON;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import pojo.Location;import pojo.RoutePojo;import pojo.SegmentPojo;public class GaoDeUtils &#123; private static CloseableHttpClient httpClient = HttpClientBuilder.create().build(); /** * @param origin * 起点经纬度 * @param dst * 终点经纬度 * @param city * 城市名 * @param strategy * 0：最快捷模式; 1：最经济模式; 2：最少换乘模式; 3：最少步行模式; 5：不乘地铁模式 * @param dateTime（可选） * 日期时间，格式：2014-03-19 22:34 * @return */ public static RoutePojo cityInnerGuide(String origin, String dst, String city, String strategy, String... dateTime) &#123; String url = "https://restapi.amap.com/v3/direction/transit/integrated?strategy=" + strategy + "&amp;origin=" + origin + "&amp;destination=" + dst + "&amp;key=d4393e4b379c905601d89f62b8c0c0aa&amp;city=" + city; // 处理日期时间 int argsNum = dateTime.length; if (argsNum &gt; 1) &#123; return null; &#125; else if (argsNum == 1) &#123; url = url + "&amp;date=" + dateTime[0].split(" ")[0] + "&amp;time=" + dateTime[0].split(" ")[1]; &#125; // 创建Get请求 HttpGet httpGet = new HttpGet(url); // 响应模型 CloseableHttpResponse response = null; try &#123; // 由客户端执行(发送)Get请求 response = httpClient.execute(httpGet); // 从响应模型中获取响应实体 HttpEntity responseEntity = response.getEntity(); if (responseEntity == null) return null; // 整个结果 JSONObject result = JSON.parseObject(EntityUtils.toString(responseEntity)); // 和路径有关的信息 JSONObject routes = result.getJSONObject("route"); // 查询出来的路径个数// int ways = Integer.parseInt(result.getString("count")); // 所有路径的详细信息 JSONArray transits = routes.getJSONArray("transits"); // for (int i = 0; i &lt; ways; i++) &#123; // 一条路径 JSONObject route = (JSONObject) transits.get(0); RoutePojo rp = new RoutePojo(); // 此路径的花费 rp.setCost(Double.valueOf(route.getString("cost"))); // 此路径的时间 rp.setTime(Long.valueOf(route.getString("duration"))); // 每条路径的分段 JSONArray segments = (JSONArray) route.get("segments"); // 每条路径经过的 段数 int segmentsSize = segments.size(); List&lt;SegmentPojo&gt; segList = new ArrayList&lt;&gt;(); for (int j = 0; j &lt; segmentsSize; j++) &#123; // 每个子段。每个子段都包含三种方式：步行、地铁、公交。地铁和公交不会同时存在。 JSONObject path = (JSONObject) segments.get(j); // 解析 步行 SegmentPojo segWalking = new SegmentPojo(); segWalking.setType("WALKING"); // 如果需要换乘，解析为JSONObject。如果不需要换乘解析为JSONArray try &#123; JSONObject walking = path.getJSONObject("walking"); JSONArray steps = walking.getJSONArray("steps"); int stepSize = steps.size(); String instructions = ""; for (int k = 0; k &lt; stepSize; k++) &#123; JSONObject step = (JSONObject) steps.get(k); String instruction = step.getString("instruction"); instructions = instructions + "`" + instruction; &#125; segWalking.setVias(instructions.substring(1)); &#125; catch (Exception e) &#123; segWalking.setVias("在此站换乘！"); &#125; segList.add(segWalking); // 解析 出租车 // JSONArray taxi = path.getJSONArray("taxi"); int flag = 0; // 如果是公交车，解析为JSONArray，不是公交车，解析为JSONObject try &#123; path.getJSONArray("exit"); &#125; catch (Exception e) &#123; flag = 1; &#125; SegmentPojo segBus = new SegmentPojo(); // 获得bus和sub的信息，字段都是 bus JSONObject bus = path.getJSONObject("bus"); JSONArray buslinesHelp = (JSONArray) bus.getJSONArray("buslines"); if (buslinesHelp.size() &lt; 1) &#123; break; &#125; JSONObject buslines = (JSONObject) buslinesHelp.get(0); JSONArray viaStops = buslines.getJSONArray("via_stops"); // 处理bus和sub的公交经停 String vias = ""; int viaSize = viaStops.size(); for (int k = 0; k &lt; viaSize; k++) &#123; JSONObject stop = (JSONObject) viaStops.get(k); vias = vias + "`" + stop.getString("name"); &#125; if (vias.length() &gt; 0) segBus.setVias(vias.substring(1)); // 设置公交路线 segBus.setName(buslines.getString("name")); // 处理公交车 if (flag == 0) &#123; segBus.setType("BUS"); // 设置起点 JSONObject departureStop = buslines.getJSONObject("departure_stop"); segBus.setStart(departureStop.getString("name")); // 设置终点 JSONObject arrivalStop = buslines.getJSONObject("arrival_stop"); segBus.setEnd(arrivalStop.getString("name")); segList.add(segBus); &#125; else if (flag == 1) &#123; segBus.setType("SUB"); JSONObject exitObject = path.getJSONObject("exit"); // 设置起点 JSONObject departureStop = buslines.getJSONObject("departure_stop"); // 不用换站使用JSONArray解析，换站使用JSONObject解析 try &#123; JSONObject entranceObject = path.getJSONObject("entrance"); segBus.setStart(departureStop.getString("name") + "`" + entranceObject.getString("name")); &#125; catch (Exception e) &#123; segBus.setStart(departureStop.getString("name") + "`在此站换乘！"); &#125; // 设置终点 JSONObject arrivalStop = buslines.getJSONObject("arrival_stop"); segBus.setEnd(arrivalStop.getString("name") + "`" + exitObject.getString("name")); segList.add(segBus); &#125; &#125; rp.setSegments(segList); return rp; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return null; &#125; /** * * @param keyWords * 关键字，务必尽量准确 * @param types * 所有地点：all 交通运输类：150000 机场类：150100 火车站类：150200 公交车：150700 地铁类 150500 * 轻轨类：150600 * @param city * 限定查询的城市 * @return */ public static Location getLocation(String keyWords, String types, String city) &#123; Location loc = new Location(); loc.setKey(keyWords); String url = "https://restapi.amap.com/v3/place/text?keywords=" + keyWords + "&amp;city=" + city + "&amp;key=d4393e4b379c905601d89f62b8c0c0aa&amp;offset=1&amp;page=1&amp;extensions=all"; if (!"all".equals(types)) &#123; url = url + "&amp;types=" + types; &#125; // 创建Get请求 HttpGet httpGet = new HttpGet(url); // 响应模型 CloseableHttpResponse response = null; try &#123; // 由客户端执行(发送)Get请求 response = httpClient.execute(httpGet); // 从响应模型中获取响应实体 HttpEntity responseEntity = response.getEntity(); if (responseEntity == null) return null; JSONObject result = JSON.parseObject(EntityUtils.toString(responseEntity)); System.out.println(result); if ("0".equals(result.getString("count"))) return null; // 获得第一个poi JSONObject poi = (JSONObject) result.getJSONArray("pois").get(0); // 经纬度 String location = poi.getString("entr_location"); // 结构化城市名：省（直辖市）`市（直辖市）`县区 String structureName = poi.getString("pname") + "`" + poi.getString("cityname") + "`" + poi.getString("adname"); loc.setLocation(location); loc.setCity(structureName); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; if("[]".equals(loc.getLocation())) return null; return loc; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件测试]]></title>
    <url>%2Fposts%2F26323.html%2F</url>
    <content type="text"><![CDATA[什么是软件测试使用人工或自动手段来运行或测定某个系统的过程，其目的在于检验它是否满足规定的需求或是弄清预期结果与实际结果之间的差别。软件测试是根据软件开发各阶段的规格说明和程序的内部结构而精心设计一批测试用例，并利用这些测试用例去执行程序，以发现软件故障的过程。软件测试是一种软件质量保证活动，其动机是通过一些经济有效的方法，发现软件中存在的缺陷，从而保证软件质量。几个概念错误 Error：错误是针对人来说的，人非圣贤，孰能无过？缺陷 Bug：由于人为的错误，在软件中引入了Bug。故障 Fault：带有Bug的软件在某种条件下被激活，称为Fault。失效 Failure：如果没能及时解决Fault，便会导致失效。软件测试的原则不可能进行完全测试软件测试只能表明缺陷的存在，而不能证明产品已经没有缺陷软件产品中所存在的缺陷数与已发现的缺陷数成正比软件测试的杀虫剂效应由于测试人员的思路不尽相同，每个人测试的侧重点不同，由于都按照测试用例进行测试，但是测试用例一般仅描述系统的一些基本测试项，不会将所有的测试用例方方面面都写到，有时还需要测试人员的经验和素质。所以A测试某个产品用了七个工作日，第一天到第四天报出许多bug，但从第5天开始几乎报不出啥bug了。七天后换了B，B一下子又测试出一堆bug，不能说A的水平差，只能说该产品已经对A产生了抗药性，这就是测试学中的杀虫剂现象。所以在测试中每次轮流测试最好安排不同的测试人员进行不同模块测试工作，以避免杀虫剂现象。尽早测试的原则WHY SHOULD WE “FIX”BUGS ASAP?LIKE MANY LIVING CREATURES, BUGS GROW IN SIZE THROUGHOUT THEIR LIFE. IT IS DESIRABLE TO DISCOVER AND EXTERMINATE BUGS SOON AFTER CONCEPTION.回归测试的原则Regression: “when you fix one bug, you introduce several newer bugs.”软件测试的价值-微笑模型软件测试的内容软件测试过程单元测试针对函数或类中的方法进行的测试检查函数功能和函数内部实现是否和详细设计说明书相符驱动和桩假设现在项目组把任务分给了7个人，每个人负责实现一个模块。你负责的是B模块，你很优秀，第一个完成了编码工作，现在需要开展单元测试工作，先分析结构图：由于B模块不是最顶层模块，所以它一定不包含main函数（A模块包含main函数），也就不能独立运行。B模块调用了D模块和E模块，而目前D模块和E模块都还没有开发好，那么想让B模块通过编译器的编译也是不可能的。那么怎样才能测试B模块呢？需要做：写两个模块Sd和Se分别代替D模块和E模块（函数名、返回值、传递的参数相同），这样B模块就可以通过编译了。Sd模块和Se模块就是桩模块。写一个模块Da用来代替A模块，里面包含main函数，可以在main函数中调用B模块，让B模块运行起来。Da模块就是驱动模块。知识点：桩模块的使命除了使得程序能够编译通过之外，还需要模拟返回被代替的模块的各种可能返回值（什么时候返回什么值需要根据测试用例的情况来决定）。驱动模块的使命就是根据测试用例的设计去调用被测试模块，并且判断被测试模块的返回值是否与测试用例的预期结果相符集成测试针对单元、模块或者子系统间接口进行的测试检查接口和集成后的功能是否和概要设计说明书相符合在把各模块连接起来的时候，穿越模块接口的数据是否会丢失。案例案例一某软件公司测试人员在测试某法院办案办公系统时，先通过具有分配案件权限的用户登录，为某案件选择承办部门，测试人员故意为该案件选择了错误的承办部门，比如状态为立案侦查的案件，本应选择侦查部门作为承办部门，却选择了民事行政。结果当以民事行政的身份登录到系统时，却并没有发现该案件，再以具有分配案件权限的用户登录，也没有发现该案件。可以料想与该案件有关的记录已经被存入了数据库，但却无法取出。由于用户操作失误，引起了数据在模块间流转中发生了丢失，系统应该对这种操作失误进行处理，保证数据的完整性。一个模块的功能是否会对另一个模块的功能产生不利的影响。案例二电信系统中经常会发生一些异常话单，例如无主叫话单、无被叫话单、超长话单、超短话单、通话同时进行等错误的异常话单。测试人员要注意测试这些异常话单是否对电信计费无影响。当一个模块的功能对另一个模块有不良影响时，其中一个模块要进行处理。案例三某石油公司管理系统的地区数据库入库省数据库，在测试人员测试过程中发现，当地方数据库中某条记录有误时，省数据库的处理是将全部数据全都回滚，包括正确的记录，这样的处理方式显然是不合理的，当省数据库发现错误记录时，应告之地方数据库，而不是把所有的数据库回滚回去。others上面只是提到了集成测试中需要注意的一部分问题，还有：各个子功能组合起来，能否达到预期要求的父功能。全局数据结构是否有问题。单个模块的误差累积起来，是否会放大，从而达到不能接受的程度。模块间是否存在时序问题（实时系统）与资源竞争。接口接口用于不同单元、模块、子系统或者系统间进行信息交互。接口类型函数接口消息接口文件接口数据库接口共享内存接口类接口。。。集成测试策略大爆炸集成自顶向下集成自底向上集成确认测试对照软件需求规格说明书对软件产品进行评估以确认其是否满足软件需求测试内容包括：功能、性能、可移植性、兼容性、可维护性、人机接口等给出结论性评价合格不合格，给出缺陷清单系统测试针对集成后的整个系统进行的测试检查集成后的整个系统功能、性能、易用性等特性是否和需求规格说明书相符合系统类型桌面软件Web系统嵌入式系统移动应用开放平台应用浏览器扩展/插件验收测试针对系统在用户实际使用环境下使用进行的测试检查系统在实际使用环境下是否和用户需求相一致验收测试正式验收测试：第三方验收测试α测试：用户验收测试（开发环境、有人指导、受控）β测试：用户验收测试（实际环境、无人指导、不受控）软件测试模型瀑布模型V模型明确地表明了测试的不同级别，清晰地展示了软件测试与开发之间的关系每一测试阶段的前提和基础是对应开发阶段的文档W模型测试活动伴随整个软件开发生命周期测试对象不仅包括程序，还包括需求和设计阶段形成的各种文档H模型测试流程独立于其他流程其他流程包括开发、设计和评审等支持反复和迭代过程软件测试环境的搭建硬件环境软件环境网络环境数据准备测试工具软件质量度量外部质量和内部质量模型功能性适合性：功能有没有准确性：功能准不准互操作性：与其它系统交互安全保密性：信息安全、权限控制功能性依从性：是否符合标准可靠性成熟性：对软件内部错误处理能力容错性：对软件外部错误处理能力易恢复性：从故障或失效恢复的能力可靠性依从性：是否符合标准易用性易理解性：界面提示易学性：帮助易操作性：操作步骤数吸引性：外观、颜色易用性依从性：是否符合标准效率时间特性：花费多长时间资源利用性：占用多少内存、CPU效率依从性：是否符合标准维护性易分析性：容易定位缺陷易改变性：容易修改代码稳定性：内部接口稳定易测试性：容易被操作、观察维护性依从性：是否符合标准可移植性适应性：可以在各种环境下使用易安装性：容易在各种环境下安装共存性：可以与其它软件共存易替换性：很容易更换版本使用质量模型有效性在特定的使用环境下，用户执行任务时能否准确和完全的达到规定目标。生产率在特定使用环境下，用户为达到有效性消耗的资源，如时间、金钱等安全性在特定使用环境下，对用户人身财产产生伤害的风险级别满意度特定的使用环境下用户对软件使用的态度黑盒测试又称功能测试或基于规格说明的测试与软件具体实现无关，变化后原测试用例仍可使用可与软件实现同步进行，压缩项目总的开发时间用例设计系统业务熟悉模型-SFDPOT模型。Structure系统架构Function系统功能Data数据处理Platform平台支持Operation用户操作Time时间影响综合案例Structure：客户端和服务器端间通过UDP包和TCP包混合传输数据Function：登录、聊天、文件传输Data：聊天记录保存、在线状态更新Platform：支持Windows、Linux、AndroidOperation：用户以年轻人为主，且很多为非技术用户Time：用户会在不同时区登录和使用通用测试用例写作用例编号测试项目测试标题重要级别预置条件观察点检查点测试步骤预期结果| 用例编号 | F-01-001 || :———-: | :————————————: || 测试项目 | 登录功能 || 测试标题 | 测试有效用户登录 || 重要级别 | 高 || 预置条件 | 用户事先没有登录或已经退出系统 || 观察点 | 系统主页 || 检查点 | 左上角登录标签显示内容 || 测试步骤 | 输入用户名admin和密码123后点击登录按钮 || 预期结果 | 进入系统主页并显示欢迎您：admin字样 |等价类划分法输入域的某个互不相交的子集并集等于整个输入域对测试的意义完备性无冗余性等价类划分有效等价类符合程序规格说明书有意义，合理的数据无效等价类不符合程序规格说明书无意义或者不合理的数据等价类划分原则按区间划分：区间内、区间外按数值划分：一个值一个按数值集合划分：集合内、集合外按限制条件或规则划分细分等价类等价类用例设计原则设计一个测试用例，使其尽可能多的覆盖所有尚未覆盖的有效等价类。重复这一步骤，使得有效等价类均被测试用例所覆盖。设计一个测试用例，使其只覆盖一个无效等价类。重复这一步骤使得所有无效等价类均被覆盖。案例某保险公司人寿保险的保费计算方式为：保费＝投保额×保险费率保险费率根据年龄、性别、婚姻状况和抚养人数的不同而有所不同，体现在不同年龄、性别、婚姻状况和抚养人数，点数设定不同，10点及10点以上保险费率为0.6%，10点以下保险费率为0.1%数据需求分析年龄：一位或两位非零整数，取值的有效范围为1-99。性别：一位英文字符，只能取 ‘M’或’F’ 值。婚姻：字符，只能取‘已婚’或‘未婚’。抚养人数：空白或字符‘无’或一位非零整数（1-9）点数 ：一位或两位非零整数，取值范围为8-19等价类划分输入输入条件有效等价类无效等价类年龄1-2位非0整数，有效范围为1-9920-39、40-59、1-19、60-99大于99小于1负数非数字性别一个英文字符，且只能取M或FM、F长度为1的其他英文字符长度大于1长度等于0非英文字符婚姻字符，只能取“已婚”或“未婚”“已婚”、“未婚”其他字符抚养人数空白或者字符“无”或1-9之间的一位整数空白、“无”、1-6、7-9除空白或“无”之外的其他字符小于1大于9测试用例用例编号年龄性别婚姻抚养人数预期输出127M已婚空白0.60%250F未婚无0.60%370M已婚10.10%427F未婚70.60%50M已婚空白年龄错误6100F未婚无年龄错误750男已婚4性别错误827M离婚7婚姻错误945F已婚没有抚养人数错误1062M未婚0抚养人数错误1130F已婚10抚养人数错误边界值分析法错误往往出现在边界处，如：&lt;写成&lt;=第一个、最后一个最小值、最大值开始、完成超过、未超过空、满最短/最长; 最快/最慢; 最高/最低相邻/最远程序含有n个变量。选择其中一个变量依次取min、min+、nom、max-、max。若采用健壮性边界值测试，另外增加min-和max+。其余变量取正常值，总共有4n+1 / 6n+1个测试用例。案例11-100之间的三条边构成何种三角形？案例2案例3对于方法int textSearch(char* txt, char* s)。txt和s均为字符串，返回s在txt中的起始位置，如果txt中不含s，返回-1。| No | S | txt || —- | ——— | ——————————- || 1 | | Laughter is good for the heart. || 2 | Laughter | || 3 | | || 4 | good for | Laughter is good for the heart. || 5 | Laughter | Laughter is good for the heart. || 6 | aughter | Laughter is good for the heart. || 7 | gLaughter | Laughter is good for the heart. || 8 | heart. | Laughter is good for the heart. || 9 | heart | Laughter is good for the heart. || 10 | heart.d | Laughter is good for the heart. |因果图法因果图基本符号因果图约束符号因果图法测试用例设计步骤确定原因和结果（输入和输出）确定逻辑关系确定约束关系转换为决策表设计测试用例案例1输入第一个字符必须是#或者*，第二个字符必须是数字，在此情况下进行文件的修改。如果第一个字符不正确，给出信息N。如果第二个字符不正确，给出信息M。案例2若落点在棋盘外，则不移动棋子；若落点与起点不构成日字型，则不移动棋子；若绊马腿，则不移动棋子；若落点处有己方棋子，则不移动棋子；若不属于1-4条，且落点处无棋子，则移动棋子；若不属于1-4条，且落点处为对方棋子（非老将），则移动棋子并除去对方棋子；若不属于1-4条，且落点处为对方老将，则移动棋子，并提示战胜对方，游戏结束。原因棋盘内成日字绊马腿己方子无棋子对方子(非老将)对方将结果不动跳马吃掉对方棋子战胜决策表法适用于描述复杂的业务规则（输入输出较多，且制约关系比较多）条件桩条件项动作桩动作项案例NextDate(month, day, year)month, day, year都是整数、month:[1-12]、day:[1-31]、year:[1900-2050]动作A1：不可能A2：day加1A3：day复位为1A4：month加1A5：month复位为1A6：year加1条件决策表白盒测试控制流测试语句覆盖程序中的每个可执行语句至少被执行一次。流程图中的节点全部被覆盖。分支覆盖/判定覆盖程序中每个分支都至少获得一次“真”值和“假”值。流程图中的有向边全部被覆盖。谓词覆盖/条件覆盖每个复合谓词所包含的每一个原子谓词都至少获得一次“真”值和一次“假”值。分支谓词覆盖/判定条件覆盖是分支和谓词覆盖的交集。条件中的所有谓词可能取值至少执行一次。同时，所有分支的可能结果至少执行一次。复合谓词覆盖/条件组合覆盖不是简单地要求每个谓词都出现“真”与“假”两种结果，而是要求让这些结果的所有可能组合都至少出现一次。】路径覆盖覆盖程序中所有可能的执行路径。数据流测试单元测试的目标和任务模块独立执行通路测试：检查每一条独立执行路径的测试。保证每条语句被至少执行一次。模块局部数据结构测试：检查局部数据结构完整性。模块接口测试：检查模块接口是否正确。模块边界条件测试：检查临界数据处理的正确性。模块的各条错误处理通路测试：预见、预设的各种出错处理是否正确有效。静态测试不运行被测试程序，对代码通过检查、阅读进行分析。走查：采用讲解、讨论和模拟运行的方式进行的查找错误的活动。审查：采用讲解、提问方式进行，一般有正式的计划、流程和结果。主要方法采用缺陷检查表。评审：通常在审查会后进行，审查小组根据记录和报告进行评估。充分审查了所规定的代码，并且全部编码准则被遵守。审查中发现的错误已全部修改。走查与审查的比较：缺陷测试缺少copy构造函数造成申请内存的重复释放1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class base&#123;public:char *p;public : base()&#123; p = new char[strlen("default value") + 1]; strcpy(p, "default value"); printf("base constructor is calling\n"); &#125; /* base(base &amp;a)&#123; printf("base copy constructor is calling\n"); p = new char[strlen(a.p) + 1]; strcpy(p, a.p); &#125;*/ void setp(char *s)&#123; if(p!=NULL) delete[] p; p = new char[strlen(s)+1]; strcpy(p, s); &#125; ~base()&#123; if(p) &#123; delete[] p; p = NULL; &#125; printf("base deconstructor is calling\n"); &#125;&#125;;class derive:public base&#123;public: derive()&#123;&#125; derive(derive &amp;a) &#123; printf("derive copy constructor is calling\n"); &#125; &#125;;int main(int argc, char*argv[])&#123; derive c; c.setp("this is c"); derive b(c); printf("c: %s\n", c.p); printf("b: %s\n", b.p); return 0;&#125;集成测试集成测试主要关注问题模块间的数据传递是否正确？一个模块的功能是否会对另一个模块的功能产生错误的影响？全局数据结构是否有问题，会不会被异常修改？块组合起来的功能能否满足要求？集成后，各个模块的累积误差是否会扩大，是否达到不可接受的程度？集成测试的原则所有公共接口必须被测试到；关键模块必须进行充分测试；集成测试应当按一定层次进行；集成测试策略选择应当综合考虑质量、成本和进度三者之间的关系；集成测试应当尽早开始，并以概要设计为基础；在模块和接口的划分上，测试人员应该和开发人员进行充分沟通；当测试计划中的结束标准满足时，集成测试才能结束；当接口发生修改时，涉及到的相关接口都必须进行回归测试；集成测试应根据集成测试计划和方案进行，不能随意测试；项目管理者应保证测试用例经过审核；测试执行结果应当如实的记录。集成测试策略非渐增式集成BIG BANG：很难确定出错的真正位置、所在的模块、错误的原因。这种方法并不推荐在任何系统中使用，适合在规模较小的应用系统中使用。渐增式集成 INCREMENTAL：自顶向下 TOP-DOWN：自顶向下集成：大量桩模块的开发是困难的。且在测试过程中，由于桩模块代替了低层模块，无重要数据自上往下流动。自底向上 BOTTOM-UP：不需要开发桩模块；重要的UI部分最后才能进行测试；适合于OO system，Real-time system以及有严格性能要求的系统。三明治集成 SANDWICH：是一种混合增量式测试策略，综合了自顶向下和自底向上两种集成方法的优点，桩模块和驱动模块的开发都比较少。主要缺点是：在真正集成之前每一个独立的模块没有完全测试过。性能测试性能测试主要检验软件是否达到需求规格说明书中规定的各类性能指标，并满足一些性能相关的约束和限制条件。性能测试包括以下几个方面：评估系统的能力。测试中得到的负荷和响应时间等数据可以被用于验证所计划的模型的能力，并帮助做出决策。识别系统中的弱点。受控的负荷可以被增加到一个极端的水平并突破它，从而修复系统的瓶颈或薄弱的地方。系统调优。重复运行测试，验证调整系统的活动得到了预期的结果，从而改进性能，检测软件中的问题。性能测试方法基准法：响应时间并发用户数吞吐量性能计数器性能测试执行三个阶段：计划阶段定义目标并设置期望值收集系统和测试要求定义工作负载选择要收集的性能度量值标出要运行的测试并决定什么时候运行它们决定工具选项和生成负载编写测试计划，设计用户场景并创建测试脚本测试阶段做准备工作（如建立测试服务器或布置其他设备）运行测试收集数据分析阶段分析结果改变系统以优化性能设计新的测试压力测试压力测试（Stress Testing）是指模拟巨大的工作负荷，以查看系统在峰值使用情况下是否可以正常运行。压力测试是通过逐步增加系统负载来测试系统性能的变化，并最终确定在什么负载条件下系统性能处于失效状态，以此来获得系统性能提供的最大服务级别的测试。压力测试方法特点：压力测试是检查系统处于压力情况下的能力表现：比如，通过增加并发用户的数量，检测系统的服务能力和水平；通过增加文件记录数来检测数据处理的能力和水平等等。压力测试一般通过模拟方法进行：通常在系统对内存和CPU利用率上进行模拟，以获得测量结果。如将压力的基准设定为：内存使用率达到75%以上、CPU使用率达到75%以上，并在此观测系统响应时间、系统有无错误产生。除了对内存和CPU的使用率进行设定外，数据库的连接数量、数据库服务器的CPU利用率等等也都可以作为压力测试的依据。压力测试一般用于测试系统的稳定性：如果一个系统能够在压力环境下稳定运行一段时间，那么该系统在普遍的运行环境下就应该可以达到令人满意的稳定程度。在压力测试中，通常会考察系统在压力下是否会出现错误等方面的问题。压力测试与性能测试的联系与区别：压力测试是用来保证产品发布后系统能否满足用户需求，关注的重点是系统整体；性能测试可以发生在各个测试阶段，即使是在单元层，一个单独模块的性能也可以进行评估。压力测试是通过确定一个系统的瓶颈，来获得系统能提供的最大服务级别的测试。性能测试是检测系统在一定负荷下的表现，是正常能力的表现；而压力测试是极端情况下的系统能力的表现。压力测试和负载测试（Load Test）：负载测试是通过逐步增加系统工作量，测试系统能力的变化，并最终确定在满足功能指标的情况下，系统所能承受的最大工作量的测试。压力测试实质上就是一种特定类型的负载测试。压力测试和并发性测试：并发性测试是一种测试手段，在压力测试中可以利用并发测试来进行压力测试。压力测试方法：压力测试应该尽可能逼真的模拟系统环境。对于实时系统，测试者应该以正常和超常的速度输入要处理的事务从而进行压力测试。批处理的压力测试可以利用大批量的批事务进行，被测事务中应该包括错误条件。压力测试中使用事务获得途径：测试数据生成器；由测试小组创建的测试事务；原来在系统环境中处理过的事务。压力测试手段：重复（Repetition）测试：重复测试就是一遍又一遍地执行某个操作或功能，比如重复调用一个Web服务。压力测试的一项任务就是确定在极端情况下一个操作能否正常执行，并且能否持续不断地在每次执行时都正常。这对于推断一个产品是否适用于某种生产情况至关重要，客户通常会重复使用产品。重复测试往往与其它测试手段一并使用。并发（Concurrency）测试：并发是同时执行多个操作的行为，即在同一时间执行多个测试线程。例如，在同一个服务器上同时调用许多Web服务。并发测试原则上不一定适用于所有产品（比如无状态服务），但多数软件都具有某个并发行为或多线程行为元素，这一点只能通过执行多个代码测试用例才能得到测试结果。量级（Magnitude）增加：压力测试可以重复执行一个操作，但是操作自身也要尽量给产品增加负担。例如一个Web服务允许客户机输入一条消息，测试人员可以通过模拟输入超长消息来使操作进行高强度的使用，即增加这个操作的量级。这个量级的确定总是与应用系统有关，可以通过查找产品的可配置参数来确定量级。随机变化：该手段是指对上述测试手段进行随机组合，以便获得最佳的测试效果。压力测试执行：可以设计压力测试用例来测试应用系统的整体或部分能力。压力测试用例选取可以从以下几个方面考虑：输入待处理事务来检查是否有足够的磁盘空间；创造极端的网络负载；制造系统溢出条件；当应用系统所能正常处理的工作量并不确定时需要使用压力测试。压力测试意图通过对系统施加超负载事务量来达到破坏系统的目的。压力测试和在线应用程序非常类似，因为很难利用其他测试技术来模拟高容量的事务。压力测试的弱点在于准备测试的时间与在测试的实际执行过程中所消耗的资源数量都非常庞大。通常在应用程序投入使用之前这种消耗的衡量是无法进行的。容量测试所谓的容量测试（Volume Testing）是指，采用特定的手段测试系统能够承载处理任务的极限值所从事的测试工作。这里的特定手段是指，测试人员根据实际运行中可能出现极限，制造相对应的任务组合，来激发系统出现极限的情况。容量测试的目的容量测试的目的是使系统承受超额的数据容量来发现它是否能够正确处理，通过测试，预先分析出反映软件系统应用特征的某项指标的极限值（如最大并发用户数、数据库记录数等），确定系统在其极限值状态下是否还能保持主要功能正常运行。容量测试还将确定测试对象在给定时间内能够持续处理的最大负载或工作量。对软件容量的测试，能让软件开发商或用户了解该软件系统的承载能力或提供服务的能力，如电子商务网站所能承受的、同时进行交易或结算的在线用户数。知道了系统的实际容量，如果不能满足设计要求，就应该寻求新的技术解决方案，以提高系统的容量。有了对软件负载的准确预测，不仅能对软件系统在实际使用中的性能状况充满信心，同时也可以帮助用户经济地规划应用系统，优化系统的部署。容量测试与压力测试的区别与容量测试十分相近的概念是压力测试。二者都是检测系统在特定情况下，能够承担的极限值。然而两者的侧重点有所不同，压力测试主要是使系统承受速度方面的超额负载，例如一个短时间之内的吞吐量。容量测试关注的是数据方面的承受能力，并且它的目的是显示系统可以处理的数据容量。压力测试、容量测试和性能测试的区别更确切的说，压力测试可以看作是容量测试、性能测试和可靠性测试的一种手段，不是直接的测试目标。压力测试的重点在于发现功能性测试所不易发现的系统方面的缺陷，而容量测试和性能测试是系统测试的主要目标内容，也就是确定软件产品或系统的非功能性方面的质量特征，包括具体的特征值。容量测试和性能测试更着力于提供性能与容量方面的数据，为软件系统部署、维护、质量改进服务，并可以帮助市场定位、销售人员对客户的解释、广告宣传等服务。压力测试、容量测试和性能测试的测试方法相通，在实际测试工作中，往往结合起来进行以提高测试效率。一般会设置专门的性能测试实验室完成这些工作，即使用虚拟的手段模拟实际操作，所需要的客户端有时还是很大，所以性能测试实验室的投资较大。对于许多中小型软件公司，可以委托第三方完成性能测试，可以在很大程度上降低成本。]]></content>
      <categories>
        <category>课内学习</category>
      </categories>
      <tags>
        <tag>课内学习</tag>
        <tag>软件测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[软件工程和项目管理]]></title>
    <url>%2Fposts%2F64809.html%2F</url>
    <content type="text"><![CDATA[软件危机软件危机指在计算机软件的开发和维护过程中，所遇到的一系列严重问题。软件危机主要包括的问题：如何开发软件如何维护软件软件危机的典型表现：发费用和进度难以估算和控制，大大超过预期的资金和规定日期软件需求分析不够充分，用户不满意“已经完成”的软件系统。软件质量难于保证软件维护困难难以改正程序中的错误难以根据用户的需要在原有程序中增加一些新的功能。通常没有保留适当的文档资料。文档的作用：软件开发管理人员：用于管理和评价软件开发工程的进展状况软件开发人员：用于开发人员对各个阶段的工作都进行周密思考、全盘权衡、从而减少返工。并且可在开发早期发现错误和不一致性，便于及时加以纠正软件维护人员：软件维护的依据开发成本逐年上升，软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势。产生软件危机的原因软件本身的特点软件与硬件不同抽象性。软件生产没有明显的制造过程，难以衡量开发进展，也难以控制软件质量。问题的隐蔽性。没有硬件的磨损、老化问题，但存在开发早期在分析、设计阶段的错误，修改难度较大。软件与一般程序不同软件远比一般程序规模庞大，复杂性高。而复杂性包括实际问题的复杂性和程序逻辑结构的复杂性。大型软件开发既有技术问题，还有社会问题。如：开发团队成员分工合作、技术与管理的矛盾、软件开发人员对软件应用的领域知识的了解。包括的社会因素有：组织机构、体制、管理方式、观念、人的心理素质等。软件开发与维护的方法不正确对用户需求的获取不正确用户的原因分析人员的原因，对分析人员的要求：沟通能力、归纳总结能力、经验。软件开发不是编写程序。一个完整的软件产品由一整套完整的配置组成，程序只是其中的一个组成部分。软件开发过程包括多个阶段，每个阶段的产品都是最终的完整的软件产品的一部分。软件开发只要依靠个别编程高手就能完成。轻视软件维护。软件维护约占软件费用55%-75%，包括修改软件运行的错误；对软件进行改进和功能扩充。其他产生软件危机的原因软件开发尚未完全摆脱手工艺的开发方式。软件成本相当昂贵，主要依靠大量复杂的、高强度的脑力劳动。软件的开发和运行常常受到计算机系统的限制，对计算机系统有着不同程度的依赖性。软件的本质特性复杂性一致性软件不能独立存在，需要依附于一定的环境（如硬件、网络以及其他软件）软件必须遵从认为的惯例并适应已有的技术和系统软件需要随接口不同而改变，随时间推移而变化，而这些变化是不同人设计的结果可变性：软件需要不断的进行调整来满足用户的需求不可见性软件是一种“看不见，摸不着”的逻辑实体，不具有空间的形体特征。开发人员可以直接看到程序代码，但是源代码并不是软件本身。软件是以机器代码的形式运行，但是开发人员无法看到源代码是如何执行的。软件开发面临的挑战消除软件危机的途径彻底消除“软件就是程序”的错误观念。充分认识到软件开发是一种组织良好、管理严密、各类人员协同配合、共同完成的工程项目，不是个人独立的劳动。推广和使用在实践中总结出来的软件开发的成功技术和方法。开发和使用更好的软件工具“软件工程”的方法理论是摆脱软件危机的一个主要出路。即按工程化的原则和方法组织软件开发工作是有效的，是摆脱软件危机的一个主要出路。软件开发的误区只要是编程高手，即使是不懂软件工程，也能编出很好的软件。软件是服务于大众，却是由个性化的开发人员完成的。如果个性化太强，程序就无法阅读，其他人员也就无法维护。例：国内 80 年代涌现出来的众多汉字操作系统均是由编程高手完成的。只要拥有一套讲述如何开发软件的书籍，并了解了书中的标准与示例，就可以解决软件开发中遇到的任何问题。软件是用来解决现实问题的，现实问题的特殊性对规范提出了挑战（要进行适应）。软件技术是发展的，没有祖传秘方。就像拥有食谱并不能成为名厨一样，软件开发需要实践。只要拥有最好的开发工具、最好的计算机，一定能做出优秀的软件。硬件环境只是必要条件，人才是充分条件，软件是人在一定的约束条件下创造出来的。因人因事而异。软件开发时，如果进度慢，落后于计划，可以增加更多的程序员来解决。Brook法则：当人数增加后，项目所需的工作量将不成比例的增加。因为需要增加管理、协调、通信等工作。软件的定义软件 = 程序 + 数据 + 文档软件：计算机可以接受的一系列指令，运行时可以提供所要求的功能和性能。数据：使得程序能够适当地操作信息的数据结构文档：描述程序的研制过程、方法和使用的图文资料。软件工程1968 年，第一届NATO会议：为了经济地获得可靠的且能在实际机器上有效地运行的软件，而建立和使用完善的工程原理。1993 年，IEEE/CS：将系统化的、规范的、可度量的方法应用于软件的开发、运行和维护的过程，即将工程化应用于软件中。软件工程便是对上述提到的各种方法的研究。另一个角度的看软件工程本质特性软件工程关注于大型程序的构造。软件工程的中心课题是控制复杂性主要考虑：如何分解和集成。为什么要分解： G .Miller（美国认知心理学家乔治·米勒）, “7±2 ” 原则，即短时间内人的记忆广度大约为7±2个单位。比如在记忆圆周率的时候只能记忆7±2位，超过这个范围需要分组记忆。软件经常变化开发软件的效率非常重要和谐地合作是开发软件的关键软件必须有效地支持它的用户在软件工程领域中是由具有一种文化背景的人替具有另一种文化背景的人创造产品扩展定义：软件 = 知识＋程序 + 数据 + 文档软件工程的基本原理用分阶段的生命周期计划严格管理坚持进行阶段评审实行严格的产品控制基线：基线（baseline）控制采用现代程序设计技术结果应能清楚地审查开发小组的人员应该少而精承认不断改进软件工程实践的必要性软件工程方法学软件工程包括“管理”和“技术”两方面内容：管理：对人、财、物的合理使用和配置；技术：指软件开发中采用的方法、工具和过程。软件工程方法学：通常把在软件生命周期全过程中使用的一整套技术方法的集合称为方法学（methodology），也称为范型（paradigm）。三要素软件工程过程：规定了完成各项任务的工作步骤。软件工程方法：完成软件开发的各项任务的技术方法，为软件开发提供了“如何做”的技术。如项目计划与估算、软件系统需求分析、数据结构、系统总体结构的设计、算法过程的设计、编码、测试以及维护等。软件工程工具：计算机辅助软件工程 CASE（computer Aided sottware Engineering），为软件工程方法提供自动或半自动的软件支撑环境。软件工程方法软件工程方法学思想传统方法学采用结构化技术（结构化分析、结构化设计和结构化实现）来完成软件开发的各项任务；把软件生命周期划分为若干个阶段，按顺序完成每个阶段的任务；每个阶段开始和结束都有严格的标准，对任何两个相邻的阶段而言，前一个阶段的结束标准就是后一阶段的开始标准；每一个阶段结束之前都必须进行正式严格的技术审查和管理复审优点分解任务，分工合作，降低整个软件开发工程的困难；采用科学的管理技术和良好的技术方法对每个阶段成果都进行严格的审查。保证了软件的质量。缺点把数据和操作人为地分离成两个独立的部分，增加了软件开发与维护的难度。面向对象方法学模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类认识世界解决问题的方法与过程，从而使描述问题的问题空间（也称为问题域）与实现解法的解空间（也称为求解域）在结构上尽可能一致。要点如下：把对象（object）作为融合了数据及在数据上的操作行为的统一的软件构件。把所有对象都划分成类（class ）。按照父类（或称为基类）与子类（或称为派生类）的关系，把若干个相关类组成一个层次结构的系统（也称为类等级）。对象彼此间仅能通过发送消息互相联系。和传统方法学的区别是：传统方法学强调自顶向下顺序地完成软件开发的各阶段任务。面向对象方法是主动地多次反复迭代的演化过程。软件生命周期软件定义时期确定软件开发工程必须完成的总目标；确定工程的可行性；导出实现工程目标应该采用的策略及系统必须完成的功能；估计完成该项工程需要的资源和成本，并且制定工程进度表。通常分为问题定义、可行性研究和需求分析三个阶段。问题定义阶段要解决的问题是什么？可行性研究阶段对于上一个阶段所确定的问题有行得通的解决办法吗？需求分析为了解决这个问题，目标系统必须做什么。用正式文档准确地记录对目标系统的需求，这份文档通常称为规格说明书（specification）。软件开发时期具体设计和实现前一个时期定义的软件，通常分为四个阶段。总体设计（概要设计）根据需求分析，设计软件的体系结构；定义结构中的组成模块。详细设计（模块设计）对每个模块要完成的工作进行具体的描述，为源程序编写打下基础。编写设计说明书，提交评审。与总体设计统称系统设计。程序编写（Coding, Programming）把软件设计转换成计算机可以接受的程序代码。软件测试（Testing）按规定的各项需求，逐项进行有效性测试，决定已开发的软件是否合格，能否交付用户使用，包括单元测试和组装测试。与程序编写统称系统实现。运行维护（软件维护）时期使软件持久的满足用户的需要，包括：改正性维护：运行中发现了软件中的错误需要修正。适应性维护：为了适应变化了的软件工作环境，需做适当变更。完善性维护：当用户有新的要求时，应该及时改进软件以满足用户的要求。预防性维护: 即修改软件为将来的维护活动预先做准备。软件过程软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。软件过程描述为了开发出客户需要的软件，什么人（who）、在什么时候（when）、做什么事（what）以及怎样（how）做这些事以实现某一个特定的具体目标。通常用软件生命周期模型来描述。ISO 9000的定义：使用资源将输入转化为输出的活动所构成的系统。 “系统”是相互关联或相互作用的一组要素。软件生命周期模型指软件项目从需求定义直至软件经使用后废弃为止，跨越整个生存周期的系统开发、运作和维护所实施的全部过程、活动和任务的结构框架。瀑布模型从上一阶段接受本阶段的工作对象，作为输入；利用输入，完成本阶段活动的内容。本阶段的工作成果作为输出传入下一阶段。实际的瀑布模型增加了一个评审活动，评审每个阶段完成的活动，若得到确认，则进行下一阶段的活动；否则返回前一阶段，甚至更前阶段返工。特点阶段间具有顺序性和依赖性。推迟实现的观点。质量保证的观点。优点可强迫开发人员采用规范的方法；严格地规定了每个阶段必须提交的文档；要求每个阶段的所有产品都必须经过质量保证小组的仔细验证；缺点无法解决软件需求不明确或不准确的问题；可能导致最终开发的产品不能真正满足用户需要。瀑布模型比较适合开发需求明确的软件。快速原型模型原型是快速实现和运行的早期版本，反映最终系统部分重要特性。常见的原型实例：人机界面；系统主要功能。快速原型就是快速开发一个能用的版本再后期修改。获得用户的基本需求说明，据此快速建立一个小型软件系统。用户试用，对其评价；开发人员按照用户的意见快速地修改原型系统，获得新的原型版本，再请用户试用，如此反复，直到满足用户的要求；用户确认原型系统之后，开发人员据此书写规格说明文档，进行下一步开发。优点通常能反映用户真实需求；软件产品的开发基本上是线性顺序进行的。增量（渐增）模型把软件产品作为一系列的增量构件来设计、编码、集成和测试。每个构件由多个相互作用的模块构成，并且能够完成特定的功能。使用增量模型时，第一个阶段的增量构件往往实现软件的基本需求，提供最核心的功能；后面的增量构架逐渐添加系统的功能。注意事项增量构件规模适中；分解的约束条件是当把新构件集成到现有软件中时，所形成的产品必须是可测试的；软件体系必须是开放的，即在对现有系统添加新增量构件时，不能破坏系统原有功能。优点能在较短的时间内，提供可完成部分工作的初步产品给用户；用户有较为充裕的时间学习和适应新产品。缺点对开发人员技术能力要求较高，要求能从系统整体出发正确划分增量构件，并进行分别开发，最后能很好地集成这些构件。一种风险更大的增量模型有可能提高开发速度，但需要密切地监控整个开发过程，否则会有构件无法集成到一起的风险。螺旋模型大型软件开发面临的重要问题：软件风险，如：产品交付给用户之后，用户不满意；开发进度落后，开发成本超出预算；产品完成前关键的开发人员跳槽；在产品投人市场前，竞争对手发布了一个功能相近，价格更低的软件 …构建原型能使某些类型的风险降到最低。优点强调可选方案和约束条件，有利于已有软件的重用，也有助于把软件质量作为软件开发的一个重要目标；减少了过多测试（浪费资金）或测试不足（产品故障多）所带来的风险；维护是一个周期，与开发并没有本质区别缺点需要开发人员具有相当丰富的风险评估经验和专门知识；进行风险分析的费用可能较大。适合大型软件开发。各种模型的比较模型优点缺点瀑布模型规范，文档驱动系统可能不满足客户真正的需求快速原型克服了瀑布型的缺点增量模型开发早期回报明确，易于维护要求开放的软件体系结构螺旋模型风险驱动，适用于大型项目开发风险分析人员需要有经验且经过充分训练软件工程工具软件开发的基本策略软件复用利用已有的软件制品，直接组装或合理修改形成新的软件系统，从而提高开发效率和产品质量，降低维护成本。软件复用不仅仅是代码复用，函数库、类库、模板（文档、网页）、设计模式、组件、框架。分而治之软件工程是一项解决问题的工程活动，通过对问题进行研究分析，将一个复杂的问题分解成可以理解并能够处理的若干小问题，然后再逐个解决。逐步演进软件开发应该遵循软件的客观规律，不断进行迭代式增量开发，最终交付符合客户价值的产品。优化折中软件工程师应该把优化当成一种责任，不断改进和提升软件质量；但是优化是一个多目标的最优决策，在不可能使所有目标都得到优化时，需要进行折中实现整体最优。ISO9126 质量模型功能性适合性：当软件你在指定条件下使用，其满足明确和隐含要求功能的能力。准确性：软件提供给用户功能的精准度能不能满足要求互操作性：软件与其他系统进行交互的能力安全性：软件保护信息和数据的安全能力可靠性成熟性：软件产品避免因软件中错误开发而导致失效的能力容错性：软件防止外部接口错误扩散而导致系统失效的能力可恢复性：系统失效后，重新恢复原有功能和性能的能力易用性易理解性：软件显示的信息要清晰、准确且易懂，使用户能够快速理解软件。易学习性：软件使用户能学习其应用的能力易操作性：软件产品使用户能易于操作和控制它的能力。吸引性：软件具有的某些独特的、能让用户眼前一亮的属性。效率时间特性：在规定的条件下，软件产品执行其功能时能够提供适当的响应时间效和处理时间以及吞吐率的能力。资源利用：软件系统在完成用户指定的业务请求所消耗的系统资源，诸如CPU占有率、内存占有率、网络带宽占有率等。可维护性易分析性：软件提供辅助手段帮助开发人员定位缺陷原因并判断出修改之处。易改变性：软件产品使得指定的修改容易实现的能力。稳定性：软件产品避免由于软件修改而造成意外结果的能力。易测试性：软件提供辅助性手段帮助测试人员实现其测试意图。可移植性适应性：软件产品无需做任何相应变动就能适应不同运行环境的能力。易安装性：在平台变化后成功安装软件的难易程度共存性：软件产品在公共环境与其共享资源的其他系统共存的能力。替换性：软件系统的升级能力，包括在线升级、打补丁升级等。可行性研究的目的说明该软件开发项目的实现在技术上、经济上和社会条件上的可行性；评述为合理地达到开发目标可能选择的各种方案。用最小的代价在尽可能短的时间内确定问题是否能够并且值得解决。可行性研究最根本任务是对以后的行动方针提出建议，一般占预期工程总成本的 5%-10%。可行性研究的基本内容技术可行性：使用现有的技术能实现这个系统吗？主要考虑：开发风险；资源；相关技术的发展经济可行性：这个系统的经济效益能超过它的开发成本吗？系统经济效益 = 新系统增加的收入＋ 新系统节省的费用考虑：成本——效益分析、长期的公司经营策略、对其他单位或产品的影响、开发所需的成本和资源、潜在的市场前景操作可行性：系统的操作方式在用户组织内行得通吗？其他：法律可行性、社会效应、管理问题等技术可行性对系统的性能、可靠性、可维护性以及生产率等方面的信息进行评价。通过技术可行性的分析，将为新系统提交技术可行性评估。以指明为完成系统的功能和性能需要什么技术？需要哪些材料、方法、算法、或者过程等。技术可行性分析方法：数学模型和优化技术、概率和统计、排队论、控制论等方法。经济可行性进行成本效益分析，评估项目的开发成本。操作可行性一个地区、一个行业乃至一个国家计算机应用发展的客观道路及规律客观发展规律，各阶段是不能超越的结合实际分析本单位、本部门、本行业的实际情况，参照国内外经验教训，实事求是地规划本企业信息系统的发展。可行性研究的任务可行性研究的目的是建立目标系统的逻辑模型。通常软件软件开发项目是要实现目标系统的物理模型，即确定待开发软件系统的系统元素，并将功能和数据结构分配到这些系统元素中。它是软件实现的基础。但是目标系统的物理模型是由它的逻辑模型经实例化，即具体到某个业务领域而得到的。与物理模型不同，逻辑模型忽视机制和细节，只描述系统要完成的功能和要处理的数据。为此，该阶段的主要任务是，借助于当前系统的逻辑模型导出目标系统的逻辑模型，也就是解决目标系统“做什么”的问题。其实系统的开发过程就是根据需要解决的问题，建立一个有信息技术支撑、与解决问题相关的、数据处理的、可运行的计算机模型。具体模型到逻辑模型举例可行性研究的定义了解客户的要求及现实环境，从技术、经济和社会因素等三方面研究并论证本软件项目的可行性，编写可行性研究报告，制定初步项目开发计划。可行性分析的描述手段：系统流程图、数据流图可行性研究报告功能说明软件项目的实现在技术上、经济上和社会因素上的可行性，评述为合理地达到开发目标可供选择的各种可能的实现方案，说明并论证所选定实施方案的理由。成本／效益分析从经济角度分析开发一个特定的新系统是否划算，帮助客户负责人作出是否投资的决定。主要包括成本估计和成本效益分析。成本估计包括开发成本和运行成本开发成本代码行技术：根据经验和历史数据，估算实现一个功能需要多少源程序行数，用每行代码的平均成本乘以行数。任务分解技术：将软件开发工程分解成若干个相对独立的任务，分别估算，然后累加得出总成本。按阶段分解按功能分解自动估计成本技术：采用自动估计成本的软件工具，需要有长期搜集的大量历史数据为基础，并需要良好的数据库系统支持。运行成本取决于系统的操作费用（操作人员数、工作时间、消耗的物资等）和维护费用。需求定义需求是人们要解决的问题某个问题或达到某种目的的需要。是系统或其组成部分为满足某种书面规定（合同、标准、规范等）所要具备的能力。需求将作为系统开发、测试、验收、提交的正式文档的依据。需求的内容需求是系统为满足客户期望的目标而完成的行为需求要体现出对问题领域的清晰理解给出系统的使用场景和上下文需求定义涵盖如下内容为什么要设计此系统系统由谁使用系统要做什么系统涉及哪些信息对解决方案有什么额外补充如何使用该系统质量需要达到何种程度需求内容来源干系人：干系人是任何和系统有关的人，如：资方、客户、系统用户、领域专家、项目研发团队。识别干系人可以从以下几个方面来判别：产品谁来用、输入谁提供、输出谁要、谁监管、影响谁、奖励谁、惩罚谁。业务过程：对现有业务过程的分析有助于识别业务问题并改进找出并列举当前业务过程中的问题分析问题的本质，可能是遗漏的，可能不好用，可能有新需求分析改进的机会分析改进的实质组织规章制度：分析规章制度有益于确定业务规则和约束条件业务规则：描述对业务过程的要求，如支撑系统的业务过程的结构、控制、行为效果约束：对系统开发过程的管理限制，主要涉及经济、政治、技术和环境四个方面，具体包括项目资源、时间、目标环境级现有系统：分析现有系统有助于了解未来系统的工作数据需求分析软件需求指用户对所开发的软件在功能、性能、环境、可靠性等各方面的要求。需求分析主要回答待开发的系统必须“做什么”，并用 《 需求规格说明书 》 的形式准确、详细、规范地表达出来。需求分析阶段，系统分析员的主要关注点是“做什么（ what ) ” ，不是“怎样做（ how）”；需求分析阶段，系统分析员应该给出软件需求规格书。需求分析的任务确定对系统的综合要求分析系统的数据要求导出系统的逻辑模型修正系统开发计划确定对系统的综合要求功能需求。指定系统必须提供的服务。性能需求。指定系统必须满足的定时约束或容量约束等。可靠性和可用性需求。应定量指定。出错处理需求。指环境错误，非系统本身的错误。接口需求。常见的接口需求：用户接口需求；硬件接口需求；软件接口需求；通信接口需求。常见的约束：精度；工具和语言约束；设计约束；应该使用的标准；应该使用的硬件平台。逆向需求。指定系统不应该做什么，将来可能提出的要求。分析建模结构化分析（Structured Analysis，SA）是面向数据流进行分析的方法，主要建立以下几种模型：实体关系图（Entity-Relationship Diagram，E-R图）来创建数据模型，描述系统中所有重要的数据对象；数据流图（Data Flow Diagram，DFD）：用来创建功能模型，描述了信息流和数据转换；状态转换图（State-Transition Diagram，STD）用来创建行为模型，描述系统状态如何响应外部事件，而进行转换。面向对象分祈方法（OOA）所建立的摸型对象模型（Object model）：定义实体，描述系统的静态结构，定义“对谁做”动态模型（Dynamic model）：描述对象之间的交互过程，规定“何时做”功能模型（Functional model） ：描述内部数据的处理，指明系统应“做什么”数据词典DD 是对数据流图中包含的所有元素的定义的集合，使得每个图形元素的名字都有一个精确的、严格的定义。数据流图和词典结合在一起，能清楚地表达数据处理的要求，构成了“需求说明书”定义数据的方法举例北京某高校可用的电话号码有以下几类：校内电话号码由4位数字组成，第1位数字不是0；校外电话又分为本市电话和外地电话两类，拨校外电话需先拨0，若是本市电话则再接着拨8位数字(第1位不是0)，若是外地电话则拨3位区码再拨8位电话号码(第1位不是0)。请用定义数据字典的方法，定义上述的电话号码。电话号码 = [校内电话号码|校外电话号码]校内电话号码 = 非零数字+ 3 位数字 //后面继续定义校外电话号码 = [本市号码|外地号码]本市号码 = 数字零+8位数字外地号码 = 数字零+3位数字+8位数字非零数字 = [1|2|3|4|5|6|7|8|9]数字零＝03位数字＝3{数字}3 //3至3个数字8位数字 = 非零数字+7位数字7位数字 = 7{数字}7数字＝[0|1|2|3|4|5|6|7|8|9]DD定义数据流数据流名：说明：简要介绍作用即它产生的原因和结果。数据流来源：来自何方。数据流去向：去向何处。数据流组成：数据结构。数据量流通量：数据量，流通量数据流定义数据流：购物单别名：无简述：学生购书时填写的项目来源：学生去向：审查并开发票组成：学号+姓名+书号+数量数据流量：1000次/周高峰值：开学期间1000次/天DD定义数据元素数据元素，又叫数据项，指数据处理中最小的，不可再分的单位。描述包括：数据元素名类型：数字（离散值，连续值），文字（编码类型）长度取值范围相关的数据元素及数据结构举例数据元素名：商品编号别名：描述：唯一的描述库存库清单中一个特定商品的关键域定义：商品编号 = 8 {字符} 8位置：订货报表订货信息库存清单DD定义数据存储数据文件名：简述：存放的是什么数据输入数据：输出数据：数据文件组成：数据结构存储方式：顺序，直接，关键码存取频率：举例数据文件名：库存记录别名：无简述：存放库存所有可供货物的信息组成：货物名称+编号+生产厂家+单价+库存量组织方式：索引文件，以货物编号为关键字查询要求：要求能立即查询DD定义数据处理处理名编号：DFD中的编号激活条件处理逻辑：此处理的子项执行频率例子数据处理名：登记报名单编号：1激活条件：收到报告单数据处理组成：1.1：检查报告单1.2：编准考证号1.3：登记考生执行频率：2000次/日软件设计的目标软件需求：解决“做什么”。软件设计：解决“怎么做”。软件设计的任务：以软件需求规格说明书为依据，着手实现软件的需求，并将设计的结果反映在“设计规格说明书”文档中。软件设计的重要性：是软件开发阶段的第一步，最终影响软件实现的成败和软件维护的难易程度。软件设计的两个阶段第一阶段：概要设计（总体设计）根据软件需求，设计软件系统结构和数据结构，确定程序的组成模块及模块之间的相互关系。回答“概括地说，系统应该如何实现？”。其重要性是：站在全局高度，从较抽象的层次上分析对比多种可能的系统实现方案和软件结构，从中选出最佳方案和最合理的软件结构，从而用较低成本开发出较高质量的软件系统。第二阶段：详细设计（过程设计）确定模块内部的算法和数据结构；选定某种过程的表达形式来描述各种算法；产生精确描述各模块程序过程的详细文档，并进行评审。SA和SD概要设计的任务制定规范：为软件开发小组制定在进行软件设计，应该共同遵守的标准，以便协调组内各员的工作。设计软件系统结构（简称软件结构）将系统按功能划分成模块确定每个模块的功能确定模块之间的调用关系确定模块之间的接口，即模块之间传递的信息评价模块结构的质量处理方式设计功能设计：确定实现功能法，评估算法的性能．性能设计：确定实现性能需求必须的算法和模块间的控制方式数据结构及数据库设计可靠性设计编写概要设计文档概要设计评审软件设计的过程软件设计的原理模块化采取自顶向下的方式，逐层把软件系统划分成若干可单独命名和可编址的部分，即“ 模块” ，每个模块完成一个特定的子功能；所有模块按某种方法组成一个整体，完成整个系统所要求的功能。软件系统就是通过这些模块的组合来实现。模块化是在逻辑和无理上将整个系统分解成多个更小的部分，其实质是“分而治之”，即将一个复杂问题分解成若干个简单问题，然后再逐个解决。自顶向下，逐步求精的基本思想将功能、信息的说明分为多个层次，最高层也最抽象 ― 仅仅只是概念性地描述功能或信息，不提供功能的内部工作情况或信息的内部结构；设计者从最高层开始，仔细推敲，进行功能和信息的细化，给出下层实现的细节；随着每个后续细化逐步的完成，提供越来越多的细节，最终得出用程序设计语言表达的程序。模块独立系统分解的目标：高内聚、低耦合。内聚性是一个模块或子系统内部的依赖程度。如果一个模块或子系统含有许多彼此相关的元素，并且它们执行类似任务，那么其内聚性比较高；如果一个模块或子系统含有许多彼此不相关的元素，其内聚性就比较低。耦合性是两个模块或子系统之间依赖关系的强度。如果两个模块或 子系统是松散耦合的，二者相互独立，那么当其中一个发生变化时对另一个产生的影响就很小；如果两个模块或子系统是紧密耦合的，其中一个发生变化就可能对另一个产生较大影响。耦合性也称块间的联系。是对软件系统结构中，各模块间相互联系紧密程度的一种度量。无直接藕合两个模块没有直接关系，模块独立性最强。数据耦合属松散耦合。一模块访问另一模块时，通过数据参数交换输入、输出信息。控制藕合模块之间传递的是控制信息（如开关、标志、名字等），控制被调用模块的内部逻辑。特征耦合两个模块通过传递数据结构加以联系，或都与一个数据结构有关系，则称这两个模块间存在特征耦合。可能出现的情况：当把整个数据结构作为参数传递时，被调用的模块虽然只需要使用其中的一部分数据元素，但实际可以使用的数据多于它真正需要的数据，这将导致对数据访问失去控制。“住户情况”是一个数据结构，图中模块都与此数据结构有关。“计算水费”和“计算电费”本无关，由于引用了此数据结构产生依赖关系。公共环境耦合一组模块引用同一个公用数据区（也称全局数据区、公共数据环境）。公共数据区指：全局数据结构。共享通讯区。内存公共覆盖区等公共耦合存在的问题：软件可理解性降低诊断错误困难软件可维护性差软件可靠性差内容耦合有下列情况之一的。是最不好的耦合形式！控制耦合改为数据耦合将被调用模块内的判定上移到调用模块中进行被调用模块分解成若干单一功能模块特征耦合修改为数据耦合内聚性巧合内聚块内各组成成份在功能上是互不相关的。逻辑内聚把几种相关功能（逻辑上相似的功能）组合在一模块内，每次调用由传给模块的参数确定执行哪种功能。时间内聚模块完成的功能必须在同一时间内执行，这些功能只因时间因素关联在一起。如：]初始化系统模块系统结束模块、紧急故障处理模块等过程内聚模块内各处理成分相关，且必须以特定次序执行。通信内聚模块内各部分使用相同的输入数据，或产生相同的输出结果。顺序内聚模块完成多个功能，各功能都在同一数据结构上操作，每一功能有唯一入口。功能内聚模块仅包括为完成某个功能所必须的所有成分。模块所有成分共同完成一个功能，缺一不可。启发规则改进软件结构，提高模块独立性：通过模块分解或合并，降低耦合提高内聚模块规模适中：在考虑模块的独立性同时，为了增加可理解性，模块的大小最好在 50-150 条语句左右，可以用 1-2 页打印纸打印，便于人们阅读与研究。模块过大：可理解程度下降模块过小：开销大于有效操作系统接口复杂深度、宽度、扇出和扇入适中将模块的影响限制在控制范围内：使任一模块的作用域在其控制域内作用域是指受模块内一个判定影响的所有模块的集合控制域是指这个模块本身及其所有的下属模块的集合模块 C 的控制范围： C 、 D 、 E 、 F 、 G 、 H 。如果模块 C 作出的决策影响了模块 L ，L超出了 C 的控制范围降低模块接口的复杂性：接口传递信息应简单且和模块功能一致。模块的接口要简单、清晰、含义明确，便于理解，易于实现、测试与维护。设计单入口单出口的模块：不要使模块间出现内容耦合。模块功能可预测：如果一个模块可以当作一个黑盒子，相同输入产生相同输出，其功能为可预测的。若模块带有内部“存储器”，其功能可能是不可预测的，难理解、难测试、难维护。单一的模块具有高内聚。但模块功能过分局限，可使用范围将过分狭窄，缺乏灵活性和扩充性。描绘软件结构的图形具层次图和 HIPO 图描述软件的层次结构。层次图中，一个方框代表一个模块，方框间的连线表示调用关系。 HIPO图=层次图+ IPO 图结构图…结构程序设计经典定义：如果一个程序的代码块仅仅通过顺序、选择和循环这 3 种基本控制结构进行连接，而且每个代码块只有一个入口和一个出口，则称这个程序是结构化的。比较全面的定义：结构程序设计是尽可能少用 GOTO 语句的程序设计方法，最好仅仅在检测出错误时才使用 GOTO 语句，而且应该总是使用前向的 GOTO 语句。SP主要原则使用语言中的顺序、选择、重复等有限的基本控制结构表示程序逻辑。选用的控制结构只准许有一个入口和一个出口。复杂结构应该用基本控制结构进行组合嵌套来实现。严格控制 GOTO 语句，仅在下列情形才可使用。用一个非结构化的程序设计语言去实现一个结构化的构造。在某种可以改善而不是损害程序可读性的情况下。五种基本的结构化控制结构控制流图符号“ O ”为程序图的结点，表示一个或多个无分支的语句；箭头为边，表示控制流的方向。边和结点圈定的封闭范围叫做区域。程序图的基本元素从图论的观点看，它是一个可以用 G = &lt; N , E ＞来表示的有向图。其中：N一结点；E一有向边，指明程序的流程；包含条件的结点称为判定结点；环路复杂性V ( G ) ＝流图中区域数（包括图外区域）V ( G ) ＝判定结点数＋ 1V ( G )= E - N + 2编码选择程序设计语言从软件工程的角度，根据程序设计语言发展的历程，大致分为 4 类：第一代语言：从属于机器的语言第二代语言：汇编语言第三代语言：高级程序设计语言第四代语言（4GL）编码风格编码风格是指一个人编制程序时所表现出来的特点、习惯、逻辑思路等。良好编码风格包括：程序内部应该有很好的文档：如标识符、注释良好，程序文档结构易读易理解。数据说明应易于理解和维护语句结构尽可能简单直观输入输出风格遵守人机界面设计准则效率满足用户需求即可软件测试的基础什么是软件测试？是为了发现错误而执行程序的过程。发现错误是为了更正错误，最终得到一个高质量的软件系统。软件测试的对象：整个软件定义、开发周期的产品测试用例：通常指测试数据和预期的输出结果软件测试存在的矛盾用户希望通过软件测试暴露软件中隐藏的错误和缺陷，以考虑是否可接受该产品。软件开发者希望通过软件测试表明软件产品中不存在错误，已正确地实现了用户的要求。软件测试目的测试是为了发现错误而执行程序的过程好的测试用例是极可能发现至今为止尚未发现的错误的测试方案；成功的测试是发现了至今未发现的错误的测试总之，测试的目的是以最少的时间和人力，系统地找出软件中潜在的各种错误和缺陷；测试附带的收获是它能证明软件的功能和性能与需求说明相符合。注意：测试不能表明软件中不存在错误，它只能说明软件中存在错误。软件测试的准则所有测试都能追溯到用户需求应该远在测试开始之前就制定出测试计划应该把 Pareto原理应用到软件测试中群集现象： 80 ％的错误可能是由 20 ％的模块造成的从“小规模”测试开始，逐步过渡到“大规模”测试穷举测试是不可能的测试只能证明程序有错，不能证明程序没有错误应由独立的第三方从事测试工作测试步骤单元（模块）测试：检查各各程序模块是否有错误，能发现编码和详细设计的错误。集成测试（子系统和系统测试）：测试模块（子系统）接口，发现软件设计和需求说明的错误。确认（验收）测试：检查软件是否满足用户的需要以及文档资料是否完整、准确平行运行：同时运行新、旧系统单元测试模块接口测试在单元测试的开始，应对通过被测模块的数据流进行测试。测试项目：调用本模块的输入参数是否正确；本模块调用子模块时，输入给子模块的参数是否正确；输出给标准函数的参数是否正确；全局量的定义和用法在各摸块中是否一致；与外部设备的输入输出是否正确局部数据结构测试测试项目：不正确或不一致的数据类型说明使用尚未赋值或尚未初始化的变量错误的初始值或错误的缺省值变量名拼写错或书写错不一致的数据类型全局数据对模块的影响重要的执行通路测试白盒测试错误处理测试着重测试以下可能发生的错误：出错的措述是否难以理解出错的描述是否能够对错误定位显示的错误与实际的错误是否相符对错误条件的处理正确与否在对错误进行处理之前，错误条件是否已经引起系统的干预等边界测试重点检查刚好等于、大于或小于边界值的数据;对运行时间有要求的模块，还要专门进行关键路径测试，以确定最坏情况下和平均意义下影响模块运行时间的因素。代码审查人工测试源程序。参与者：程序的设计者、编写者、测试者没有直接参与系统开发，但有力的程序员。方法：研究设计说明书，一起审查程序代码如何实现设计，从中发现问题。注意：通常代码审查和机器测试结合使用。计算机测试单元测试通常在编码阶段进行。常用机器测试，即通过运行模块发现问题。两个重要概念：驱动程序（ driver ) ：相当于被测试模块的“主程序”，接收测试数据，把这些数据传送给被测试的模块，并且输出相关结果。存根程序（stub）：代替被测试模块所调用的模块。不需要具有子模块所有功能，但不允许什么事情也不做。集成测试在单元测试之后，将模块组装成系统，为发现并排除模块在连接中可能出现的问题，而进行的测试。需要考虑：模块连接时穿越模块接口的数据是否会 丢失；一个模块对另一个模块是否会产生不利的影响；各子功能组合起来，能 否达到预期要求的父功能全局数据结构是否有问题；单个模块的误差累积起来，是 否会放大至不能接受的程度。集成测试的两种方式非渐增式组装方式对每个模块分别进行单元测试，再把所有模块组装成一个完整的系统进行的测试，从而得到要求的软件系统。渐增式组装方式先对模块进行单元测试，然后将测试后的模块逐步组装成较大的系统；在组装的过程中边连接边测试，以发现连接过程中产生的问题；最后组装成为要求的软件系统。自顶向下的渐增方式将模块按系统程序结构，沿控制层次自顶向下进行组装。不需要驱动模块，需要存根模块自底向上结合的渐增方式从程序模块结构最底层的模块开始组装和测试。不再需要存根程序，需要驱动模块。组合策略：把低层模块组合成实现某个特定的软件子功能的族；用驱动程序协调测试数据的输入和输出;对由模块组成的子功能族进行测试;去掉驱动程序，没软件结构自下向上移动，把子功能族组合起来形成更大的子功能族。混合渐增测试衍变的自顶向下的增殖测试：先对输入／输出模块和引入新算法模块进行测试；再自底向上组装成为功能相当完整且相对独立的子系统；然后由主模块开始自顶向下进行增殖测试。自底向上 - 自顶向下的增殖测试：先对含读操作的子系统自底向上直至根结点模块进行组装和测试；再对含写操作的子系统做自顶向下的组装与测试。确认测试又称有效性测试。验证软件的功能、性能及其它特性是否与用户的要求一致。确认测试的基础 ：软件需求规格说明书确认测试的主要工作：有效性测试与软件配置审查主要参与人员：以用户为主确认测试范围通常采用黑盒测试，验证被测软件是否满足用户需求。测试计划：包括测试种类及进度安排；测试步骤：描述具体的测试用例测试目的：确定软件的特性是否与需求相符；所有的文档都是正确且便于使用；其它软件需求。测试结果：与预期的结果相符；与预期的结果不符：要提交一份问题报告。软件配置复查目的：保证软件配置的所有成分都齐全；各方面的质量都符合要求；具有维护阶段所必需的细节；而且已经编排好分类的目录。应当严格遵守用户手册和操作手册中规定的使用步骤，以便检查这些文档资料的完整性和正确性。α测试和β测试α测试：由用户在开发环境下进行的测试。主要评价软件产品的:FLURPS(即功能、局域化、可使用性、可靠性、性能和支持）β测试：由最终用户在实际使用环境下进行的测试，这些用户定期返回有关错误信息给开发者。注意：只有当α测试达到一定的可靠程度时，才开始β测试。自盒测试技术白盒测试执行的要求：对程序模块的所有独立的执行路径至少测试一次对所有的逻辑判定，取“真”与取“假”的两种情况都至少测试一次；在循环的边界和运行界限内执行循环体；测试内部数据结构的有效性。逻辑覆盖语句覆盖使得每一可执行语句至少执行一次。判定覆盖运行被测程序，使得程序中每个判断的取真分支和取假分支至少经历一次。条件覆盖使得程序中每个判断的每个条件的可能取值至少执行一次。判定一条件覆盖使得判断中每个条件的所有可能取值至少执行一次，每个判断中的每个分支至少执行一次。即同时满足判断覆盖和条件覆盖。条件组合覆盖使得每个判断的所有可能的条件取值组合至少执行一次。点覆盖如果连通图G的子图G′是连通的，而且包含G的所有结点，则称G′是G的点覆盖。点覆盖标准和语句覆盖标准是相同的。边覆盖要求选取足够多测试数据，使得程序执行路径至少经过流图中每条边一次。通常边覆盖和判定覆盖是一致的。路径覆盖覆盖程序中所有可能的路径。控制结构测试基本路径测试以环形复杂度为基础，导出基本可执行路径集合，设计测试用例的方法。测试用例要保证程序的每个可执行语句至少执行一次。步骤由程序流程图导出程序控制流图，并计算其环路复杂度：确定程序的独立路径什么是独立路径？流图中，一条独立路径是至少包含一条在其它独立路径中从未有过的边的路径。独立路径条数是确保程序中，每个可执行语句至少能被执行一次所必需的测试用例数目的上界。独立路径条数＝程序环路复杂性 V ( G )黑盒测试技术黑盒测试主要是为了发现以下错误：是否有不正确或遗漏了的功能？能否正确地接受输入？能否正确的输出结果？是否有数据结构错误或外部数据库访问错误？性能上是否能够满足要求？是否有初始化或终止性错误？几种黑盒测试技术：等价类划分边界值分析错误推测法因果图等价划分把所有可能的输入数据（包括有效或无效的），划分成若干数据类（等价类），然后从每个数据类中选取少数有代表性的数据做为测试用例。这种方法完全不考虑程序的内部结构，只依据程序的规格说明来设计测试用例。步骤1：划分等价类等价类是指输入数据的子集合。在该子集合中，各输入数据对于发现程序中的错误都是等效的。根据程序功能说明，确定有效和无效的等价类等价类划分原则若规定了取值范围，或输入值的个数，则可以确立一个有效等价类和两个无效等价类。如果规定了输入数据的一组值，而且程序要对每种输入数据分别处理，则可为每种输入值确立一个有效等价类，此外针对这组值确立一个无效等价类，它是所有不允许的输入值的集合。若规定了输入值的集合，或者是规定了“必须如何”的条件，则可确立一个有效等价类和一个无效等价类。如果规定输入数据为整型，则可划分出正整、零和负整数三个有效类，其他数据为无效类如果程序处理对象是表格，则应使用空表、含一项和多项的表。如果确知，已划分的等价类中各元素在程序中的处理方式不同，则应将此等价类进一步划分成更小的等价类。步骤2：根据等价类设计测试用例在确立了等价类之后，建立等价类表，列出所有划分出的等价类。测试用例的选择原则为每一个等价类规定一个唯一编号；设计一个新的测试用例，使其尽可能多地覆盖尚未被覆盖的有效等价类，重复这一步，直到所有的有效等价类都被覆盖为止；设计一个新的测试用例，使其仅覆盖一个尚未被覆盖的无效等价类，重复这一步，直到所有的无效等价类都被覆盖为止。某报表处理系统系统规定日期由年、月的 6 位数字字符组成，前 4 位代表年，后两位代表月。设日期限制在 1990 年 1 月至 1999 年 12 月，即系统只能对该段时期内的报表进行处理。如果用户输入的日期不在此范围内，则显示输入错误。现用等价类划分法设计测试用例，来测试程序的“日期检查功能”。为合理等价类设计测试用例不合理等价类设计测试用例边界值分析边界是指，对于输入和输出等价类而言，稍高和稍低于其边界值的一些特定情况。经验得知，大量的错误是发生在输入或输出范围的边界上，而不是在输入范围的内部。边界值分析方法思想：确定边界之后，选取正好等于、刚刚大于或刚刚小于边界的值做为测试数据，而不是选取等价类中典型值或任意值做为测试数据。通常总是与等价划分技术联合使用，是等价划分方法的补充。假设一个数据库产品规范要求该产品能够处理从1到1000中间的任何数量的记录。请首先为其划分等价类，并利用等价类划分和边界值分析技术为其设计测试用例，并说明每个测试用例属于某等价类成员还是属于边界值或是邻接边界值。等价类等价类1：少于1个记录等价类2：1到1000个记录等价类3：多于1000个记录测试用例测试用例1：0个记录 //等价类1成员且邻接边界值测试用例2：1个记录 //边界值测试用例3：2个记录 //邻接边界值测试用例4：100个记录 //等价类2的成员测试用例5：999个记录 //邻接边界值测试用例6：1000个记录 //边界值测试用例7：1001个记录 //等价类3成员且邻接边界值因果图因果图是借助图形来设计测试用例的一种系统方法。它适用于被测程序具有多种输入条件，程序的输出又依赖于输入条件的各种组合的情况。因果图是一种简化了的逻辑图，它能直观地表明程序输入条件（原因）和输出动作（结果）之间的相互关系。利用因果图产生测试用例的基本步骤分析软件规格说明书中，哪些是原因（即输入条件或输入条件的等价类），哪些是结果（即输出条件）并给每个原因和结果赋予一个标识。分析软件规格说明书中所描述的语义，找出原因与结果之间、原因与原因之间对应的是什么关系？根据这些关系画出因果图。由于语法或环境的限制，有些原因与原因之间、原因与结果之间的组合情况不可能出现。为表明这些特殊情况，在因果图上用一些记号标明约束或限制条件。把因果图转换为判断表把判断表的每一列拿出来作为依据，设计测试用例。在因果图中出现的基本符号通常在因果图中用 Ci 来表示原因，用Ei表示结果其基本符号如下图所示。其中各结点表示状态，可取值为 “0”或“1”。“0”表示某状态不出现，“1”表示某状态出现。主要的原因和结果之间的关系如下:恒等：表示原因与结果之间是一对一的对应关系。若原因出现，则结果出现。若原因不出现，则结果也不出现。非：表示原因与结果之间的一种否定关系。若原因出现，则结果不出现。若原因不出现，反而结果出现。或：表示若几个原因中有一个出现，则结果出现，而当这几个原因都不出现时，结果才不出现。与：表示若几个原因都出现，则结果才出现若几个原因中有一个不出现，结果就不出现。例设有一个处理单价为5角钱饮料自动售货机其规格说明为，若投入5角钱或1元钱的硬币 ，再按下橙汁或啤酒按钮，则相应的饮料就送出来；若售货机 没有零钱找，则一个显示零钱已找完的红灯亮，这时在投入1元硬币并按下按钮后，饮料不送出来而且1元硬币也退出来;若有零钱找，则应显示零钱找完的红灯灭， 在送出饮料的同时退还5角硬币。| 序号 | 原因 | 序号 | 结果 || :–: | :————: | :——: | :—————-: || 1 | 售货机有零钱找 | 2.1 | 售货机零钱找完灯亮 || 2 | 投入1元硬币 | 2.2 | 退还1元硬币 || 3 | 投入5角硬币 | 2.3 | 退还5角硬币 || 4 | 按下橙汁按钮 | 2.4 | 送出橙汁饮料 || 5 | 按下啤酒按钮 | 2.5 | 送出啤酒饮料 || 序号 | 中间结点 || :–: | :—————————–: || 11 | 投入1元硬币且按下饮料按钮 || 12 | 按下橙汁或啤酒的按钮 || 13 | 应当找5角零钱并且售货机有零钱找 || 14 | 钱已付请 |软件维护的定义软件维护是指在软件运行或维护阶段对软件产品所进行的修改。分为四类：改正性维护在软件交付使用后，由于开发时测试得不彻底或不完全，在运行阶段会暴露一些开发时未能测试出来的错误。为了识别和纠正软件错误，改正软件性能上的缺陷，避免实施中的错误使用，应当进行的诊断和改正错误的过程，这就是改正性维护。适应性维护随着计算机技术的飞速发展和更新换代，软件系统所需的外部环境或数据环境可能会更新和升级。为了使软件系统适应这种变化，需要对软件进行相应的修改，这种维护活动称为适应性维护。扩充与完善性维护在软件的使用过程中，用户往往会对软件提出新的功能与性能要求。为了满足这些要求，需要修改或再开发软件，以扩充软件功能、增强软件性能、改进加工效率、提高软件的可维护性。这种情况下进行的维护活动叫做完善性维护。预防性维护采用先进的软件工程方法，对需要维护的软件或软件中的某一部分重新进行设计、编制和测试。软件的可维护性指纠正软件系统出现的错误和缺陷，以及为满足新的要求进行修改、扩充或压缩的容易程度。衡量软件质量的几个主要质量特性：可理解性：人们通过阅读源代码和相关文档，了解程序功能及其如何运行的容易程度。可靠性：表明一个程序按照用户的要求和设计目标，在给定的一段时间内正确执行的概率。可测试性：表明诊断和测试的容易程度。可修改性：表明程序容易修改的程度。可移植性：表明把程序从一种计算环境转移到另一种计算环境的难易程度。可重用性：指同一个软件（或软件成份）不做修改或稍加改动，就可以在不同环境中多次重复使用。软件再工程过程预防性维护也称为软件再工程逆向工程软件的逆向工程是分析程序，力图在比源代码更高的抽象层次上建立程序表示的过程，是一个设计恢复的过程，逆向工程工具可以从已有的程序中抽取数据结构、体系结构和程序设计信息。正向工程应用现代软件工程的概念、原理、技术和方法，重新开发现有的某个应用系统。软件再工程软件再工程是一个工程过程，它将逆向工程、重构和正向工程组合起来，旨在对现存的大量软件系统进行挖掘、整理，重新获得设计信息，用这些信息改建或重构现有的系统，以改进它的综合质量；或者得到有用的软件构件，对已有软件构件进行维护以延长其生存期。再工程的基础是系统理解，包括对运行系统、源代码、设计、分析、文档等的全面理解。但在很多情况下，由于各类文档的丢失，只能对源代码进行理解，即程序理解。典型的软件再工程过程模型定义了库存目录分析、文档重构、逆向工程、代码重构、数据重构和正向工程6类活动。]]></content>
      <categories>
        <category>课内学习</category>
      </categories>
      <tags>
        <tag>课内学习</tag>
        <tag>软件工程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML基础]]></title>
    <url>%2Fposts%2F2276.html%2F</url>
    <content type="text"><![CDATA[objectAn object is an entity with a well-defined boundary and identity that encapsulates state and behavior.State is represented by attributes and relationships.Behavior is represented by operations, methods, and state machines.An Object Has StateThe state of an object is one of the possible conditions in which an object may exist.The state of an object normally changes over time.An Object Has BehaviorBehavior determines how an object acts and reacts.The visible behavior [bɪ’heɪvjə] of an object is modeled by the set of messages it can respond to (operations the object can perform).An Object Has IdentityEach object has a unique identity, even if the state is identical to that of another object.classA class is a description of a set of objects that share the same properties and behavior. An object is an instance of a class.The Relationship Between Classes and ObjectsA class is an abstract definition of an object. It defines the structure and behavior of each object in the class. It serves as a template for creating objects.Objects are grouped into classes.An object is an instance of a class.What Is an Operation?An operation is the implementation of a service that can be requested from any object of the class to affect behavior.A class may have any number of operations or none at all.Objects Need to CollaborateObjects are useless unless they can collaborate [kəˈlæbəreɪt] together to solve a problem.Each object is responsible for its own behavior and status.No one object can carry out every responsibility on its own.How do objects interact with each other?They interact through messages.What is a message?A specification of a communication between objects that conveys information with the expectation that activity will ensue(跟着发生)One object asks another object to perform an operation.What Is Abstraction?Abstraction can be defined as: Process allowing to focus on most important aspects while ignoring less important detailsAllows us to manage complexity by concentrating on essential aspects making an entity different from othersAbstractionEmphasizes relevant characteristics.Suppresses（抑制） other characteristics.What Is Encapsulation?Encapsulation means to design, produce, and describe software so that it can be easily used without knowing the details of how it works.Also known as information hidingAn analogy:When you drive a car, you don’t have know the details of how many cylinders(汽缸) the engine has or how the gasoline and air are mixed and ignited(点火).Instead you only have to know how to use the controls.Encapsulation allows objects to be viewed as ‘black boxes’It protects an object’s internal state from being corrupted by other objects.Also, other objects are protected from changes in the object implementation.隔离复杂度What Is Inheritance ?Inheritance [ɪnˈherɪtəns]—a way of organizing classesClasses with properties in common can be grouped so that their common properties are only defined once.增加了软件重用的机会PolymorphismPolymorphism—the same word or phrase can be mean different things in different contextsAnalogy（类比）: in English, bank can mean side of a river or a place to put moneyIn Java, two or more classes could each have a method called outputEach output method would do the right thing for the class that it was in.One output might display a number where as a different one might display a name.What Is Polymorphism?消息发送方不需要知道消息接收方属于那个子类同一类族的接收者可以按自己的方式处理消息同一类族的接收者可以按自己的方式处理同一个消息有多种对象可以按自己的方式处理相同的数据What is an Interface?An interface is a collection of operations that specify a service of a class or component.Interfaces formalize（正式化） polymorphismInterfaces support “plug-and-play(即插即用)” architectures小结类定义了对象群体的逻辑结构，包括属性和操作。系统运行时，类作为产生对象的模板，在物理层面是不存在的对象系统运行时必须为每一个需要的对象分配内存、保存数据对象存在于物理层面，每个对象都有自己的数据空间。所有的对象共享同一块代码空间属性Attribute ==状态state == 信息information操作operation == 方法method ==行为behaviour = = 职责responsibilityProcedural ProgrammingThis programming paradigm（范式） is essentially an abstraction of machine /assembly language.Program is organized around procedures.Focus on data structures, algorithms and sequencing of stepsPrograms = Algorithm + Data StructureAn algorithm is a set of instructions for solving a problemA data structure is a construct used to organize data in a specific way.Most computer languages, from early examples like FORTRAN and ALGOL to more recent languages like C and Ada have been imperative or procedural.Object-Oriented ProgrammingA design and programming techniqueSome terminology:object - usually a person, place or thing (a noun)method - an action performed by an object (a verb)type or class - a category of similar objects (such as automobiles)Objects have both data and methodsObjects of the same class have the same data elements and methodsObjects send and receive messages to invoke actionsC语言是一种面向过程的思维方式程序的运行“一切尽在掌握中”：从main()函数的逐条语句开始执行、调用了子程序就必须一层层返回，最终又返回main函数系统需要完成的功能，分配到各个子函数，由main函数统一调度比较面向过程侧重于考虑方法的编写（哪个方法做什么事，不考虑所涉及的数据在哪里）面向对象则致力于将数据和方法先做一个封装（分配一个对象做事，先考虑所需要的数据是否和它在一起）What is modeling?A model is an abstraction of things.Emphasizes relevant characteristics.Suppresses other characteristics.建模目的We build models to better understand the system we are developing.Modeling achieves four aims.模型帮助我们按照实际情况或按照我们所需要的样式对系统进行可视化模型允许我们详细说明系统的结构或行为模型给出了一个指导我们构造系统的模板模型对我们作出的决策进行文档化We build models of complex systems because we cannot comprehend such a system in its entirety.UMLUnified Modeling Language 统一建模语言作用：建立软件模型，可以用UML对软件密集型系统的制品（artifact：软件开发过程中产生的各种各样的产物）进行可视化、详述、构造和文档化。建模语言：提供统一的交流词汇和规则可视化: 通过标准图符构成图形来描述模型通用标准: 成为软件建模的标准语言,并且在其他领域也得到应用。UML的构成Building Blocks of the UMLThe vocabulary of the UML encompasses three kinds of building blocks:Things: the abstractions that are first-class citizens in a model;Relationships: relationships tie these things together;Diagrams: diagrams group interesting collections of things.Things in the UMLThere are four kinds of things in the UML:Structural things: class, interface, collaboration, use case, active class, component, nodeBehavioral things: interaction, state machine, activityGrouping things: packageAnnotational(注释) things: noteThese things are the basic object-oriented building blocks of the UML.Structural things in the UMLthe nouns of UML models.the mostly static parts of a model, either conceptual or physicalCollectively, the structural things are called classifiersStructural things - ClassA class is a description of a set of objects that share the same attributes, operations, relationships, and semantics(语义).A class is represented using a compartmented(间隔间) rectangleA class is comprised of three sectionsThe first section contains the class nameThe second section shows the structure (attributes)The third section shows the behavior (operations)Representing ObjectsAn object is represented as rectangles with underlined namesStructural things - InterfaceAn interface is a collection of operations that specify a service of a class or component.Interfaces support “plug-and-play” architecturesStructural things – Use Casea use case is a description of set of sequence of actions that a system performs that yields an observable result of value to a particular actor.A use case is used to structure(组织) the behavioral things in a model.A use case is realized by a collaboration.Graphically, a use case is rendered as an ellipse [ɪˈlɪps] with solid lines, usually including only its name.Structural things - CollaborationIn the context of a system‘s architecture, a collaboration allows you to name a conceptual chunk(大块) that encompasses both static and dynamic aspects.A collaboration names a society of classes, interfaces, and other elements that work together to provide some cooperative [kəʊ’ɒpərətɪv] behavior that’s bigger than the sum of all its parts.You use collaborations to specify the realization of use cases and operations, and to model the architecturally significant mechanisms of your system.A collaboration is also the specification of how an element, such as a classifier (including a class, interface, component, node, or use case) or an operation, is realized by a set of classifiers and associations playing specific roles used in a specific way.Graphically, a collaboration is rendered as an ellipse(椭圆) with dashed lines.Structural things – Active Classan active class is a class whose objects own one or more processes or threads and therefore can initiate control activity.Graphically, an active class is rendered as a class with double lines on the left and right; it usually includes its name, attributes, and operations.Structural things – ComponentA component is a modular part of the system design that hides its implementation behind a set of external interfaces.系统中遵从一组接口且提供其实现的物理的、可替换的部分。构件是物理抽象，可以替换的文件。类是逻辑抽象，包含属性和方法。逻辑抽象出来的东西用文件写出来，这些源文件就是构件。eg：Structural things – Nodea node is a physical element that exists at run time and represents a computational resource, generally having at least some memory and, often, processing capability.A set of components may reside（安置、居住） on a node and may also migrate from node to node.Graphically, a node is rendered as a cube, usually including only its name.Behavioral things in the UMLthe verbs of UML models.the mostly dynamic parts of a modelthree primary kindsAmong a set of objects: interactionFor an object: state machineThe sequence of steps: activityBehavioral things - Interactionan interaction is a behavior that comprises（包括） a set of messages exchanged among a set of objects within a particular context to accomplish a specific purpose.An interaction involves（包含、涉及） a number of other elements, including messages, action sequences (the behavior invoked by a message), and links (the connection between objects).Graphically, a message is rendered as a directed line, almost always including the name of its operation.What Is an Interaction Diagram?An interaction diagram shows an interaction, consisting of a set of objects and their relationships, including the messages that may be dispatched（派遣，分发） among them.It models the dynamic aspects of a system.What Is a Sequence Diagram?A sequence diagram is an interaction diagram that emphasizes the time ordering of messages.The diagram showsThe objects participating in the interaction.The sequence of messages exchanged.What Is a Communication Diagram?A communication diagram emphasizes the organization of the objects that participate in an interaction.The communication diagram showsThe objects participating in the interaction.Links( physical or conceptual connection among objects) between the objects.Messages passed between the objects.Behavioral things - State machinea state machine is a behavior that specifies the sequences of states an object or an interaction goes through during its lifetime in response to events, together with its responses to those events.A state machine involves a number of other elements, including states, transitions, events, and activities.Graphically, a state is rendered as a rounded rectangle, usually including its name and its substates（子状态）, if any（如果有）.Behavioral things - Activityan activity is a behavior that specifies the sequence of steps a computational process performsIn an activity, the focus is on the flows among steps without regard to which object performs each step.A step of an activity is called an action.Graphically, an action is rendered as a rounded rectangle with a name indicating its purpose. States and actions are distinguished by their different contexts.Grouping things in the UMLGrouping things - PackageGrouping things are the organizational parts of UML models.Structural things, behavioral things, and even other grouping things may be placed in a package.Unlike components (which exist at run time), a package is purely conceptual (meaning that it exists only at development time).Graphically, a package is rendered as a tabbed folder, usually including only its name and, sometimes, its contents.Annotational things in the UMLAnnotational things - NoteAnnotational things are the explanatory(解释性的) parts of UML models.These are the comments（解释） you may apply to describe, illuminate（阐释）, and remark about any element in a model.There is one primary kind of annotational thing, called a note.A note is simply a symbol for rendering constraints and comments attached to an element or a collection of elements.Graphically, a note is rendered as a rectangle with a dog-eared corner, together with a textual or graphical comment.Relationships in the UMLThere are four kinds of relationships in the UML:AssociationDependencyGeneralizationRealizationWhat Is an AssociationThe semantic relationship between two or more classes that specifies connections among their instancesA structural relationship, specifying that objects of one thing are connected to objects of anotherRelationships: DependencyA relationship between two model elements where a change in one may cause a change in the other.Non-structural, “using” relationship.Relationships: GeneralizationA relationship among classes where one class shares the structure and/or behavior of one or more classesDefines a hierarchy of abstractions in which a subclass inherits from one or more superclassesSingle inheritanceMultiple inheritancean “is-a-kind of” relationshipRelationships: RealizationOne classifier serves as the contract that the other classifier agrees to carry outDiagrams in the UMLThe UML1.x includes nine such diagrams:Use-case diagrams: to illustrate requirement.Class diagrams: to illustrate logical structure.Object diagrams: to illustrate objects and links.State diagrams: to illustrate behavior.Component diagrams: to illustrate physical structure of the software.Deployment diagrams: to show the mapping of software to hardware configurations.Interaction diagrams (i.e., collaboration and sequence diagrams): to illustrate behavior.Activity diagrams: to illustrate the flow of events in a use-case.A diagram is a view into a modelA model is a complete description of a system from a particular perspective规则命名规定对要素(事物)、关系、图命名。例如：student为一个类的名字范围UML成员所定义的内容起作用的上下文环境。可视性UML成员能被其他成员引用的方式。三种：public（+）：公共protected（#）：保护private（-）：私有完整性保证事物正确、一致地相互联系。执行运行或模拟动态模型的含义是什么UML的公共机制UML的公共机制有：规范说明修饰通用划分扩展机制规格说明，pecificationUML对每一个元素都有确定的图形表示符号，但对该图形符号还有语法、语义的文字说明。例如，Actor：参与者，UML表示为：修饰，adornment图形符号表示一个元素的主要特征，此外，可以加上修饰，表示该元素的其它特征。例如：矩形框表示一个类，有类名，属性，操作等。但也可增加“可视性” 等修饰。通用划分（common division）一种保证不同抽象概念层次的机制。有两种通用划分的形式：抽象-实例：例如，类-对象，用例-具体用例接口-实现：接口表示约定，实现表示对约定的实施Extension mechanism of the UMLStereotypeTagged valueConstraintExtension mechanism - StereotypesA stereotype is an extension of the vocabulary of the UML, allowing you to create new kinds of building blocks similar to existing ones but specific to your problem.Stereotypes must be based on certain existing types or classes in the metamodel. Stereotypes may extend the semantics, but not the structure of pre-existing types and classes. Certain stereotypes are predefined in the UML, others may be user defined.Extension mechanism - Tagged ValuesMany kinds of elements have detailed properties that do not have a visual notation. In addition, users can define new element properties using the tagged value mechanism.A tagged value is an extension of the properties of a UML element, allowing you to create new information in that element’s specification.A tagged value is a keyword-value pair that may be attached to any kind of model element. The keyword is called a tag.Common examples of tagged values are：{Author = (Dave,Ron)}{Version Number = 3}{Location = d:\java\uml\examples}{Location = Node: Middle Tier}Extension mechanism - ConstraintA constraint is an extension of the semantics of a UML elements, allowing you to add new rules or to modify existing ones.Constraints may be written as free-form text. If you want to specify your semantics more precisely, you can use the UML’s Object Constraint Language (OCL).小结Modeling Comments - use notesModeling New Building Blocks - use stereotype.Modeling New Properties - use tagged values.Modeling New Semantics - use constraintUML的4+1视图UML可以用在系统开发的各个阶段业务模型：业务用例图，活动图，状态图，实体图；需求模型：用例图，活动图，状态图等逻辑模型：类图，交互图，活动图，状态图等设计模型：类图，交互图，活动图，状态图等实现模型：构件图等测试模型：用例图，类图，交互图等用例A sequence of actions a system performs that yields an observable result of value to a particular actorUML中用例用椭圆表示，使用动宾结构或主谓结构命名。用例的特点用例从使用系统的角度描述系统中的信息，即站在系统外部查看系统功能，不反映功能的实现方式。用例描述用户提出的一些可见需求，对应一个具体的用户目标。用例反映系统与用户的一次交互过程，应该具有交互的信息的传递。用例是对系统行为的描述，属于UML的动态建模部分。通过读卡机，储户插入ATM卡ATM系统从卡上读取银行ID、帐号、并验证帐号。储户键入密码，系统检验密码。储户按确认键，输入取款金额。ATM把帐号和取款金额传递给银行系统，取回帐户余额。ATM输出现金，并显示帐户余额。ATM记录事务到日志文件。What Is an ActorActors are not part of the system.Actors represent roles a user of the system can play(扮演).They can represent a human, a machine, or another system.They can actively interchange（交换） information with the system.They can be a giver of information.They can be a passive recipient of information.Actors are EXTERNAL.参与者参与者(actor)是指系统以外的、需要使用系统或与系统交互的事物，包括: 人、设备、外部系统等。其它译名有: 活动者、执行者、行动者等。例，一个银行业务系统中的参与者：客户：从系统获取信息并执行金融交易管理人员：创建系统的用户，获取并更新信息厂商：接受作为转账支付结果的资金Mail系统：与系统交互，发送或接收邮件An actor represents a role that a human, hardware device, or another system can play.UML中的Actor实际上是一个版型化的类, 可以有三种表示形式：由于Actor实际上是一个类, 因此它们之间可以存在一定的关系,如：脚本脚本(scenario)在UML中指贯穿用例的一条单一路径，用来显示用例中的正常和特殊情况。系统在某个特定的执行期内所发生的一系列事件。其它译名：情景、场景、情节、剧本。每个用例有一系列脚本，包括一个主要脚本，以及几个次要脚本。相对于主要脚本，次要脚本描述了执行路径中的异常或可选择的情况。用例之间的关系用例与参与者之间：关联(association)关系。用例之间的关系有：泛化(generalization)、包含(include)、扩展(extend)等。关联关系参与者与用例之间是关联关系，表示参与者与用例之间具有使用，交互信息的关联。泛化关系泛化关系代表一般与特殊的关系，与继承类似。在泛化关系中，子用例继承了父用例的行为和含义，子用例也可以增加新的行为和含义或覆盖父用例中的行为和含义。包含关系包含关系是指一个用例（基本用例）的行为包含了另一个用例（包含用例）的行为。包含关系是依赖关系的版型。扩展关系扩展关系的基本含义与泛化关系类似，但对扩展用例有更多限制, 即基本用例必须声明若干“扩展点”，扩展用例只能在扩展点上增加行为和含义，以扩展到新用例。扩展关系是依赖关系版型。关系比较扩展关系的基本用例是 well formed 的。一个基本用例执行时，可以执行或不执行扩展用例。包含关系的基本用例可以不是或是 well formed 的。执行基本用例时，一定会执行包含用例。需要重复处理两个或多个用例时吗，可以考虑包含关系。处理正常行为的变型且只是偶而描述时，可以考虑只使用泛化关系。处理正常行为的变型且希望采用更多控制方式时，可以在基本用例中设置扩展点，使用扩展关系。用例的描述用例描述是指对一个用例的功能进行的文字描述，是参与者与系统交互动作序列的说明。用例描述才是用例的主要部分，是后续的交互图分析和类图分析必不可少的部分。用例采用自然语言描述参与者与系统的交互行为，要易于理解，其读者是开发人员、用户、项目经理、测试人员等。错误描述正确描述用例规约的主要组成用例名称用例标识涉及的参与者描述用例的规格说明前置条件 PreConditions后置条件 PostConditions正常事件流 Flow of events备选事件流 Alternate flow其它非功能需求、设计约束、尚存在的问题前置、后置条件-1前置条件约束在用例开始前系统的状态把它们看做是看门人，它阻止参与者触发该用例直到满足所有条件说明在用例触发之前什么必须为真后置条件约束用例执行后系统的状态用例执行后什么必须为真对于有多个事件流的用例，则应该有多个后置条件事件流描述要点只书写“可观测”的语句、系统通过ADO建立数据库连接，传送SQL查询语句，从“商品表”查询商品的详细信息……系统按照查询条件搜索商品的详细信息使用主动语句句子必须以参与者或系统作为主语出纳员接收顾客的付款—顾客的付款数可能高于商品总额出纳员录入顾客所付的现金总额系统显示出应找还给顾客的余额，打印付款收据不要涉及界面细节会员从下拉框中选择类别会员在相应文本框中输入查询条件会员点击“确定”按钮分支和循环分支：参与者的选择分支：另一条成功线路分支：系统进行验证循环：直接描述寻找用例的方法start with actors, then identify what they want to do What functions will the actor want from the system系统是否存储和检索信息Are any actors notified when the system changes ?Are there external events that notify the system ?哪个参与者触发了活动？Which actors trigger activity ?用例的常见问题分析用例的粒度问题对于一个目标系统进行用例分析后得到的用例数目有多少比较合适?用例要有路径，路径要有步骤；而这一切都是可观测的最常犯错误：粒度过细，陷入功能分解。过细的粒度，一般都会导致技术语言的描述，而不再是业务语言。如把步骤当用例，或者把系统活动当用例。用例模型用例模型包括：系统边界参与者用例用例图用例描述是面向对象设计的输入是开发部门与顾客之间的合同是软件设计部门与软件工程师之间的合同是开发部门领导、非直接开发人员，了解系统的主要信息来源交互图的概念交互图(interaction)：用来描述对象之间及对象与参与者之间的动态协作关系，以及协作过程中行为次序的图形文档。交互图的类型：顺序图，协作图交互图的作用：用于描述用例的行为，显示该用例中所涉及的对象和这些对象之间的消息传递情况。顺序图的概念顺序图(sequence diagram)：用来描述为了完成确定事务，对象之间按照时间进行消息交互的顺序关系。对象及命名生命线表示对象存在的时间，对象下面一条虚线表示。控制焦点(Focus of Control, FOC)小矩形，表示这个时间段内对象将执行操作。激活期休眠的对象收到一个消息时，开始活动，称为激活激活的对象要么执行自己的代码，要么在等待另一个对象的返回激活期外，对象处在休眠期，什么事都不做，但它仍然存在，等待消息的激活消息带箭头的连线，表示对象之间传输的信息。消息解释对象之间传输的信息。消息有以下类型：调用消息（procedure call）调用消息(也称为同步消息)的发送者把控制传递给接收者，然后停止活动，等到消息接收者放弃或返回控制。调用消息必有一个与之配对的返回消息, 但是可以不用画出.异步消息异步消息的发送者通过消息把信号传递给接收者，然后继续自己活动，不等待接收者返回消息或控制。返回消息返回消息表示从过程调用返回。如果是从过程调用返回，则返回消息是隐含的，可以不画出来。对于非过程调用，如果有返回消息，必须画出来。消息的语法格式display (x,y) 简单消息p:= find (specs) 嵌套消息，消息带返回值、[x&lt;0]5: invert (x,color) 条件消息[i:=1..n]: update() 循环消息建立顺序图从用例中识别交互过程;识别参与交互过程的对象;为每一个对象设置生命线,并确定对象的存在期限;哪些对象存在于整个交互过程，哪些对象在交互过程中被创建和销毁。从引发交互的初始消息开始,在对象生命线上依次画出交互的消息;Use Case：Register New MemberThe customer fills out an application form containing the customer’s name, address and phone number and gives this to the clerk.The clerk issues a request to add a new member.The system asks for data about the new member.The clerk enters the data into the system.Reads in data, and if the member can be added, generates an identification number for the member and remembers information about the member. Informs the clerk if the member was added and outputs the member’s name, address, phone and id.The clerk gives the user his identification number.Use Case：Adding New BookThe library receives a shipment of books from the publisherThe clerk issues a request to add a new book.The system asks for the identifier, title, and author name of the book.The clerk generates the unique identifier, enters the identifier, title, and author name of a book.The system attempts to enter the information in the catalog and informs the clerk about the result. It then asks if the clerk wants to enter information about another book.The clerk answers in the affirmative or in the negative.If the answer is in the affirmative, the system goes to Step 3. Otherwise, it exits.用例：借书参与者：图书管理员事件流：管理员进入图书借阅界面，用例开始。管理员输入借书证上的读者编号。系统检验借书证合法性吗，如果正确,则显示借阅者(姓名、学院、年级等信息)及其以前所借图书的信息。A1：借书证编码有错。A2: 如果该借阅者所借图书已经超期，则提示，本次拒借。管理员输入图书条码。系统显示所借图书的信息。管理员确认借书，系统保存借书信息（包括时间，读者号，图书编号等）。用例结束。协作图协作图的概念：用来描述系统的行为是如何由系统的成分协作实现的图，各对象之间消息联系的结构关系。协作图样式和元素：建立协作图从用例中识别交互过程;识别参与交互过程的对象;确定对象之间的链，以及链上的消息;从引发交互的初始消息开始,将随后每个消息附在相应的链上;顺序图与协作图的异同顺序图和协作图都属于交互图,用来描述对象之间的动态关系。顺序图强调消息的时间顺序，协作图强调参与交互的对象的组织关系。顺序图和协作图在语义上是等价的，两者可以相互转换。写出Class A伪代码图书馆还书处理的交互图用例：还书参与者：图书管理员事件流：管理员进入图书借阅界面，用例开始。系统要求输入读者编号及所还图书的条码。管理员输入相应信息。系统显示所还图书的图书、读者信息、借书记录信息。图书管理员确认还书（登记还书时间）。用例结束。识别交互过程读者在还书时，先由管理员把借书证上的读者编号及所借图书的图书编号扫描给系统，系统接收到这个信息，则显示这个该读者信息,以及这本书的信息、借书记录信息。管理员确认还书,则系统登记还书信息，并返回还书成功信息，还书过程完成。画图类的概念类的定义：类(class): 具有相似结构、行为和关系的一组对象。缩略表示：类的版型边界类边界类位于系统与外界的交界处,承担系统与外界的信息交互功能。边界类处在用例图中，参与者与用例的关联处，可以根据用例图发现边界类。实体类实体类对应着现实中的客观实物，用来保存信息，一般对应着数据表、文件等。实体类可以从现实中存在的客观事物，以及需要持久存放的信息两方面来发现。控制类控制类负责其他类工作的类，控制调控的作用。一个用例中最少会有一个控制类，用来控制用例中的事件顺序，也可以在多个用例之间共用。控制类较少接收消息，发出较多(控制)消息。类之间的关系关联模型元素之间的一种语义联系,它是对具有共同的结构特性、行为特性、关系和语义的链接（link，对象之间物理上或概念上的连接）的描述。关联可以分为单向关联，双向关联。关联的特性关联名：用来描述关联的作用。关联的角色：关联的两端可以以某种角色参与关联。关联的多重性：表示可以有多少个对象参与该关联。关联类：通过关联类描述关联的属性，操作，及其它信息。增加关联类的准则有某个属性与关联相关关联类的实例具有依赖于关联的生命期两个概念之间有多对多关联，并且存在与关联自身相关的信息关联的约束通过约束加强关联的含义。例如，“帐户”不能同时与“人”和“公司”有关联。限定关联通过限定符(qualifier)来规定关联的限定关系。关联的种类一元(自返)关联二元关联三元关联三元关联是功能齐全的关联，可以有关联类。多元关联编程语言不能表示多元关联，需要提升为一个类聚集和组合聚集聚集(aggregation): 表示类之间一种松散的整体与部分的组成关系，是一种特殊的关联。组合组合(composition)：表示类之间一种紧密的整体与部分的组成关系，也是一种特殊的关联。聚集与组合的区别聚集松散，组合紧密一个部分事物对象可以属于多个聚集对象,但一个部分事物对象仅能属于一个组合对象聚集的对象生命周期可以不同,但组合对象则是同存同亡。泛化泛化(generalization)：表示事物之间的一般与特殊的关系；也可以称为继承关系。泛化关系除了表示类与类之间的关系之外，还可以表示参与者、用例、包、构件、接口等建模元素之间的关系。依赖依赖(dependency): 表示两个元素X、Y，如果X的变化必然导致Y的变化，则称Y依赖X。依赖关系不仅限于类，用例、包、构件之间都可以存在依赖关系。 如果类A和类B有关联关系，那么就有依赖关系。只表示出关联关系，不用表示出依赖关系。依赖关系本身不生成专门的实现代码。派生属性和派生关联派生属性和派生关联的概念：可以从其它属性或关联计算推演得到的属性和关联。在派生的名字前面加/，以示区别。派生容易产生不一致，应注意。抽象类和接口抽象类：只有声明，没有具体实现，不能实例化；接口：不包含属性，只有方法声明类图类图(Class Diagram): 是由类，相关建模元素（接口、包），及其关系构成的图，用来描述类之间的静态关系。类图在系统中处在核心位置。也是UML中最为重要的一种图。售票系统的类图：顾客可多次订票，但每一次订票只能由一个顾客来执行。有两种订票方式：个人票或套票；前者只是一张票，后者包括多张票。每一张票不是个人票就是套票中的一张，但是不能又是个人票又是套票中的一张。每场演出都有多张票可供预定，每张票对应一个唯一的座位号。每次演出用剧目名、日期和时间来标识。类图的抽象层次在系统的不同开发阶段，类图可以具有不同的抽象程度。随着开发的深入，类图应该越来越详细、具体。可以分为：概念层，说明层，实现层。构造类图寻找类的方法根据用例描述中的名词确定候选类。根据边界类、控制类和实体类的划分来帮助发现类。参考设计模式来确定类。根据软件开发过程的指导寻找类。构造类图时注意不要试图使用所有的符号，20％的建模元素能满足80％的建模需求。不要过早陷入细节, 根据不同阶段，采用不同层次类图，逐步细化。构造完成要将模型与目标问题对照验证其是否合理，是否反应了应用领域的实际情况。对象图对象图的概念对象图表示一组对象及其它们之间的联系。对象是系统的详细状态在某一时刻的快照，通常用来表示复杂类图的一个实例。说明对象图并不在任何时间都是必须的；Rose2003不支持对象图。类的关系具有四种关联：表示类中对象之间的链接关系组成：表示事物之间的整体和部分关系，（聚合，组合）泛化：表示事物的一般和特殊关系依赖：事物之间的因果关系状态图状态图(state chart diagram)：用来描述一个特定的对象所有可能的状态，以及由于各种事件的发生而引起的状态之间的转移和变化。状态图的要素—–状态概念是指对象在其生命周期中，满足某些条件、执行某些活动、或等待某些事件时的一个状况（时间段）。状态的表示和要素状态的表示：用圆角的矩形框表示状态。状态的要素：包括状态名，进入/退出动作、内部转移，子状态等。eg:状态的类型初态、终态、中间状态、组合状态、历史状态等。一个状态图只能有一个初态，但是结束状态可能有多个，也可以没有终态。组合状态和子状态嵌套在另一个状态中的状态称为子状态;包含子状态的状态称为组合状态.历史状态历史状态是伪状态, 其目的是记住从组合状态中退出时所处的子状态, 当再次进入组合状态时, 可以直接进入这个子状态, 而不是再从组合状态的初态开始.浅(shallow)历史状态，只记住最外层组合状态的历史深(deep)历史状态, 可以记住任意深度的组合状态的历史.状态图的要素—–转移转移(transition): 是一个状态向另外一个状态的转换（瞬时变化）。转移是两种状态之间的一种关系，表示对象将在第一个状态执行一定的动作，并在某个特定事件发生且满足某个特定的警戒条件时进入第二个状态。转移的格式：event-name [‘(‘parameters’)’] [‘[’guard-condition’]’] [’/’action]对于一个给定的状态，最终只能产生一个转移，因此从一个状态出发的几个转移之间应该是互斥的，包括：事件不同；事件相同但警戒条件互斥。状态图的要素—–事 件概念事件(event)：是指在确定的时间和位置所发生的对于对象起作用的事情。事件的发生将引起一些动作，使对象发生状态的转移。动作（action）：动作是对象类中一个操作的执行，动作具有原子性和不可中断特性。描述事件名称[参数表]字符串，常为接收对象类中的一个操作。事件的形式参数，可以省略事件的类型调用事件(call event)：是表示对操作的调用变化事件(change event)：因满足某种条件（参量变化）而引起的事件，变化条件用when表示。(由满足布尔表达式而引起的事件，不断测试表达式，直到表达式为真)时间事件：满足某一时间表达式而引起的事件,时间事件用after,when表示。状态图的作用用来描述一个对象在其生命周期中所表现出来的状态和行为。当在系统建模过程中需要描述某个事物或对象的不同状态，以及状态之间转移的事件和动作时，用状态图。 但状态图并不是对每一个对象都需要的。如何绘制状态图选择对象与视点寻找主要的状态确定状态之间的转移（换）细化状态内的活动与转换用组合状态来展开细节活动图活动图(activity diagram)是UML的动态视图之一，用来描述系统的工作流程和并发行为。活动图是状态图的一个变体，活动图中一个活动结束后将立即进入下一个活动（不需要事件的触发）。使用活动图活动图的用途是对人类组织的现实世界中的工作流程建模。也可以对具体操作建模，用于描述计算过程的细节。活动图有助于理解系统高层活动的执行行为，而不涉及建立交互图所必须的消息传送细节。软件公司可以用活动图对一个软件的开发过程建模；会计师事务所可以用活动图对任意数目的财务往来进行建模；贸易公司可以用活动图对订单批准过程进行建模；科研人员还可以对诸如求Fibonacci数列第n个数的数值之类的操作进行建模。活动图的要素活动是活动图主要结点,用两边为弧的条形框表示,中间填活动名 。活动流（控制流）描述活动之间的有向关系，反映一个活动向另外一个活动之间的转移。用带箭头的实线表示。分支表示从一个活动按照某种条件转移到几个不同的活动。分叉和汇合表示并发的同步行为，用同步杆表示。分叉表示一个控制流被多个控制流替代，替代后的控制流是并发的。汇合与分叉含义相反。泳道是活动图中的区域划分，每一个泳道代表一个责任区域。一个泳道中包括一组相关活动。对象流反映活动与对象之间的依赖关系，表示对象对活动的作用或活动对对象的影响，用依赖关系表示。活动图的用途活动图具有广泛地用途,在软件建模中,活动图可以用来：描述工作流：也被称为业务流程，通常对于涉及众多参与者的非常复杂的业务流程建模，简单的业务流程，用例文本就够用了。总之，分析理解用例。用户下订单后，填写收货信息，选择支付方式，如果用户想要取消订单或订单超过了时限则该订单取消，否则系统处理付款，生成送货单，然后由供应商发货，修改订单项状态，然后等所有的订单项全都送货完毕，这样一笔订单就完成了。描述算法流程例绘制一张活动图，描述登录电子邮件系统的细节。状态图与活动图的比较都是对系统的动态行为建模描述对象不同状态图：描述对象状态及状态之间的转移；活动图：描述从活动到活动的控制流。使用场合不同状态图：描述对象在其生命期中的行为状态变化；状态图中的动作和事件对应类模型中对象上的操作。活动图：描述工作流程的过程变化。分析用例、理解涉及多个用例的工作流程等。OOADWhat is Analysis ?Analysis is investigation of the problem and requirements, rather than a solution.For example, if a new online trading system is desired,how will it be used? What are its functions?requirements analysis ：an investigation of the requirementsWhat is design?Design is a conceptual solution that fulfills the requirements 概念性的、满足 需求的解决方案Design is a conceptual solution that fulfills the requirements。What is OOAfinding and describing the objects or concepts in the problem domainWhat is OODdefining software objects and how they collaborate to fulfill the requirementsFor example, Airplane example of object and class discoveryOOAin the case of the flight information system, some of the concepts include：Plane, Flight, and Pilot.OODa Plane software object may have a tailNumber attribute and a getFlightHistory() method.OOAD Simple ExampleRudimentary（最基本的过程） processDice game exampleStep1: Use CasePlayer is requested to roll the dice.System presents results:If the dice face value totals (&gt;=)seven, player wins; otherwise, player losesStep2: Domain ModelOOA的结果体现在领域模型中，显示重要的领域概念或者对象What is domain model?a visual representation of conceptual classes or real-situation(真实) objects in a domain.Domain models have also been called conceptual models , domain object models, and analysis object models.有哪些概念类呢？Step3: InteractionsAssignment of responsibilities among objectsSequence or Communication diagrams在现实里，是Player扔的骰子。在软件设计中，由DiceGame 对 象 扔 骰 子dice (给Dice 对象发送一个消息)。 软件设计需要从真实世界的事物中获取一些灵感、启发，但是，不能完全模仿真实世界。Step4: Design Class Diagrams (DCD)Software classes（软件类） with methods according to responsibilities and attributes according to visibilitythe domain model showing real-world classesthis diagram shows software classesObject Oriented AnalysisIdentifying objects 识别对象Organising the objects: 组织对象classifying the objects identified, so similar objects can later be defined in the same class.Identifying relationships between objects: 定义对象之间的关系this helps to determine inputs and outputs of an object.Defining operations of the objects: 定义对象的操作the way of processing data within an object.Also known as ‘responsibility assignment’这一步，主要在设计阶段完成Defining objects internally: 定义对象内部细节information held within the objects.名词法定义概念名词法定义概念类The system controls a recycling machine for returnable bottles, cans and crates. The machine can be used by several customers at the same time and each customer can return all three types of item on the same occasion. The system has to check, for each item, what type has been returned.The system will register how many items each customer returns and when the customer asks for a receipt, the system will print out what was deposited , the value of the returned items and the total return sum that will be paid to the customer.recycling machinebottles, cans, and cratesmachinecustomers, customertypes of item, item, type, returned itemssystemreceipt(收据)return sum分析模型法用于描述系统规格说明一个健壮、稳定的模型，必须与实现环境无关实现环境的任何变化，不会影响到系统的逻辑结构分析模型能够关注到系统的信息、行为、展示（输入/出）等特性特性：Behaviour - Information - PresentationThe model is defined in information - behaviour - presentationspace.分析模型的语义An entity object models information that shows the state of a system. This information is often used to record the effects of operations and therefore is related to the behaviors of the system.A boundary/interface object models inputs and outputs and operations that process them.A control object models functionality/operations regarding to validate and decide whether to process and pass information from the interface object to the entity object or the way around.分析模型的使用Identifying interface objectsfunctions directly related to actorsIdentifying entity objectsinformation used in an use case and functions of processing the informationIdentifying control objectsfunctions that link interface objects and entity objects1.4 分析模型案例：废品回收机Identifying interface objects：Printer Customer PanelIdentifying entity objectsCrate, Bottle, CanDeposit itemReceipt basisIdentifying control objectsDeposit item receiverCRCClasses (of objects) 类Responsibilities (of the objects in each class) 职责Collaborations (with objects in other classes) 协作In UML, these will be examples of “associations”Domain ModelsA domain model is a representation of real-world conceptual classesnot a representation of software components.not a set of diagrams describing software classes,not software objects with responsibilities.A domain model is a visual representation of conceptual classes or real-world objects in a domain of interestThey have also been called conceptual models, domain object models, and analysis object models.Domain Modeling GuidelinesA Common Mistake in Identifying Conceptual ClassesPerhaps the most common mistake when creating a domain model is to represent something as an attribute when it should have been a concept.A rule of thumb (经验法则)to help prevent this mistake is:If we do not think of some conceptual class X as a number or text in the real world, X is probably a conceptual class, not an attribute.As an example, should store be an attribute of Sale, or a separate conceptual class Store?In the real world, a store is not considered a number or text - the term suggests a legal entity, an organization, and something occupies space. Therefore, Store should be a concept.As another example, consider the domain of airline reservations. Should destination be an attribute of Flight, or a separate conceptual class Airport?In the real world, a destination airport is not considered a number or text—it is a massive thing that occupies space. Therefore, Airport should be a concept.What are System Sequence Diagrams?A system sequence diagram (SSD) is a picture that shows, for a particular scenario of a use case, the events that external actors generate, their order and inter-system （与系统交互）eventsAll systems are treated as a black box; the emphasis of the diagram is events that cross the system boundary from actors to systemsGuidelineDraw an SSD for a main success scenario of each use case, and frequent or complex.alternative scenariosThe Relationship between SSDs and Use Cases?Why draw SSD?Basically, a software system reacts to three things:external events from actors (humans or computers),timer events,faults or exceptions (which are often from external sources).It is useful to know what, precisely, are the external input events— the system events. They are an important part of analyzing system behaviorBefore proceeding to a detailed design of how a software application will work, it is useful to investigate and define its behavior as a “black box.“System behavior is a description of what a system does, without explaining how it does it.One part of that description is a system sequence diagram(SSD)Other parts include the use cases and system operation contractsWhat is Contract?(契约)Example : enterItemOperation: enterItem(itemID:ItemID,quantity:integer)Cross References: Process SalePreconditions: There is a sale underwayPostconditions:A SalesLineItem instance sli was created(instance creation)sli was associated with current Sale(association formed)sli.quantity became quantity(attribute modification)Sli was associated with a ProductDescription, based on itemID match (association formed)分层架构可以做到关注分离（separation of concerns），减少耦合和依赖性，增强内聚性封装和分解了相关的复杂性某些层可以被替换（例如UI层）较低层可以被复用通过逻辑划分，有助于团队开发Designing Objects(对象设计)Static modeling (Design Class Diagram, Package)Dynamic modeling (Sequence and Communication Diagram)Principles of responsibility assignmentDesign PatternGRASPGeneral Responsibility Assignment software patterns.Doing responsibilities of an object include:doing something itself, such as creating an object or doing a calculationinitiating action in other objectscontrolling and coordinating activities in other objectsKnowing responsibilities of an object include:knowing about private encapsulated dataknowing about related objectsknowing about things it can derive or calculateFor example“a Sale is responsible for creating SalesLineItems” (a doing),“a Sale is responsible for knowing its total” (a knowing).GRASPGRASP - CreatorProblem:Who creates an A?SolutionAssign class B the responsibility to create an instance of class A if one of these is true (the more the better):B “contains” or compositely aggregates A.B records A.B closely uses A.B has the initializing data for A.GRASP - Information ExpertProblem:What is a basic principle by which to assign responsibilities to objects?SolutionAssign a responsibility to the class that has the information needed to fulfill it.GRASP - Low CouplingProblem:How to reduce the impact of change?SolutionAssign responsibilities so that (unnecessary) coupling remains low.Use this principle to evaluate alternatives.DiscussionWhat is Coupling ？面向对象语言中，TypeX到TypeY耦合的常见形式？GRASP - ControllerProblem:What first object beyond the UI layer receives and coordinates (“controls”) a system operation?SolutionAssign the responsibility to an object representing one of these choices:Represents the overall “system,” a “root object,” a device that the software is running within, or a major subsystem (these are all variations of a facade controller). 外观控制器Represents a use case scenario within which the system operation occurs (a use case or session controller)，Handler. 会话控制器GRASP - High CohesionProblem:How to keep objects focused, understandable, and manageable, and as a side effect, support Low Coupling?SolutionAssign responsibilities so that cohesion remains high.Use this to evaluate alternatives.OO设计的原则开闭原则(Open/Closed Principle, OCP)Liskov替换原则(Liskov Substitution Principle, LSP)依赖倒置原则(Dependency Inversion Principle, DSP)接口分离原则(Interface Segregation Principle, ISP)GoF设计模式的分类创建型：抽象了创建对象的过程，使得系统不依赖于系统中的对象是如何创建、组合和表示的。例如：Factory method, Singleton.结构型：描述如何组合类和对象。例如：Adapter，Façade行为型：描述算法和对象间职责的分配。主要考虑对象之间的通信方式。例如：Iterator, Visitor]]></content>
      <categories>
        <category>课内学习</category>
      </categories>
      <tags>
        <tag>课内学习</tag>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo上传本地图片]]></title>
    <url>%2Fposts%2F1576.html%2F</url>
    <content type="text"><![CDATA[步骤找到Hexo下的_config.yml里的post_asset_folder，把这个选项从false改成true。在博客根目录下执行一个下载上传图片插件的命令npm install hexo-asset-image --save。插件地址：https://github.com/dangxuandev/hexo-asset-image之后再使用hexo new xxx就会在_post目录下生成xxx.md文件和xxx目录。在xxx.md文件中要插入图片时，先要把所要插入的图片放在生成的同名文件夹下。利用markdown的语法将文件引入文章中。提交到github上时就可以有图片了。Bug修复插件有一个bug，使用时可能会出现如下问题：12345678910111213141516171819202122TypeError: Cannot read property &apos;replace&apos; of undefinedat Object. (D:\blog\isjinhao\node_modules\hexo-asset-image\index.js:31:38)at initialize.exports.each (D:\blog\isjinhao\node_modules\hexo-asset-image\node_modules\cheerio\lib\api\traversing.js:293:24)at Hexo. (D:\blog\isjinhao\node_modules\hexo-asset-image\index.js:29:16)at Hexo.tryCatcher (D:\blog\isjinhao\node_modules\bluebird\js\release\util.js:16:23)at Hexo. (D:\blog\isjinhao\node_modules\bluebird\js\release\method.js:15:34)at Promise.each.filter (D:\blog\isjinhao\node_modules\hexo\lib\extend\filter.js:63:65)at tryCatcher (D:\blog\isjinhao\node_modules\bluebird\js\release\util.js:16:23)at Object.gotValue (D:\blog\isjinhao\node_modules\bluebird\js\release\reduce.js:155:18)at Object.gotAccum (D:\blog\isjinhao\node_modules\bluebird\js\release\reduce.js:144:25)at Object.tryCatcher (D:\blog\isjinhao\node_modules\bluebird\js\release\util.js:16:23)at Promise._settlePromiseFromHandler (D:\blog\isjinhao\node_modules\bluebird\js\release\promise.js:512:31)at Promise._settlePromise (D:\blog\isjinhao\node_modules\bluebird\js\release\promise.js:569:18)at Promise._settlePromise0 (D:\blog\isjinhao\node_modules\bluebird\js\release\promise.js:614:10)at Promise._settlePromises (D:\blog\isjinhao\node_modules\bluebird\js\release\promise.js:694:18)at _drainQueueStep (D:\blog\isjinhao\node_modules\bluebird\js\release\async.js:138:12)at _drainQueue (D:\blog\isjinhao\node_modules\bluebird\js\release\async.js:131:9)at Async._drainQueues (D:\blog\isjinhao\node_modules\bluebird\js\release\async.js:147:5)at Immediate.Async.drainQueues [as _onImmediate] (D:\blog\isjinhao\node_modules\bluebird\js\release\async.js:17:14)at runCallback (timers.js:705:18)at tryOnImmediate (timers.js:676:5)at processImmediate (timers.js:658:5)这是插件的index.js文件中存在bug，把node_modules/hexo-asset-image/index.js的内容修改为：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657'use strict';var cheerio = require('cheerio');// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-stringfunction getPosition(str, m, i) &#123; return str.split(m, i).join(m).length;&#125;var version = String(hexo.version).split('.');hexo.extend.filter.register('after_post_render', function(data)&#123; var config = hexo.config; if(config.post_asset_folder)&#123; var link = data.permalink; if(version.length &gt; 0 &amp;&amp; Number(version[0]) == 3) var beginPos = getPosition(link, '/', 1) + 1; else var beginPos = getPosition(link, '/', 3) + 1; // In hexo 3.1.1, the permalink of "about" page is like ".../about/index.html". var endPos = link.lastIndexOf('/') + 1; link = link.substring(beginPos, endPos); var toprocess = ['excerpt', 'more', 'content']; for(var i = 0; i &lt; toprocess.length; i++)&#123; var key = toprocess[i]; var $ = cheerio.load(data[key], &#123; ignoreWhitespace: false, xmlMode: false, lowerCaseTags: false, decodeEntities: false &#125;); $('img').each(function()&#123; if ($(this).attr('src'))&#123; // For windows style path, we replace '\' to '/'. var src = $(this).attr('src').replace('\\', '/'); if(!/http[s]*.*|\/\/.*/.test(src) &amp;&amp; !/^\s*\//.test(src)) &#123; // For "about" page, the first part of "src" can't be removed. // In addition, to support multi-level local directory. var linkArray = link.split('/').filter(function(elem)&#123; return elem != ''; &#125;); var srcArray = src.split('/').filter(function(elem)&#123; return elem != '' &amp;&amp; elem != '.'; &#125;); if(srcArray.length &gt; 1) srcArray.shift(); src = srcArray.join('/'); $(this).attr('src', config.root + link + src); console.info&amp;&amp;console.info("update link as:--&gt;"+config.root + link + src); &#125; &#125;else&#123; console.info&amp;&amp;console.info("no src attr, skipped..."); console.info&amp;&amp;console.info($(this)); &#125; &#125;); data[key] = $.html(); &#125; &#125;&#125;);]]></content>
      <categories>
        <category>文章编辑</category>
      </categories>
      <tags>
        <tag>文章编辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown数学公式]]></title>
    <url>%2Fposts%2F59718.html%2F</url>
    <content type="text"><![CDATA[符号代码符号代码$\sum$\sum$\sum_{i=0}^n$\sum_{i=0}^n$\pm$\pm$\div$\div$\cdot$\cdot$\times$\times$\mid$\mid$\circ$\circ$\ast$\ast$\bigotimes$\bigotimes$\bigoplus$\bigoplus$\leq$\leq$\geq$\geq$\neq$\neq$\approx$\approx$\prod$\prod$\coprod$\coprod$\cdots$\cdots$\int$\int$\iint$\iint$\oint$\oint$\infty$\infty$\nabla$\nabla$\because$\because$\therefore$\therefore$\forall$\forall$\exists$\exists$\not=$\not=$\not&gt;$\not&gt;$\leq$\leq$\geq$\geq$\not\subset$\not\subset$\emptyset$\emptyset$\in$\in$\notin$\notin$\subset$\subset$\subseteq$\subseteq$\bigcup$\bigcup$\bigcap$\bigcap$\bigvee$\bigvee$\bigwedge$\bigwedge$\biguplus$\biguplus$\bigsqcup$\bigsqcup$\hat{y}$\hat{y}$\check{y}$\check{y}$\breve{y}$\breve{y}$\overline{a+b+c+d}$\overline{a+b+c+d}$\underline{a+b+c+d}$\underline{a+b+c+d}$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$\uparrow$\uparrow$\downarrow$\downarrow$\Uparrow$\Uparrow$\Downarrow$\Downarrow$\rightarrow$\rightarrow$\leftarrow$\leftarrow$\Rightarrow$\Rightarrow$\Longleftarrow$\Longleftarrow$\longleftarrow$\longleftarrow$\longrightarrow$\longrightarrow$\Longrightarrow$\Longrightarrow$\alpha$\alpha$\beta$\beta$\gamma$\gamma$\Gamma$\Gamma$\delta$\delta$\Delta$\Delta$\epsilon$\epsilon$\varepsilon$\varepsilon$\zeta$\zeta$\eta$\eta$\theta$\theta$\Theta$\Theta$\vartheta$\vartheta$\iota$\iota$\pi$\pi$\phi$\phi$\Phi$\Phi$\psi$\psi$\Psi$\Psi$\omega$\omega$\Omega$\Omega$\chi$\chi$\rho$\rho$\omicron$\omicron$\sigma$\sigma$\Sigma$\Sigma$\nu$\nu$\xi$\xi$\tau$\tau$\lambda$\lambda$\Lambda$\Lambda$\mu$\mu$\partial$\partial$\lbrace$\lbrace$\rbrace$\rbrace$\overline{a}$\overline{a}$\frac{7x+5}{1+y^2}$\frac{7x+5}{1+y^2}$\int ^2_3 x^2 {\rm d}x$\int ^2_3 x^2 {\rm d}x$\sqrt[n]{3}$\sqrt[n]{3}$\vec{a} \cdot \vec{b}=0$\vec{a} \cdot \vec{b}=0$\iiint$\iiint$\oint$\oint$\lim$\lim$\infty$\infty$\partial$\partial$\ln15$\ln15$\log_2^{10}$\log_2^{10}]]></content>
      <categories>
        <category>文章编辑</category>
      </categories>
      <tags>
        <tag>文章编辑</tag>
        <tag>markdown</tag>
      </tags>
  </entry>
</search>
