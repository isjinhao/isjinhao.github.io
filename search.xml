<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[09-磁盘存储器的管理]]></title>
    <url>%2F2019%2F09-%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[文件管理的目标是管理文件的组织方式，管理文件的访问权等。而磁盘存储器的管理是管理存储器的使用，如何高效利用存储器。他俩是棋与棋盘的关系。连续组织方式文件的信息存放在若干连续的物理块中。优点简单支持顺序存取和随机存取顺序存取速度快，所需的磁盘寻道次数和寻道时间最少缺点文件不能动态增长（预留空间：浪费、重新分配和移动）不利于文件插入和删除外部碎片问题链接组织方式隐式链接在文件的目录中记录该文件的第一和最后一个盘块的指针，每一个盘块的指针指向文件的下一物理块号。优点文件可动态增长有利于文件的插入和删除提高了磁盘空间利用率,不存在外部碎片问题缺点存取速度慢，不适于随机存取可靠性问题，如指针出错更多的寻道次数和寻道时间链接指针占用一定的空间显示链接将链接文件各物理块的指针显示地放在内存的一张链接表（文件分配表，File Allocation Table）中。在FCB的物理地址中填写其首指针所对应的盘块号。由于文件分配表示存储在内存中的，可以大大减少访问磁盘的次数。FAT微软公司早、中期推出的操作系统一直都是采用的FAT技术，即利用文件分配表FAT来记录每个文件中所有盘块之间的链接。FAT中引入了“卷”的概念，支持将一个物理磁盘分成四个逻辑磁盘，每个逻辑磁盘就是一个卷（也称为分区），每个卷都可以被单独格式化和使用。把盘块作为基本分配单位，同时每个分区中都配有两张相同的文件分配表FAT1和FAT2。FAT技术的发展有三个阶段：FAT12、FAT16和FAT32FAT12FAT表的每个表项占用12个bit。所以最多有$2^{12}$个表项，每个盘块的大小是512B，则每个磁盘分区的容量是2MB，能处理的磁盘最大容量是8MB。为了增大FAT能管理的最大容量，引入了“簇”的概念，每个簇是一组相邻的扇区，这样如果分配时以簇为单位进行分配就能管理更大的磁盘容量，但是相应的簇内零头也会更大，降低磁盘的利用率。FAT16FAT表的每个表项占用16个bit。最多有$2^{16}$个表项。FAT32FAT表的每个表项占用16个bit。最多有$2^{32}$个表项。同时每个簇固定为4KB。所以最大可管理$4 \ast 2^{10} \ast 2^{32} = 2TB$大小的空间。NTFS索引组织方式单级索引组织方式一个文件的信息存放在若干不连续物理块中，系统为每个文件建立一个专用数据结构索引表，并将这些块的块号存放在一个索引表中。一个索引表就是磁盘块地址数组，其中第i个条目指向文件的第i块。·### 多级索引组织方式增量式索引组织方式可以更好的满足大、中、小文件的组织。文件存储空间的管理文件存储空间的管理包括空闲块的组织分配和回收。空闲表法把一个连续未分配区域称为“空闲文件”，系统为所有空闲文件单独建立一个目录。表目内容：序号，第一个空白块号，空白块个数。分配算法：内存管理中的首次适应算法、循环首次适应算法。合并：空闲区邻接合并空闲链表法空闲盘块链：所有空闲盘块拉成一条链，分配时从头分配，回收时链接在尾部。空闲盘区链：每个连续的盘块组成一个盘区，每个盘区包含本盘区的大小和下一个盘区的地址。位示图法用一串二进制位反映磁盘空间中分配使用情况，每个物理块对应一位，分配物理块为1，否则为0。申请物理块时，可以在位示图中查找为0的位，返回对应物理块号；归还时；将对应位转置0。成组链接法（重点）把所有的空闲盘块按每n个一组分成m个组。最后一个组放在内存的空闲盘块号栈中，其他组存在外存上。空闲盘块号栈是一个临界资源，只允许一个进程同时访问。数据结构，一个size为n+1的栈。图上是一个倒着的的栈（栈底在上方，栈顶在下方）一个n+1的栈实际可用盘块只有n（图上只有99个可用盘块），因为栈底是一个计数器，指示当前有多少个可用盘块，但是可用盘块中有一个是指向下一个组，即stack[1]指向下一个组。如果stack[1]==0表示此时是最后一组。分配时从栈顶开始向下分配，直至分配出n-1个盘块，此时如果再想分配一个块就需要把下一个组调入空闲盘块号栈。调入后新组覆盖旧组。然后把新组在外存中占用的盘块分配出去。回收时从栈底向上回收，如果计数器==100时还有空闲盘块（设这个盘块编号为p）要回收，就把空闲盘块号栈内的组取出来存在p中，在空闲盘块号栈内新开辟一个组，新组的stack[1]指向p。例此题题目及来源：https://blog.csdn.net/ajay666/article/details/73569654分配3个盘块后，回收它所占的5个盘块，回收的盘块号依次为700、711、703、788、701，画出分配回收过程。第一次分配第二次分配注意：300号盘块中存储的组信息调入空闲盘块号栈之后其自己也可以被分配。第三次分配第一次回收第二次回收第三次&amp;第四次&amp;第五次回收]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么硬链接不能作用于目录]]></title>
    <url>%2F2019%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%B8%8D%E8%83%BD%E4%BD%9C%E7%94%A8%E4%BA%8E%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[笔者最初遇见这个问题的时候是因为知道了在Linux系统中，目录其实也是一种文件，只不过是一种比较特殊的文件，既然都是文件，那为什么不能对它做硬链接呢？想弄明白这个，就需要知道两个知识，目录和文件共享。因为链接的目的就是要实现文件共享。通常可以定义为文件控制块（FCB）的有序集合。但是并不是说目录中的每一个目录项都是一个FCB，只能是每一个目录项都能唯一确定一个FCB。这是由于如果每个目录项都是FCB会引起文件共享问题。比如下图：对于文件F8，D5:p、D6:e、D3:p都保存了F8的物理地址，即从某个盘块开始，总长度多少等。此时如果D6:e对F8进行了删除操作，D5:p和D3:P都无法察觉，仍然会认为在它们存储的位置上有文件，即一个目录项对文件的操作对其他目录项来说是不可见的。为了解决这个问题，引入索引节点。将文件的物理地址和其他的属性放在索引结点中，只在目录项中存放文件名和指向索引结点的指针。任何用户对文件进行操作，引起相应索引结点内容的改变。此种方法即Linux中的硬链接。所以如果我们对文件做硬链接，比如对Test r做硬链接生成thirdHardLink，那么就是thirdHardLink的指针指向索引节点，索引节点的count修改为3。Linux限制了对目录做硬链接，那么假如我们是设计者，想对一个目录做硬链接可以怎么做呢？第一种方法是把对目录生成的硬链接单独作为一种文件类型，如果我们想使用目录中的某个文件时，操作系统的处理步骤是HardLinkDir-&gt;Dir-&gt;指向索引节点的指针指针-&gt;索引节点。可以看出此种方法的代价很大。第二种方法是把目录的每个目录项拷贝一份，但这样不就是拷贝cp了吗，没有必要再实现对目录的硬链接了。第三种方法是把每个目录项的文件名拷贝一份，HardLink的指针指向原目录项的指针位置。但是这种方法也需要把对目录生成的硬链接单独作为一种文件类型，代价很大。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08-文件管理]]></title>
    <url>%2F2019%2F08-%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[文件管理概述计算机中有很多的程序和数据都是保存在外存中，在需要使用的时候才调入内存中。而如何保存这些信息是很重要的问题，因为不同类型的文件存储的数据格式不同，但这些格式却必须“迎合”硬件只能存储二进制数据的硬性条件。所以操作系统提供了文件管理的功能，让使用者能在不了解文件特性和外存特性的情况下完成文件的存储和查找等功能。同时还提供了文件共享和安全管理等功能。文件系统 &amp; 文件操作系统中负责管理和存储文件信息的软件称为文件管理系统，简称文件系统。包含：文件系统的接口，对对象操纵和管理的软件集合，对象及属性三部分。它负责对文件存储设备的空间进行组织和分配，负责文件存储并对存入的文件进行保护和检索的系统。包含创建文件、删除文件等功能。文件是指具有文件名的若干相关元素的集合，可以分成有结构文件和无结构文件，无结构文件可以看成一个字符流。有结构文件是由一组记录的集合，记录又是一组数据项的集合。数据项：用来描述一个对象的某种属性的字符集。例如学生的学号、姓名等。记录：一组数据项的集合，用来描述一个对象在某方面的属性，例如学生的成绩。能唯一标识一个记录的一个或多个数据项叫做关键字。文件类型不同的文件类型由于本身存储的信息具有不同的结构，在管理的时候也是不同。所以文件会被分成很多类型，下面是常用的文件分类方法：按用途分类：系统文件、库文件、用户文件。按文件中数据的形式分类：源文件、目标文件、可执行文件。按存储控制属性分类：可读、可写、可执行文件。按组织形式和处理方法分类：普通文件、目录文件、特殊文件。剖析文件和目录我们刚才在定义中说道，文件是指具有文件名的若干相关元素的集合，在有结构文件中这些元素是数据项集合的集合，在无结构文件指的是字符流。所以文件的概念中本身是：文件系统的层次结构文件系统从底层到高层可分成三部分：对象及其属性、对对象操纵和管理的软件集合、文件系统接口：对象及其属性：文件管理系统管理的文件如下：文件：在文件管理系统中有着各种不同类型的文件，它们都作为文件管理的直接对象。目录：用于对文件的存储和检索，目录的每个目录项包含了一个文件或目录的信息。磁盘存储空间：文件和目录必定占用存储空间，对这部分空间的有效管理不仅能提高外存的利用率，而且能提高对文件的存取速度。对对象操纵和管理的软件集合：该层是文件管理系统的核心部分。文件系统的功能大多是在这一层实现的。如：文件存储的管理、文件目录的管理、将文件的逻辑地址转换为物理地址的机制、文件读写控制的管理、文件的共享和保护等功能。这些功能被可分为四层：I/O控制层：文件系统的最底层、主要由磁盘驱动程序等组成。基本文件系统层：主要用于处理内存和磁盘之间数据块的交换。基本I/O管理程序：完成与磁盘I/O有关的事务，如将文件的逻辑块号转换为物理块号、管理磁盘中的空闲盘块、I/O缓冲的指定等。逻辑文件系统：管控对文件的操作，如控制用户或应用程序对文件的读写等。文件系统的接口：操作系统提供给用户或应用程序用来使用文件系统的接口：命令接口：用户与文件系统直接交互的接口，如Shell命令。程序接口：应用程序可以通过一系列命令调用文件系统的服务。文件的打开和关闭当用户要求对一个文件实施多次读/写操作时，如果每次都检索目录效率较低，所以为了避免多次重复的检索目录，OS提供了“打开（Open）”操作，当此操作被执行时，OS会把被打开文件的信息存为“打开文件表”的一个条目，然后把这个条目编号返回用户，这样用户就可以通过这个编号和文件之间建立一个连接，也就可以进行文件的读写等操作。当用户再次向系统发出请求时，把这个编号提交给OS，OS通过这个编号在打开文件表中查找文件信息就可以减少检索时间。而关闭就是OS从“打开文件表”上删除此条目，这样断开了用户和文件之间的连接。文件的逻辑结构和物理结构逻辑结构：从用户的角度来看，文件是能被存取的基本单位。物理结构：文件在磁盘上存储时的组织形式。逻辑文件按结构分类有结构文件：每个文件用于描述实体集中的一个实体。每个记录的长度对OS来说都是可知的。但记录之间可以分为定长和变长两种。定长记录：所有记录的长度都是相同的、所有记录中的各数据项都处在记录中相同的位置具有相同的顺序和长度。变长记录：各记录的长度不相同。比如论文的摘要可能长度差距很大，不能在存储之前估计出所需要的空间。无结构文件：系统中运行的大量的源程序、可执行文件、文本文件等都是无结构文件，即流式文件。其文件长度是以字节为单位的。逻辑文件按组织方式分类组织方式指的是文件中记录的组织方式。只对有结构文件有效。可以分成：顺序文件、索引文件、索引顺序文件。顺序文件指由一系列记录按某种顺序排列所形成的的文件。串结构：按存入时间的先后顺序排列。所以检索时必须从头挨个查找，效率低。顺序结构：用户指定一个字段作为关键字，他可以是任意类型的变量。如sql文件。索引文件为变长记录文件创建一张索引表，索引表是定长记录文件，检索时，先查找索引表，再根据指针所指的地址读取记录。可以解决变长文件记录较难直接存取的问题。索引顺序文件将顺序文件的所有记录分成若干组，为顺序文件建立一张索引表，索引表中为每组的第一个记录建立一个索引项。检索时，先检索索引表，找到记录所在记录组的第一个记录的表项，再顺序查找主文件，得到要求的记录。文件目录文件控制块包含三类信息：基本信息类：文件名、文件物理位置、文件逻辑结构、文件物理结构控制信息类：各类用户的读、写、可执行文件等。使用信息类：文件的建立时间，当前的使用信息，上一次修改的时间，是否被进程锁住等。索引节点为了唯一确定外存中的一个文件，必须要把文件的FCB加载进内存，而每次加载的数据大小是一定的，所以为了一次能多加载进内存一个文件标识。将FCB分成两部分：磁盘索引节点文件主标识符文件类型文件存取权限文件物理地址文件长度文件连接计数：本人理解为硬链接计数文件存取时间内存索引节点。索引节点编号状态访问计数文件所属文件系统的逻辑设备号：不明白链接指针：不明白树形结构目录在树形结构目录中，目录应该保存文件的信息。同时目录的目录项要能既作为目录文件的FCB，又作为数据文件的FCB。文件共享基于有向无循环图实现文件共享此种方法存在问题：比如对于文件F8，D5:p、D6:e、D3:p都保存了F8的物理地址，即从某个盘块开始，总长度多少等。此时如果D6:e对F8进行了删除操作，D5:p和D3:P都无法察觉，仍然会认为在它们存储的位置上有文件，即一个目录项对文件的操作对其他目录项来说是不可见的。利用索引节点引入索引结点，将文件的物理地址和其他的属性放在索引结点中，只在目录项中存放文件名和指向索引结点的指针。由任何用户对文件进行Append操作或修改，引起相应索引结点内容的改变。此种方法即Linux中的硬链接。利用符号链接实现文件共享建立符号链接文件，它是一种特殊类型的文件，其内容是被链接文件的路径名。建立符号链接文件，并不影响原文件，实际上它们各是一个文件。可以建立任意的别名关系，甚至原文件是在其他计算机上。只有文件主才有指向索引结点的指针，而其他共享用户只有该文件的路径名。文件保护访问权&amp;保护域访问权：一个进程能对某对象执行操作的权利，用&lt;对象名，权集&gt;表示，如&lt;F1, {R/W}&gt;表示进程对F1有读和写的权利。保护域：进程对一组对象访问权的集合，进程只能在域内进行操作。进程和域的联系方式进程和域之间是一对多的关系，即一个进程可以联系多个域。此时进程的运行分为多个阶段，每个阶段联系一个域，这样就可以根据运行的实际需要规定进程每个阶段所能访问的对象。访问矩阵R：在域内运行的进程对文件具有读权限W：在域内运行的进程对文件具有写权限$R^\ast$：在域内运行的进程能把其对文件的读权限扩展到其他域中，但在其他域中是R权限，不再是$R^\ast$。$W^\ast$：在域内运行的进程能把其对文件的写权限扩展到其他域中，但在其他域中是W权限，不再是$W^\ast$。S：在域Di中运行的进程能转移到域Dj中运行，如图中在域D3运行的进程能转移到域D2中运行。O：在域中运行的进程能增加或删除对某文件的访问权。Control：在域Di中运行的进程能删除在域Dj中运行进程对各对象的访问权。如图中在D2中运行的进程能删除在D3中运行进程的访问权。访问矩阵的实现访问控制表将访问对象按列划分，为每一列建立一张访问控制表，在该表中把属于对象的所有空项都删除。此时表中的每一项都是一个有序对&lt;域，权集&gt;构成。访问权限表将访问矩阵按行划分，每一行是一个访问权限表，表中的每一项表示该域对某对象的访问权限。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07-输入输出系统]]></title>
    <url>%2F2019%2F07-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[输入输出系统和OS中的其他部分有很大区别，因为其他部分都是在说计算机接受任务后该怎么运行能又快又可靠的完成任务并把结果输出。而输入输出系统是怎么快速稳定的将任务的需求输入和任务的结果输出。又由于输入输出设备种类繁多，比如输入设备中的键盘、鼠标、网卡、摄像头，输出设备中的打印机、音频等。所以输入输出系统被划分很多层次来尽可能屏蔽物理细节。IO系统的基本功能隐藏物理设备的细节：只需要使用简单的命令就能操作各种具有不同实现的硬件完成相应需求。与设备的无关性：用户不需要指定哪些设备完成功能，只需要描述需求，OS会选择一个设备完成功能。提高处理机和IO设备的利用率：IO设备之间一般是相互独立的，因此设备之间能够并行操作，所以OS应让处理机和设备之间能并行操作。对IO设备进行控制：轮询的可编程IO方式。采用中断你的可编程IO方式。直接存储器访问方式。IO通道方式。确保对设备的正确共享。错误处理。IO软件的层次结构用户层软件：提供设备与用户交互的接口，用户可以使用该层提供的功能直接控制设备。设备独立性软件：设备分配，设备保护，设备分配，设备回收，数据缓存等。设备驱动软件：发出控制设备的命令。中断处理程序：保存被中断的进程的CPU环境，转入相应的中断处理程序仅需处理，处理完毕后再恢复被中断进程的现场，返回到被中断的进程。IO系统各模块层次视图块设备：输入输出以数据块为单位的设备。如磁盘。流设备：字符设备的输入输出，如键盘。网络通信接口：网卡。IO设备和设备控制器直接和IO设备对接的是设备控制器。作用接收和识别命令（控制寄存器、命令译码器）：设备控制器将CPU送来的命令写入控制器寄存器中，并进行译码。数据交换（数据寄存器）。设备状态的了解和报告（状态寄存器）。地址识别（地址译码器）：系统中的每个设备都有自己的地址段，设备接口电路中有多个寄存器，一个寄存器有唯一的一个地址，每个地址为I/O端口，该地址称为I/O端口地址。设备控制器必须能识别每个设备的地址。数据缓冲：缓冲器。差错控制：差错检测码。组成设备控制器和处理机的接口：用于实现CPU与设备控制器之间的通信。设备控制器和设备的接口。IO逻辑：在一个设备控制器上，可以连一个或多个设备。相应的，在控制器中就有一个或多个设备接口，一个接口连一台设备，控制器中的I/O逻辑根据处理机发来的地址信号，去选择一个设备接口。控制器中的I/O逻辑用来实现对设备的控制。通过接收CPU 发来的命令和地址信息，对所选设备进行控制CPU如何控制设备控制器CPU控制内存时需要指定指令地址、数据地址等。控制设备控制器亦如此，一般有两种控制方式：利用特定IO指令：利用特殊的IO指令控制设备控制器。内存映像IO：不再区分内存和控制器中的寄存器地址。假如有一个地址K，当0&lt;=K&lt;N时被认为是内存地址，K&gt;=N时被认为是寄存器地址。IO通道有了设备控制器之后，CPU便可以操作控制器完成对IO设备的控制，但是此时数据交换仍然需要CPU的全程参与，所以引入IO通道来使数据传送、IO设备的组织管理等都独立于CPU。通道是独立于CPU的专门负责数据输入/输出传输工作的处理机，对外部设备实现统一管理，代替CPU对输入/输出操作进行控制，从而使输入，输出操作可与CPU并行操作。通道执行通道程序来控制IO操作。与CPU的区别：通道程序指令类型单一通道没有自己的内存，通道程序在主机的内存中，即通道与CPU共享内存。字节多路通道主要连接以字节为单位的低速IO设备。如打印机，终端。按字节交叉方式工作的通道。通常含有许多非分配型子通道，其数量从几十个到数百个，每一个子通道连接一台I/O设备。这些子通道按时间片轮转方式共享主通道。字节多路通道以字节为单位传输信息，它可以分时地执行多个通道程序。当一个通道程序控制某台设备传送一个字节后，通道硬件就控制转去执行另一个通道程序，控制另一台设备传送信息。数组选择通道主要连接磁盘，磁带等高速I/O设备选择通道是按数组方式进行数据传送，每次传送一批数据，故传送速度很高。选择通道在一段时间内只能执行一个通道程序，只允许一台设备进行数据传输。当这台设备数据传输完成后，再选择与通道连接的另一台设备，执行它的相应的通道程序。这种独占性又使得通道利用率很低。数组多路通道主要连接高速设备。结合了数组选择通道传送速度高和字节多路通道能进行分时并行操作的优点。它先为一台设备执行一条通道指令，然后自动转接，为另一台设备执行一条通道指令。它含有多个非分配型的子通道，既有很高的数据传输率，又能获得令人满意的通道利用率对通道程序采用多道程序设计的硬件实现可以连接多台高速设备，数据传输按数组方式，一段时间内可以执行多道通道程序解决瓶颈通道执行通道程序，向控制器发出命令，并具有向CPU发中断信号的功能。一旦CPU发出指令，启动通道，则通道独立于CPU工作。但是，由于通道价格贵，通道数量少，往往使之成为IO的“瓶颈”。解决办法是在不增加通道的前提下，增加设备到主机间的通路，一个通道可连接多个控制器，一个控制器可连接多个设备，形成树形交叉连接。中断机构和中断处理程序https://isjinhao.github.io/2019/%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD/#more设备驱动程序功能接受设备独立性软件发来的命令和参数，将接收到的抽象要求转换为具体要求检查用户IO请求的合法性，了解IO设备的状态，传递有关参数，设置设备的工作方式发出IO命令，如果设备空闲，启动IO设备完成指定的IO操作；如果设备忙碌，则将请求挂在设备队列上等待及时响应由控制器或通道发来的中断请求，并根据其中断类型调用相应的中断处理程序进行处理。对于设置有通道的计算机系统，驱动程序还应能够根据用户的IO请求，自动地构成通道程序。特点驱动程序主要是在设备无关性软件和设备控制器之间的一个通信程序驱动程序与IO设备特性密切相关：通常由硬件厂商提供驱动程序与I/O控制方式密切相关:中断驱动和DMA方式驱动程序与硬件相关,部分代码需用汇编语言编写驱动程序应允许可重入处理过程将抽象要求转换为具体要求通常设备控制器中都有若干个寄存器，分别用于暂存命令、数据和参数等；用户及上层软件对设备控制器的具体情况毫无了解，因而只能向它们发出抽象的要求(命令)，但不能直接传送给设备控制器。需要将抽象要求转换为具体要求(命令码，数据，参数)。例如，将抽象要求中的盘块号转换为磁盘的盘面、磁道号及扇区。这一转换工作只能由驱动程序来完成；在OS中只有驱动程序才同时了解抽象要求和设备控制器中的寄存器情况；也只有它才知道命令、数据和参数应分别送往哪个寄存器。检查IO请求的合法性读出和检查设备的状态传送必要的参数，设置工作方式启动I/O设备在完成上述准备工作后，驱动程序可以向控制器中的命令寄存器传送相应的控制命令对于字符设备，若发出的是写命令，驱动程序将把一个数据传送给控制器；若发出的是读命令，则驱动程序等待接收数据，并通过从控制器中的状态寄存器读入状态字的方法，来确定数据是否到达。驱动程序发出IO命令后，基本的IO是在设备控制器的控制下进行的，通常IO操作所要完成的工作较多，需要一定的时间，如读/写一个盘块中的数据，此时，驱动程序进程把自己阻塞起来，直至中断到来时才将它唤醒。对IO设备的控制方式使用轮询的可编程I/O方式CPU发出启动外设的I/O指令，同时将忙/闲标志置为1。如果外设的工作没有完成，则标志一直为1，CPU不断循环检测该标志，直到标志为不忙为止。使用中断的可编程I/O方式CPU设定I/O设备的初始值，然后不再忙等待，运行其他进程，当前进程阻塞；I/O设备完成对当前数据的处理后，向CPU发出中断，I/O中断处理程序将负责传送剩余数据。直接存储器访问(DMA)方式采用中断驱动IO方式时的CPU，是以字为单位进行干预的。如果将这种方式用于块设备的I／O，是极其低效的。如：为了从磁盘中读出1KB的数据块；需要中断1K次CPU。而DMA方式使用独立的DMA控制器代替CPU的工作，I/O设备与DMA通信，DMA在传输完成一个数据缓冲区之后再向CPU发中断。数据传输的基本单位是数据块，即CPU与IO设备之间，每次传送至少是一个数据块，主要用在块设备的IO操作中。在DMA方式中，利用总线直接连接外设和内存，由DMA控制机构窃取总线占有权，完成外设与内存间的成批数据交换。所传送的数据是从设备直接送入内存的，或者相反。仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的，不再需要CPU进行干预。I/O通道控制方式使用DMA方式，CPU每发出一条I/O指令，只能读写一个连续的数据块。如果需要一次去读多个离散的数据块且将它们分别送到不同的内存区域，则需要CPU分别发出多条I/O指令及进行多次中断处理，才能完成。而IO通道可实现CPU、通道和I/O设备三者的并行操作，进一步提高CPU与外设之间的并行工作能力，使I/O操作形成独立于CPU的体系，减少CPU的负担，使外设与内存的数据交换更加灵活，从而更有效地提高整个系统的资源利用率。参见4.4。与设备无关的I/O软件为了便于对外设进行管理，系统对每台进入计算机系统中的设备都给定一个对应的编号，作为调用时识别和区分设备用。这种编号无任何重复，一般被称为设备的绝对号（或物理设备名）。早期操作系统，应用程序直接使用物理设备名称，非常不灵活。所以引入逻辑设备名，规定用户申请外设时，只需要向系统说明所需用的某类设备真正在实际中使用哪台设备，由系统根据这类设备的应用情况作出分配。设备分配在多道程序环境下，设备不允许用户自行使用，而必须由系统分配。对于进程的IO请求，只要是安全（无死锁），设备分配程序便按照一定的策略进行设备分配。数据结构：系统设备表SDT：System Device Table。整个系统中只有一张，全面反映了系统中的外设资源的类型、数量、占用情况等。在SDT表中，每个接入系统中的外围设备都占有一个表目项。登录了该设备的名称、标识、设备控制表DCT的入口地址、设备驱动程序的入口地址及占用设备的进程名称等相关信息。设备控制表DCT ：Device Control Table。每台设备都有一张设备控制表DCT，用于记录本设备的情况。Type：设备类型Deviceid:设备标识符设备队列队首指针设备状态：标识设备忙或者空闲；与设备连接的控制器表指针。重复执行次数控制器控制表COCT：Controller Control Table。每个控制器都有一张，用于记录某控制器的使用分配情况及与该控制器相连的通道的情况。控制器号：控制器的内部标识符。控制器状态：控制器忙/闲，好/坏的状态标志。通道指针：指向与该控制器相联的通道控制表CHCT，当控制器与若干通道连接时该项内含多个指针。等待队列指针：指向等待该控制器的I/O进程队列通道控制表CHCT：Channel Control Table。反映了通道的情况，系统中的每个通道一张CHCT。通道号：通道内部标识符通道状态：通道的各种状态（好/坏，已分/未分等）的反映等待队列指针：等待该通道的I/O进程队列的首位置设备分配算法用户层的I/O软件系统调用与库函数用户层软件必须使用一组系统调用来取得操作系统服务，在高级语言中都提供了相应的库函数来完成此功能。SPOOLing程序多道程序技术将一台CPU虚拟为多台CPU，从而可以提高CPU的利用率。而SPOOLing系统是模拟脱机输入输出系统来实现多个用户共享一台物理IO设备。脱机输入输出系统的IO处理机 对应 SPOOLing程序。脱机输入输出系统的高速缓冲 对应 内存。缓冲区单缓冲区双缓冲区为输入或输出分配两个缓冲区，让两个缓冲区交替工作，形成并行操作的方式。环形缓冲区空缓冲区R：用于存放数据（指针：Nexti）已装满数据的缓冲区G：其中的数据提供给进程使用。（指针：Nextg）现行工作缓冲区C：当前进程使用的缓冲区。（指针：Current）磁盘存储器的性能和调度磁盘是一个扁平的圆盘（与电唱机的唱片类似）。盘面上有许多称为磁道的圆圈，数据就记录在这些磁道上。磁盘可以是单片的，也可以是由若干盘片组成的盘组，每一盘片上有两个面。如下图中所示的6片盘组为例，除去最顶端和最底端的外侧面不存储数据之外，一共有10个面可以用来保存信息。各个盘面上半径相同的磁道组成了一个圆柱面，我们称为柱面 。因此，柱面的个数也就是盘面上的磁道数。磁盘访问时间寻道时间Ts：$T_s = m \times n + s$旋转延迟时间$T_τ$。磁盘访问时间 ：$T_t=\frac{b}{rN}​$：b是传输的字节数，r是每秒的转数，M是一条磁道上的字节数。$总时间 = T_s + \frac{1}{2r} + \frac{b}{rN}$磁盘调度算法假设磁盘访问序列：98，183，37，122，14，124，65，67，读写头起始位置：53。先来先服务按访问请求到达的先后次序服务。最短寻道时间优先扫描算法当设备无访问请求时，磁头不动；当有访问请求时，磁头按一个方向移动，在移动过程中对遇到的访问请求进行服务，然后判断该方向上是否还有访问请求，如果有则继续扫描；否则改变移动方向，并为经过的访问请求服务，如此反复。循环扫描算法CSCAN算法规定磁头单向移动，例如由里向外移动，当磁头移到最外的磁道并访问后磁头立即返回到最里的欲访问磁道，即最小磁道号紧接最大磁道号构成循环，进行循环扫描。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07-Mysql高级操作]]></title>
    <url>%2F2019%2F07-Mysql%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[视图]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06-事务]]></title>
    <url>%2F2019%2F06-%E4%BA%8B%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[ACIDA原子性（Atomicity）：事务是数据库的逻辑工作单位事务中包括的诸操作要么都做，要么都不做。C一致性（Consistency）：事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。一致性状态：数据库中只包含成功事务提交的结果。不一致状态：数据库中包含失败事务的结果。I隔离性（Isolation）：一个事务内部的操作及使用的数据对其他并发事务是隔离的。也就是说一个事务在执行的时候不知道是否有其他事务和它一起在对相同的数据做操作，事务之间是相对不可见的。D持续性（Durability）：持续性也称永久性。一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其执行结果有任何影响。事务的并发问题由于事务的隔离性，不同事务若同时相同的数据做操作，可能会引发问题，即事务的并发问题。按照问题解决的难度由低至高可分为四类。丢失修改一个事务对数据对象的修改被另一个事务的修改所覆盖。分为两类：第一类：事务T1、T2同时读取A为10，T1将A减1后提交，T2将A也减1后提交，此时数据库中数据为9。T1的修改被T2覆盖。第一类：事务T1、T2同时读取A为10，T1将A减1后提交，T2将A也减1后回滚，此时数据库中数据为10。T1的修改被T2覆盖。脏读由于一个事物的回滚，使得另一个事务读到的数据无效。事务T1中读A为100，修改A未300，还未提交时事务T2读C为300，但由于T1因某原因进行事务回滚。A又被重置为100。T2读取到的是脏数据。不可重复读在一个事务的两次“读”同一数据之间，有另一个事务的“updata”发生。如在事务T1中第一次读A为100，读B为200，A+B为300，在事务T2中把A修改为200，事务T2第二次读A为200，读B为200，A+B为400。同一事务两次读取的数据不一致。幻读在一个事务的两次“读”同一数据之间，有另一个事务的“insert”发生。如在事务T1中第一次读count(*)为100，事务T2插入一条数据，事务T1中第二次读count(*)为101，同一事务两次读取的数据不一致。封锁类型加锁是解决事务并发问题的常见手段。数据库中的锁从读写的角度可分为两类：共享锁和排它锁。排它锁（X锁）：只允许当前事务T对数据进行“读”、“写”，其它事务对数据R的任何锁请求被拒绝直到T释放R上的X锁。共享锁（S锁）：允许当前事务T对数据R进行“读”，不允许“写“，而其它事务对R的S申请被允许，X请求拒绝。带来的效果是：X锁：数据对象当前只能由一个事务操作。S锁：多个事务允许同时“读”一个数据。封锁协议在运用X锁和S锁对数据对象加锁时，还需要约定一些规则 ，例如何时申请X锁或S锁、持锁时间、何时释放等。称这些规则为封锁协议。对封锁方式规定不同的规则，就形成了各种不同的封锁协议。一级封锁协议对T要“写”的R加X锁，直到T结束。此时可以解决丢失更新。此时仍然会发生：脏读：事务T2可以绕过X锁读取数据，且读取到的是T1回滚的数据。不可重复读：事务T2的两次读之间可以发生T1的”update“。幻读：事务T2的两次读之间可以发生T1的”insert“。二级封锁协议T发生“写”加X锁，直到T结束；（一级封锁协议）T发生“读”R加S锁，读完即释放。此时可以解决丢失修改和脏读。事务T1先对R进行写（加X锁），则事务T2在读时没法加S锁，直至T1结束。事务T2先对R进行读（加S锁），则事务T1在写时需要等待读结束（T1不一定结束）。此时仍然会发生：不可重复读：事务T1在第一次读之后（释放S锁），事务T2进行了”update”操作，事务T1再读得到的数据和上次不一致。幻读：事务T1在第一次读之后（释放S锁），事务T2进行了”insert”操作，事务T1再读得到的数据和上次不一致。三级封锁协议T发生“写”加X锁，直到T结束。T发生“读”加S锁，直到T结束。此时可以解决任何并发问题，因为无论对数据进行读还是写都要加锁：写：加X锁，之后任何读写都被禁止。读：加S锁，之后任何写操作都被被禁止。三级封锁协议仅允许不同的事务同时发生读操作。事务的隔离级别读未提交READ UNCOMMITTED。对应一级封锁协议。读已提交READ COMMITTED。对应二级封锁协议。可重复读REPEATABLE READ。二级封锁协议加上不允许事务读取在该事务开始后新提交的数据。即防止了不可重复读的发生。可串行化SERIALIZABLE。对应三级封锁协议。MySql特点MySql默认的事务隔离级别是读已提交MySql的事务是自动提交，即即使未事务，MySql也会把每个SQL语句放在一个事务中运行，这个事务是MySql自动添加上去的。]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Servlet]]></title>
    <url>%2F2019%2FServlet%2F</url>
    <content type="text"><![CDATA[Servlet的创建实现Servlet接口继承HttpSerlvet类]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[汤姆猫和超文本传输协议]]></title>
    <url>%2F2019%2F%E6%B1%A4%E5%A7%86%E7%8C%AB%E5%92%8C%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[TomcatTomcat结构bin用来存放Tomcat的可执行文件：startup.bat是windows系统下启动Tomcat的可执行文件；shutdown.bat是windows系统下关闭Tomca的可执行文件。startup.sh是Linux下的启动Tomcat的可执行文件；shutdown.sh是linux下关闭Tomca的可执行文件。conf存放Tomcat服务器全局配置的各种文件。web.xml：给动态Web工程提供相应的配置，比如Session的过期时间，如果在工程的web.xml中覆盖了同种配置，以工程配置优先。server.xml：配置和服务器本身相关的信息，如用什么编码集解析URL，lib存放的是tomcat运行时和项目运行时必须的jar包。如果我们想把某个jar包让所有工程都能使用而不用每个工程都导入，直接将其放入lib文件夹下即可。logs存放的是日志文件webapps存放要发布的Web项目。将Web项目打包成War包，放在此目录下，在Tomcat启动时会将War解压并发布。work用来存放jsp文件文件在运行时产生的java文件和class文件。Dynamic Web项目结构Web项目结构12345678myweb(目录名:项目名) | |---资源文件 html img css js 可以存放到文件夹下 |---WEB-INF(目录:特点,通过浏览器直接访问不到) | | | |---lib(目录:项目运行的jar包) | |---classes(目录:存放的class文件) | |---web.xml(核心配置文件,在web2.5版本中必须有,web3.0版本不是必须的)手动创建一个Web项目并发布http://localhost:8080/test-web/test.htmlhttp://localhost:8080/test-web/WEB-INF/test.htmlHTTP协议请求行请求的方式 请求的资源 协议/版本。请求头key-value类型的数据。Accept：浏览器可接受的mime类型，如：text/html,image/*。Accept-Charset：浏览器解析所用哪个的字符集，如：ISO-8859-1。Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。这个指的是中文、英语这种语言。Host：被访问的主机。If-Modified-Since：在发送HTTP请求时，把浏览器端缓存页面的最后修改时间一起发到服务器去，服务器会把这个时间与服务器上实际文件的最后修改时间进行比较。如果时间一致，那么返回HTTP状态码304（不返回文件内容），客户端接到之后，就直接把本地缓存文件显示到浏览器中。如果时间不一致，就返回HTTP状态码200和新的文件内容，客户端接到之后，会丢弃旧文件，把新文件缓存起来，并显示到浏览器中。Referer：告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。User-Agent：浏览器内核。客户端浏览器的信息， 如。Mozilla/4.0 (compatible; MSIE 5.5; Windows NT 5.0)Cookie：客户端会话技术。请求体post请求的参数。只有表单提交或异步提交时明确指定method=&quot;post&quot;这时候是post请求，其他的都是get请求。格式：参数名称=值&amp;参数名称=值。响应行版本/协议 响应的状态码 状态码说明。常见的状态码：200：响应成功302：重定向304：读缓存404：用户访问的数据不存在500：服务器内部错误响应头Location：跳转方向，仅配合状态码302使用才有作用，如 https://www.baicu.com。Server：服务器型号Content-Encoding：Servlet应该通过查看Accept-Encoding头（即request.getHeader(&quot;Accept-Encoding&quot;)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。Content-Length：数据长度Content-Type: text/html; charset=GB2312 –数据类型Last-Modified：客户可以通过If-Modified-Since请求头提供一个日期，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。Refresh：表示浏览器应该在多少时间之后刷新文档，以秒计。但只刷新一次。除了刷新当前文档之外，还可以通过setHeader(&quot;Refresh&quot;, &quot;5; URL=http://host/path&quot;)让浏览器读取指定的页面。Content-Disposition：指示浏览器不要解析文档，而是以附加形式下载。如attachment; filename=aaa.zip。Set-Cookie：设置cookie。响应体浏览器解析的内容。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么分页存储管理页面大小是2的n次幂]]></title>
    <url>%2F2019%2F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%86%E9%A1%B5%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86%E9%A1%B5%E9%9D%A2%E5%A4%A7%E5%B0%8F%E6%98%AF2%E7%9A%84n%E6%AC%A1%E5%B9%82%2F</url>
    <content type="text"><![CDATA[在分页存储管理方式中，进程中存储的是逻辑地址，通过地址变换机构将逻辑地址转变为物理地址。逻辑地址形式为page: offset。页面大小为什么满足2的n次幂，原因有下：方便计算如果要将（线性）地址转换为page：offset，则需要将地址除以页面大小，并将整数答案作为页面，将余数作为偏移量。 这是使用编程语言中的整数除法和模数运算符完成的。 计算机将地址表示为数字，存储为二进制位。 这是一个示例地址：12是二进制1100。 如果页面大小为3，那么我们需要计算12/3和12%3来查找页面和偏移量（分别为4、0）。 但是，如果页面大小为4（2的幂），则二进制中的4为100，此时使用特殊的“快捷方式”计算整数除法和模数：右移进行除法，按位与进行取模。所以： 12/4 == 12&gt;&gt;2（右移两位） 12%4 == 12&amp;(4-1)（1100和11按位与）。同时页面大小转为2进制可以使用左移，可以减小时间开销。充分利用空间如果页面大小不满足2的n次幂，假如是5，则页内偏移地址，采用2位则每页有一个地址不能使用，采用3位则111、110、101未被使用。怎么做都不能完全利用地址空间。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05-多表DQL]]></title>
    <url>%2F2019%2F05-%E5%A4%9A%E8%A1%A8DQL%2F</url>
    <content type="text"><![CDATA[数据准备12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/*功能：创建 scott 数据库中的 dept 表 */CREATE TABLE dept( deptno INT UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT '部门编号', dname VARCHAR(15) COMMENT '部门名称', loc VARCHAR(50) COMMENT '部门所在位置')ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT='部门表'; /*功能：创建 scott 数据库中的 emp 表 */CREATE TABLE emp( empno INT UNSIGNED AUTO_INCREMENT PRIMARY KEY COMMENT '雇员编号', ename VARCHAR(15) COMMENT '雇员姓名', job VARCHAR(10) COMMENT '雇员职位', mgr INT UNSIGNED COMMENT '雇员对应的领导的编号', hiredate DATE COMMENT '雇员的雇佣日期', sal DECIMAL(7,2) COMMENT '雇员的基本工资', comm DECIMAL(7,2) COMMENT '奖金', deptno INT UNSIGNED COMMENT '所在部门', FOREIGN KEY(deptno) REFERENCES dept(deptno))ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT='雇员表'; /*功能：创建数据库 scott 中的 salgrade 表，工资等级表 */CREATE TABLE salgrade( grade INT UNSIGNED COMMENT '工资等级', losal INT UNSIGNED COMMENT '此等级的最低工资', hisal INT UNSIGNED COMMENT '此等级的最高工资' )ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT='工资等级表'; /*功能：创建数据库 scott 的 bonus 表，工资表 */CREATE TABLE bonus( ename VARCHAR(10) COMMENT '雇员姓名', job VARCHAR(9) COMMENT '雇员职位', sal DECIMAL(7,2) COMMENT '雇员工资', comm DECIMAL(7,2) COMMENT '雇员资金' )ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT='工资表'; /*功能：插入数据库 scott 中表 dept 的初始化数据 */INSERT INTO dept VALUES (10,'ACCOUNTING','NEW YORK');INSERT INTO dept VALUES (20,'RESEARCH','DALLAS');INSERT INTO dept VALUES (30,'SALES','CHICAGO');INSERT INTO dept VALUES (40,'OPERATIONS','BOSTON'); /*功能：插入数据库 scott 中表 emp 的初始数据 */INSERT INTO emp VALUES (7369,'SMITH','CLERK',7902,'1980-12-17',800,NULL,20);INSERT INTO emp VALUES (7499,'ALLEN','SALESMAN',7698,'1981-2-20',1600,300,30);INSERT INTO emp VALUES (7521,'WARD','SALESMAN',7698,'1981-2-22',1250,500,30);INSERT INTO emp VALUES (7566,'JONES','MANAGER',7839,'1981-4-2',2975,NULL,20);INSERT INTO emp VALUES (7654,'MARTIN','SALESMAN',7698,'1981-9-28',1250,1400,30);INSERT INTO emp VALUES (7698,'BLAKE','MANAGER',7839,'1981-5-1',2850,NULL,30);INSERT INTO emp VALUES (7782,'CLARK','MANAGER',7839,'1981-6-9',2450,NULL,10);INSERT INTO emp VALUES (7788,'SCOTT','ANALYST',7566,'87-7-13',3000,NULL,20);INSERT INTO emp VALUES (7839,'KING','PRESIDENT',NULL,'1981-11-7',5000,NULL,10);INSERT INTO emp VALUES (7844,'TURNER','SALESMAN',7698,'1981-9-8',1500,0,30);INSERT INTO emp VALUES (7876,'ADAMS','CLERK',7788,'87-7-13',1100,NULL,20);INSERT INTO emp VALUES (7900,'JAMES','CLERK',7698,'1981-12-3',950,NULL,30);INSERT INTO emp VALUES (7902,'FORD','ANALYST',7566,'1981-12-3',3000,NULL,20);INSERT INTO emp VALUES (7934,'MILLER','CLERK',7782,'1982-1-23',1300,NULL,10); /*功能：插入数据库 scott 中表 salgrade 的初始数据 */INSERT INTO salgrade VALUES (1,700,1200);INSERT INTO salgrade VALUES (2,1201,1400);INSERT INTO salgrade VALUES (3,1401,2000);INSERT INTO salgrade VALUES (4,2001,3000);INSERT INTO salgrade VALUES (5,3001,9999);1234567891011121314151617181920212223242526272829dept( DEPTNO, //部门编号，由两位数字所组成 DNAME, //部门名称，最多由14个字符所组成, LOC //部门所在的位置);emp( EMPNO, //雇员的编号，由四位数字所组成 ENAME, //雇员的姓名，由10位字符所组成 JOB, //雇员的职位 MGR, //雇员对应的经理编号，经理也是雇员 HIREDATE, //雇员的雇佣日期 SAL, //基本工资，其中有两位小数，五倍整数，一共是七位 COMM, //奖金，佣金 DEPTNO //雇员所在的部门编号);salgrade( GRADE, //工资的等级 LOSAL, //此等级的最低工资 HISAL //此等级的最高工资);bonus( ENAME, //雇员姓名 JOB, //雇员职位 SAL, //雇员的工资 COMM //雇员的奖金);自连接自连接就是自己和自己连接，在使用时将一张表看做多张表使用。查询员工编号，员工姓名，经理的编号，经理的姓名KING没有经理，所以查询出来只有13条记录12345678910SELECT e1.empno, e1.ename, e1.mgr, m1.enameFROM emp e1, emp m1WHERE e1.mgr = m1.empno查询员工编号，员工姓名，员工的部门名称，经理的编号，经理的姓名12345678910111213SELECT e1.empno, e1.ename, d1.dname, e1.mgr, m1.enameFROM emp e1, emp m1, dept d1WHERE e1.mgr = m1.empno AND e1.deptno = d1.deptno查询员工编号，员工姓名，员工的部门名称，经理的编号，经理的姓名，经理的部门名称12345678910111213141516SELECT e1.empno, e1.ename, d1.dname, e1.mgr, m1.ename, d2.dnameFROM emp e1, emp m1, dept d1, dept d2WHERE e1.mgr = m1.empno AND e1.deptno = d1.deptno AND m1.deptno = d2.deptno这里有一个难点是为什么需要拓展出两张部门表？这里需要理解刚才说的一句话：在使用时将一张表看做多张表使用，想象一下，如果真实存在一张员工表和一张经理表，员工表.部门=部门.id，经理表.部门=部门.id，不就等于是经理和员工在一个部门才能要求吗？这个题意明显不符。查询员工编号，员工姓名，员工的部门名称，员工的工资等级，经理的编号，经理的姓名，经理的部门名称12345678910111213141516171819SELECT e1.empno, e1.ename, d1.dname, s1.grade, e1.mgr, m1.ename, d2.dnameFROM emp e1, emp m1, dept d1, dept d2, salgrade s1WHERE e1.mgr = m1.empno AND e1.deptno = d1.deptno AND m1.deptno = d2.deptno AND e1.sal BETWEEN s1.losal AND s1.hisal查询员工编号，员工姓名，员工的部门名称，员工的工资等级，经理的编号，经理的姓名，经理的部门名称，员工所属经理的工资等级12345678910111213141516171819202122SELECT e1.empno, e1.ename, d1.dname, s1.grade, e1.mgr, m1.ename, d2.dname, s2.gradeFROM emp e1, emp m1, dept d1, dept d2, salgrade s1, salgrade s2WHERE e1.mgr = m1.empno AND e1.deptno = d1.deptno AND m1.deptno = d2.deptno AND e1.sal BETWEEN s1.losal AND s1.hisal AND m1.sal BETWEEN s2.losal AND s2.hisal查询员工编号，员工姓名，员工的部门名称，员工的工资等级，经理的编号，经理的姓名，经理的部门名称，经理的工资等级（将工资等级 1,2,3,4 显示成 中文的 一级 二级 三级…）1234567891011121314151617181920212223242526272829303132333435363738394041424344SELECT e1.empno, e1.ename, d1.dname, CASE s1.grade WHEN 1 THEN '一级' WHEN 2 THEN '二级' WHEN 3 THEN '三级' WHEN 4 THEN '四级' ELSE '五级' END "等级", e1.mgr, m1.ename, d2.dname, CASE s2.grade WHEN 1 THEN '一级' WHEN 2 THEN '二级' WHEN 3 THEN '三级' WHEN 4 THEN '四级' ELSE '五级' END "等级"FROM emp e1, emp m1, dept d1, dept d2, salgrade s1, salgrade s2WHERE e1.mgr = m1.empno AND e1.deptno = d1.deptno AND m1.deptno = d2.deptno AND e1.sal BETWEEN s1.losal AND s1.hisal AND m1.sal BETWEEN s2.losal AND s2.hisal外连接数据准备：insert into emp(empno,ename) values(9527,&#39;HUAAN&#39;);左外连接以左表为基准，右表能匹配上左表则匹配，右表没有一条记录匹配上左表，左表显示为空。右连接是以右表为基准，左表能匹配上右表则匹配，左表没有一条记录匹配上右表，右表显示为空。查询员工所在的部门12345SELECT *FROM emp e1LEFT OUTER JOIN dept d1 ON e1.deptno = d1.deptno;查询部门的员工12345SELECT *FROM emp e1 RIGHT OUTER JOIN dept d1 ON e1.deptno = d1.deptno;子查询查询最高工资的员工信息123456SELECT *FROM empWHERE sal = (SELECT max(sal) FROM emp);查询出比雇员7654的工资高,同时和7788从事相同工作的员工信息123456789101112131415161718192021SELECT *FROM empWHERE sal &gt; ( SELECT sal FROM emp WHERE empno = 7654 )AND job = ( SELECT job FROM emp WHERE empno = 7788 );查询每个部门最低工资的员工信息和他所在的部门信息12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 查询每个部门的最低工资,分组统计SELECT deptno, min(sal) minsalFROM empGROUP BY deptno; # 员工工资等于他所处部门的最低工资SELECT *FROM emp e1, ( SELECT deptno, min(sal) minsal FROM emp GROUP BY deptno ) t1WHERE e1.deptno = t1.deptno AND e1.sal = t1.minsal;# 查询部门相关信息SELECT *FROM emp e1, ( SELECT deptno, min(sal) minsal FROM emp GROUP BY deptno ) t1, dept d1WHERE e1.deptno = t1.deptno AND e1.sal = t1.minsal AND e1.deptno = d1.deptno;查询领导信息123456SELECT *FROM empWHERE empno IN (SELECT mgr FROM emp);查询不是领导的信息1234567891011121314151617181920212223242526272829# 错误的写法SELECT *FROM empWHERE empno NOT IN (SELECT mgr FROM emp);# &lt;&gt; ALL 等价于 NOT INSELECT *FROM empWHERE empno &lt;&gt; ALL (SELECT mgr FROM emp); # 正确的写法SELECT *FROM empWHERE empno NOT IN ( SELECT mgr FROM emp WHERE mgr IS NOT NULL );查询出比20号部门所有员工薪资高的员工信息 10 20 301234567891011121314151617181920212223242526272829# 写法1SELECT *FROM empWHERE sal &gt; ( SELECT max(sal) FROM emp WHERE deptno = 20 ); # 写法2SELECT *FROM empWHERE sal &gt; ALL ( SELECT sal FROM emp WHERE deptno = 20 );查询有员工的部门的信息12345678910111213SELECT *FROM dept d1WHERE EXISTS ( SELECT * FROM emp e1 WHERE e1.deptno = d1.deptno );补充EXISTS假设有三张表，学生、课程、选课表。查询选修了全部课程的同学。1234567891011121314151617181920212223242526/* 思路： 从上面的例子可以看到EXITSTS其实是对外部表的某个字段做循环。循环变量带入内部表后判断 从内部表能否查出来信息，能查出来表示真（留下），查不出来表示假（去除）。 所以这个题就是对每个学生做循环，把学生带入内部查询，查询学生是否有未选修的课，如果有 学生去除，否则学生留下，所以选用not exists： select * from student where not exists (学生未选修的课) 假设某次循环的学号是 110，此时需要拿course中的每个课号到sc表中做循环，查询在sc表的 学号为110且course.no = sc.cno的情况下，记录是否存在，记录存在course去除，记录不存 在course留下，所以选用not exists： select * from course where not exists select * from sc where 110 = sc.sno and sc.cno = course.no; 这样，可以查出学号为110的同学未选修的课程。 结果： 把两次分析的合并之后： select * from student where not exists( select * from course where not exists( select * from sc where student.no = sc.sno and sc.cno = course.no; ) )*/现在还是这三张表，我们换个题，查询被所有学生选修的课程信息123456789101112131415161718192021/* 思路： 对课程做循环，把课程带入内部查询，如果有学生未选此课，课程去除，否则课程留下， 所以选用not exists：： select * from course where not exists (未被选的课) 假设某次循环，课号为120，此时拿student中的每个学号到sc表做循环，查询在sc表的课号为 120且student.no = sc.sno的情况下，记录是否存在，记录存在student去除，记录不存在 student留下，所以选用not exists：： select * from student where not exists select * from sc where student.no = sc.sno and 120 = sc.no 结果： 两次分析合并 select * from course where not exists( select * from student where not exists( select * from sc where course.no = sc.cno and sc.sno = student.no ) )*/查询没有一个学生选择的课：123456789101112/* 对course做循环，如果存在学生选此课去除，没有学生选此课保留，选用not exists： 对内部循环，记录存在保留，记录不存在去除，选用exists：*/select * from course where not exists( select * from student where exists( select * from sc where course.no = sc.cno and sc.sno = student.no ))]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06-虚拟存储器]]></title>
    <url>%2F2019%2F06-%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%2F</url>
    <content type="text"><![CDATA[传统存储器的问题传统的内存管理方式要求将一个作业全部装入内存才可以运行，由此造成了以下两种情况：大作业对内存的要求超出物理内存总容量，致使其无法运行。内存由于容量的限制，只能装入少量的作业使其运行，而其它大量作业留在外存。解决原理程序局部性原理程序执行时， 除了少部分的转移和过程调用指令外，在大多数情况下仍是顺序执行的。过程调用将会使程序的执行轨迹由一部分区域转至另一部分区域， 但经研究看出，过程调用的深度在大多数情况下都不超过5。程序中存在许多循环结构， 这些虽然只由少数指令构成， 但是它们将多次执行。程序中还包括许多对数据结构的处理， 如对数组进行操作， 它们往往都局限于很小的范围内。表现两个方面时间局限性。如果程序中的某条指令一旦执行， 则不久以后该指令可能再次执行；如果某数据被访问过， 则不久以后该数据可能再次被访问。产生时间局限性的典型原因，是由于在程序中存在着大量的循环。空间局限性。一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，其典型情况便是程序的顺序执行。基于局部性原理在程序装入时，不必将其全部读入到内存，而只需将当前需要执行的部分页或段读入到内存，就可让程序开始执行。在程序执行过程中，如果需执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统，将相应的页或段调入到内存，然后继续执行程序。虚拟存储器定义所谓虚拟存储器， 是指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度，而每位的成本却又接近于外存。可见，虚拟存储技术是一种性能非常优越的存储器管理技术，故被广泛地应用于大、 中、 小型机器和微型机中。实现虚拟存储器的条件由于一个作业被分成多次地调入内存运行，所以在内存分配时必须采用离散分配方式。同时需要解决以下问题：页表（段表）的设计（软件支持）程序不在内存时去外存调度需要中断（硬件支持）逻辑地址转换为物理地址（软件硬件支持）如何给每个进程分配物理块一个页（段）进入内存时，淘汰哪个页（段）请求分页存储管理方式页表机制用于将用户逻辑地址空间变换为内存的物理地址空间。在页表中增加若干项，以便于标志程序或数据的状态。状态位（存在位）P：表示该页是否调入内存。访问字段A：用于记录该页在某段时间内被访问的次数。修改位M：表示该页在调入内存后是否被修改过。未修改过不必写回外存，修改要写回外存。外存地址：该页在外存上的地址，通常是物理块号。缺页中断机构在地址映射过程中，在页表中发现所要访问的页不在内存，则产生缺页中断。操作系统接到此中断信号后，就调出缺页中断处理程序，根据页表中给出的外存地址，将该页调入内存，使进程继续运行下去。如果内存中有空闲块，则分配一页，将新调入页装入内存，并修改页表中相应页表项目的状态位及相应的内存块号。若此时内存中没有空闲块，则要淘汰某页，若该页在内存期间被修改过，则要将其写回外存。缺页中断发生在指令执行期间，而通常情况下，CPU是在一条指令执行完后，才检查是否有中断请求到达；一条指令在执行期间，可能产生多次缺页中断。所以硬件机构应能保存多次中断时的状态，并保证最后能返回到中断前产生缺页中断的指令处，继续执行。地址转换机构内存分配最小物理块数的确定最小物理块数：保证进程正常运行所需的最小物理块数。与计算机的硬件机构有关，取决于指令的格式、功能和寻址方式。内存分配策略在请求分页中，可采取两种分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置换和局部置换（置换范围不同）。于是组合出三种适用的策略：固定分配局部置换：分配固定数目的内存空间，在整个运行期间都不改变。如果缺页，则先从该进程在内存的页面中选中一页，进行换出操作，然后再调入一页。可变分配全局置换：每个进程预先分配一定数目的物理块，同时OS也保持一个空闲物理块队列。当缺页时，首先将对OS所占有的空闲块进行分配，从而增加了各进程的物理块数。当OS的空闲块全部用完，将引起换出操作。可变分配局部置换：系统根据缺页率动态调整各进程占有的物理块数目，使其保持在一个比较低的缺页率状态下。物理块分配算法平均分配算法：将系统中所有可供分配的物理块，平均分配给各个进程。按比例分配算法：按照进程的大小比例分配物理块。考虑优先权的分配算法：为了对于紧迫的作业，能够尽快完成。可以将内存的物理块分成两部分，一部分按照比例分配给各进程，另一部分根据进程优先级，适当增加其相应的份额，分配给各进程。页面调入何时调入页面提前取页：预先装入主存一页或几页（提前页）。请求取页：当用到某页而不在主存时即缺页时取页。从何处调入页面外存有两个部分：文件区和对换区。对换区I/O操作速度比文件区相对快一些，因此一般应当尽量使用对换区来调入页面。对于不同情况，采用不同的策略：系统有足够的对换空间：全部从对换区调入。系统对换空间不足：未修改的从文件区调入，修改的从对换区调入。UNIX的调入方式：未运行过的从文件区调入，运行过的放在对换区，允许页面共享。页面调入过程进程需要的页面不在内存，引起缺页中断中断处理程序保留现场环境，转入缺页中断处理程序中断处理程序查找页表，得到对应的外存物理块号。如果内存有空闲，则启动磁盘操作，将所缺的页面读入，并修改页表。否则，到4。执行置换算法，选出要换出的页面，如果该页修改过，应将其写入磁盘，然后将所缺页调入内存，修改相应表项，将其存在位置为1，并放入快表。利用修改后的页表，形成物理地址，访问内存数据。缺页率假设进程逻辑空间为n页，系统为其分配物理块数为m。如果进程运行过程中，访问页面成功次数为S，访问页面失败次数为F，总页面访问次数A=S+F，则进程运行过程中 缺页率f=F/A。影响缺页率的主要因素：页面大小：页面越大，缺页率越小进程所分配物理块数：物理块越多，缺页率越小页面置换算法：合理的置换算法能更少将页面调入调出程序固有特性：比如做循环操作时，缺页率较低，因为执行的命令都是一系列大致相同的指令。页面置换算法最佳置换算法所选择的被淘汰页面，将是以后永不使用的， 或许是在最长（未来）时间内不再被访问的页面。采用最佳置换算法，通常可保证获得最低的缺页率。这是一种理想情况，是实际执行中无法预知的，因而不能实现。可用作性能评价的依据。例：假定系统为某进程分配了三个物理块， 并考虑有以下的页面号引用串17，0，1，2，0，3，0，4，2，3，0，3，2，1，2，0，1，7，0，1进程运行时， 先将7，0，1三个页面装入内存。 以后， 当进程要访问页面2时， 将会产生缺页中断。此时OS根据最佳置换算法， 将选择页面7予以淘汰。先进先出页面置换算法选择装入最早的页面被置换。可以通过链表来表示各页的建立时间先后。最近最久未使用置换算法选择内存中最久未使用的页面被置换。这是局部性原理的合理近似，性能接近最佳算法。但由于需要记录页面使用时间的先后关系，硬件开销太大。硬件支持寄存器：每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，于是寄存器数值最小的是最久未使用页面。栈：一个特殊的栈，每当进程访问某页面时，便把被访问的页面移到栈顶，于是栈底的是最久未使用页面。最少使用置换算法选择到当前时间为止被访问次数最少的页面被置换。实现方法1：每个页面设立移位寄存器：被访问时左边最高位置1，定期右移并且最高位补0，这样，在最近一段时间内时用最少的页面将是$\sum_{R_i}$最小的页。实现方法2：每页设置访问计数器，每当页面被访问时，该页面的访问计数器加1；发生缺页中断时，淘汰计数值最小的页面，并将所有计数清零。Clock置换算法也称最近未使用算法（NRU, Not Recently Used），它是LRU（最近最久未使用算法）和FIFO的折衷。内存中所有页面通过链接指针形成一个循环队列，每页有一个使用访问位，若该页被访问则置1。置换时采用一个指针，从当前指针位置开始按地址先后检查各页，寻找访问位为0的页面作为被置换页。指针经过的访问位为1的页都修改0，最后指针停留在被置换页的下一个页。改进Clock置换算法由于Clock算法不考虑换出页面时，页面是否修改过的问题。这样在换出的页面如果被修改过的话，则必须做拷回磁盘处理，开销比较大。于是，改进型的Clock算法为每个页又增加了一个修改位。选择页面时，尽量选择既未使用又没有修改的页面。访问位A，修改位M有四种不同情形：1类(A=0，M=0）既未访问，又没有修改，最佳淘汰页2类(A=0，M=1）未访问，但是有修改，效率低的淘汰页3类(A=1，M=0）被访问，但没有修改4类(A=1，M=1）既被访问，又有修改算法：指针从当前位置开始，开始第一轮扫描循环队列，寻找A=0且M=0的页面，找到则可换出。如果找不到，则开始第二轮扫描，寻找A=0且M=1的页面，并且每经过一个页面时，将其访问位A设置为0。如果找到一个第2类页面，则可换出。如果仍旧未找到合适的换出页面，则此时指针回到初始位置，且所有页面其访问位A为0。再转回1继续工作。页面缓冲算法在请求分页系统中，进程在运行的时候经常会发生页面换进换出的情况。而影响换进换出效率的原因如下：页面置换算法：好的页面置换算法能使进程运行中具有较低的缺页率，从而可以减少换进换出的开销。写会磁盘的频率。读入内存的频率。而页面缓存算法就是降低读写磁盘的频率来降低开销。做法如下：空闲页面链表：当有一个未被修改的页要换出时，实际上并不将其换出到外存，而是把它们所在的物理块挂在空闲链表的末尾。如果以后某进程请求此页时，便将其从空闲页面链表上取下。修改页面链表：和空闲页面链表的功能一样，只是说此链表是存放已修改页面的。当链表上挂有足够多的页面时，将它们一齐写入磁盘，这样可以降低读写磁盘的频率。访问内存的有效时间被访问页在主存，且相应页表项在快表：$EAT= \lambda +t$查找快表+访问实际物理地址被访问页在主存，但相应页表项不在快表：$ EAT= \lambda +t + t + \lambda$查找快表+读取页表+读取数据+更新快表被访问页不在主存：$EAT= \lambda + t + \varepsilon + t + \lambda​$查找快表+读取页表+缺页中断处理+读取数据+等新快表内存的有效访问时间为：$EAT= \lambda + t + (1 - a ) \ast [f \ast ( \varepsilon + \lambda + t)+(1-f) \ast(\lambda+t)]$a为命中率，f为缺页率。查找快表+访问内存一次+未命中不需要请求缺页访问快表+未命中时不需要请求缺页访问内存+未命中需要请求缺页访问快表+未命中时需要请求缺页访问内存+未命中时需要请求缺页开销。抖动与工作集抖动由于只装入一个进程的部分程序和数据便可开始运行，故希望运行更多进程，增加多道程序度。但在多道程序环境下，并不是多道程序的度越高，系统吞吐量越大。当CPU的利用率达到某一峰值后，若继续增加多道程度，将产生“抖动”。抖动是指同时运行进程太多，分配给每个进程物理块太少，进程在运行时频繁缺页，必须请求调页，等待页面调进调出的进程增多，磁盘访问时间急剧增加，进程大部分时间用于页面换进换出，处理机利用率急剧下降并趋于0。工作集基于程序运行的局部性原理，程序运行时，对页面的访问并不均匀，一段时间仅局限于较少的页面；另一段时间，有可能局限于另一些较少的页面，如果能预知这些页面，并提前调入，将大大减少缺页率工作集，是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。定义：是指在某段时间间隔内，进程实际要访问的页面的集合。为了降低缺页率，应将程序全部工作集装入主存。方法：用程序过去某段时间的行为作为程序将来某段时间行为的近似。工作集$ \omega (t, \Delta) $是二元函数。某进程在时间t的工作集记为$ \omega (t, \Delta) $，其中，$\Delta$为工作集的窗口尺寸。例窗口大小$\Delta$选择得过小，频繁产生缺页中断。窗口大小$\Delta$选择得很大，失去了虚拟存储器的意义抖动的预防方法采取局部置换策略：仅允许进程在自身范围内进行置换，不影响其他进程在CPU调度程序中引入工作集算法：调入新作业时，应该检查每个进程在内存中的驻留集是否足够大L=S准则：产生缺页的平均时间L=系统处理进程缺页的平均时间S选择暂停的进程：使某些低优先级的进程进程挂起，从而腾出内存空间请求分段存储管理方式请求分页系统建立的虚拟存储器，是以页面为单位进行换入、换出操作的。在请求分段系统中实现的虚拟存储器，以分段为单位进行换入和换出。程序在运行之前，只需要装入必要的若干个分段即可运行。当访问的分段不在内存时，可由OS将所缺少的段调入内存。使用请求分段存储管理方式可以对动态链接有很好的支持。请求段表机制存取方式：标记本段存取属性。如读R，写W，执行X访问字段A：记录本段使用的频繁程度修改位：是否在调入内存后做过修改存在位：本段是否装入内存增补位：该段是否动态增长过缺段中断机构要有专门的缺段中断处理程序。特点：指令和操作数必定不会跨越在段边界上。由于段的长度是不固定的，处理比缺页系统复杂。调入一个段可能要淘汰几个内存中的段。请求中断处理地址中断机构分段的共享与保护共享段表共享进程计数：多少进程在使用此段。存取控制手段：每个共享段，应为不同进程赋予不同的存取权限。断号：同一个共享段在不同进程那有不同的断号。分配第一个请求的进程，由系统分配一物理块，调入共享段，设置相关表项信息，并置count=1； 以后的进程，在自己的段表中增加一项，填入共享段的信息，在共享段表项中做count=count+1，填写进程相关信息。回收做count=count-1；若count=0 ，则该共享段被回收。分段保护越界检查：在进行存储访问时，要将逻辑地址的段号与段表长度进行比较，如果超出则发生越界中断信号；其次，将段内地址与段表中该段的长度进行比较，如果有效才进行转换，否则产生越界中断信号。存取控制检查：用于规定对该段的访问权限。通常的访问方式有：读：允许用户对该段/页内任何信息或其副本进行读操作。写：允许用户修改该段/页内任何信息直至撤消整个段/页。执行：用户可以执行该段/页程序，数据段/页除外。增加：用户可在段/页的末尾添加信息，但不允许修改已存在于段/页中的信息。环保护检查：是一种功能较完善的保护机制。思想：将所有的程序分成不同的级别，分别放置在不同的环上。内环（编号小，在内侧）的程序具有高优先权，外环的程序优先权低。操作系统核心安排在0环内；重要程序和操作系统服务安排在中间环；一般应用程序安排在外环。一个程序可以直接访问在相同环或低优先级环（比自身相对靠外的环）上的数据。一个程序访问高优先级（比自己靠内的环）时，通过系统调用方式实现。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis入门]]></title>
    <url>%2F2019%2Fredis%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[环境安装本人使用的是redis-3.0.0和阿里云centos7服务器。上传redis-3.0.0到服务器。安装gcc环境：yum install gcc-g++解压redis-3.0.0：tar -zxvf ...进入解压后的redis文件夹执行：make安装：make PREFIX=/usr/local/redis install拷贝redis文件夹的redis.conf到/usr/local/redis下修改/usr/local/redis下的redis.conf，搜索以daemonize开头的行，将此行修改为daemonize yes。修改后redis以后台进程运行。开放端口：redis默认端口是6379。/sbin/iptables -I INPUT -p tcp --dport 6379 -j ACCEPT启动服务器：./xxx/redis-server xxx/redis.conf使用客户端连接服务器：./xxx/redis-cli -h ip地址 -p 6379连接测试：ping显示PONG表名成功关闭客户端：quit关闭服务器：./bin/redis-cli shutdown基础使用存储string设置：set key value取值：get key删除：del username数值相加减加一：incr key减一：decr key加x：incrby key x减x：decrby key x字符串拼接存储Map赋值：赋多值：取值：删除字段：删除map：判断字段存在：获取全部entry：获取全部key：获取全部value：存储list头部添加：尾部添加：查看列表：头部弹出：尾部弹出：lpushx key value：仅当key存在时才向头部插入rpush key value：仅当key存在时才向尾部插入删除：irem key count value：count&gt;0时从头部开始删除|count|个值为value的元素；count&lt;0时从尾部开始删除|count|个值为value的元素；count=0时删除全部的值为|value|的元素。设置：lset key index value：设置链表中索引值为index的元素，0是链表头，-1是链表尾。索引值不存在抛异常。lindex key index：通过索引获取列表中的元素linsert key before|after pivot value：在列表的元素前或者后插入元素rpoplpush source destination：移除列表的最后一个元素，并将该元素添加到另一个列表并返回存储setSADD key member1 member2...：向集合添加一个或多个成员SREM key member1 member2...：移除集合中一个或多个成员SISMEMBER key member：判断 member 元素是否是集合 key 的成员1：存在0：key不存在或member不存在sdiff key1 key2：返回集合key1-key2的数据sinter key1 key2 ...：返回集合key1,key2,...的交集sunion key1 key2 ...：返回集合key1,key2,...的并集scard key：返回集合的数量srandmember key：随机返回集合中的一个数据集合运算拓展存储sortedset有序集合和集合一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。有序集合的成员是唯一的,但分数(score)却可以重复。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。ZADD key score1 member1 [score2 member2]：向有序集合添加一个或多个成员，或者更新已存在成员的分数。ZSCORE key member：返回有序集中，成员的分数值。ZREM key member1 member2 ...：移除有序集合中的一个或多个成员ZRANGE key start stop [WITHSCORES]：通过索引区间返回有序集合成指定区间内的成员。withscores表示返回的成员包含分数。ZREVRANGE key start stop [WITHSCORES]：返回有序集中指定区间内的成员，通过索引，分数从高到底。withscores表示返回的成员包含分数。ZREMRANGEBYRANK key start stop：移除有序集合中给定的排名区间的所有成员ZREMRANGEBYSCORE key min max：移除有序集合中给定的分数区间的所有成员keys的通用操作keys pattern：获取所有和pattern匹配的key。del key1, key2, ...：删除指定key。exists key：key是否存在。rename key newkey：为当前的key重命名。expire key：为key设置过期时间，单位：秒。ttl key：获取key所剩的时间，如果没有设置超时，返回-1，key不存在返回-2。type key：以字符串形式返回key的类型。key不存在返回none。Jedisjedis是Java操作redis的一套规范。使用jedis需要有两个包。commons-pool2-2.3.jar和jedis-2.7.0.jar。入门使用12345678910public class Demo1 &#123; public static void main(String[] args) &#123; Jedis jedis = new Jedis("59.110.143.226", 6379); jedis.set("name", "zhangsan"); String string = jedis.get("name"); System.out.println(string); jedis.close(); &#125;&#125;工具类连接1234maxTotal=20maxWaitMillis=7000host=59.110.143.226port=637912345678910111213141516171819202122232425262728public class JedisPoolUtils &#123; private static JedisPoolConfig jc = null; private static int maxTotal = 0; private static long maxWaitMillis = 0; private static String host = null; private static int port=0; private static JedisPool pool=null; static&#123; jc=new JedisPoolConfig(); //获取properties中的配置数据 ResourceBundle re = ResourceBundle.getBundle("jedis"); maxTotal=Integer.parseInt(re.getString("maxTotal")); maxWaitMillis=Long.parseLong(re.getString("maxWaitMillis")); jc.setMaxTotal(maxTotal); jc.setMaxWaitMillis(maxWaitMillis); host = re.getString("host"); port = Integer.parseInt(re.getString("port")); //创建Jedis池 pool=new JedisPool(jc, host, port); &#125; public static Jedis getJedis()&#123; return pool.getResource(); &#125;&#125;123456789public class TestUtils &#123; public static void main(String[] args) &#123; Jedis jedis=JedisPoolUtils.getJedis(); jedis.set("username2", "xiaowang"); String string = jedis.get("username2"); System.out.println(string); jedis.close(); &#125;&#125;多数据库redis的一个实例可以有多个数据库，就像一个mysql可以有多个数据库一样。一个redis实例最多可以提供16个数据库，下标从0到15，默认是0号数据库，连接其他数据库使用select num。移动key到指定数据库消息订阅与发布订阅就是一个客户端在某个频道里发消息，其它订阅到此频道的客户端接收消息。订阅：发布消息：批量订阅：发布消息：redis持久化RDB每隔指定时间自动把内存中数据写入一个文件，下次启动时加载文件，这样内存中就有上次的数据。redis默认的持久化方式。配置在redis.conf的140多行有如下配置是RDB配置。save 900 1：每900秒至少有1个key发生变化，则备份内存快照。save 300 10：每300秒至少有10个key发生变化，则备份内存快照。save 60 10000：每60秒至少有10000个key发生变化，则备份内存快照。位置：AOF把对redis的操作存在一个文件中，下次开机时按照文件的记录再次将数据存在内存中。配置appendonly no改为appendonly yes。appendfsync always：每次有数据修改时，都会写入AOF文件appendfsync everysec：每秒同步一次，写入AOF文件appendfsynv no：从不同步。手动重写aof文件命令：bgrewriteaof。启动多个redis拷贝安装目录下的redis文件夹修改redis.conf文件的端口号启动redis时指定配置文件，保证端口号不同关闭时指定端口号，如：./bin/redis-cli -p 端口号 shutdown]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05-内存管理]]></title>
    <url>%2F2019%2F05-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[存储器的层次我们都知道存储器的容量和速度是限制计算机发展的一大原因，人们对存储器的要求需要既快又大，但是这样带来的结果就是存储器的造价非常昂贵，所以不可能在计算机中全部配置既快又大的存储器。所以现代的计算机系统中都配置了多层结构的存储器系统来平衡速度差异问题。存储器一般被分成六层，不过在只有前四层属于内存，所以此篇只介绍前四层：主存储器用于保存进程运行时的程序和数据。对于微机系统和大中型机，容量为数十MB到数GB；对于嵌入式系统，容量为数十KB到数MB。CPU从主存读取指令和数据。CPU与外设交换信息要依托主存。为缓解CPU执行指令速度和主存访问速度的矛盾，引入寄存器和高速缓冲。寄存器访问速度做快，完全与CPU协调工作，价格十分昂贵，容量不可能很大。长度一般以字为单位。对于微机系统和大中型机，可能有几十个甚至上百个；对于嵌入式系统，仅有几个到几十个。高速缓冲容量大于或远大于寄存器，比内存小两到三个数量级左右，从几十KB到几MB。访问速度快于主存。将主存中经常访问的信息存放在高速缓冲，减少访问主存次数。磁盘缓冲将一部分频繁使用的磁盘数据和信息，暂时存放在磁盘缓冲中，减少访问磁盘次数。不是实际存在的存储介质，利用主存的存储空间，暂存从磁盘读出或写入的信息。总结一下：磁盘缓冲是为了解决内存和外存的速度差异而在内存中开辟的一块用于暂存磁盘数据的存储介质。主存储器是保存进程运行时的程序和数据的。寄存器是和CPU速度匹配的存储器，直接给CPU提供数据。虽然CPU是直接从寄存器去取指令和数据，但是寄存器的数据来源最终还是主存储器，所以为了减少访问CPU的次数，产生了高速缓冲来缓和寄存器和主存储器的矛盾。至于为什么能缓和呢？这是由于程序局部性原理。程序的装入和链接用户程序要在系统中运行，必须将它装入内存，其中有三个过程。编译：由编译程序（Complier）将用户源代码编译成若干个目标模块（Object Module）；链接：由链接程序（Linker）将编译后形成的目标模块以及它们所需要的库函数，链接在一起，形成一个装入模块（Load Module）；装入：由装入程序(Loader)将装入模块装入内存。链接链接程序的功能是将经过编译或汇编后得到的一组目标模块以及它们所需要的库函数，装配成一个完整的装入模块。静态链接方式生成可执行文件时进行链接。主要有两步。修改相对地址。变换外部调用符号。装入时动态链接目标模块是在装入内存时，边装入边链接的。装入时动态链接方式有以下优点：便于修改和更新。便于实现对目标模块的共享。运行时动态链接将对某些模块的链接推迟到执行时才执行，即在执行过程中，当发现一个被调用模块尚未装入内存时，立即由OS去找到该模块并将之装入内存， 把它链接到调用者模块上。凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上，这样不仅可加快程序的装入过程，而且可节省大量的内存空间。装入装入是将一个具有执行资格的模块加载进内存。绝对装入方式在可执行文件中指定内存地址，装入时直接定位在上述（即文件中记录的地址）内存地址。逻辑地址和物理地址完全相同。可重定位装入方式编译程序所生成的目标模块中采用逻辑地址，根据当前内存情况，将装入模块装入到适当位置。地址映射是在装入模块装入内存时一次性进行的，即是静态重定位。动态运行时装入方式静态重定位时程序装入内存后不能移动，而且通常需要占用连续的内存空间。所以与其对应的动态重定位是将地址映射工作推迟到程序真正执行时才进行。现代计算机运行过程预处理把存储在不同文件中的源程序聚合在一起。把被称为宏的缩写语句转换为原始语句。编译：将高级语言翻译成汇编语言或机器语言。链接将多个可重定位的机器代码文件（包括库文件）连接到一起。解决外部内存地址（一个文件中的代码会引用其他文件中的数据对象或过程，这些数据对象或过程的地址对于此文件来说就是外部地址）问题。装入确定程序在内中的绝对地址（即修改程序起始地址），将修改后的指令和数据放到内存中适当的位置。连续分配存储管理方式连续分配是指为一个用户程序分配空间的时候，将所有程序装入到一段连续的物理内存中。在早期（20世纪60-80年代）的操作系统中，这种分配内存的方式曾经被广泛的使用。单一连续分配这是最简单的一种存储管理方式，但只能用于单用户、单任务的操作系统中。内存分为以下两个分区：系统区和用户区。操作系统使用系统区；应用程序装入到用户区，可使用用户区全部空间。固定分区分配固定分区式分配，是最早使用的一种可运行多道程序的存储管理方式。它将内存空间划分为若干个固定大小的区域，每个分区大小可相同，也可不同。OS占一区，其余每个分区中可以装入一道作业。为了便于内存分配，系统需建立一张分区使用表。当有一用户程序要装入时，从表中找出一个能满足要求的、尚未分配的分区分配给该程序，然后修改分区使用表。动态分区分配数据结构空闲分区表每个空闲分区占用一个表项。分区表的表项中包含分区号、分区始址及分区大小等表目。表长不易确定。占用额外内存。空闲分区链表利用各空闲分区自身的单元组成双向链表。操作速度较慢。分区分配分区回收如果回收区的前后有空闲区，可分为图示三种情况。回收时将空闲区和回收区合并。如果回收区的前后无空闲区，新建一个表项，填写信息插入。分区检索算法顺序检索算法首次适应算法：按各空闲分区首址的升序的方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从头查找，找到符合要求的第一个分区。循环首次适应算法：分配空闲空间时，不是从链首（或表头）开始查找，而是从上次找到的空闲分区的下一个空闲分区开始查找。最佳适应算法：按空闲区大小的升序方法组织，分配时，按空闲分区表（或空闲分区链）的先后次序，从头查找，找到符合要求的第一个分区。就说明它是最适合的（即最佳的）。最坏适应算法：按空闲区大小的降序方法组织，分配时总是取空闲分区表（或空闲分区链）中的第一项，若大小不能满足申请者的要求，则表示系统中无满足要求的空闲区，分配失败；否则分配。索引检索算法快速适应算法：将空闲分区根据其容量大小进行分类，对于每一类具有相同容量的所有空闲分区，单独设立一个空闲分区链表，同时在内存中设立一张管理索引表，该表的每一个表项对应一种空闲分区类型，并记录其表头指针。空闲分区的分类是根据进程常用的空间大小进行划分，对于其他大小的分区，可以放在一个特殊的空闲区链表中。伙伴系统：分区大小均为2的K次幂。假设系统可利用空间容量为$2^m$个字，系统运行过程中，不断划分，将空闲分区根据大小分类。为长度为n的进程分配分区时，首先计算$i$值使得$2^{i-1}≦n≦2^i$。先找大小为$2^i$的分区分配，否则找大小为$2^{i+1}$的分区分配，把$2^{i+1}$分区分成两个$2^i$分区（互称伙伴），一个分配，另一个加入$2^i​$的空闲分区链表。分配可能经过多次分割，回收可能进行多次合并。哈希算法：根据空闲分区在可利用空闲区表中的分布规律，建立哈希函数，构造一张以空闲分区大小为关键字的哈希表，该表的每一个表项记录了一个对应的空闲分区链表表头指针。当进行空闲分区分配时，根据所需空闲分区大小，通过哈希函数计算，即得到在哈希表中的位置，从中得到相应的空闲分区链表，实现最近分配策略。紧凑可变式分区也有零头问题。在系统不断地分配和回收中，必定会出现一些不连续的小的空闲区，称为外零头。虽然可能所有零头的总和超过某一个作业的要求，但是由于不连续而无法分配。解决零头的方法是拼接（或称紧凑），即向一个方向（例如向低地址端）移动已分配的作业，使那些零散的小空闲区在另一方向连成一片。分区的拼接技术，一方面是要求能够对作业进行重定位，另一方面系统在拼接时要耗费较多的时间。分页存储管理方式基本概念页面：将一个进程的逻辑地址空间分成若干个大小相等的片，称为页面或页。物理块：把内存空间分成与页面相同大小的若干个存储块，称为（物理）块或页框（frame）。页面碎片：由于进程的最后一页经常装不满一块而形成了不可利用的碎片，称之为“页内碎片”。页面大小：每一页可进行编址的地址数目。页面大小应该满足2的n此幂。逻辑地址：页表：系统为每个进程建一张页表，其在内存的起始地址和长度记录在该进程的PCB中。页表项：页表的每一行。页表项长度：每个页表项占用的编址个数。从逻辑地址那里我们可以看到页号占用了20位，对应的块号也要占用20位，当然块号本身可能不止$2^{20}$个。又由于为了控制对物理块的读写等操作，会在页表项中加上控制字段。如果内存按字节编址，即每个编址可以存储8个二进制位，那么页表项占用的二进制位总数大于内存的字长度。我们需要把一个页表项拆开存放在多个编址后的空间中。地址变换$物理地址=块号+块内地址=F(逻辑地址的页号*页表项长度+页表始址)+业内地址$。每次进行地址变换需要访问两次内存，内存速度较慢，所以影响计算机整体性能。具有快表的地址变换根据程序局部性原理，把最近使用的页表项存放在快表中，下次再进行地址变换时先去快表中查找对应项，如果没找到再去内存中查找，然后把新找到的页表项存放在快表中，如果快表已满，采用某种算法淘汰一份。有效访问时间设t是访问内存的时间，a是快表命中率，λ是查找快表所需的时间。普通地址变换时间：t+t具有快表的地址变换时间：$ a \ast \lambda + (1-a) \ast (t+\lambda)$。两级页表对于两级页表，是将页表再进行分页，页面的大小与内存物理块的大小相同。逻辑地址结构可描述如下：两级页表地址变换可推广至N级页表。反置页表页表是按每个进程的页号排序，指示出物理块号的位置，反置页表是按物理块号排序，指示出每个页隶属的进程和页号。此方法需要为每个进程创建一个外部页表，即将页表建立在外存中。进程进行地址变换时先从反置页表里查找，如果查找不到则去外村中查找，再将查找到的页表项调入内存。分段存储管理方式之前的分区管理都是为了更好的利用内存。为了满足程序员在编程上的要求引入了分段管理方式。方便编程：通常，用户把自己的作业按照逻辑关系划分为若干个段，每个段都是从0开始编址，并有自己的名字和长度。因此，希望要访问的逻辑地址是由段名（段号）和段内偏移量（段内地址）决定的。例如，下述的两条指令便是使用段名和段内地址：其中，前一条指令的含义是将分段A中D单元内的值读入寄存器1；后一条指令的含义是将寄存器1的内容存入B分段的C单元中。12LOAD 1，[A] |〈D〉；STORE 1，[B] |〈C〉；信息共享：在实现对程序和数据的共享时，是以信息的逻辑单位为基础的。比如，共享某个例程和函数。分页系统中的“页”只是存放信息的物理单位（块），并无完整的意义，不便于实现共享；然而段却是信息的逻辑单位。由此可知，为了实现段的共享，希望存储管理能与用户程序分段的组织方式相适应。信息保护：信息保护同样是对信息的逻辑单位进行保护，因此，分段管理方式能更有效和方便地实现信息保护功能。动态增长：在实际应用中，往往有些段，特别是数据段，在使用过程中会不断地增长，而事先又无法确切地知道数据段会增长到多大。前述的其它几种存储管理方式，都难以应付这种动态增长的情况，而分段存储管理方式却能较好地解决这一问题。动态链接：动态链接是指在作业运行之前，并不把几个目标程序段链接起来。要运行时，先将主程序所对应的目标程序装入内存并启动运行，当运行过程中又需要调用某段时，才将该段（目标程序）调入内存并进行链接。可见，动态链接也要求以段作为管理的单位。分段地址段表地址映射地址变换分页和分段的主要区别页是信息的物理单位，段则是信息的逻辑单位；页的的大小固定且由系统决定，而段的长度不固定，由用户所编写的程序决定；分页的地址空间是一维的，而分段的地址空间是二维的。分页是系统管理的需要；分段是为了更好满足用户的需要。段页式存储管理方式分段结构具有逻辑上清晰的优点，但它的一个致命弱点是每个段必须占据主存储器的连续区域，于是，要装入一个分段时可能要移动已在主存储器中的信息，为了克服这个缺点，可兼用分段和分页的方法，构成段页式存储管理。每个作业仍按逻辑分段，但对每一段不是按单一的连续整体存放到存储器中，而是把每个段再分成若干个页面，每一段不必占据连续的主存空间，可把它按页存放在不连续的主存块中。原理逻辑地址空间分段，段内分页，内存分块（页框），存储管理的分配单位是：物理块（页框）地址结构：段号，页号，页内偏移地址。每个作业一张段表，每段一张页表。地址变换：先查段表，再查该段的页表。映射地址变换机构]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04-死锁及处理]]></title>
    <url>%2F2019%2F04-%E6%AD%BB%E9%94%81%E5%8F%8A%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[资源分类可重用资源和消耗性资源可重用性资源：可供用户重复使用多次的资源。特点：互斥访问系统中此资源数目相对固定系统中大多数资源属于此类可消耗性资源：临时性资源由进程动态创建和消耗，数目是可以不断变化的，比如信号量、进程通信的信息等。可抢占性资源和不可抢占性资源可抢占性资源：CPU和主存，不会引起死锁。不可抢占性资源：只能进程自行释放。如打印机，因为如果打印到一半，打印机被抢占，造成的结果只能是此次打印作废，所以它是不可抢占资源。死锁定义如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。死锁的起因竞争不可抢占性资源引起死锁一个资源只能同时被一个进程使用，但是下图P1在获得R1后还去申请R2，同时P2获得R2后还去申请R1，陷入僵局，引发死锁。竞争可消耗性资源引起死锁123P1：receive(p3,m3)； send(p2,m1)；P2：receive(p1,m1)； send(p3,m2)；P3：receive(p2,m2)； send(p1,m3)；如上代码，P1在等待P3给P1发消息，P2在等待P1给它P2发消息，P3在等待P2给P3发消息。造成一个死循环。进程推进顺序非法在下图中，X轴表示进程P1推进图，Y轴表示进程P2推进图。如果按照4号路线推进，可以看出P1在经过b、d段的执行之后，获得R1，P2在进过a、c、e段的执行之后获得R2。此时如果不加以处理，系统一定会进入死锁状态，因为接下来P1在拥有R1后又去申请R2，P2在拥有R2后又去申请R1。死锁产生的必要条件互斥条件：某段时间内，某资源只能由一个进程使用；请求和保持条件：进程因请求资源而阻塞时，对已分配给它的资源保持不放；不可抢占条件 ：资源在未使用完前，不能被剥夺，由使用进程释放；循环等待条件 ：发生死锁时，有向图必构成一环路。死锁处理共有三类做法：第一类是预防死锁，也就是破坏死锁产生的条件（破坏其中一个就可以），这样系统就永远不会产生死锁。第二类是死锁避免，死锁产生的根本原因是系统资源分配出现问题，如果能进行合理的资源分配就能避免死锁的发生。第三类是死锁发生后的检测和解除。预防死锁预防死锁是给系统施加一个条件使其永远不可能满足死锁产生的必要条件，但是互斥条件是不能被破坏的条件，所以预防死锁有三类做法：破坏“请求和保持”条件即进程在请求资源时，它不能持有不可抢占资源。有两种做法：所有进程在开始运行之前，一次性的申请其在整个运行过程中的全部资源，如果申请成功，进程便陷入等待。这样进程在运行的时候就不会再发出请求。进程在只获得运行初期所需的资源后便开始运行，但是进程在运行过程中需要逐步释放以分配给自己的资源，等初期获得所有资源都被释放后才能请求其他资源。破坏“不可抢占”条件当进程保持了某些不可被抢占资源，且提出的新需求又不能被满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这种预防策略的代价非常昂贵，比如进程请求的打印机被强制剥夺后，之前的工作等于作废。破坏“循环等待”条件常见的方法是“资源有序分配”。其基本思想是将系统中的所有资源顺序编号，将紧缺的，稀少的采用较大的编号，在申请资源时必须按照编号升序进行，一个进程只有获得较小编号的进程才能申请较大编号的进程，在拥有大编号资源再申请小编号资源时需要释放和小资源编号相等及以上的编号。避免死锁避免死锁讲道理是属于死锁的预防，但是它和预防死锁不同，预防死锁是破坏死锁产生的条件，避免死锁是防止系统进入不安全状态。所以我们就要明白什么是安全状态，它和死锁产生的必要条件有什么区别。安全状态安全状态指的是系统能按某种进程推进顺序(P1, P2, …, Pn)为每个进程分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺利地完成。此时，序列(P1, P2, …, Pn)为安全序列。如果系统无法找到这样一个序列，则称系统处于不安全状态。为什么能找到这样的序列系统就是安全的呢？其实它是一个递推的关系，假如系统在时刻i发起申请资源请求，其此时状态为a，系统会判断它申请成功后是否还能寻找到一个安全序列，如果能找到便可以分配，否则便是系统不安全状态。假如系统申请到了资源，还想发出申请请求，便会再次判断请求成功之后能否找到安全序列，由此递推下去可保证整个系统能避免死锁。安全状态和死锁必要条件的区别仍以此图为例。假如我们采用的是预防死锁策略中的破坏“请求和保持”条件里的第一个做法，那么推进顺序就不可能为4，因为进程P1在执行的时候需要获取全部资源才能执行。但对于避免死锁来说，系统可以按照4号推进顺序推进到e段和阴影区的交界处，然后进程P2在申请资源R2的时候会去判断分配R2给P2之后系统能否找到安全序列，事实上是找不到的，所以R2便不会分配给P2，这样系统就进入不了阴影区，从而可以避免死锁。所以预防死锁和避免死锁的区别是：预防死锁是每个进程在执行之前确保其自身不陷入死锁状态，如果每个进程都能不陷入死锁状态，系统便能永远安全。即从单个进程角度静态解决问题。但避免死锁是在每一次进行资源分配时判断分配之后是否系统处于安全状态，如果处于安全状态便可分配，否则便不能分配。即从系统整体角度动态解决问题。银行家算法数据结构可利用资源向量$Available$：是个含有m个元素的数组，其中的每一个元素代表一类可利用的资源数目。如果$Available[j]=K$，则表示系统中现有$R_j$类资源K个。最大需求矩阵$Max$：这是一个$n×m$的矩阵，它定义了系统中$n$个进程中的每一个进程对$m$类资源的最大需求。如果$Max[i, j]=K$，则表示进程$i$需要$R_j$类资源的最大数目为K。分配矩阵$Allocation$：这也是一个$n×m$的矩阵，它定义了系统中每一类资源当前已分配给每一进程的资源数。如果$Allocation[i,j]=K$，则表示进程i当前已分得$R_j$类资源的 数目为K。需求矩阵$Need$：这也是一个$n×m$的矩阵，用以表示每一个进程尚需的各类资源数。如果$Need[i,j]=K$，则表示进程$i$还需要$R_j$类资源K个，方能完成其任务。可得：$Need[i,j]=Max[i,j]-Allocation[i,j]​$算法设进程$cusneed$提出请求$REQUEST[i]$，则银行家算法按如下规则进行判断。如果$REQUEST[cusneed] [i]&lt;= Need[cusneed][i]​$，则转2；否则，出错。如果$REQUEST [cusneed] [i]&lt;= Available[i]$，则转3；否则，等待。系统试探分配资源，修改相关数据：$Available[i]-=REQUEST[cusneed][i]$;$Allocation[cusneed][i]+=REQUEST[cusneed][i]$;$Need[cusneed][i]-=REQUEST[cusneed][i]$;系统执行安全性检查算法，如安全，则分配成立；否则试探险性分配作废，系统恢复原状，进程等待。安全性算法设置两个工作向量$Work=Available​$、$Finish=false​$。从进程集合中找到一个满足下述条件的进程$i$，$Finish[i]==false;$$Need[i, j]&lt;=Work[j];$，如找到，执行3；否则，执行4。设进程获得资源，可顺利执行，直至完成，从而释放资源。$Work[i]=Work[i]+Allocation[i,j];​$，$Finish[i]=true;​$，循环2。如所有的进程$Finish= true​$，则表示安全；否则系统不安全。举例假定系统中有五个进程$\lbrace P0, P1, P2, P3, P4\rbrace$和三类资源$\lbrace A,B, C\rbrace$，各种资源的数量分别为10、5、7，在$T0$时刻的资源分配情况如图所示。$T0​$时刻的安全性$P1$请求资源：$P1$发出请求向量$Request1(1,0,2)​$，系统按银行家算法进行检查。$Request_1(1, 0, 2)≤Need_1(1, 2, 2)​$$Request_1(1, 0, 2)≤Available_1(3, 3, 2)$系统先假定可为$P1​$分配资源，并修改$Available,Allocation_1和Need_1​$向量。由此得到的资源变换情况如上上图括号所示。再利用安全性算法检查此时系统是否安全。$P4$请求资源：$P4$发出请求向量$Request_4(3,3,0)$，系统按银行家算法进行检查。$Request_4(3, 3, 0)≤Need_4(4, 3, 1);$。$Request_4(3, 3, 0)&gt;Available(2, 3, 0)​$，让$P4​$等待。$P0$请求资源：$P0$发出请求向量$Requst_0(0,2,0)$，系统按银行家算法进行检查。$Request_0(0, 2, 0)≤Need_0(7, 4, 3);$$Request_0(0, 2, 0)≤Available(2, 3, 0);$系统暂时先假定可为$P0$分配资源，并修改有关数据，如下图所示。进行安全性检查：此时可用资源$Available(2,1,0)$已经不能满足任何进程的需要，进入不安全状态，因此系统不分配资源。死锁的检测和解除死锁的检测在图中找一既非阻塞又非独立的进程节点$P_i$，如顺利，$P_i$可获得所有资源直至运行完毕。消去$P_i$所有的请求边和分配边，即释放占有的所有资源，同理再选下一进程节点$P_{i+1}, …, $若能消去所有的边，那么该图是可完全简化的，否则该图是不可完全简化的。具体做法如下：可利用资源向量$Available[]$，它表示了m类资源中每一类资源的可用数目。把不占用资源的进程（向量$Allocation[i]∶= 0$）记入L表中，即$L_i \bigcup L$。从进程集合中找到一个$Request_i≤Work$的进程，做如下处理：将其资源分配图简化，释放出资源，增加工作向量$Work∶ =Work+Allocation_i$。将它记入L表中。若不能把所有进程都记入L表中， 便表明系统状态S的资源分配图是不可完全简化的。 因此，该系统状态将发生死锁。死锁的解除死锁解除有多种做法，如下是按代价递减排序的几种。撤销所有死锁的进程。将每个进程回退到先前定义的某个检查点，再重新启动所有进程。逐个撤销死锁进程，直至死锁不存在。撤销进程的顺序应是基于某种最小代价原则，每次撤销后，死锁检测算法应该重新检测死锁是否依然存在。剥夺进程P的资源交给进程Q，P同时会退到获得此资源的节点上。对于3和4，选择的标准可以如下：以占用处理器的时间最小；以产生的输出少；所估计的剩余运行时间最长；所占用的资源最少；优先权最低。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时钟中断]]></title>
    <url>%2F2019%2F%E6%97%B6%E9%92%9F%E4%B8%AD%E6%96%AD%2F</url>
    <content type="text"><![CDATA[中断的理解说到中断还不得不从现代操作系统的特性说起，无论是桌面PC操作系统还是嵌入式都是多任务的操作系统，而很遗憾，处理器往往是单个的，即使在硬件成本逐渐下降，但处理器的数量依然不可能做到每个任务一个CPU，所以CPU必须作为一种全局的资源让所有任务共享。即什么时候给任务A用，什么时候给任务B用……这就是进程调度，具体的安排就由调度算法决定了。进程如何去调度？现代操作系统一般都是采用基于时间片的优先级调度算法，把CPU的时间划分为很细粒度的时间片，一个任务每次只能时间这么多的时间，时间到了就必须交出使用权，即换其他的任务使用。这种要看操作系统的定时器机制了。那么时间片到之后，系统做了什么呢？这就要用到我们的中断了，时间片到了由定时器触发一个软中断，然后进入相应的处理历程。当然这一点不足以表明中断的重要，计算机操作系统自然离不开外部设备：鼠标、键盘、网卡、磁盘等等。就拿网卡来讲，我计算机并不知道时候数据包会来到，我能保证的就是数据来了我能正常接收就行了。但是我又不可能一直等着接收数据包，要是这样其他任务就死完了。所以合理的办法是，你数据包来到之后，通知我，然后我再对你处理，怎么通知呢？？答：中断！键盘、鼠标亦是如此！中断的定义指处理机处理程序运行中出现的紧急事件的整个过程.程序运行过程中，系统外部、系统内部或者现行程序本身若出现紧急事件，处理机立即中止现行程序的运行，自动转入相应的处理程序（中断服务程序），待处理完后，再返回原来的程序运行，这整个过程称为程序中断。可分为两类：硬中断（Hardware Interrupt）外部中断：一般是指由计算机外设发出的中断请求，如：键盘中断、打印机中断、定时器中断等。外部中断是可屏蔽的。内部中断是指因硬件出错（如突然掉电、奇偶校验错等）,或运算出错（除数为零、运算溢出、单步中断等）所引起的中断，内部中断是不可屏蔽的。软中断（Software Interrupt）软中断是利用硬中断的概念，用软件方式进行模拟，实现宏观上的异步执行效果。很多情况下，软中断和”信号”有些类似，同时，软中断又是和硬中断相对应的，硬中断是外部设备对CPU的中断，软中断通常是硬中断服务程序（模拟硬件发出中断的程序）对内核的中断，信号则是由内核（或其他进程）对某个进程的中断。时钟中断在Linux的0号中断是一个定时器中断。在固定的时间间隔都发生一次中断，也是说每秒发生该中断的频率都是固定的。该频率是常量HZ，该值一般是在100 ~ 1000之间。该中断的作用是为了定时更新系统日期和时间，使系统时间不断地得到跳转。另外该中断的中断处理函数除了更新系统时间外，还需要更新本地CPU统计数。若进程的时间片递减到0，进程则被调度出去而放弃CPU使用权。Linux的OS时钟的物理产生原因是可编程定时/计数器产生的输出脉冲，这个脉冲送入CPU，就可以引发一个中断请求信号，我们就把它叫做时钟中断。时钟中断是特别重要的一个中断，因为整个操作系统的活动都受到它的激励。系统利用时钟中断维持系统时间、促使环境的切换，以保证所有进程共享CPU；利用时钟中断进行记帐、监督系统工作以及确定未来的调度优先级等工作。可以说，时钟中断是整个操作系统的脉搏。参考：https://www.jb51.net/article/133782.htmhttps://blog.csdn.net/wlf_go/article/details/80237491]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>计算机组成原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c与cpp]]></title>
    <url>%2F2019%2Fc%E4%B8%8Ecpp%2F</url>
    <content type="text"><![CDATA[数据类型绝对值在$10^9$范围以内或者是32位的整数都可以定义成int型。绝对值在$10^{18}$范围以内或者是64位以内的整数可以定义为long long型。如果long long型赋大于$2^{31}-1$的初值，则需要在初值后面加上LL。遇到浮点型数据不要使用float，都应该使用double。小写字母的ASCII值开始于97，大写字母的ASCII值开始于65。小写字母比大写字母大32。\0表示NULL。运算符运算符含义语法效果&lt;&lt;左移a &lt;&lt; x整数a按二进制位左移x位&gt;&gt;右移a &gt;&gt; x整数a按二进制位右移x位&amp;位与a &amp; b整数a和b按二进制对齐，进行按位与运算$\mid$位或$a \mid b$整数a和b按二进制对齐，进行按位或运算^位异或a ^ b整数a和b按二进制对齐，进行按位或运算~位取反~a整数a在二进制下各位取反解释按位与：除了11为1，其他都是0；按位或：除了00为0，其他都是1；按位异或：相同为0，不同为1。无穷大const int INF = (1 &lt;&lt; 30) - 1;const int INF = 0x3fffffff;scanf数据类型格式符举例int%dscanf(&quot;%d&quot;, &amp;n)long long%lldscanf(&quot;%lld&quot;, &amp;ll)float%fscanf(&quot;%f&quot;, &amp;fl)double%lfscanf(&quot;%lf&quot;, &amp;db)char%cscanf(&quot;%d&quot;, &amp;c)字符串（char数组）%sscanf(&quot;%d&quot;, str)scanf双引号之内的字符串其实类似一个匹配模式，我们输入的参数只要能匹配这个模式其实都算对。比如在输入时间时：scanf(&quot;%d:%d:%d&quot;, &amp;hour, &amp;minute, &amp;second)。输入的参数只要是：h​:m:​d的形式就行。除了字符类型（%c），scanf对于其他类型都是默认以空白符（空格、换行等）判断结束标志的。但是在使用字符类型时可以读入空白符。如对于scanf(&quot;%d%c%s&quot;, &amp;a, %c, str)，我们输入1 a bad，得到的结果是a=1, c= , str=a。printf数据类型格式符举例int%dprintf(&quot;%d&quot;, n)long long%lldprintf(&quot;%lld&quot;, ll)float%fprintf(&quot;%f&quot;, fl)double%fprintf(&quot;%f&quot;, db)char%cptintf(&quot;%d&quot;, c)字符串（char数组）%sptintf(&quot;%d&quot;, str)输出%和\：printf(&quot;%%&quot;)，printf(&quot;\\&quot;)%md &amp; %0md &amp; %.md%md：使不足m位的int型变量以m位且右对齐输出，高位以空格补齐，若变量本身超过m位，则保持原样。%0md：使不足m位的int型变量以m位且右对齐输出，高位以0补齐，若变量本身超过m位，则保持原样。%.mf：让浮点数保留m位小数输出。如果题目要求保留xx位小数，使用这个格式便是正确的。这种格式不是四舍五入：它是四舍六入偶成双。getchar &amp; putchargetchar()输入单个字符，putchar(char c)输出单个字符。如char c = getchar();，getchar()可以读入换行符。typedef给复杂的数据类型定义一个别名。如：typedef long long ll。常用math函数double类型取绝对值：fabs(double x)double类型向上取整：floor(double x)double类型向下取整：ceil(double x)求$r_p$：pow(double r, double p)取double类型的算术平方根：sqrt(double x)得到以自然对数为底的对数：log(double x)得到以a为底b的对数：$log_ab$=log(b)/log(a)四舍五入：round (double x)三角函数：sin(double x)，cos(double x)，tan(double x)：参数是弧度制。asin(double x)，acos(double x)，atan(double x)。memsetmemset(数组名, 值, sizeof(数组名));。memset是按字节赋值，也就是说所有的字节都会被赋值为相同的数值，比如对于int a[10]，使用memset(a, 1, sizeof(a);，则四十个字节上的二进制结果都是00000001。由于0的二进制补码全为0，-1的二进制补码全为1，所以memset一般只用于赋值0和-1。字符数组仅在初始化的时候可以直接赋值字符串，如：char str[4] = &quot;PAT&quot;;gets(str)：读入一行字符串，以换行符作为输入结束。puts(str)：输出一行字符串，即输出字符串+换行符。gets()和scanf()在读入字符串时会自动添加结束符（\0）。string.h头文件strlen()：获得字符数组中第一个\0前的字符个数（不包含\0）。strcmp(str1, str2)：比较两个字符串的大小（字典序）：str1 &lt; str2：返回负整数；str1 == str2：返回0；str1 &gt; str2：返回正整数；strcpy(str1, str2)：把str2复制给str1，包含结束符\0。strcat(str1, str2)：把str2粘贴在str1后面（覆盖str1的\0）。sscanf &amp; sprintf用于处理字符串问题：sscanf(原位置，格式符，目的位置)：把原位置里的数据输入到目的位置中。sprintf(目的位置, 格式符, 原位置)：把原位置里的数据输出到目的位置中。12345678int main()&#123; int n; char str[100] = "123"; sscanf(str, "%d", &amp;n); //字符转int时不是强转为ASCII，是字面值相同。 printf("%d\n", n); //123 return 0;&#125;处理复杂的字符串：12345678910int main()&#123; int n; double db; char str1[100] = "2048:3.14,hello"; char str2[100]; sscanf(str1, "%d:%lf,%s", &amp;n, &amp;db, str2); printf("n=%d, db=%.2f, str2=%s\n", n, db, str2); //n=2048, db=3.14, str2=hello return 0;&#125;12345678910int main()&#123; int n = 12; double db = 3.1415926; char str1[100]; char str2[100] = "good"; sprintf(str1, "%d:%.2lf,%s", n, db, str2); printf("str2=%s\n", str1); //str2=12:3.14,good return 0;&#125;指针指针存储的地址的类型称为基类型。基类型必须和指针变量存储的地址类型相同。进行加减法得到的是其基类型偏移的位数。如，两个int型指针相减，等价于两个指针之间差了几个int。指针作为函数的参数，传递的是地址的拷贝123456789101112void testPointer(int *p1, int * p2)&#123; p1 = p1 + 1; cout &lt;&lt; *p1 &lt;&lt; endl; //3&#125;int main()&#123; int a[6] = &#123;1, 2, 3, 4, 5, 6 &#125;; testPointer(&amp;a[1], &amp;a[5]); cout &lt;&lt; a[1] &lt;&lt; endl; // 2 return 0;&#125;指针在创建的时候赋予初值。否则可能出现问题。如int *temp;，temp会被赋予一个随机空间，可能指向系统功能区，此时程序运行就会问题。结构体结构体限制：结构体内部不能定义本类型，但可以定义本类型的指针。结构体的构造函数：1234567891011121314struct studentInfo&#123; int id; char gender; studentInfo()&#123;&#125; studentInfo(char _gender): gender(_gender) &#123;&#125; studentInfo(int _id, char _gender): id(_id), gender(_gender) &#123;&#125;&#125;;int main()&#123; studentInfo stu = studentInfo(10086, 'M'); cout &lt;&lt; stu.id &lt;&lt; " " &lt;&lt; stu.gender &lt;&lt; endl; return 0;&#125;浮点数的比较计算机采用有限位的二进制代码，因此浮点数在计算机中的存储并不总是精确的，具体参考IEEE754规则。所以我们需要定义一个极小数eps（一般定义为$10^{-8}$）对这种误差进行修正。等于运算大于运算小于运算大于等于运算小于等于运算123456789101112const double eps = 1e-8;const double Pi = acos(-1.0);#define Equ(a, b) ((fabs((a) - (b))) &lt; (eps))#define More(a, b) ((a) &gt; (b + (eps)))#define Less(a, b) ((a) &lt; (b - (eps)))#define MoreEqu(a, b) ((a) &gt; (b - (eps)))#define LessEqu(a, b) ((a) &lt; (b + (eps)))单点测试提交的程序被执行多次，每次执行会输入一组数据，得到输出后和此组数据的结果做比较，如果相同则判断此测试点通过，总成绩等于N次执行的成绩之和。PAT采用的是单点测试的方案。多点测试提交的程序被执行一次，会把所有的测试数据都输入，如果其中一组输出出错，则此题错误。所以此时需要程序能有循环读入多组数据的能力。大多数OJ系统采用这种方案，如codeup。下面介绍三种读入方案：while ... EOF应用于没有给定输入的结束条件，默认读到文件末尾。123while(scanf("%d", &amp;n) != EOF)&#123; ...&#125;while ... break应用于题目要求输入的数据满足某个条件时停止输入12345while(scanf("%d", &amp;n) != EOF)&#123; if(n == 0) break; ...&#125;while(T--)当题目给出测试数据组数时采用这种方案。1234int T = 20；while(T--)&#123; ...&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05-Shell]]></title>
    <url>%2F2019%2F05-Shell%2F</url>
    <content type="text"><![CDATA[简介Shell是一个命令解释器，用户输入命令来获得自己想要的结果，但是终端中输入的命令很难进行高级语言的选择、循环等操作。不过Shell程序可以存放在文件上，称为Shell脚本（虽然Linux文件不以后缀名区分文件类型，但是一般编写Shell脚本时文件名会命名为以.sh结尾）。在脚本中可以较方便的进行类似高级语言的操作。最简单的Shell脚本我们都知道，直接在终端输入echo命令是回显参数，把echo命令放在shell脚本中有相同的效果。设置成可执行文件变量Shell脚本中的变量直接使用=便可创建，使用$解析变量名。{}是分组命令，表示H是一个变量，这里不加也可以。特殊变量$#：除脚本名外，命令行上参数的个数。$*：表示在命令行上实际给出的所有实参。如：exam3.sh A B C D E F G H I J K。$#是11。$*是： A B C D E F G H I J K$n：表示命令行上第n个参数$0表示文件名 $1表示第一个参数 …$@：表示在命令行上实际给出的所有实参。如：exam3.sh A B C D E F G H I J K。$@就是： “A” “B” “C” “D” “E” “F” “G” “H” “I” “J” “K”$$：当前进程的进程号$!：上一个后台命令对应的进程号。$?：上一条前台命令执行后的返回值。算术运算执行算术运算需要使用let，如let c=$a+$b。可以使用c=$(($a+$b))代替。其中算术运算符及优先级等同于C语言。同时多了个**表示幂运算。（运算符前后不要有空格）从命令行读入参数直接使用read，命令行中的参数会读到read后面跟的参数（相当于变量）里。读入时输出提示信息：引号双引号：由双引号引起来的字符（除$、`和`\`）都被当做普通字符对待。$表示变量替换； `表示命令替换；\之后的字符只有是$、 、双引号、`或换行符之一时会成为转义字符。其他情况都是\本身。单引号：单引号引起来的字符都是普通字符。特殊字符也失效。倒引号：被到引号引起来的字符被解释为命令。如上上图中所示。数组变量之间使用空格隔开各个元素。如果元素中有空格，使用双引号引起来。测试条件任何命令都可以作为条件，shell会执行这个命令并检查返回值，如果命令成功（返回值为0），表示真。test &lt;条件&gt;：如test n1 -eq n2[ 条件 ]：如[ n1 -eq n2 ]有关文件方面的测试-r 文件名：真 &lt;==&gt; 文件存在并且是用户可读-w 文件名：真 &lt;==&gt; 文件存在并且是用户可写-x 文件名：真 &lt;==&gt; 文件存在并且用户可执行-f 文件名：真 &lt;==&gt; 文件存在且是普通文件-d 文件名：真 &lt;==&gt; 文件存在且是目录文件-s 文件名：真 &lt;==&gt; 文件存在且长度大于0有关字符串方面的测试-z s1：真 &lt;==&gt; 字符串长度为0-n s1：真 &lt;==&gt; 字符串长度大于0s1：真 &lt;==&gt; 字符串不是空字符串s1 = s2（在“=”前后应有空格）：真 &lt;==&gt; 字符串相等s1 != s2：真 &lt;==&gt; 字符串不等s1 &lt; s2：真 &lt;==&gt; 按字典顺序s1在s2之后s1 &gt; s2：真 &lt;==&gt; 按字典顺序s1在s2之前数值方面的测试n1 -eq n2：真 &lt;==&gt; 数值相等n1 -ne n2：真 &lt;==&gt; 数值不等n1 -lt n2：真 &lt;==&gt; n1小于n2n1 -le n2：真 &lt;==&gt; n1小于或等于n2n1 -gt n2：真 &lt;==&gt; n1大于n2n1 -ge n2：真 &lt;==&gt; n1大于或等于n2逻辑运算符!：逻辑非-a：逻辑与-o：逻辑或(表达式)：圆括号括起来表示为一条语句选择结构循环结构break &amp; continue和C语言一致。shift参数跳转命令：不跟数组默认跳转1位，跟了跳转n位。命令行ex.shABCDEF原位置参数$0$1$2$3$4$5$6移位后参数$0$1$2$3$4$5还可以用于循环结构的done上面，表示每次选择指定参数。参数置换变量格式var1为空var1不空var2=${var1:-str}var2=str。var1不变var2=$var1。var1不变var2=${var1:=str}var2=var1=strvar2=$var1。var1不变var2=${var1:+str}var2为空。var1不变var2=str。var1不变var2=${var1:?str}输出：“shell 脚本名:var1:str”并退出shell。var2不变var2=$var1。var1不变ex1编写ex1.sh，参数为一个大于 20 的正整数。先检查参数是否符合要求。如果不符合要求，请给出提示；如果符合要求，输出这个参数的平方。ex2编写ex2.sh，首先显示当天日期，然后查找给定的用户是否在系统中工作（who 命令）。如果在系统中，就输出一条欢迎语句（例如 hello，xxxx！）；如果不在系统中，就输出一条语句（waiting for xxx！）ex3编写 ex3.sh，该脚本接受一个参数。若改参数不是目录，则给出提示信息；否则使用ll命令列出该目录下的内容，并输出有多少个子目录（d开头），多少个普通文件（-开头）。ex4编写 ex4.sh，将第一个参数指定的内容 copy 到第二个参数指定地点。若第一个参数是目录，自动添加-r选项（即把目录下的所有内容都 copy 过去）；若第一个参数是普通文件，则将其 copy 到指定地点；若第一个参数指定的文件或目录不存在，则报错；若第二个参数指定的文件或目录已经存在，则提示是否替换，若选择 yes，则先删除原来的文件或目录，然后再执行 copy 操作，否则放弃。ex5编写 ex5.sh。检查命令行的第一个参数是否是-b或者-s。如果是-b，则计算由第二个参数指定的文件中以 b 开头的行数。如果是-s，则计算由第二个参数指定的文件中以 s 开头的行数。否则显示选择有错的信息。ex6编写 ex6.sh。该脚本需要输入两个文件的名称，然后由用户选择相应的操作（若两个参数中任何一个不是普通文件，则报错）。cat：输出两个文件的内容statistic：统计两个文件分别有多少行merge：将第 1 个文件的内容合并到第 2 个文件后面copy：将第 1 个文件的内容 copy 到第 2 个文件（覆盖原文件）bye：退出1ex编写 1ex.sh，利用 for 循环将当前目录下的.c 文件移动到指定的目录下，完成后显示指定目录下的文件内容，并按文件从小到大排序。(ll -r -S）2ex编写 2ex.sh，显示 Fibonacci 数列的前 10 项及其总和。3ex编写 ex3.sh，判断给定的参数是否是素数。4ex编写 ex4.sh，将给定的参数转换成二进制表示。5exex5.sh假设存在一个/homework的文件夹，其中包含一个 studentlist.csv的文件，当中存放了若干学生的学号，每个一行。例如：150341101、150341102、150341105、150341106，编写 ex11.sh。查看/homework 文件夹下学生是否提交了作业，假设作业名的格式为：学号_homework.txt。最后输出没提交作业的学号名单。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04-进程管理]]></title>
    <url>%2F2019%2F04-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux的进程状态psProcess Status。查看进程状态的最常用的命令，它可以提供关于进程的许多信息。直接用ps命令可以列出每个与你的当前Shell有关的进程的基本信息。ps -ef：显示系统中所有进程的全面信息。-e：显示所有进程-f：全格式用户ID、进程ID、父进程ID、CPU占用率、开始时间、开始此进程的终端设备、此进程运行的总时间、命令名。ps aux显示所有终端上所有用户的有关进程的所有信息。终结进程通常来说，终结一个前台进程可以使用Ctrl+C。终结一个后台进程得使用kill命令。kill &lt;进程号&gt;。如果想强制杀掉一个进程需要使用-9：kill -9 &lt;进程号&gt;sleep使进程暂停由时间值所指定的秒数。此命令大多用于shell程序设计中，使两条命令执行之间停顿指定的时间。如：sleep 100; who | grep &#39;root&#39;。waitwait是用来阻塞当前进程的执行，直至指定的子进程执行结束后，才继续执行。wait [进程号 或 作业号]：eg：wait 23 or wait %1如果wait后面不带任何的进程号或作业号，那么wait会阻塞当前进程的执行，直至当前进程的所有子进程都执行结束后，才继续执行。fork()fork()函数会创建一个和原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事。但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。fork()调用一次，分别向父子进程返回，它可能有三种不同的返回值：在父进程中，fork()返回新创建子进程的进程ID；在子进程中，fork()返回0；如果出现错误，fork()返回一个负值；所以我们可以通过fork返回的值来判断当前进程是子进程还是父进程。同时每个进程都有一个互不相同的进程标识符（process ID），可以通过getpid()函数获得，还有一个记录父进程pid的变量，可以通过getppid()函数获得变量的值。题1源代码运行结果分析程序运行到第7行，创建一个新的进程，克隆一份当前进程。向父进程返回子进程的pid，向子进程返回0。所以执行后父进程进入第3个分支，子进程进入第2个分支。题2源代码结果分析题3源代码结果分析题4题目分析执行第5行之后，向父进程返回真，向子进程返回假，但是没有任何影响，此时创建了一个进程，之后父子进程创建的进程个数相同，所以只分析一个再乘以2即可。第一个子进程分析结果如下图。注意，对于A &amp;&amp; B || C：表达式A为假，B不执行，C执行；表达式A为真，B执行：B为真：C不执行；B为假：C执行。所以答案是1+9*2=19个。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03-vim]]></title>
    <url>%2F2019%2F03-vim%2F</url>
    <content type="text"><![CDATA[vi &amp; vim这俩都是文本编辑器。vi是Linux默认的编辑器，类似于windows的记事本。vim是vi的拓展，比vi更强大。可以用于在Linux中编辑文件内容。笔记中使用vim。它有两种模式，命令模式和编辑模式，在命令模式中可以做一些检索、筛选等操作。在编辑模式中可以对文档进行修改。进入 &amp; 退出进入命令模式方法：vim &lt;文件名&gt;。此时进入命令模式，不能对文件内容进行操作。对文档的检索是在这种模式下进行的。进入编辑模式：i：编辑位置在当前光标位置之前按下i再按_I：在光标所在行的行首插入新增文本按下I再按_a：在该命令之后输入的字符都插到光标之后按下a再按_A：在光标所在行的行尾添加文本按下A再按_o：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行按下o再按_O：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上按下O再按_r：替换光标所在的哪一个字符按下r再按_R：一直替换光标所在的文字，直到按下ESC为止按下R再按三次_再按Esc退出编辑模式在编辑模式下按 Esc 键。退出命令模式需要使用转义字符::q：若未修改文件，此命令可以退出编辑器。:wq：把编辑缓冲区的内容写入文件中，退出编辑器，回到Shell下。:ZZ或:x：仅当作过修改时才将缓冲区内容写到文件上。:q!： 强行退出vi。告诉vi，无条件退出，丢弃缓冲区内容。vim流程图命令模式下的光标跳转方向键和Backspace键的使用和正常情况下相同。移动到上一行，列不变：k移动到上一行行头：-移动到下一行，列不变：j移动到下一行行头：+如果在相应命令的前面加上一个数字n，相应命令执行n次。如2k表示向上移动两行，列不变。移至行首：^或0移至行尾：$移至指定行：行号G。如2G，移动到第二行行首。移至指定列：列号|。如2|，移动到本行第2列。文本删除命令x（小写字母）删除光标所在的字符。命令X（大写字母）删除光标前面的那个字符命令dd删除光标所在的整行命令D从光标位置开始删除到行尾d&lt;光标移动命令&gt;删除从光标位置开始至光标移动命令之间的所有字符。如：d0：从光标位置（不包括光标位）删至行首。d3l：从光标位置（包括光标位）向右删3个字符。d$：从光标位置（包括光标位）删至行尾。与D相同。d5G：将光标所在行至第5行都删除。复原命令u：取消前面刚执行的插入或删除命令的效果，恢复到此前的情况。U：总是把当前行恢复成它被编辑之前的状态。重复命令.：在命令模式下，重复执行前一次插入命令或删除命令补充文本编辑命令方式下d0：删至行首d$：删至行尾ndd：删除当前行及其后的n-1行yy：复制当前行的文本10yy：复制包括当前行及其后面9行文本p：在当前行后面插入一个空行，把缓冲区的内容粘贴过来P：在当前行前面插入一个空行，把缓冲区的内容粘贴过来ex转移方式下:n1,n2 d：将n1行到n2行的内容删除:n1,n2 co n3：将n1行到n2行的内容复制到n3行下:n1,n2 m n3：将n1行到n2行的内容移到n3行下字符串检索向下检索：/模式〈Enter〉。例如：/int向上检索：?模式〈Enter〉。例如：?flout字符串替换:n1,n2s/word1/word2/g：n1和n2为数字。在n1与n2行之间寻找word1这个字符串，并将该字符串替换为word2。例如:100,200s/a/A在100行到200行之间搜索a并替换成A。:1,$s/word1/word2/gc：全局搜索word1，替换成word2。g改成gc表示要用户确认。:%s/$/s2/g：在整个行的末尾添加s2。全局替换命令g：:g/模式/命令表。:g/s1/p：打印文本中有s1的行。p命令表示打印。块选择ctrl+v，然后使用方向键选择块。y：复制反白的地方d：将反白的地方删除掉p：插入复制的内容参考：https://jingyan.baidu.com/article/84b4f565c6b9e560f6da3291.html。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-Linux常用命令]]></title>
    <url>%2F2019%2F02-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[输入终端窗口中的命令以Enter键结束，且Shell命令区分大小写。如果命令太长，一行放不下时，在行尾输入\并按Enter键。这时Shell会返回一个大于号（&gt;）作为提示符，表示该命令行尚未结束，允许继续输入有关信息。echoecho命令把命令行中的参数全部显示到标准输出（终端）中。如果参数用引号引起来，会按原样输出。否则会把各个单词按字符串输出，字符串之间用空格隔开。单引号/双引号的区别请看Shell那一部分。输出重定向Linux的标准输出是屏幕，把结果输出到指定的文件叫做输出重定向。&gt;：目标文件不存在，系统将建立该文件；文件存在，重定向将会删除该文件，并重新建立一个新文件存放结果。&gt;&gt;：目标文件不存在，系统将建立该文件；如果目标文件存在，新的输出结果将会追加到文件末尾。pwd显示出当前所在目录的路径。历史命令history命令可以看到用户所有曾经输入过的命令。!!：执行上一个命令；`!n：执行第n个命令；!-n：执行倒数第n个命令；!xxx：执行以xxx开头的命令，如之前使用过clear，!cle会执行clear。~/.bash_history文件中会存储你近期使用过的命令。查看此文件：cat ~/.bash_historydatedate命令在屏幕上显示或设置系统的日期和时间：date [+格式控制字符串]格式控制字符串常用单引号引起来。年:Y 月:m 日:d 小时:H 分:M 秒:S有且只有超级用户能设置或修改系统时钟，语法如下：date -s “year-month-day hour:minute:second”系统在启动的时候是从CMOS（用来存储计算机某些参数的芯片）中加载时钟，为了保持系统时间与CMOS时间的一致性，Linux每隔一段时间会将系统时间写入CMOS。由于该同步是每隔一段时间进行的，在我们执行date -s后，如果马上重起机器，修改时间就有可能没有被写入CMOS，而hwclock –w强制把系统时间写入CMOS。cal列出日历信息。单独一个cal：列出当前月的日历信息。cal xxxx：列出xxxx年的日历信息。cal yy xxxx：列出xxxx年yy月的日历信息。cal dd yy xxxx：列出xxxx年yy月xx日所在月的日历信息。clearclear命令清除屏幕上的信息，清屏后，提示符移到屏幕左上角。关机 &amp; 重启shutdown -h now：立刻关机shutdown -h 15:30：15:30 关机shutdown -h +30：30 分钟后关机reboot：重启shutdown -k +2 &quot;一会要关机，抓紧保存&quot;：向所有用户输出关机通知，但不做真正操作。+2表示通知的关机时间是现在之后的两分钟。帮助命令如果我们忘记某些命令或其参数如何使用，需要使用帮助命令。whatis &lt;命令&gt;：显示命令的简短描述。&lt;命令&gt; -help：显示使用方法概述和参数列表。man &lt;命令&gt;：为命令提供相关帮助文档，页面分成章节。info &lt;命令&gt;：类似man命令，但是通常比它更详细。切换路径命令cd &lt;位置&gt;：切换到指定位置；cd ~：切换到用户家目录；cd -：切换到上一个所在目录；passwd修改密码。单独的passwd：修改使用该命令的用户的密码。passwd 用户名：root用户可以使用该命令修改其他用户的密码。Linux用户登录Linux系统时，必须通过指定的用户名和密码进行登录。不过所有的用户在Linux眼中都是一个数字，用userid（一个32位的二进制整数）来表示。可以通过id命令，查看自己的userid。userid为0的表示根用户。同时，在系统运行的每个进程、所创建的每个文件都有一个userid，这个userid代表运行这个程序的用户，或者文件的所有者。Linux系统中，用户被保存在/etc/passwd文件中。用户又分成三类：一般用户（userid&gt;=500）、超级用户（userid=0）和系统用户（userid&lt;500）。查看用户Linux是一个多用户系统，即很多个用户同时操作一个设备中的资源，但不同的用户有不同的权限。这些用户中有一个是超级用户（root），它是权限最高的用户。root用户在终端中的输入命令以#开头，其他的用户以$开头。who：列出正在使用系统的所有用户、所用的终端名和注册到系统的时间。who am i：列出使用该命令的用户、所用的终端名和注册到系统的时间。用户组由于不同的用户有不同的权限。为了给不同的用户赋予相同的权限更加方便，诞生了用户组的概念。即同一个用户组里的人员可以有相同的某些权限。Linux中的用户或文件至少属于一个用户组。添加用户useradd或者adduser。执行后的具体操作（不同发行版有区别）：分配一个新的userid，数值等于之前所有userid中数值最大的加一。在/etc/passwd中添加一行。为用户在/home下建立一个新的目录（用户的家目录），目录名和用户名相同。在/etc/group中为用户建立一个新的个人组。在/var/spool/mail中创建用户的邮件文件。删除用户userdel &lt;用户&gt;。删除用户及部分相关信息，家目录和邮件文件还会存在。-r：包括家目录和邮件池等在内的所有用户信息都会被删除。添加/删除组groupadd &lt;组名&gt;。所有的组都保存在/etc/group文件中。groupdel &lt;组名&gt;。删除组。/etc/passwd &amp; /etc/shadow/etc/passwd有7列：用户名、密码、用户id、主要组id、备注信息、主目录、登录shell。各列之间使用:分割。同时密码一般都是x（被加密了），加密后的密码在/etc/shadow中。/etc/shadow有9列：用户名、加密密码、最近更改密码的日期、密码不可更改的天数、密码需要重新更改的天使、密码更改期限前的警告期限、密码过期的宽限时间、帐号失效日期、保留字段。但这里显示的密码是加密的。查看用户所属的组groups：查看使用此命令的用户所属组；groups &lt;用户&gt;：查看指定用户所属组。用户可多选，使用空格隔开。/etc/group &amp; /etc/gshadow/etc/group：组名、组密码、组id、组中附加用户。/etc/gshadow：组名、密码、组管理者、组中附加用户。为用户添加备注在创建的时候添加：useradd -c &lt;备注&gt; 用户名。创建后修改：usermod -c &lt;备注&gt; 用户名。（会清除之前的备注信息）。usermod改变用户某些属性的命令。-l：改变用户的名称；-G：改变用户支持的用户组，会退出原来的附属组，配合-a不会删除之前组；-L：不让该用户登录；-e：设定用户失效日期。日期格式：“YYYY-MM-DD”。-s：改变Shell。新创建的用户默认使用bash，此选项修改登录Shell。如：usermod -aG 组名 用户gpasswdgpasswd -d userName groupName：从组中删除用户切换用户超级用户输入su 用户名可以不用输入密码切换到其他用户。普通用户切换到其他所有用户（su 用户名）需要输入密码。文件系统操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。文件：文件系统中存储数据的一个命名的对象。即使是空文件（不包含用户数据）也会为操作系统提供其他信息。目录：包含文件项目的一类特殊文件。Linux中在应用层上来看目录和文件是被区分开来的。查找文件find &lt;路径&gt; -name &#39;正则表达式&#39;：如find . -name &#39;*.so&#39;，查找当前目录下以.so结尾的文件。catcat &lt;文件&gt;：显示文件的内容。文件可以多选，之间用空格隔开。cat f1 &gt; f2：把f1文件的内容合并到f2文件中。touch文件不存在：则创建一个空的新文件；文件存在：把文件的时间标签更新为系统当前时间。grep命令的意思：global search regular expression and print out the line。部分选项如下：-a：将 binary 文件以 text 文件的方式搜寻数据-c：计算找到 ‘搜寻字符串’ 的次数-i：忽略大小写的不同，所以大小写视为相同-n：顺便输出行号-v：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！--color=auto：可以将找到的关键词部分加上颜色的显示喔！举例如下：管道命令管道命令是用来过滤信息的，比如我们之前grep -n root /etc/passwd之后显示带有root的行，如果想在结果中再按其他条件过滤就要使用管道命令：“|”。统计文件信息wc：统计指定文件的字节数（-c）、字数（-w）、行数（-l）例子：统计文件a中以b开头的行数：cat a | grep ^b | wc -l创建目录mkdir &lt;文件名&gt;。-p：父目录不存在时也可以创建。删除文件/目录rm -rf &lt;文件名&gt;。-r表示递归删除；-f表示强制删除，不询问。列出文件ls命令列出指定目录的内容。-l：文件的详细信息。输出的信息分成多列，它们依次是：文件类型与权限、链接数、文件主、文件组、文件大小、建立或最近修改的时间、文件名。total的计算：https://yq.aliyun.com/ziliao/264744。-a：显示所有文件。之前显示的没有隐藏文件（以.开头）。-h：文件大小以人类可读的方式显示。需要配合-l使用。拷贝文件cp &lt;文件&gt; &lt;目录&gt;。剪切文件mv &lt;文件&gt; &lt;目录&gt;。修改文件名mv &lt;文件&gt; &lt;新文件名&gt;。文件结构Linux中所有的文件都由两部分构成。索引结点：包含此文件的信息，如文件权限、文件主、文件大小等。数据：文件的实际内容，有没有数据都可以。链接链接就是把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。硬链接：硬链接是多一个文件名和inode结点关联。由于它依赖于inode，所以不能在不同的文件系统之间做硬链接。硬链接不能用于目录。用法：ln &lt;被链接的文件&gt; &lt;新的文件名&gt;软连接：软连接是再拓展出一份inode，这个inode指向的区域保存如何找到真正数据的信息。用法：ln -s &lt;被链接的文件&gt; &lt;新的文件名&gt;用户和权限文件主：文件所有者，并赋予唯一的注册名。只有文件主或root才有权利用chown命令改变文件的所有关系（UID）。用户组：通常，组中包含了有相同需求的用户。文件主或超级用户（root）可以利用chgrp命令改变文件的GID。用户存取权限：Linux系统中规定了4种不同类型的用户：文件主、同组用户、其他用户、超级用户。3种访问文件或目录的方式：r（读）、w（写）、 x（可执行或查找）。chmod只有文件主或超级用户root才有权用chmod命令改变文件或目录的存取权限。使用格式：chmod [选项] MODE 文件。MODE可多选，之间用,隔开。MODE：&lt;who&gt;&lt;操作符号&gt;&lt;权限&gt;。who：u——user、g——group、o——others、a——all（可叠加）。操作符号：+ 添加、- 取消、= 赋予；权限：r 读、w 写、x 执行。（可叠加）举例以绝对方式改变权限置为1表示有相应权限，置为0表示没有相应权限。例如：r w x r - x r - -1 1 1 1 0 1 1 0 0转换成十进制是754。chmod 754 aa和chmod u=rwx,g=rx,o=r aa一致。umask官方的解释是掩码，其实就是用户创建文件或目录后它们的默认权限。不过和chomd有区别的是它把有权限设置为0，没权限设置为1，而且umask命令显示的是八进制数字。我的umask显示的是0022，转换成二进制就是000 010 010，转换成权限就是rwx r-x r-x。所以创建的目录的默认权限就是这个。但是Linux不允许新创建的文件有可执行权限，所以创建的文件的默认权限是rw- r-- r--。chown改变某个文件或目录的所有者。chown &lt;用户&gt; &lt;文件&gt;/&lt;目录&gt;chgrp改变文件或目录所属的用户组。chgrp &lt;用户组&gt; &lt;文件&gt;/&lt;目录&gt;文件权限的理解可读（r）：浏览文件中的内容；可写（w）：修改文件中的内容；可执行（x）：将文件作为命令使用。目录权限的理解可读：只能查看到目录下的子目录名和文件名；可执行：可以访问目录中的文件，包括子目录；可写：要在目录下添加删除目录和文件，必须有可执行的权利。压缩 &amp; 打包 &amp; 解压缩tar -zcvf：打包压缩后的文件名 要打包压缩的文件（多个之间用space分开）z：调用gzip压缩命令进行压缩c：create，打包文件v：显示运行过程f：指定文件名tar -xvf xxx.tar.gz -C 位置x：extract，解包v：显示允许过程f：指定文件名别名我们可以使用ll代替ls -l。但是对于ls -a，系统并没有提供la命令，不过我们可以使用alias定义la。取消别名使用unalias 别名定时任务cron工具允许用户配置要定期运行的任务，通过配置crontab的文件可以指定要运行哪些作业以及何时运行。配置crontab文件使用命令crontab。命令由6个用空白分隔的字段组成：字段minutehourday of monthmonthday of weekcommand to run举例4516***date&gt;/tmp/date.txt范围0-590-231-311-120-7*corntab命令的参数：-e：编辑crontab的内容（会打开一个文件）；设置定期任务（16:45时把当前时间写入/tmp/date.txt文件中）：过一段时间之后查看/tmp文件夹：-u：只有root才能执行这个选项，帮助其他用户建立/删除crontab；-l：查看crontab的工作内容:-r：删除crontab的工作内容；成组命令被成组命令约束的命令被认为是一条命令。{ 命令; }：需要有空格和命令隔开，且命令后面需要“;”。不创建子进程。(命令)：不强制需要有空格和命令隔开，不强制需要“;”。创建子进程完成功能。例如下例把两条ls命令的值全部由管道输入给grep。sortsort lines of text files，将文本文件内容加以排序，以行为单位来排序，但不改变文件原始内容。默认排序规则：从第每行一个字符开始，依次按照ASCII码值进行比较。-n：按数字的大小排序，默认情况下把数字看成字符。-r：反转排序效果。uniq文件输出时，删除重复行或列。但如果重复的行不连续则不起作用。文件类型-：普通文件l：符号链接文件d：目录s：套接字文件（socket）b：块设备文件p：命名管道文件（pipe）c：字符设备文件ex1：用户管理在系统中添加三个用户：Blondie、Prince和Madonna他们都希望属于次要组musicBlondie要求在他的条目中添加特殊备注“heart of glass”Prince要求使用/bin/csh作为登录shellMadonna的使用期限为2020-12-1。Blondie决定加入摔跤俱乐部wrestle组。Prince要将他的用户名改为tafkap。Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。groupadd fengshuiusermod -a –G fengshui Madonnausermod –u 888 MadonnaPrince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。usermod –L PrinceBlondie最近表现不好，我们决定将他踢出去。userdel –r Blondie（想把该用户所有信息都一起删除可以使用-r）ex2：文件目录管理Ventura同时属于次要组governor和wrestle。Ventura撰写了自己的摔跤计划plans.txt，并将它放到目录/tmp下。Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？不可以，只有root和文件主能修改文件访问权。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-Linux入门]]></title>
    <url>%2F2019%2F01-Linux%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Linux介绍Linux是一套免费使用和自由传播的操作系统。严格来讲，Linux这个词本身只表示Linux内核，但一般来说使用Linux内核的操作系统都被称为Linux。而不同的厂家使用相同的Linux内核所构建的操作系统叫做Linux发行版。常见的Linux发行版有Ubuntu、Centos、Debian等。这些发行版的使用方法大同小异。但Linux不仅限于使用在PC机上，移动端（安卓系统是由Linux改写而来）、路由器（只保留少许功能的Linux系统）等终端都在使用Linux。Linux安装虚拟机安装：blog.csdn.net/qq_38206090/article/details/82559358双系统：笔者没有安装过，因为怕系统出问题导致文件损失。云服务器：云服务器系统配置Linux版本我认为是最简单的方式，所以以下实例均采用阿里云服务器。连接服务器工具SecureCRT：去 http://59.110.143.226/Sharing-Your-Story/ 搜索。Termius：https://www.microsoft.com/store/productId/9NK1GDVPX09V推荐使用Termius，好看也好用。SecureCRT是破解版，Termius是免费使用。Linux目录结构Linux的目录结构是一个树形结构，树根是一个/。直接子目录包括root、home等。如我的阿里云服务器根目录：ShellShell是指“为使用者提供操作界面”的软件（命令解析器）。Shell翻译过来叫做“壳”，用来区别于“核”，也就是说它把底层的东西封装成命令，使用者键入命令就能得到相应的结果。比如上面的这张图中，我在根目录下输入ll命令，就在终端上给我显示根目录下的文件信息。也就是说Shell解析了我输入的ll命令，返回我想要的信息（根目录文件信息）。Bash命令Shell是命令解释器，自然会有不同的分类，就类比于同是循环结构，Java和Python却有不同的语法。但是Bash（Bourne-Again SHell）是Linux默认的Shell交互类型，也就是说在Linux中打开一个终端，就启动一个Bash进程。Bash命令格式格式：命令名 [选项] [参数1] [参数2] … 有如下特点：命令名必须是小写英文字母。一般格式中，方括号括起来的部分是可选选项。选项是对命令的特别定义，以“-”开始。一个命令可以使用多个选项且多个选项连接起来同样有效（部分发行版不支持）。如：ls -al和ls -a -l效果相同。命令正常执行后返回一个0表示执行成功，返回非0值表示执行过程出错。在终端上很难体现出来，但在shell脚本（后续会介绍）中可作为控制逻辑流程的一部分（用$?查看）。Bash举例查看内核版本号：uname -a:uname是命令名，-a是选项，这个命令没有参数。uname解释]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[opencv实现人脸识别、人脸打框、人脸剪切]]></title>
    <url>%2F2019%2Fopencv%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E3%80%81%E4%BA%BA%E8%84%B8%E6%89%93%E6%A1%86%E3%80%81%E4%BA%BA%E8%84%B8%E5%89%AA%E5%88%87%2F</url>
    <content type="text"><![CDATA[Opencv在各平台上的配置https://opencv-java-tutorials.readthedocs.io/en/latest/01-installing-opencv-for-java.html。测试图片人脸识别代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Arrays;import java.util.List;import org.opencv.core.Core;import org.opencv.core.Mat;import org.opencv.core.MatOfRect;import org.opencv.core.Rect;import org.opencv.imgcodecs.Imgcodecs;import org.opencv.objdetect.CascadeClassifier;public class GetImgFace &#123; private static String classifier = "D:/opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml"; static &#123; // 必须要加载Opencv的Library System.loadLibrary(Core.NATIVE_LIBRARY_NAME); &#125; public static void main(String[] args) &#123; //图片路径不能有中文... GetImgFace.getImgFace("C:\\Users\\ISJINHAO\\Desktop\\test.jpg"); &#125; public static List&lt;Rect&gt; getImgFace(String imgPath)&#123; /* * 加载分类器，选择已经训练好的opencv分类器，训练器路径：%OPENCV_HOME%/sources/data/haarcascades/ * 分类器包含眼睛，人脸，人体，微笑等等，其中对于仅仅识别人脸来说，最好的训练器是： * haarcascade_frontalface_default.xml * haarcascade_frontalface_alt.xml * haarcascade_frontalface_alt2.xml * */ // 分类器路径不要有中文... CascadeClassifier faceDetector = new CascadeClassifier(classifier); if (faceDetector.empty()) &#123; System.out.println("请选择正确的分类器！"); return null; &#125; // 创建Mat，Mat是用来保存图片信息的类。Imgcodecs是用来读取图片的工具类 Mat image = Imgcodecs.imread(imgPath); // 检测人脸，检测结果存在faceDetections中 MatOfRect faceDetections = new MatOfRect(); faceDetector.detectMultiScale(image, faceDetections); List&lt;Rect&gt; faceList = Arrays.asList(faceDetections.toArray()); System.out.println(faceList); return faceList; &#125; &#125;结果人脸打框代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.File;import java.util.Iterator;import java.util.List;import java.util.UUID;import org.opencv.core.Mat;import org.opencv.core.Point;import org.opencv.core.Rect;import org.opencv.core.Scalar;import org.opencv.imgcodecs.Imgcodecs;import org.opencv.imgproc.Imgproc;public class FaceRect &#123; public static void main(String[] args) &#123; String imgPath = "C:\\Users\\ISJINHAO\\Desktop\\test.jpg"; List&lt;Rect&gt; faceRects = GetImgFace.getImgFace(imgPath); //把识别出来的图片分别打框 Iterator&lt;Rect&gt; iterator1 = faceRects.iterator(); while(iterator1.hasNext()) &#123; Rect rect = iterator1.next(); FaceRect.imageMark(imgPath, "D:\\test\\" + UUID.randomUUID() + ".jpg", rect); &#125; //在一张图片中把所有识别出来的人脸都打框 Mat image = Imgcodecs.imread(imgPath); Iterator&lt;Rect&gt; iterator2 = faceRects.iterator(); while(iterator2.hasNext()) &#123; Rect rect = iterator2.next(); Imgproc.rectangle(image, new Point(rect.x, rect.y), // 左上点 new Point(rect.x + rect.width, rect.y + rect.height), // 右下点 new Scalar(0, 255, 0), 2); // 框的颜色和粗细 &#125; Imgcodecs.imwrite("D:\\test\\" + UUID.randomUUID() + ".jpg", image); &#125; public static File imageMark(String imagePath, String outFilePath, Rect rect) &#123; Mat image = Imgcodecs.imread(imagePath); // 原始图片 //Imgproc.rectangle的作用是在修改image中的数据，把相应的位置打上框 Imgproc.rectangle(image, new Point(rect.x, rect.y), // 左上点 new Point(rect.x + rect.width, rect.y + rect.height), // 右下点 new Scalar(0, 255, 0), 2); // 框的颜色和粗细 // 把mat写入图片 Imgcodecs.imwrite(outFilePath, image); return new File(outFilePath); &#125;&#125;结果人脸剪切代码1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.File;import java.util.Iterator;import java.util.List;import java.util.UUID;import org.opencv.core.Mat;import org.opencv.core.Rect;import org.opencv.core.Size;import org.opencv.imgcodecs.Imgcodecs;import org.opencv.imgproc.Imgproc;public class FaceCut &#123; public static void main(String[] args) &#123; String imgPath = "C:\\Users\\ISJINHAO\\Desktop\\test.jpg"; List&lt;Rect&gt; faceRects = GetImgFace.getImgFace(imgPath); //把识别出来的图片分别打框 Iterator&lt;Rect&gt; iterator1 = faceRects.iterator(); while(iterator1.hasNext()) &#123; Rect rect = iterator1.next(); FaceCut.imageCut(imgPath, "D:\\test\\" + UUID.randomUUID() + ".jpg", rect); &#125; &#125; public static File imageCut(String imagePath, String outFilePath, Rect rect) &#123; Mat image = Imgcodecs.imread(imagePath); // 按照原始图片中的人脸提取出来 Mat sub = image.submat(rect); Mat mat = new Mat(); Size size = new Size(rect.width, rect.height); // 修改提取出来的人脸信息sub在坐标轴的位置。 Imgproc.resize(sub, mat, size); // 将截图保存 Imgcodecs.imwrite(outFilePath, mat); return new File(outFilePath); &#125;&#125;结果]]></content>
      <categories>
        <category>大学生创新创业项目</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>人脸识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03-处理机调度]]></title>
    <url>%2F2019%2F03-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[概述处理机调度是指通过对处理机资源进程的合理分配来提升系统资源的利用率、降低作业周转时间等。但是由于不同操作系统的目标不同，所以处理机调度的策略和目标也不相同。处理机调度的层次高级调度：又称作业调度或长程调度。它的主要功能是根据某种算法决定把外存上处于后备队列中的哪些作业调入内存，并为他们创建进程、分配资源等，然后放入就绪进程队列。主要用于批处理系统，分时系统的实时系统中不设置高级调度。低级调度：又称进程调度或断层调度。它的主要功能是根据某种算法决定让哪些就绪队列获得处理机，并由分配程序将处理机分配给被选中的进程。在批处理系统、实时系统和分时系统中都设置低级调度。中级调度：又称内存调度。它的主要功能是根据某种算法决定将哪些暂时不能运行的进程调至外存等待，当它们具备运行条件且内存又有空闲时再调入内存。这实际上是存储器管理中的对换功能，在下一章再展开介绍，处理机调度的目标共同目标：提升资源利用率：$CPU的利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}​$。公平：每个进程都应获得合理的CPU时间，不发生进程饥饿现象。平衡：进程可以分成多个类型，如计算型、I/O型等等。平衡是指系统中不同的设备都能处于忙碌状态。策略强制执行：指某些强制型任务，比如安全策略等，即使会造成其他工作的延迟。批处理系统的目标：平均周转时间短：周转时间：从作业进入系统到作业完成退出系统所用的时间。平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NT_i]​$带权周转时间：作业的周转时间（$T​$）和系统为它提供服务的时间（$T_S​$）。$W=\frac{T}{T_s}​$平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NW_i]​$系统吞吐量高：单位时间内系统完成的作业数尽量多。处理机利用率高。分时系统的目标：响应时间快：指终端提交一个请求到主机返回结果至终端的时间短。均衡：不同请求的复杂度不同，所以响应时间必定不同，均衡是指响应时间应和请求复杂度相适应。实时系统的目标：截止时间的保证：对于HRT任务截止时间必须满足要求，SRT也要尽可能满足。可预测性：如在观看电影时一般都会连续播放帧，所以请求是可预测的，假如采用双缓冲实现第i帧和第i+1帧并行处理就能提高实时性。高级调度作业作业：比程序更为广泛的概念，不仅包含了通常的程序和数据，还有一份作业说明书。在批处理系统中，是以作业为基本单位从外存调入内存的。作业步：在作业运行期间，每个作业都必须经过若干个相对独立。又相互关联的顺序加工步骤才能得到结果。期中每一个加工步骤成为一个作业步。作业控制块Job Control Block，JCB。是作业在系统中存在的标志。保存了系统对作业进行管理和调度所需的全部信息。如：作业标识、用户名称、用户账号、作业类型（CPU繁忙型、I/O繁忙型、批量型、终端型等）、作业状态、调度信息（优先级、作业运行时间）、资源需求（预计运行时间、要求内存大小等）、已申请到资源的使用情况。作业运行的三个阶段收容阶段：每一个作业进入系统时（即输入到硬盘），便由“作业注册”程序为该作业建立一个作业控制块JCB并把它放入作业后备队列中。运行阶段：后备队列中的作业被选中后，系统会为其分配必要的资源和建立进程，然后将其放入就绪队列。一个作业从第一次进入就绪状态开始到它运行结束前都是处于运行阶段。完成阶段：当作业完成或发生异常而终止时，作业便处于完成阶段，此时系统会撤销进程和资源，并将运行结果通过某种方式输入，如输出到文件中。先来先服务算法First-Come First-served，FCFS。每次调度都是选择一个或多个最先进入队列的作业或进程，为它们分配资源，创建进程和分配CPU，使之投入运行。它是最简单的调度算法，同时也可用于进程调度。效率不高，所以一般不作为主调度算法。适用于CPU繁忙型而不适用于I/O繁忙型。因为CPU繁忙型长时间占用CPU很少有I/O操作，一旦获得CPU，就会运行很长时间，就是会长时间占用CPU，而I/O繁忙型由于要频繁访问IO端口，每次访问都要放弃CPU，等I/O访问完后要重新等待下一次调度（此时排到了就绪队列的队尾），所以要等待很久才能重新被调度。因此先来先服务有利于CPU繁忙型而不利于I/O繁忙型。短作业优先算法Short Job First，SJF。指对短作业优先调度的算法，它从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。此种算法对长作业非常不利而且实际使用上很难预估每个作业的运行时间。静态优先级调度算法为照顾紧迫性作业，使之进入系统后获得优先处理，引入优先级调度算法。按照进程的优先级大小来调度，使高优先级进程得到优先处理的策略称为优先权调度算法。静态优先级调度算法是指在输入前作业为其赋予优先级且一直保持不变。虽然可以照顾紧迫性作业，但是没有考虑到作业本身的运行时间和作业的等待时间等，所以产生了更好的动态优先级算法。高响应比算法高响应比算法是动态优先级算法的一种，其中$优先级 = \frac{响应时间}{要求服务时间} = \frac{等待时间+要求服务时间}{要求服务时间}​$。这样可以得到：对于短作业：其要求服务时间短，优先级相对较高。对于长作业：在等待一段时间之后，其优先级会增长，直至够高而能获得服务。对于先来作业：假如在某一时刻其仍未获得服务，和后来的作业相比其优先级相对较高。相应时间与周转时间的对比，假如作业运行完了，两者相等，假如没有则 $响应时间&lt;周转时间$周转时间：从作业进入系统到作业完成退出系统所用的时间。响应时间：等待时间+要求服务时间。低级调度进程调度的任务和机制保存处理机的现场信息：比如程序计数器、通用寄存器里的内容。按某种算法选取进程。把处理机分配给进程：把选中进程的PCB中的有关处理机调度的信息装入处理器的寄存器中，把处理器的控制权交给进程使其能从上次的断点处恢复运行。进程调度机制排队器：每当有进程转入就绪状态时，排队器会将它插入到相应的就绪队列。分派器：分派器依据进程调度程序（更直接的说，进程调度算法）所选定的进程，将其从就绪队列中取出。上下文切换器：会产生两次上下文切换：旧进程和分配程序之间的切换；分配程序和新进程之间的切换。排队器、分派器、上下文切换器本身也是程序，但是它们是处于系统态的程序，而被调度的进程一般是用户态的程序，从系统态到用户态进行上下文切换需要很大的耗费，所以一般采用两组（或多组）寄存器，一组用于处理机在系统态时使用，一组用于系统在用户态时使用，这样在系统态和用户态之间切换时就可以只改变指针（用于从寄存器中存取数据和指令）使其指向指定寄存器就行。进程调度方式非抢占方式一旦某进程获得处理机，就会一直运行下去，直至该进程完成或者因发生某种事件而被阻塞其他进程才能获得处理机。此时引起进程调度的因素：正在执行的进程运行完毕。外部环境的改变使其不能再继续运行，如程序运行发生异常。进程通信或进程同步时执行了某种原语，如Block。正在执行的进程发出I/O请求。抢占方式允许调度程序根据某种原则去暂停某个正在执行的进程，将处理机分配给其他进程。这些原则一般有三种：高优先级原则；短进程优先原则；时间片原则。我们后面所提到的进程调度算法其实都是抢占方式下的策略。轮转调度算法将CPU的处理时间分成固定大小的时间片q， q的大小从几ms到几百ms。系统将所有就绪进程按先来先服务的原则排成队列。每次调度时，把CPU分配给队首进程，令其执行一个时间片，时间片用完后若进程未结束，则送回就需队列尾部重新调度，在一给定的时间内，就绪进程均能获得一时间片的执行时间。此时时间片大小是关键问题，一般来说时间片q正比于响应时间，反比于就绪进程数目。计算机的处理能力。速度快，q可小些。通常q值是这样决定的：批处理系统:80%的CPU周期在一个时间片内完成分时系统：$q=T/N_{max}$，（$T-响应时间上限，N_{max}-最大进程数$）优先级调度算法非抢占式优先级调度算法即一旦某个高优先级的进程占有了处理机，就一直运行下去，直到由于其自身的原因而主动让出处理机时（任务完成或等待事件）才让另一高优先级进程运行。主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。抢占式优先级调度算法任何时刻都严格按照高优先级进程在处理机上运行的原则进行进程的调度。常用于要求比较严格的实时系统中， 以及对性能要求较高的批处理和分时系统中。静态优先权静态优先权是在创建进程时确定的，且在进程的整个运行期间保持不变。一般地，优先权是利用某一范围内的一个整数来表示的，这些整数被称为优先数。确定优先权大小的依据：进程类型；进程对资源的需求；用户要求。动态优先权动态优先权是指，在创建进程时所赋予的优先权，是可以随进程的推进或随其等待时间的增加而改变的，以便获得更好的调度性能。例如，我们可以规定，在就绪队列中的进程，随其等待时间的增长，其优先权以速率a提高。若所有的进程都具有相同的优先权初值，则显然是最先进入就绪队列的进程，将因其动态优先权变得最高而优先获得处理机，此即FCFS算法。若所有的就绪进程具有各不相同的优先权初值，那么，对于优先权初值低的进程，在等待了足够的时间后，其优先权便可能升为最高，从而可以获得处理机。当采用抢占式优先权调度算法时，如果再规定当前进程的优先权以速率b下降，则可防止一个长作业长期地垄断处理机。多队列调度算法之前介绍的调度算法都是用一个算法来解决所有的进程调度，这样无法满足系统中不同用户对进程调度策略的不同要求。而多队列调度算法就是将就绪队列从一个分成多个，将不同性质或类型的进程放在不同的就绪队列，这样不同的队列之间设置优先级，和队列内部也可以设置优先级，能更好的满足用户的需求。同时在多处理机系统中，可以方便的给每个处理机设置单独的就绪队列。多级反馈队列调度算法设置多个就绪队列，每个队列赋予不同的优先级，一个队列的优先级最高，第二个队列次之，其余各队列的优先级逐个降低，各队列内部使用FCFS原则排列。优先级越高的进程时间片越短。当一个进程进入内存后，首先放在第一队列的尾部，按FCFS的原则调度，如果该时间片内未结束，进程调度时将此进程转入第二队列队尾，直至第N个对列，若进程仍未结束，在第N个对列上采用时间片轮转算法。仅当第i队列空闲时才调度第i+1队列，如果有新进程进入优先级较高的队列，剥夺CPU执行新进程，旧进程放入原队列尾部。此算法不必事先知道各进程执行的所需时间，可满足各种进程需要，是目前公认较好的进程调度算法。举例第i个对列的时间片为$2^{i-1}$。基于公平原则的调度算法保证调度算法保证每个进程都获得相同的处理机时间：跟踪计算每个进程自创建以来已经执行的时间。计算每个进程应该获得的处理机时间，即自创建以来的时间除以n。比较各进程获得处理机时间的比率，即实际执行时间除以应获得的处理机时间。比较各进程获得处理机时间的比率，如A：0.5；B：0.9；C：1.2。调度程序应选择比率最小的进程将处理机分配给它，并让该进程一直运行，直到超过最接近它的进程比率，然后把处理机让给此时比率最小的进程。公平调度算法在上个算法中，如果用户A有4个进程，用户B有1各进程，那用户A获得处理机的时间是用户B的四倍。而公平调度算法的目标是保证每个用户都获得相同的处理机时间。实时调度实时调度必须能满足实时任务对截止时间的要求。所以实时任务的算法和优先级算法有些区别。实时算法的分类非抢占式调度算法非抢占式轮转调度算法；非抢占式优先调度算法。抢占式调度算法基于时钟中断的抢占式优先级调度算法：在某实时任务到达后，如果它的优先级高于当前任务的优先级，这时并不立即抢占当前任务的处理机，而是等到时钟中断发生时，调度程序才剥夺当前任务的执行，将处理机分配给新到的高优先级任务。立即抢占式优先级调度算法：一旦出现外部中断，只要当前任务未处于临界区，便立即剥夺当前任务的执行，把处理机分配给请求中断的紧迫任务。最早截止时间优先算法Earliest Deadline First，EDF。可用于非抢占式算法，也可用于抢占式算法。非抢占式抢占式有两个周期任务，A、B的周期分别是20ms，50ms。A、B的执行时间分别是10ms和25ms。最低松弛度优先即算法Least Laxity First，LLF。$松弛度=截止时间-当前时间-任务执行时间$。主要用于抢占式调度。例有两个周期任务，A、B的周期分别是20ms，50ms。A、B的执行时间分别是10ms和25ms。优先级倒置即高优先级进程（或线程）被低优先级（或线程）延迟或阻塞。例，假如有三个完全独立的进程P1、P2和P3，优先级P1&gt;P2&gt;P3。P1和P3通过共享一个临界资源进行交互。123P1：...P(mutex); CS-1; V(mutex);... P2: ...Program2...;P3：...P(mutex); CS-3; V(mutex);...假如P3最先执行，在执行了P(mutex)操作后，进入临界区CS-3。在时刻a，P2就绪，因为它比P3的优先级高，P2抢占了P3的处理机而运行，在时刻b，P1就绪，因为它比P2的优先级高，抢占处理机执行，但P1执行P(mutex)之后被阻塞，处理机被P2获得，P2执行结束后，P1仍不能进入临界区，处理机被P3获得，等P3退出临界区，P1才能获得处理机。所以本应该高优先级的P1优先执行，但是由于存在临界资源而导致优先级倒置。优先级倒置的解决遵循动态优先级继承原则：当高优先级进程P1要进入临界区去使用临界资源，如果已经有一个低优先级进程P3正在使用该资源，此时一方面P1被阻塞，一方面P3继承P1的优先级并一直保持到P3退出临界区。这样做就能保证不会有比P3优先级高但比P1优先级低的进程插进来。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[仅使用Servlet3实现文件上传下载]]></title>
    <url>%2F2019%2F%E4%BB%85%E4%BD%BF%E7%94%A8Servlet3%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[上传文件的html界面123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;单文件上传&lt;/h2&gt; &lt;form action="/servlet3-upload-and-download/uploadone" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file"&gt; &lt;input type="submit" name="upload"&gt; &lt;/form&gt; &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;h2&gt;多文件上传&lt;/h2&gt; &lt;form action="/servlet3-upload-and-download/uploadmany" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file1"&gt; &lt;input type="file" name="file2"&gt; &lt;input type="submit" name="upload"&gt; &lt;/form&gt; &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;h2&gt;文件下载&lt;/h2&gt; &lt;a href="/servlet3-upload-and-download/download"&gt;点击下载&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;下载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package download;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet("/download")public class download extends HttpServlet&#123; private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType("text/html;charset=utf-8"); //filepath String filePath = "D:\\我.jpg"; try( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath)); BufferedOutputStream bos = new BufferedOutputStream(resp.getOutputStream()); ) &#123; long fileLength = new File(filePath).length(); resp.setHeader("Content-disposition", "attachment; filename=" + new String(new File(filePath).getName().getBytes("utf-8"), "ISO8859-1")); resp.setHeader("Content-Length", String.valueOf(fileLength)); byte[] buff = new byte[2048]; int bytesRead; while (-1 != (bytesRead = bis.read(buff, 0, buff.length))) &#123; bos.write(buff, 0, bytesRead); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125; &#125;上传单文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package upload;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.MultipartConfig;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.Part;@WebServlet("/uploadone")@MultipartConfig //Servlet3中处理multipart/form-data类型请求的注解public class UploadOne extends HttpServlet&#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; this.doPost(request, response); &#125; protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; //说明输入的请求信息采用UTF-8编码方式 request.setCharacterEncoding("utf-8"); response.setContentType("text/html; charset=UTF-8"); PrintWriter out = response.getWriter(); //Servlet3.0中新引入的方法，用来处理multipart/form-data类型编码的表单 Part part = request.getPart("file"); //获取HTTP头信息headerInfo=（form-data; name="file" filename="文件名"） String headerInfo = part.getHeader("content-disposition"); System.out.println("headinfo ==&gt; " + headerInfo); //从HTTP头信息中获取文件名fileName=（文件名） String fileName = headerInfo.substring(headerInfo.lastIndexOf("=") + 2, headerInfo.length() - 1); //获得存储上传文件的文件夹路径 String fileSavingFolder = this.getServletContext().getRealPath("/upload"); //获得存储上传文件的完整路径（文件夹路径+文件名） //文件夹位置固定，文件夹采用与上传文件的原始名字相同 String fileSavingPath = fileSavingFolder + File.separator + fileName; System.out.println("filePath ==&gt; " + fileSavingPath); //如果存储上传文件的文件夹不存在，则创建文件夹 File f = new File(fileSavingFolder + File.separator); if(!f.exists())&#123; f.mkdirs(); &#125; //将上传的文件内容写入服务器文件中 part.write(fileSavingPath); //输出上传成功信息 out.println("文件上传成功~！"); &#125;&#125;多文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package upload;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import java.util.Collection;import java.util.Iterator;import javax.servlet.ServletException;import javax.servlet.annotation.MultipartConfig;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.Part;@WebServlet("/uploadmany")@MultipartConfig //Servlet3中处理multipart/form-data类型请求的注解public class UploadMany extends HttpServlet&#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; this.doPost(request, response); &#125; protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; //说明输入的请求信息采用UTF-8编码方式 request.setCharacterEncoding("utf-8"); response.setContentType("text/html; charset=UTF-8"); PrintWriter out = response.getWriter(); //Servlet3.0中新引入的方法，用来处理multipart/form-data类型编码的表单 Collection&lt;Part&gt; parts = request.getParts(); Iterator&lt;Part&gt; iterator = parts.iterator(); //获得存储上传文件的文件夹路径 String fileSavingFolder = this.getServletContext().getRealPath("/upload"); while(iterator.hasNext()) &#123; Part next = iterator.next(); //获得文件大小 long size = next.getSize(); System.out.println(size); //获取HTTP头信息headerInfo=（form-data; name="file" filename="文件名"） String headerInfo = next.getHeader("content-disposition"); System.out.println("headinfo ==&gt; " + headerInfo); //从HTTP头信息中获取文件名fileName=（文件名） String fileName = headerInfo.substring(headerInfo.lastIndexOf("=") + 2, headerInfo.length() - 1); //获得存储上传文件的完整路径（文件夹路径+文件名） //文件夹位置固定，文件夹采用与上传文件的原始名字相同 String fileSavingPath = fileSavingFolder + File.separator + fileName; System.out.println("filePath ==&gt; " + fileSavingPath); //如果存储上传文件的文件夹不存在，则创建文件夹 File f = new File(fileSavingFolder + File.separator); if(!f.exists())&#123; f.mkdirs(); &#125; //将上传的文件内容写入服务器文件中 next.write(fileSavingPath); &#125; //输出上传成功信息 out.println("文件上传成功~！"); &#125;&#125;demo下载：https://github.com/isjinhao/servlet3-upload-and-download。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
        <tag>servlet3</tag>
        <tag>文件上传</tag>
        <tag>文件下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Face++人脸识别系统项目结构]]></title>
    <url>%2F2019%2F%E5%9F%BA%E4%BA%8EFacepp%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[要求AngularJS+Bootstrap3+SSM+Opencv+Face++开发一套人脸签到系统，使用电脑摄像头获取人脸并进行签到。识别方式验证方式：人脸图片+保存人脸至服务器+到场离场时间。到场离场时间：第一次截取到的人脸是到场，最后一次截取到的人脸是离场。人脸图片、保存至服务器：使用Opencv 识别图片中的人脸得到所有的Rect，一个人脸在图片中的位置会储存在一个Rect（x轴、y轴、width、height）对象中。然后循环以下做法：剪切出每个Rect在图片中对应的子图片，调用Face++的接口搜索与子图片最相近的一个人，如果最相近的人置信度 &gt;= 80，认为是同一个人，复制一份原图片，然后把Rect对应的位置画上框，保存在指定文件夹（每个活动有唯一的存储文件夹）下，如果置信度 &lt; 80，处理下一个Rect。上传方式：客户端一秒截一张图上传。实体 &amp; 表结构组织创建活动，学生参与活动。活动分为两种，使用组的和不使用组的。使用组的应用场景是教学班签到，教学班的人数是固定的，不属于教学班的人即使识别成功也不算为签到。不使用组的应用场景是社团活动签到，只要识别成功，就算为签到。组织功能组织注册发布活动查看组信息查看举办的活动信息：查看每场活动用户：录入和导出记录签到用户用户注册###用户查看签到用户查看组管理员]]></content>
      <categories>
        <category>大学生创新创业项目</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Face++</tag>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown数学公式]]></title>
    <url>%2F2019%2Fmarkdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[符号代码符号代码$\sum$\sum$\sum_{i=0}^n$\sum_{i=0}^n$\pm$\pm$\div$\div$\cdot$\cdot$\times$\times$\mid$\mid$\circ$\circ$\ast$\ast$\bigotimes$\bigotimes$\bigoplus$\bigoplus$\leq$\leq$\geq$\geq$\neq$\neq$\approx$\approx$\prod$\prod$\coprod$\coprod$\cdots$\cdots$\int$\int$\iint$\iint$\oint$\oint$\infty$\infty$\nabla$\nabla$\because$\because$\therefore$\therefore$\forall$\forall$\exists$\exists$\not=$\not=$\not&gt;$\not&gt;$\leq$\leq$\geq$\geq$\not\subset$\not\subset$\emptyset$\emptyset$\in$\in$\notin$\notin$\subset$\subset$\subseteq$\subseteq$\bigcup$\bigcup$\bigcap$\bigcap$\bigvee$\bigvee$\bigwedge$\bigwedge$\biguplus$\biguplus$\bigsqcup$\bigsqcup$\hat{y}$\hat{y}$\check{y}$\check{y}$\breve{y}$\breve{y}$\overline{a+b+c+d}$\overline{a+b+c+d}$\underline{a+b+c+d}$\underline{a+b+c+d}$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$\uparrow$\uparrow$\downarrow$\downarrow$\Uparrow$\Uparrow$\Downarrow$\Downarrow$\rightarrow$\rightarrow$\leftarrow$\leftarrow$\Rightarrow$\Rightarrow$\Longleftarrow$\Longleftarrow$\longleftarrow$\longleftarrow$\longrightarrow$\longrightarrow$\Longrightarrow$\Longrightarrow$\alpha$\alpha$\beta$\beta$\gamma$\gamma$\Gamma$\Gamma$\delta$\delta$\Delta$\Delta$\epsilon$\epsilon$\varepsilon$\varepsilon$\zeta$\zeta$\eta$\eta$\theta$\theta$\Theta$\Theta$\vartheta$\vartheta$\iota$\iota$\pi$\pi$\phi$\phi$\Phi$\Phi$\psi$\psi$\Psi$\Psi$\omega$\omega$\Omega$\Omega$\chi$\chi$\rho$\rho$\omicron$\omicron$\sigma$\sigma$\Sigma$\Sigma$\nu$\nu$\xi$\xi$\tau$\tau$\lambda$\lambda$\Lambda$\Lambda$\mu$\mu$\partial$\partial$\lbrace$\lbrace$\rbrace$\rbrace$\overline{a}$\overline{a}$\frac{7x+5}{1+y^2}$\frac{7x+5}{1+y^2}$\int ^2_3 x^2 {\rm d}x$\int ^2_3 x^2 {\rm d}x$\sqrt[n]{3}$\sqrt[n]{3}$\vec{a} \cdot \vec{b}=0$\vec{a} \cdot \vec{b}=0$\iiint$\iiint$\oint$\oint$\lim$\lim$\infty$\infty$\partial$\partial$\ln15$\ln15$\log_2^{10}$\log_2^{10}]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-语言及其文法]]></title>
    <url>%2F2019%2F02-%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字母表字母表（$\sum​$）是一个有穷符号集合，符号包括字母、数字、标点符号、…。例如，二进制字母表：{0,1}、ASCII字符集，Unicode字符集等。字母表上的运算乘积运算：$\sum_{1} \sum_{2} = \lbrace{ab | a \in \sum_{1}, b \in \sum_{2} \rbrace}​$例： $\lbrace0 , 1\rbrace \lbrace a, b \rbrace = \lbrace 0a, 0b, 1a, 1b \rbrace$幂运算字母表的n次幂：长度为n的符号串构成的集合$\sum_{}^0 = \lbrace \varepsilon \rbrace​$$\sum_{}^n = \sum_{}^{n-1}\sum_{} n \geq 1$${\lbrace 0, 1 \rbrace}^3 = \lbrace0, 1\rbrace \lbrace0, 1\rbrace \lbrace0, 1\rbrace = \lbrace000, 001, 010, 011, 100, 101, 110, 111\rbrace$正闭包运算字母表的正闭包：长度正数的符号串构成的集合$\sum_{}^+ = \sum_{}^1 \bigcup \sum_{}^2 \bigcup \sum_{}^3 \bigcup \cdots​$克林闭包运算字母表的克林闭包：任意符号串（长度可以为零）构成的集合$\sum_{}^* = \sum_{}^0 \bigcup \sum_{}^1 \bigcup \sum_{}^2 \bigcup \sum_{}^3 \bigcup \cdots$串设$\sum_{}​$是一个字母表，$\forall x \in \sum_{}^*​$，$x​$称为是$\sum_{}​$上的一个串。串是字母表中符号的一个有穷序列。串$s$的长度，通常记作$|s|$，是指$s$中符号的个数。例：$|aab|$=3。空串是长度为0的串，用 $ \varepsilon$表示$|\varepsilon|= 0$串上的运算连接如果$x$和$y$是串，那么$x$和$y$的连接（concatenation）是把$y$附加到$x$后面而形成的串，记作$xy$。例如，如果$x=dog$且$y=house$，那么$xy=doghouse$空串是连接运算的单位元（identity），即，对于任何串$s$都有，$εs = sε = s$。设$x$, $y$, $z$是三个字符串，如果$x=yz$，则称$y$是$x$的前缀，$z$是$x​$的后缀。幂串s的n次幂：将$n$个$s$连接起来$s^0 = \varepsilon$，$s^n = s^{n-1}s, n \geq 1​$如果 $s = ba$，那么$s^1= ba$，$s^2=baba$，$s^3=bababa$，…文法的定义文法的直观概念当人们表述一门语言时，无非是说明这种语言的句子，如果语言只含有有穷多个句子，则只需要列出句子的有穷集就行。但对于含有无穷多个句子的语言来讲，采用的做法是给出一些规则，符合规则的句子是语言的一个句子。我们以简化版的汉语（句子的结构只有主谓结构）规则来说明：其中用尖括号括起来的部分称为语法成分，未用尖括号括起来的部分称为语言的基本符号。文法的形式化定义定义：$G=(V_{T}, V_{N}, P, S)$，$V_{T}$：终结符集合。文法所定义的语言的基本符号，也称为token。终结是指其不能再被改变。$V_{N}​$：非终结符集合。用来表示语法成分的符号，也称为”语法变量“。非终结指可以由他们推导出句子。$V_{T} \bigcap V_{N} = \phi​$。$V_{T}\bigcup V_{N}$：文法符号集。P：产生式集合：描述了将终结符和非终结符组合成串的方法，产生式的一般形式：$\alpha \rightarrow \beta​$。$α∈(V_T∪V_N)^*​$，且$\alpha​$中至少包含$V_N​$中的一个元素。称为产生式的头（head）或左部（left side）。${\beta \in (V_T \bigcup V_N)}^*​$，称为产生式的体（body）或右部（right side）。S：开始符号。$S\in V_N​$。开始符号（start symbol）表示的是该文法中最大的语法成分。例：$S = &lt;句子&gt;​$举例$G = ( \lbrace id, +, *, (, ) \rbrace, \lbrace E \rbrace, P, E )$ &nbsp; $P =\lbrace E \rightarrow E + E , E \rightarrow E \ast E, E \rightarrow ( E ), E \rightarrow id \rbrace $产生式的简写对一组有相同左部的 $\alpha$ 产生式$\alpha \rightarrow \beta_1,\alpha \rightarrow \beta_2 , … , \alpha \rightarrow \beta_n$。可以简记为：$\alpha \rightarrow \beta_1 | \beta_2 | , … , | \beta_n​$。符号约定终结符：字母表中排在前面的小写字母，如 a、b、c；运算符，如 +、*等；标点符号，如括号、逗号等；数字0、1、. . . 、9；粗体字符串，如id、if等；非终结符：字母表中排在前面的大写字母，如A、B、 C；字母S。通常表示开始符号；小写、斜体的名字，如 expr、stmt等；代表程序构造的大写字母。如E（表达式）、T（项）和F（因子）；文法符号（即终结符或非终结符）：字母表中排在后面的大写字母（如X、Y、Z）终结符号串：字母表中排在后面的小写字母（主要是u、v、. . . 、z）。包括空串。文法符号串：小写希腊字母，如α、β、γ，表示。包括空串。开始符号：除非特别说明，第一个产生式的左部。语言的定义推导 （Derivations）给定文法$G=(V_T , V_N , P , S )$，如果 $\alpha→\beta \in P$，那么可以将符号串$\gamma \alpha \delta$中的$ \alpha$替换为$\beta$，也就是说，将$\gamma \alpha \delta$重写为$\gamma \beta \delta$，记作 $\gamma \alpha \delta \Rightarrow \gamma \beta \delta$γ。此时，称文法中的符号串 $\gamma \alpha \delta$ 直接推导（directly derive）出$\gamma \beta \delta$。简而言之，就是用产生式的右部替换产生式的左部。如果$\alpha_0 \Rightarrow \alpha_1, \alpha_1 \Rightarrow \alpha_2, \cdots, \alpha_{n-1} \Rightarrow \alpha_{n}​$。则称符号串$\alpha_0​$经过$n​$步推导出$\alpha_n​$，可简记为$\alpha_0 \Rightarrow^n \alpha_n​$。$\alpha \Rightarrow^0 \alpha$；$\Rightarrow^+​$表示“经过正数步推导”；$\Rightarrow^*$表示“经过若干（可以是0）步推导。归约（Reductions）规约是推导的逆过程。句型如果$S \Rightarrow^\ast \alpha $，$ \alpha \in (V_T \bigcup V_N)^\ast $，则称$ \alpha $是G的一个句型（sentential form）。一个句型中既可以包含终结符，又可以包含非终结符，也可能是空串。如果$S \Rightarrow^\ast \omega $，$\omega \in V_T\ast$，则称$ \omega $ 是G的一个句子（sentence）。句子是不包含非终结符的句型。语言的形式化定义由文法$G$的开始符号$S$推导出的所有句子构成的集合称为文法$G$生成的语言，记为$L(G )$。即：$L(G)= \lbrace \omega \Rightarrow^\ast \omega \rbrace, \omega \in {V_T}^\ast$。例字母数字串的文法（T）：$T \rightarrow L | D | TL | TD​$$L \rightarrow a | b | c | \cdots | z​$$ D \rightarrow 0 | 1 | 2 | 3 | \cdots | 9​$标识符的文法（S）：和T区别的是S必须以字母或_开头。$ S \rightarrow L | LT​$$T \rightarrow L | D | TL | TD​$$ L \rightarrow a \mid b \mid c \mid \cdots \mid z \mid _ ​$$ D \rightarrow 0 | 1 | 2 | 3 | \cdots | 9​$无符号整数（S）：$S \rightarrow SN ​$$S\rightarrow \varepsilon​$$N \rightarrow 0|1|\cdots|9​$浮点数（T）：$S \rightarrow STN | SN $$S\rightarrow \varepsilon​$$ T \rightarrow .$$N \rightarrow 0|1|\cdots|9​$语言上的运算例：令$L=\lbrace A, B, \cdots Z, a, b, \cdots, z\rbrace$，$D=\lbrace 0, 1, \cdots, 9\rbrace$。则$L(L\bigcap D)^*$表示的语言是标识符。文法的分类Chomsky（形式语言的建立者）把文法分成四类，0型、1型、2型和3型。区别在于在不同文法的产生式上施加的限制不同。0型文法被叫做，无限制文法（Unrestricted Grammar）或 短语结构文法（Phrase Structure Grammar, PSG）。$\forall α \rightarrow \beta \in P​$，$\alpha, \beta \in {(V_N \bigcup V_T)}^\ast​$，且$\alpha​$中至少包含1个非终结符（即$\mid \alpha \mid \geq 1​$）。1型文法被叫做，上下文有关文法（Context-Sensitive Grammar , CSG）。$\forall \alpha \rightarrow \beta \in P，\mid \alpha \mid \leq \mid \beta \mid ​$。产生式的一般形式：$ \alpha_1 A \alpha_2 \rightarrow \alpha_1 \beta \alpha_2$ （$ \alpha_1, \alpha_2, \beta \in (V_N \bigcup V_T)^\ast$且$\beta \ne \varepsilon$）。和0型文法相比，0型文法要求$\mid \alpha \mid \geq 1​$，1型文法要求$1 \leq \mid \alpha \mid \leq \mid \beta \mid ​$。2型文法被叫做，上下文无关文法（Context-Free Grammar, CFG）$\forall \alpha \rightarrow \beta \in P$ （$\alpha \in V_N, \beta \in {(V_N \bigcup V_T)}^\ast$）。产生式的一般形式：$A \rightarrow \beta$。和1型文法相比，当1型文法的$\alpha_1, \alpha_2 \rightarrow \varepsilon$且$ \alpha $只属于非终结符集时，就是2型文法。3型文法被叫做，正则文法（Regular Grammar, RG），分为右线性文法和左线性文法。右线性（Right Linear）文法： $A \rightarrow a B$ 或 $A \rightarrow a $（$a \in {V_T}^ \ast$）左线性（Left Linear）文法： $A \rightarrow B a $ 或 $A \rightarrow a $（$a \in {V_T}^ \ast$）和2型文法相比，3型文法右侧形式必须是非终结符+终结符、终结符+非终结符、终结符三种之一。三种文法的区别参考：https://blog.csdn.net/cjsy_2011/article/details/32412967。1型文法式子左边可以有多个字符，但必须有一个终结符式子右边可以有多个字符，可以是终结符，也可以是非终结符，但必须是有限个字符2型文法式子左边只能有一个字符，而且必须是非终结符式子右边可以有多个字符，可以是终结符，也可以是非终结符，8但必须是有限个字符3型文法式子左边只能有一个字符，而且必须是非终结符式子右边最多有二个字符，而且如果有二个字符必须是一个终结符和一个非终结符，如果只有一个字符，那么必须是终结符左线性文法：式子右边的产生是（非终结符+终结符）的格式右线型文法：式子右边的产生式是（终结符+非终结符）的格式式子右边的格式一定要一致，也就是说如果有一个是（终结符+非终结符）那么所有的式子都必须是（终结符+非终结符）。如果有一个是（非终结符+终结符），那么所有的式子都必须是（非终结符+终结符）右线性文法、左线性文法举例右线性文法S → a | b | c | dS → aT | bT | cT | dTT → a | b | c | d | 0 | 1 | 2 | 3 | 4 | 5T → aT | bT | cT | dT | 0T | 1T | 2T | 3T | 4T | 5T左线性文法R → Ra | Rb | Rc | Rd | R0 | R1 | R2 | R3 | R4 | R5R → a | b | c | d文法S和R都是标识符。CFG 的分析树上下文无关文法有足够的能力描述当今程序设计语言结构，所以以下分析CFG的分析树。根节点的标号为文法开始符号。内部结点表示对一个产生式A→β的应用，该结点的标号是此产生式左部A 。该结点的子结点的标号从左到右构成了产生式的右部β。叶结点的标号既可以是非终结符，也可以是终结符。从左到右排列叶节点得到的符号串称为是这棵树的产出（ yield）或边缘（frontier）。(句型的）短语给定一个句型，其分析树中的每一棵子树的边缘称为该句型的一个短语（phrase）。如果子树只有父子两代结点，那么这棵子树的边缘称为该句型的一个直接短语（immediate phrase）。二义性文法如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的。二义性文法的判定对于任意一个上下文无关文法，不存在一个算法，判定它是无二义性的；但能给出一组充分条件，满足这组充分条件的文法是无二义性的。满足，肯定无二义性不满足，也未必就是有二义性的]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-编译原理绪论]]></title>
    <url>%2F2019%2F01-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[计算机程序设计语言及编译机器语言可以被计算机直接理解，如：C706 0000 0002（16进制）。与人类表达习惯相去甚远、难记忆、难编写、难阅读、易写错。汇编语言引入助记符，如MOV X, 2。依赖于特定机器，非计算机专业人员使用受限制、编写效率依然很低。高级语言类似于数学定义或自然语言的简洁形式，如x = 2。接近人类表达习惯、不依赖于特定机器、编写效率高。编译将高级语言翻译成汇编语言或机器语言的过程。编译器在语言处理系统中的位置预处理器把存储在不同文件中的源程序聚合在一起。把被称为宏的缩写语句转换为原始语句。链接器将多个可重定位的机器代码文件（包括库文件）连接到一起。解决外部内存地址（一个文件中的代码会引用其他文件中的数据对象或过程，这些数据对象或过程的地址对于此文件来说就是外部地址）问题。加载器确定程序在内中的绝对地址（即修改程序起始地址），将修改后的指令和数据放到内存中适当的位置。编译系统的结构词法分析/扫描(Scanning)从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词转换成统一的机内表示，即词法单元（token）形式。token格式：&lt; 种别码, 属性值&gt;一词一码：可以枚举的单词，比如关键字和运算符。使用token的种别码确定。多词一码：不能枚举的单词，比如变量名，使用token的种别码标识出是变量，属性值标识变量名称。一型一码：不能枚举但能被分类的单词，比如数据类型和运算符类别，使用token的种别码标识类型，属性值标识值。举例语法分析语法分析器（parser）从词法分析器输出的token序列中识别出各类短语，并构造语法分析树（parse tree）。语法分析树描述了句子的语法结构。赋值语句分析树变量声明语句的分析树语义分析收集标识符的属性信息：种属：简单变量、复合变量（数组，记录…）、过程、…类型：整型、实型（浮点型）、字符型、布尔型、指针型、…存储位置、长度：变量的值过程的作用域过程的参数和返回值信息符号表字符串表的作用：高级语言中一般不限制标识符长度，故name字段的长度不便预先固定，将标识符的字面值单独放在字符串表中，其位置索引放在name字段中，可保证name长度固定，由此带来存储效率高，查询方便等优点。此外，在语义分析中标识符的值很少被使用，这样就只用读取标识符的id，不用频繁读取标识符本身。语义检查变量或过程未经声明就使用变量或过程名重复声明运算分量类型不匹配，如String类型 + int类型操作符与操作数之间的类型不匹配数组下标不是整数对非数组变量使用数组访问操作符对非过程名使用过程调用操作符过程调用的参数类型或数目不匹配函数返回类型有误中间代码生成常见的中间表示形式语法结构树/语法树 (Syntax Trees)注意不是语法分析树，第八章介绍…三地址码 (Three-address Code)三地址码由类似于汇编语言的指令序列组成，每个指令最多有三个操作数(operand)。常用的三地址指令三地址指令的表示四元式 (Quadruples)：(op, y, z, x)三元式 (Triples)以后再说…间接三元式 (Indirect triples)以后再说…中间代码生成的例子代码优化为改进代码所进行的等价程序变换，使其运行得更快一些、占用空间更少一些，或者二者兼顾。目标代码生成目标代码生成以源程序的中间表示形式作为输入，并把它映射到目标语言目标代码生成的一个重要任务是为程序中使用的变量合理分配。]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-Spring入门]]></title>
    <url>%2F2019%2F01-Spring%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Spring - 概述（00）Spring概述Spring是一个一站式框架。它为Java EE开发的三层架构中每一层都提供了解决方案Web层：Spring MVC；Service层：Spring的Bean管理，Spring声明式事务；DAO层：Spring的JDBC模板，Spring的ORM模块。（后期会用Mybatis替换Spring的DAO层）Spring下载Spring现在是在github上托管的开源项目：地址。Spring各版本下载：地址。Spring环境搭建我的Spring文集中使用的是Spring 4.2版本，下方这张图是Spring官方给的架构图，想运行Spring项目，必须得导入Core Container中的包，但是也需要日志包。## Spring初体验123public interface UserDao &#123; public void save();&#125;12345public class UserDaoImpl implements UserDao&#123; public void save() &#123; System.out.println("UserService执行了..."); &#125;&#125;123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:p="http://www.springframework.org/schema/p" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- Spring的入门的配置==================== --&gt; &lt;bean name="userDao" class="com.isjinhao.Demo1.UserDaoImpl" &gt;&lt;/bean&gt; &lt;/beans&gt;12345678910111213141516171819import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; //传统方法的获得UserDao对象 @org.junit.Test public void test1() &#123; UserDao dao = new UserDaoImpl(); dao.save(); &#125; //通过Spring获得UserDao对象 @org.junit.Test public void test2() &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao bean = (UserDao)applicationContext.getBean("userDao"); bean.save(); &#125;&#125;开发的一个规则是在后期维护的时候少修改源代码。如果没有Spring我们更换UserDao的实现类，比如更换为UserMybatisDaoImpl，我们在源代码中就要改为UserDao dao = new UserMybatisDaoImpl();。但有了Spring之后就只需要修改配置文件中的class为xxx.UserMybatisDaoImpl，被Spring管理的类叫做bean。## DI（Dependency Injection）### 依赖关系1234567Class A&#123; &#125;Class B&#123; A a; public void xxx()&#123; &#125;&#125;如果在类B中使用到了类A，就说类B依赖类A，上图就是其中一种情况。### Spring解决依赖123public interface UserDao &#123; public void save();&#125;123456789101112public class UserDaoImpl implements UserDao&#123; private String name; public void save() &#123; System.out.println("UserService执行了..." + name); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:p="http://www.springframework.org/schema/p" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- Spring的入门的配置==================== --&gt; &lt;bean name="userDao" class="com.isjinhao.Demo1.UserDaoImpl"&gt; &lt;property name="name" value="isjinhao" /&gt; //name的值和属性名称相同 &lt;/bean&gt; &lt;/beans&gt;1234567891011import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; //通过Spring获得UserDao对象 @org.junit.Test public void test2() &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao dao = (UserDao)applicationContext.getBean("userDao"); dao.save(); &#125;&#125;所谓解决依赖，就是在使用时给其设置一个被依赖的对象，如果不使用Spring，设置name的值需要把dao转换为UserDaoImpl，再使用setName()方法，但是用了Spring我们就能在配置文件中设置，Spring帮我们完成设置。此时就叫做依赖注入。## ApplicationContext继承体系bean配置id &amp; namename和id的功能类似，作用如图：从语法上说name属性可以不唯一，而id必须唯一，但是实际使用时name标签和id标签通常都标识唯一值，而且优先使用name。初始化时执行的方法 &amp; 销毁的时候执行的方法init-method=””：指定的方法在bean被创建时执行。destroy-method=””：指定的方法在bean被销毁时创建的，但要求bean是单例的且手动关闭工厂。bean的作用域bean标签有一个属性scope=””，可以设置bean的作用范围，五种值如下：singleton ：默认的，Spring会采用单例模式创建这个对象。prototype ：多例模式。request ：应用在web项目中，Spring创建这个类以后，将这个类存入到request范围中。session ：应用在web项目中，Spring创建这个类以后，将这个类存入到session范围中。globalsession ：应用在web项目中，必须在porlet环境下使用。但是如果没有这种环境，相当于session。（笔者不懂，抄过来的…）]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04-单表DQL]]></title>
    <url>%2F2019%2F04-%E5%8D%95%E8%A1%A8DQL%2F</url>
    <content type="text"><![CDATA[数据准备12345678910111213141516171819create table product( pid int primary key, pname varchar(20), price double, category_id varchar(32));INSERT INTO product(pid,pname,price,category_id) VALUES(1,'联想',5000,'c001');INSERT INTO product(pid,pname,price,category_id) VALUES(2,'海尔',3000,'c001');INSERT INTO product(pid,pname,price,category_id) VALUES(3,'雷神',5000,'c001');INSERT INTO product(pid,pname,price,category_id) VALUES(4,'JACK JONES',800,'c002');INSERT INTO product(pid,pname,price,category_id) VALUES(5,'真维斯',200,'c002');INSERT INTO product(pid,pname,price,category_id) VALUES(6,'花花公子',440,'c002');INSERT INTO product(pid,pname,price,category_id) VALUES(7,'劲霸',2000,'c002');INSERT INTO product(pid,pname,price,category_id) VALUES(8,'香奈儿',800,'c003');INSERT INTO product(pid,pname,price,category_id) VALUES(9,'相宜本草',200,'c003');INSERT INTO product(pid,pname,price,category_id) VALUES(10,'面霸',5,'c003');INSERT INTO product(pid,pname,price,category_id) VALUES(11,'好想你枣',56,'c004');INSERT INTO product(pid,pname,price,category_id) VALUES(12,'香飘飘奶茶',1,'c005');INSERT INTO product(pid,pname,price,category_id) VALUES(13,'果9',1,NULL);简单查询查询表的所有字段信息：select * from 表名;查询表中某字段信息：select 字段1, 字段2 from 表名;去掉重复值：select distinct 字段1, 字段2, ... from 表名;若有多个字段则所有字段相等才被算为重复值。查询结果是表达式（运算查询）：将商品的价格+10元进行显示，select pname,price+10 from product;别名查询，使用的关键字是as（as可以省略的）：表别名：select * from product as p;列别名：select pname as pn from product;条件查询符号含义&gt; &lt; &lt;= &gt;= = &lt;&gt;!=大于、小于、大于(小于)等于、不等于BETWEEN …AND…显示在某一区间的值(含头含尾)(也可以是日期)IN(set)显示在in列表中的值，例：in(100,200)LIKE ‘张%’%代表零个或多个任意字符，_代表一个字符。例如：first_name like ‘_a%’IS NULL / IS NOT NULL判断为空/不为空and多个条件同时成立or多个条件任一成立not不成立，例：where not(salary&gt;100);例查询商品名称为“花花公子”的商品所有信息：SELECT * FROM product WHERE pname = &#39;花花公子&#39;查询价格为800商品：SELECT * FROM product WHERE price = 800查询价格不是800的所有商品：SELECT * FROM product WHERE price != 800SELECT * FROM product WHERE price &lt;&gt; 800SELECT * FROM product WHERE NOT(price = 800)查询商品价格大于60元的所有商品信息：SELECT * FROM product WHERE price &gt; 60;查询商品价格在200到1000之间所有商品：SELECT * FROM product WHERE price &gt;= 200 AND price &lt;=1000;SELECT * FROM product WHERE price BETWEEN 200 AND 1000;查询商品价格是200或800的所有商品：SELECT * FROM product WHERE price = 200 OR price = 800;SELECT * FROM product WHERE price IN (200,800);查询含有’霸’字的所有商品：SELECT * FROM product WHERE pname LIKE &#39;%霸%&#39;;查询以’香’开头的所有商品：SELECT * FROM product WHERE pname LIKE &#39;香%&#39;;查询第二个字为’想’的所有商品：SELECT * FROM product WHERE pname LIKE &#39;_想%&#39;;查询没有分类的商品：SELECT * FROM product WHERE category_id IS NULL;查询有分类的商品：SELECT * FROM prod quct WHERE category_id IS NOT NULL查询所有价格大于2000的电脑商品或者价格大于1000的服装商品：SELECT * FROM product WHERE (price &gt; 2000 AND category_id=&#39;c001&#39;) OR (price &gt;1000 AND category_id=&#39;c002&#39;);排序查询SELECT * FROM 表名 ORDER BY 排序字段 ASC|DESC;ASC： 升序 (默认)DESC：降序例：查询所有商品信息，使用价格排序(降序)：SELECT * FROM product ORDER BY price DESC;在价格排序(降序)的基础上，以分类排序(降序)：SELECT * FROM product ORDER BY price DESC, category_id DESC;显示商品的价格(去重复)，并排序(降序)：SELECT DISTINCT price FROM product ORDER BY price DESC;聚合查询聚合函数SELECT不仅可以作用于字段，还可以作用于聚合函数。count(…)：统计指定列不为NULL的记录行数；sum(…)：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；max(…)：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；min(…)：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；avg(…)：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；例：查询商品的总条数：SELECT COUNT(*) FROM product;查询价格大于200的商品总条数：SELECT COUNT(*) FROM product WHERE price &gt; 200;查询分类为’c001’的商品价格总和：SELECT SUM(price) FROM product WHERE category_id = &#39;c001&#39;;查询分类为’c002’商品的平均价格：SELECT AVG(price) FROM product WHERE category_id = &#39;c002&#39;;查询商品的最大价格和最小价格：SELECT MAX(price),MIN(price) FROM product;分组分组查询是指使用group by字句对查询信息进行分组。​ SELECT 字段1, 字段2… FROM 表名 GROUP BY 分组字段 HAVING 分组条件;HAVING：分组操作中的having子语句，是用于在分组后对数据进行过滤的，作用类似于where条件。与where的区别:having是在分组后对数据进行过滤。where是在分组前对数据进行过滤。having后面可以使用聚合函数过滤数据。where后面不可以使用聚合函数。例：统计各个分类商品的个数：SELECT category_id ,COUNT(*) FROM product GROUP BY category_id;统计各个分类商品的个数,且只显示个数大于1的信息：SELECT category_id, COUNT(*) FROM product GROUP BY category_id HAVING COUNT(*) &gt; 1;分页查询由于数据量很大，显示屏长度有限，因此对数据需要采取分页显示方式。例如数据共有30条，每页显示5条。格式：SELECT 字段1，字段2... FROM 表明 LIMIT M, N;M: 整数，表示从第几条索引开始，计算方式 （当前页-1）*每页显示条数N: 整数，表示查询多少条数据例：SELECT 字段1，字段2... FROM 表明 LIMIT 0,5;SELECT 字段1，字段2... FROM 表明 LIMIT 5,5;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03-DDL与DML]]></title>
    <url>%2F2019%2F03-DDL%E4%B8%8EDML%2F</url>
    <content type="text"><![CDATA[操作数据库创建数据库create database 数据库名;例：CREATE DATABASE db1;create database 数据库名 charset 字符集;例：CREATE DATABASE db2 CHARSET utf8;删除数据库drop database 数据库名使用数据库查看数据库的定义信息show create database 数据库名;操作表创建表1234567CREATE TABLE &lt;表名&gt;( 字段名1 类型(长度) [列级完整性约束条件], 字段名2 类型(长度) [列级完整性约束条件], ... 字段名n 类型(长度) [列级完整性约束条件] [,&lt;表级完整性约束条件&gt;]);先不涉及约束条件，后面会有详细分析。1234CREATE TABLE category ( cid INT PRIMARY KEY, #分类ID cname VARCHAR(100) #分类名称);查看表查看数据库中的所有表：SHOW TABLES;查看表结构：DESC 表名;删除表drop table 表名修改表名rename table 表名 to 新表名;增改删增向表中插入某些字段：insert into 表 (字段1,字段2,字段3..) values (值1,值2,值3..);向表中插入所有字段，字段的顺序为创建表时的顺序：insert into 表 values (值1,值2,值3..);注意：值与字段必须对应，个数相同，类型相同值的数据大小必须在字段的长度范围内除了数值类型外，其它的字段类型的值必须使用引号引起。（建议单引号）如果要插入空值，可以不写字段，或者插入 null。改更新所有记录的指定字段：update 表名 set 字段名=值, 字段名=值, ...;更新符号条件记录的指定字段：update 表名 set 字段名=值, 字段名=值, ... where 条件;注意：列名的类型与修改的值要一致修改值得时候不能超过最大长度除了数值类型外，其它的字段类型的值必须使用引号引起删删除所有数据：delete from 表名;或者truncate table 表名;delete 一条一条删除，不清空auto_increment记录数。truncate 直接将表删除，重新建表，auto_increment将置为零，从新开始。删除某些数据：delete from 表名 where 条件操作表结构添加列：alter table 表名 add 列名 类型(长度) [约束];ALTER TABLE category ADD cdesc VARCHAR(20);删除列：alter table 表名 drop 列名;ALTER TABLE category DROP cdesc;修改列名：alter table 表名 change 旧列名 新列名 类型(长度) 约束;ALTER TABLE category CHANGE cdesc description VARCHAR(30);修改列的类型长度及约束：alter table 表名 modify 列名 类型(长度) 约束;ALTER TABLE category MODIFY cdesc VARCHAR(50) NOT NULL;修改表的字符集：alter table 表名 character set 字符集;ALTER TABLE category CHARACTER SET gbk;数据完整性指数据库中存储的数据是有意义的或正确的。实体完整性若属性A是基本关系R的主属性，则属性A不能取空值。参照完整性若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码相对应，则对于R中每个元组在F上的值必须为：或者取空值（S的每个属性值均为空值）。或者等于S中某个元组的主码值。EMP(E#, ESEX, D#) -参照关系； DEPT(D# ,DNAME,LOCATION) -被参照关系用户定义的完整性针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。约束主键约束唯一标识一条记录的属性值。主键必须是唯一的值。主键列不能是 NULL 值。每个表都应该有且只能有一个主键。添加主键约束。方式一：创建表时，在字段描述处，声明指定字段为主键1234567CREATE TABLE Persons( Id_P int PRIMARY KEY, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255));方式二：创建表时，在表级约束区域，声明指定字段为主键格式：[constraint 名称] primary key (字段列表)关键字constraint可以省略，如果需要为主键命名，constraint不能省略。字段列表需要使用小括号括住，如果有多字段需要使用逗号分隔。这时多个字段联合构成主键。1234567CREATE TABLE Persons( FirstName varchar(255), LastName varchar(255), Address varchar(255), City varchar(255), [CONSTRAINT pk_PersonID] PRIMARY KEY (FirstName,LastName));方式三：创建表之后，通过修改表结构，声明指定字段为主键ALTER TABLE Persons ADD [CONSTRAINT 名称] PRIMARY KEY (字段列表)1234567CREATE TABLE Persons( FirstName varchar(255), LastName varchar(255), Address varchar(255), City varchar(255));ALTER TABLE Persons ADD PRIMARY KEY (FirstName);撤销主键约束：ALTER TABLE Persons DROP PRIMARY KEY自动增长列设置某列的值自动增长。使用 auto_increment（自动增长列）关键字。自动增长列类型必须是整形。自动增长列必须为键(一般是主键)。添加自动增长：1234567CREATE TABLE Persons( P_Id int PRIMARY KEY AUTO_INCREMENT, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255));添加数据时，可以不设置值，也可以设置成null，数据库将自动维护主键值：INSERT INTO Persons (FirstName,LastName) VALUES (&#39;Bill&#39;,&#39;Gates&#39;);INSERT INTO Persons (P_Id,FirstName,LastName) VALUES (NULL,&#39;Bill&#39;,&#39;Gates&#39;);修改起始值ALTER TABLE Persons AUTO_INCREMENT=100;非空约束约束不接受NULL值，意味着如果不向字段添加值，就无法插入新记录或者更新记录。添加方式方式一：创建表，下面的 SQL 语句强制 “Id_P” 列和 “LastName” 列不接受 NULL 值1234567CREATE TABLE Persons( Id_P int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255));方式二：修改表结构ALTER TABLE student MODIFY LastName varchar(255) NOT NULL删除非空约束ALTER TABLE student MODIFY LastName varchar(255);唯一约束UNIQUE约束唯一标识数据库表中的每条记录。PRIMARY KEY拥有自动定义的UNIQUE约束。每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。添加唯一约束方式1：创建表时，在字段描述处，声明唯一1234567CREATE TABLE Persons( Id_P int UNIQUE, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255));方式2：创建表时，在约束区域，声明唯一12345678CREATE TABLE Persons( Id_P int, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), CONSTRAINT 名称 UNIQUE (Id_P));方式3：创建表后，修改表结构，声明字段唯一ALTER TABLE Persons ADD [CONSTRAINT 名称] UNIQUE (Id_P);删除唯一约束ALTER TABLE Persons DROP INDEX 约束名称如果添加唯一约束时，没有设置约束名称，默认是当前字段的字段名。默认约束在添加数据中，如果该字段不指定值，采用默认值处理。添加方式方式一： 创建表，字段处声明1234567CREATE TABLE Persons( Id_P int, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255) DEFAULT '北京', City varchar(255));方式二： 修改表结构ALTER TABLE Persons MODIFY Address VARCHAR(255) DEFAULT &#39;北京&#39;;删除方式ALTER TABLE Persons MODIFY Address VARCHAR(255);外键约束参照关系对应的表是从表。被参照关系对应的表是主表。声明外键约束创建表时添加。12345678CREATE TABLE Persons( Id_P int, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255) DEFAULT &apos;北京&apos;, City varchar(255), [CONSTRAINT FK_DEPTNO] FOREIGN KEY (Address) REFERENCES CITY(Address));修改表结构alter table 从表 add [constraint 名称] foreign key (外键字段) references 主表 (主表主键);删除外键alter table 从表 drop foreign key 外键名称;备份 &amp; 恢复备份恢复&gt;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-MySQL环境安装]]></title>
    <url>%2F2019%2F02-MySQL%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装MySQLMySQL有两种安装方式，解压配置和安装程序安装。在这使用解压配置但是资源里有使用安装程序安装的教程。解压至指定目录解压至自己选定的目录，一般不选择系统盘。我是解压至D盘根目录：D:\mysql-5.5\。写配置文件123456789#设置字符集为utf8 character-set-server = utf8basedir = D:/mysql-5.5 #指定为自己选定的目录datadir = D:/mysql-5.5/data #指定为选定目录下的data文件夹[client] #设置客户端字符集default-character-set = utf8[WinMySQLadmin] Server = D:/mysql-5.5/bin/mysqld.exe #指定至mysqld.exe文件配置环境变量安装和配置在管理员下的cmd命令下进入%MYSQL_HOME%/bin目录执行mysqld -install。如果想要卸载服务执行命令mysqld -remove。启动服务net start mysql第一次进入mysql -u root。mysql&gt; update mysql.user set password=PASSWORD(‘root’) where User=’root’;mysql&gt; flush privileges;后续进入mysql -u username -p按提示输入密码退出exit停止服务net stop mysql查看编码集mysql&gt; show variables like ‘%char%’;1234567891011121314mysql&gt; show variables like &apos;%char%&apos;;+--------------------------+------------------------------+| Variable_name | Value |+--------------------------+------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | D:\mysql-5.5\share\charsets\ |+--------------------------+------------------------------+8 rows in set (0.01 sec)编码集如图上表示编码集配置正确。安装SQLyogSQLyog是一个可视化操作数据库工具。解压后就可使用：点击SQLyog.exe连接数据库使用]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-关系型数据库绪论]]></title>
    <url>%2F2019%2F01-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[数据、数据库、数据库管理系统数据：描述事物的符号记录称为数据，如文字、图形、图象、声音、学生的档案记录、货物的运输情况等。数据的含义称为数据的语义，数据与其语义是不可分的。数据库：数据按一定的方式组织、描述和存储后形成的数据集合叫做数据库。数据库具有三个特点：永久存储：不随程序的结束而结束。有组织：数据之间有一定的格式，可以通过格式知道数据所代表的的意义。可共享：数据库里的信息不是只为某一用户或某一程序所使用。数据库管理系统：数据库管理系统是位于用户与操作系统之间的一层用来管理数据库的软件。常用的数据库管理系统有MySQL、Oracle、Redis、MongoDB等。关系数据库系统数据库是由数据按某种形式组织所形成，按照不同的组织方式可以分为不同的类型。所以关系型数据库就是指以关系数学模型来组织数据的数据库，关系数学模型中以二维表的形式来描述数据。也就是一个关系对应一个二维表。实体-联系实体：客观存在并可相互区别的事物。二维表非首行。属性：实体所具有的某一特性。二维表的一格。码：唯一标识实体的属性。域：属性的取值范围。实体型：用实体名及其属性名集合来抽象和刻画同类实体。实体集：同型实体的集合称为实体集联系：现实世界中事物内部以及事物之间的联系在信息世界中反映为实体内部的联系和实体之间的联系。SQLDDL、DML、DCL、DQL常见的关系数据库系统有MySQL、Oracle等，可以使用结构化查询语言（Structured Query Language，SQL）进行操作。不同的数据库生产厂商都支持SQL语句，但都有特有内容（称为方言）。SQL可分为四类：数据定义语言（Data Definition Language，DDL）：用来定义数据库中的对象：数据库，表，列等。关键字有create、alter、drop、 show等。数据操作语言（Data Manipulation Language，DML）：用来对数据库中表的记录进行更新。关键字有insert、delete、update等。数据查询语言（Data Query Language，DQL）：用来查询数据库中表的记录。关键字：select，from，where等。数据控制语言（Data Control Language，DCL）：用来定义数据库的访问权限和安全级别，及创建用户。关键字有grant、revoke等。SQL通用语法SQL语句可以单行或多行书写，以分号结尾，可使用空格和缩进来增强语句的可读性。MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。例如：SELECT * FROM user。使用/* ... */的方式完成注释。数据类型类型描述int整型double浮点型varchar变长字符串型（指定为10个字节长度，存储abc只占用3个字节）char定长字符串型（指定为10个字节长度，存储abc也占用10个字节）datetimeYYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00~ 9999-12-31 23:59:59）实体型之间的联系一对一联系：如果对于实体集A中的每一个实体，实体集B中至多有一个实体与之联系，反之亦然，称实体集A与实体集B有一对一联系。记为1：1。一对多联系：如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，称实体集A与实体B有一对多联系。记为1：n。多对多联系：如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中有m个实体（m≥0）与之联系，称实体集A与实体B有多对多联系。记为m：n。多对多联系能经由一个中间表拆分成两个一对多关系。Entity-Relationship ModelE-R图提供了表示实体型、属性和联系的方法。先把需求转化成E-R图，可以方便的化简和建表。实体型：用矩形表示，矩形框内写明实体名。属性：用椭圆形表示，并用无向边将其与相应的实体连接起来。联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上。联系的类型: 1：1、1：n或m：n。联系本身也是一种实体型，也可以有属性。如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来。E-R图转换成关系转换原则：实体和联系分别转换为关系，再合并具有相同主键的关系。实体转换为关系：一个实体型 转换成 一个关系。实体型的名称 转换成 构成关系的名称。实体型的属性 转换成 构成关系的属性（也叫字段）。实体型的主键 转换成 关系的主键。联系转换为关系：一个联系 转换成 一个关系。与该联系相关联的各实体的码属性以及联系本身的属性 构成 关系的属性。联系转换为关系的码的取决于联系的类型。1：1联系，任一实体的码。1：n联系，n端实体的码。m：n联系，双方实体的码相同码的关系合并为一个关系。E-R图实例数据：科室：科名，科地址，科电话病房：病房号，床位号医生：姓名，职称，年龄，工作证病人：病历号，姓名，性别，诊断联系：一个科室有多个病房、多个医生一个病房只能属于一个科室一个医生只属于一个科室，但可负责多个病人的诊治一个病人的主管医生只有一个E-R图转换科室（科名，地址，电话）医生（医生名，职称，年龄，工作证号）病房（病房号，床位号）病人（病历号，姓名，性别，诊断）负责（床位号，科名）拥有（医生名，科名）诊治（病历号，医生名）合并科室（科名，地址，电话）医生（医生名，职称，科名，年龄，工作证号）病房（床位号，病房号，科名）病人（病历号，姓名，性别，诊断，医生名）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-进程的描述与控制]]></title>
    <url>%2F2019%2F02-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进程概念前趋图数据结构中的有向无环图。箭头表示进程之间执行的先后关系。结点表示一个程序或一个进程，甚至一条语句。程序的并发执行不存在前趋关系的程序之间才有可能并发执行。特征：间断性：程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系，进而导致并发程序具有“执行-暂停-执行”这种间断性的活动规律。失去封闭性：由于资源共享，所以当某程序的运行影响资源的状态时，其他程序的运行环境就会被破坏。不可再现性：计算结果与并发程序各自执行速度有关。即同一程序，使用相同输入、在相同环境下运行，却可能获得完全不同的结果。进程的定义在多道程序环境下，程序的执行属于并发执行，此时他们将失去其封闭性，并具有间断性，以及运行结果的不可再现性。由此，决定了通常的程序是不能参与并发执行的。为了能使程序并发执行，引入了进程。进程实体：程序+数据+进程控制块（Process Control Block，PCB）。进程：运行态的进程实体是就是进程，是系统进行资源分配和调度的一个独立单位。PCB是为了使程序能并发执行而诞生的一种数据结构，它用来控制和管理进程。由于数据和程序本来就存在，所以创建/撤销进程也就是创建/撤销PCB。至于如何并发执行，见下面的进程同步。区别于作业：进程是程序在数据集上的一次作执行，作业是用户提交给系统的一个任务，包含一个或多个进程。进程的特点动态性：由创建而产生，由调度而执行，由撤销而消亡。并发性：进程的重要特征，操作系统的重要特征。独立性：独立运行、独立分配资源、独立接受调度。异步性：按各自独立、不可预知的速度向前推进。PCBPCB中保存的信息进程标识符。用于唯一的标识某个进程。外部标识符：不仅可以标识进程，还指明其父进程、子进程以及拥有该进程的用户。内部标识符：方便系统使用进程，仅能标识进程。处理机状态。用于在进程切换时保存处理机中各个寄存器的内容。以便在该进程重新调度时能再从断点执行。进程调度信息。进程状态：指明进程的状态，方便进程调度和对换时的依据。进程优先级：进程优先级高的更容易获得处理机。进程调度所需信息：保存的内容和进程调度算法有关，如进程等待了多久CPU，使用了多长CPU。事件：进程因何由执行状态转变为阻塞状态，即阻塞原因。进程控制信息。程序和数据的地址。进程同步的通信机制。资源清单。进程已分配到的除处理机之外的资源。链接指针。用于指向下一个PCB的首地址。用于进程调度。PCB的组织方式线性方式：所有的PCB都保存在一张表中，每次寻找PCB都在表中查找。效率低。链接方式：把具有相同状态的PCB链接起来。索引方式：把具有相同状态的PCB保存在相应的表中。OS内核系统态 &amp; 用户态对于处理机来说，根据其执行的指令不同，可以将其分成系统态（管态、内核态）和用户态。处理机处于系统态时可以执行任意的指令，访问所有的寄存器和存储区，而处于用户态的时候会受到相应的限制。所以计算机中的程序可以分成系统程序和用户程序，用户程序运行在用户态，这样就可以防止用户程序对操作系统进行破坏。指令分类操作系统把CPU指令分成两类：特权指令：在系统态执行的指令。执行几乎不受限制，如启动外部设备、设置系统时钟等。非特权指令：在用户态执行的指令。限制较多，比如不能操作硬件等。内核概念现代操作系统采用分层设计模式，不同权重的程序分别设置在不同的层次中。通常与硬件紧密相关的程序、设备驱动程序和运行频率高的程序等放置在高级别层次中，操作系统会将它们常驻内存，这些程序便被称为OS内核。OS内核运行在系统态中。内核的功能不同操作系统的内核在功能上有一定的差异，但是一般都包含两类功能：支撑功能中断处理：是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，且处理完毕后又返回原被暂停的程序继续运行。人机交互、设备驱动和进程调度等都需要依赖中断处理。时钟管理：系统中很多活动都需要用到时钟，如定时任务、时间片轮转调度算法等。原语操作：原语是若干条机器指令构成的，用以完成特定功能的一段程序。而原语操作便是原语的执行，其在执行期间是不可分割的。资源管理功能进程管理：进程的创建、撤销、调度等操作。存储器管理：空间的分配、撤销、逻辑地址转换为物理地址等。设备管理：进行设备分配、缓和CPU和I/O速度不匹配矛盾的缓冲管理等。进程的生命周期进程的创建为新进程申请内部标识符，同时从PCB集合中索取一个空白的PCB。为新进程分配其运行所需的资源。这些资源直接来自操作系统或者父进程。初始化PCB。如处理机状态信息、标识符和进程优先级等。若就绪队列还能接受进程，则插入就绪队列。不能接受则执行相应处理机制。进程的终止从PCB集合中获得某进程的PCB，并读出该进程的状态。若进程正处于执行状态，应立即终止该进程的执行。若此进程有子进程则一并终止，防止其成为不可控进程。将进程拥有的所有资源归还给其父进程或操作系统。将被终止的进程从所在队列或链表（指PCB的组织方式）中移出，等待其他程序收集信息，释放空间等。三种基本状态就绪状态：分配到出处理机之外的其他所有必要资源。此时可运行，但其他进程正在占用CPU。执行状态：就绪状态的进程获得CPU，正在执行的状态。阻塞状态：进程发出的请求没有及时得到满足而无法继续执行的状态，此时会引起进程调度，OS把处理机分配给其他就绪进程，原进程暂停。挂起进程暂停执行或不接受调度的状态。原因有如下几点：用户的需要：用户想暂停正在的进程，观察其状态或修改程序等。父进程请求：父进程为了完成某项任务，协调其各子进程间的活动。负荷调节的需要：系统压力过大或实时操作系统不能很好的满足可靠性时会挂起一些进程。操作系统的需要：操作系统挂起某些进程来更方便的检查系统资源。挂起和阻塞不同在于阻塞是客观条件不能得到满足，即资源不足引起暂停。挂起是主观需要引起暂停。进程同步进程同步的主要任务是使并发执行的诸进程之间能有效的共享资源和相互合作，从而使程序的执行具有可再现性。同步 &amp; 互斥并发执行的诸进程之间既有独立性又有制约性。独立性：各进程都可独立地向前推进；制约性：由于资源共享和进程合作引起的进程之间的相互依赖和相互制约的关系。可归结为互斥和同步。同步：两个或多个事件的发生有着某种时序上的关系。按照这种时序关系进行能保证各任务安全的完成。互斥：资源的使用要排它使用，防止冲突（不同时使用，但无先后次序。一种特殊同步）。临界资源 &amp; 临界区临界资源：需要被各进程互斥访问的资源。临界区：各进程中访问临界资源的代码。若能保证各进程互斥地进入自己的临界区，便可以保证互斥地访问临界资源，进而保证进程同步。常用的方式有硬件同步机制和信号量机制。同步准则空闲让进：当无进程处于临界区时，应当允许一个进程进入自己的临界区。忙则等待：当有进程处于临界区时其他请求就如临界区的进程必须等待。有限等待：对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区。让权等待：当进程不能进入临界区时，应立即释放处理机避免进程陷入“忙等”的状态。硬件同步机制关中断当进程在临界区执行期间，计算机系统不响应中断，因此不会引发调度，临界资源只会被一个进程占据，这样就不会发生进程同步问题。利用Test-and-Set指令实现互斥指令的描述如下：123456boolean TS(boolean *lock)&#123; boolean old; old = *lock; *lock = true; return old;&#125;为临界资源设置一个布尔变量lock = false。在进程进入临界区之前利用TS指令测试，如果得到的值为false表示资源未被使用，如果得到的值为true，则一直测试到结果为false。使用TS指令实现互斥描述如下：1234567do&#123; ... while (TS(&amp;lock)); ... lock = false; ...&#125;while(true);利用Swap指令实现互斥指令描述如下：123456void swap(boolean *a, boolean *b)&#123; boolean temp; temp = *a; *a = *b; *b = temp;&#125;为每个临界资源设置一个全局变量lock=false。每个进程设置一个局部变量key。实现互斥的描述如下：12345678910do&#123; ... key = true; do&#123; swap(&amp;lock, &amp;key); &#125;while(key != false) critical section; lock = false; ...&#125;缺点关中断：效率低下且不适用于多处理机系统。且其他进行会”忙等“，不符合让权等待。TS指令 &amp; Swap指令：其他进行会”忙等“，不符合让权等待。信号量机制整型信号量整型信号量是一个用于描述资源数目的整型量（S）。但除了初始化以外，仅能通过两个原子操作来访问。wait(S)：P操作1234wait(S)&#123; while(S &lt;= 0); S--;&#125;signal(S)：V操作123signal(S)&#123; S++;&#125;P操作用于分配资源，V操作用于释放资源。记录型信号量整型信号量未遵循让权等待原则。只要S &lt;= 0就会不断的循环。此时需要增加一个进程链表指针链接等待进程。数据结构的描述：1234typedef struct&#123; int value; //资源数 struct process_control_block *list; //阻塞队列&#125; semaphore;wait(S)：12345wait(semaphore *S)&#123; S-&gt;value--; if(S-&gt;value &lt; 0) block(S-&gt;list);&#125;signal(S)：12345signal(semaphore *S)&#123; S-&gt;value++; if(S-&gt;value &lt;= 0) wakeup(S-&gt;list);&#125;当进程被阻塞时会被加入阻塞对列，资源被满足时唤醒阻塞对列中的某个资源。AND型信号量记录型信号量只能解决共享一个临界资源的情况，若有多个临界资源则需要使用多个记录型信号量。但是信号量越多，系统死锁的概率越大，且大量的同步操作会给系统的管理带来麻烦。AND型信号量的思想是一次性分配进程所需的全部资源，如果有一个没有分配成功，则其他所有可能为之分配的资源亦不分配。Swait(S)：123456789101112Swait(S1, S2, ..., Sn)&#123; while(true)&#123; if(Si &gt;= 1 &amp;&amp; ... &amp;&amp; Sn &gt;= 1)&#123; for(i = 1; i &lt;= n; i++) Si--; break; &#125;else&#123; 把进程阻塞在请求未能得到满足的资源Si所对应的阻塞队列里，同时把进程的程序计数器（放 置CPU下一条要执行的指令地址）放置在本操作的开始处（下一次再调度到此进程，需要再次 检查所有的资源）。 &#125; &#125;&#125;Ssignal(S)：12345678Ssignal(S1, S2, ..., Sn)&#123; while(true)&#123; for(i = 1; i &lt;= n; i++)&#123; Si++; 唤醒等待Si资源的阻塞队列。 &#125; &#125;&#125;信号量集之前的信号量都是一次申请或释放某资源一份，若申请或释放N份资源需要进行N次操作，效率比较低下。此外，当资源数量低于某一下限值时，为了系统安全，就不能再予以分配。所以产生信号量集解决以上问题。描述如下：Swait(S1, t1, d1, ..., Sn, tn, dn)：当Si &gt;= ti时Si = Si - di。（di &gt;= ti）Ssignal(S1, d1, ..., Sn, dn)：Si = Si + di。特殊的信号量集：Swait(S1, d, d)：每次申请d份资源，资源少于d时不分配。Swait(S, 1, 1)：退化成一般的记录型信号量。Swait(S, 1, 0)：S &gt;= 1时运行多个进行进入特定区。S &lt;= 0时禁止进程进入特定区。管程直接使用信号量机制会把大量的同步操作分散在各个进程中，这会增加系统死锁的概率并且不方便系统的管理。而管程就是把代表共享资源的数据结构和对共享数据结构的操作（包括同步机制）封装起来以更好的为进程使用。这时所有请求访问共享资源的进程都只能通过管程间接访问，同时管程每次只允许一个进程进入管程。此时的管程可以使用面相对象的操作来完成整型信号量的功能。但是此时无法解决“让权等待”的问题，所以再按照面相对象的思想将block和wakeup操作封装起来来解决这个问题，即构成条件变量。条件变量的操作如下：condition.wait()：使进程在因某条件不能满足时阻塞在其所对应的条件变量上。condition.signal()：唤醒因某条件不能满足而阻塞的进程。可以很容易看出来，设置不同的条件变量能使由不同原因等待的进程阻塞在不同的队列中。使用时把signal()操作放在函数/过程的最后，这样保证在唤醒其他进程后本进程能直接退出而不再产生冲突。管程的描述如下：123456789101112131415161718/* 1、局部数据和条件变量组成管程内的数据结构。 2、过程/函数1~过程/函数k组成管程内的一组过程对管程内的数据结构进行操作。 3、初始化代码：对管程内的数据结构进行初始化。*/Monitor monitor_name&#123; share variable declartions; //共享变量说明 condition declarations; //条件变量说明 &#123; //管程主体 initialization code; //初始化代码 ... &#125; public: //能被进程调用的过程 void P1(...)&#123;...&#125; void P2(...)&#123;...&#125; ... void Pn(...)&#123;...&#125;&#125;信号量的应用互斥访问资源设某共享资源的信号量是mutex，PA和PB进程并发时需互斥访问。12345678910111213141516171819semaphore mutex = 1;PA()&#123; while(1)&#123; ... wait(mutex); ... signal(mutex); ... &#125;&#125;PB()&#123; while(1)&#123; ... wait(mutex); ... signal(mutex); ... &#125;&#125;利用信号量实现前趋关系123456789101112P1（）&#123;...V(f1);V(f1);V(f1);&#125;P2（）&#123;P(f1)；... V(f2);&#125;P3（）&#123;P(f1)；... V(f3);&#125;P4（）&#123;P(f1)；... V(f4);&#125;P5（）&#123;P(f2)；... V(f5);&#125;P6（）&#123;P(f3);P(f4);P(f5);...;&#125;main()&#123; semaphore f1=f2=f3=f4=f5=0； Cobegin P1(); P2();P3(); P4();P5(); P6(); Coend&#125;在并发时，如果P1的功能代码未执行完，f1为0，每次对f1进行V操作能使P2、P3、P4运行一个。其他亦然。生产者—消费者问题问题描述：多个生产者进程生产产品以供多个消费者消费。通过由n个环形缓冲区构成的缓冲池（循环队列），把多个生产者和多个消费者联系起来。不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未取走的缓冲区中投放产品。分析：任何时刻，只能有一个进程在缓冲区中操作。对于“生产者”而言，缓冲区满则应等待。对于“消费者”而言，缓冲区空则应等待。利用记录型信号量解决问题12345678910111213141516171819202122232425262728293031int in = 0, out = 0;//in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。item buffer[n];//缓存区大小为n，地址为[0, n-1]。semaphore mutex = 1, empty = n, full = 0; //mutex用于互斥访问缓存区void producer()&#123; do&#123; produce an item nextproducer; ... wait(empty); //消耗一个empty，当empty&lt;=0时等待 wait(mutex); buffer[in] = nextproducer; in = (in+1) % n; signal(mutex); signal(full); //增加一个full &#125;while(true);&#125;void consumer()&#123; do&#123; wait(full); //消耗一个full，当full&lt;=0时等待 wait(mutex); nextconsumer = buffer[out]; out = (out+1) % n; signal(mutex); signal(empty); //增加一个empty ... &#125;while(true);&#125;void main()&#123; ConcurrentBegin produce();consumer(); ConcurrentEnd;&#125;互斥信号量 &amp; 资源信号量互斥使用的资源设置一个互斥信号量，资源数为1。资源信号量的资源数和资源的意义有关。资源信号量的资源为1时退化成互斥信号量。在使用时互斥信号量的P操作需要紧邻其对应共享资源的临界区使用，否则可能造成同步问题。比如互换上面代码的第8行和第9行之后，若生产者进程和消费者进程都只有一个，且生产者通过了P(mutex)，阻塞在P(empty)，消费者通过了P(full)，阻塞在P(mutex)，此时生产者等待消费者的V(empty)，消费者等待生产者的V(mutex)，发生死锁。而V操作不需要注意顺序。利用AND型信号量解决问题123456789101112131415161718192021222324252627int in = 0, out = 0;//in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。item buffer[n];//缓存区大小为n，地址为[0, n-1]。semaphore mutex = 1, empty = n, full = 0; //mutex用于互斥访问缓存区void producer()&#123; do&#123; produce an item nextproducer; ... Swait(empty, mutex); //消耗一个empty，当empty&lt;=0时等待 buffer[in] = nextproducer; in = (in+1) % n; signal(empty, mutex); //增加一个full &#125;while(true);&#125;void consumer()&#123; do&#123; wait(full, mutex); //消耗一个full，当full&lt;=0时等待 nextconsumer = buffer[out]; out = (out+1) % n; signal(full, mutex); //增加一个empty ... &#125;while(true);&#125;void main()&#123; ConcurrentBegin produce();consumer(); ConcurrentEnd;&#125;利用管程解决问题12345678910111213141516171819202122232425262728293031323334353637383940414243Monitor monitor&#123; item buffer[n]; int in = 0, out = 0, count = 0; condition notfull, notempty; public: void static put(item x)&#123; if(count &gt;= n) cwait(notfull); //阻塞在队列满的条件下 buffer[in] = x; in = (in+1) % n; count++; csignal(notempty); &#125; void static get(item &amp;x)&#123; if(count &lt;= 0) cwait(notempty); //阻塞在队列空的条件下 x = buffer[out]; out = (out+1) % n; count--; csignal(notfull); &#125;&#125;void producer()&#123; item x; while(true)&#123; ... produce an item in nextproducer; monitor.put(x); &#125;&#125;void consumer()&#123; item x; while(true)&#123; monitor.get(x); consume the item in nextconsumer; ... &#125;&#125;void main()&#123; ConcurrentBegin produce();consumer(); ConcurrentEnd;&#125;哲学家进餐问题问题描述：五个哲学家坐在圆桌前，每人一份饭，每个哲学家两侧各有一支筷子,只有拿到左右两只筷子才能进餐，哲学家处于吃饭和思考两种状态。分析同一时刻一只筷子只能有一个哲学家拿起。只有获得两个筷子后才能进餐。如果每个哲学家都拿起一只筷子，都饿死。并行程度：五只筷子允许两人同时进餐。利用AND型信号量解决问题每次必须拿到两只筷子才能拿起，否则不拿起筷子。12345678semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;do&#123; ... Swait(chopstick[i], chopstick[(i+1) % 5]); ... Ssignal(chopstick[i], chopstick[(i+1) % 5]); ...&#125;读者-写者问题问题描述：写者向共享数据区放数据，读者从共享数据区读数据。多个读者可同时读取数据，多个写者不能同时写数据。分析：读者进入共享数据区，写者必须等待。读者进入共享数据区，读者可以进入。写者进入共享数据区，读者必须等待。利用记录型信号量解决问题1234567891011121314151617181920212223242526272829semaphore readmutex = 1, writemutex = 1;int readcount = 0;void reader()&#123; do&#123; wait(readmutex); if(readcount == 0) wait(writemutex); readcount++; signal(readmutex); ... //read opreation wait(readmutex); readcount--; if(readcount == 0) signal(writemutex); signal(readmutex); &#125;while(true);&#125;void writer()&#123; do&#123; wait(writemutex); //当写者进入共享数据区，reader会阻塞在 ... //write operation signal(writemutex); &#125;while(true);&#125;void main()&#123; ConcurrentBegin reader();writer(); ConcurrentEnd;&#125;代码分析：最开始并发的时候：假如读者先抢到资源，readcount == 0，P(writemutex)，writer()会阻塞在第20行，但其他reader()仍可以运行，只是不会再P(writemutex)。同时每个reader()都readcount++，直到readcount == 0时V(writemutex)，然后writer()才有可能能进入。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。假如写者先抢到资源，P(writemutex)，此时readcount == 0，所有reader()阻塞在第7行。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。综上，完成了要求。读者-写者问题拓展问题描述：拓展就是又增加一个条件，最多只允许RN个读者同时读。利用信号量集解决问题123456789101112131415161718192021semaphore L = RN, mx = 1; //L用来控制访问数，mx控制写者访问时所有读者阻塞void reader()&#123; do&#123; Swait(L, 1, 1); //第RN+1个读者进入时会阻塞 Swait(mx, 1, 0);//mx &gt;= 1时才可以进入 ... //read operation Ssignal(L, 1); &#125;while(true);&#125;void writer()&#123; do&#123; Swait(mx, 1, 1; L, RN, 0); //mx &gt;= 1 &amp;&amp; L &gt;= RN时进入 ... //write operation Ssignal(mx, 1); &#125;while(true);&#125;void main()&#123; ConcurrentBegin reader();writer(); ConcurrentEnd;&#125;代码分析：最开始并发的时候：假如读者先抢到资源，L = L - 1，写者阻塞在第12行，但其他reader()仍可以运行，直至没有读者进程在访问共享数据区。当所有的读者进程都退出时，共享数据区中停留的个进程数都为0，即重新开始。假如写者先抢到资源，mx = mx - 1，所有读者进程和其他写者进程都要被阻塞，写者进程退出时，共享数据区中停留的个进程数都为0，即重新开始。理发师问题问题描述：一把理发椅，N把等待座位。理发师为理发椅上的顾客理发，没有顾客就在理发椅上睡觉，有一个顾客时需要叫醒理发师，多个顾客时需要在等待座位上等候。分析：理发椅上只能有一位顾客。等待座位是有限缓冲区。只要存在顾客，理发师就不能睡觉。利用记录型信号量解决问题：123456789101112131415161718192021222324semaphore customer = 0, barber = 0, mutex = 1; //barber使理发师只能为一个顾客服务int waiting = 0;void barber()&#123; while(true)&#123; wait(customer); //没有顾客的时候理发师睡觉 wait(mutex); waiting –= 1; //等待的人少一个 signal(mutex); signal(barber); ...//获得被激活进程的信息并给相应的顾客剪发 &#125;&#125;void customer()&#123; wait(mutex); if(waiting &lt; CHAIRS)&#123; //顾客到来的时候，还有座位就进去等待 waiting += 1; signal(mutex); signal(customer); wait(barber); ... //将被激活进程的信息发送给barber() &#125;else&#123; signal(mutex); &#125;&#125;代码分析在最开始并发的时候barber()会等待到有顾客时才醒来。顾客一来就需要访问waiting，所以获得mutex。如果位置不够就立即释放mutex。如果位置够，就让等待的人加1，再释放mutex。然后顾客人数customer += 1来激活理发师进程。理发师进程激活后会V(barber)，然后等待着的customer()进程争夺资源，争夺到P(barber)的进程将被激活进程的信息发送给barber()，barber()获得被激活进程的信息并给相应的顾客剪发。进程通信概念进程之间合作完成工作不仅仅需要有时序关系，还需要进程信息交互，比如刚才的理发师问题中就设计到了信息交互。从概念上说进程通信是指进程之间的信息交换，所以信号量机制本身就涉及到了信息交换，不过我们把这种信息交换叫做低级进程通信，因为其效率低且需要用户大量的干预。真正的进程通信需要满足使用方便且能高效传输大量数据的需求。共享存储器系统基于共享数据结构的通信方式：诸进程公用某些数据结构来实现进行通信 ，如生产者—消费者问题中的有界缓冲区，属于低级通信方式。基于共享存储区的通信方式：在存储器中划出一块共享存储区，诸进程通过对共享存储区中数据的读或写实现通信，此时数据的形式、位置和访问控制仍是进程实现。适用于传输大量数据，属于高级通信。管道通信系统所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件。向管道提供输入的发送进程（即写进程）以字符流形式将大量的数据送入管道，而接收进程（即读进程），可从管道中接收数据。管道通信系统必须满足以下三个要求：互斥：管道的使用必须互斥。因为存数据和取数据可归于写文件的添加和删除。同步：写进程把一定数量的数据写入管道后去睡眠，读进程读完后将其唤醒。读进程读空的管道时需要睡眠。确定对方存在：如果写进程不存在，读进程就会一直等待。如果读进程不存在，写进程写完数据后也会一直等待，所以通信双方必须同时存在。消息传递系统指进程可以利用一组通信命令（原语）把数据封装在消息中传送，不需要显示的指定共享存储区或数据结构等。它隐藏了通信的细节，也是目前使用最广泛的进程间通信机制。通常有两种实现方式：直接通信方式：OS提供原语给进程使用。间接通信方式：借助共享中间实体（称为邮箱）完成进程间的通信。和共享存储器系统的区别是进程不再需要指定数据的形式、位置和访问控制等，信箱内部自有实现。客户机-服务器系统前三种都是单机下的通信机制，这种是网络环境中的通信机制。主要有套接字和RPC两种方式。套接字：一个套接字是一个通信标识类型的数据结构，包含了通信目的地址、通信端口号、通信的网络协议、进程自身的地址以及对外提供的系统调用等。使用套接字可以在不同主机上的进程建立连接进而进行通信。RPC：Remote Procedure Call，它是一个通信协议，可以使本地进程调用其他主机的进程对程序员表现为常规方法调用。线程线程的由来进程解决了程序不能并发执行的问题，但是由于进程是拥有资源的基本单位，所以在创建、撤销和切换时所需的时空开销很大，因为处理机势必要付出更大的代价来保存现场。所以把拥有资源和独立运行两项功能分开，让线程作为独立运行的基本单位，进程作为拥有资源的基本单位。不过线程也拥有一些能保证其独立运行的资源，如TCB。TCB（Thread Control Block）所有用于控制和管理线程的信息都会被记录在线程控制块中，通常包含：线程标识符：每个线程都有唯一的线程标识符。处理机信息：包括程序计数器、状态寄存器、通用寄存器的内容。线程运行状态：线程和进程一样也有多种运行状态，就绪、阻塞、运行等。详见103-网络编程。优先级：和调度算法有关，优先级越高，得到处理机的机会越大。线程专有存储区：用于在线程切换时保存现场状态和保存线程的统计信息。信号屏蔽：屏蔽某些发送给线程的信号。堆栈指针：线程调用别的过程时需要保存局部变量和返回地址等来供返回时能继续执行。线程的实现线程是为了解决进程调度时过于笨重的问题，所以在不同的环境中实现线程的方式不同。根据内核能否感知到线程的存在可分为内核支持线程（Kernel Supported Threads，KST）和用户级线程（User Level Threads，ULT）。它俩的区别是能否直接调用系统服务，前者可以而后者需要借助中间系统。内核支持线程若线程是由内核直接调度，线程资源也是保存在内核空间，就可以说此类线程为内核支持线程。此类线程的创建、撤销和切换等操作都是在内核空间完成的，此时线程可以直接调用系统服务。一种可能的实现方式是在创建进程时分配一个任务数据区（Per Task Data Area，PTDA），各个线程的TCB保存在其中即可。不过仅实现内核支持线程的系统对用户进程创建的线程很不友好，每次线程调度处理机都要从用户态转换到核心态。用户级线程用户级线程是指线程虽客观存在但对内核来说是透明的，此时不能再直接调用系统服务，间接调用系统服务需要有中间系统的支持，通常的中间系统有运行时系统和内核控制线程。运行时系统：把创建线程、撤销线程和线程同步等只能由OS内核完成的操作封装起来作为运行时系统，而运行时系统停留在用户空间供其他进程调用来实现线程调度。内核控制线程：这种线程又被称作轻量进程（Light Weight Process，LWP），它既可以共享进程的资源，又可以使用内核提供的服务。虽然下图中LWP和用户线程是1对1关系，但实际上多个用户级线程可以复用一个LWP，但每个轻型线程都要连接到一个内核线程中。所以此种方式系统需要同时实现内核支持线程。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-操作系统引论]]></title>
    <url>%2F2019%2F01-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[操作系统的定义操作系统（Operating System，简称OS）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是管理硬件设备来提高利用率和吞吐量，同时为用户和应用系统提供易于使用的接口。提高利用率：使系统中各设备的空闲时间尽可能短。提高吞吐量：使单位时间内完成的业务更多。提供易于使用的接口：即是方便使用计算机资源。例如没有操作系统，操纵计算机可能需要用户输入二进制代码，有了操作系统，用户可以点击图标，操作系统就会将其转换成二进制代码。操作系统的目标方便性：即对用户和应用程序提供易于使用的接口。有效性：提高利用率和吞吐量。可扩充性：计算机硬件和体系结构等都在不断发展中，OS需要有好的可扩充性来满足不断发展的需求。开放性：为了使计算机的应用环境从单机转换成网络，OS需要满足相应的软硬件标准来实现设备的互联。操作系统的作用提供易于使用的接口，如Shell、图形界面等。管理计算机所有的资源，负责计算机系统全部资源的分配、控制、调度和回收。隐蔽硬件特性，如计算2*3，某些机器的实现是使用加法器做2+2+2，而有的机器是乘法器实现2*3。操作系统屏蔽这些细节，用户只需要输入2*3就能完成。未配置操作系统的计算机系统人工操作：程序员把程序和数据通过穿孔的方式记录在纸带上，再启动机器读入纸带，运行完成并取走计算结果后，才允许下一个用户上机。缺点：用户独占整机：计算机上的资源为上机用户独占。设备空闲率高：用户装卡，卸卡等人工操作时，设备资源是空闲的。脱机输入/输出（Off-Line I/O）：为了解决人机矛盾及CPU、I/O等设备之间速度的不匹配。它是先把纸带通过输入设备在外围机（与主机相比处于次要地位的计算机）的控制下输入到磁带上，当CPU需要这些信息时再从磁带上高速地调取。类似的，在输出时把信息输出到磁盘中，在外围机的控制下通过输出设备输出。也就是说主机直接对磁盘进行操作，输入输出和程序运行脱离。減少了CPU的空闲时间：主机不必依赖输入输出，可以从磁盘中读取数据。提升了I/O速度：主机读取信息不再是从卡片中读取，从磁盘读取速度较快。批处理系统为了提升计算机资源的利用率和提升计算机的吞吐量研发出了批操作系统。基础概念作业：程序+数据+作业说明书（系统根据说明书来对程序的运行进行控制）。周转时间：从作业进入系统到作业完成退出系统所用的时间。平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NT_i]​$带权周转时间：作业的周转时间（$T​$）和系统为它提供服务的时间（$T_S​$）。$W=\frac{T}{T_s}​$平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NW_i]​$单道批处理系统设计一个常驻内存的程序（监督程序），操作员有选择地把若干作业合成一批，安装输入设备上，并启动监督程序，然后由监督程序自动控制这批作业运行，从而减少部分人工干预，有效地缩短了作业运行前的准备时间，相对的提高CPU的利用率。同一时刻只有一个硬件在运行。特点：自动性、顺序性、单道性。缺点：I/O的慢速与CPU 的高速不匹配，且输入时需要CPU等待。用户交互性差。作业安装输入后，就不能再交互。多道批处理系统把一个以上的作业存放在主存中，并且同时处于运行状态，使这些作业共享处理机和外部设备等其它系统资源。对于一个单处理机系统来说，作业同时处于运行状态只是宏观的概念，其含义是指每个作业都已开始运行，但尚未完成。就微观而言，在任意特定时刻，处理机上运行的作业只有一个。特点：多道性、无序性、调度性。优缺点：优点：资源利用率高、系统吞吐量大。缺点：作业仍然要排队处理，所以平均周转时间长、无交互能力。此时如何调度程序已经不是再用一张简单的流程图能说明了，第二章会有介绍。下图只是说明处理器利用率高。举例证明资源利用率高和系统吞吐量大设内存中有三道程序 A、B、C，它们的计算和I/O操作的时间如下表所示：程序操作ABC计算306020I/O403040计算101020单道多道分时系统批处理系统中，作业一旦提交就不能进行更改，所以人机交互性很差。为了满足人机交互的需求诞生分时系统。每一个用户通过一台终端与计算机相连，以交互式的命令使用系统，采用分享CPU的方法，由于CPU的速度比人在终端输入指令的时间快得多，所以用户感到自己独占了整个计算机系统。系统规定一个称之为“时间片”的时间单位，所有终端用户轮流享用一个时间片的CPU。需要解决的问题：及时接受：所有终端用户输入的信息都要能够被及时的送到处理器上。所以主机会以很快的速度循环扫描各个终端。每个终端也要拥有缓存区来保存输入的信息。及时处理：用户需要能对自己的作业及其允许及时地实施控制。所以所有的作业必须驻留在内存中，因此批作业系统不能被使用。它采用的方式是：作业直接进入内存。但每个用户只连续使用一个“时间片”的时间，对所有用户进行循环。这样每个用户都能及时地与自己的作业进行交互。分时系统与多道批处理系统的不同特性多路性：允许多个用户共享一台计算机，提高资源利用率。独立性：每个用户之间互不干扰，感觉就是一个人在独占一台计算机。及时性：用户的请求能在很短的时间内得到回应。交互性：用户可以通过终端和计算机进行及时交互。实时系统指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。实时系统强调程序运行的时间，它需对接收到的某些信号做出及时地反应。大多数的实时系统是专用系统，如：工业（武器）控制系统、信息查询系统、多媒体系统、嵌入式系统等。最大的特点就是可靠性：系统必须高度可靠，因为任何可能的差错都可能带来灾难性后果，所以系统一般都有多级容错措施。按是否周期执行分类：周期性实时任务：如外部设备周期性地发出状态信号给计算机使其状态能被实时感知。非周期性实时任务：提交给系统时需要指定开始截止时间和完成截止时间。硬实时任务&amp;软实时任务：硬实时任务（Hard Real-time Task）：截止时间到达时任务必须完成，比如武器控制系统。软实时任务（Soft Real-time Task）：截止时间到达时任务没有完成没有太大影响，比如多媒体系统。进程和线程进程：在系统中能独立运行并作为资源分配的基本单位。线程：独立运行的基本单位，比进程更小，基本上不拥有系统资源。通常在一个进程中包含了若干个线程。操作系统的基本特性并发：宏观上是多个进程同时运行，微观上是每一时刻只有一道进程在执行。共享：系统中的资源可供内存中多个并发执行的进程（线程）共同使用。有两种共享方式：互斥共享方式，如打印机；同时访问方式，如共享文件夹、网络资源。虚拟：通过某种技术把一个物理实体变为若干个逻辑上的对应物。这样可以避免一个进程单独占用某个物理设备，一个物理设备被分配给多个进程便可以提升物理设备的使用率。不确定性（异步性）：进程以人们不可预知的速度向前推进，即为进程的不确定性。这样的话很可能是先进入内存的作业后完成；而后进入内存的作业先完成。尽管如此，但只要有合理的进程同步方式且运行环境相同，作业经多次运行，都会获得完全相同的结果。因此，异步运行方式是允许的。操作系统的结构传统操作系统结构无结构OS：关注功能的实现和获得高的效率操作系统是为数众多的一组过程的集合，各过程之间可以相互调用，在操作系统内部不存在任何结构。程序设计的技巧，只是如何编制紧凑的程序，以便于有效地利用内存。操作系统既庞大又杂乱，缺乏清晰的程序结构。程序错误很多，给调试工作带来很多困难；另一方面也使程序难以阅读和理解，增加了维护人员的负担。模块化结构OS模块化程序设计技术，是最早（20世纪60年代）出现的一种程序设计技术。该技术是基于“分解”和“模块”原则来控制大型软件的复杂度的。将OS按其功能划分为若干个具有一定独立性和大小的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口， 使各模块之间能通过该接口实现交互，然后再进一步将各模块细分为若干个具有一定管理功能的子模块。（会导致模块之间的依赖关系很重，OS结构不清晰）若子模块较大时，再进一步将它细分。分层式结构OS：改进设计方式，使每一步设计都是建立在可靠的基础上一层一层地自底向上增添软件层，每一层都实现若干功能，最后总能构成一个能满足需要的OS。每一层都仅使用其底层所提供的功能和服务，这样可使系统的调试和验证都变得容易。一旦发现错误后，通常该错误只会局限于某一层，因为它与所有其高层的软件无关，而此层以下的各层软件，又都经过仔细的调试，bug修复较为容易。客户/服务器结构为了提高OS的灵活性和可扩充性而将OS划分为两部分。一部分是用于提供各种服务的一组服务器（进程），所有这些服务器（进程）都运行在用户态。当有一用户进程（现在称为客户进程）要求读文件的一个盘块时，该进程便向文件服务器（进程）发出一个请求；当服务器完成了该客户的请求后，便给该客户回送一个响应。另一部分是内核，用来处理客户和服务器之间的通信， 即由内核来接收客户的请求，再将该请求送至相应的服务器；同时它也接收服务器的应答， 并将此应答回送给请求客户。此外，在内核中还应具有其它一些机构，用于实现与硬件紧密相关的和一些较基本的功能。面向对象结构（20世纪80年代）该技术是基于“抽象”和“隐蔽”原则来控制大型软件的复杂度的。所谓对象，是指在现实世界中具有相同属性、服从相同规则的一系列事物的抽象，而把其中的具体事物称为对象的实例。OS中的各类实体如进程、线程、消息、存储器等，都使用了对象这一概念，相应地，便有进程对象、线程对象、 存储器对象等。由于隐蔽了表示实体的数据和操作，因而可以改变对象的表示而不会影响其它部分， 从而可以方便地改变老的对象和增加新的对象。继承性。继承性是面向对象技术所具有的重要特性。继承性是指子对象可以继承父对象的属性，这样，在创建一个新的对象时， 便可减少大量的时空开销。正确性和可靠性。由于对象是构成操作系统的基本单元，可以独立地对它进行测试，这样，比较易于保证其正确性和可靠性，从而比较容易保证整个系统的正确性和可靠性。微服务结构（20世纪90年代）能有效支持多处理机，适用于分布式系统环境。以微内核为操作系统核心，以客户/服务器为基础，采用了面向对象的程序设计方法。所谓微内核技术，是指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS(程序)不同， 它更小更精炼，它不仅运行在核心态，而且开机后常驻内存， 它不会因内存紧张而被换出内存。微内核并非是一个完整的OS， 而只是为构建通用OS提供一个重要基础。在微内核OS结构中，通常都采用了客户/服务器模式，因此OS的大部分功能和服务，都是由若干服务器来提供的， 如文件服务器、作业服务器和网络服务器等。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
