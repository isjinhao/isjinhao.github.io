<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c与cpp]]></title>
    <url>%2F2019%2Fc%E4%B8%8Ecpp%2F</url>
    <content type="text"><![CDATA[数据类型绝对值在$10^9$范围以内或者是32位的整数都可以定义成int型。绝对值在$10^{18}$范围以内或者是64位以内的整数可以定义为long long型。如果long long型赋大于$2^{31}-1$的初值，则需要在初值后面加上LL。遇到浮点型数据不要使用float，都应该使用double。小写字母的ASCII值开始于97，大写字母的ASCII值开始于65。小写字母比大写字母大32。\0表示NULL。运算符运算符含义语法效果&lt;&lt;左移a &lt;&lt; x整数a按二进制位左移x位&gt;&gt;右移a &gt;&gt; x整数a按二进制位右移x位&amp;位与a &amp; b整数a和b按二进制对齐，进行按位与运算``位或$a \mid b$整数a和b按二进制对齐，进行按位或运算^位异或a ^ b整数a和b按二进制对齐，进行按位或运算~位取反~a整数a在二进制下各位取反解释按位与：除了11为1，其他都是0；按位或：除了00为0，其他都是1；按位异或：相同为0，不同为1。无穷大const int INF = (1 &lt;&lt; 30) - 1;const int INF = 0x3fffffff;scanf数据类型格式符举例int%dscanf(&quot;%d&quot;, &amp;n)long long%lldscanf(&quot;%lld&quot;, &amp;ll)float%fscanf(&quot;%f&quot;, &amp;fl)double%lfscanf(&quot;%lf&quot;, &amp;db)char%cscanf(&quot;%d&quot;, &amp;c)字符串（char数组）%sscanf(&quot;%d&quot;, str)scanf双引号之内的字符串其实类似一个匹配模式，我们输入的参数只要能匹配这个模式其实都算对。比如在输入时间时：scanf(&quot;%d:%d:%d&quot;, &amp;hour, &amp;minute, &amp;second)。输入的参数只要是：h​:m:​d的形式就行。除了字符类型（%c），scanf对于其他类型都是默认以空白符（空格、换行等）判断结束标志的。但是在使用字符类型时可以读入空白符。如对于scanf(&quot;%d%c%s&quot;, &amp;a, %c, str)，我们输入1 a bad，得到的结果是a=1, c= , str=a。printf数据类型格式符举例int%dprintf(&quot;%d&quot;, n)long long%lldprintf(&quot;%lld&quot;, ll)float%fprintf(&quot;%f&quot;, fl)double%fprintf(&quot;%f&quot;, db)char%cptintf(&quot;%d&quot;, c)字符串（char数组）%sptintf(&quot;%d&quot;, str)输出%和\：printf(&quot;%%&quot;)，printf(&quot;\\&quot;)%md &amp; %0md &amp; %.md%md：使不足m位的int型变量以m位且右对齐输出，高位以空格补齐，若变量本身超过m位，则保持原样。%0md：使不足m位的int型变量以m位且右对齐输出，高位以0补齐，若变量本身超过m位，则保持原样。%.mf：让浮点数保留m位小数输出。如果题目要求保留xx位小数，使用这个格式便是正确的。这种格式不是四舍五入：它是四舍六入偶成双。getchar &amp; putchargetchar()输入单个字符，putchar(char c)输出单个字符。如char c = getchar();，getchar()可以读入换行符。typedef给复杂的数据类型定义一个别名。如：typedef long long ll。常用math函数double类型取绝对值：fabs(double x)double类型向上取整：floor(double x)double类型向下取整：ceil(double x)求$r_p$：pow(double r, double p)取double类型的算术平方根：sqrt(double x)得到以自然对数为底的对数：log(double x)得到以a为底b的对数：$log_ab$=log(b)/log(a)四舍五入：round (double x)三角函数：sin(double x)，cos(double x)，tan(double x)：参数是弧度制。asin(double x)，acos(double x)，atan(double x)。memsetmemset(数组名, 值, sizeof(数组名));。memset是按字节赋值，也就是说所有的字节都会被赋值为相同的数值，比如对于int a[10]，使用memset(a, 1, sizeof(a);，则四十个字节上的二进制结果都是00000001。由于0的二进制补码全为0，-1的二进制补码全为1，所以memset一般只用于赋值0和-1。字符数组仅在初始化的时候可以直接赋值字符串，如：char str[4] = &quot;PAT&quot;;gets(str)：读入一行字符串，以换行符作为输入结束。puts(str)：输出一行字符串，即输出字符串+换行符。gets()和scanf()在读入字符串时会自动添加结束符（\0）。string.h头文件strlen()：获得字符数组中第一个\0前的字符个数（不包含\0）。strcmp(str1, str2)：比较两个字符串的大小（字典序）：str1 &lt; str2：返回负整数；str1 == str2：返回0；str1 &gt; str2：返回正整数；strcpy(str1, str2)：把str2复制给str1，包含结束符\0。strcat(str1, str2)：把str2粘贴在str1后面（覆盖str1的\0）。sscanf &amp; sprintf用于处理字符串问题：sscanf(原位置，格式符，目的位置)：把原位置里的数据输入到目的位置中。sprintf(目的位置, 格式符, 原位置)：把原位置里的数据输出到目的位置中。12345678int main()&#123; int n; char str[100] = "123"; sscanf(str, "%d", &amp;n); //字符转int时不是强转为ASCII，是字面值相同。 printf("%d\n", n); //123 return 0;&#125;处理复杂的字符串：12345678910int main()&#123; int n; double db; char str1[100] = "2048:3.14,hello"; char str2[100]; sscanf(str1, "%d:%lf,%s", &amp;n, &amp;db, str2); printf("n=%d, db=%.2f, str2=%s\n", n, db, str2); //n=2048, db=3.14, str2=hello return 0;&#125;12345678910int main()&#123; int n = 12; double db = 3.1415926; char str1[100]; char str2[100] = "good"; sprintf(str1, "%d:%.2lf,%s", n, db, str2); printf("str2=%s\n", str1); //str2=12:3.14,good return 0;&#125;指针指针存储的地址的类型称为基类型。基类型必须和指针变量存储的地址类型相同。进行加减法得到的是其基类型偏移的位数。如，两个int型指针相减，等价于两个指针之间差了几个int。指针作为函数的参数，传递的是地址的拷贝123456789101112void testPointer(int *p1, int * p2)&#123; p1 = p1 + 1; cout &lt;&lt; *p1 &lt;&lt; endl; //3&#125;int main()&#123; int a[6] = &#123;1, 2, 3, 4, 5, 6 &#125;; testPointer(&amp;a[1], &amp;a[5]); cout &lt;&lt; a[1] &lt;&lt; endl; // 2 return 0;&#125;指针在创建的时候赋予初值。否则可能出现问题。如int *temp;，temp会被赋予一个随机空间，可能指向系统功能区，此时程序运行就会问题。结构体结构体限制：结构体内部不能定义本类型，但可以定义本类型的指针。结构体的构造函数：1234567891011121314struct studentInfo&#123; int id; char gender; studentInfo()&#123;&#125; studentInfo(char _gender): gender(_gender) &#123;&#125; studentInfo(int _id, char _gender): id(_id), gender(_gender) &#123;&#125;&#125;;int main()&#123; studentInfo stu = studentInfo(10086, 'M'); cout &lt;&lt; stu.id &lt;&lt; " " &lt;&lt; stu.gender &lt;&lt; endl; return 0;&#125;浮点数的比较计算机采用有限位的二进制代码，因此浮点数在计算机中的存储并不总是精确的，具体参考IEEE754规则。所以我们需要定义一个极小数eps（一般定义为$10^{-8}$）对这种误差进行修正。等于运算大于运算小于运算大于等于运算小于等于运算123456789101112const double eps = 1e-8;const double Pi = acos(-1.0);#define Equ(a, b) ((fabs((a) - (b))) &lt; (eps))#define More(a, b) ((a) &gt; (b + (eps)))#define Less(a, b) ((a) &lt; (b - (eps)))#define MoreEqu(a, b) ((a) &gt; (b - (eps)))#define LessEqu(a, b) ((a) &lt; (b + (eps)))单点测试提交的程序被执行多次，每次执行会输入一组数据，得到输出后和此组数据的结果做比较，如果相同则判断此测试点通过，总成绩等于N次执行的成绩之和。PAT采用的是单点测试的方案。多点测试提交的程序被执行一次，会把所有的测试数据都输入，如果其中一组输出出错，则此题错误。所以此时需要程序能有循环读入多组数据的能力。大多数OJ系统采用这种方案，如codeup。下面介绍三种读入方案：while ... EOF应用于没有给定输入的结束条件，默认读到文件末尾。123while(scanf("%d", &amp;n) != EOF)&#123; ...&#125;while ... break应用于题目要求输入的数据满足某个条件时停止输入12345while(scanf("%d", &amp;n) != EOF)&#123; if(n == 0) break; ...&#125;while(T--)当题目给出测试数据组数时采用这种方案。1234int T = 20；while(T--)&#123; ...&#125;]]></content>
      <categories>
        <category>算法笔记</category>
      </categories>
      <tags>
        <tag>C</tag>
        <tag>C++</tag>
        <tag>PAT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07-javaweb环境搭建]]></title>
    <url>%2F2019%2F07-javaweb%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[06-Gcc与Make]]></title>
    <url>%2F2019%2F06-Gcc%E4%B8%8EMake%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[05-Shell]]></title>
    <url>%2F2019%2F05-Shell%2F</url>
    <content type="text"><![CDATA[简介Shell是一个命令解释器，用户输入命令来获得自己想要的结果，但是终端中输入的命令很难进行高级语言的选择、循环等操作。不过Shell程序可以存放在文件上，称为Shell脚本（虽然Linux文件不以后缀名区分文件类型，但是一般编写Shell脚本时文件名会命名为以.sh结尾）。在脚本中可以较方便的进行类似高级语言的操作。最简单的Shell脚本我们都知道，直接在终端输入echo命令是回显参数，把echo命令放在shell脚本中有相同的效果。设置成可执行文件变量Shell脚本中的变量直接使用=便可创建，使用$解析变量名。{}是分组命令，表示H是一个变量，这里不加也可以。特殊变量$#：除脚本名外，命令行上参数的个数。$*：表示在命令行上实际给出的所有实参。如：exam3.sh A B C D E F G H I J K。$#是11。$*是： A B C D E F G H I J K$n：表示命令行上第n个参数$0表示文件名 $1表示第一个参数 …$@：表示在命令行上实际给出的所有实参。如：exam3.sh A B C D E F G H I J K。$@就是： “A” “B” “C” “D” “E” “F” “G” “H” “I” “J” “K”$$：当前进程的进程号$!：上一个后台命令对应的进程号。$?：上一条前台命令执行后的返回值。算术运算执行算术运算需要使用let，如let c=$a+$b。可以使用c=$(($a+$b))代替。其中算术运算符及优先级等同于C语言。同时多了个**表示幂运算。（运算符前后不要有空格）从命令行读入参数直接使用read，命令行中的参数会读到read后面跟的参数（相当于变量）里。读入时输出提示信息：引号双引号：由双引号引起来的字符（除$、`和`\`）都被当做普通字符对待。$表示变量替换； `表示命令替换；\之后的字符只有是$、 、双引号、`或换行符之一时会成为转义字符。其他情况都是\本身。单引号：单引号引起来的字符都是普通字符。特殊字符也失效。倒引号：被到引号引起来的字符被解释为命令。如上上图中所示。数组变量之间使用空格隔开各个元素。如果元素中有空格，使用双引号引起来。测试条件任何命令都可以作为条件，shell会执行这个命令并检查返回值，如果命令成功（返回值为0），表示真。test &lt;条件&gt;：如test n1 -eq n2[ 条件 ]：如[ n1 -eq n2 ]有关文件方面的测试-r 文件名：真 &lt;==&gt; 文件存在并且是用户可读-w 文件名：真 &lt;==&gt; 文件存在并且是用户可写-x 文件名：真 &lt;==&gt; 文件存在并且用户可执行-f 文件名：真 &lt;==&gt; 文件存在且是普通文件-d 文件名：真 &lt;==&gt; 文件存在且是目录文件-s 文件名：真 &lt;==&gt; 文件存在且长度大于0有关字符串方面的测试-z s1：真 &lt;==&gt; 字符串长度为0-n s1：真 &lt;==&gt; 字符串长度大于0s1：真 &lt;==&gt; 字符串不是空字符串s1 = s2（在“=”前后应有空格）：真 &lt;==&gt; 字符串相等s1 != s2：真 &lt;==&gt; 字符串不等s1 &lt; s2：真 &lt;==&gt; 按字典顺序s1在s2之后s1 &gt; s2：真 &lt;==&gt; 按字典顺序s1在s2之前数值方面的测试n1 -eq n2：真 &lt;==&gt; 数值相等n1 -ne n2：真 &lt;==&gt; 数值不等n1 -lt n2：真 &lt;==&gt; n1小于n2n1 -le n2：真 &lt;==&gt; n1小于或等于n2n1 -gt n2：真 &lt;==&gt; n1大于n2n1 -ge n2：真 &lt;==&gt; n1大于或等于n2逻辑运算符!：逻辑非-a：逻辑与-o：逻辑或(表达式)：圆括号括起来表示为一条语句选择结构循环结构break &amp; continue和C语言一致。shift参数跳转命令：不跟数组默认跳转1位，跟了跳转n位。命令行ex.shABCDEF原位置参数$0$1$2$3$4$5$6移位后参数$0$1$2$3$4$5还可以用于循环结构的done上面，表示每次选择指定参数。参数置换变量格式var1为空var1不空var2=${var1:-str}var2=str。var1不变var2=$var1。var1不变var2=${var1:=str}var2=var1=strvar2=$var1。var1不变var2=${var1:+str}var2为空。var1不变var2=str。var1不变var2=${var1:?str}输出：“shell 脚本名:var1:str”并退出shell。var2不变var2=$var1。var1不变ex1编写ex1.sh，参数为一个大于 20 的正整数。先检查参数是否符合要求。如果不符合要求，请给出提示；如果符合要求，输出这个参数的平方。ex2编写ex2.sh，首先显示当天日期，然后查找给定的用户是否在系统中工作（who 命令）。如果在系统中，就输出一条欢迎语句（例如 hello，xxxx！）；如果不在系统中，就输出一条语句（waiting for xxx！）ex3编写 ex3.sh，该脚本接受一个参数。若改参数不是目录，则给出提示信息；否则使用ll命令列出该目录下的内容，并输出有多少个子目录（d开头），多少个普通文件（-开头）。ex4编写 ex4.sh，将第一个参数指定的内容 copy 到第二个参数指定地点。若第一个参数是目录，自动添加-r选项（即把目录下的所有内容都 copy 过去）；若第一个参数是普通文件，则将其 copy 到指定地点；若第一个参数指定的文件或目录不存在，则报错；若第二个参数指定的文件或目录已经存在，则提示是否替换，若选择 yes，则先删除原来的文件或目录，然后再执行 copy 操作，否则放弃。ex5编写 ex5.sh。检查命令行的第一个参数是否是-b或者-s。如果是-b，则计算由第二个参数指定的文件中以 b 开头的行数。如果是-s，则计算由第二个参数指定的文件中以 s 开头的行数。否则显示选择有错的信息。ex6编写 ex6.sh。该脚本需要输入两个文件的名称，然后由用户选择相应的操作（若两个参数中任何一个不是普通文件，则报错）。cat：输出两个文件的内容statistic：统计两个文件分别有多少行merge：将第 1 个文件的内容合并到第 2 个文件后面copy：将第 1 个文件的内容 copy 到第 2 个文件（覆盖原文件）bye：退出1ex编写 1ex.sh，利用 for 循环将当前目录下的.c 文件移动到指定的目录下，完成后显示指定目录下的文件内容，并按文件从小到大排序。(ll -r -S）2ex编写 2ex.sh，显示 Fibonacci 数列的前 10 项及其总和。3ex编写 ex3.sh，判断给定的参数是否是素数。4ex编写 ex4.sh，将给定的参数转换成二进制表示。5exex5.sh假设存在一个/homework的文件夹，其中包含一个 studentlist.csv的文件，当中存放了若干学生的学号，每个一行。例如：150341101、150341102、150341105、150341106，编写 ex11.sh。查看/homework 文件夹下学生是否提交了作业，假设作业名的格式为：学号_homework.txt。最后输出没提交作业的学号名单。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04-进程管理]]></title>
    <url>%2F2019%2F04-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[Linux的进程状态psProcess Status。查看进程状态的最常用的命令，它可以提供关于进程的许多信息。直接用ps命令可以列出每个与你的当前Shell有关的进程的基本信息。ps -ef：显示系统中所有进程的全面信息。-e：显示所有进程-f：全格式用户ID、进程ID、父进程ID、CPU占用率、开始时间、开始此进程的终端设备、此进程运行的总时间、命令名。ps aux显示所有终端上所有用户的有关进程的所有信息。终结进程通常来说，终结一个前台进程可以使用Ctrl+C。终结一个后台进程得使用kill命令。kill &lt;进程号&gt;。如果想强制杀掉一个进程需要使用-9：kill -9 &lt;进程号&gt;sleep使进程暂停由时间值所指定的秒数。此命令大多用于shell程序设计中，使两条命令执行之间停顿指定的时间。如：sleep 100; who | grep &#39;root&#39;。waitwait是用来阻塞当前进程的执行，直至指定的子进程执行结束后，才继续执行。wait [进程号 或 作业号]：eg：wait 23 or wait %1如果wait后面不带任何的进程号或作业号，那么wait会阻塞当前进程的执行，直至当前进程的所有子进程都执行结束后，才继续执行。fork()fork()函数会创建一个和原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事。但如果初始参数或者传入的变量不同，两个进程也可以做不同的事。一个进程调用fork()函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。fork()调用一次，分别向父子进程返回，它可能有三种不同的返回值：在父进程中，fork()返回新创建子进程的进程ID；在子进程中，fork()返回0；如果出现错误，fork()返回一个负值；所以我们可以通过fork返回的值来判断当前进程是子进程还是父进程。同时每个进程都有一个互不相同的进程标识符（process ID），可以通过getpid()函数获得，还有一个记录父进程pid的变量，可以通过getppid()函数获得变量的值。题1源代码运行结果分析程序运行到第7行，创建一个新的进程，克隆一份当前进程。向父进程返回子进程的pid，向子进程返回0。所以执行后父进程进入第3个分支，子进程进入第2个分支。题2源代码结果分析题3源代码结果分析题4题目分析执行第5行之后，向父进程返回真，向子进程返回假，但是没有任何影响，此时创建了一个进程，之后父子进程创建的进程个数相同，所以只分析一个再乘以2即可。第一个子进程分析结果如下图。注意，对于A &amp;&amp; B || C：表达式A为假，B不执行，C执行；表达式A为真，B执行：B为真：C不执行；B为假：C执行。所以答案是1+9*2=19个。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03-vim]]></title>
    <url>%2F2019%2F03-vim%2F</url>
    <content type="text"><![CDATA[vi &amp; vim这俩都是文本编辑器。vi是Linux默认的编辑器，类似于windows的记事本。vim是vi的拓展，比vi更强大。可以用于在Linux中编辑文件内容。笔记中使用vim。它有两种模式，命令模式和编辑模式，在命令模式中可以做一些检索、筛选等操作。在编辑模式中可以对文档进行修改。进入 &amp; 退出进入命令模式方法：vim &lt;文件名&gt;。此时进入命令模式，不能对文件内容进行操作。对文档的检索是在这种模式下进行的。进入编辑模式：i：编辑位置在当前光标位置之前按下i再按_I：在光标所在行的行首插入新增文本按下I再按_a：在该命令之后输入的字符都插到光标之后按下a再按_A：在光标所在行的行尾添加文本按下A再按_o：在光标所在行的下面新开辟一行，随后输入的文本就插入在这一行按下o再按_O：在光标所在行的上面新开辟一行，随后输入的文本就插入在这一行上按下O再按_r：替换光标所在的哪一个字符按下r再按_R：一直替换光标所在的文字，直到按下ESC为止按下R再按三次_再按Esc退出编辑模式在编辑模式下按 Esc 键。退出命令模式需要使用转义字符::q：若未修改文件，此命令可以退出编辑器。:wq：把编辑缓冲区的内容写入文件中，退出编辑器，回到Shell下。:ZZ或:x：仅当作过修改时才将缓冲区内容写到文件上。:q!： 强行退出vi。告诉vi，无条件退出，丢弃缓冲区内容。vim流程图命令模式下的光标跳转方向键和Backspace键的使用和正常情况下相同。移动到上一行，列不变：k移动到上一行行头：-移动到下一行，列不变：j移动到下一行行头：+如果在相应命令的前面加上一个数字n，相应命令执行n次。如2k表示向上移动两行，列不变。移至行首：^或0移至行尾：$移至指定行：行号G。如2G，移动到第二行行首。移至指定列：列号|。如2|，移动到本行第2列。文本删除命令x（小写字母）删除光标所在的字符。命令X（大写字母）删除光标前面的那个字符命令dd删除光标所在的整行命令D从光标位置开始删除到行尾d&lt;光标移动命令&gt;删除从光标位置开始至光标移动命令之间的所有字符。如：d0：从光标位置（不包括光标位）删至行首。d3l：从光标位置（包括光标位）向右删3个字符。d$：从光标位置（包括光标位）删至行尾。与D相同。d5G：将光标所在行至第5行都删除。复原命令u：取消前面刚执行的插入或删除命令的效果，恢复到此前的情况。U：总是把当前行恢复成它被编辑之前的状态。重复命令.：在命令模式下，重复执行前一次插入命令或删除命令补充文本编辑命令方式下d0：删至行首d$：删至行尾ndd：删除当前行及其后的n-1行yy：复制当前行的文本10yy：复制包括当前行及其后面9行文本p：在当前行后面插入一个空行，把缓冲区的内容粘贴过来P：在当前行前面插入一个空行，把缓冲区的内容粘贴过来ex转移方式下:n1,n2 d：将n1行到n2行的内容删除:n1,n2 co n3：将n1行到n2行的内容复制到n3行下:n1,n2 m n3：将n1行到n2行的内容移到n3行下字符串检索向下检索：/模式〈Enter〉。例如：/int向上检索：?模式〈Enter〉。例如：?flout字符串替换:n1,n2s/word1/word2/g：n1和n2为数字。在n1与n2行之间寻找word1这个字符串，并将该字符串替换为word2。例如:100,200s/a/A在100行到200行之间搜索a并替换成A。:1,$s/word1/word2/gc：全局搜索word1，替换成word2。g改成gc表示要用户确认。:%s/$/s2/g：在整个行的末尾添加s2。全局替换命令g：:g/模式/命令表。:g/s1/p：打印文本中有s1的行。p命令表示打印。块选择ctrl+v，然后使用方向键选择块。y：复制反白的地方d：将反白的地方删除掉p：插入复制的内容参考：https://jingyan.baidu.com/article/84b4f565c6b9e560f6da3291.html。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-Linux常用命令]]></title>
    <url>%2F2019%2F02-Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[输入终端窗口中的命令以Enter键结束，且Shell命令区分大小写。如果命令太长，一行放不下时，在行尾输入\并按Enter键。这时Shell会返回一个大于号（&gt;）作为提示符，表示该命令行尚未结束，允许继续输入有关信息。echoecho命令把命令行中的参数全部显示到标准输出（终端）中。如果参数用引号引起来，会按原样输出。否则会把各个单词按字符串输出，字符串之间用空格隔开。单引号/双引号的区别请看Shell那一部分。输出重定向Linux的标准输出是屏幕，把结果输出到指定的文件叫做输出重定向。&gt;：目标文件不存在，系统将建立该文件；文件存在，重定向将会删除该文件，并重新建立一个新文件存放结果。&gt;&gt;：目标文件不存在，系统将建立该文件；如果目标文件存在，新的输出结果将会追加到文件末尾。pwd显示出当前所在目录的路径。历史命令history命令可以看到用户所有曾经输入过的命令。!!：执行上一个命令；`!n：执行第n个命令；!-n：执行倒数第n个命令；!xxx：执行以xxx开头的命令，如之前使用过clear，!cle会执行clear。~/.bash_history文件中会存储你近期使用过的命令。查看此文件：cat ~/.bash_historydatedate命令在屏幕上显示或设置系统的日期和时间：date [+格式控制字符串]格式控制字符串常用单引号引起来。年:Y 月:m 日:d 小时:H 分:M 秒:S有且只有超级用户能设置或修改系统时钟，语法如下：date -s “year-month-day hour:minute:second”系统在启动的时候是从CMOS（用来存储计算机某些参数的芯片）中加载时钟，为了保持系统时间与CMOS时间的一致性，Linux每隔一段时间会将系统时间写入CMOS。由于该同步是每隔一段时间进行的，在我们执行date -s后，如果马上重起机器，修改时间就有可能没有被写入CMOS，而hwclock –w强制把系统时间写入CMOS。cal列出日历信息。单独一个cal：列出当前月的日历信息。cal xxxx：列出xxxx年的日历信息。cal yy xxxx：列出xxxx年yy月的日历信息。cal dd yy xxxx：列出xxxx年yy月xx日所在月的日历信息。clearclear命令清除屏幕上的信息，清屏后，提示符移到屏幕左上角。关机 &amp; 重启shutdown -h now：立刻关机shutdown -h 15:30：15:30 关机shutdown -h +30：30 分钟后关机reboot：重启shutdown -k +2 &quot;一会要关机，抓紧保存&quot;：向所有用户输出关机通知，但不做真正操作。+2表示通知的关机时间是现在之后的两分钟。帮助命令如果我们忘记某些命令或其参数如何使用，需要使用帮助命令。whatis &lt;命令&gt;：显示命令的简短描述。&lt;命令&gt; -help：显示使用方法概述和参数列表。man &lt;命令&gt;：为命令提供相关帮助文档，页面分成章节。info &lt;命令&gt;：类似man命令，但是通常比它更详细。切换路径命令cd &lt;位置&gt;：切换到指定位置；cd ~：切换到用户家目录；cd -：切换到上一个所在目录；passwd修改密码。单独的passwd：修改使用该命令的用户的密码。passwd 用户名：root用户可以使用该命令修改其他用户的密码。Linux用户登录Linux系统时，必须通过指定的用户名和密码进行登录。不过所有的用户在Linux眼中都是一个数字，用userid（一个32位的二进制整数）来表示。可以通过id命令，查看自己的userid。userid为0的表示根用户。同时，在系统运行的每个进程、所创建的每个文件都有一个userid，这个userid代表运行这个程序的用户，或者文件的所有者。Linux系统中，用户被保存在/etc/passwd文件中。用户又分成三类：一般用户（userid&gt;=500）、超级用户（userid=0）和系统用户（userid&lt;500）。查看用户Linux是一个多用户系统，即很多个用户同时操作一个设备中的资源，但不同的用户有不同的权限。这些用户中有一个是超级用户（root），它是权限最高的用户。root用户在终端中的输入命令以#开头，其他的用户以$开头。who：列出正在使用系统的所有用户、所用的终端名和注册到系统的时间。who am i：列出使用该命令的用户、所用的终端名和注册到系统的时间。用户组由于不同的用户有不同的权限。为了给不同的用户赋予相同的权限更加方便，诞生了用户组的概念。即同一个用户组里的人员可以有相同的某些权限。Linux中的用户或文件至少属于一个用户组。添加用户useradd或者adduser。执行后的具体操作（不同发行版有区别）：分配一个新的userid，数值等于之前所有userid中数值最大的加一。在/etc/passwd中添加一行。为用户在/home下建立一个新的目录（用户的家目录），目录名和用户名相同。在/etc/group中为用户建立一个新的个人组。在/var/spool/mail中创建用户的邮件文件。删除用户userdel &lt;用户&gt;。删除用户及部分相关信息，家目录和邮件文件还会存在。-r：包括家目录和邮件池等在内的所有用户信息都会被删除。添加/删除组groupadd &lt;组名&gt;。所有的组都保存在/etc/group文件中。groupdel &lt;组名&gt;。删除组。/etc/passwd &amp; /etc/shadow/etc/passwd有7列：用户名、密码、用户id、主要组id、备注信息、主目录、登录shell。各列之间使用:分割。同时密码一般都是x（被加密了），加密后的密码在/etc/shadow中。/etc/shadow有9列：用户名、加密密码、最近更改密码的日期、密码不可更改的天数、密码需要重新更改的天使、密码更改期限前的警告期限、密码过期的宽限时间、帐号失效日期、保留字段。但这里显示的密码是加密的。查看用户所属的组groups：查看使用此命令的用户所属组；groups &lt;用户&gt;：查看指定用户所属组。用户可多选，使用空格隔开。/etc/group &amp; /etc/gshadow/etc/group：组名、组密码、组id、组中附加用户。/etc/gshadow：组名、密码、组管理者、组中附加用户。为用户添加备注在创建的时候添加：useradd -c &lt;备注&gt; 用户名。创建后修改：usermod -c &lt;备注&gt; 用户名。（会清除之前的备注信息）。usermod改变用户某些属性的命令。-l：改变用户的名称；-G：改变用户支持的用户组，会退出原来的附属组，配合-a不会删除之前组；-L：不让该用户登录；-e：设定用户失效日期。日期格式：“YYYY-MM-DD”。-s：改变Shell。新创建的用户默认使用bash，此选项修改登录Shell。如：usermod -aG 组名 用户gpasswdgpasswd -d userName groupName：从组中删除用户切换用户超级用户输入su 用户名可以不用输入密码切换到其他用户。普通用户切换到其他所有用户（su 用户名）需要输入密码。文件系统操作系统中负责管理和存储文件信息的软件机构称为文件管理系统，简称文件系统。文件：文件系统中存储数据的一个命名的对象。即使是空文件（不包含用户数据）也会为操作系统提供其他信息。目录：包含文件项目的一类特殊文件。Linux中在应用层上来看目录和文件是被区分开来的。查找文件find &lt;路径&gt; -name &#39;正则表达式&#39;：如find . -name &#39;*.so&#39;，查找当前目录下以.so结尾的文件。catcat &lt;文件&gt;：显示文件的内容。文件可以多选，之间用空格隔开。cat f1 &gt; f2：把f1文件的内容合并到f2文件中。touch文件不存在：则创建一个空的新文件；文件存在：把文件的时间标签更新为系统当前时间。grep命令的意思：global search regular expression and print out the line。部分选项如下：-a：将 binary 文件以 text 文件的方式搜寻数据-c：计算找到 ‘搜寻字符串’ 的次数-i：忽略大小写的不同，所以大小写视为相同-n：顺便输出行号-v：反向选择，亦即显示出没有 ‘搜寻字符串’ 内容的那一行！--color=auto：可以将找到的关键词部分加上颜色的显示喔！举例如下：管道命令管道命令是用来过滤信息的，比如我们之前grep -n root /etc/passwd之后显示带有root的行，如果想在结果中再按其他条件过滤就要使用管道命令：“|”。统计文件信息wc：统计指定文件的字节数（-c）、字数（-w）、行数（-l）例子：统计文件a中以b开头的行数：cat a | grep ^b | wc -l创建目录mkdir &lt;文件名&gt;。-p：父目录不存在时也可以创建。删除文件/目录rm -rf &lt;文件名&gt;。-r表示递归删除；-f表示强制删除，不询问。列出文件ls命令列出指定目录的内容。-l：文件的详细信息。输出的信息分成多列，它们依次是：文件类型与权限、链接数、文件主、文件组、文件大小、建立或最近修改的时间、文件名。total的计算：https://yq.aliyun.com/ziliao/264744。-a：显示所有文件。之前显示的没有隐藏文件（以.开头）。-h：文件大小以人类可读的方式显示。需要配合-l使用。拷贝文件cp &lt;文件&gt; &lt;目录&gt;。剪切文件mv &lt;文件&gt; &lt;目录&gt;。修改文件名mv &lt;文件&gt; &lt;新文件名&gt;。文件结构Linux中所有的文件都由两部分构成。索引结点：包含此文件的信息，如文件权限、文件主、文件大小等。数据：文件的实际内容，有没有数据都可以。链接链接就是把文件名和计算机文件系统使用的节点号链接起来。因此我们可以用多个文件名与同一个文件进行链接，这些文件名可以在同一目录或不同目录。硬链接：硬链接是多一个文件名和inode结点关联。由于它依赖于inode，所以不能在不同的文件系统之间做硬链接。硬链接不能用于目录。用法：ln &lt;被链接的文件&gt; &lt;新的文件名&gt;软连接：软连接是再拓展出一份inode，这个inode指向的区域保存如何找到真正数据的信息。用法：ln -s &lt;被链接的文件&gt; &lt;新的文件名&gt;用户和权限文件主：文件所有者，并赋予唯一的注册名。只有文件主或root才有权利用chown命令改变文件的所有关系（UID）。用户组：通常，组中包含了有相同需求的用户。文件主或超级用户（root）可以利用chgrp命令改变文件的GID。用户存取权限：Linux系统中规定了4种不同类型的用户：文件主、同组用户、其他用户、超级用户。3种访问文件或目录的方式：r（读）、w（写）、 x（可执行或查找）。chmod只有文件主或超级用户root才有权用chmod命令改变文件或目录的存取权限。使用格式：chmod [选项] MODE 文件。MODE可多选，之间用,隔开。MODE：&lt;who&gt;&lt;操作符号&gt;&lt;权限&gt;。who：u——user、g——group、o——others、a——all（可叠加）。操作符号：+ 添加、- 取消、= 赋予；权限：r 读、w 写、x 执行。（可叠加）举例以绝对方式改变权限置为1表示有相应权限，置为0表示没有相应权限。例如：r w x r - x r - -1 1 1 1 0 1 1 0 0转换成十进制是754。chmod 754 aa和chmod u=rwx,g=rx,o=r aa一致。umask官方的解释是掩码，其实就是用户创建文件或目录后它们的默认权限。不过和chomd有区别的是它把有权限设置为0，没权限设置为1，而且umask命令显示的是八进制数字。我的umask显示的是0022，转换成二进制就是000 010 010，转换成权限就是rwx r-x r-x。所以创建的目录的默认权限就是这个。但是Linux不允许新创建的文件有可执行权限，所以创建的文件的默认权限是rw- r-- r--。chown改变某个文件或目录的所有者。chown &lt;用户&gt; &lt;文件&gt;/&lt;目录&gt;chgrp改变文件或目录所属的用户组。chgrp &lt;用户组&gt; &lt;文件&gt;/&lt;目录&gt;文件权限的理解可读（r）：浏览文件中的内容；可写（w）：修改文件中的内容；可执行（x）：将文件作为命令使用。目录权限的理解可读：只能查看到目录下的子目录名和文件名；可执行：可以访问目录中的文件，包括子目录；可写：要在目录下添加删除目录和文件，必须有可执行的权利。压缩 &amp; 打包 &amp; 解压缩tar -zcvf：打包压缩后的文件名 要打包压缩的文件（多个之间用space分开）z：调用gzip压缩命令进行压缩c：create，打包文件v：显示运行过程f：指定文件名tar -xvf xxx.tar.gz -C 位置x：extract，解包v：显示允许过程f：指定文件名别名我们可以使用ll代替ls -l。但是对于ls -a，系统并没有提供la命令，不过我们可以使用alias定义la。取消别名使用unalias 别名定时任务cron工具允许用户配置要定期运行的任务，通过配置crontab的文件可以指定要运行哪些作业以及何时运行。配置crontab文件使用命令crontab。命令由6个用空白分隔的字段组成：字段minutehourday of monthmonthday of weekcommand to run举例4516***date&gt;/tmp/date.txt范围0-590-231-311-120-7*corntab命令的参数：-e：编辑crontab的内容（会打开一个文件）；设置定期任务（16:45时把当前时间写入/tmp/date.txt文件中）：过一段时间之后查看/tmp文件夹：-u：只有root才能执行这个选项，帮助其他用户建立/删除crontab；-l：查看crontab的工作内容:-r：删除crontab的工作内容；成组命令被成组命令约束的命令被认为是一条命令。{ 命令; }：需要有空格和命令隔开，且命令后面需要“;”。不创建子进程。(命令)：不强制需要有空格和命令隔开，不强制需要“;”。创建子进程完成功能。例如下例把两条ls命令的值全部由管道输入给grep。sortsort lines of text files，将文本文件内容加以排序，以行为单位来排序，但不改变文件原始内容。默认排序规则：从第每行一个字符开始，依次按照ASCII码值进行比较。-n：按数字的大小排序，默认情况下把数字看成字符。-r：反转排序效果。uniq文件输出时，删除重复行或列。但如果重复的行不连续则不起作用。文件类型-：普通文件l：符号链接文件d：目录s：套接字文件（socket）b：块设备文件p：命名管道文件（pipe）c：字符设备文件ex1：用户管理在系统中添加三个用户：Blondie、Prince和Madonna他们都希望属于次要组musicBlondie要求在他的条目中添加特殊备注“heart of glass”Prince要求使用/bin/csh作为登录shellMadonna的使用期限为2020-12-1。Blondie决定加入摔跤俱乐部wrestle组。Prince要将他的用户名改为tafkap。Madonna开始对风水感兴趣，加入组fengshui，并要求将她的userid改为888。groupadd fengshuiusermod -a –G fengshui Madonnausermod –u 888 MadonnaPrince又要改名字了，我们觉得太麻烦，干脆锁住他的帐号。usermod –L PrinceBlondie最近表现不好，我们决定将他踢出去。userdel –r Blondie（想把该用户所有信息都一起删除可以使用-r）ex2：文件目录管理Ventura同时属于次要组governor和wrestle。Ventura撰写了自己的摔跤计划plans.txt，并将它放到目录/tmp下。Ventura希望将他的摔跤计划和用户Hogan以及其他摔跤组的成员共享，但他不希望组外的成员访问。用户Hogan想往用户Ventura的计划上添加内容，可以吗？怎么做？用户Hogan对他自己的贡献很满意，他希望将这个计划公开，让所有人都能读到这个文件，可以实现吗？不可以，只有root和文件主能修改文件访问权。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-Linux入门]]></title>
    <url>%2F2019%2F01-Linux%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Linux介绍Linux是一套免费使用和自由传播的操作系统。严格来讲，Linux这个词本身只表示Linux内核，但一般来说使用Linux内核的操作系统都被称为Linux。而不同的厂家使用相同的Linux内核所构建的操作系统叫做Linux发行版。常见的Linux发行版有Ubuntu、Centos、Debian等。这些发行版的使用方法大同小异。但Linux不仅限于使用在PC机上，移动端（安卓系统是由Linux改写而来）、路由器（只保留少许功能的Linux系统）等终端都在使用Linux。Linux安装虚拟机安装：blog.csdn.net/qq_38206090/article/details/82559358。双系统：笔者没有安装过，因为怕系统出问题导致文件损失。云服务器：云服务器系统配置Linux版本我认为是最简单的方式，所以以下实例均采用阿里云服务器。连接服务器工具SecureCRT：去 http://59.110.143.226/Sharing-Your-Story/ 搜索。Termius：https://www.microsoft.com/store/productId/9NK1GDVPX09V。推荐使用Termius，好看也好用。SecureCRT是破解版，Termius是免费使用。Linux目录结构Linux的目录结构是一个树形结构，树根是一个/。直接子目录包括root、home等。如我的阿里云服务器根目录：ShellShell是指“为使用者提供操作界面”的软件（命令解析器）。Shell翻译过来叫做“壳”，用来区别于“核”，也就是说它把底层的东西封装成命令，使用者键入命令就能得到相应的结果。比如上面的这张图中，我在根目录下输入ll命令，就在终端上给我显示根目录下的文件信息。也就是说Shell解析了我输入的ll命令，返回我想要的信息（根目录文件信息）。Bash命令Shell是命令解释器，自然会有不同的分类，就类比于同是循环结构，Java和Python却有不同的语法。但是Bash（Bourne-Again SHell）是Linux默认的Shell交互类型，也就是说在Linux中打开一个终端，就启动一个Bash进程。Bash命令格式格式：命令名 [选项] [参数1] [参数2] … 有如下特点：命令名必须是小写英文字母。一般格式中，方括号括起来的部分是可选选项。选项是对命令的特别定义，以“-”开始。一个命令可以使用多个选项且多个选项连接起来同样有效（部分发行版不支持）。如：ls -al和ls -a -l效果相同。命令正常执行后返回一个0表示执行成功，返回非0值表示执行过程出错。在终端上很难体现出来，但在shell脚本（后续会介绍）中可作为控制逻辑流程的一部分（用$?查看）。Bash举例查看内核版本号：uname -a:uname是命令名，-a是选项，这个命令没有参数。uname解释]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[opencv实现人脸识别、人脸打框、人脸剪切]]></title>
    <url>%2F2019%2Fopencv%E5%AE%9E%E7%8E%B0%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E3%80%81%E4%BA%BA%E8%84%B8%E6%89%93%E6%A1%86%E3%80%81%E4%BA%BA%E8%84%B8%E5%89%AA%E5%88%87%2F</url>
    <content type="text"><![CDATA[Opencv在各平台上的配置https://opencv-java-tutorials.readthedocs.io/en/latest/01-installing-opencv-for-java.html。测试图片人脸识别代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.Arrays;import java.util.List;import org.opencv.core.Core;import org.opencv.core.Mat;import org.opencv.core.MatOfRect;import org.opencv.core.Rect;import org.opencv.imgcodecs.Imgcodecs;import org.opencv.objdetect.CascadeClassifier;public class GetImgFace &#123; private static String classifier = "D:/opencv/sources/data/haarcascades/haarcascade_frontalface_default.xml"; static &#123; // 必须要加载Opencv的Library System.loadLibrary(Core.NATIVE_LIBRARY_NAME); &#125; public static void main(String[] args) &#123; //图片路径不能有中文... GetImgFace.getImgFace("C:\\Users\\ISJINHAO\\Desktop\\test.jpg"); &#125; public static List&lt;Rect&gt; getImgFace(String imgPath)&#123; /* * 加载分类器，选择已经训练好的opencv分类器，训练器路径：%OPENCV_HOME%/sources/data/haarcascades/ * 分类器包含眼睛，人脸，人体，微笑等等，其中对于仅仅识别人脸来说，最好的训练器是： * haarcascade_frontalface_default.xml * haarcascade_frontalface_alt.xml * haarcascade_frontalface_alt2.xml * */ // 分类器路径不要有中文... CascadeClassifier faceDetector = new CascadeClassifier(classifier); if (faceDetector.empty()) &#123; System.out.println("请选择正确的分类器！"); return null; &#125; // 创建Mat，Mat是用来保存图片信息的类。Imgcodecs是用来读取图片的工具类 Mat image = Imgcodecs.imread(imgPath); // 检测人脸，检测结果存在faceDetections中 MatOfRect faceDetections = new MatOfRect(); faceDetector.detectMultiScale(image, faceDetections); List&lt;Rect&gt; faceList = Arrays.asList(faceDetections.toArray()); System.out.println(faceList); return faceList; &#125; &#125;结果人脸打框代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import java.io.File;import java.util.Iterator;import java.util.List;import java.util.UUID;import org.opencv.core.Mat;import org.opencv.core.Point;import org.opencv.core.Rect;import org.opencv.core.Scalar;import org.opencv.imgcodecs.Imgcodecs;import org.opencv.imgproc.Imgproc;public class FaceRect &#123; public static void main(String[] args) &#123; String imgPath = "C:\\Users\\ISJINHAO\\Desktop\\test.jpg"; List&lt;Rect&gt; faceRects = GetImgFace.getImgFace(imgPath); //把识别出来的图片分别打框 Iterator&lt;Rect&gt; iterator1 = faceRects.iterator(); while(iterator1.hasNext()) &#123; Rect rect = iterator1.next(); FaceRect.imageMark(imgPath, "D:\\test\\" + UUID.randomUUID() + ".jpg", rect); &#125; //在一张图片中把所有识别出来的人脸都打框 Mat image = Imgcodecs.imread(imgPath); Iterator&lt;Rect&gt; iterator2 = faceRects.iterator(); while(iterator2.hasNext()) &#123; Rect rect = iterator2.next(); Imgproc.rectangle(image, new Point(rect.x, rect.y), // 左上点 new Point(rect.x + rect.width, rect.y + rect.height), // 右下点 new Scalar(0, 255, 0), 2); // 框的颜色和粗细 &#125; Imgcodecs.imwrite("D:\\test\\" + UUID.randomUUID() + ".jpg", image); &#125; public static File imageMark(String imagePath, String outFilePath, Rect rect) &#123; Mat image = Imgcodecs.imread(imagePath); // 原始图片 //Imgproc.rectangle的作用是在修改image中的数据，把相应的位置打上框 Imgproc.rectangle(image, new Point(rect.x, rect.y), // 左上点 new Point(rect.x + rect.width, rect.y + rect.height), // 右下点 new Scalar(0, 255, 0), 2); // 框的颜色和粗细 // 把mat写入图片 Imgcodecs.imwrite(outFilePath, image); return new File(outFilePath); &#125;&#125;结果人脸剪切代码1234567891011121314151617181920212223242526272829303132333435363738394041424344import java.io.File;import java.util.Iterator;import java.util.List;import java.util.UUID;import org.opencv.core.Mat;import org.opencv.core.Rect;import org.opencv.core.Size;import org.opencv.imgcodecs.Imgcodecs;import org.opencv.imgproc.Imgproc;public class FaceCut &#123; public static void main(String[] args) &#123; String imgPath = "C:\\Users\\ISJINHAO\\Desktop\\test.jpg"; List&lt;Rect&gt; faceRects = GetImgFace.getImgFace(imgPath); //把识别出来的图片分别打框 Iterator&lt;Rect&gt; iterator1 = faceRects.iterator(); while(iterator1.hasNext()) &#123; Rect rect = iterator1.next(); FaceCut.imageCut(imgPath, "D:\\test\\" + UUID.randomUUID() + ".jpg", rect); &#125; &#125; public static File imageCut(String imagePath, String outFilePath, Rect rect) &#123; Mat image = Imgcodecs.imread(imagePath); // 按照原始图片中的人脸提取出来 Mat sub = image.submat(rect); Mat mat = new Mat(); Size size = new Size(rect.width, rect.height); // 修改提取出来的人脸信息sub在坐标轴的位置。 Imgproc.resize(sub, mat, size); // 将截图保存 Imgcodecs.imwrite(outFilePath, mat); return new File(outFilePath); &#125;&#125;结果]]></content>
      <categories>
        <category>大学生创新创业项目</category>
      </categories>
      <tags>
        <tag>opencv</tag>
        <tag>人脸识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03-处理机调度]]></title>
    <url>%2F2019%2F03-%E5%A4%84%E7%90%86%E6%9C%BA%E8%B0%83%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[概述处理机调度是指通过对处理机资源进程的合理分配来提升系统资源的利用率、降低作业周转时间等。但是由于不同操作系统的目标不同，所以处理机调度的策略和目标也不相同。处理机调度的层次高级调度：又称作业调度或长程调度。它的主要功能是根据某种算法决定把外存上处于后备队列中的哪些作业调入内存，并为他们创建进程、分配资源等，然后放入就绪进程队列。主要用于批处理系统，分时系统的实时系统中不设置高级调度。低级调度：又称进程调度或断层调度。它的主要功能是根据某种算法决定让哪些就绪队列获得处理机，并由分配程序将处理机分配给被选中的进程。在批处理系统、实时系统和分时系统中都设置低级调度。中级调度：又称内存调度。它的主要功能是根据某种算法决定将哪些暂时不能运行的进程调至外存等待，当它们具备运行条件且内存又有空闲时再调入内存。这实际上是存储器管理中的对换功能，在下一章再展开介绍，处理机调度的目标共同目标：提升资源利用率：$CPU的利用率=\frac{CPU有效工作时间}{CPU有效工作时间+CPU空闲等待时间}​$。公平：每个进程都应获得合理的CPU时间，不发生进程饥饿现象。平衡：进程可以分成多个类型，如计算型、I/O型等等。平衡是指系统中不同的设备都能处于忙碌状态。策略强制执行：指某些强制型任务，比如安全策略等，即使会造成其他工作的延迟。批处理系统的目标：平均周转时间短：周转时间：从作业进入系统到作业完成退出系统所用的时间。平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NT_i]​$带权周转时间：作业的周转时间（$T​$）和系统为它提供服务的时间（$T_S​$）。$W=\frac{T}{T_s}​$平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NW_i]​$系统吞吐量高：单位时间内系统完成的作业数尽量多。处理机利用率高。分时系统的目标：响应时间快：指终端提交一个请求到主机返回结果至终端的时间短。均衡：不同请求的复杂度不同，所以响应时间必定不同，均衡是指响应时间应和请求复杂度相适应。实时系统的目标：截止时间的保证：对于HRT任务截止时间必须满足要求，SRT也要尽可能满足。可预测性：如在观看电影时一般都会连续播放帧，所以请求是可预测的，假如采用双缓冲实现第i帧和第i+1帧并行处理就能提高实时性。高级调度作业作业：比程序更为广泛的概念，不仅包含了通常的程序和数据，还有一份作业说明书。在批处理系统中，是以作业为基本单位从外存调入内存的。作业步：在作业运行期间，每个作业都必须经过若干个相对独立。又相互关联的顺序加工步骤才能得到结果。期中每一个加工步骤成为一个作业步。作业控制块Job Control Block，JCB。是作业在系统中存在的标志。保存了系统对作业进行管理和调度所需的全部信息。如：作业标识、用户名称、用户账号、作业类型（CPU繁忙型、I/O繁忙型、批量型、终端型等）、作业状态、调度信息（优先级、作业运行时间）、资源需求（预计运行时间、要求内存大小等）、已申请到资源的使用情况。作业运行的三个阶段收容阶段：每一个作业进入系统时（即输入到硬盘），便由“作业注册”程序为该作业建立一个作业控制块JCB并把它放入作业后备队列中。运行阶段：后备队列中的作业被选中后，系统会为其分配必要的资源和建立进程，然后将其放入就绪队列。一个作业从第一次进入就绪状态开始到它运行结束前都是处于运行阶段。完成阶段：当作业完成或发生异常而终止时，作业便处于完成阶段，此时系统会撤销进程和资源，并将运行结果通过某种方式输入，如输出到文件中。先来先服务算法First-Come First-served，FCFS。每次调度都是选择一个或多个最先进入队列的作业或进程，为它们分配资源，创建进程和分配CPU，使之投入运行。它是最简单的调度算法，同时也可用于进程调度。效率不高，所以一般不作为主调度算法。适用于CPU繁忙型而不适用于I/O繁忙型。因为CPU繁忙型长时间占用CPU很少有I/O操作，一旦获得CPU，就会运行很长时间，就是会长时间占用CPU，而I/O繁忙型由于要频繁访问IO端口，每次访问都要放弃CPU，等I/O访问完后要重新等待下一次调度（此时排到了就绪队列的队尾），所以要等待很久才能重新被调度。因此先来先服务有利于CPU繁忙型而不利于I/O繁忙型。短作业优先算法Short Job First，SJF。指对短作业优先调度的算法，它从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。此种算法对长作业非常不利而且实际使用上很难预估每个作业的运行时间。静态优先级调度算法为照顾紧迫性作业，使之进入系统后获得优先处理，引入优先级调度算法。按照进程的优先级大小来调度，使高优先级进程得到优先处理的策略称为优先权调度算法。静态优先级调度算法是指在输入前作业为其赋予优先级且一直保持不变。虽然可以照顾紧迫性作业，但是没有考虑到作业本身的运行时间和作业的等待时间等，所以产生了更好的动态优先级算法。高响应比算法高响应比算法是动态优先级算法的一种，其中$优先级 = \frac{响应时间}{要求服务时间} = \frac{等待时间+要求服务时间}{要求服务时间}$。这样可以得到：对于短作业：其要求服务时间短，优先级相对较高。对于长作业：在等待一段时间之后，其优先级会增长，直至够高而能获得服务。对于先来作业：加入在某一时刻其仍未获得服务，和后来的作业相比其优先级相对较高。相应时间与周转时间的对比，假如作业运行完了，两者相等，假如没有则 $响应时间&lt;周转时间$周转时间：从作业进入系统到作业完成退出系统所用的时间。响应时间：等待时间+要求服务时间。低级调度进程调度的任务和机制保存处理机的现场信息：比如程序计数器、通用寄存器里的内容。按某种算法选取进程。把处理机分配给进程：把选中进程的PCB中的有关处理机调度的信息装入处理器的寄存器中，把处理器的控制权交给进程使其能从上次的断点处恢复运行。进程调度机制排队器：每当有进程转入就绪状态时分派器：上下文切换器：]]></content>
  </entry>
  <entry>
    <title><![CDATA[仅使用Servlet3实现文件上传下载]]></title>
    <url>%2F2019%2F%E4%BB%85%E4%BD%BF%E7%94%A8Servlet3%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[上传文件的html界面123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset="UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;单文件上传&lt;/h2&gt; &lt;form action="/servlet3-upload-and-download/uploadone" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file"&gt; &lt;input type="submit" name="upload"&gt; &lt;/form&gt; &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;h2&gt;多文件上传&lt;/h2&gt; &lt;form action="/servlet3-upload-and-download/uploadmany" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="file1"&gt; &lt;input type="file" name="file2"&gt; &lt;input type="submit" name="upload"&gt; &lt;/form&gt; &lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt;&lt;br/&gt; &lt;h2&gt;文件下载&lt;/h2&gt; &lt;a href="/servlet3-upload-and-download/download"&gt;点击下载&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;下载1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package download;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;@WebServlet("/download")public class download extends HttpServlet&#123; private static final long serialVersionUID = 1L; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; resp.setContentType("text/html;charset=utf-8"); //filepath String filePath = "D:\\我.jpg"; try( BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath)); BufferedOutputStream bos = new BufferedOutputStream(resp.getOutputStream()); ) &#123; long fileLength = new File(filePath).length(); resp.setHeader("Content-disposition", "attachment; filename=" + new String(new File(filePath).getName().getBytes("utf-8"), "ISO8859-1")); resp.setHeader("Content-Length", String.valueOf(fileLength)); byte[] buff = new byte[2048]; int bytesRead; while (-1 != (bytesRead = bis.read(buff, 0, buff.length))) &#123; bos.write(buff, 0, bytesRead); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125; &#125;上传单文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package upload;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.MultipartConfig;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.Part;@WebServlet("/uploadone")@MultipartConfig //Servlet3中处理multipart/form-data类型请求的注解public class UploadOne extends HttpServlet&#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; this.doPost(request, response); &#125; protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; //说明输入的请求信息采用UTF-8编码方式 request.setCharacterEncoding("utf-8"); response.setContentType("text/html; charset=UTF-8"); PrintWriter out = response.getWriter(); //Servlet3.0中新引入的方法，用来处理multipart/form-data类型编码的表单 Part part = request.getPart("file"); //获取HTTP头信息headerInfo=（form-data; name="file" filename="文件名"） String headerInfo = part.getHeader("content-disposition"); System.out.println("headinfo ==&gt; " + headerInfo); //从HTTP头信息中获取文件名fileName=（文件名） String fileName = headerInfo.substring(headerInfo.lastIndexOf("=") + 2, headerInfo.length() - 1); //获得存储上传文件的文件夹路径 String fileSavingFolder = this.getServletContext().getRealPath("/upload"); //获得存储上传文件的完整路径（文件夹路径+文件名） //文件夹位置固定，文件夹采用与上传文件的原始名字相同 String fileSavingPath = fileSavingFolder + File.separator + fileName; System.out.println("filePath ==&gt; " + fileSavingPath); //如果存储上传文件的文件夹不存在，则创建文件夹 File f = new File(fileSavingFolder + File.separator); if(!f.exists())&#123; f.mkdirs(); &#125; //将上传的文件内容写入服务器文件中 part.write(fileSavingPath); //输出上传成功信息 out.println("文件上传成功~！"); &#125;&#125;多文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package upload;import java.io.File;import java.io.IOException;import java.io.PrintWriter;import java.util.Collection;import java.util.Iterator;import javax.servlet.ServletException;import javax.servlet.annotation.MultipartConfig;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import javax.servlet.http.Part;@WebServlet("/uploadmany")@MultipartConfig //Servlet3中处理multipart/form-data类型请求的注解public class UploadMany extends HttpServlet&#123; private static final long serialVersionUID = 1L; protected void doGet(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; this.doPost(request, response); &#125; protected void doPost(HttpServletRequest request,HttpServletResponse response) throws ServletException,IOException&#123; //说明输入的请求信息采用UTF-8编码方式 request.setCharacterEncoding("utf-8"); response.setContentType("text/html; charset=UTF-8"); PrintWriter out = response.getWriter(); //Servlet3.0中新引入的方法，用来处理multipart/form-data类型编码的表单 Collection&lt;Part&gt; parts = request.getParts(); Iterator&lt;Part&gt; iterator = parts.iterator(); //获得存储上传文件的文件夹路径 String fileSavingFolder = this.getServletContext().getRealPath("/upload"); while(iterator.hasNext()) &#123; Part next = iterator.next(); //获得文件大小 long size = next.getSize(); System.out.println(size); //获取HTTP头信息headerInfo=（form-data; name="file" filename="文件名"） String headerInfo = next.getHeader("content-disposition"); System.out.println("headinfo ==&gt; " + headerInfo); //从HTTP头信息中获取文件名fileName=（文件名） String fileName = headerInfo.substring(headerInfo.lastIndexOf("=") + 2, headerInfo.length() - 1); //获得存储上传文件的完整路径（文件夹路径+文件名） //文件夹位置固定，文件夹采用与上传文件的原始名字相同 String fileSavingPath = fileSavingFolder + File.separator + fileName; System.out.println("filePath ==&gt; " + fileSavingPath); //如果存储上传文件的文件夹不存在，则创建文件夹 File f = new File(fileSavingFolder + File.separator); if(!f.exists())&#123; f.mkdirs(); &#125; //将上传的文件内容写入服务器文件中 next.write(fileSavingPath); &#125; //输出上传成功信息 out.println("文件上传成功~！"); &#125;&#125;demo下载：https://github.com/isjinhao/servlet3-upload-and-download。]]></content>
      <categories>
        <category>Java Web</category>
      </categories>
      <tags>
        <tag>servlet3</tag>
        <tag>文件上传</tag>
        <tag>文件下载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Face++人脸识别系统项目结构]]></title>
    <url>%2F2019%2F%E5%9F%BA%E4%BA%8EFacepp%E4%BA%BA%E8%84%B8%E8%AF%86%E5%88%AB%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[要求AngularJS+Bootstrap3+SSM+Opencv+Face++开发一套人脸签到系统，使用电脑摄像头获取人脸并进行签到。识别方式验证方式：人脸图片+保存人脸至服务器+到场离场时间。到场离场时间：第一次截取到的人脸是到场，最后一次截取到的人脸是离场。人脸图片、保存至服务器：使用Opencv 识别图片中的人脸得到所有的Rect，一个人脸在图片中的位置会储存在一个Rect（x轴、y轴、width、height）对象中。然后循环以下做法：剪切出每个Rect在图片中对应的子图片，调用Face++的接口搜索与子图片最相近的一个人，如果最相近的人置信度 &gt;= 80，认为是同一个人，复制一份原图片，然后把Rect对应的位置画上框，保存在指定文件夹（每个活动有唯一的存储文件夹）下，如果置信度 &lt; 80，处理下一个Rect。上传方式：客户端一秒截一张图上传。实体 &amp; 表结构组织创建活动，学生参与活动。活动分为两种，使用组的和不使用组的。使用组的应用场景是教学班签到，教学班的人数是固定的，不属于教学班的人即使识别成功也不算为签到。不使用组的应用场景是社团活动签到，只要识别成功，就算为签到。组织功能组织注册发布活动查看组信息查看举办的活动信息：查看每场活动用户：录入和导出记录签到用户用户注册###用户查看签到用户查看组管理员]]></content>
      <categories>
        <category>大学生创新创业项目</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>Face++</tag>
        <tag>Opencv</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown数学公式]]></title>
    <url>%2F2019%2Fmarkdown%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[符号代码符号代码$\sum$\sum$\sum_{i=0}^n$\sum_{i=0}^n$\pm$\pm$\div$\div$\cdot$\cdot$\times$\times$\mid$\mid$\circ$\circ$\ast$\ast$\bigotimes$\bigotimes$\bigoplus$\bigoplus$\leq$\leq$\geq$\geq$\neq$\neq$\approx$\approx$\prod$\prod$\coprod$\coprod$\cdots$\cdots$\int$\int$\iint$\iint$\oint$\oint$\infty$\infty$\nabla$\nabla$\because$\because$\therefore$\therefore$\forall$\forall$\exists$\exists$\not=$\not=$\not&gt;$\not&gt;$\leq$\leq$\geq$\geq$\not\subset$\not\subset$\emptyset$\emptyset$\in$\in$\notin$\notin$\subset$\subset$\subseteq$\subseteq$\bigcup$\bigcup$\bigcap$\bigcap$\bigvee$\bigvee$\bigwedge$\bigwedge$\biguplus$\biguplus$\bigsqcup$\bigsqcup$\hat{y}$\hat{y}$\check{y}$\check{y}$\breve{y}$\breve{y}$\overline{a+b+c+d}$\overline{a+b+c+d}$\underline{a+b+c+d}$\underline{a+b+c+d}$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$\overbrace{a+\underbrace{b+c}_{1.0}+d}^{2.0}$\uparrow$\uparrow$\downarrow$\downarrow$\Uparrow$\Uparrow$\Downarrow$\Downarrow$\rightarrow$\rightarrow$\leftarrow$\leftarrow$\Rightarrow$\Rightarrow$\Longleftarrow$\Longleftarrow$\longleftarrow$\longleftarrow$\longrightarrow$\longrightarrow$\Longrightarrow$\Longrightarrow$\alpha$\alpha$\beta$\beta$\gamma$\gamma$\Gamma$\Gamma$\delta$\delta$\Delta$\Delta$\epsilon$\epsilon$\varepsilon$\varepsilon$\zeta$\zeta$\eta$\eta$\theta$\theta$\Theta$\Theta$\vartheta$\vartheta$\iota$\iota$\pi$\pi$\phi$\phi$\Phi$\Phi$\psi$\psi$\Psi$\Psi$\omega$\omega$\Omega$\Omega$\chi$\chi$\rho$\rho$\omicron$\omicron$\sigma$\sigma$\Sigma$\Sigma$\nu$\nu$\xi$\xi$\tau$\tau$\lambda$\lambda$\Lambda$\Lambda$\mu$\mu$\partial$\partial$\lbrace$\lbrace$\rbrace$\rbrace$\overline{a}$\overline{a}$\frac{7x+5}{1+y^2}$\frac{7x+5}{1+y^2}$\int ^2_3 x^2 {\rm d}x$\int ^2_3 x^2 {\rm d}x$\sqrt[n]{3}$\sqrt[n]{3}$\vec{a} \cdot \vec{b}=0$\vec{a} \cdot \vec{b}=0$\iiint$\iiint$\oint$\oint$\lim$\lim$\infty$\infty$\partial$\partial$\ln15$\ln15$\log_2^{10}$\log_2^{10}]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
        <tag>Latex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-语言及其文法]]></title>
    <url>%2F2019%2F02-%E8%AF%AD%E8%A8%80%E5%8F%8A%E5%85%B6%E6%96%87%E6%B3%95%2F</url>
    <content type="text"><![CDATA[字母表字母表（$\sum​$）是一个有穷符号集合，符号包括字母、数字、标点符号、…。例如，二进制字母表：{0,1}、ASCII字符集，Unicode字符集等。字母表上的运算乘积运算：$\sum_{1} \sum_{2} = \lbrace{ab | a \in \sum_{1}, b \in \sum_{2} \rbrace}​$例： $\lbrace0 , 1\rbrace \lbrace a, b \rbrace = \lbrace 0a, 0b, 1a, 1b \rbrace$幂运算字母表的n次幂：长度为n的符号串构成的集合$\sum_{}^0 = \lbrace \varepsilon \rbrace​$$\sum_{}^n = \sum_{}^{n-1}\sum_{} n \geq 1$${\lbrace 0, 1 \rbrace}^3 = \lbrace0, 1\rbrace \lbrace0, 1\rbrace \lbrace0, 1\rbrace = \lbrace000, 001, 010, 011, 100, 101, 110, 111\rbrace$正闭包运算字母表的正闭包：长度正数的符号串构成的集合$\sum_{}^+ = \sum_{}^1 \bigcup \sum_{}^2 \bigcup \sum_{}^3 \bigcup \cdots​$克林闭包运算字母表的克林闭包：任意符号串（长度可以为零）构成的集合$\sum_{}^* = \sum_{}^0 \bigcup \sum_{}^1 \bigcup \sum_{}^2 \bigcup \sum_{}^3 \bigcup \cdots$串设$\sum_{}​$是一个字母表，$\forall x \in \sum_{}^*​$，$x​$称为是$\sum_{}​$上的一个串。串是字母表中符号的一个有穷序列。串$s$的长度，通常记作$|s|$，是指$s$中符号的个数。例：$|aab|$=3。空串是长度为0的串，用 $ \varepsilon$表示$|\varepsilon|= 0$串上的运算连接如果$x$和$y$是串，那么$x$和$y$的连接（concatenation）是把$y$附加到$x$后面而形成的串，记作$xy$。例如，如果$x=dog$且$y=house$，那么$xy=doghouse$空串是连接运算的单位元（identity），即，对于任何串$s$都有，$εs = sε = s$。设$x$, $y$, $z$是三个字符串，如果$x=yz$，则称$y$是$x$的前缀，$z$是$x​$的后缀。幂串s的n次幂：将$n$个$s$连接起来$s^0 = \varepsilon$，$s^n = s^{n-1}s, n \geq 1​$如果 $s = ba$，那么$s^1= ba$，$s^2=baba$，$s^3=bababa$，…文法的定义文法的直观概念当人们表述一门语言时，无非是说明这种语言的句子，如果语言只含有有穷多个句子，则只需要列出句子的有穷集就行。但对于含有无穷多个句子的语言来讲，采用的做法是给出一些规则，符合规则的句子是语言的一个句子。我们以简化版的汉语（句子的结构只有主谓结构）规则来说明：其中用尖括号括起来的部分称为语法成分，未用尖括号括起来的部分称为语言的基本符号。文法的形式化定义定义：$G=(V_{T}, V_{N}, P, S)$，$V_{T}$：终结符集合。文法所定义的语言的基本符号，也称为token。终结是指其不能再被改变。$V_{N}​$：非终结符集合。用来表示语法成分的符号，也称为”语法变量“。非终结指可以由他们推导出句子。$V_{T} \bigcap V_{N} = \phi​$。$V_{T}\bigcup V_{N}$：文法符号集。P：产生式集合：描述了将终结符和非终结符组合成串的方法，产生式的一般形式：$\alpha \rightarrow \beta​$。$α∈(V_T∪V_N)^*​$，且$\alpha​$中至少包含$V_N​$中的一个元素。称为产生式的头（head）或左部（left side）。${\beta \in (V_T \bigcup V_N)}^*​$，称为产生式的体（body）或右部（right side）。S：开始符号。$S\in V_N​$。开始符号（start symbol）表示的是该文法中最大的语法成分。例：$S = &lt;句子&gt;​$举例$G = ( \lbrace id, +, *, (, ) \rbrace, \lbrace E \rbrace, P, E )$ &nbsp; $P =\lbrace E \rightarrow E + E , E \rightarrow E \ast E, E \rightarrow ( E ), E \rightarrow id \rbrace $产生式的简写对一组有相同左部的 $\alpha$ 产生式$\alpha \rightarrow \beta_1,\alpha \rightarrow \beta_2 , … , \alpha \rightarrow \beta_n$。可以简记为：$\alpha \rightarrow \beta_1 | \beta_2 | , … , | \beta_n​$。符号约定终结符：字母表中排在前面的小写字母，如 a、b、c；运算符，如 +、*等；标点符号，如括号、逗号等；数字0、1、. . . 、9；粗体字符串，如id、if等；非终结符：字母表中排在前面的大写字母，如A、B、 C；字母S。通常表示开始符号；小写、斜体的名字，如 expr、stmt等；代表程序构造的大写字母。如E（表达式）、T（项）和F（因子）；文法符号（即终结符或非终结符）：字母表中排在后面的大写字母（如X、Y、Z）终结符号串：字母表中排在后面的小写字母（主要是u、v、. . . 、z）。包括空串。文法符号串：小写希腊字母，如α、β、γ，表示。包括空串。开始符号：除非特别说明，第一个产生式的左部。语言的定义推导 （Derivations）给定文法$G=(V_T , V_N , P , S )$，如果 $\alpha→\beta \in P$，那么可以将符号串$\gamma \alpha \delta$中的$ \alpha$替换为$\beta$，也就是说，将$\gamma \alpha \delta$重写为$\gamma \beta \delta$，记作 $\gamma \alpha \delta \Rightarrow \gamma \beta \delta$γ。此时，称文法中的符号串 $\gamma \alpha \delta$ 直接推导（directly derive）出$\gamma \beta \delta$。简而言之，就是用产生式的右部替换产生式的左部。如果$\alpha_0 \Rightarrow \alpha_1, \alpha_1 \Rightarrow \alpha_2, \cdots, \alpha_{n-1} \Rightarrow \alpha_{n}​$。则称符号串$\alpha_0​$经过$n​$步推导出$\alpha_n​$，可简记为$\alpha_0 \Rightarrow^n \alpha_n​$。$\alpha \Rightarrow^0 \alpha$；$\Rightarrow^+​$表示“经过正数步推导”；$\Rightarrow^*$表示“经过若干（可以是0）步推导。归约（Reductions）规约是推导的逆过程。句型如果$S \Rightarrow^\ast \alpha $，$ \alpha \in (V_T \bigcup V_N)^\ast $，则称$ \alpha $是G的一个句型（sentential form）。一个句型中既可以包含终结符，又可以包含非终结符，也可能是空串。如果$S \Rightarrow^\ast \omega $，$\omega \in V_T\ast$，则称$ \omega $ 是G的一个句子（sentence）。句子是不包含非终结符的句型。语言的形式化定义由文法$G$的开始符号$S$推导出的所有句子构成的集合称为文法$G$生成的语言，记为$L(G )$。即：$L(G)= \lbrace \omega \Rightarrow^\ast \omega \rbrace, \omega \in {V_T}^\ast$。例字母数字串的文法（T）：$T \rightarrow L | D | TL | TD​$$L \rightarrow a | b | c | \cdots | z​$$ D \rightarrow 0 | 1 | 2 | 3 | \cdots | 9​$标识符的文法（S）：和T区别的是S必须以字母或_开头。$ S \rightarrow L | LT​$$T \rightarrow L | D | TL | TD​$$ L \rightarrow a \mid b \mid c \mid \cdots \mid z \mid _ ​$$ D \rightarrow 0 | 1 | 2 | 3 | \cdots | 9​$无符号整数（S）：$S \rightarrow SN ​$$S\rightarrow \varepsilon​$$N \rightarrow 0|1|\cdots|9​$浮点数（T）：$S \rightarrow STN | SN $$S\rightarrow \varepsilon​$$ T \rightarrow .$$N \rightarrow 0|1|\cdots|9​$语言上的运算例：令$L=\lbrace A, B, \cdots Z, a, b, \cdots, z\rbrace$，$D=\lbrace 0, 1, \cdots, 9\rbrace$。则$L(L\bigcap D)^*$表示的语言是标识符。文法的分类Chomsky（形式语言的建立者）把文法分成四类，0型、1型、2型和3型。区别在于在不同文法的产生式上施加的限制不同。0型文法被叫做，无限制文法（Unrestricted Grammar）或 短语结构文法（Phrase Structure Grammar, PSG）。$\forall α \rightarrow \beta \in P​$，$\alpha, \beta \in {(V_N \bigcup V_T)}^\ast​$，且$\alpha​$中至少包含1个非终结符（即$\mid \alpha \mid \geq 1​$）。1型文法被叫做，上下文有关文法（Context-Sensitive Grammar , CSG）。$\forall \alpha \rightarrow \beta \in P，\mid \alpha \mid \leq \mid \beta \mid ​$。产生式的一般形式：$ \alpha_1 A \alpha_2 \rightarrow \alpha_1 \beta \alpha_2$ （$ \alpha_1, \alpha_2, \beta \in (V_N \bigcup V_T)^\ast$且$\beta \ne \varepsilon$）。和0型文法相比，0型文法要求$\mid \alpha \mid \geq 1​$，1型文法要求$1 \leq \mid \alpha \mid \leq \mid \beta \mid ​$。2型文法被叫做，上下文无关文法（Context-Free Grammar, CFG）$\forall \alpha \rightarrow \beta \in P$ （$\alpha \in V_N, \beta \in {(V_N \bigcup V_T)}^\ast$）。产生式的一般形式：$A \rightarrow \beta$。和1型文法相比，当1型文法的$\alpha_1, \alpha_2 \rightarrow \varepsilon$且$ \alpha $只属于非终结符集时，就是2型文法。3型文法被叫做，正则文法（Regular Grammar, RG），分为右线性文法和左线性文法。右线性（Right Linear）文法： $A \rightarrow a B$ 或 $A \rightarrow a $（$a \in {V_T}^ \ast$）左线性（Left Linear）文法： $A \rightarrow B a $ 或 $A \rightarrow a $（$a \in {V_T}^ \ast$）和2型文法相比，3型文法右侧形式必须是非终结符+终结符、终结符+非终结符、终结符三种之一。三种文法的区别参考：https://blog.csdn.net/cjsy_2011/article/details/32412967。1型文法式子左边可以有多个字符，但必须有一个终结符式子右边可以有多个字符，可以是终结符，也可以是非终结符，但必须是有限个字符2型文法式子左边只能有一个字符，而且必须是非终结符式子右边可以有多个字符，可以是终结符，也可以是非终结符，8但必须是有限个字符3型文法式子左边只能有一个字符，而且必须是非终结符式子右边最多有二个字符，而且如果有二个字符必须是一个终结符和一个非终结符，如果只有一个字符，那么必须是终结符左线性文法：式子右边的产生是（非终结符+终结符）的格式右线型文法：式子右边的产生式是（终结符+非终结符）的格式式子右边的格式一定要一致，也就是说如果有一个是（终结符+非终结符）那么所有的式子都必须是（终结符+非终结符）。如果有一个是（非终结符+终结符），那么所有的式子都必须是（非终结符+终结符）右线性文法、左线性文法举例右线性文法S → a | b | c | dS → aT | bT | cT | dTT → a | b | c | d | 0 | 1 | 2 | 3 | 4 | 5T → aT | bT | cT | dT | 0T | 1T | 2T | 3T | 4T | 5T左线性文法R → Ra | Rb | Rc | Rd | R0 | R1 | R2 | R3 | R4 | R5R → a | b | c | d文法S和R都是标识符。CFG 的分析树上下文无关文法有足够的能力描述当今程序设计语言结构，所以以下分析CFG的分析树。根节点的标号为文法开始符号。内部结点表示对一个产生式A→β的应用，该结点的标号是此产生式左部A 。该结点的子结点的标号从左到右构成了产生式的右部β。叶结点的标号既可以是非终结符，也可以是终结符。从左到右排列叶节点得到的符号串称为是这棵树的产出（ yield）或边缘（frontier）。(句型的）短语给定一个句型，其分析树中的每一棵子树的边缘称为该句型的一个短语（phrase）。如果子树只有父子两代结点，那么这棵子树的边缘称为该句型的一个直接短语（immediate phrase）。二义性文法如果一个文法可以为某个句子生成多棵分析树，则称这个文法是二义性的。二义性文法的判定对于任意一个上下文无关文法，不存在一个算法，判定它是无二义性的；但能给出一组充分条件，满足这组充分条件的文法是无二义性的。满足，肯定无二义性不满足，也未必就是有二义性的]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-编译原理绪论]]></title>
    <url>%2F2019%2F01-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[计算机程序设计语言及编译机器语言可以被计算机直接理解，如：C706 0000 0002（16进制）。与人类表达习惯相去甚远、难记忆、难编写、难阅读、易写错。汇编语言引入助记符，如MOV X, 2。依赖于特定机器，非计算机专业人员使用受限制、编写效率依然很低。高级语言类似于数学定义或自然语言的简洁形式，如x = 2。接近人类表达习惯、不依赖于特定机器、编写效率高。编译将高级语言翻译成汇编语言或机器语言的过程。编译器在语言处理系统中的位置预处理器把存储在不同文件中的源程序聚合在一起。把被称为宏的缩写语句转换为原始语句。链接器将多个可重定位的机器代码文件（包括库文件）连接到一起。解决外部内存地址（一个文件中的代码会引用其他文件中的数据对象或过程，这些数据对象或过程的地址对于此文件来说就是外部地址）问题。加载器确定程序在内中的绝对地址（即修改程序起始地址），将修改后的指令和数据放到内存中适当的位置。编译系统的结构词法分析/扫描(Scanning)从左向右逐行扫描源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词转换成统一的机内表示，即词法单元（token）形式。token格式：&lt; 种别码, 属性值&gt;一词一码：可以枚举的单词，比如关键字和运算符。使用token的种别码确定。多词一码：不能枚举的单词，比如变量名，使用token的种别码标识出是变量，属性值标识变量名称。一型一码：不能枚举但能被分类的单词，比如数据类型和运算符类别，使用token的种别码标识类型，属性值标识值。举例语法分析语法分析器（parser）从词法分析器输出的token序列中识别出各类短语，并构造语法分析树（parse tree）。语法分析树描述了句子的语法结构。赋值语句分析树变量声明语句的分析树语义分析收集标识符的属性信息：种属：简单变量、复合变量（数组，记录…）、过程、…类型：整型、实型（浮点型）、字符型、布尔型、指针型、…存储位置、长度：变量的值过程的作用域过程的参数和返回值信息符号表字符串表的作用：高级语言中一般不限制标识符长度，故name字段的长度不便预先固定，将标识符的字面值单独放在字符串表中，其位置索引放在name字段中，可保证name长度固定，由此带来存储效率高，查询方便等优点。此外，在语义分析中标识符的值很少被使用，这样就只用读取标识符的id，不用频繁读取标识符本身。语义检查变量或过程未经声明就使用变量或过程名重复声明运算分量类型不匹配，如String类型 + int类型操作符与操作数之间的类型不匹配数组下标不是整数对非数组变量使用数组访问操作符对非过程名使用过程调用操作符过程调用的参数类型或数目不匹配函数返回类型有误中间代码生成常见的中间表示形式语法结构树/语法树 (Syntax Trees)注意不是语法分析树，第八章介绍…三地址码 (Three-address Code)三地址码由类似于汇编语言的指令序列组成，每个指令最多有三个操作数(operand)。常用的三地址指令三地址指令的表示四元式 (Quadruples)：(op, y, z, x)三元式 (Triples)以后再说…间接三元式 (Indirect triples)以后再说…中间代码生成的例子代码优化为改进代码所进行的等价程序变换，使其运行得更快一些、占用空间更少一些，或者二者兼顾。目标代码生成目标代码生成以源程序的中间表示形式作为输入，并把它映射到目标语言目标代码生成的一个重要任务是为程序中使用的变量合理分配。]]></content>
      <categories>
        <category>编译原理</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-Spring入门]]></title>
    <url>%2F2019%2F01-Spring%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Spring - 概述（00）Spring概述Spring是一个一站式框架。它为Java EE开发的三层架构中每一层都提供了解决方案Web层：Spring MVC；Service层：Spring的Bean管理，Spring声明式事务；DAO层：Spring的JDBC模板，Spring的ORM模块。（后期会用Mybatis替换Spring的DAO层）Spring下载Spring现在是在github上托管的开源项目：地址。Spring各版本下载：地址。Spring环境搭建我的Spring文集中使用的是Spring 4.2版本，下方这张图是Spring官方给的架构图，想运行Spring项目，必须得导入Core Container中的包，但是也需要日志包。## Spring初体验123public interface UserDao &#123; public void save();&#125;12345public class UserDaoImpl implements UserDao&#123; public void save() &#123; System.out.println("UserService执行了..."); &#125;&#125;123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:p="http://www.springframework.org/schema/p" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- Spring的入门的配置==================== --&gt; &lt;bean name="userDao" class="com.isjinhao.Demo1.UserDaoImpl" &gt;&lt;/bean&gt; &lt;/beans&gt;12345678910111213141516171819import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; //传统方法的获得UserDao对象 @org.junit.Test public void test1() &#123; UserDao dao = new UserDaoImpl(); dao.save(); &#125; //通过Spring获得UserDao对象 @org.junit.Test public void test2() &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao bean = (UserDao)applicationContext.getBean("userDao"); bean.save(); &#125;&#125;开发的一个规则是在后期维护的时候少修改源代码。如果没有Spring我们更换UserDao的实现类，比如更换为UserMybatisDaoImpl，我们在源代码中就要改为UserDao dao = new UserMybatisDaoImpl();。但有了Spring之后就只需要修改配置文件中的class为xxx.UserMybatisDaoImpl，被Spring管理的类叫做bean。## DI（Dependency Injection）### 依赖关系1234567Class A&#123; &#125;Class B&#123; A a; public void xxx()&#123; &#125;&#125;如果在类B中使用到了类A，就说类B依赖类A，上图就是其中一种情况。### Spring解决依赖123public interface UserDao &#123; public void save();&#125;123456789101112public class UserDaoImpl implements UserDao&#123; private String name; public void save() &#123; System.out.println("UserService执行了..." + name); &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125;&#125;1234567891011121314&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:p="http://www.springframework.org/schema/p" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- Spring的入门的配置==================== --&gt; &lt;bean name="userDao" class="com.isjinhao.Demo1.UserDaoImpl"&gt; &lt;property name="name" value="isjinhao" /&gt; //name的值和属性名称相同 &lt;/bean&gt; &lt;/beans&gt;1234567891011import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Test &#123; //通过Spring获得UserDao对象 @org.junit.Test public void test2() &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml"); UserDao dao = (UserDao)applicationContext.getBean("userDao"); dao.save(); &#125;&#125;所谓解决依赖，就是在使用时给其设置一个被依赖的对象，如果不使用Spring，设置name的值需要把dao转换为UserDaoImpl，再使用setName()方法，但是用了Spring我们就能在配置文件中设置，Spring帮我们完成设置。此时就叫做依赖注入。## ApplicationContext继承体系bean配置id &amp; namename和id的功能类似，作用如图：从语法上说name属性可以不唯一，而id必须唯一，但是实际使用时name标签和id标签通常都标识唯一值，而且优先使用name。初始化时执行的方法 &amp; 销毁的时候执行的方法init-method=””：指定的方法在bean被创建时执行。destroy-method=””：指定的方法在bean被销毁时创建的，但要求bean是单例的且手动关闭工厂。bean的作用域bean标签有一个属性scope=””，可以设置bean的作用范围，五种值如下：singleton ：默认的，Spring会采用单例模式创建这个对象。prototype ：多例模式。request ：应用在web项目中，Spring创建这个类以后，将这个类存入到request范围中。session ：应用在web项目中，Spring创建这个类以后，将这个类存入到session范围中。globalsession ：应用在web项目中，必须在porlet环境下使用。但是如果没有这种环境，相当于session。（笔者不懂，抄过来的…）]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04-单表DQL]]></title>
    <url>%2F2019%2F04-%E5%8D%95%E8%A1%A8DQL%2F</url>
    <content type="text"><![CDATA[数据准备12345678910111213141516171819create table product( pid int primary key, pname varchar(20), price double, category_id varchar(32));INSERT INTO product(pid,pname,price,category_id) VALUES(1,'联想',5000,'c001');INSERT INTO product(pid,pname,price,category_id) VALUES(2,'海尔',3000,'c001');INSERT INTO product(pid,pname,price,category_id) VALUES(3,'雷神',5000,'c001');INSERT INTO product(pid,pname,price,category_id) VALUES(4,'JACK JONES',800,'c002');INSERT INTO product(pid,pname,price,category_id) VALUES(5,'真维斯',200,'c002');INSERT INTO product(pid,pname,price,category_id) VALUES(6,'花花公子',440,'c002');INSERT INTO product(pid,pname,price,category_id) VALUES(7,'劲霸',2000,'c002');INSERT INTO product(pid,pname,price,category_id) VALUES(8,'香奈儿',800,'c003');INSERT INTO product(pid,pname,price,category_id) VALUES(9,'相宜本草',200,'c003');INSERT INTO product(pid,pname,price,category_id) VALUES(10,'面霸',5,'c003');INSERT INTO product(pid,pname,price,category_id) VALUES(11,'好想你枣',56,'c004');INSERT INTO product(pid,pname,price,category_id) VALUES(12,'香飘飘奶茶',1,'c005');INSERT INTO product(pid,pname,price,category_id) VALUES(13,'果9',1,NULL);简单查询查询表的所有字段信息：select * from 表名;查询表中某字段信息：select 字段1, 字段2 from 表名;去掉重复值：select distinct 字段1, 字段2, ... from 表名;若有多个字段则所有字段相等才被算为重复值。查询结果是表达式（运算查询）：将商品的价格+10元进行显示，select pname,price+10 from product;别名查询，使用的关键字是as（as可以省略的）：表别名：select * from product as p;列别名：select pname as pn from product;条件查询符号含义&gt; &lt; &lt;= &gt;= = &lt;&gt;!=大于、小于、大于(小于)等于、不等于BETWEEN …AND…显示在某一区间的值(含头含尾)(也可以是日期)IN(set)显示在in列表中的值，例：in(100,200)LIKE ‘张%’%代表零个或多个任意字符，_代表一个字符。例如：first_name like ‘_a%’IS NULL / IS NOT NULL判断为空/不为空and多个条件同时成立or多个条件任一成立not不成立，例：where not(salary&gt;100);例查询商品名称为“花花公子”的商品所有信息：SELECT * FROM product WHERE pname = &#39;花花公子&#39;查询价格为800商品：SELECT * FROM product WHERE price = 800查询价格不是800的所有商品：SELECT * FROM product WHERE price != 800SELECT * FROM product WHERE price &lt;&gt; 800SELECT * FROM product WHERE NOT(price = 800)查询商品价格大于60元的所有商品信息：SELECT * FROM product WHERE price &gt; 60;查询商品价格在200到1000之间所有商品：SELECT * FROM product WHERE price &gt;= 200 AND price &lt;=1000;SELECT * FROM product WHERE price BETWEEN 200 AND 1000;查询商品价格是200或800的所有商品：SELECT * FROM product WHERE price = 200 OR price = 800;SELECT * FROM product WHERE price IN (200,800);查询含有’霸’字的所有商品：SELECT * FROM product WHERE pname LIKE &#39;%霸%&#39;;查询以’香’开头的所有商品：SELECT * FROM product WHERE pname LIKE &#39;香%&#39;;查询第二个字为’想’的所有商品：SELECT * FROM product WHERE pname LIKE &#39;_想%&#39;;查询没有分类的商品：SELECT * FROM product WHERE category_id IS NULL;查询有分类的商品：SELECT * FROM prod quct WHERE category_id IS NOT NULL查询所有价格大于2000的电脑商品或者价格大于1000的服装商品：SELECT * FROM product WHERE (price &gt; 2000 AND category_id=&#39;c001&#39;) OR (price &gt;1000 AND category_id=&#39;c002&#39;);排序查询SELECT * FROM 表名 ORDER BY 排序字段 ASC|DESC;ASC： 升序 (默认)DESC：降序例：查询所有商品信息，使用价格排序(降序)：SELECT * FROM product ORDER BY price DESC;在价格排序(降序)的基础上，以分类排序(降序)：SELECT * FROM product ORDER BY price DESC, category_id DESC;显示商品的价格(去重复)，并排序(降序)：SELECT DISTINCT price FROM product ORDER BY price DESC;聚合查询聚合函数SELECT不仅可以作用于字段，还可以作用于聚合函数。count(…)：统计指定列不为NULL的记录行数；sum(…)：计算指定列的数值和，如果指定列类型不是数值类型，那么计算结果为0；max(…)：计算指定列的最大值，如果指定列是字符串类型，那么使用字符串排序运算；min(…)：计算指定列的最小值，如果指定列是字符串类型，那么使用字符串排序运算；avg(…)：计算指定列的平均值，如果指定列类型不是数值类型，那么计算结果为0；例：查询商品的总条数：SELECT COUNT(*) FROM product;查询价格大于200的商品总条数：SELECT COUNT(*) FROM product WHERE price &gt; 200;查询分类为’c001’的商品价格总和：SELECT SUM(price) FROM product WHERE category_id = &#39;c001&#39;;查询分类为’c002’商品的平均价格：SELECT AVG(price) FROM product WHERE category_id = &#39;c002&#39;;查询商品的最大价格和最小价格：SELECT MAX(price),MIN(price) FROM product;分组分组查询是指使用group by字句对查询信息进行分组。​ SELECT 字段1, 字段2… FROM 表名 GROUP BY 分组字段 HAVING 分组条件;HAVING：分组操作中的having子语句，是用于在分组后对数据进行过滤的，作用类似于where条件。与where的区别:having是在分组后对数据进行过滤。where是在分组前对数据进行过滤。having后面可以使用聚合函数过滤数据。where后面不可以使用聚合函数。例：统计各个分类商品的个数：SELECT category_id ,COUNT(*) FROM product GROUP BY category_id;统计各个分类商品的个数,且只显示个数大于1的信息：SELECT category_id, COUNT(*) FROM product GROUP BY category_id HAVING COUNT(*) &gt; 1;分页查询由于数据量很大，显示屏长度有限，因此对数据需要采取分页显示方式。例如数据共有30条，每页显示5条。格式：SELECT 字段1，字段2... FROM 表明 LIMIT M, N;M: 整数，表示从第几条索引开始，计算方式 （当前页-1）*每页显示条数N: 整数，表示查询多少条数据例：SELECT 字段1，字段2... FROM 表明 LIMIT 0,5;SELECT 字段1，字段2... FROM 表明 LIMIT 5,5;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03-DDL与DML]]></title>
    <url>%2F2019%2F03-DDL%E4%B8%8EDML%2F</url>
    <content type="text"><![CDATA[操作数据库创建数据库create database 数据库名;例：CREATE DATABASE db1;create database 数据库名 charset 字符集;例：CREATE DATABASE db2 CHARSET utf8;删除数据库drop database 数据库名使用数据库查看数据库的定义信息show create database 数据库名;操作表创建表1234567CREATE TABLE &lt;表名&gt;( 字段名1 类型(长度) [列级完整性约束条件], 字段名2 类型(长度) [列级完整性约束条件], ... 字段名n 类型(长度) [列级完整性约束条件] [,&lt;表级完整性约束条件&gt;]);先不涉及约束条件，后面会有详细分析。1234CREATE TABLE category ( cid INT PRIMARY KEY, #分类ID cname VARCHAR(100) #分类名称);查看表查看数据库中的所有表：SHOW TABLES;查看表结构：DESC 表名;删除表drop table 表名修改表名rename table 表名 to 新表名;增改删增向表中插入某些字段：insert into 表 (字段1,字段2,字段3..) values (值1,值2,值3..);向表中插入所有字段，字段的顺序为创建表时的顺序：insert into 表 values (值1,值2,值3..);注意：值与字段必须对应，个数相同，类型相同值的数据大小必须在字段的长度范围内除了数值类型外，其它的字段类型的值必须使用引号引起。（建议单引号）如果要插入空值，可以不写字段，或者插入 null。改更新所有记录的指定字段：update 表名 set 字段名=值, 字段名=值, ...;更新符号条件记录的指定字段：update 表名 set 字段名=值, 字段名=值, ... where 条件;注意：列名的类型与修改的值要一致修改值得时候不能超过最大长度除了数值类型外，其它的字段类型的值必须使用引号引起删删除所有数据：delete from 表名;或者truncate table 表名;delete 一条一条删除，不清空auto_increment记录数。truncate 直接将表删除，重新建表，auto_increment将置为零，从新开始。删除某些数据：delete from 表名 where 条件操作表结构添加列：alter table 表名 add 列名 类型(长度) [约束];ALTER TABLE category ADD cdesc VARCHAR(20);删除列：alter table 表名 drop 列名;ALTER TABLE category DROP cdesc;修改列名：alter table 表名 change 旧列名 新列名 类型(长度) 约束;ALTER TABLE category CHANGE cdesc description VARCHAR(30);修改列的类型长度及约束：alter table 表名 modify 列名 类型(长度) 约束;ALTER TABLE category MODIFY cdesc VARCHAR(50) NOT NULL;修改表的字符集：alter table 表名 character set 字符集;ALTER TABLE category CHARACTER SET gbk;数据完整性指数据库中存储的数据是有意义的或正确的。实体完整性若属性A是基本关系R的主属性，则属性A不能取空值。参照完整性若属性（或属性组）F是基本关系R的外码，它与基本关系S的主码相对应，则对于R中每个元组在F上的值必须为：或者取空值（S的每个属性值均为空值）。或者等于S中某个元组的主码值。EMP(E#, ESEX, D#) -参照关系； DEPT(D# ,DNAME,LOCATION) -被参照关系用户定义的完整性针对某一具体关系数据库的约束条件，它反映某一具体应用所涉及的数据必须满足的语义要求。约束主键约束唯一标识一条记录的属性值。主键必须是唯一的值。主键列不能是 NULL 值。每个表都应该有且只能有一个主键。添加主键约束。方式一：创建表时，在字段描述处，声明指定字段为主键1234567CREATE TABLE Persons( Id_P int PRIMARY KEY, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255));方式二：创建表时，在表级约束区域，声明指定字段为主键格式：[constraint 名称] primary key (字段列表)关键字constraint可以省略，如果需要为主键命名，constraint不能省略。字段列表需要使用小括号括住，如果有多字段需要使用逗号分隔。这时多个字段联合构成主键。1234567CREATE TABLE Persons( FirstName varchar(255), LastName varchar(255), Address varchar(255), City varchar(255), [CONSTRAINT pk_PersonID] PRIMARY KEY (FirstName,LastName));方式三：创建表之后，通过修改表结构，声明指定字段为主键ALTER TABLE Persons ADD [CONSTRAINT 名称] PRIMARY KEY (字段列表)1234567CREATE TABLE Persons( FirstName varchar(255), LastName varchar(255), Address varchar(255), City varchar(255));ALTER TABLE Persons ADD PRIMARY KEY (FirstName);撤销主键约束：ALTER TABLE Persons DROP PRIMARY KEY自动增长列设置某列的值自动增长。使用 auto_increment（自动增长列）关键字。自动增长列类型必须是整形。自动增长列必须为键(一般是主键)。添加自动增长：1234567CREATE TABLE Persons( P_Id int PRIMARY KEY AUTO_INCREMENT, LastName varchar(255), FirstName varchar(255), Address varchar(255), City varchar(255));添加数据时，可以不设置值，也可以设置成null，数据库将自动维护主键值：INSERT INTO Persons (FirstName,LastName) VALUES (&#39;Bill&#39;,&#39;Gates&#39;);INSERT INTO Persons (P_Id,FirstName,LastName) VALUES (NULL,&#39;Bill&#39;,&#39;Gates&#39;);修改起始值ALTER TABLE Persons AUTO_INCREMENT=100;非空约束约束不接受NULL值，意味着如果不向字段添加值，就无法插入新记录或者更新记录。添加方式方式一：创建表，下面的 SQL 语句强制 “Id_P” 列和 “LastName” 列不接受 NULL 值1234567CREATE TABLE Persons( Id_P int NOT NULL, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255));方式二：修改表结构ALTER TABLE student MODIFY LastName varchar(255) NOT NULL删除非空约束ALTER TABLE student MODIFY LastName varchar(255);唯一约束UNIQUE约束唯一标识数据库表中的每条记录。PRIMARY KEY拥有自动定义的UNIQUE约束。每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。添加唯一约束方式1：创建表时，在字段描述处，声明唯一1234567CREATE TABLE Persons( Id_P int UNIQUE, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255));方式2：创建表时，在约束区域，声明唯一12345678CREATE TABLE Persons( Id_P int, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255), City varchar(255), CONSTRAINT 名称 UNIQUE (Id_P));方式3：创建表后，修改表结构，声明字段唯一ALTER TABLE Persons ADD [CONSTRAINT 名称] UNIQUE (Id_P);删除唯一约束ALTER TABLE Persons DROP INDEX 约束名称如果添加唯一约束时，没有设置约束名称，默认是当前字段的字段名。默认约束在添加数据中，如果该字段不指定值，采用默认值处理。添加方式方式一： 创建表，字段处声明1234567CREATE TABLE Persons( Id_P int, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255) DEFAULT '北京', City varchar(255));方式二： 修改表结构ALTER TABLE Persons MODIFY Address VARCHAR(255) DEFAULT &#39;北京&#39;;删除方式ALTER TABLE Persons MODIFY Address VARCHAR(255);外键约束参照关系对应的表是从表。被参照关系对应的表是主表。声明外键约束创建表时添加。12345678CREATE TABLE Persons( Id_P int, LastName varchar(255) NOT NULL, FirstName varchar(255), Address varchar(255) DEFAULT &apos;北京&apos;, City varchar(255), [CONSTRAINT FK_DEPTNO] FOREIGN KEY (Address) REFERENCES CITY(Address));修改表结构alter table 从表 add [constraint 名称] foreign key (外键字段) references 主表 (主表主键);删除外键alter table 从表 drop foreign key 外键名称;备份 &amp; 恢复备份恢复&gt;]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-MySQL环境安装]]></title>
    <url>%2F2019%2F02-MySQL%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[安装MySQLMySQL有两种安装方式，解压配置和安装程序安装。在这使用解压配置但是资源里有使用安装程序安装的教程。解压至指定目录解压至自己选定的目录，一般不选择系统盘。我是解压至D盘根目录：D:\mysql-5.5\。写配置文件123456789#设置字符集为utf8 character-set-server = utf8basedir = D:/mysql-5.5 #指定为自己选定的目录datadir = D:/mysql-5.5/data #指定为选定目录下的data文件夹[client] #设置客户端字符集default-character-set = utf8[WinMySQLadmin] Server = D:/mysql-5.5/bin/mysqld.exe #指定至mysqld.exe文件配置环境变量安装和配置在管理员下的cmd命令下进入%MYSQL_HOME%/bin目录执行mysqld -install。如果想要卸载服务执行命令mysqld -remove。启动服务net start mysql第一次进入mysql -u root。mysql&gt; update mysql.user set password=PASSWORD(‘root’) where User=’root’;mysql&gt; flush privileges;后续进入mysql -u username -p按提示输入密码退出exit停止服务net stop mysql查看编码集mysql&gt; show variables like ‘%char%’;1234567891011121314mysql&gt; show variables like &apos;%char%&apos;;+--------------------------+------------------------------+| Variable_name | Value |+--------------------------+------------------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | utf8 || character_set_system | utf8 || character_sets_dir | D:\mysql-5.5\share\charsets\ |+--------------------------+------------------------------+8 rows in set (0.01 sec)编码集如图上表示编码集配置正确。安装SQLyogSQLyog是一个可视化操作数据库工具。解压后就可使用：点击SQLyog.exe连接数据库使用]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-关系型数据库绪论]]></title>
    <url>%2F2019%2F01-%E5%85%B3%E7%B3%BB%E5%9E%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%AA%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[数据、数据库、数据库管理系统数据：描述事物的符号记录称为数据，如文字、图形、图象、声音、学生的档案记录、货物的运输情况等。数据的含义称为数据的语义，数据与其语义是不可分的。数据库：数据按一定的方式组织、描述和存储后形成的数据集合叫做数据库。数据库具有三个特点：永久存储：不随程序的结束而结束。有组织：数据之间有一定的格式，可以通过格式知道数据所代表的的意义。可共享：数据库里的信息不是只为某一用户或某一程序所使用。数据库管理系统：数据库管理系统是位于用户与操作系统之间的一层用来管理数据库的软件。常用的数据库管理系统有MySQL、Oracle、Redis、MongoDB等。关系数据库系统数据库是由数据按某种形式组织所形成，按照不同的组织方式可以分为不同的类型。所以关系型数据库就是指以关系数学模型来组织数据的数据库，关系数学模型中以二维表的形式来描述数据。也就是一个关系对应一个二维表。实体-联系实体：客观存在并可相互区别的事物。二维表非首行。属性：实体所具有的某一特性。二维表的一格。码：唯一标识实体的属性。域：属性的取值范围。实体型：用实体名及其属性名集合来抽象和刻画同类实体。实体集：同型实体的集合称为实体集联系：现实世界中事物内部以及事物之间的联系在信息世界中反映为实体内部的联系和实体之间的联系。SQLDDL、DML、DCL、DQL常见的关系数据库系统有MySQL、Oracle等，可以使用结构化查询语言（Structured Query Language，SQL）进行操作。不同的数据库生产厂商都支持SQL语句，但都有特有内容（称为方言）。SQL可分为四类：数据定义语言（Data Definition Language，DDL）：用来定义数据库中的对象：数据库，表，列等。关键字有create、alter、drop、 show等。数据操作语言（Data Manipulation Language，DML）：用来对数据库中表的记录进行更新。关键字有insert、delete、update等。数据查询语言（Data Query Language，DQL）：用来查询数据库中表的记录。关键字：select，from，where等。数据控制语言（Data Control Language，DCL）：用来定义数据库的访问权限和安全级别，及创建用户。关键字有grant、revoke等。SQL通用语法SQL语句可以单行或多行书写，以分号结尾，可使用空格和缩进来增强语句的可读性。MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。例如：SELECT * FROM user。使用/* ... */的方式完成注释。数据类型类型描述int整型double浮点型varchar变长字符串型（指定为10个字节长度，存储abc只占用3个字节）char定长字符串型（指定为10个字节长度，存储abc也占用10个字节）datetimeYYYY-MM-DD HH:MM:SS（1000-01-01 00:00:00~ 9999-12-31 23:59:59）实体型之间的联系一对一联系：如果对于实体集A中的每一个实体，实体集B中至多有一个实体与之联系，反之亦然，称实体集A与实体集B有一对一联系。记为1：1。一对多联系：如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中至多只有一个实体与之联系，称实体集A与实体B有一对多联系。记为1：n。多对多联系：如果对于实体集A中的每一个实体，实体集B中有n个实体（n≥0）与之联系，反之，对于实体集B中的每一个实体，实体集A中有m个实体（m≥0）与之联系，称实体集A与实体B有多对多联系。记为m：n。多对多联系能经由一个中间表拆分成两个一对多关系。Entity-Relationship ModelE-R图提供了表示实体型、属性和联系的方法。先把需求转化成E-R图，可以方便的化简和建表。实体型：用矩形表示，矩形框内写明实体名。属性：用椭圆形表示，并用无向边将其与相应的实体连接起来。联系：用菱形表示，菱形框内写明联系名，并用无向边分别与有关实体连接起来，同时在无向边旁标上。联系的类型: 1：1、1：n或m：n。联系本身也是一种实体型，也可以有属性。如果一个联系具有属性，则这些属性也要用无向边与该联系连接起来。E-R图转换成关系转换原则：实体和联系分别转换为关系，再合并具有相同主键的关系。实体转换为关系：一个实体型 转换成 一个关系。实体型的名称 转换成 构成关系的名称。实体型的属性 转换成 构成关系的属性（也叫字段）。实体型的主键 转换成 关系的主键。联系转换为关系：一个联系 转换成 一个关系。与该联系相关联的各实体的码属性以及联系本身的属性 构成 关系的属性。联系转换为关系的码的取决于联系的类型。1：1联系，任一实体的码。1：n联系，n端实体的码。m：n联系，双方实体的码相同码的关系合并为一个关系。E-R图实例数据：科室：科名，科地址，科电话病房：病房号，床位号医生：姓名，职称，年龄，工作证病人：病历号，姓名，性别，诊断联系：一个科室有多个病房、多个医生一个病房只能属于一个科室一个医生只属于一个科室，但可负责多个病人的诊治一个病人的主管医生只有一个E-R图转换科室（科名，地址，电话）医生（医生名，职称，年龄，工作证号）病房（病房号，床位号）病人（病历号，姓名，性别，诊断）负责（床位号，科名）拥有（医生名，科名）诊治（病历号，医生名）合并科室（科名，地址，电话）医生（医生名，职称，科名，年龄，工作证号）病房（床位号，病房号，科名）病人（病历号，姓名，性别，诊断，医生名）]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02-进程的描述与控制]]></title>
    <url>%2F2019%2F02-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0%E4%B8%8E%E6%8E%A7%E5%88%B6%2F</url>
    <content type="text"><![CDATA[进程概念前趋图数据结构中的有向无环图。箭头表示进程之间执行的先后关系。结点表示一个程序或一个进程，甚至一条语句。程序的并发执行不存在前趋关系的程序之间才有可能并发执行。特征：间断性：程序在并发执行时，由于它们共享系统资源，以及为完成同一项任务而相互合作，致使在这些并发执行的程序之间形成了相互制约的关系，进而导致并发程序具有“执行-暂停-执行”这种间断性的活动规律。失去封闭性：由于资源共享，所以当某程序的运行影响资源的状态时，其他程序的运行环境就会被破坏。不可再现性：计算结果与并发程序各自执行速度有关。即同一程序，使用相同输入、在相同环境下运行，却可能获得完全不同的结果。进程的定义在多道程序环境下，程序的执行属于并发执行，此时他们将失去其封闭性，并具有间断性，以及运行结果的不可再现性。由此，决定了通常的程序是不能参与并发执行的。为了能使程序并发执行，引入了进程。进程实体：程序+数据+进程控制块（Process Control Block，PCB）。进程：运行态的进程实体是就是进程，是系统进行资源分配和调度的一个独立单位。PCB是为了使程序能并发执行而诞生的一种数据结构，它用来控制和管理进程。由于数据和程序本来就存在，所以创建/撤销进程也就是创建/撤销PCB。至于如何并发执行，见下面的进程同步。区别于作业：进程是程序在数据集上的一次作执行，作业是用户提交给系统的一个任务，包含一个或多个进程。进程的特点动态性：由创建而产生，由调度而执行，由撤销而消亡。并发性：进程的重要特征，操作系统的重要特征。独立性：独立运行、独立分配资源、独立接受调度。异步性：按各自独立、不可预知的速度向前推进。PCBPCB中保存的信息进程标识符。用于唯一的标识某个进程。外部标识符：不仅可以标识进程，还指明其父进程、子进程以及拥有该进程的用户。内部标识符：方便系统使用进程，仅能标识进程。处理机状态。用于在进程切换时保存处理机中各个寄存器的内容。以便在该进程重新调度时能再从断点执行。进程调度信息。进程状态：指明进程的状态，方便进程调度和对换时的依据。进程优先级：进程优先级高的更容易获得处理机。进程调度所需信息：保存的内容和进程调度算法有关，如进程等待了多久CPU，使用了多长CPU。事件：进程因何由执行状态转变为阻塞状态，即阻塞原因。进程控制信息。程序和数据的地址。进程同步的通信机制。资源清单。进程已分配到的除处理机之外的资源。链接指针。用于指向下一个PCB的首地址。用于进程调度。PCB的组织方式线性方式：所有的PCB都保存在一张表中，每次寻找PCB都在表中查找。效率低。链接方式：把具有相同状态的PCB链接起来。索引方式：把具有相同状态的PCB保存在相应的表中。OS内核系统态 &amp; 用户态对于处理机来说，根据其执行的指令不同，可以将其分成系统态（管态、内核态）和用户态。处理机处于系统态时可以执行任意的指令，访问所有的寄存器和存储区，而处于用户态的时候会受到相应的限制。所以计算机中的程序可以分成系统程序和用户程序，用户程序运行在用户态，这样就可以防止用户程序对操作系统进行破坏。指令分类操作系统把CPU指令分成两类：特权指令：在系统态执行的指令。执行几乎不受限制，如启动外部设备、设置系统时钟等。非特权指令：在用户态执行的指令。限制较多，比如不能操作硬件等。内核概念现代操作系统采用分层设计模式，不同权重的程序分别设置在不同的层次中。通常与硬件紧密相关的程序、设备驱动程序和运行频率高的程序等放置在高级别层次中，操作系统会将它们常驻内存，这些程序便被称为OS内核。OS内核运行在系统态中。内核的功能不同操作系统的内核在功能上有一定的差异，但是一般都包含两类功能：支撑功能中断处理：是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，且处理完毕后又返回原被暂停的程序继续运行。人机交互、设备驱动和进程调度等都需要依赖中断处理。时钟管理：系统中很多活动都需要用到时钟，如定时任务、时间片轮转调度算法等。原语操作：原语是若干条机器指令构成的，用以完成特定功能的一段程序。而原语操作便是原语的执行，其在执行期间是不可分割的。资源管理功能进程管理：进程的创建、撤销、调度等操作。存储器管理：空间的分配、撤销、逻辑地址转换为物理地址等。设备管理：进行设备分配、缓和CPU和I/O速度不匹配矛盾的缓冲管理等。进程的生命周期进程的创建为新进程申请内部标识符，同时从PCB集合中索取一个空白的PCB。为新进程分配其运行所需的资源。这些资源直接来自操作系统或者父进程。初始化PCB。如处理机状态信息、标识符和进程优先级等。若就绪队列还能接受进程，则插入就绪队列。不能接受则执行相应处理机制。进程的终止从PCB集合中获得某进程的PCB，并读出该进程的状态。若进程正处于执行状态，应立即终止该进程的执行。若此进程有子进程则一并终止，防止其成为不可控进程。将进程拥有的所有资源归还给其父进程或操作系统。将被终止的进程从所在队列或链表（指PCB的组织方式）中移出，等待其他程序收集信息，释放空间等。三种基本状态就绪状态：分配到出处理机之外的其他所有必要资源。此时可运行，但其他进程正在占用CPU。执行状态：就绪状态的进程获得CPU，正在执行的状态。阻塞状态：进程发出的请求没有及时得到满足而无法继续执行的状态，此时会引起进程调度，OS把处理机分配给其他就绪进程，原进程暂停。挂起进程暂停执行或不接受调度的状态。原因有如下几点：用户的需要：用户想暂停正在的进程，观察其状态或修改程序等。父进程请求：父进程为了完成某项任务，协调其各子进程间的活动。负荷调节的需要：系统压力过大或实时操作系统不能很好的满足可靠性时会挂起一些进程。操作系统的需要：操作系统挂起某些进程来更方便的检查系统资源。挂起和阻塞不同在于阻塞是客观条件不能得到满足，即资源不足引起暂停。挂起是主观需要引起暂停。进程同步进程同步的主要任务是使并发执行的诸进程之间能有效的共享资源和相互合作，从而使程序的执行具有可再现性。同步 &amp; 互斥并发执行的诸进程之间既有独立性又有制约性。独立性：各进程都可独立地向前推进；制约性：由于资源共享和进程合作引起的进程之间的相互依赖和相互制约的关系。可归结为互斥和同步。同步：两个或多个事件的发生有着某种时序上的关系。按照这种时序关系进行能保证各任务安全的完成。互斥：资源的使用要排它使用，防止冲突（不同时使用，但无先后次序。一种特殊同步）。临界资源 &amp; 临界区临界资源：需要被各进程互斥访问的资源。临界区：各进程中访问临界资源的代码。若能保证各进程互斥地进入自己的临界区，便可以保证互斥地访问临界资源，进而保证进程同步。常用的方式有硬件同步机制和信号量机制。同步准则空闲让进：当无进程处于临界区时，应当允许一个进程进入自己的临界区。忙则等待：当有进程处于临界区时其他请求就如临界区的进程必须等待。有限等待：对要求访问临界资源的进程，应保证在有限的时间内能进入自己的临界区。让权等待：当进程不能进入临界区时，应立即释放处理机避免进程陷入“忙等”的状态。硬件同步机制关中断当进程在临界区执行期间，计算机系统不响应中断，因此不会引发调度，临界资源只会被一个进程占据，这样就不会发生进程同步问题。利用Test-and-Set指令实现互斥指令的描述如下：123456boolean TS(boolean *lock)&#123; boolean old; old = *lock; *lock = true; return old;&#125;为临界资源设置一个布尔变量lock = false。在进程进入临界区之前利用TS指令测试，如果得到的值为false表示资源未被使用，如果得到的值为true，则一直测试到结果为false。使用TS指令实现互斥描述如下：1234567do&#123; ... while (TS(&amp;lock)); ... lock = false; ...&#125;while(true);利用Swap指令实现互斥指令描述如下：123456void swap(boolean *a, boolean *b)&#123; boolean temp; temp = *a; *a = *b; *b = temp;&#125;为每个临界资源设置一个全局变量lock=false。每个进程设置一个局部变量key。实现互斥的描述如下：12345678910do&#123; ... key = true; do&#123; swap(&amp;lock, &amp;key); &#125;while(key != false) critical section; lock = false; ...&#125;缺点关中断：效率低下且不适用于多处理机系统。且其他进行会”忙等“，不符合让权等待。TS指令 &amp; Swap指令：其他进行会”忙等“，不符合让权等待。信号量机制整型信号量整型信号量是一个用于描述资源数目的整型量（S）。但除了初始化以外，仅能通过两个原子操作来访问。wait(S)：P操作1234wait(S)&#123; while(S &lt;= 0); S--;&#125;signal(S)：V操作123signal(S)&#123; S++;&#125;P操作用于分配资源，V操作用于释放资源。记录型信号量整型信号量未遵循让权等待原则。只要S &lt;= 0就会不断的循环。此时需要增加一个进程链表指针链接等待进程。数据结构的描述：1234typedef struct&#123; int value; //资源数 struct process_control_block *list; //阻塞队列&#125; semaphore;wait(S)：12345wait(semaphore *S)&#123; S-&gt;value--; if(S-&gt;value &lt; 0) block(S-&gt;list);&#125;signal(S)：12345signal(semaphore *S)&#123; S-&gt;value++; if(S-&gt;value &lt;= 0) wakeup(S-&gt;list);&#125;当进程被阻塞时会被加入阻塞对列，资源被满足时唤醒阻塞对列中的某个资源。AND型信号量记录型信号量只能解决共享一个临界资源的情况，若有多个临界资源则需要使用多个记录型信号量。但是信号量越多，系统死锁的概率越大，且大量的同步操作会给系统的管理带来麻烦。AND型信号量的思想是一次性分配进程所需的全部资源，如果有一个没有分配成功，则其他所有可能为之分配的资源亦不分配。Swait(S)：123456789101112Swait(S1, S2, ..., Sn)&#123; while(true)&#123; if(Si &gt;= 1 &amp;&amp; ... &amp;&amp; Sn &gt;= 1)&#123; for(i = 1; i &lt;= n; i++) Si--; break; &#125;else&#123; 把进程阻塞在请求未能得到满足的资源Si所对应的阻塞队列里，同时把进程的程序计数器（放 置CPU下一条要执行的指令地址）放置在本操作的开始处（下一次再调度到此进程，需要再次 检查所有的资源）。 &#125; &#125;&#125;Ssignal(S)：12345678Ssignal(S1, S2, ..., Sn)&#123; while(true)&#123; for(i = 1; i &lt;= n; i++)&#123; Si++; 唤醒等待Si资源的阻塞队列。 &#125; &#125;&#125;信号量集之前的信号量都是一次申请或释放某资源一份，若申请或释放N份资源需要进行N次操作，效率比较低下。此外，当资源数量低于某一下限值时，为了系统安全，就不能再予以分配。所以产生信号量集解决以上问题。描述如下：Swait(S1, t1, d1, ..., Sn, tn, dn)：当Si &gt;= ti时Si = Si - di。（di &gt;= ti）Ssignal(S1, d1, ..., Sn, dn)：Si = Si + di。特殊的信号量集：Swait(S1, d, d)：每次申请d份资源，资源少于d时不分配。Swait(S, 1, 1)：退化成一般的记录型信号量。Swait(S, 1, 0)：S &gt;= 1时运行多个进行进入特定区。S &lt;= 0时禁止进程进入特定区。管程直接使用信号量机制会把大量的同步操作分散在各个进程中，这会增加系统死锁的概率并且不方便系统的管理。而管程就是把代表共享资源的数据结构和对共享数据结构的操作（包括同步机制）封装起来以更好的为进程使用。这时所有请求访问共享资源的进程都只能通过管程间接访问，同时管程每次只允许一个进程进入管程。此时的管程可以使用面相对象的操作来完成整型信号量的功能。但是此时无法解决“让权等待”的问题，所以再按照面相对象的思想将block和wakeup操作封装起来来解决这个问题，即构成条件变量。条件变量的操作如下：condition.wait()：使进程在因某条件不能满足时阻塞在其所对应的条件变量上。condition.signal()：唤醒因某条件不能满足而阻塞的进程。可以很容易看出来，设置不同的条件变量能使由不同原因等待的进程阻塞在不同的队列中。使用时把signal()操作放在函数/过程的最后，这样保证在唤醒其他进程后本进程能直接退出而不再产生冲突。管程的描述如下：123456789101112131415161718/* 1、局部数据和条件变量组成管程内的数据结构。 2、过程/函数1~过程/函数k组成管程内的一组过程对管程内的数据结构进行操作。 3、初始化代码：对管程内的数据结构进行初始化。*/Monitor monitor_name&#123; share variable declartions; //共享变量说明 condition declarations; //条件变量说明 &#123; //管程主体 initialization code; //初始化代码 ... &#125; public: //能被进程调用的过程 void P1(...)&#123;...&#125; void P2(...)&#123;...&#125; ... void Pn(...)&#123;...&#125;&#125;信号量的应用互斥访问资源设某共享资源的信号量是mutex，PA和PB进程并发时需互斥访问。12345678910111213141516171819semaphore mutex = 1;PA()&#123; while(1)&#123; ... wait(mutex); ... signal(mutex); ... &#125;&#125;PB()&#123; while(1)&#123; ... wait(mutex); ... signal(mutex); ... &#125;&#125;利用信号量实现前趋关系123456789101112P1（）&#123;...V(f1);V(f1);V(f1);&#125;P2（）&#123;P(f1)；... V(f2);&#125;P3（）&#123;P(f1)；... V(f3);&#125;P4（）&#123;P(f1)；... V(f4);&#125;P5（）&#123;P(f2)；... V(f5);&#125;P6（）&#123;P(f3);P(f4);P(f5);...;&#125;main()&#123; semaphore f1=f2=f3=f4=f5=0； Cobegin P1(); P2();P3(); P4();P5(); P6(); Coend&#125;在并发时，如果P1的功能代码未执行完，f1为0，每次对f1进行V操作能使P2、P3、P4运行一个。其他亦然。生产者—消费者问题问题描述：多个生产者进程生产产品以供多个消费者消费。通过由n个环形缓冲区构成的缓冲池（循环队列），把多个生产者和多个消费者联系起来。不允许消费者进程到一个空缓冲区去取产品，也不允许生产者进程向一个已装满产品且尚未取走的缓冲区中投放产品。分析：任何时刻，只能有一个进程在缓冲区中操作。对于“生产者”而言，缓冲区满则应等待。对于“消费者”而言，缓冲区空则应等待。利用记录型信号量解决问题12345678910111213141516171819202122232425262728293031int in = 0, out = 0;//in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。item buffer[n];//缓存区大小为n，地址为[0, n-1]。semaphore mutex = 1, empty = n, full = 0; //mutex用于互斥访问缓存区void producer()&#123; do&#123; produce an item nextproducer; ... wait(empty); //消耗一个empty，当empty&lt;=0时等待 wait(mutex); buffer[in] = nextproducer; in = (in+1) % n; signal(mutex); signal(full); //增加一个full &#125;while(true);&#125;void consumer()&#123; do&#123; wait(full); //消耗一个full，当full&lt;=0时等待 wait(mutex); nextconsumer = buffer[out]; out = (out+1) % n; signal(mutex); signal(empty); //增加一个empty ... &#125;while(true);&#125;void main()&#123; ConcurrentBegin produce();consumer(); ConcurrentEnd;&#125;互斥信号量 &amp; 资源信号量互斥使用的资源设置一个互斥信号量，资源数为1。资源信号量的资源数和资源的意义有关。资源信号量的资源为1时退化成互斥信号量。在使用时互斥信号量的P操作需要紧邻其对应共享资源的临界区使用，否则可能造成同步问题。比如互换上面代码的第8行和第9行之后，若生产者进程和消费者进程都只有一个，且生产者通过了P(mutex)，阻塞在P(empty)，消费者通过了P(full)，阻塞在P(mutex)，此时生产者等待消费者的V(empty)，消费者等待生产者的V(mutex)，发生死锁。而V操作不需要注意顺序。利用AND型信号量解决问题123456789101112131415161718192021222324252627int in = 0, out = 0;//in指向此次生产的产品应该放置的位置。out指向此次消费的产品所在的位置。item buffer[n];//缓存区大小为n，地址为[0, n-1]。semaphore mutex = 1, empty = n, full = 0; //mutex用于互斥访问缓存区void producer()&#123; do&#123; produce an item nextproducer; ... Swait(empty, mutex); //消耗一个empty，当empty&lt;=0时等待 buffer[in] = nextproducer; in = (in+1) % n; signal(empty, mutex); //增加一个full &#125;while(true);&#125;void consumer()&#123; do&#123; wait(full, mutex); //消耗一个full，当full&lt;=0时等待 nextconsumer = buffer[out]; out = (out+1) % n; signal(full, mutex); //增加一个empty ... &#125;while(true);&#125;void main()&#123; ConcurrentBegin produce();consumer(); ConcurrentEnd;&#125;利用管程解决问题12345678910111213141516171819202122232425262728293031323334353637383940414243Monitor monitor&#123; item buffer[n]; int in = 0, out = 0, count = 0; condition notfull, notempty; public: void static put(item x)&#123; if(count &gt;= n) cwait(notfull); //阻塞在队列满的条件下 buffer[in] = x; in = (in+1) % n; count++; csignal(notempty); &#125; void static get(item &amp;x)&#123; if(count &lt;= 0) cwait(notempty); //阻塞在队列空的条件下 x = buffer[out]; out = (out+1) % n; count--; csignal(notfull); &#125;&#125;void producer()&#123; item x; while(true)&#123; ... produce an item in nextproducer; monitor.put(x); &#125;&#125;void consumer()&#123; item x; while(true)&#123; monitor.get(x); consume the item in nextconsumer; ... &#125;&#125;void main()&#123; ConcurrentBegin produce();consumer(); ConcurrentEnd;&#125;哲学家进餐问题问题描述：五个哲学家坐在圆桌前，每人一份饭，每个哲学家两侧各有一支筷子,只有拿到左右两只筷子才能进餐，哲学家处于吃饭和思考两种状态。分析同一时刻一只筷子只能有一个哲学家拿起。只有获得两个筷子后才能进餐。如果每个哲学家都拿起一只筷子，都饿死。并行程度：五只筷子允许两人同时进餐。利用AND型信号量解决问题每次必须拿到两只筷子才能拿起，否则不拿起筷子。12345678semaphore chopstick[5] = &#123;1, 1, 1, 1, 1&#125;;do&#123; ... Swait(chopstick[i], chopstick[(i+1) % 5]); ... Ssignal(chopstick[i], chopstick[(i+1) % 5]); ...&#125;读者-写者问题问题描述：写者向共享数据区放数据，读者从共享数据区读数据。多个读者可同时读取数据，多个写者不能同时写数据。分析：读者进入共享数据区，写者必须等待。读者进入共享数据区，读者可以进入。写者进入共享数据区，读者必须等待。利用记录型信号量解决问题1234567891011121314151617181920212223242526272829semaphore readmutex = 1, writemutex = 1;int readcount = 0;void reader()&#123; do&#123; wait(readmutex); if(readcount == 0) wait(writemutex); readcount++; signal(readmutex); ... //read opreation wait(readmutex); readcount--; if(readcount == 0) signal(writemutex); signal(readmutex); &#125;while(true);&#125;void writer()&#123; do&#123; wait(writemutex); //当写者进入共享数据区，reader会阻塞在 ... //write operation signal(writemutex); &#125;while(true);&#125;void main()&#123; ConcurrentBegin reader();writer(); ConcurrentEnd;&#125;代码分析：最开始并发的时候：假如读者先抢到资源，readcount == 0，P(writemutex)，writer()会阻塞在第20行，但其他reader()仍可以运行，只是不会再P(writemutex)。同时每个reader()都readcount++，直到readcount == 0时V(writemutex)，然后writer()才有可能能进入。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。假如写者先抢到资源，P(writemutex)，此时readcount == 0，所有reader()阻塞在第7行。此时读者进程和写者进程进入共享数据区的个数都为0，即又是重新开始。综上，完成了要求。读者-写者问题拓展问题描述：拓展就是又增加一个条件，最多只允许RN个读者同时读。利用信号量集解决问题123456789101112131415161718192021semaphore L = RN, mx = 1; //L用来控制访问数，mx控制写者访问时所有读者阻塞void reader()&#123; do&#123; Swait(L, 1, 1); //第RN+1个读者进入时会阻塞 Swait(mx, 1, 0);//mx &gt;= 1时才可以进入 ... //read operation Ssignal(L, 1); &#125;while(true);&#125;void writer()&#123; do&#123; Swait(mx, 1, 1; L, RN, 0); //mx &gt;= 1 &amp;&amp; L &gt;= RN时进入 ... //write operation Ssignal(mx, 1); &#125;while(true);&#125;void main()&#123; ConcurrentBegin reader();writer(); ConcurrentEnd;&#125;代码分析：最开始并发的时候：假如读者先抢到资源，L = L - 1，写者阻塞在第12行，但其他reader()仍可以运行，直至没有读者进程在访问共享数据区。当所有的读者进程都退出时，共享数据区中停留的个进程数都为0，即重新开始。假如写者先抢到资源，mx = mx - 1，所有读者进程和其他写者进程都要被阻塞，写者进程退出时，共享数据区中停留的个进程数都为0，即重新开始。理发师问题问题描述：一把理发椅，N把等待座位。理发师为理发椅上的顾客理发，没有顾客就在理发椅上睡觉，有一个顾客时需要叫醒理发师，多个顾客时需要在等待座位上等候。分析：理发椅上只能有一位顾客。等待座位是有限缓冲区。只要存在顾客，理发师就不能睡觉。利用记录型信号量解决问题：123456789101112131415161718192021222324semaphore customer = 0, barber = 0, mutex = 1; //barber使理发师只能为一个顾客服务int waiting = 0;void barber()&#123; while(true)&#123; wait(customer); //没有顾客的时候理发师睡觉 wait(mutex); waiting –= 1; //等待的人少一个 signal(mutex); signal(barber); ...//获得被激活进程的信息并给相应的顾客剪发 &#125;&#125;void customer()&#123; wait(mutex); if(waiting &lt; CHAIRS)&#123; //顾客到来的时候，还有座位就进去等待 waiting += 1; signal(mutex); signal(customer); wait(barber); ... //将被激活进程的信息发送给barber() &#125;else&#123; signal(mutex); &#125;&#125;代码分析在最开始并发的时候barber()会等待到有顾客时才醒来。顾客一来就需要访问waiting，所以获得mutex。如果位置不够就立即释放mutex。如果位置够，就让等待的人加1，再释放mutex。然后顾客人数customer += 1来激活理发师进程。理发师进程激活后会V(barber)，然后等待着的customer()进程争夺资源，争夺到P(barber)的进程将被激活进程的信息发送给barber()，barber()获得被激活进程的信息并给相应的顾客剪发。进程通信概念进程之间合作完成工作不仅仅需要有时序关系，还需要进程信息交互，比如刚才的理发师问题中就设计到了信息交互。从概念上说进程通信是指进程之间的信息交换，所以信号量机制本身就涉及到了信息交换，不过我们把这种信息交换叫做低级进程通信，因为其效率低且需要用户大量的干预。真正的进程通信需要满足使用方便且能高效传输大量数据的需求。共享存储器系统基于共享数据结构的通信方式：诸进程公用某些数据结构来实现进行通信 ，如生产者—消费者问题中的有界缓冲区，属于低级通信方式。基于共享存储区的通信方式：在存储器中划出一块共享存储区，诸进程通过对共享存储区中数据的读或写实现通信，此时数据的形式、位置和访问控制仍是进程实现。适用于传输大量数据，属于高级通信。管道通信系统所谓“管道”，是指用于连接一个读进程和一个写进程以实现他们之间通信的一个共享文件，又名pipe文件。向管道提供输入的发送进程（即写进程）以字符流形式将大量的数据送入管道，而接收进程（即读进程），可从管道中接收数据。管道通信系统必须满足以下三个要求：互斥：管道的使用必须互斥。因为存数据和取数据可归于写文件的添加和删除。同步：写进程把一定数量的数据写入管道后去睡眠，读进程读完后将其唤醒。读进程读空的管道时需要睡眠。确定对方存在：如果写进程不存在，读进程就会一直等待。如果读进程不存在，写进程写完数据后也会一直等待，所以通信双方必须同时存在。消息传递系统指进程可以利用一组通信命令（原语）把数据封装在消息中传送，不需要显示的指定共享存储区或数据结构等。它隐藏了通信的细节，也是目前使用最广泛的进程间通信机制。通常有两种实现方式：直接通信方式：OS提供原语给进程使用。间接通信方式：借助共享中间实体（称为邮箱）完成进程间的通信。和共享存储器系统的区别是进程不再需要指定数据的形式、位置和访问控制等，信箱内部自有实现。客户机-服务器系统前三种都是单机下的通信机制，这种是网络环境中的通信机制。主要有套接字和RPC两种方式。套接字：一个套接字是一个通信标识类型的数据结构，包含了通信目的地址、通信端口号、通信的网络协议、进程自身的地址以及对外提供的系统调用等。使用套接字可以在不同主机上的进程建立连接进而进行通信。RPC：Remote Procedure Call，它是一个通信协议，可以使本地进程调用其他主机的进程对程序员表现为常规方法调用。线程线程的由来进程解决了程序不能并发执行的问题，但是由于进程是拥有资源的基本单位，所以在创建、撤销和切换时所需的时空开销很大，因为处理机势必要付出更大的代价来保存现场。所以把拥有资源和独立运行两项功能分开，让线程作为独立运行的基本单位，进程作为拥有资源的基本单位。不过线程也拥有一些能保证其独立运行的资源，如TCB。TCB（Thread Control Block）所有用于控制和管理线程的信息都会被记录在线程控制块中，通常包含：线程标识符：每个线程都有唯一的线程标识符。处理机信息：包括程序计数器、状态寄存器、通用寄存器的内容。线程运行状态：线程和进程一样也有多种运行状态，就绪、阻塞、运行等。详见103-网络编程。优先级：和调度算法有关，优先级越高，得到处理机的机会越大。线程专有存储区：用于在线程切换时保存现场状态和保存线程的统计信息。信号屏蔽：屏蔽某些发送给线程的信号。堆栈指针：线程调用别的过程时需要保存局部变量和返回地址等来供返回时能继续执行。线程的实现线程是为了解决进程调度时过于笨重的问题，所以在不同的环境中实现线程的方式不同。根据内核能否感知到线程的存在可分为内核支持线程（Kernel Supported Threads，KST）和用户级线程（User Level Threads，ULT）。它俩的区别是能否直接调用系统服务，前者可以而后者需要借助中间系统。内核支持线程若线程是由内核直接调度，线程资源也是保存在内核空间，就可以说此类线程为内核支持线程。此类线程的创建、撤销和切换等操作都是在内核空间完成的，此时线程可以直接调用系统服务。一种可能的实现方式是在创建进程时分配一个任务数据区（Per Task Data Area，PTDA），各个线程的TCB保存在其中即可。不过仅实现内核支持线程的系统对用户进程创建的线程很不友好，每次线程调度处理机都要从用户态转换到核心态。用户级线程用户级线程是指线程虽客观存在但对内核来说是透明的，此时不能再直接调用系统服务，间接调用系统服务需要有中间系统的支持，通常的中间系统有运行时系统和内核控制线程。运行时系统：把创建线程、撤销线程和线程同步等只能由OS内核完成的操作封装起来作为运行时系统，而运行时系统停留在用户空间供其他进程调用来实现线程调度。内核控制线程：这种线程又被称作轻量进程（Light Weight Process，LWP），它既可以共享进程的资源，又可以使用内核提供的服务。虽然下图中LWP和用户线程是1对1关系，但实际上多个用户级线程可以复用一个LWP，但每个轻型线程都要连接到一个内核线程中。所以此种方式系统需要同时实现内核支持线程。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01-操作系统引论]]></title>
    <url>%2F2019%2F01-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[操作系统的定义操作系统（Operating System，简称OS）是配置在计算机硬件上的第一层软件，是对硬件系统的首次扩充。主要作用是管理硬件设备来提高利用率和吞吐量，同时为用户和应用系统提供易于使用的接口。提高利用率：使系统中各设备的空闲时间尽可能短。提高吞吐量：使单位时间内完成的业务更多。提供易于使用的接口：即是方便使用计算机资源。例如没有操作系统，操纵计算机可能需要用户输入二进制代码，有了操作系统，用户可以点击图标，操作系统就会将其转换成二进制代码。操作系统的目标方便性：即对用户和应用程序提供易于使用的接口。有效性：提高利用率和吞吐量。可扩充性：计算机硬件和体系结构等都在不断发展中，OS需要有好的可扩充性来满足不断发展的需求。开放性：为了使计算机的应用环境从单机转换成网络，OS需要满足相应的软硬件标准来实现设备的互联。操作系统的作用提供易于使用的接口，如Shell、图形界面等。管理计算机所有的资源，负责计算机系统全部资源的分配、控制、调度和回收。隐蔽硬件特性，如计算2*3，某些机器的实现是使用加法器做2+2+2，而有的机器是乘法器实现2*3。操作系统屏蔽这些细节，用户只需要输入2*3就能完成。未配置操作系统的计算机系统人工操作：程序员把程序和数据通过穿孔的方式记录在纸带上，再启动机器读入纸带，运行完成并取走计算结果后，才允许下一个用户上机。缺点：用户独占整机：计算机上的资源为上机用户独占。设备空闲率高：用户装卡，卸卡等人工操作时，设备资源是空闲的。脱机输入/输出（Off-Line I/O）：为了解决人机矛盾及CPU、I/O等设备之间速度的不匹配。它是先把纸带通过输入设备在外围机（与主机相比处于次要地位的计算机）的控制下输入到磁带上，当CPU需要这些信息时再从磁带上高速地调取。类似的，在输出时把信息输出到磁盘中，在外围机的控制下通过输出设备输出。也就是说主机直接对磁盘进行操作，输入输出和程序运行脱离。減少了CPU的空闲时间：主机不必依赖输入输出，可以从磁盘中读取数据。提升了I/O速度：主机读取信息不再是从卡片中读取，从磁盘读取速度较快。批处理系统为了提升计算机资源的利用率和提升计算机的吞吐量研发出了批操作系统。基础概念作业：程序+数据+作业说明书（系统根据说明书来对程序的运行进行控制）。周转时间：从作业进入系统到作业完成退出系统所用的时间。平均周转时间：同时参与系统运行的几个作业的周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NT_i]​$带权周转时间：作业的周转时间（$T​$）和系统为它提供服务的时间（$T_S​$）。$W=\frac{T}{T_s}​$平均带权周转时间：同时参与系统运行的几个作业的带权周转时间的平均值。$T=\frac{1}{n}[\sum_{i=1}^NW_i]​$单道批处理系统设计一个常驻内存的程序（监督程序），操作员有选择地把若干作业合成一批，安装输入设备上，并启动监督程序，然后由监督程序自动控制这批作业运行，从而减少部分人工干预，有效地缩短了作业运行前的准备时间，相对的提高CPU的利用率。同一时刻只有一个硬件在运行。特点：自动性、顺序性、单道性。缺点：I/O的慢速与CPU 的高速不匹配，且输入时需要CPU等待。用户交互性差。作业安装输入后，就不能再交互。多道批处理系统把一个以上的作业存放在主存中，并且同时处于运行状态，使这些作业共享处理机和外部设备等其它系统资源。对于一个单处理机系统来说，作业同时处于运行状态只是宏观的概念，其含义是指每个作业都已开始运行，但尚未完成。就微观而言，在任意特定时刻，处理机上运行的作业只有一个。特点：多道性、无序性、调度性。优缺点：优点：资源利用率高、系统吞吐量大。缺点：作业仍然要排队处理，所以平均周转时间长、无交互能力。此时如何调度程序已经不是再用一张简单的流程图能说明了，第二章会有介绍。下图只是说明处理器利用率高。举例证明资源利用率高和系统吞吐量大设内存中有三道程序 A、B、C，它们的计算和I/O操作的时间如下表所示：程序操作ABC计算306020I/O403040计算101020单道多道分时系统批处理系统中，作业一旦提交就不能进行更改，所以人机交互性很差。为了满足人机交互的需求诞生分时系统。每一个用户通过一台终端与计算机相连，以交互式的命令使用系统，采用分享CPU的方法，由于CPU的速度比人在终端输入指令的时间快得多，所以用户感到自己独占了整个计算机系统。系统规定一个称之为“时间片”的时间单位，所有终端用户轮流享用一个时间片的CPU。需要解决的问题：及时接受：所有终端用户输入的信息都要能够被及时的送到处理器上。所以主机会以很快的速度循环扫描各个终端。每个终端也要拥有缓存区来保存输入的信息。及时处理：用户需要能对自己的作业及其允许及时地实施控制。所以所有的作业必须驻留在内存中，因此批作业系统不能被使用。它采用的方式是：作业直接进入内存。但每个用户只连续使用一个“时间片”的时间，对所有用户进行循环。这样每个用户都能及时地与自己的作业进行交互。分时系统与多道批处理系统的不同特性多路性：允许多个用户共享一台计算机，提高资源利用率。独立性：每个用户之间互不干扰，感觉就是一个人在独占一台计算机。及时性：用户的请求能在很短的时间内得到回应。交互性：用户可以通过终端和计算机进行及时交互。实时系统指系统能及时响应外部事件的请求，在规定的时间内完成对该事件的处理，并控制所有实时任务协调一致地运行。实时系统强调程序运行的时间，它需对接收到的某些信号做出及时地反应。大多数的实时系统是专用系统，如：工业（武器）控制系统、信息查询系统、多媒体系统、嵌入式系统等。最大的特点就是可靠性：系统必须高度可靠，因为任何可能的差错都可能带来灾难性后果，所以系统一般都有多级容错措施。按是否周期执行分类：周期性实时任务：如外部设备周期性地发出状态信号给计算机使其状态能被实时感知。非周期性实时任务：提交给系统时需要指定开始截止时间和完成截止时间。硬实时任务&amp;软实时任务：硬实时任务（Hard Real-time Task）：截止时间到达时任务必须完成，比如武器控制系统。软实时任务（Soft Real-time Task）：截止时间到达时任务没有完成没有太大影响，比如多媒体系统。进程和线程进程：在系统中能独立运行并作为资源分配的基本单位。线程：独立运行的基本单位，比进程更小，基本上不拥有系统资源。通常在一个进程中包含了若干个线程。操作系统的基本特性并发：宏观上是多个进程同时运行，微观上是每一时刻只有一道进程在执行。共享：系统中的资源可供内存中多个并发执行的进程（线程）共同使用。有两种共享方式：互斥共享方式，如打印机；同时访问方式，如共享文件夹、网络资源。虚拟：通过某种技术把一个物理实体变为若干个逻辑上的对应物。这样可以避免一个进程单独占用某个物理设备，一个物理设备被分配给多个进程便可以提升物理设备的使用率。不确定性（异步性）：进程以人们不可预知的速度向前推进，即为进程的不确定性。这样的话很可能是先进入内存的作业后完成；而后进入内存的作业先完成。尽管如此，但只要有合理的进程同步方式且运行环境相同，作业经多次运行，都会获得完全相同的结果。因此，异步运行方式是允许的。操作系统的结构传统操作系统结构无结构OS：关注功能的实现和获得高的效率操作系统是为数众多的一组过程的集合，各过程之间可以相互调用，在操作系统内部不存在任何结构。程序设计的技巧，只是如何编制紧凑的程序，以便于有效地利用内存。操作系统既庞大又杂乱，缺乏清晰的程序结构。程序错误很多，给调试工作带来很多困难；另一方面也使程序难以阅读和理解，增加了维护人员的负担。模块化结构OS模块化程序设计技术，是最早（20世纪60年代）出现的一种程序设计技术。该技术是基于“分解”和“模块”原则来控制大型软件的复杂度的。将OS按其功能划分为若干个具有一定独立性和大小的模块。每个模块具有某方面的管理功能，并规定好各模块间的接口， 使各模块之间能通过该接口实现交互，然后再进一步将各模块细分为若干个具有一定管理功能的子模块。（会导致模块之间的依赖关系很重，OS结构不清晰）若子模块较大时，再进一步将它细分。分层式结构OS：改进设计方式，使每一步设计都是建立在可靠的基础上一层一层地自底向上增添软件层，每一层都实现若干功能，最后总能构成一个能满足需要的OS。每一层都仅使用其底层所提供的功能和服务，这样可使系统的调试和验证都变得容易。一旦发现错误后，通常该错误只会局限于某一层，因为它与所有其高层的软件无关，而此层以下的各层软件，又都经过仔细的调试，bug修复较为容易。客户/服务器结构为了提高OS的灵活性和可扩充性而将OS划分为两部分。一部分是用于提供各种服务的一组服务器（进程），所有这些服务器（进程）都运行在用户态。当有一用户进程（现在称为客户进程）要求读文件的一个盘块时，该进程便向文件服务器（进程）发出一个请求；当服务器完成了该客户的请求后，便给该客户回送一个响应。另一部分是内核，用来处理客户和服务器之间的通信， 即由内核来接收客户的请求，再将该请求送至相应的服务器；同时它也接收服务器的应答， 并将此应答回送给请求客户。此外，在内核中还应具有其它一些机构，用于实现与硬件紧密相关的和一些较基本的功能。面向对象结构（20世纪80年代）该技术是基于“抽象”和“隐蔽”原则来控制大型软件的复杂度的。所谓对象，是指在现实世界中具有相同属性、服从相同规则的一系列事物的抽象，而把其中的具体事物称为对象的实例。OS中的各类实体如进程、线程、消息、存储器等，都使用了对象这一概念，相应地，便有进程对象、线程对象、 存储器对象等。由于隐蔽了表示实体的数据和操作，因而可以改变对象的表示而不会影响其它部分， 从而可以方便地改变老的对象和增加新的对象。继承性。继承性是面向对象技术所具有的重要特性。继承性是指子对象可以继承父对象的属性，这样，在创建一个新的对象时， 便可减少大量的时空开销。正确性和可靠性。由于对象是构成操作系统的基本单元，可以独立地对它进行测试，这样，比较易于保证其正确性和可靠性，从而比较容易保证整个系统的正确性和可靠性。微服务结构（20世纪90年代）能有效支持多处理机，适用于分布式系统环境。以微内核为操作系统核心，以客户/服务器为基础，采用了面向对象的程序设计方法。所谓微内核技术，是指精心设计的、能实现现代OS核心功能的小型内核，它与一般的OS(程序)不同， 它更小更精炼，它不仅运行在核心态，而且开机后常驻内存， 它不会因内存紧张而被换出内存。微内核并非是一个完整的OS， 而只是为构建通用OS提供一个重要基础。在微内核OS结构中，通常都采用了客户/服务器模式，因此OS的大部分功能和服务，都是由若干服务器来提供的， 如文件服务器、作业服务器和网络服务器等。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
</search>
