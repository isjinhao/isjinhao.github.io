<!-- build time:Mon Dec 30 2019 21:34:07 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html class="theme-next mist use-motion" lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script><link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet"><style>.pace .pace-progress{background:#1E92FB;height:3px}.pace .pace-progress-inner{box-shadow:0 0 10px #1E92FB,0 0 5px #1E92FB}.pace .pace-activity{border-top-color:#1E92FB;border-left-color:#1E92FB}</style><meta name="theme-color" content="#222"><link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2"><link rel="stylesheet" href="/css/main.css?v=6.7.0"><link rel="apple-touch-icon" sizes="180x180" href="/images/favicon16x16.ico?v=6.7.0"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon32x32.ico?v=6.7.0"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon16x16.ico?v=6.7.0"><link rel="mask-icon" href="/images/favicon16x16.ico?v=6.7.0" color="#222"><link rel="manifest" href="/images/favicon16x16.ico"><meta name="msapplication-config" content="/images/favicon16x16.ico"><script id="hexo.configurations">var NexT=window.NexT||{},CONFIG={root:"/",scheme:"Mist",version:"6.7.0",sidebar:{position:"left",display:"post",offset:12,b2t:!1,scrollpercent:!1,onmobile:!1},fancybox:!1,fastclick:!1,lazyload:!1,tabs:!0,motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},algolia:{applicationID:"",apiKey:"",indexName:"",hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}}}</script><script>!function(e,t,o,c,i,a,n){e.DaoVoiceObject=i,e[i]=e[i]||function(){(e[i].q=e[i].q||[]).push(arguments)},e[i].l=1*new Date,a=t.createElement(o),n=t.getElementsByTagName(o)[0],a.async=1,a.src=c,a.charset="utf-8",n.parentNode.insertBefore(a,n)}(window,document,"script",("https:"==document.location.protocol?"https:":"http:")+"//widget.daovoice.io/widget/0f81ff2f.js","daovoice"),daovoice("init",{app_id:"28dbf854"}),daovoice("update")</script><meta name="description" content="类型的生命周期生命周期加载：查找并加载类的二进制数据到JVM中（从外存到内存的过程）连接：验证 : 确保被加载的类的正确性准备：为类的静态变量分配内存，并将其初始化为默认值，但是到达初始化之前类变量都没有初始化为真正的初始值解析：把类中的符号引用转换为直接引用，就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程初始化：为类的静态变量赋予正确的初始值初始化Ja"><meta name="keywords" content="Java,JVM"><meta property="og:type" content="article"><meta property="og:title" content="03.01-JVM-类加载机制"><meta property="og:url" content="https://isjinhao.github.io/posts/35597.html/index.html"><meta property="og:site_name" content="ISJINHAO"><meta property="og:description" content="类型的生命周期生命周期加载：查找并加载类的二进制数据到JVM中（从外存到内存的过程）连接：验证 : 确保被加载的类的正确性准备：为类的静态变量分配内存，并将其初始化为默认值，但是到达初始化之前类变量都没有初始化为真正的初始值解析：把类中的符号引用转换为直接引用，就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程初始化：为类的静态变量赋予正确的初始值初始化Ja"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="http://blogfileqiniu.isjinhao.site/c0e21dca-6e8a-4abc-ad89-ce78d41e5c3f"><meta property="og:image" content="http://blogfileqiniu.isjinhao.site/8dfa5630-d565-410f-b279-3edbb89666b7"><meta property="og:image" content="http://blogfileqiniu.isjinhao.site/24a9845e-bf60-4cdd-b956-156cedb97dcf"><meta property="og:image" content="http://blogfileqiniu.isjinhao.site/e5d0c474-d9c1-41d9-9206-e4d57c18659a"><meta property="og:updated_time" content="2019-12-30T13:20:35.714Z"><meta name="twitter:card" content="summary"><meta name="twitter:title" content="03.01-JVM-类加载机制"><meta name="twitter:description" content="类型的生命周期生命周期加载：查找并加载类的二进制数据到JVM中（从外存到内存的过程）连接：验证 : 确保被加载的类的正确性准备：为类的静态变量分配内存，并将其初始化为默认值，但是到达初始化之前类变量都没有初始化为真正的初始值解析：把类中的符号引用转换为直接引用，就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程初始化：为类的静态变量赋予正确的初始值初始化Ja"><meta name="twitter:image" content="http://blogfileqiniu.isjinhao.site/c0e21dca-6e8a-4abc-ad89-ce78d41e5c3f"><link rel="alternate" href="/atom.xml" title="ISJINHAO" type="application/atom+xml"><link rel="canonical" href="https://isjinhao.github.io/posts/35597.html/"><script id="page.configurations">CONFIG.page={sidebar:""}</script><title>03.01-JVM-类加载机制 | ISJINHAO</title><noscript><style>.sidebar-inner,.use-motion .brand,.use-motion .collection-title,.use-motion .comments,.use-motion .menu-item,.use-motion .motion-element,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header{opacity:initial}.use-motion .logo,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line-before i{left:initial}.use-motion .logo-line-after i{right:initial}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN"><div class="container sidebar-position-left page-post-detail"><div class="headband"></div><header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-wrapper"><div class="site-meta"><div class="custom-logo-site-title"><a href="/" class="brand" rel="start"><span class="logo-line-before"><i></i></span> <span class="site-title">ISJINHAO</span> <span class="logo-line-after"><i></i></span></a></div></div><div class="site-nav-toggle"><button aria-label="切换导航栏"><span class="btn-bar"></span> <span class="btn-bar"></span> <span class="btn-bar"></span></button></div></div><nav class="site-nav"><ul id="menu" class="menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i><br>首页</a></li><li class="menu-item menu-item-series"><a href="/series/" rel="section"><i class="menu-item-icon fa fa-fw fa-book"></i><br>系列文章</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i><br>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i><br>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i><br>归档</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i><br>关于</a></li><li class="menu-item menu-item-search"><a href="javascript:;" class="popup-trigger"><i class="menu-item-icon fa fa-search fa-fw"></i><br>搜索</a></li></ul><div class="site-search"><div class="algolia-popup popup search-popup"><div class="algolia-search"><div class="algolia-search-input-icon"><i class="fa fa-search"></i></div><div class="algolia-search-input" id="algolia-search-input"></div></div><div class="algolia-results"><div id="algolia-stats"></div><div id="algolia-hits"></div><div id="algolia-pagination" class="algolia-pagination"></div></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div></div></nav></div></header><main id="main" class="main"><div class="main-inner"><div class="content-wrap"><div id="content" class="content"><div id="posts" class="posts-expand"><article class="post post-type-normal" itemscope itemtype="http://schema.org/Article"><div class="post-block"><link itemprop="mainEntityOfPage" href="https://isjinhao.github.io/posts/35597.html/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="name" content="ISJINHAO"><meta itemprop="description" content="Living & Working"><meta itemprop="image" content="/images/avatar.gif"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="ISJINHAO"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">03.01-JVM-类加载机制</h1><div class="post-meta"><span class="post-time"><span class="post-meta-item-icon"><i class="fa fa-calendar-o"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-12-30 21:20:19 / 修改时间：21:20:35" itemprop="dateCreated datePublished" datetime="2019-12-30T21:20:19+08:00">2019-12-30</time> </span><span class="post-category"><span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-folder-o"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span></span><div class="post-symbolscount"><span class="post-meta-item-icon"><i class="fa fa-file-word-o"></i> </span><span class="post-meta-item-text">本文字数：</span> <span title="本文字数">50k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-clock-o"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span title="阅读时长">45 分钟</span></div></div></header><div class="post-body" itemprop="articleBody"><p><br></p><h2 id="类型的生命周期"><a href="#类型的生命周期" class="headerlink" title="类型的生命周期"></a>类型的生命周期</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><ul><li>加载：查找并加载类的二进制数据到JVM中（从外存到内存的过程）</li><li>连接：<ul><li>验证 : 确保被加载的类的正确性</li><li>准备：为类的<strong>静态变量</strong>分配内存，并将其<strong>初始化为默认值</strong>，但是到达初始化之前类变量都没有初始化为真正的初始值</li><li>解析：把类中的符号引用转换为直接引用，就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程</li></ul></li><li>初始化：为类的静态变量赋予正确的初始值</li></ul><p><br></p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>Java程序对类的使用方式可分为<strong>主动使用</strong>和<strong>被动使用</strong>两种。当且仅当主动使用时才会触发初始化过程。</p><h4 id="主动使用"><a href="#主动使用" class="headerlink" title="主动使用"></a>主动使用</h4><ul><li>创建类的实例（助记符：<code>new</code>）</li><li>访问某个类或接口的静态变量，或者对该静态变量赋值（助记符：<code>getstatic</code>、<code>putstatic</code>）</li><li>调用类的静态方法（助记符：<code>invokestatic</code>）</li><li>反射（<code>Class.forName(xxx)</code>）</li><li>初始化一个类的子类时其父类需要现行初始化</li><li>Java虚拟机启动时被标明启动类的类</li><li>JDK1.7开始提供的动态语言支持（了解）</li></ul><h4 id="被动使用"><a href="#被动使用" class="headerlink" title="被动使用"></a>被动使用</h4><p>除了上面七种情况外，其他使用Java类的方式都被看做是对类的被动使用，都不会导致类的初始化。比如：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread.currentThread().getContextClassLoader().loadClass(<span class="string">"xxx"</span>);	<span class="comment">// 不会初始化</span></span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">        对于静态字段来说，只有直接定义了该字段的类才会被初始化</span></span><br><span class="line"><span class="comment">        当一个类在初始化时，要求父类全部都已经初始化完毕</span></span><br><span class="line"><span class="comment">        -XX:+TraceClassLoading，用于追踪类的加载信息并打印出来</span></span><br><span class="line"><span class="comment">        -XX:+&lt;option&gt;，表示开启option选项</span></span><br><span class="line"><span class="comment">        -XX:-&lt;option&gt;，表示关闭option选项</span></span><br><span class="line"><span class="comment">        -XX:&lt;option&gt;=&lt;value&gt;，表示将option的值设置为value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(MyChild.str);    </span><br><span class="line">        <span class="comment">// 输出：MyParent static block、 hello world   （因为对MyChild不是主动使用）</span></span><br><span class="line">        System.out.println(MyChild.str2);   </span><br><span class="line">        <span class="comment">// 输出：MyParent static block、MyChild static block、welcome</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyParent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChild</span> <span class="keyword">extends</span> <span class="title">MyParent</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String str2 = <span class="string">"welcome"</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyChild static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">        常量在编译阶段会存入到调用这个常量的方法所在的类的常量池中。所以本质上，调用类并没有直接调用到定义常量的</span></span><br><span class="line"><span class="comment">        类，因此并不会触发定义常量的类的初始化。注意：这里指的是将常量存到MyTest2的常量池中，之后MyTest2和</span></span><br><span class="line"><span class="comment">        MyParent就没有任何关系了。甚至我们可以将MyParent2的class文件删除</span></span><br><span class="line"><span class="comment">        助记符 ldc：        表示将int、float或者String类型的常量值从常量池中推送至栈顶</span></span><br><span class="line"><span class="comment">        助记符 bipush：     表示将单字节[128-127]的常量值推送到栈顶，byte int push</span></span><br><span class="line"><span class="comment">        助记符 sipush：     表示将一个短整型值[-32768-32369]推送至栈顶，short int push</span></span><br><span class="line"><span class="comment">        助记符 iconst_1：   表示将int型的1推送至栈顶（iconst_m1到iconst_5）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyParent2.str);    <span class="comment">//输出 hello world</span></span><br><span class="line">        System.out.println(MyParent2.s);</span><br><span class="line">        System.out.println(MyParent2.i);</span><br><span class="line">        System.out.println(MyParent2.j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParent2</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = <span class="string">"hello world"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span> s = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> i = <span class="number">129</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyParent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当一个常量的值并非编译期间可以确定的，那么其值就不会放到调用类的常量池中</span></span><br><span class="line"><span class="comment"> * 这时在程序运行时，会导致主动使用这个常量所在的类，显然会导致这个类被初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyParent3.str);  </span><br><span class="line">        <span class="comment">// 输出MyParent static block、kjqhdun-baoje21w-jxqioj1-2jwejc9029</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParent3</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String str = UUID.randomUUID().toString();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyParent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	使用接口中的变量的时候不需要初始化其父接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoadTest5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyChild2.thread);</span><br><span class="line">        <span class="comment">// thread 初始化了</span></span><br><span class="line">		<span class="comment">// Thread[Thread-0,5,main]</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Student6</span> </span>&#123;</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread 初始化了"</span>);  <span class="comment">//如果父接口初始化了这句应该输出</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyChild2</span> <span class="keyword">extends</span> <span class="title">Student6</span> </span>&#123;</span><br><span class="line">    <span class="comment">// thread2是final变量，但是不会在编译期被放在ClassLoadTest5的常量池中</span></span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"thread2 初始化了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类-接口"><a href="#类-接口" class="headerlink" title="类+接口"></a>类+接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类初始化的时候不需要其接口完成初始化</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyChild8.t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyGrandpa</span> </span>&#123;</span><br><span class="line">    Thread t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyGrandpa init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyParent1</span> <span class="keyword">extends</span> <span class="title">MyGrandpa</span> </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyParent1 init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChild8</span> <span class="keyword">implements</span> <span class="title">MyParent1</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Thread t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyChild8 init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// MyChild8 init</span></span><br><span class="line"><span class="comment">// Thread[Thread-0,5,main]</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest8</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MyChild8.t2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyGrandpa</span> </span>&#123;</span><br><span class="line">    Runnable t = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyGrandpa init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParent1</span> <span class="keyword">implements</span> <span class="title">MyGrandpa</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runnable t1 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyParent1 init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChild8</span> <span class="keyword">extends</span> <span class="title">MyParent1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Runnable t2 = <span class="keyword">new</span> Thread() &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"MyChild8 init"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	MyParent1 init</span></span><br><span class="line"><span class="comment">    MyChild8 init</span></span><br><span class="line"><span class="comment">    Thread[Thread-1,5,main]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="准备阶段和初始化的顺序"><a href="#准备阶段和初始化的顺序" class="headerlink" title="准备阶段和初始化的顺序"></a>准备阶段和初始化的顺序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 准备阶段会把静态变量附上默认值</span></span><br><span class="line"><span class="comment"> * 初始化的时候按从上到下的顺序把变量附上初始值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest6</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton singleton = Singleton.getInstance();</span><br><span class="line">        System.out.println(Singleton.counter1);     <span class="comment">// 1</span></span><br><span class="line">        System.out.println(Singleton.counter2);     <span class="comment">// 0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        counter1++;</span><br><span class="line">        counter2++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> counter2 = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于数组实例来说，其类型是由JVM在运行期动态生成的，表示为 `[L数组元素全限定名` 这种形式。</span></span><br><span class="line"><span class="comment"> * 对于数组来说，JavaDoc将构成数据的元素称为Component，实际上是将数组降低一个维度后的类型。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 助记符：anewarray：表示创建一个引用类型（如类、接口）的数组，并将其引用值压入栈顶</span></span><br><span class="line"><span class="comment"> * 助记符：newarray：表示创建一个指定原始类型（int boolean float double）d的数组，并将其引用值压入栈顶</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="comment">//        MyParent4 myParent4 = new MyParent4();        // 创建类的实例，属于主动使用，会导致类的初始化</span></span><br><span class="line">        MyParent4[] myParent4s = <span class="keyword">new</span> MyParent4[<span class="number">1</span>];      <span class="comment">// 不是主动使用，不会导致类的初始化</span></span><br><span class="line">        System.out.println(myParent4s.getClass());   <span class="comment">// 输出 [[Ltwo.jvm.classloader.MyParent4;</span></span><br><span class="line">        System.out.println(myParent4s.getClass().getSuperclass());    <span class="comment">// 输出Object</span></span><br><span class="line">        <span class="keyword">int</span>[] i = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        System.out.println(i.getClass());          <span class="comment">// 输出 [I</span></span><br><span class="line">        System.out.println(i.getClass().getSuperclass());    <span class="comment">// 输出Object</span></span><br><span class="line">        <span class="comment">// 实际上数组类型是运行期动态加载的，也就是说数组类型是JVM在运行过程中创建的</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParent4</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"MyParent static block"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类的实例化过程"><a href="#类的实例化过程" class="headerlink" title="类的实例化过程"></a>类的实例化过程</h4><ul><li>为新的对象分配内存</li><li>为实例变量赋默认值</li><li>为实例变量赋正确的初始值</li><li>执行构造方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest7</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTest7</span><span class="params">()</span> </span>&#123;    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line">    &#123;</span><br><span class="line">        i = <span class="number">100</span>;</span><br><span class="line">    &#125;	<span class="comment">// 这种代码块会在每次创建一个实例的时候都执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="keyword">new</span> MyTest7().i); <span class="comment">// 100</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="生命周期的几个时机"><a href="#生命周期的几个时机" class="headerlink" title="生命周期的几个时机"></a>生命周期的几个时机</h3><p><strong>类加载</strong></p><p>类加载器并不需要等到某个类被“首次主动使用”时再加载它。JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器不会立即报告错误，而是在程序首次主动使用该类才报告错误（LinkageError错误），如果这个类没有被程序主动使用，那么类加载器就不会报告错误。在使用loadClass的时候只进行类加载过程，不会进行连接。</p><p><strong>连接</strong></p><p>连接的前两个过程笔者没有找到进行的依据，但是第三个过程解析的触发条件是遇到如下字节码：anewarray、checkcast、getfiled、getstatic、instanceof、invokedynamic、invokeinterface、invokespecial、invokestatic、invokevirtual、ldc、ldc_c、multianewarray、new、putfield、putstatic。</p><p><strong>初始化时机</strong></p><p>主动使用</p><p><strong>生命周期的顺序</strong></p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/c0e21dca-6e8a-4abc-ad89-ce78d41e5c3f"></div><p>规范规定，加载、验证、准备、初始化、卸载这五个阶段的是要按顺序进行，但是解析阶段是遇到如上字节码指令才会进行。比如解析可能再初始化之后。</p><p><br></p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ul><li>Java虚拟机自带的加载器<ul><li>根类加载器（Bootstrap）：该加载器没有父加载器，它负责加载虚拟机中的核心类库。根类加载器从系统属性<code>sun.boot.class.path</code>所指定的目录中加载类库。类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有继承<code>java.lang.ClassLoader</code>类。</li><li>扩展类加载器（Extension）：它的父加载器为根类加载器。它从<code>java.ext.dirs</code>系统属性所指定的目录中加载类库，或者从JDK的安装目录的<code>jre\lib\ext</code>子目录（扩展目录）下加载类库，如果把用户创建的jar文件放在这个目录下，也会自动由扩展类加载器加载，扩展类加载器是纯<code>java</code>类，是<code>java.lang.ClassLoader</code>的子类。</li><li>系统应用类加载器（System）：也称为应用类加载器，它的父加载器为扩展类加载器，它从环境变量<code>classpath</code>或者系统属性<code>java.class.path</code>所指定的目录中加载类，他是用户自定义的类加载器的默认父加载器。系统类加载器时纯Java类，是<code>java.lang.ClassLoader</code>的子类。</li></ul></li><li>用户自定义的类加载器<ul><li><code>java.lang.ClassLoader</code>的子类</li><li>用户可以定制类的加载方式<br>根类加载器–&gt;扩展类加载器–&gt;系统应用类加载器–&gt;自定义类加载器</li></ul></li></ul><p><strong>路径</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));  <span class="comment">// 根加载器路径</span></span><br><span class="line">System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));        <span class="comment">// 扩展类加载器路径</span></span><br><span class="line">System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));      <span class="comment">// 应用类加载器路径</span></span><br></pre></td></tr></table></figure><p><br></p><h3 id="ClassLoader"><a href="#ClassLoader" class="headerlink" title="ClassLoader"></a>ClassLoader</h3><blockquote><p>A class loader is an object that is responsible for loading classes. The class ClassLoader is an abstract class. Given the binary name of a class, a class loader should attempt to locate or generate data that constitutes a definition for the class. A typical strategy is to transform the name into a file name and then read a “class file” of that name from a file system.<br>Every Class object contains a reference to the ClassLoader that defined it.<br><strong>Class objects for array classes are not created by class loaders, but are created automatically as required by the Java runtime.</strong> The class loader for an array class, as returned by Class.getClassLoader() is the same as the class loader for its element type; if the element type is a primitive type, then the array class has no class loader.<br>Applications implement subclasses of ClassLoader in order to extend the manner in which the Java virtual machine dynamically loads classes.<br>Class loaders may typically be used by security managers to indicate security domains.<br>The ClassLoader class uses a delegation model to search for classes and resources. Each instance of ClassLoader has an associated parent class loader. When requested to find a class or resource, a ClassLoader instance will delegate the search for the class or resource to its parent class loader before attempting to find the class or resource itself. The virtual machine’s built-in class loader, called the “bootstrap class loader”, does not itself have a parent but may serve as the parent of a ClassLoader instance.<br>Class loaders that support concurrent loading of classes are known as parallel capable class loaders and are required to register themselves at their class initialization time by invoking the ClassLoader.registerAsParallelCapable method. Note that the ClassLoader class is registered as parallel capable by default. However, its subclasses still need to register themselves if they are parallel capable. In environments in which the delegation model is not strictly hierarchical, class loaders need to be parallel capable, otherwise class loading can lead to deadlocks because the loader lock is held for the duration of the class loading process (see loadClass methods).<br>Normally, the Java virtual machine loads classes from the local file system in a platform-dependent manner. For example, on UNIX systems, the virtual machine loads classes from the directory defined by the CLASSPATH environment variable.<br>However, some classes may not originate from a file; they may originate from other sources, such as the network, or they could be constructed by an application. The method defineClass converts an array of bytes into an instance of class Class. Instances of this newly defined class can be created using Class.newInstance.<br>The methods and constructors of objects created by a class loader may reference other classes. To determine the class(es) referred to, the Java virtual machine invokes the loadClass method of the class loader that originally created the class.<br>For example, an application could create a network class loader to download class files from a server. Sample code might look like:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader loader = <span class="keyword">new</span> NetworkClassLoader(host, port);</span><br><span class="line">Object main = loader.loadClass(<span class="string">"Main"</span>, <span class="keyword">true</span>).newInstance();</span><br><span class="line"><span class="comment">// . . .</span></span><br></pre></td></tr></table></figure><p></p></blockquote><p>The network class loader subclass must define the methods findClass and loadClassData to load a class from the network. Once it has downloaded the bytes that make up the class, it should use the method defineClass to create a class instance. A sample implementation is:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NetworkClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    String host;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Class <span class="title">findClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] b = loadClassData(name);</span><br><span class="line">        <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        <span class="comment">// load the class data from the connection</span></span><br><span class="line">        <span class="comment">// . . .</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><p><strong>Binary names</strong></p><p>Any class name provided as a String parameter to methods in ClassLoader must be a binary name as defined by The Java™ Language Specification. Examples of valid class names include:<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"java.lang.String"</span></span><br><span class="line"><span class="string">"javax.swing.JSpinner$DefaultEditor"</span></span><br><span class="line"><span class="string">"java.security.KeyStore$Builder$FileBuilder$1"</span></span><br><span class="line"><span class="string">"java.net.URLClassLoader$3$1"</span></span><br></pre></td></tr></table></figure><p></p><h4 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] strings = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">    System.out.println(strings.getClass().getClassLoader());</span><br><span class="line">    <span class="comment">// 输出null，因为String是BootStrap类加载器加载的</span></span><br><span class="line">    <span class="keyword">int</span>[] ints = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">    System.out.println(ints.getClass().getClassLoader());</span><br><span class="line">    <span class="comment">// 输出null，因为int是原生类型，没有类加载器</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h4><p>如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就加载后返回，否则交给子类加载器完成。（扩展类加载器只会加载jar包）</p><div align="center"><img width="70%" src="http://blogfileqiniu.isjinhao.site/8dfa5630-d565-410f-b279-3edbb89666b7"></div><p>若有一个类能够成功加载Test类，那么这个类加载器被称为<strong>定义类加载器</strong>，所有能成功返回Class对象引用的类加载器（包括定义类加载器）称为<strong>初始类加载器</strong>。</p><p><br></p><h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><h4 id="loadClass"><a href="#loadClass" class="headerlink" title="loadClass"></a>loadClass</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">        <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="comment">// 如果没有被记载</span></span><br><span class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 有爹就找他爹去加载</span></span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 没爹就找BootStrap加载器去加载</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 父亲不能加载的情况下自己加载</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 一个满足双亲委派原则的自定义类加载器需要覆盖此方法</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="findClass"><a href="#findClass" class="headerlink" title="findClass"></a>findClass</h4><blockquote><p>Finds the class with the specified binary name. This method should be overridden by class loader implementations that follow the delegation model for loading classes, and will be invoked by the loadClass method after checking the parent class loader for the requested class. The default implementation throws a ClassNotFoundException.<br>这个方法是上面第29行被调用的方法。如果想保持双亲委派机制（实际推荐），在自定义类加载器的时候不去覆盖loadClass，去覆盖findClass就可以了。</p></blockquote><h4 id="自定义一个类加载器"><a href="#自定义一个类加载器" class="headerlink" title="自定义一个类加载器"></a>自定义一个类加载器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建自定义加载器，继承ClassLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileExtension = <span class="string">".class"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();        <span class="comment">// 将系统类当做该类的父加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String className) &#123;</span><br><span class="line">        System.out.println(<span class="string">"className="</span> + className);</span><br><span class="line">        <span class="keyword">byte</span>[] data = loadClassData(className);</span><br><span class="line">        <span class="keyword">return</span> defineClass(className, data, <span class="number">0</span>, data.length);  <span class="comment">// define方法为父类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.path +  name.replace(<span class="string">"."</span>, <span class="string">"\\"</span>) + <span class="keyword">this</span>.fileExtension);</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> ch;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (ch = is.read())) &#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"two.jvm.classloader.MyTest"</span>);</span><br><span class="line">        <span class="comment">//loadClass是父类方法，在方法内部调用findClass</span></span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 父亲是系统类加载器，根据父类委托机制，MyTest1由AppClassLoader加载了</span></span><br><span class="line"><span class="comment">//        MyClassLoader loader1 = new MyClassLoader("loader1");</span></span><br><span class="line"><span class="comment">//        test(loader1);</span></span><br><span class="line">        <span class="comment">// 仍然是系统类加载器进行加载的，因为路径正好是classpath</span></span><br><span class="line"><span class="comment">//        MyClassLoader loader2 = new MyClassLoader("loader2");</span></span><br><span class="line"><span class="comment">//        loader2.path = "D:\\workspace\\java\\project-workspace\\backend-development-summary\\backend-development-summary\\target\\classes\\";</span></span><br><span class="line"><span class="comment">//        test(loader2);</span></span><br><span class="line">        <span class="comment">// 自定义的类加载器被执行，findClass方法下的输出被打印。前提是当前classpath下不存在MyTest1.class，MyTest16的父加载器-系统类加载器会尝试从classpath中寻找MyTest1。</span></span><br><span class="line">        MyClassLoader loader3 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader3"</span>);</span><br><span class="line">        loader3.path = <span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>;</span><br><span class="line">        test(loader3);</span><br><span class="line">        <span class="comment">// 与3同时存在，输出两个class的hash不同，findClass方法下的输出均被打印，因为类加载器的命名空间不同</span></span><br><span class="line">        MyClassLoader loader4 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader4"</span>);</span><br><span class="line">        loader4.path = <span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>;</span><br><span class="line">        test(loader4);</span><br><span class="line">        <span class="comment">// 将loader3作为父加载器，此次输出的字节码和loader3的一致</span></span><br><span class="line">        MyClassLoader loader5 = <span class="keyword">new</span> MyClassLoader(loader3, <span class="string">"loader3"</span>);</span><br><span class="line">        loader3.path = <span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>;</span><br><span class="line">        test(loader5);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    className=two.jvm.classloader.MyTest</span></span><br><span class="line"><span class="comment">    C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyTest.class</span></span><br><span class="line"><span class="comment">    1554874502</span></span><br><span class="line"><span class="comment">    two.jvm.classloader.MyTest@6e0be858</span></span><br><span class="line"><span class="comment">    className=two.jvm.classloader.MyTest</span></span><br><span class="line"><span class="comment">    C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyTest.class</span></span><br><span class="line"><span class="comment">    1360875712</span></span><br><span class="line"><span class="comment">    two.jvm.classloader.MyTest@60e53b93</span></span><br><span class="line"><span class="comment">    1554874502</span></span><br><span class="line"><span class="comment">    two.jvm.classloader.MyTest@5e2de80c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>命名空间</strong></p><ul><li>每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类构成；</li><li>在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；</li><li>在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类；</li><li>同一命名空间内的类是互相可见的，非同一命名空间内的类是不可见的；</li><li>子加载器可以见到父加载器加载的类，父加载器也能见到子加载器加载的类。</li></ul><p><br></p><h3 id="类的卸载"><a href="#类的卸载" class="headerlink" title="类的卸载"></a>类的卸载</h3><ul><li>当一个类被加载、连接和初始化之后，它的生命周期就开始了。当此类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，类在方法区内的数据也会被卸载。</li><li>一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。</li><li>由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机本身会始终引用这些加载器，而这些类加载器则会始终引用他们所加载的类的Class对象，因此这些Class对象是可触及的。</li><li>由用户自定义的类加载器所加载的类是可以被卸载的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    自定义类加载器加载类的卸载</span></span><br><span class="line"><span class="comment">    -XX:+TraceClassUnloading</span></span><br><span class="line"><span class="comment">    </span></span><br><span class="line"><span class="comment">    jvisualvm 可以查看Java进程的信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    MyClassLoader loader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader2"</span>);</span><br><span class="line">    loader2.path = <span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>;</span><br><span class="line">    test(loader2);</span><br><span class="line">    loader2 = <span class="keyword">null</span>;</span><br><span class="line">    System.gc();   <span class="comment">// 让系统去显式执行垃圾回收</span></span><br><span class="line">    <span class="comment">// 输出的两个对象hashcode值不同，因为前面加载的已经被卸载了</span></span><br><span class="line">    loader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader6"</span>);</span><br><span class="line">    loader2.path = <span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>;</span><br><span class="line">    test(loader2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    className=two.jvm.classloader.MyTest</span></span><br><span class="line"><span class="comment">    C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyTest.class</span></span><br><span class="line"><span class="comment">    1554874502</span></span><br><span class="line"><span class="comment">    two.jvm.classloader.MyTest@6e0be858</span></span><br><span class="line"><span class="comment">    [Unloading class two.jvm.classloader.MyTest 0x0000000100061028]</span></span><br><span class="line"><span class="comment">    className=two.jvm.classloader.MyTest</span></span><br><span class="line"><span class="comment">    C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyTest.class</span></span><br><span class="line"><span class="comment">    1360875712</span></span><br><span class="line"><span class="comment">    two.jvm.classloader.MyTest@60e53b93</span></span><br><span class="line"><span class="comment">    [Unloading class two.jvm.classloader.MyTest 0x0000000100061028]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ul><p><br></p><h3 id="命名空间解析"><a href="#命名空间解析" class="headerlink" title="命名空间解析"></a>命名空间解析</h3><p><strong>定于两个辅助类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySample is loaded... "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">new</span> MyCat();</span><br><span class="line">        System.out.println(<span class="string">"from MySample: "</span> + MyCat.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat is loaded... "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line"><span class="comment">//        System.out.println("from MyCat: " + MySample.class);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>操作1：</strong></p><ol><li>外部文件有MySample和MyCat字节码</li><li>classpath下只有MySample字节码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建自定义加载器，继承ClassLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileExtension = <span class="string">".class"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();        <span class="comment">//将系统类当做该类的父加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String className) &#123;</span><br><span class="line">        System.out.println(<span class="string">"className="</span> + className);</span><br><span class="line">        <span class="keyword">byte</span>[] data = loadClassData(className);</span><br><span class="line">        <span class="keyword">return</span> defineClass(className, data, <span class="number">0</span>, data.length); <span class="comment">//define方法为父类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.path + name.replace(<span class="string">"."</span>, <span class="string">"\\"</span>) + <span class="keyword">this</span>.fileExtension);</span><br><span class="line">            System.out.println(file.getAbsolutePath());</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> ch;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (ch = is.read())) &#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; clazz = classLoader.loadClass(<span class="string">"two.jvm.classloader.MyTest"</span>);</span><br><span class="line">        <span class="comment">//loadClass是父类方法，在方法内部调用findClass</span></span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        Object object = clazz.newInstance();</span><br><span class="line">        System.out.println(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader1"</span>);</span><br><span class="line">        loader1.setPath(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz = loader1.loadClass(<span class="string">"two.jvm.classloader.MySample"</span>);</span><br><span class="line">        System.out.println(clazz.hashCode());</span><br><span class="line">        clazz.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">312714112</span></span><br><span class="line"><span class="comment">MySample is loaded... sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.NoClassDefFoundError: two/jvm/classloader/MyCat</span></span><br><span class="line"><span class="comment">	at two.jvm.classloader.MySample.&lt;init&gt;(MySample.java:6)</span></span><br><span class="line"><span class="comment">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span></span><br><span class="line"><span class="comment">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span></span><br><span class="line"><span class="comment">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span></span><br><span class="line"><span class="comment">	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span></span><br><span class="line"><span class="comment">	at java.lang.Class.newInstance(Class.java:442)</span></span><br><span class="line"><span class="comment">	at two.jvm.classloader.MyClassLoader.main(MyClassLoader.java:83)</span></span><br><span class="line"><span class="comment">Caused by: java.lang.ClassNotFoundException: two.jvm.classloader.MyCat</span></span><br><span class="line"><span class="comment">	at java.net.URLClassLoader.findClass(URLClassLoader.java:382)</span></span><br><span class="line"><span class="comment">	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span></span><br><span class="line"><span class="comment">	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)</span></span><br><span class="line"><span class="comment">	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span></span><br><span class="line"><span class="comment">	... 7 more</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">由于MySample是由AppClassLoader加载的，所以new MyCat()使用的是MySample的的类加载器，但是AppClassLoader的命名空间下无法加载MyCat，所以报错。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>操作2：</strong></p><ol><li>外部文件有MySample和MyCat字节码</li><li>classpath下只有MyCat字节码<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">className=two.jvm.classloader.MySample</span></span><br><span class="line"><span class="comment">C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MySample.class</span></span><br><span class="line"><span class="comment">1554874502</span></span><br><span class="line"><span class="comment">MySample is loaded... two.jvm.classloader.MyClassLoader@12a3a380</span></span><br><span class="line"><span class="comment">MyCat is loaded... sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">from MySample: class two.jvm.classloader.MyCat</span></span><br><span class="line"><span class="comment">由于MySample是由MyClassLoader加载的，所以new MyCat()使用的是MySample的的类加载器，但是MyClassLoader的父加载器是可以加载MyCat的，所以MyCat是由AppClassLoader加载的。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>操作3</strong></p><ol><li>外部文件有MySample和MyCat字节码</li><li>classpath下只有MyCat字节码</li><li>修改MyCat为<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat is loaded... "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"from MyCat: "</span> + MySample.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">className=two.jvm.classloader.MySample</span></span><br><span class="line"><span class="comment">C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MySample.class</span></span><br><span class="line"><span class="comment">1554874502</span></span><br><span class="line"><span class="comment">MySample is loaded... two.jvm.classloader.MyClassLoader@12a3a380</span></span><br><span class="line"><span class="comment">MyCat is loaded... sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.NoClassDefFoundError: two/jvm/classloader/MySample</span></span><br><span class="line"><span class="comment">	at two.jvm.classloader.MyCat.&lt;init&gt;(MyCat.java:6)</span></span><br><span class="line"><span class="comment">	at two.jvm.classloader.MySample.&lt;init&gt;(MySample.java:6)</span></span><br><span class="line"><span class="comment">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span></span><br><span class="line"><span class="comment">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:62)</span></span><br><span class="line"><span class="comment">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)</span></span><br><span class="line"><span class="comment">	at java.lang.reflect.Constructor.newInstance(Constructor.java:423)</span></span><br><span class="line"><span class="comment">	at java.lang.Class.newInstance(Class.java:442)</span></span><br><span class="line"><span class="comment">	at two.jvm.classloader.MyClassLoader.main(MyClassLoader.java:83)</span></span><br><span class="line"><span class="comment">Caused by: java.lang.ClassNotFoundException: two.jvm.classloader.MySample</span></span><br><span class="line"><span class="comment">	at java.net.URLClassLoader.findClass(URLClassLoader.java:382)</span></span><br><span class="line"><span class="comment">	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span></span><br><span class="line"><span class="comment">	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)</span></span><br><span class="line"><span class="comment">	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span></span><br><span class="line"><span class="comment">	... 8 more</span></span><br><span class="line"><span class="comment">MySample是由MyClassLoader加载的，MyCat是由AppClassLoader加载的，在AppClassLoader中不能访问子加载器加载的类。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><p><strong>操作4</strong></p><p>MySample和MyCat如下：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySample</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MySample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MySample is loaded... "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line">        <span class="keyword">new</span> MyCat();</span><br><span class="line">        System.out.println(<span class="string">"from MySample: "</span> + MyCat.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCat</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyCat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyCat is loaded... "</span> + <span class="keyword">this</span>.getClass().getClassLoader());</span><br><span class="line"><span class="comment">//        System.out.println("from MyCat: " + MySample.class);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">className=two.jvm.classloader.MySample</span><br><span class="line">C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MySample.class</span><br><span class="line"><span class="number">1554874502</span></span><br><span class="line">MySample is loaded... two.jvm.classloader.MyClassLoader@<span class="number">12</span>a3a380</span><br><span class="line">MyCat is loaded... sun.misc.Launcher$AppClassLoader@<span class="number">18</span>b4aac2</span><br><span class="line">from MySample: <span class="class"><span class="keyword">class</span> <span class="title">two</span>.<span class="title">jvm</span>.<span class="title">classloader</span>.<span class="title">MyCat</span></span></span><br></pre></td></tr></table></figure><p>正常。因为MySample是由MyClassLoader加载的，MyCat是由AppClassLoader加载的，在MyClassLoader中可以访问父加载器加载的类。</p><p><strong>命名空间与强转问题</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyPerson</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MyPerson person;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyPerson</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.person = (MyPerson) object;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest21</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader1"</span>);</span><br><span class="line">        MyClassLoader loader2 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader2"</span>);</span><br><span class="line">        loader1.setPath(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>);</span><br><span class="line">        loader2.setPath(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>);</span><br><span class="line">        <span class="comment">// 删掉classpath下的MyPerson类</span></span><br><span class="line">        Class&lt;?&gt; clazz1 = loader1.loadClass(<span class="string">"two.jvm.classloader.MyPerson"</span>);</span><br><span class="line">        Class&lt;?&gt; clazz2 = loader2.loadClass(<span class="string">"two.jvm.classloader.MyPerson"</span>);</span><br><span class="line">        <span class="comment">// clazz1和clazz2由loader1和loader2加载，结果为false</span></span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line">        Object object1 = clazz1.newInstance();</span><br><span class="line">        Object object2 = clazz2.newInstance();</span><br><span class="line">        Method method = clazz1.getMethod(<span class="string">"setMyPerson"</span>, Object.class);</span><br><span class="line">        <span class="comment">// 此处报错，如图所示，loader1和loader2所处不用的命名空间</span></span><br><span class="line">        method.invoke(object1, object2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">className=two.jvm.classloader.MyPerson</span></span><br><span class="line"><span class="comment">C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyPerson.class</span></span><br><span class="line"><span class="comment">className=two.jvm.classloader.MyPerson</span></span><br><span class="line"><span class="comment">C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyPerson.class</span></span><br><span class="line"><span class="comment">false</span></span><br><span class="line"><span class="comment">Exception in thread "main" java.lang.reflect.InvocationTargetException</span></span><br><span class="line"><span class="comment">	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span></span><br><span class="line"><span class="comment">	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span></span><br><span class="line"><span class="comment">	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span></span><br><span class="line"><span class="comment">	at java.lang.reflect.Method.invoke(Method.java:498)</span></span><br><span class="line"><span class="comment">	at two.jvm.classloader.MyTest21.main(MyTest21.java:22)</span></span><br><span class="line"><span class="comment">Caused by: java.lang.ClassCastException: two.jvm.classloader.MyPerson cannot be cast to two.jvm.classloader.MyPerson</span></span><br><span class="line"><span class="comment">	at two.jvm.classloader.MyPerson.setMyPerson(MyPerson.java:7)</span></span><br><span class="line"><span class="comment">	... 5 more</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><div align="center"><img width="40%" src="http://blogfileqiniu.isjinhao.site/24a9845e-bf60-4cdd-b956-156cedb97dcf"></div><h4 id="双亲委托机制的好处"><a href="#双亲委托机制的好处" class="headerlink" title="双亲委托机制的好处"></a>双亲委托机制的好处</h4><ul><li>可以确保Java和核心库的安全：所有的Java应用都会引用java.lang中的类，也就是说在运行期java.lang中的类会被加载到虚拟机中，如果这个加载过程如果是由自己的类加载器所加载，那么很可能就会在JVM中存在多个版本的java.lang中的类，而且这些类是相互不可见的（命名空间的作用）。借助于双亲委托机制，Java核心类库中的类的加载工作都是由启动根加载器去加载，从而确保了Java应用所使用的的都是同一个版本的Java核心类库，他们之间是相互兼容的；</li><li>确保Java核心类库中的类不会被自定义的类所替代；</li><li>不同的类加载器可以为相同名称的类（binary name）创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器去加载即可。相当于在Java虚拟机内部建立了一个又一个相互隔离的Java类空间。</li></ul><p><br></p><h3 id="getSystemClassLoader"><a href="#getSystemClassLoader" class="headerlink" title="getSystemClassLoader()"></a>getSystemClassLoader()</h3><blockquote><p>Returns the system class loader for delegation. This is the default delegation parent for new ClassLoader instances, and is typically the class loader used to start the application.<br><strong>This method is first invoked early in the runtime’s startup sequence, at which point it creates the system class loader and sets it as the context class loader of the invoking Thread.</strong><br>The default system class loader is an implementation-dependent instance of this class.<br>If the system property “java.system.class.loader” is defined when this method is first invoked then the value of that property is taken to be the name of a class that will be returned as the system class loader. The class is loaded using the default system class loader and must define a public constructor that takes a single parameter of type ClassLoader which is used as the delegation parent. An instance is then created using this constructor with the default system class loader as the parameter. The resulting class loader is defined to be the system class loader.<br>自定义类加载器的双亲默认是<code>getSystemClassLoader()返回的实例</code>，启动应用（运行main方法）的类加载器亦是。从文档可以看出此方法会很早就被JVM调用一次，此次调用的时候初始化<code>AppClasLoader</code>。实际上，拓展类加载器也是在这个阶段。</p></blockquote><p><br></p><h3 id="指定SystemClassLoader"><a href="#指定SystemClassLoader" class="headerlink" title="指定SystemClassLoader"></a>指定SystemClassLoader</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">在classes文件夹下运行，指定系统类加载器</span><br><span class="line">java -Djava.system.class.loader=two.jvm.classloader.MyClassLoader two.jvm.cla</span><br><span class="line">ssloader.MyTest23</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    在运行期，一个Java类是由该类的完全限定名（binary name）和用于加载该类的定义类加载器所共同决定的。如果同样名字（完全相同限定名）是由两个不同的加载器所加载，那么这些类就是不同的，即便.class文件字节码相同，并且从相同的位置加载亦如此。</span></span><br><span class="line"><span class="comment">    在oracle的hotspot，系统属性sun.boot.class.path如果修改错了，则运行会出错：</span></span><br><span class="line"><span class="comment">    Error occurred during initialization of VM</span></span><br><span class="line"><span class="comment">    java/lang/NoClassDeFoundError: java/lang/Object</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest23</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"sun.boot.class.path"</span>));</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.ext.dirs"</span>));</span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.class.path"</span>));</span><br><span class="line">        System.out.println(<span class="string">"-----------"</span>);</span><br><span class="line">        System.out.println(ClassLoader.class.getClassLoader());</span><br><span class="line">        System.out.println(Launcher.class.getClassLoader());</span><br><span class="line">        <span class="comment">// 下面的系统属性指定系统类加载器，默认是AppClassLoader</span></span><br><span class="line">        System.out.println(System.getProperty(<span class="string">"java.system.class.loader"</span>));</span><br><span class="line">        ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();</span><br><span class="line">		<span class="comment">// 上面官方文档的解释，会将AppClassLoader设置为指定系统类加载器的父亲</span></span><br><span class="line">        System.out.println(systemClassLoader.getParent());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">需要加入一个新的构造方法：</span></span><br><span class="line"><span class="comment">    public MyClassLoader(ClassLoader parent) &#123;</span></span><br><span class="line"><span class="comment">        super(parent);      //显式指定该类的父加载器</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">从终端启动：&gt;java -Djava.system.class.loader=two.jvm.classloader.MyClassLoader two.jvm.cla</span></span><br><span class="line"><span class="comment">ssloader.MyTest23</span></span><br><span class="line"><span class="comment">D:\Java\jdk\jre\lib\resources.jar;D:\Java\jdk\jre\lib\rt.jar;D:\Java\jdk\jre\lib\sunrsasign.jar;D:\Java\jdk\jre\lib\jsse.jar;D:\Java\jdk\jre\lib\jce.jar;D:\Java\jdk\jre\lib\charsets.ja</span></span><br><span class="line"><span class="comment">r;D:\Java\jdk\jre\lib\jfr.jar;D:\Java\jdk\jre\classes</span></span><br><span class="line"><span class="comment">D:\Java\jdk\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext</span></span><br><span class="line"><span class="comment">.</span></span><br><span class="line"><span class="comment">-----------</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">null</span></span><br><span class="line"><span class="comment">two.jvm.classloader.MyClassLoader</span></span><br><span class="line"><span class="comment">sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="三个自带的类加载器初始化流程分析"><a href="#三个自带的类加载器初始化流程分析" class="headerlink" title="三个自带的类加载器初始化流程分析"></a>三个自带的类加载器初始化流程分析</h4><p>由于三个自带的类加载器初始化涉及的代码较多，所以下面只是按照方法的执行顺序来进行分析。而方法的起始便是我们之前提过的<code>getSystemClassLoader()</code>，这个方法在JVM后很早期就会被调用。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The class loader for the system</span></span><br><span class="line"><span class="comment">// @GuardedBy("ClassLoader.class")</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ClassLoader scl;</span><br><span class="line"><span class="comment">// 如果没有初始化，初始化，否则返回SystemClassLoader，默认是AppClassLoader</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    initSystemClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (scl == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SecurityManager sm = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">        checkClassLoaderPermission(scl, Reflection.getCallerClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> scl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Set to true once the system class loader has been set</span></span><br><span class="line"><span class="comment">// @GuardedBy("ClassLoader.class")</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> sclSet;</span><br><span class="line"><span class="comment">// 初始化系统类加载器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initSystemClassLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 没有被初始化过</span></span><br><span class="line">    <span class="keyword">if</span> (!sclSet) &#123;</span><br><span class="line">        <span class="keyword">if</span> (scl != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"recursive invocation"</span>);</span><br><span class="line">        <span class="comment">// 获得Launcher，在Launcher的构造方法中初始化拓展类加载器和AppClassLoader</span></span><br><span class="line">        sun.misc.Launcher l = sun.misc.Launcher.getLauncher();</span><br><span class="line">        <span class="keyword">if</span> (l != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Throwable oops = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">// 获得AppClassLoader</span></span><br><span class="line">            scl = l.getClassLoader();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 如果类加载器是被-Djava.system.class.loader指定的，通过这一步设置给scl</span></span><br><span class="line">                scl = AccessController.doPrivileged(<span class="keyword">new</span> SystemClassLoaderAction(scl));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException pae) &#123;</span><br><span class="line">                oops = pae.getCause();</span><br><span class="line">                <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> InvocationTargetException) &#123;</span><br><span class="line">                    oops = oops.getCause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (oops != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (oops <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> (Error) oops;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// wrap the exception</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(oops);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sclSet = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Launcher launcher = <span class="keyword">new</span> Launcher();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Launcher <span class="title">getLauncher</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> launcher; &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Launcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Launcher.ExtClassLoader var1;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var1 = Launcher.ExtClassLoader.getExtClassLoader();  <span class="comment">// 获得拓展类加载器</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var10) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create extension class loader"</span>, var10);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create application class loader"</span>, var9);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 设置线程上下文类加载器</span></span><br><span class="line">    Thread.currentThread().setContextClassLoader(<span class="keyword">this</span>.loader);</span><br><span class="line">    String var2 = System.getProperty(<span class="string">"java.security.manager"</span>);</span><br><span class="line">    <span class="keyword">if</span> (var2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        SecurityManager var3 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="string">""</span>.equals(var2) &amp;&amp; !<span class="string">"default"</span>.equals(var2)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                var3 = (SecurityManager)<span class="keyword">this</span>.loader.loadClass(var2).newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception xxx) &#123;            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;   var3 = <span class="keyword">new</span> SecurityManager();       &#125;</span><br><span class="line">        <span class="keyword">if</span> (var3 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(<span class="string">"Could not create SecurityManager: "</span> + var2);</span><br><span class="line">        &#125;</span><br><span class="line">        System.setSecurityManager(var3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">getExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Class var0 = Launcher.ExtClassLoader.class;</span><br><span class="line">        <span class="keyword">synchronized</span>(Launcher.ExtClassLoader.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123; instance = createExtClassLoader(); &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 构建一个拓展类加载器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Launcher.<span class="function">ExtClassLoader <span class="title">createExtClassLoader</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (Launcher.ExtClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedExceptionAction&lt;Launcher.ExtClassLoader&gt;() &#123;</span><br><span class="line">            <span class="comment">// 获得ExtDirs并且构建 拓展类加载器</span></span><br><span class="line">            <span class="comment">// 由于拓展类加载器继承了URLClassLoader，给定File便可以进行加载</span></span><br><span class="line">            <span class="keyword">public</span> Launcher.<span class="function">ExtClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">                File[] var1 = Launcher.ExtClassLoader.getExtDirs();</span><br><span class="line">                <span class="keyword">int</span> var2 = var1.length;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> var3 = <span class="number">0</span>; var3 &lt; var2; ++var3) &#123;</span><br><span class="line">                    MetaIndex.registerDirectory(var1[var3]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> Launcher.ExtClassLoader(var1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PrivilegedActionException var1) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (IOException)var1.getException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获得java.ext.dirs属性对应的jar包</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> File[] getExtDirs() &#123;</span><br><span class="line">    String var0 = System.getProperty(<span class="string">"java.ext.dirs"</span>);</span><br><span class="line">    File[] var1;</span><br><span class="line">    <span class="keyword">if</span> (var0 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        StringTokenizer var2 = <span class="keyword">new</span> StringTokenizer(var0, File.pathSeparator);</span><br><span class="line">        <span class="keyword">int</span> var3 = var2.countTokens();</span><br><span class="line">        var1 = <span class="keyword">new</span> File[var3];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> var4 = <span class="number">0</span>; var4 &lt; var3; ++var4) &#123; var1[var4] = <span class="keyword">new</span> File(var2.nextToken()); &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; var1 = <span class="keyword">new</span> File[<span class="number">0</span>];  &#125;</span><br><span class="line">    <span class="keyword">return</span> var1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取AppClassLoader</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClassLoader <span class="title">getAppClassLoader</span><span class="params">(<span class="keyword">final</span> ClassLoader var0)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// jars由java.class.path属性指定</span></span><br><span class="line">    <span class="keyword">final</span> String var1 = System.getProperty(<span class="string">"java.class.path"</span>);</span><br><span class="line">    <span class="keyword">final</span> File[] var2 = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> File[<span class="number">0</span>] : Launcher.getClassPath(var1);</span><br><span class="line">    <span class="keyword">return</span> (ClassLoader)AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Launcher.AppClassLoader&gt;() &#123;</span><br><span class="line">        <span class="keyword">public</span> Launcher.<span class="function">AppClassLoader <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            URL[] var1x = var1 == <span class="keyword">null</span> ? <span class="keyword">new</span> URL[<span class="number">0</span>] : Launcher.pathToURLs(var2);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Launcher.AppClassLoader(var1x, var0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SystemClassLoaderAction</span> <span class="keyword">implements</span> <span class="title">PrivilegedExceptionAction</span>&lt;<span class="title">ClassLoader</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ClassLoader parent;</span><br><span class="line">    SystemClassLoaderAction(ClassLoader parent) &#123;  <span class="keyword">this</span>.parent = parent;  &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ClassLoader <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String cls = System.getProperty(<span class="string">"java.system.class.loader"</span>);</span><br><span class="line">        <span class="comment">// 如果没有设置java.system.class.loader，返回parent</span></span><br><span class="line">        <span class="keyword">if</span> (cls == <span class="keyword">null</span>) &#123;   <span class="keyword">return</span> parent;   &#125;</span><br><span class="line">        <span class="comment">// 调用自定义类加载器中能接受一个 parentClassLoader 的构造方法</span></span><br><span class="line">        Constructor&lt;?&gt; ctor = Class.forName(cls, <span class="keyword">true</span>, parent)</span><br><span class="line">            .getDeclaredConstructor(<span class="keyword">new</span> Class&lt;?&gt;[] &#123; ClassLoader.class &#125;);</span><br><span class="line">        ClassLoader sys = (ClassLoader) ctor.newInstance(</span><br><span class="line">            <span class="keyword">new</span> Object[] &#123; parent &#125;);</span><br><span class="line">        <span class="comment">// 更新线程上下文类加载器</span></span><br><span class="line">        Thread.currentThread().setContextClassLoader(sys);</span><br><span class="line">        <span class="keyword">return</span> sys;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><br></p><h3 id="Class-forName"><a href="#Class-forName" class="headerlink" title="Class.forName"></a>Class.forName</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">name：class name</span></span><br><span class="line"><span class="comment">initialize: 是否初始化</span></span><br><span class="line"><span class="comment">loader: 类加载器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String name, <span class="keyword">boolean</span> initialize, ClassLoader loader)</span><br></pre></td></tr></table></figure><blockquote><p>Returns the Class object associated with the class or interface with the given string name, using the given class loader. Given the fully qualified name for a class or interface (in the same format returned by getName) this method attempts to locate, load, and link the class or interface. The specified class loader is used to load the class or interface. If the parameter loader is null, the class is loaded through the bootstrap class loader. The class is initialized only if the initialize parameter is true and if it has not been initialized earlier.<br>If name denotes a primitive type or void, an attempt will be made to locate a user-defined class in the unnamed package whose name is name. Therefore, this method cannot be used to obtain any of the Class objects representing primitive types or void.<br>If name denotes an array class, the component type of the array class is loaded but not initialized.<br>For example, in an instance method the expression:<br>Class.forName(“Foo”)<br>is equivalent to:<br>Class.forName(“Foo”, true, this.getClass().getClassLoader())<br>Note that this method throws errors related to loading, linking or initializing as specified in Sections 12.2, 12.3 and 12.4 of The Java Language Specification. Note that this method does not check whether the requested class is accessible to its caller.<br>If the loader is null, and a security manager is present, and the caller’s class loader is not null, then this method calls the security manager’s checkPermission method with a RuntimePermission(“getClassLoader”) permission to ensure it’s ok to access the bootstrap class loader.<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认初始化</span></span><br><span class="line"><span class="comment">// 默认的类加载器是调用者的类加载器</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Class&lt;?&gt; forName(String className)</span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    Class&lt;?&gt; caller = Reflection.getCallerClass();</span><br><span class="line">    <span class="keyword">return</span> forName0(className, <span class="keyword">true</span>, ClassLoader.getClassLoader(caller), caller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></blockquote><p><br></p><h3 id="线程上下文类加载器"><a href="#线程上下文类加载器" class="headerlink" title="线程上下文类加载器"></a>线程上下文类加载器</h3><h4 id="当前类加载器"><a href="#当前类加载器" class="headerlink" title="当前类加载器"></a><strong>当前类加载器</strong></h4><p>每个类都会使用自己的类加载器（即加载自身的类加载器）来去加载其他类（指的是所依赖的类），如果classX引用了classY，那么加载classX的类加载器就会去加载classY。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest24</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader myClassLoader = <span class="keyword">new</span> MyClassLoader(<span class="string">"myclassloader"</span>);</span><br><span class="line">        myClassLoader.setPath(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>);</span><br><span class="line">        Class.forName(<span class="string">"two.jvm.classloader.Test1"</span>, <span class="keyword">true</span>, myClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Test2 test2 = <span class="keyword">new</span> Test2();</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// Test2是由MyClassLoader加载的</span></span><br><span class="line">        System.out.println(test2.getClass().getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span> </span>&#123;   &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从外部加载class文件：</span></span><br><span class="line"><span class="comment">    className=two.jvm.classloader.Test1</span></span><br><span class="line"><span class="comment">    C:\Users\ISJINHAO\Desktop\two\jvm\classloader\Test1.class</span></span><br><span class="line"><span class="comment">    className=two.jvm.classloader.Test2</span></span><br><span class="line"><span class="comment">    C:\Users\ISJINHAO\Desktop\two\jvm\classloader\Test2.class</span></span><br><span class="line"><span class="comment">    two.jvm.classloader.MyClassLoader@4554617c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p>这时候我们有一个问题，就是如果有一个类加载器委托模型如图：</p><div align="center"><img width="80%" src="http://blogfileqiniu.isjinhao.site/e5d0c474-d9c1-41d9-9206-e4d57c18659a"></div><p>如果我们用loader1加载classX，loader1的父加载器是AppClassLoader，在classX中有一个classY成员变量。JVM是使用AppClassLoader加载classY，还是使用loader1加载classY，再委托给AppClassLoader？测试如下<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest26</span> </span>&#123;</span><br><span class="line">    MyTest27 myTest27 = <span class="keyword">new</span> MyTest27();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest27</span> </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest25</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MyClassLoader loader1 = <span class="keyword">new</span> MyClassLoader(<span class="string">"loader1"</span>);</span><br><span class="line">        loader1.setPath(<span class="string">"C:\\Users\\ISJINHAO\\Desktop\\"</span>);</span><br><span class="line">        Class&lt;?&gt; aClass = loader1.loadClass(<span class="string">"two.jvm.classloader.MyTest26"</span>);</span><br><span class="line">        aClass.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建自定义加载器，继承ClassLoader</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyClassLoader</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String classLoaderName;</span><br><span class="line">    <span class="keyword">private</span> String path = <span class="string">""</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String fileExtension = <span class="string">".class"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClassLoader</span><span class="params">(String classLoaderName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();        <span class="comment">// 将系统类当做该类的父加载器</span></span><br><span class="line">        <span class="keyword">this</span>.classLoaderName = classLoaderName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPath</span><span class="params">(String path)</span> </span>&#123; <span class="keyword">this</span>.path = path; &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String className) &#123;</span><br><span class="line">        System.out.println(<span class="string">"className="</span> + className);</span><br><span class="line">        System.out.println(<span class="string">"classLoaderName="</span> + classLoaderName);</span><br><span class="line">        <span class="keyword">byte</span>[] data = loadClassData(className);</span><br><span class="line">        <span class="keyword">return</span> defineClass(className, data, <span class="number">0</span>, data.length); <span class="comment">//define方法为父类方法</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        InputStream is = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] data = <span class="keyword">null</span>;</span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            File file = <span class="keyword">new</span> File(<span class="keyword">this</span>.path + <span class="string">"\\"</span> + name.replace(<span class="string">"."</span>, <span class="string">"\\"</span>) + <span class="keyword">this</span>.fileExtension);</span><br><span class="line">            System.out.println(file.exists() + <span class="string">" "</span> + file.getAbsolutePath());</span><br><span class="line">            is = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">int</span> ch;</span><br><span class="line">            <span class="keyword">while</span> (-<span class="number">1</span> != (ch = is.read())) &#123;</span><br><span class="line">                baos.write(ch);</span><br><span class="line">            &#125;</span><br><span class="line">            data = baos.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (is != <span class="keyword">null</span>)</span><br><span class="line">                    is.close();</span><br><span class="line">                <span class="keyword">if</span> (baos != <span class="keyword">null</span>)</span><br><span class="line">                    baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>操作步骤1</strong></p><ol><li>删除当前类路径下的MyTest27</li><li>“C:\Users\ISJINHAO\Desktop\“路径下有MyTest26和MyTest27</li></ol><p><strong>结果</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.NoClassDefFoundError: two/jvm/classloader/MyTest27</span><br><span class="line">	at two.jvm.classloader.MyTest26.&lt;init&gt;(MyTest26.java:<span class="number">5</span>)</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)</span><br><span class="line">	at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:<span class="number">62</span>)</span><br><span class="line">	at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:<span class="number">45</span>)</span><br><span class="line">	at java.lang.reflect.Constructor.newInstance(Constructor.java:<span class="number">423</span>)</span><br><span class="line">	at java.lang.Class.newInstance(Class.java:<span class="number">442</span>)</span><br><span class="line">	at two.jvm.classloader.MyTest25.main(MyTest25.java:<span class="number">10</span>)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: two.jvm.classloader.MyTest27</span><br><span class="line">	at java.net.URLClassLoader.findClass(URLClassLoader.java:<span class="number">382</span>)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">424</span>)</span><br><span class="line">	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:<span class="number">349</span>)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:<span class="number">357</span>)</span><br><span class="line">	... <span class="number">7</span> more</span><br></pre></td></tr></table></figure><p><strong>操作步骤2</strong></p><ol><li>删除当前类路径下的MyTest27和MyTest26</li><li>“C:\Users\ISJINHAO\Desktop\“路径下有MyTest26和MyTest27</li></ol><p><strong>结果</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">className=two.jvm.classloader.MyTest26</span><br><span class="line">classLoaderName=loader1</span><br><span class="line">true C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyTest26.class</span><br><span class="line">className=two.jvm.classloader.MyTest27</span><br><span class="line">classLoaderName=loader1</span><br><span class="line">true C:\Users\ISJINHAO\Desktop\two\jvm\classloader\MyTest27.class</span><br></pre></td></tr></table></figure><p><strong>分析</strong></p><p>操作1里面loader1加载MyTest26，loader1委托给AppClassLoader，所以MyTest26是被AppClassLoader加载的，如果MyTest27是由被loader1加载，再委托给AppClassLoader的，AppClassLoader无法加载，再交由loader1，如此一来，MyTest27可以顺利加载。实际上无法顺利加载，说明MyTest27是直接被交给AppClassLoader的，AppClassLoader无法加载，所以有ClassNotFoundException。<br>操作2里面loader1加载MyTest26，loader1委托给AppClassLoader，AppClassLoader无法加载，再交给loader1，loader1从“C:\Users\ISJINHAO\Desktop\”路径下加载MyTest26，加载MyTest27的时候也是从外部路径加载的。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h5><p>每个类都会使用自己的类加载器（即加载自身的类加载器）来去加载其他类（指的是所依赖的类），如果classX引用了classY，那么classX的定义类加载器就会去加载classY。</p><h4 id="线程上下文类加载器-1"><a href="#线程上下文类加载器-1" class="headerlink" title="线程上下文类加载器"></a><strong>线程上下文类加载器</strong></h4><p>线程上下文类加载器是从JDK1.2开始引入的类，Thread类中的<code>getContextClassLoader()</code>与<code>setContextClassLoader(ClassLoader cl)</code>分别用来获取和设置上下文类加载器。如果没有通过set方法进行设置的话，线程将继承其父线程的上下文类加载器。Java应用运行时的初始线程的上下文类加载器是AppClassLoader。在线程中运行的代码可以通过该类加载器来加载类与资源。<br>线程上下文类加载器的重要性：在SPI（Service Provider Interface）机制下，ServiceLoader是由Bootstrap类加载器加载的，但是外包部导入的包是由AppClassLoader加载的。按照我们刚才的验证知道，这样其实是不可能的，因为在Bootstrap类加载器中根本无法看见当前类路径下的jar包。解决这个问题的就是线程上下文类加载器。<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest28</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServiceLoader&lt;Driver&gt; loader = ServiceLoader.load(Driver.class);</span><br><span class="line">        Iterator&lt;Driver&gt; iterator = loader.iterator();</span><br><span class="line">        <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">            Driver next = iterator.next();</span><br><span class="line">            System.out.println(<span class="string">"driver: "</span> + next + <span class="string">", loader"</span> </span><br><span class="line">                               + next.getClass().getClassLoader());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"ServiceLoader类加载器: "</span> + ServiceLoader.class.getClassLoader());</span><br><span class="line">        System.out.println(<span class="string">"当前类加载器："</span> + Thread.currentThread().getContextClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">driver: com.mysql.jdbc.Driver@5e481248, loadersun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">driver: com.mysql.fabric.jdbc.FabricMySQLDriver@66d3c617, loadersun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">ServiceLoader类加载器: null</span></span><br><span class="line"><span class="comment">当前类加载器：sun.misc.Launcher$AppClassLoader@18b4aac2</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p></p><p><strong>跟踪分析</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service)</span> </span>&#123;</span><br><span class="line">    ClassLoader cl = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="comment">// 传入当前线程类加载器</span></span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; <span class="function">ServiceLoader&lt;S&gt; <span class="title">load</span><span class="params">(Class&lt;S&gt; service, ClassLoader loader)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ServiceLoader&lt;&gt;(service, loader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The class loader used to locate, load, and instantiate providers</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ClassLoader loader;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> </span>&#123;</span><br><span class="line">    service = Objects.requireNonNull(svc, <span class="string">"Service interface cannot be null"</span>);</span><br><span class="line">    loader = (cl == <span class="keyword">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">    acc = (System.getSecurityManager() != <span class="keyword">null</span>) ? AccessController.getContext() : <span class="keyword">null</span>;</span><br><span class="line">    reload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hasNext的源码省略…其目的是确定<code>META-INF/services</code>中的文件的全限定名。下面是next代码：<br></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> S <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (acc == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> nextService();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PrivilegedAction&lt;S&gt; action = <span class="keyword">new</span> PrivilegedAction&lt;S&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> S <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> nextService(); &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">return</span> AccessController.doPrivileged(action, acc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> S <span class="title">nextService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    String cn = nextName;</span><br><span class="line">    nextName = <span class="keyword">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在这里便是使用之前从线程获得类加载器进行类的加载</span></span><br><span class="line">        c = Class.forName(cn, <span class="keyword">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service, <span class="string">"Provider "</span> + cn + <span class="string">" not found"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service, <span class="string">"Provider "</span> + cn  + <span class="string">" not a subtype"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        S p = service.cast(c.newInstance());</span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service, <span class="string">"Provider "</span> + cn + <span class="string">" could not be instantiated"</span>, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p></div><div><div><div style="text-align:center;color:#ccc;font-size:14px;margin-top:30px">如果您有好的建议，欢迎在评论区或DaoVoice与我联系</div></div></div><div><div style="padding:10px 0;margin:20px auto;width:90%;text-align:center"><div></div><button id="rewardButton" disable="enable" onclick='var e=document.getElementById("QR");"none"===e.style.display?e.style.display="block":e.style.display="none"'><span>打赏</span></button><div id="QR" style="display:none"><div id="wechat" style="display:inline-block"><img id="wechat_qr" src="/images/weichatpay.png" alt="ISJINHAO 微信支付"><p>微信支付</p></div><div id="alipay" style="display:inline-block"><img id="alipay_qr" src="/images/alipay.jpg" alt="ISJINHAO 支付宝"><p>支付宝</p></div></div></div></div><footer class="post-footer"><div class="post-tags"><a href="/tags/Java/" rel="tag"># Java</a> <a href="/tags/JVM/" rel="tag"># JVM</a></div><div class="post-nav"><div class="post-nav-next post-nav-item"><a href="/posts/20964.html/" rel="next" title="03.02-JVM-字节码"><i class="fa fa-chevron-left"></i> 03.02-JVM-字节码</a></div><span class="post-nav-divider"></span><div class="post-nav-prev post-nav-item"></div></div></footer></div></article></div></div><div class="comments" id="gitalk-container"></div></div><div class="sidebar-toggle"><div class="sidebar-toggle-line-wrap"><span class="sidebar-toggle-line sidebar-toggle-line-first"></span> <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span> <span class="sidebar-toggle-line sidebar-toggle-line-last"></span></div></div><aside id="sidebar" class="sidebar"><div class="sidebar-inner"><ul class="sidebar-nav motion-element"><li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">文章目录</li><li class="sidebar-nav-overview" data-target="site-overview-wrap">站点概览</li></ul><div class="site-overview-wrap sidebar-panel"><div class="site-overview"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" src="/images/avatar.gif" alt="ISJINHAO"><p class="site-author-name" itemprop="name">ISJINHAO</p><p class="site-description motion-element" itemprop="description">Living & Working</p></div><nav class="site-state motion-element"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">41</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/index.html"><span class="site-state-item-count">7</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/index.html"><span class="site-state-item-count">14</span> <span class="site-state-item-name">标签</span></a></div></nav><div class="feed-link motion-element"><a href="/atom.xml" rel="alternate"><i class="fa fa-rss"></i> RSS</a></div><div class="links-of-author motion-element"><span class="links-of-author-item"><a href="https://github.com/isjinhao" title="GitHub &rarr; https://github.com/isjinhao" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a> </span><span class="links-of-author-item"><a href="mailto:isjinhao@163.com" title="E-Mail &rarr; mailto:isjinhao@163.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a></span></div></div></div><div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active"><div class="post-toc"><div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#类型的生命周期"><span class="nav-number">1.</span> <span class="nav-text">类型的生命周期</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#生命周期"><span class="nav-number">1.1.</span> <span class="nav-text">生命周期</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">1.2.</span> <span class="nav-text">初始化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#主动使用"><span class="nav-number">1.2.1.</span> <span class="nav-text">主动使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#被动使用"><span class="nav-number">1.2.2.</span> <span class="nav-text">被动使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#final"><span class="nav-number">1.2.3.</span> <span class="nav-text">final</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口"><span class="nav-number">1.2.4.</span> <span class="nav-text">接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类-接口"><span class="nav-number">1.2.5.</span> <span class="nav-text">类+接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#准备阶段和初始化的顺序"><span class="nav-number">1.2.6.</span> <span class="nav-text">准备阶段和初始化的顺序</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数组"><span class="nav-number">1.2.7.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类的实例化过程"><span class="nav-number">1.2.8.</span> <span class="nav-text">类的实例化过程</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#生命周期的几个时机"><span class="nav-number">1.3.</span> <span class="nav-text">生命周期的几个时机</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类加载器"><span class="nav-number">2.</span> <span class="nav-text">类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#ClassLoader"><span class="nav-number">2.1.</span> <span class="nav-text">ClassLoader</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#数组-1"><span class="nav-number">2.1.1.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委派机制"><span class="nav-number">2.1.2.</span> <span class="nav-text">双亲委派机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#自定义类加载器"><span class="nav-number">2.2.</span> <span class="nav-text">自定义类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#loadClass"><span class="nav-number">2.2.1.</span> <span class="nav-text">loadClass</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#findClass"><span class="nav-number">2.2.2.</span> <span class="nav-text">findClass</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#自定义一个类加载器"><span class="nav-number">2.2.3.</span> <span class="nav-text">自定义一个类加载器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类的卸载"><span class="nav-number">2.3.</span> <span class="nav-text">类的卸载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#命名空间解析"><span class="nav-number">2.4.</span> <span class="nav-text">命名空间解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#双亲委托机制的好处"><span class="nav-number">2.4.1.</span> <span class="nav-text">双亲委托机制的好处</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getSystemClassLoader"><span class="nav-number">2.5.</span> <span class="nav-text">getSystemClassLoader()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#指定SystemClassLoader"><span class="nav-number">2.6.</span> <span class="nav-text">指定SystemClassLoader</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#三个自带的类加载器初始化流程分析"><span class="nav-number">2.6.1.</span> <span class="nav-text">三个自带的类加载器初始化流程分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Class-forName"><span class="nav-number">2.7.</span> <span class="nav-text">Class.forName</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程上下文类加载器"><span class="nav-number">2.8.</span> <span class="nav-text">线程上下文类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#当前类加载器"><span class="nav-number">2.8.1.</span> <span class="nav-text">当前类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#总结"><span class="nav-number">2.8.1.1.</span> <span class="nav-text">总结</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#线程上下文类加载器-1"><span class="nav-number">2.8.2.</span> <span class="nav-text">线程上下文类加载器</span></a></li></ol></li></ol></li></ol></div></div></div></div></aside></div></main><footer id="footer" class="footer"><div class="footer-inner"><script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="copyright">&copy; <span itemprop="copyrightYear">2019</span> <span class="with-love" id="animate"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">ISJINHAO</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-area-chart"></i> </span><span title="站点总字数">670k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">10:09</span></div><div class="powered-by"><i class="fa fa-user-md"></i><span id="busuanzi_container_site_uv"> 本站访客数：<span id="busuanzi_value_site_uv"></span></span></div><div class="theme-info"><div class="powered-by"></div><span class="post-count">| 博客全站共246.2k字</span></div></div></footer><div class="back-to-top"><i class="fa fa-arrow-up"></i></div></div><script>"[object Function]"!==Object.prototype.toString.call(window.Promise)&&(window.Promise=null)</script><script src="/lib/jquery/index.js?v=2.1.3"></script><script src="/lib/velocity/velocity.min.js?v=1.2.1"></script><script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script><script src="/js/src/utils.js?v=6.7.0"></script><script src="/js/src/motion.js?v=6.7.0"></script><script src="/js/src/schemes/muse.js?v=6.7.0"></script><script src="/js/src/scrollspy.js?v=6.7.0"></script><script src="/js/src/post-details.js?v=6.7.0"></script><script src="/js/src/bootstrap.js?v=6.7.0"></script><script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css"><script src="//cdn.jsdelivr.net/npm/js-md5@0.7.3/src/md5.min.js"></script><script>var gitalk=new Gitalk({clientID:"cf0688d8364fa36ac889",clientSecret:"d9ae8a6b41055b558363130d6e6e7f7e78e2b7b8",repo:"isjinhao.github.io",owner:"isjinhao",admin:["isjinhao"],id:md5(location.pathname),distractionFreeMode:"true"});gitalk.render("gitalk-container")</script><script>function proceedsearch(){$("body").append('<div class="search-popup-overlay local-search-pop-overlay"></div>').css("overflow","hidden"),$(".search-popup-overlay").click(onPopupClose),$(".popup").toggle();var e=$("#local-search-input");e.attr("autocapitalize","none"),e.attr("autocorrect","off"),e.focus()}var isfetched=!1,isXml=!0,search_path="search.xml";0===search_path.length?search_path="search.xml":/json$/i.test(search_path)&&(isXml=!1);var path="/"+search_path,onPopupClose=function(e){$(".popup").hide(),$("#local-search-input").val(""),$(".search-result-list").remove(),$("#no-result").remove(),$(".local-search-pop-overlay").remove(),$("body").css("overflow","")},searchFunc=function(e,t,o){"use strict";$("body").append('<div class="search-popup-overlay local-search-pop-overlay"><div id="search-loading-icon"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div>').css("overflow","hidden"),$("#search-loading-icon").css("margin","20% auto 0 auto").css("text-align","center"),$.ajax({url:e,dataType:isXml?"xml":"json",async:!0,success:function(e){isfetched=!0,$(".popup").detach().appendTo(".header-inner");var n=isXml?$("entry",e).map(function(){return{title:$("title",this).text(),content:$("content",this).text(),url:$("url",this).text()}}).get():e,r=document.getElementById(t),s=document.getElementById(o),a=function(){var e=r.value.trim().toLowerCase(),t=e.split(/[\s\-]+/);t.length>1&&t.push(e);var o=[];if(e.length>0&&n.forEach(function(n){function r(t,o,n,r){for(var s=r[r.length-1],a=s.position,i=s.word,l=[],h=0;a+i.length<=n&&0!=r.length;){i===e&&h++,l.push({position:a,length:i.length});var p=a+i.length;for(r.pop();0!=r.length&&(s=r[r.length-1],a=s.position,i=s.word,p>a);)r.pop()}return c+=h,{hits:l,start:o,end:n,searchTextCount:h}}function s(e,t){var o="",n=t.start;return t.hits.forEach(function(t){o+=e.substring(n,t.position);var r=t.position+t.length;o+='<b class="search-keyword">'+e.substring(t.position,r)+"</b>",n=r}),o+=e.substring(n,t.end)}var a=!1,i=0,c=0,l=n.title.trim(),h=l.toLowerCase(),p=n.content.trim().replace(/<[^>]+>/g,""),u=p.toLowerCase(),f=decodeURIComponent(n.url).replace(/\/{2,}/g,"/"),d=[],g=[];if(""!=l&&(t.forEach(function(e){function t(e,t,o){var n=e.length;if(0===n)return[];var r=0,s=[],a=[];for(o||(t=t.toLowerCase(),e=e.toLowerCase());(s=t.indexOf(e,r))>-1;)a.push({position:s,word:e}),r=s+n;return a}d=d.concat(t(e,h,!1)),g=g.concat(t(e,u,!1))}),(d.length>0||g.length>0)&&(a=!0,i=d.length+g.length)),a){[d,g].forEach(function(e){e.sort(function(e,t){return t.position!==e.position?t.position-e.position:e.word.length-t.word.length})});var v=[];0!=d.length&&v.push(r(l,0,l.length,d));for(var $=[];0!=g.length;){var C=g[g.length-1],m=C.position,x=C.word,w=m-20,y=m+80;0>w&&(w=0),y<m+x.length&&(y=m+x.length),y>p.length&&(y=p.length),$.push(r(p,w,y,g))}$.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hits.length!==t.hits.length?t.hits.length-e.hits.length:e.start-t.start});var T=parseInt("1");T>=0&&($=$.slice(0,T));var b="";b+=0!=v.length?"<li><a href='"+f+"' class='search-result-title'>"+s(l,v[0])+"</a>":"<li><a href='"+f+"' class='search-result-title'>"+l+"</a>",$.forEach(function(e){b+="<a href='"+f+'\'><p class="search-result">'+s(p,e)+"...</p></a>"}),b+="</li>",o.push({item:b,searchTextCount:c,hitCount:i,id:o.length})}}),1===t.length&&""===t[0])s.innerHTML='<div id="no-result"><i class="fa fa-search fa-5x"></i></div>';else if(0===o.length)s.innerHTML='<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>';else{o.sort(function(e,t){return e.searchTextCount!==t.searchTextCount?t.searchTextCount-e.searchTextCount:e.hitCount!==t.hitCount?t.hitCount-e.hitCount:t.id-e.id});var a='<ul class="search-result-list">';o.forEach(function(e){a+=e.item}),a+="</ul>",s.innerHTML=a}};r.addEventListener("input",a),$(".local-search-pop-overlay").remove(),$("body").css("overflow",""),proceedsearch()}})};$(".popup-trigger").click(function(e){e.stopPropagation(),isfetched===!1?searchFunc(path,"local-search-input","local-search-result"):proceedsearch()}),$(".popup-btn-close").click(onPopupClose),$(".popup").click(function(e){e.stopPropagation()}),$(document).on("keyup",function(e){var t=27===e.which&&$(".search-popup").is(":visible");t&&onPopupClose()})</script><link rel="stylesheet" href="/lib/algolia-instant-search/instantsearch.min.css"><script src="/lib/algolia-instant-search/instantsearch.min.js"></script><script src="/js/src/algolia-search.js?v=6.7.0"></script><script>!function(){var t=document.createElement("script"),s=window.location.protocol.split(":")[0];"https"===s?t.src="https://zz.bdstatic.com/linksubmit/push.js":t.src="http://push.zhanzhang.baidu.com/push.js";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(t,e)}()</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      
      equationNumbers: {
        autoNumber: "AMS"
      }
    }
  });</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
      for (i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });</script><script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><style>.MathJax_Display{overflow:auto hidden}</style></body></html><!-- rebuild by neat -->